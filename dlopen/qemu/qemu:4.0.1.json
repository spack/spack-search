{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/dtc/tests/asm_tree_dump.c": "/*\n * libfdt - Flat Device Tree manipulation\n *\tTests if an asm tree built into a shared object matches a given dtb\n * Copyright (C) 2008 David Gibson, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n#include <dlfcn.h>\n\n#include <libfdt.h>\n\n#include \"tests.h\"\n#include \"testdata.h\"\n\nint main(int argc, char *argv[])\n{\n\tvoid *sohandle;\n\tvoid *fdt;\n\tint err;\n\n\ttest_init(argc, argv);\n\tif (argc != 3)\n\t\tCONFIG(\"Usage: %s <so file> <dtb file>\", argv[0]);\n\n\tsohandle = dlopen(argv[1], RTLD_NOW);\n\tif (!sohandle)\n\t\tFAIL(\"Couldn't dlopen() %s\", argv[1]);\n\n\tfdt = dlsym(sohandle, \"dt_blob_start\");\n\tif (!fdt)\n\t\tFAIL(\"Couldn't locate \\\"dt_blob_start\\\" symbol in %s\",\n\t\t     argv[1]);\n\n\terr = fdt_check_header(fdt);\n\tif (err != 0)\n\t\tFAIL(\"%s contains invalid tree: %s\", argv[1],\n\t\t     fdt_strerror(err));\n\n\tsave_blob(argv[2], fdt);\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/dtc/tests/value-labels.c": "/*\n * libfdt - Flat Device Tree manipulation\n *\tTest labels within values\n * Copyright (C) 2008 David Gibson, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n#include <dlfcn.h>\n\n#include <libfdt.h>\n\n#include \"tests.h\"\n#include \"testdata.h\"\n\nstruct val_label {\n\tconst char *labelname;\n\tint propoff;\n};\n\nstatic struct val_label labels1[] = {\n\t{ \"start1\", 0 },\n\t{ \"mid1\", 2 },\n\t{ \"end1\", -1 },\n};\n\nstatic struct val_label labels2[] = {\n\t{ \"start2\", 0 },\n\t{ \"innerstart2\", 0 },\n\t{ \"innermid2\", 4 },\n\t{ \"innerend2\", -1 },\n\t{ \"end2\", -1 },\n};\n\nstatic struct val_label labels3[] = {\n\t{ \"start3\", 0 },\n\t{ \"innerstart3\", 0 },\n\t{ \"innermid3\", 1 },\n\t{ \"innerend3\", -1 },\n\t{ \"end3\", -1 },\n};\n\nstatic void check_prop_labels(void *sohandle, void *fdt, const char *name,\n\t\t\t      const struct val_label* labels, int n)\n{\n\tconst struct fdt_property *prop;\n\tconst char *p;\n\tint len;\n\tint i;\n\n\tprop = fdt_get_property(fdt, 0, name, &len);\n\tif (!prop)\n\t\tFAIL(\"Couldn't locate property \\\"%s\\\"\", name);\n\n\tp = dlsym(sohandle, name);\n\tif (!p)\n\t\tFAIL(\"Couldn't locate label symbol \\\"%s\\\"\", name);\n\n\tif (p != (const char *)prop)\n\t\tFAIL(\"Label \\\"%s\\\" does not point to correct property\", name);\n\n\tfor (i = 0; i < n; i++) {\n\t\tint off = labels[i].propoff;\n\n\t\tif (off == -1)\n\t\t\toff = len;\n\n\t\tp = dlsym(sohandle, labels[i].labelname);\n\t\tif (!p)\n\t\t\tFAIL(\"Couldn't locate label symbol \\\"%s\\\"\", name);\n\n\t\tif ((p - prop->data) != off)\n\t\t\tFAIL(\"Label \\\"%s\\\" points to offset %ld instead of %d\"\n\t\t\t     \"in property \\\"%s\\\"\", labels[i].labelname,\n\t\t\t     (long)(p - prop->data), off, name);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tvoid *sohandle;\n\tvoid *fdt;\n\tint err;\n\n\ttest_init(argc, argv);\n\tif (argc != 2)\n\t\tCONFIG(\"Usage: %s <so file>\", argv[0]);\n\n\tsohandle = dlopen(argv[1], RTLD_NOW);\n\tif (!sohandle)\n\t\tFAIL(\"Couldn't dlopen() %s\", argv[1]);\n\n\tfdt = dlsym(sohandle, \"dt_blob_start\");\n\tif (!fdt)\n\t\tFAIL(\"Couldn't locate \\\"dt_blob_start\\\" symbol in %s\",\n\t\t     argv[1]);\n\n\terr = fdt_check_header(fdt);\n\tif (err != 0)\n\t\tFAIL(\"%s contains invalid tree: %s\", argv[1],\n\t\t     fdt_strerror(err));\n\n\n\tcheck_prop_labels(sohandle, fdt, \"prop1\", labels1, ARRAY_SIZE(labels1));\n\tcheck_prop_labels(sohandle, fdt, \"prop2\", labels2, ARRAY_SIZE(labels2));\n\tcheck_prop_labels(sohandle, fdt, \"prop3\", labels3, ARRAY_SIZE(labels3));\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Ia32/pyconfig.h": "/** @file\n    Manually generated Python Configuration file for EDK II.\n\n    Copyright (c) 2011 - 2016, Intel Corporation. All rights reserved.<BR>\n    This program and the accompanying materials are licensed and made available under\n    the terms and conditions of the BSD License that accompanies this distribution.\n    The full text of the license may be found at\n    http://opensource.org/licenses/bsd-license.\n\n    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n**/\n#ifndef Py_PYCONFIG_H\n#define Py_PYCONFIG_H\n\n#include  <Uefi.h>\n\n#define PLATFORM    \"uefi\"\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want\n   support for AIX C++ shared extension modules. */\n#undef AIX_GENUINE_CPLUSPLUS\n\n/* Define this if you have AtheOS threads. */\n#undef ATHEOS_THREADS\n\n/* Define this if you have BeOS threads. */\n#undef BEOS_THREADS\n\n/* Define if you have the Mach cthreads package */\n#undef C_THREADS\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM\n   mixed-endian order (byte order 45670123) */\n#undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most\n   significant byte first */\n#undef DOUBLE_IS_BIG_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the\n   least significant byte first */\n#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n\n/* Define if --enable-ipv6 is specified */\n#undef ENABLE_IPV6\n\n/* Define if flock needs to be linked with bsd library. */\n#undef FLOCK_NEEDS_LIBBSD\n\n/* Define if getpgrp() must be called as getpgrp(0). */\n#undef GETPGRP_HAVE_ARG\n\n/* Define if gettimeofday() does not have second (timezone) argument This is\n   the case on Motorola V4 (R40V4.2) */\n#undef GETTIMEOFDAY_NO_TZ\n\n/* Define to 1 if you have the 'acosh' function. */\n#undef HAVE_ACOSH\n\n/* struct addrinfo (netdb.h) */\n#undef HAVE_ADDRINFO\n\n/* Define to 1 if you have the 'alarm' function. */\n#undef HAVE_ALARM\n\n/* Define this if your time.h defines altzone. */\n#undef HAVE_ALTZONE\n\n/* Define to 1 if you have the 'asinh' function. */\n#undef HAVE_ASINH\n\n/* Define to 1 if you have the <asm/types.h> header file. */\n#undef HAVE_ASM_TYPES_H\n\n/* Define to 1 if you have the 'atanh' function. */\n#undef HAVE_ATANH\n\n/* Define if GCC supports __attribute__((format(PyArg_ParseTuple, 2, 3))) */\n#undef HAVE_ATTRIBUTE_FORMAT_PARSETUPLE\n\n/* Define to 1 if you have the 'bind_textdomain_codeset' function. */\n#undef HAVE_BIND_TEXTDOMAIN_CODESET\n\n/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_BLUETOOTH_H\n\n/* Define to 1 if you have the <bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_H\n\n/* Define if nice() returns success/failure instead of the new priority. */\n#undef HAVE_BROKEN_NICE\n\n/* Define if the system reports an invalid PIPE_BUF value. */\n#undef HAVE_BROKEN_PIPE_BUF\n\n/* Define if poll() sets errno on invalid file descriptors. */\n#undef HAVE_BROKEN_POLL\n\n/* Define if the Posix semaphores do not work on your system */\n#define HAVE_BROKEN_POSIX_SEMAPHORES  1\n\n/* Define if pthread_sigmask() does not work on your system. */\n#define HAVE_BROKEN_PTHREAD_SIGMASK   1\n\n/* define to 1 if your sem_getvalue is broken. */\n#define HAVE_BROKEN_SEM_GETVALUE      1\n\n/* Define this if you have the type _Bool. */\n#define HAVE_C99_BOOL                 1\n\n/* Define to 1 if you have the 'chflags' function. */\n#undef HAVE_CHFLAGS\n\n/* Define to 1 if you have the 'chown' function. */\n#undef HAVE_CHOWN\n\n/* Define if you have the 'chroot' function. */\n#undef HAVE_CHROOT\n\n/* Define to 1 if you have the 'clock' function. */\n#define HAVE_CLOCK                    1\n\n/* Define to 1 if you have the 'confstr' function. */\n#undef HAVE_CONFSTR\n\n/* Define to 1 if you have the <conio.h> header file. */\n#undef HAVE_CONIO_H\n\n/* Define to 1 if you have the 'copysign' function. */\n#undef HAVE_COPYSIGN\n\n/* Define to 1 if you have the 'ctermid' function. */\n#undef HAVE_CTERMID\n\n/* Define if you have the 'ctermid_r' function. */\n#undef HAVE_CTERMID_R\n\n/* Define to 1 if you have the <curses.h> header file. */\n#undef HAVE_CURSES_H\n\n/* Define if you have the 'is_term_resized' function. */\n#undef HAVE_CURSES_IS_TERM_RESIZED\n\n/* Define if you have the 'resizeterm' function. */\n#undef HAVE_CURSES_RESIZETERM\n\n/* Define if you have the 'resize_term' function. */\n#undef HAVE_CURSES_RESIZE_TERM\n\n/* Define to 1 if you have the declaration of 'isfinite', and to 0 if you\n   don't. */\n#define HAVE_DECL_ISFINITE    0\n\n/* Define to 1 if you have the declaration of 'isinf', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISINF       1\n\n/* Define to 1 if you have the declaration of 'isnan', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISNAN       1\n\n/* Define to 1 if you have the declaration of 'tzname', and to 0 if you don't.\n   */\n#define HAVE_DECL_TZNAME      0\n\n/* Define to 1 if you have the device macros. */\n#undef HAVE_DEVICE_MACROS\n\n/* Define if we have /dev/ptc. */\n#undef HAVE_DEV_PTC\n\n/* Define if we have /dev/ptmx. */\n#undef HAVE_DEV_PTMX\n\n/* Define to 1 if you have the <direct.h> header file. */\n#undef HAVE_DIRECT_H\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.\n   */\n#define HAVE_DIRENT_H   1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the 'dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the 'dup2' function. */\n#define HAVE_DUP2       1\n\n/* Defined when any dynamic module loading is enabled. */\n#undef HAVE_DYNAMIC_LOADING\n\n/* Define if you have the 'epoll' functions. */\n#undef HAVE_EPOLL\n\n/* Define to 1 if you have the 'erf' function. */\n#undef HAVE_ERF\n\n/* Define to 1 if you have the 'erfc' function. */\n#undef HAVE_ERFC\n\n/* Define to 1 if you have the <errno.h> header file. */\n#define HAVE_ERRNO_H    1\n\n/* Define to 1 if you have the 'execv' function. */\n#undef HAVE_EXECV\n\n/* Define to 1 if you have the 'expm1' function. */\n#undef HAVE_EXPM1\n\n/* Define if you have the 'fchdir' function. */\n#undef HAVE_FCHDIR\n\n/* Define to 1 if you have the 'fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the 'fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H    1\n\n/* Define if you have the 'fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the 'finite' function. */\n#define HAVE_FINITE     1\n\n/* Define to 1 if you have the 'flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the 'fork' function. */\n#undef HAVE_FORK\n\n/* Define to 1 if you have the 'forkpty' function. */\n#undef HAVE_FORKPTY\n\n/* Define to 1 if you have the 'fpathconf' function. */\n#undef HAVE_FPATHCONF\n\n/* Define to 1 if you have the 'fseek64' function. */\n#undef HAVE_FSEEK64\n\n/* Define to 1 if you have the 'fseeko' function. */\n#define HAVE_FSEEKO     1\n\n/* Define to 1 if you have the 'fstatvfs' function. */\n#undef HAVE_FSTATVFS\n\n/* Define if you have the 'fsync' function. */\n#undef HAVE_FSYNC\n\n/* Define to 1 if you have the 'ftell64' function. */\n#undef HAVE_FTELL64\n\n/* Define to 1 if you have the 'ftello' function. */\n#define HAVE_FTELLO     1\n\n/* Define to 1 if you have the 'ftime' function. */\n#undef HAVE_FTIME\n\n/* Define to 1 if you have the 'ftruncate' function. */\n#undef HAVE_FTRUNCATE\n\n/* Define to 1 if you have the 'gai_strerror' function. */\n#undef HAVE_GAI_STRERROR\n\n/* Define to 1 if you have the 'gamma' function. */\n#undef HAVE_GAMMA\n\n/* Define if we can use gcc inline assembler to get and set x87 control word\n*/\n#if defined(__GNUC__)\n  #define HAVE_GCC_ASM_FOR_X87  1\n#else\n  #undef HAVE_GCC_ASM_FOR_X87\n#endif\n\n/* Define if you have the getaddrinfo function. */\n#undef HAVE_GETADDRINFO\n\n/* Define to 1 if you have the 'getcwd' function. */\n#define HAVE_GETCWD   1\n\n/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */\n#undef HAVE_GETC_UNLOCKED\n\n/* Define to 1 if you have the 'getgroups' function. */\n#undef HAVE_GETGROUPS\n\n/* Define to 1 if you have the 'gethostbyname' function. */\n#undef HAVE_GETHOSTBYNAME\n\n/* Define this if you have some version of gethostbyname_r() */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define this if you have the 3-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_3_ARG\n\n/* Define this if you have the 5-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_5_ARG\n\n/* Define this if you have the 6-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_6_ARG\n\n/* Define to 1 if you have the 'getitimer' function. */\n#undef HAVE_GETITIMER\n\n/* Define to 1 if you have the 'getloadavg' function. */\n#undef HAVE_GETLOADAVG\n\n/* Define to 1 if you have the 'getlogin' function. */\n#undef HAVE_GETLOGIN\n\n/* Define to 1 if you have the 'getnameinfo' function. */\n#undef HAVE_GETNAMEINFO\n\n/* Define if you have the 'getpagesize' function. */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the 'getpeername' function. */\n#define HAVE_GETPEERNAME  1\n\n/* Define to 1 if you have the 'getpgid' function. */\n#undef HAVE_GETPGID\n\n/* Define to 1 if you have the 'getpgrp' function. */\n#undef HAVE_GETPGRP\n\n/* Define to 1 if you have the 'getpid' function. */\n#undef HAVE_GETPID\n\n/* Define to 1 if you have the 'getpriority' function. */\n#undef HAVE_GETPRIORITY\n\n/* Define to 1 if you have the 'getpwent' function. */\n#undef HAVE_GETPWENT\n\n/* Define to 1 if you have the 'getresgid' function. */\n#undef HAVE_GETRESGID\n\n/* Define to 1 if you have the 'getresuid' function. */\n#undef HAVE_GETRESUID\n\n/* Define to 1 if you have the 'getsid' function. */\n#undef HAVE_GETSID\n\n/* Define to 1 if you have the 'getspent' function. */\n#undef HAVE_GETSPENT\n\n/* Define to 1 if you have the 'getspnam' function. */\n#undef HAVE_GETSPNAM\n\n/* Define to 1 if you have the 'gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the 'getwd' function. */\n#undef HAVE_GETWD\n\n/* Define to 1 if you have the <grp.h> header file. */\n#undef HAVE_GRP_H\n\n/* Define if you have the 'hstrerror' function. */\n#undef HAVE_HSTRERROR\n\n/* Define to 1 if you have the 'hypot' function. */\n#undef HAVE_HYPOT\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define if you have the 'inet_aton' function. */\n#define HAVE_INET_ATON    1\n\n/* Define if you have the 'inet_pton' function. */\n#define HAVE_INET_PTON    1\n\n/* Define to 1 if you have the 'initgroups' function. */\n#undef HAVE_INITGROUPS\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H   1\n\n/* Define to 1 if you have the <io.h> header file. */\n#undef HAVE_IO_H\n\n/* Define to 1 if you have the 'kill' function. */\n#undef HAVE_KILL\n\n/* Define to 1 if you have the 'killpg' function. */\n#undef HAVE_KILLPG\n\n/* Define if you have the 'kqueue' functions. */\n#undef HAVE_KQUEUE\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H   /* non-functional in EFI. */\n\n/* Defined to enable large file support when an off_t is bigger than a long\n   and long long is available and at least as big as an off_t. You may need to\n   add some flags for configuration and compilation to enable this mode. (For\n   Solaris and Linux, the necessary defines are already defined.) */\n#undef HAVE_LARGEFILE_SUPPORT\n\n/* Define to 1 if you have the 'lchflags' function. */\n#undef HAVE_LCHFLAGS\n\n/* Define to 1 if you have the 'lchmod' function. */\n#undef HAVE_LCHMOD\n\n/* Define to 1 if you have the 'lchown' function. */\n#undef HAVE_LCHOWN\n\n/* Define to 1 if you have the 'lgamma' function. */\n#undef HAVE_LGAMMA\n\n/* Define to 1 if you have the 'dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the 'dld' library (-ldld). */\n#undef HAVE_LIBDLD\n\n/* Define to 1 if you have the 'ieee' library (-lieee). */\n#undef HAVE_LIBIEEE\n\n/* Define to 1 if you have the <libintl.h> header file. */\n#undef HAVE_LIBINTL_H\n\n/* Define if you have the readline library (-lreadline). */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the 'resolv' library (-lresolv). */\n#undef HAVE_LIBRESOLV\n\n/* Define to 1 if you have the <libutil.h> header file. */\n#undef HAVE_LIBUTIL_H\n\n/* Define if you have the 'link' function. */\n#undef HAVE_LINK\n\n/* Define to 1 if you have the <linux/netlink.h> header file. */\n#undef HAVE_LINUX_NETLINK_H\n\n/* Define to 1 if you have the <linux/tipc.h> header file. */\n#undef HAVE_LINUX_TIPC_H\n\n/* Define to 1 if you have the 'log1p' function. */\n#undef HAVE_LOG1P\n\n/* Define this if you have the type long double. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define this if you have the type long long. */\n#define HAVE_LONG_LONG  1\n\n/* Define to 1 if you have the 'lstat' function. */\n#define HAVE_LSTAT      1\n\n/* Define this if you have the makedev macro. */\n#undef HAVE_MAKEDEV\n\n/* Define to 1 if you have the 'memmove' function. */\n#define HAVE_MEMMOVE    1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the 'mkfifo' function. */\n#undef HAVE_MKFIFO\n\n/* Define to 1 if you have the 'mknod' function. */\n#undef HAVE_MKNOD\n\n/* Define to 1 if you have the 'mktime' function. */\n#define HAVE_MKTIME     1\n\n/* Define to 1 if you have the 'mremap' function. */\n#undef HAVE_MREMAP\n\n/* Define to 1 if you have the <ncurses.h> header file. */\n#undef HAVE_NCURSES_H\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netpacket/packet.h> header file. */\n#undef HAVE_NETPACKET_PACKET_H\n\n/* Define to 1 if you have the 'nice' function. */\n#undef HAVE_NICE\n\n/* Define to 1 if you have the 'openpty' function. */\n#undef HAVE_OPENPTY\n\n/* Define if compiling using MacOS X 10.5 SDK or later. */\n#undef HAVE_OSX105_SDK\n\n/* Define to 1 if you have the 'pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if you have the 'pause' function. */\n#undef HAVE_PAUSE\n\n/* Define to 1 if you have the 'plock' function. */\n#undef HAVE_PLOCK\n\n/* Define to 1 if you have the 'poll' function. */\n#define HAVE_POLL         1\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the <process.h> header file. */\n#undef HAVE_PROCESS_H\n\n/* Define if your compiler supports function prototype */\n#define HAVE_PROTOTYPES   1\n\n/* Define if you have GNU PTH threads. */\n#undef HAVE_PTH\n\n/* Defined for Solaris 2.6 bug in pthread header. */\n#undef HAVE_PTHREAD_DESTRUCTOR\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#undef HAVE_PTHREAD_H\n\n/* Define to 1 if you have the 'pthread_init' function. */\n#undef HAVE_PTHREAD_INIT\n\n/* Define to 1 if you have the 'pthread_sigmask' function. */\n#undef HAVE_PTHREAD_SIGMASK\n\n/* Define to 1 if you have the <pty.h> header file. */\n#undef HAVE_PTY_H\n\n/* Define to 1 if you have the 'putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define to 1 if you have the 'readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the 'realpath' function. */\n#define HAVE_REALPATH   1\n\n/* Define if you have readline 2.1 */\n#undef HAVE_RL_CALLBACK\n\n/* Define if you can turn off readline's signal handling. */\n#undef HAVE_RL_CATCH_SIGNAL\n\n/* Define if you have readline 2.2 */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK\n\n/* Define if you have readline 4.2 */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define if you have rl_completion_suppress_append */\n#undef HAVE_RL_COMPLETION_SUPPRESS_APPEND\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_PRE_INPUT_HOOK\n\n/* Define to 1 if you have the 'round' function. */\n#undef HAVE_ROUND\n\n/* Define to 1 if you have the 'select' function. */\n#define HAVE_SELECT       1\n\n/* Define to 1 if you have the 'sem_getvalue' function. */\n#undef HAVE_SEM_GETVALUE\n\n/* Define to 1 if you have the 'sem_open' function. */\n#undef HAVE_SEM_OPEN\n\n/* Define to 1 if you have the 'sem_timedwait' function. */\n#undef HAVE_SEM_TIMEDWAIT\n\n/* Define to 1 if you have the 'sem_unlink' function. */\n#undef HAVE_SEM_UNLINK\n\n/* Define to 1 if you have the 'setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the 'seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the 'setgid' function. */\n#undef HAVE_SETGID\n\n/* Define if you have the 'setgroups' function. */\n#undef HAVE_SETGROUPS\n\n/* Define to 1 if you have the 'setitimer' function. */\n#undef HAVE_SETITIMER\n\n/* Define to 1 if you have the 'setlocale' function. */\n#define HAVE_SETLOCALE    1\n\n/* Define to 1 if you have the 'setpgid' function. */\n#undef HAVE_SETPGID\n\n/* Define to 1 if you have the 'setpgrp' function. */\n#undef HAVE_SETPGRP\n\n/* Define to 1 if you have the 'setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the 'setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the 'setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the 'setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the 'setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the 'setuid' function. */\n#undef HAVE_SETUID\n\n/* Define to 1 if you have the 'setvbuf' function. */\n#define HAVE_SETVBUF    1\n\n/* Define to 1 if you have the <shadow.h> header file. */\n#undef HAVE_SHADOW_H\n\n/* Define to 1 if you have the 'sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the 'siginterrupt' function. */\n#undef HAVE_SIGINTERRUPT\n\n/* Define to 1 if you have the <signal.h> header file. */\n#define HAVE_SIGNAL_H   1\n\n/* Define to 1 if you have the 'sigrelse' function. */\n#undef HAVE_SIGRELSE\n\n/* Define to 1 if you have the 'snprintf' function. */\n#define HAVE_SNPRINTF   1\n\n/* Define if sockaddr has sa_len member */\n#undef HAVE_SOCKADDR_SA_LEN\n\n/* struct sockaddr_storage (sys/socket.h) */\n#undef HAVE_SOCKADDR_STORAGE\n\n/* Define if you have the 'socketpair' function. */\n#undef HAVE_SOCKETPAIR\n\n/* Define to 1 if you have the <spawn.h> header file. */\n#undef HAVE_SPAWN_H\n\n/* Define if your compiler provides ssize_t */\n#define HAVE_SSIZE_T    1\n\n/* Define to 1 if you have the 'statvfs' function. */\n#undef HAVE_STATVFS\n\n/* Define if you have struct stat.st_mtim.tv_nsec */\n#undef HAVE_STAT_TV_NSEC\n\n/* Define if you have struct stat.st_mtimensec */\n#undef HAVE_STAT_TV_NSEC2\n\n/* Define if your compiler supports variable length function prototypes (e.g.\n   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */\n#define HAVE_STDARG_PROTOTYPES          1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H                   1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H                   1\n\n/* Define to 1 if you have the 'strdup' function. */\n#define HAVE_STRDUP                     1\n\n/* Define to 1 if you have the 'strftime' function. */\n#define HAVE_STRFTIME                   1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H                   1\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#undef HAVE_STROPTS_H\n\n/* Define to 1 if 'st_birthtime' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BIRTHTIME   1\n\n/* Define to 1 if 'st_blksize' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BLKSIZE     1\n\n/* Define to 1 if 'st_blocks' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_BLOCKS\n\n/* Define to 1 if 'st_flags' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_FLAGS\n\n/* Define to 1 if 'st_gen' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_GEN\n\n/* Define to 1 if 'st_rdev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_RDEV\n\n/* Define to 1 if 'tm_zone' is a member of 'struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if your 'struct stat' has 'st_blocks'. Deprecated, use\n   'HAVE_STRUCT_STAT_ST_BLOCKS' instead. */\n#undef HAVE_ST_BLOCKS\n\n/* Define if you have the 'symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the 'sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the <sysexits.h> header file. */\n#undef HAVE_SYSEXITS_H\n\n/* Define to 1 if you have the <sys/audioio.h> header file. */\n#undef HAVE_SYS_AUDIOIO_H\n\n/* Define to 1 if you have the <sys/bsdtty.h> header file. */\n#undef HAVE_SYS_BSDTTY_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/epoll.h> header file. */\n#undef HAVE_SYS_EPOLL_H\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n#undef HAVE_SYS_EVENT_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/loadavg.h> header file. */\n#undef HAVE_SYS_LOADAVG_H\n\n/* Define to 1 if you have the <sys/lock.h> header file. */\n#undef HAVE_SYS_LOCK_H\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n#undef HAVE_SYS_MKDEV_H\n\n/* Define to 1 if you have the <sys/modem.h> header file. */\n#undef HAVE_SYS_MODEM_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#define HAVE_SYS_PARAM_H                1\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#define HAVE_SYS_POLL_H                 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H             1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H               1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H               1\n\n/* Define to 1 if you have the <sys/statvfs.h> header file. */\n#undef HAVE_SYS_STATVFS_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H                 1\n\n/* Define to 1 if you have the <sys/termio.h> header file. */\n#undef HAVE_SYS_TERMIO_H\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n#undef HAVE_SYS_TIMES_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H                 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H                1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#undef HAVE_SYS_UTSNAME_H\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the system() command. */\n#define HAVE_SYSTEM       1\n\n/* Define to 1 if you have the 'tcgetpgrp' function. */\n#undef HAVE_TCGETPGRP\n\n/* Define to 1 if you have the 'tcsetpgrp' function. */\n#undef HAVE_TCSETPGRP\n\n/* Define to 1 if you have the 'tempnam' function. */\n#define HAVE_TEMPNAM                    1\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <term.h> header file. */\n#undef HAVE_TERM_H\n\n/* Define to 1 if you have the 'tgamma' function. */\n#undef HAVE_TGAMMA\n\n/* Define to 1 if you have the <thread.h> header file. */\n#undef HAVE_THREAD_H\n\n/* Define to 1 if you have the 'timegm' function. */\n#undef HAVE_TIMEGM\n\n/* Define to 1 if you have the 'times' function. */\n#undef HAVE_TIMES\n\n/* Define to 1 if you have the 'tmpfile' function. */\n#define HAVE_TMPFILE                    1\n\n/* Define to 1 if you have the 'tmpnam' function. */\n#define HAVE_TMPNAM                     1\n\n/* Define to 1 if you have the 'tmpnam_r' function. */\n#undef HAVE_TMPNAM_R\n\n/* Define to 1 if your 'struct tm' has 'tm_zone'. Deprecated, use\n   'HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the 'truncate' function. */\n#undef HAVE_TRUNCATE\n\n/* Define to 1 if you don't have 'tm_zone' but do have the external array\n   'tzname'. */\n#undef HAVE_TZNAME\n\n/* Define this if you have tcl and TCL_UTF_MAX==6 */\n#undef HAVE_UCS4_TCL\n\n/* Define to 1 if the system has the type 'uintptr_t'. */\n#define HAVE_UINTPTR_T                  1\n\n/* Define to 1 if you have the 'uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H                   1\n\n/* Define to 1 if you have the 'unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define if you have a useable wchar_t type defined in wchar.h; useable means\n   wchar_t must be an unsigned type with at least 16 bits. (see\n   Include/unicodeobject.h). */\n#define HAVE_USABLE_WCHAR_T             1\n\n/* Define to 1 if you have the <util.h> header file. */\n#undef HAVE_UTIL_H\n\n/* Define to 1 if you have the 'utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H    1\n\n/* Define to 1 if you have the 'wait3' function. */\n#undef HAVE_WAIT3\n\n/* Define to 1 if you have the 'wait4' function. */\n#undef HAVE_WAIT4\n\n/* Define to 1 if you have the 'waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define if the compiler provides a wchar.h header file. */\n#define HAVE_WCHAR_H    1\n\n/* Define to 1 if you have the 'wcscoll' function. */\n#define HAVE_WCSCOLL    1\n\n/* Define if tzset() actually switches the local timezone in a meaningful way.\n   */\n#undef HAVE_WORKING_TZSET\n\n/* Define if the zlib library has inflateCopy */\n#undef HAVE_ZLIB_COPY\n\n/* Define to 1 if you have the '_getpty' function. */\n#undef HAVE__GETPTY\n\n/* Define if you are using Mach cthreads directly under /include */\n#undef HURD_C_THREADS\n\n/* Define if you are using Mach cthreads under mach / */\n#undef MACH_C_THREADS\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in <mkdev.h>.\n   */\n#undef MAJOR_IN_MKDEV\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in\n   <sysmacros.h>. */\n#undef MAJOR_IN_SYSMACROS\n\n/* Define if mvwdelch in curses.h is an expression. */\n#undef MVWDELCH_IS_EXPRESSION\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT   \"edk2-devel@lists.01.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME    \"EDK II Python Package\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING  \"EDK II Python Package V0.8\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME   \"EADK_Python\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL   \"https://github.com/tianocore/edk2/tree/master/AppPkg/Applications/Python\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION  \"V0.8\"\n\n/* Define if POSIX semaphores aren't enabled on your system */\n#define POSIX_SEMAPHORES_NOT_ENABLED    1\n\n/* Defined if PTHREAD_SCOPE_SYSTEM supported. */\n#undef PTHREAD_SYSTEM_SCHED_SUPPORTED\n\n/* Define as the preferred size in bits of long digits */\n#undef PYLONG_BITS_IN_DIGIT\n\n/* Define to printf format modifier for long long type */\n#define PY_FORMAT_LONG_LONG   \"ll\"\n\n/* Define to printf format modifier for Py_ssize_t */\n#define PY_FORMAT_SIZE_T    \"z\"\n\n/* Define as the integral type used for Unicode representation. */\n#define PY_UNICODE_TYPE     wchar_t\n\n/* Define if you want to build an interpreter with many run-time checks. */\n#undef Py_DEBUG\n\n/* Defined if Python is built as a shared library. */\n#undef Py_ENABLE_SHARED\n\n/* Define as the size of the unicode type. */\n#define Py_UNICODE_SIZE   2\n\n/* Define if you want to have a Unicode type. */\n#define Py_USING_UNICODE\n\n/* assume C89 semantics that RETSIGTYPE is always void */\n#undef RETSIGTYPE\n\n/* Define if setpgrp() must be called as setpgrp(0, 0). */\n#undef SETPGRP_HAVE_ARG\n\n/* Define this to be extension of shared libraries (including the dot!). */\n#undef SHLIB_EXT\n\n/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */\n#undef SIGNED_RIGHT_SHIFT_ZERO_FILLS\n\n/* The size of 'double', as computed by sizeof. */\n#define SIZEOF_DOUBLE     8\n\n/* The size of 'float', as computed by sizeof. */\n#define SIZEOF_FLOAT      4\n\n/* The size of 'fpos_t', as computed by sizeof. */\n#define SIZEOF_FPOS_T     8\n\n/* The size of 'int', as computed by sizeof. */\n#define SIZEOF_INT        4\n\n/* The size of 'long', as computed by sizeof. */\n#define SIZEOF_LONG       4\n\n/* The size of 'long double', as computed by sizeof. */\n#undef SIZEOF_LONG_DOUBLE\n\n/* The size of 'long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG  8\n\n/* The size of 'off_t', as computed by sizeof. */\n#define SIZEOF_OFF_T      4\n\n/* The size of 'pid_t', as computed by sizeof. */\n#define SIZEOF_PID_T      4\n\n/* The size of 'pthread_t', as computed by sizeof. */\n#undef SIZEOF_PTHREAD_T\n\n/* The size of 'short', as computed by sizeof. */\n#define SIZEOF_SHORT      2\n\n/* The size of 'size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T     4\n\n/* The size of 'time_t', as computed by sizeof. */\n#define SIZEOF_TIME_T     4\n\n/* The size of 'uintptr_t', as computed by sizeof. */\n#define SIZEOF_UINTPTR_T  4\n\n/* The size of 'void *', as computed by sizeof. */\n#define SIZEOF_VOID_P     4\n\n/* The size of 'wchar_t', as computed by sizeof. */\n#define SIZEOF_WCHAR_T    2\n\n/* The size of '_Bool', as computed by sizeof. */\n#define SIZEOF__BOOL      1\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS      1\n\n/* Define if you can safely include both <sys/select.h> and <sys/time.h>\n   (which you can't on SCO ODT 3.0). */\n#undef SYS_SELECT_WITH_SYS_TIME\n\n/* Define if tanh(-0.) is -0., or if platform doesn't have signed zeros */\n#undef TANH_PRESERVES_ZERO_SIGN\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if your <sys/time.h> declares 'struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Enable extensions on AIX 3, Interix.  */\n#ifndef _ALL_SOURCE\n# undef _ALL_SOURCE\n#endif\n/* Enable GNU extensions on systems that have them.  */\n#ifndef _GNU_SOURCE\n# undef _GNU_SOURCE\n#endif\n/* Enable threading extensions on Solaris.  */\n#ifndef _POSIX_PTHREAD_SEMANTICS\n# undef _POSIX_PTHREAD_SEMANTICS\n#endif\n/* Enable extensions on HP NonStop.  */\n#ifndef _TANDEM_SOURCE\n# undef _TANDEM_SOURCE\n#endif\n/* Enable general extensions on Solaris.  */\n#ifndef __EXTENSIONS__\n# undef __EXTENSIONS__\n#endif\n\n\n/* Define if you want to use MacPython modules on MacOSX in unix-Python. */\n#undef USE_TOOLBOX_OBJECT_GLUE\n\n/* Define if a va_list is an array of some kind */\n#undef VA_LIST_IS_ARRAY\n\n/* Define if you want SIGFPE handled (see Include/pyfpe.h). */\n#undef WANT_SIGFPE_HANDLER\n\n/* Define if you want wctype.h functions to be used instead of the one\n   supplied by Python itself. (see Include/unicodectype.h). */\n#define WANT_WCTYPE_FUNCTIONS   1\n\n/* Define if WINDOW in curses.h offers a field _flags. */\n#undef WINDOW_HAS_FLAGS\n\n/* Define if you want documentation strings in extension modules */\n#undef WITH_DOC_STRINGS\n\n/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic\n   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).\n   Dyld is necessary to support frameworks. */\n#undef WITH_DYLD\n\n/* Define to 1 if libintl is needed for locale functions. */\n#undef WITH_LIBINTL\n\n/* Define if you want to produce an OpenStep/Rhapsody framework (shared\n   library plus accessory files). */\n#undef WITH_NEXT_FRAMEWORK\n\n/* Define if you want to compile in Python-specific mallocs */\n#undef WITH_PYMALLOC\n\n/* Define if you want to compile in rudimentary thread support */\n#undef WITH_THREAD\n\n/* Define to profile with the Pentium timestamp counter */\n#undef WITH_TSC\n\n/* Define if you want pymalloc to be disabled when running under valgrind */\n#undef WITH_VALGRIND\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define if arithmetic is subject to x87-style double rounding issue */\n#undef X87_DOUBLE_ROUNDING\n\n/* Define on OpenBSD to activate all library features */\n#undef _BSD_SOURCE\n\n/* Define on Irix to enable u_int */\n#undef _BSD_TYPES\n\n/* Define on Darwin to activate all library features */\n#undef _DARWIN_C_SOURCE\n\n/* This must be set to 64 on some systems to enable large file support. */\n#undef _FILE_OFFSET_BITS\n\n/* Define on Linux to activate all library features */\n#undef _GNU_SOURCE\n\n/* This must be defined on some systems to enable large file support. */\n#undef _LARGEFILE_SOURCE\n\n/* Define to 1 if on MINIX. */\n#undef _MINIX\n\n/* Define on NetBSD to activate all library features */\n#ifndef _NETBSD_SOURCE\n  #define _NETBSD_SOURCE  1\n#endif\n\n/* Define _OSF_SOURCE to get the makedev macro. */\n#undef _OSF_SOURCE\n\n/* Define to 2 if the system does not provide POSIX.1 features except with\n   this defined. */\n#undef _POSIX_1_SOURCE\n\n/* Define to activate features from IEEE Stds 1003.1-2001 */\n#undef _POSIX_C_SOURCE\n\n/* Define to 1 if you need to in order for 'stat' and other things to work. */\n#undef _POSIX_SOURCE\n\n/* Define if you have POSIX threads, and your system does not define that. */\n#undef _POSIX_THREADS\n\n/* Define to force use of thread-safe errno, h_errno, and other functions */\n#undef _REENTRANT\n\n/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT32_T\n\n/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT64_T\n\n/* Define to the level of X/Open that your system supports */\n#undef _XOPEN_SOURCE\n\n/* Define to activate Unix95-and-earlier features */\n#undef _XOPEN_SOURCE_EXTENDED\n\n/* Define on FreeBSD to activate all library features */\n#undef __BSD_VISIBLE\n\n/* Define to 1 if type 'char' is unsigned and you are not using gcc.  */\n#ifndef __CHAR_UNSIGNED__\n# undef __CHAR_UNSIGNED__\n#endif\n\n/* Defined on Solaris to see additional function prototypes. */\n#undef __EXTENSIONS__\n\n/* Define to 'long' if <time.h> doesn't define. */\n//#undef clock_t\n\n/* Define to empty if 'const' does not conform to ANSI C. */\n//#undef const\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef gid_t\n\n/* Define to the type of a signed integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int32_t\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int64_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef mode_t\n\n/* Define to 'long int' if <sys/types.h> does not define. */\n//#undef off_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef pid_t\n\n/* Define to empty if the keyword does not work. */\n//#undef signed\n\n/* Define to 'unsigned int' if <sys/types.h> does not define. */\n//#undef size_t\n\n/* Define to 'int' if <sys/socket.h> does not define. */\n//#undef socklen_t\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef uid_t\n\n/* Define to the type of an unsigned integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint32_t\n\n/* Define to the type of an unsigned integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint64_t\n\n/* Define to empty if the keyword does not work. */\n//#undef volatile\n\n#endif /*Py_PYCONFIG_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Ia32/pyconfig.h": "/** @file\n    Manually generated Python Configuration file for EDK II.\n\n    Copyright (c) 2015, Daryl McDaniel. All rights reserved.<BR>\n    Copyright (c) 2011 - 2016, Intel Corporation. All rights reserved.<BR>\n    This program and the accompanying materials are licensed and made available under\n    the terms and conditions of the BSD License that accompanies this distribution.\n    The full text of the license may be found at\n    http://opensource.org/licenses/bsd-license.\n\n    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n**/\n#ifndef Py_PYCONFIG_H\n#define Py_PYCONFIG_H\n\n#include  <Uefi.h>\n\n#define PLATFORM    \"uefi\"\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want\n   support for AIX C++ shared extension modules. */\n#undef AIX_GENUINE_CPLUSPLUS\n\n/* Define this if you have AtheOS threads. */\n#undef ATHEOS_THREADS\n\n/* Define this if you have BeOS threads. */\n#undef BEOS_THREADS\n\n/* Define if you have the Mach cthreads package */\n#undef C_THREADS\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM\n   mixed-endian order (byte order 45670123) */\n#undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most\n   significant byte first */\n#undef DOUBLE_IS_BIG_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the\n   least significant byte first */\n#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n\n/* Define if --enable-ipv6 is specified */\n#undef ENABLE_IPV6\n\n/* Define if flock needs to be linked with bsd library. */\n#undef FLOCK_NEEDS_LIBBSD\n\n/* Define if getpgrp() must be called as getpgrp(0). */\n#undef GETPGRP_HAVE_ARG\n\n/* Define if gettimeofday() does not have second (timezone) argument This is\n   the case on Motorola V4 (R40V4.2) */\n#undef GETTIMEOFDAY_NO_TZ\n\n/* Define to 1 if you have the 'acosh' function. */\n#undef HAVE_ACOSH\n\n/* struct addrinfo (netdb.h) */\n#undef HAVE_ADDRINFO\n\n/* Define to 1 if you have the 'alarm' function. */\n#undef HAVE_ALARM\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#undef HAVE_ALLOCA_H\n\n/* Define this if your time.h defines altzone. */\n#undef HAVE_ALTZONE\n\n/* Define to 1 if you have the 'asinh' function. */\n#undef HAVE_ASINH\n\n/* Define to 1 if you have the <asm/types.h> header file. */\n#undef HAVE_ASM_TYPES_H\n\n/* Define to 1 if you have the 'atanh' function. */\n#undef HAVE_ATANH\n\n/* Define if GCC supports __attribute__((format(PyArg_ParseTuple, 2, 3))) */\n#undef HAVE_ATTRIBUTE_FORMAT_PARSETUPLE\n\n/* Define to 1 if you have the 'bind_textdomain_codeset' function. */\n#undef HAVE_BIND_TEXTDOMAIN_CODESET\n\n/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_BLUETOOTH_H\n\n/* Define to 1 if you have the <bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_H\n\n/* Define if nice() returns success/failure instead of the new priority. */\n#undef HAVE_BROKEN_NICE\n\n/* Define if the system reports an invalid PIPE_BUF value. */\n#undef HAVE_BROKEN_PIPE_BUF\n\n/* Define if poll() sets errno on invalid file descriptors. */\n#undef HAVE_BROKEN_POLL\n\n/* Define if the Posix semaphores do not work on your system */\n#define HAVE_BROKEN_POSIX_SEMAPHORES  1\n\n/* Define if pthread_sigmask() does not work on your system. */\n#define HAVE_BROKEN_PTHREAD_SIGMASK   1\n\n/* define to 1 if your sem_getvalue is broken. */\n#define HAVE_BROKEN_SEM_GETVALUE      1\n\n/* Define if 'unsetenv' does not return an int. */\n#undef HAVE_BROKEN_UNSETENV\n\n/* Define this if you have the type _Bool. */\n#define HAVE_C99_BOOL                 1\n\n/* Define to 1 if you have the 'chflags' function. */\n#undef HAVE_CHFLAGS\n\n/* Define to 1 if you have the 'chown' function. */\n#undef HAVE_CHOWN\n\n/* Define if you have the 'chroot' function. */\n#undef HAVE_CHROOT\n\n/* Define to 1 if you have the 'clock' function. */\n#define HAVE_CLOCK                    1\n\n/* Define to 1 if you have the 'confstr' function. */\n#undef HAVE_CONFSTR\n\n/* Define to 1 if you have the <conio.h> header file. */\n#undef HAVE_CONIO_H\n\n/* Define to 1 if you have the 'copysign' function. */\n#undef HAVE_COPYSIGN\n\n/* Define to 1 if you have the 'ctermid' function. */\n#undef HAVE_CTERMID\n\n/* Define if you have the 'ctermid_r' function. */\n#undef HAVE_CTERMID_R\n\n/* Define to 1 if you have the <curses.h> header file. */\n#undef HAVE_CURSES_H\n\n/* Define if you have the 'is_term_resized' function. */\n#undef HAVE_CURSES_IS_TERM_RESIZED\n\n/* Define if you have the 'resizeterm' function. */\n#undef HAVE_CURSES_RESIZETERM\n\n/* Define if you have the 'resize_term' function. */\n#undef HAVE_CURSES_RESIZE_TERM\n\n/* Define to 1 if you have the declaration of 'isfinite', and to 0 if you\n   don't. */\n#define HAVE_DECL_ISFINITE    0\n\n/* Define to 1 if you have the declaration of 'isinf', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISINF       1\n\n/* Define to 1 if you have the declaration of 'isnan', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISNAN       1\n\n/* Define to 1 if you have the declaration of 'tzname', and to 0 if you don't.\n   */\n#define HAVE_DECL_TZNAME      0\n\n/* Define to 1 if you have the device macros. */\n#undef HAVE_DEVICE_MACROS\n\n/* Define to 1 if you have the /dev/ptc device file. */\n#undef HAVE_DEV_PTC\n\n/* Define to 1 if you have the /dev/ptmx device file. */\n#undef HAVE_DEV_PTMX\n\n/* Define to 1 if you have the <direct.h> header file. */\n#undef HAVE_DIRECT_H\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.\n   */\n#define HAVE_DIRENT_H   1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the 'dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the 'dup2' function. */\n#define HAVE_DUP2       1\n\n/* Defined when any dynamic module loading is enabled. */\n#undef HAVE_DYNAMIC_LOADING\n\n/* Define if you have the 'epoll' functions. */\n#undef HAVE_EPOLL\n\n/* Define to 1 if you have the 'erf' function. */\n#undef HAVE_ERF\n\n/* Define to 1 if you have the 'erfc' function. */\n#undef HAVE_ERFC\n\n/* Define to 1 if you have the <errno.h> header file. */\n#define HAVE_ERRNO_H    1\n\n/* Define to 1 if you have the 'execv' function. */\n#undef HAVE_EXECV\n\n/* Define to 1 if you have the 'expm1' function. */\n#undef HAVE_EXPM1\n\n/* Define if you have the 'fchdir' function. */\n#undef HAVE_FCHDIR\n\n/* Define to 1 if you have the 'fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the 'fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H    1\n\n/* Define if you have the 'fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the 'finite' function. */\n#define HAVE_FINITE     1\n\n/* Define to 1 if you have the 'flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the 'fork' function. */\n#undef HAVE_FORK\n\n/* Define to 1 if you have the 'forkpty' function. */\n#undef HAVE_FORKPTY\n\n/* Define to 1 if you have the 'fpathconf' function. */\n#undef HAVE_FPATHCONF\n\n/* Define to 1 if you have the 'fseek64' function. */\n#undef HAVE_FSEEK64\n\n/* Define to 1 if you have the 'fseeko' function. */\n#define HAVE_FSEEKO     1\n\n/* Define to 1 if you have the 'fstatvfs' function. */\n#undef HAVE_FSTATVFS\n\n/* Define if you have the 'fsync' function. */\n#undef HAVE_FSYNC\n\n/* Define to 1 if you have the 'ftell64' function. */\n#undef HAVE_FTELL64\n\n/* Define to 1 if you have the 'ftello' function. */\n#define HAVE_FTELLO     1\n\n/* Define to 1 if you have the 'ftime' function. */\n#undef HAVE_FTIME\n\n/* Define to 1 if you have the 'ftruncate' function. */\n#undef HAVE_FTRUNCATE\n\n/* Define to 1 if you have the 'gai_strerror' function. */\n#undef HAVE_GAI_STRERROR\n\n/* Define to 1 if you have the 'gamma' function. */\n#undef HAVE_GAMMA\n\n/* Define if we can use gcc inline assembler to get and set x87 control word */\n#if defined(__GNUC__)\n  #define HAVE_GCC_ASM_FOR_X87  1\n#else\n  #undef HAVE_GCC_ASM_FOR_X87\n#endif\n\n/* Define if you have the getaddrinfo function. */\n//#undef HAVE_GETADDRINFO\n#define HAVE_GETADDRINFO  1\n\n/* Define to 1 if you have the 'getcwd' function. */\n#define HAVE_GETCWD   1\n\n/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */\n#undef HAVE_GETC_UNLOCKED\n\n/* Define to 1 if you have the 'getentropy' function. */\n#undef HAVE_GETENTROPY\n\n/* Define to 1 if you have the 'getgroups' function. */\n#undef HAVE_GETGROUPS\n\n/* Define to 1 if you have the 'gethostbyname' function. */\n//#undef HAVE_GETHOSTBYNAME\n#define HAVE_GETHOSTBYNAME  1\n\n/* Define this if you have some version of gethostbyname_r() */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define this if you have the 3-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_3_ARG\n\n/* Define this if you have the 5-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_5_ARG\n\n/* Define this if you have the 6-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_6_ARG\n\n/* Define to 1 if you have the 'getitimer' function. */\n#undef HAVE_GETITIMER\n\n/* Define to 1 if you have the 'getloadavg' function. */\n#undef HAVE_GETLOADAVG\n\n/* Define to 1 if you have the 'getlogin' function. */\n#undef HAVE_GETLOGIN\n\n/* Define to 1 if you have the 'getnameinfo' function. */\n//#undef HAVE_GETNAMEINFO\n#define HAVE_GETNAMEINFO 1\n\n/* Define if you have the 'getpagesize' function. */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the 'getpeername' function. */\n#define HAVE_GETPEERNAME  1\n\n/* Define to 1 if you have the 'getpgid' function. */\n#undef HAVE_GETPGID\n\n/* Define to 1 if you have the 'getpgrp' function. */\n#undef HAVE_GETPGRP\n\n/* Define to 1 if you have the 'getpid' function. */\n#undef HAVE_GETPID\n\n/* Define to 1 if you have the 'getpriority' function. */\n#undef HAVE_GETPRIORITY\n\n/* Define to 1 if you have the 'getpwent' function. */\n#undef HAVE_GETPWENT\n\n/* Define to 1 if you have the 'getresgid' function. */\n#undef HAVE_GETRESGID\n\n/* Define to 1 if you have the 'getresuid' function. */\n#undef HAVE_GETRESUID\n\n/* Define to 1 if you have the 'getsid' function. */\n#undef HAVE_GETSID\n\n/* Define to 1 if you have the 'getspent' function. */\n#undef HAVE_GETSPENT\n\n/* Define to 1 if you have the 'getspnam' function. */\n#undef HAVE_GETSPNAM\n\n/* Define to 1 if you have the 'gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the 'getwd' function. */\n#undef HAVE_GETWD\n\n/* Define to 1 if you have the <grp.h> header file. */\n#undef HAVE_GRP_H\n\n/* Define if you have the 'hstrerror' function. */\n#undef HAVE_HSTRERROR\n\n/* Define to 1 if you have the 'hypot' function. */\n#undef HAVE_HYPOT\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define if you have the 'inet_aton' function. */\n#define HAVE_INET_ATON    1\n\n/* Define if you have the 'inet_pton' function. */\n#define HAVE_INET_PTON    1\n\n/* Define to 1 if you have the 'initgroups' function. */\n#undef HAVE_INITGROUPS\n\n/* Define if your compiler provides int32_t. */\n#undef HAVE_INT32_T\n\n/* Define if your compiler provides int64_t. */\n#undef HAVE_INT64_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H   1\n\n/* Define to 1 if you have the <io.h> header file. */\n#undef HAVE_IO_H\n\n/* Define to 1 if you have the 'kill' function. */\n#undef HAVE_KILL\n\n/* Define to 1 if you have the 'killpg' function. */\n#undef HAVE_KILLPG\n\n/* Define if you have the 'kqueue' functions. */\n#undef HAVE_KQUEUE\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H   /* non-functional in EFI. */\n\n/* Defined to enable large file support when an off_t is bigger than a long\n   and long long is available and at least as big as an off_t. You may need to\n   add some flags for configuration and compilation to enable this mode. (For\n   Solaris and Linux, the necessary defines are already defined.) */\n#undef HAVE_LARGEFILE_SUPPORT\n\n/* Define to 1 if you have the 'lchflags' function. */\n#undef HAVE_LCHFLAGS\n\n/* Define to 1 if you have the 'lchmod' function. */\n#undef HAVE_LCHMOD\n\n/* Define to 1 if you have the 'lchown' function. */\n#undef HAVE_LCHOWN\n\n/* Define to 1 if you have the 'lgamma' function. */\n#undef HAVE_LGAMMA\n\n/* Define to 1 if you have the 'dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the 'dld' library (-ldld). */\n#undef HAVE_LIBDLD\n\n/* Define to 1 if you have the 'ieee' library (-lieee). */\n#undef HAVE_LIBIEEE\n\n/* Define to 1 if you have the <libintl.h> header file. */\n#undef HAVE_LIBINTL_H\n\n/* Define if you have the readline library (-lreadline). */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the 'resolv' library (-lresolv). */\n#undef HAVE_LIBRESOLV\n\n/* Define to 1 if you have the <libutil.h> header file. */\n#undef HAVE_LIBUTIL_H\n\n/* Define if you have the 'link' function. */\n#undef HAVE_LINK\n\n/* Define to 1 if you have the <linux/netlink.h> header file. */\n#undef HAVE_LINUX_NETLINK_H\n\n/* Define to 1 if you have the <linux/tipc.h> header file. */\n#undef HAVE_LINUX_TIPC_H\n\n/* Define to 1 if you have the 'log1p' function. */\n#undef HAVE_LOG1P\n\n/* Define this if you have the type long double. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define this if you have the type long long. */\n#define HAVE_LONG_LONG  1\n\n/* Define to 1 if you have the 'lstat' function. */\n#define HAVE_LSTAT      1\n\n/* Define this if you have the makedev macro. */\n#undef HAVE_MAKEDEV\n\n/* Define to 1 if you have the 'memmove' function. */\n#define HAVE_MEMMOVE    1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the 'mkfifo' function. */\n#undef HAVE_MKFIFO\n\n/* Define to 1 if you have the 'mknod' function. */\n#undef HAVE_MKNOD\n\n/* Define to 1 if you have the 'mktime' function. */\n#define HAVE_MKTIME     1\n\n/* Define to 1 if you have the 'mmap' function. */\n#undef HAVE_MMAP\n\n/* Define to 1 if you have the 'mremap' function. */\n#undef HAVE_MREMAP\n\n/* Define to 1 if you have the <ncurses.h> header file. */\n#undef HAVE_NCURSES_H\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netpacket/packet.h> header file. */\n#undef HAVE_NETPACKET_PACKET_H\n\n/* Define to 1 if you have the 'nice' function. */\n#undef HAVE_NICE\n\n/* Define to 1 if you have the 'openpty' function. */\n#undef HAVE_OPENPTY\n\n/* Define if compiling using MacOS X 10.5 SDK or later. */\n#undef HAVE_OSX105_SDK\n\n/* Define to 1 if you have the 'pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if you have the 'pause' function. */\n#undef HAVE_PAUSE\n\n/* Define to 1 if you have the 'plock' function. */\n#undef HAVE_PLOCK\n\n/* Define to 1 if you have the 'poll' function. */\n#define HAVE_POLL         1\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the <process.h> header file. */\n#undef HAVE_PROCESS_H\n\n/* Define if your compiler supports function prototype */\n#define HAVE_PROTOTYPES   1\n\n/* Define if you have GNU PTH threads. */\n#undef HAVE_PTH\n\n/* Define to 1 if you have the 'pthread_atfork' function. */\n#undef HAVE_PTHREAD_ATFORK\n\n/* Defined for Solaris 2.6 bug in pthread header. */\n#undef HAVE_PTHREAD_DESTRUCTOR\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#undef HAVE_PTHREAD_H\n\n/* Define to 1 if you have the 'pthread_init' function. */\n#undef HAVE_PTHREAD_INIT\n\n/* Define to 1 if you have the 'pthread_sigmask' function. */\n#undef HAVE_PTHREAD_SIGMASK\n\n/* Define to 1 if you have the <pty.h> header file. */\n#undef HAVE_PTY_H\n\n/* Define to 1 if you have the 'putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define if the libcrypto has RAND_egd */\n#undef HAVE_RAND_EGD\n\n/* Define to 1 if you have the 'readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the 'realpath' function. */\n#define HAVE_REALPATH   1\n\n/* Define if you have readline 2.1 */\n#undef HAVE_RL_CALLBACK\n\n/* Define if you can turn off readline's signal handling. */\n#undef HAVE_RL_CATCH_SIGNAL\n\n/* Define if you have readline 2.2 */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK\n\n/* Define if you have readline 4.2 */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define if you have rl_completion_suppress_append */\n#undef HAVE_RL_COMPLETION_SUPPRESS_APPEND\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_PRE_INPUT_HOOK\n\n/* Define to 1 if you have the 'round' function. */\n#undef HAVE_ROUND\n\n/* Define to 1 if you have the 'select' function. */\n#define HAVE_SELECT       1\n\n/* Define to 1 if you have the 'sem_getvalue' function. */\n#undef HAVE_SEM_GETVALUE\n\n/* Define to 1 if you have the 'sem_open' function. */\n#undef HAVE_SEM_OPEN\n\n/* Define to 1 if you have the 'sem_timedwait' function. */\n#undef HAVE_SEM_TIMEDWAIT\n\n/* Define to 1 if you have the 'sem_unlink' function. */\n#undef HAVE_SEM_UNLINK\n\n/* Define to 1 if you have the 'setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the 'seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the 'setgid' function. */\n#undef HAVE_SETGID\n\n/* Define if you have the 'setgroups' function. */\n#undef HAVE_SETGROUPS\n\n/* Define to 1 if you have the 'setitimer' function. */\n#undef HAVE_SETITIMER\n\n/* Define to 1 if you have the 'setlocale' function. */\n#define HAVE_SETLOCALE    1\n\n/* Define to 1 if you have the 'setpgid' function. */\n#undef HAVE_SETPGID\n\n/* Define to 1 if you have the 'setpgrp' function. */\n#undef HAVE_SETPGRP\n\n/* Define to 1 if you have the 'setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the 'setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the 'setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the 'setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the 'setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the 'setuid' function. */\n#undef HAVE_SETUID\n\n/* Define to 1 if you have the 'setvbuf' function. */\n#define HAVE_SETVBUF    1\n\n/* Define to 1 if you have the <shadow.h> header file. */\n#undef HAVE_SHADOW_H\n\n/* Define to 1 if you have the 'sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the 'siginterrupt' function. */\n#undef HAVE_SIGINTERRUPT\n\n/* Define to 1 if you have the <signal.h> header file. */\n#define HAVE_SIGNAL_H   1\n\n/* Define to 1 if you have the 'sigrelse' function. */\n#undef HAVE_SIGRELSE\n\n/* Define to 1 if you have the 'snprintf' function. */\n#define HAVE_SNPRINTF   1\n\n/* Define if sockaddr has sa_len member */\n#undef HAVE_SOCKADDR_SA_LEN\n\n/* struct sockaddr_storage (sys/socket.h) */\n#undef HAVE_SOCKADDR_STORAGE\n\n/* Define if you have the 'socketpair' function. */\n#undef HAVE_SOCKETPAIR\n\n/* Define to 1 if you have the <spawn.h> header file. */\n#undef HAVE_SPAWN_H\n\n/* Define if your compiler provides ssize_t */\n#define HAVE_SSIZE_T    1\n\n/* Define to 1 if you have the 'statvfs' function. */\n#undef HAVE_STATVFS\n\n/* Define if you have struct stat.st_mtim.tv_nsec */\n#undef HAVE_STAT_TV_NSEC\n\n/* Define if you have struct stat.st_mtimensec */\n#undef HAVE_STAT_TV_NSEC2\n\n/* Define if your compiler supports variable length function prototypes (e.g.\n   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */\n#define HAVE_STDARG_PROTOTYPES          1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H   1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H   1\n\n/* Define to 1 if you have the 'strdup' function. */\n#define HAVE_STRDUP     1\n\n/* Define to 1 if you have the 'strftime' function. */\n#define HAVE_STRFTIME   1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H   1\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#undef HAVE_STROPTS_H\n\n/* Define to 1 if 'st_birthtime' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BIRTHTIME   1\n\n/* Define to 1 if 'st_blksize' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BLKSIZE     1\n\n/* Define to 1 if 'st_blocks' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_BLOCKS\n\n/* Define to 1 if 'st_flags' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_FLAGS\n\n/* Define to 1 if 'st_gen' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_GEN\n\n/* Define to 1 if 'st_rdev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_RDEV\n\n/* Define to 1 if 'st_dev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_DEV\n\n/* Define to 1 if 'st_ino' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_INO\n\n/* Define to 1 if 'tm_zone' is a member of 'struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if your 'struct stat' has 'st_blocks'. Deprecated, use\n   'HAVE_STRUCT_STAT_ST_BLOCKS' instead. */\n#undef HAVE_ST_BLOCKS\n\n/* Define if you have the 'symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the 'sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the <sysexits.h> header file. */\n#undef HAVE_SYSEXITS_H\n\n/* Define to 1 if you have the <sys/audioio.h> header file. */\n#undef HAVE_SYS_AUDIOIO_H\n\n/* Define to 1 if you have the <sys/bsdtty.h> header file. */\n#undef HAVE_SYS_BSDTTY_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/epoll.h> header file. */\n#undef HAVE_SYS_EPOLL_H\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n#undef HAVE_SYS_EVENT_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/loadavg.h> header file. */\n#undef HAVE_SYS_LOADAVG_H\n\n/* Define to 1 if you have the <sys/lock.h> header file. */\n#undef HAVE_SYS_LOCK_H\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n#undef HAVE_SYS_MKDEV_H\n\n/* Define to 1 if you have the <sys/modem.h> header file. */\n#undef HAVE_SYS_MODEM_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#define HAVE_SYS_PARAM_H                1\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#define HAVE_SYS_POLL_H                 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H             1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H               1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H               1\n\n/* Define to 1 if you have the <sys/statvfs.h> header file. */\n#undef HAVE_SYS_STATVFS_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H   1\n\n/* Define to 1 if you have the <sys/termio.h> header file. */\n#undef HAVE_SYS_TERMIO_H\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n#undef HAVE_SYS_TIMES_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H     1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H    1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#undef HAVE_SYS_UTSNAME_H\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the system() command. */\n#define HAVE_SYSTEM       1\n\n/* Define to 1 if you have the 'tcgetpgrp' function. */\n#undef HAVE_TCGETPGRP\n\n/* Define to 1 if you have the 'tcsetpgrp' function. */\n#undef HAVE_TCSETPGRP\n\n/* Define to 1 if you have the 'tempnam' function. */\n#define HAVE_TEMPNAM      1\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <term.h> header file. */\n#undef HAVE_TERM_H\n\n/* Define to 1 if you have the 'tgamma' function. */\n#undef HAVE_TGAMMA\n\n/* Define to 1 if you have the <thread.h> header file. */\n#undef HAVE_THREAD_H\n\n/* Define to 1 if you have the 'timegm' function. */\n#undef HAVE_TIMEGM\n\n/* Define to 1 if you have the 'times' function. */\n#undef HAVE_TIMES\n\n/* Define to 1 if you have the 'tmpfile' function. */\n#define HAVE_TMPFILE    1\n\n/* Define to 1 if you have the 'tmpnam' function. */\n#define HAVE_TMPNAM     1\n\n/* Define to 1 if you have the 'tmpnam_r' function. */\n#undef HAVE_TMPNAM_R\n\n/* Define to 1 if your 'struct tm' has 'tm_zone'. Deprecated, use\n   'HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the 'truncate' function. */\n#undef HAVE_TRUNCATE\n\n/* Define to 1 if you don't have 'tm_zone' but do have the external array\n   'tzname'. */\n#undef HAVE_TZNAME\n\n/* Define this if you have tcl and TCL_UTF_MAX==6 */\n#undef HAVE_UCS4_TCL\n\n/* Define if your compiler provides uint32_t. */\n#undef HAVE_UINT32_T\n\n/* Define if your compiler provides uint64_t. */\n#undef HAVE_UINT64_T\n\n/* Define to 1 if the system has the type 'uintptr_t'. */\n#define HAVE_UINTPTR_T                  1\n\n/* Define to 1 if you have the 'uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H                   1\n\n/* Define to 1 if you have the 'unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define if you have a useable wchar_t type defined in wchar.h; useable means\n   wchar_t must be an unsigned type with at least 16 bits. (see\n   Include/unicodeobject.h). */\n#define HAVE_USABLE_WCHAR_T             1\n\n/* Define to 1 if you have the <util.h> header file. */\n#undef HAVE_UTIL_H\n\n/* Define to 1 if you have the 'utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H                    1\n\n/* Define to 1 if you have the 'wait3' function. */\n#undef HAVE_WAIT3\n\n/* Define to 1 if you have the 'wait4' function. */\n#undef HAVE_WAIT4\n\n/* Define to 1 if you have the 'waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define if the compiler provides a wchar.h header file. */\n#define HAVE_WCHAR_H    1\n\n/* Define to 1 if you have the 'wcscoll' function. */\n#define HAVE_WCSCOLL    1\n\n/* Define if tzset() actually switches the local timezone in a meaningful way.\n   */\n#undef HAVE_WORKING_TZSET\n\n/* Define if the zlib library has inflateCopy */\n#undef HAVE_ZLIB_COPY\n\n/* Define to 1 if you have the '_getpty' function. */\n#undef HAVE__GETPTY\n\n/* Define if you are using Mach cthreads directly under /include */\n#undef HURD_C_THREADS\n\n/* Define if you are using Mach cthreads under mach / */\n#undef MACH_C_THREADS\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in <mkdev.h>.\n   */\n#undef MAJOR_IN_MKDEV\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in\n   <sysmacros.h>. */\n#undef MAJOR_IN_SYSMACROS\n\n/* Define if mvwdelch in curses.h is an expression. */\n#undef MVWDELCH_IS_EXPRESSION\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT   \"edk2-devel@lists.01.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME    \"EDK II Python 2.7.10 Package\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING  \"EDK II Python 2.7.10 Package V0.1\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME   \"EADK_Python\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL   \"http://www.tianocore.org/\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION  \"V0.1\"\n\n/* Define if POSIX semaphores aren't enabled on your system */\n#define POSIX_SEMAPHORES_NOT_ENABLED    1\n\n/* Defined if PTHREAD_SCOPE_SYSTEM supported. */\n#undef PTHREAD_SYSTEM_SCHED_SUPPORTED\n\n/* Define as the preferred size in bits of long digits */\n#undef PYLONG_BITS_IN_DIGIT\n\n/* Define to printf format modifier for long long type */\n#define PY_FORMAT_LONG_LONG   \"ll\"\n\n/* Define to printf format modifier for Py_ssize_t */\n#define PY_FORMAT_SIZE_T    \"z\"\n\n/* Define as the integral type used for Unicode representation. */\n#define PY_UNICODE_TYPE     wchar_t\n\n/* Define if you want to build an interpreter with many run-time checks. */\n#undef Py_DEBUG\n\n/* Defined if Python is built as a shared library. */\n#undef Py_ENABLE_SHARED\n\n/* Define as the size of the unicode type. */\n#define Py_UNICODE_SIZE   2\n\n/* Define if you want to have a Unicode type. */\n#define Py_USING_UNICODE\n\n/* assume C89 semantics that RETSIGTYPE is always void */\n#undef RETSIGTYPE\n\n/* Define if setpgrp() must be called as setpgrp(0, 0). */\n#undef SETPGRP_HAVE_ARG\n\n/* Define this to be extension of shared libraries (including the dot!). */\n#undef SHLIB_EXT\n\n/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */\n#undef SIGNED_RIGHT_SHIFT_ZERO_FILLS\n\n/* The size of 'double', as computed by sizeof. */\n#define SIZEOF_DOUBLE     8\n\n/* The size of 'float', as computed by sizeof. */\n#define SIZEOF_FLOAT      4\n\n/* The size of 'fpos_t', as computed by sizeof. */\n#define SIZEOF_FPOS_T     8\n\n/* The size of 'int', as computed by sizeof. */\n#define SIZEOF_INT        4\n\n/* The size of 'long', as computed by sizeof. */\n#define SIZEOF_LONG       4\n\n/* The size of 'long double', as computed by sizeof. */\n#undef SIZEOF_LONG_DOUBLE\n\n/* The size of 'long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG  8\n\n/* The size of 'off_t', as computed by sizeof. */\n#define SIZEOF_OFF_T      4\n\n/* The size of 'pid_t', as computed by sizeof. */\n#define SIZEOF_PID_T      4\n\n/* The size of 'pthread_t', as computed by sizeof. */\n#undef SIZEOF_PTHREAD_T\n\n/* The size of 'short', as computed by sizeof. */\n#define SIZEOF_SHORT      2\n\n/* The size of 'size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T     4\n\n/* The size of 'time_t', as computed by sizeof. */\n#define SIZEOF_TIME_T     4\n\n/* The size of 'uintptr_t', as computed by sizeof. */\n#define SIZEOF_UINTPTR_T  4\n\n/* The size of 'void *', as computed by sizeof. */\n#define SIZEOF_VOID_P     4\n\n/* The size of 'wchar_t', as computed by sizeof. */\n#define SIZEOF_WCHAR_T    2\n\n/* The size of '_Bool', as computed by sizeof. */\n#define SIZEOF__BOOL      1\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS      1\n\n/* Define if you can safely include both <sys/select.h> and <sys/time.h>\n   (which you can't on SCO ODT 3.0). */\n#undef SYS_SELECT_WITH_SYS_TIME\n\n/* Define if tanh(-0.) is -0., or if platform doesn't have signed zeros */\n#undef TANH_PRESERVES_ZERO_SIGN\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if your <sys/time.h> declares 'struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Enable extensions on AIX 3, Interix.  */\n#ifndef _ALL_SOURCE\n# undef _ALL_SOURCE\n#endif\n/* Enable GNU extensions on systems that have them.  */\n#ifndef _GNU_SOURCE\n# undef _GNU_SOURCE\n#endif\n/* Enable threading extensions on Solaris.  */\n#ifndef _POSIX_PTHREAD_SEMANTICS\n# undef _POSIX_PTHREAD_SEMANTICS\n#endif\n/* Enable extensions on HP NonStop.  */\n#ifndef _TANDEM_SOURCE\n# undef _TANDEM_SOURCE\n#endif\n/* Enable general extensions on Solaris.  */\n#ifndef __EXTENSIONS__\n# undef __EXTENSIONS__\n#endif\n\n\n/* Define if you want to use MacPython modules on MacOSX in unix-Python. */\n#undef USE_TOOLBOX_OBJECT_GLUE\n\n/* Define if a va_list is an array of some kind */\n#undef VA_LIST_IS_ARRAY\n\n/* Define if you want SIGFPE handled (see Include/pyfpe.h). */\n#undef WANT_SIGFPE_HANDLER\n\n/* Define if you want wctype.h functions to be used instead of the one\n   supplied by Python itself. (see Include/unicodectype.h). */\n#define WANT_WCTYPE_FUNCTIONS   1\n\n/* Define if WINDOW in curses.h offers a field _flags. */\n#undef WINDOW_HAS_FLAGS\n\n/* Define if you want documentation strings in extension modules */\n#undef WITH_DOC_STRINGS\n\n/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic\n   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).\n   Dyld is necessary to support frameworks. */\n#undef WITH_DYLD\n\n/* Define to 1 if libintl is needed for locale functions. */\n#undef WITH_LIBINTL\n\n/* Define if you want to produce an OpenStep/Rhapsody framework (shared\n   library plus accessory files). */\n#undef WITH_NEXT_FRAMEWORK\n\n/* Define if you want to compile in Python-specific mallocs */\n#undef WITH_PYMALLOC\n\n/* Define if you want to compile in rudimentary thread support */\n#undef WITH_THREAD\n\n/* Define to profile with the Pentium timestamp counter */\n#undef WITH_TSC\n\n/* Define if you want pymalloc to be disabled when running under valgrind */\n#undef WITH_VALGRIND\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define if arithmetic is subject to x87-style double rounding issue */\n#undef X87_DOUBLE_ROUNDING\n\n/* Define on OpenBSD to activate all library features */\n#undef _BSD_SOURCE\n\n/* Define on Irix to enable u_int */\n#undef _BSD_TYPES\n\n/* Define on Darwin to activate all library features */\n#undef _DARWIN_C_SOURCE\n\n/* This must be set to 64 on some systems to enable large file support. */\n#undef _FILE_OFFSET_BITS\n\n/* Define on Linux to activate all library features */\n#undef _GNU_SOURCE\n\n/* This must be defined on some systems to enable large file support. */\n#undef _LARGEFILE_SOURCE\n\n/* This must be defined on AIX systems to enable large file support. */\n#undef _LARGE_FILES\n\n/* Define to 1 if on MINIX. */\n#undef _MINIX\n\n/* Define on NetBSD to activate all library features */\n#define _NETBSD_SOURCE  1\n\n/* Define _OSF_SOURCE to get the makedev macro. */\n#undef _OSF_SOURCE\n\n/* Define to 2 if the system does not provide POSIX.1 features except with\n   this defined. */\n#undef _POSIX_1_SOURCE\n\n/* Define to activate features from IEEE Stds 1003.1-2001 */\n#undef _POSIX_C_SOURCE\n\n/* Define to 1 if you need to in order for 'stat' and other things to work. */\n#undef _POSIX_SOURCE\n\n/* Define if you have POSIX threads, and your system does not define that. */\n#undef _POSIX_THREADS\n\n/* Define to force use of thread-safe errno, h_errno, and other functions */\n#undef _REENTRANT\n\n/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT32_T\n\n/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT64_T\n\n/* Define to the level of X/Open that your system supports */\n#undef _XOPEN_SOURCE\n\n/* Define to activate Unix95-and-earlier features */\n#undef _XOPEN_SOURCE_EXTENDED\n\n/* Define on FreeBSD to activate all library features */\n#undef __BSD_VISIBLE\n\n/* Define to 1 if type 'char' is unsigned and you are not using gcc.  */\n#ifndef __CHAR_UNSIGNED__\n# undef __CHAR_UNSIGNED__\n#endif\n\n/* Defined on Solaris to see additional function prototypes. */\n#undef __EXTENSIONS__\n\n/* Define to 'long' if <time.h> doesn't define. */\n//#undef clock_t\n\n/* Define to empty if 'const' does not conform to ANSI C. */\n//#undef const\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef gid_t\n\n/* Define to the type of a signed integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int32_t\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int64_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef mode_t\n\n/* Define to 'long int' if <sys/types.h> does not define. */\n//#undef off_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef pid_t\n\n/* Define to empty if the keyword does not work. */\n//#undef signed\n\n/* Define to 'unsigned int' if <sys/types.h> does not define. */\n//#undef size_t\n\n/* Define to 'int' if <sys/socket.h> does not define. */\n//#undef socklen_t\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef uid_t\n\n/* Define to the type of an unsigned integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint32_t\n\n/* Define to the type of an unsigned integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint64_t\n\n/* Define to empty if the keyword does not work. */\n//#undef volatile\n\n#endif /*Py_PYCONFIG_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/X64/pyconfig.h": "/** @file\n    Manually generated Python Configuration file for EDK II.\n\n    Copyright (c) 2015, Daryl McDaniel. All rights reserved.<BR>\n    Copyright (c) 2011 - 2016, Intel Corporation. All rights reserved.<BR>\n    This program and the accompanying materials are licensed and made available under\n    the terms and conditions of the BSD License that accompanies this distribution.\n    The full text of the license may be found at\n    http://opensource.org/licenses/bsd-license.\n\n    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n**/\n#ifndef Py_PYCONFIG_H\n#define Py_PYCONFIG_H\n\n#include  <Uefi.h>\n\n#define PLATFORM    \"uefi\"\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want\n   support for AIX C++ shared extension modules. */\n#undef AIX_GENUINE_CPLUSPLUS\n\n/* Define this if you have AtheOS threads. */\n#undef ATHEOS_THREADS\n\n/* Define this if you have BeOS threads. */\n#undef BEOS_THREADS\n\n/* Define if you have the Mach cthreads package */\n#undef C_THREADS\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM\n   mixed-endian order (byte order 45670123) */\n#undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most\n   significant byte first */\n#undef DOUBLE_IS_BIG_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the\n   least significant byte first */\n#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n\n/* Define if --enable-ipv6 is specified */\n#undef ENABLE_IPV6\n\n/* Define if flock needs to be linked with bsd library. */\n#undef FLOCK_NEEDS_LIBBSD\n\n/* Define if getpgrp() must be called as getpgrp(0). */\n#undef GETPGRP_HAVE_ARG\n\n/* Define if gettimeofday() does not have second (timezone) argument This is\n   the case on Motorola V4 (R40V4.2) */\n#undef GETTIMEOFDAY_NO_TZ\n\n/* Define to 1 if you have the 'acosh' function. */\n#undef HAVE_ACOSH\n\n/* struct addrinfo (netdb.h) */\n#undef HAVE_ADDRINFO\n\n/* Define to 1 if you have the 'alarm' function. */\n#undef HAVE_ALARM\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#undef HAVE_ALLOCA_H\n\n/* Define this if your time.h defines altzone. */\n#undef HAVE_ALTZONE\n\n/* Define to 1 if you have the 'asinh' function. */\n#undef HAVE_ASINH\n\n/* Define to 1 if you have the <asm/types.h> header file. */\n#undef HAVE_ASM_TYPES_H\n\n/* Define to 1 if you have the 'atanh' function. */\n#undef HAVE_ATANH\n\n/* Define if GCC supports __attribute__((format(PyArg_ParseTuple, 2, 3))) */\n#undef HAVE_ATTRIBUTE_FORMAT_PARSETUPLE\n\n/* Define to 1 if you have the 'bind_textdomain_codeset' function. */\n#undef HAVE_BIND_TEXTDOMAIN_CODESET\n\n/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_BLUETOOTH_H\n\n/* Define to 1 if you have the <bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_H\n\n/* Define if nice() returns success/failure instead of the new priority. */\n#undef HAVE_BROKEN_NICE\n\n/* Define if the system reports an invalid PIPE_BUF value. */\n#undef HAVE_BROKEN_PIPE_BUF\n\n/* Define if poll() sets errno on invalid file descriptors. */\n#undef HAVE_BROKEN_POLL\n\n/* Define if the Posix semaphores do not work on your system */\n#define HAVE_BROKEN_POSIX_SEMAPHORES  1\n\n/* Define if pthread_sigmask() does not work on your system. */\n#define HAVE_BROKEN_PTHREAD_SIGMASK   1\n\n/* define to 1 if your sem_getvalue is broken. */\n#define HAVE_BROKEN_SEM_GETVALUE      1\n\n/* Define if 'unsetenv' does not return an int. */\n#undef HAVE_BROKEN_UNSETENV\n\n/* Define this if you have the type _Bool. */\n#define HAVE_C99_BOOL                 1\n\n/* Define to 1 if you have the 'chflags' function. */\n#undef HAVE_CHFLAGS\n\n/* Define to 1 if you have the 'chown' function. */\n#undef HAVE_CHOWN\n\n/* Define if you have the 'chroot' function. */\n#undef HAVE_CHROOT\n\n/* Define to 1 if you have the 'clock' function. */\n#define HAVE_CLOCK                    1\n\n/* Define to 1 if you have the 'confstr' function. */\n#undef HAVE_CONFSTR\n\n/* Define to 1 if you have the <conio.h> header file. */\n#undef HAVE_CONIO_H\n\n/* Define to 1 if you have the 'copysign' function. */\n#undef HAVE_COPYSIGN\n\n/* Define to 1 if you have the 'ctermid' function. */\n#undef HAVE_CTERMID\n\n/* Define if you have the 'ctermid_r' function. */\n#undef HAVE_CTERMID_R\n\n/* Define to 1 if you have the <curses.h> header file. */\n#undef HAVE_CURSES_H\n\n/* Define if you have the 'is_term_resized' function. */\n#undef HAVE_CURSES_IS_TERM_RESIZED\n\n/* Define if you have the 'resizeterm' function. */\n#undef HAVE_CURSES_RESIZETERM\n\n/* Define if you have the 'resize_term' function. */\n#undef HAVE_CURSES_RESIZE_TERM\n\n/* Define to 1 if you have the declaration of 'isfinite', and to 0 if you\n   don't. */\n#define HAVE_DECL_ISFINITE    0\n\n/* Define to 1 if you have the declaration of 'isinf', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISINF       1\n\n/* Define to 1 if you have the declaration of 'isnan', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISNAN       1\n\n/* Define to 1 if you have the declaration of 'tzname', and to 0 if you don't.\n   */\n#define HAVE_DECL_TZNAME      0\n\n/* Define to 1 if you have the device macros. */\n#undef HAVE_DEVICE_MACROS\n\n/* Define to 1 if you have the /dev/ptc device file. */\n#undef HAVE_DEV_PTC\n\n/* Define to 1 if you have the /dev/ptmx device file. */\n#undef HAVE_DEV_PTMX\n\n/* Define to 1 if you have the <direct.h> header file. */\n#undef HAVE_DIRECT_H\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'. */\n#define HAVE_DIRENT_H   1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the 'dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the 'dup2' function. */\n#define HAVE_DUP2       1\n\n/* Defined when any dynamic module loading is enabled. */\n#undef HAVE_DYNAMIC_LOADING\n\n/* Define if you have the 'epoll' functions. */\n#undef HAVE_EPOLL\n\n/* Define to 1 if you have the 'erf' function. */\n#undef HAVE_ERF\n\n/* Define to 1 if you have the 'erfc' function. */\n#undef HAVE_ERFC\n\n/* Define to 1 if you have the <errno.h> header file. */\n#define HAVE_ERRNO_H    1\n\n/* Define to 1 if you have the 'execv' function. */\n#undef HAVE_EXECV\n\n/* Define to 1 if you have the 'expm1' function. */\n#undef HAVE_EXPM1\n\n/* Define if you have the 'fchdir' function. */\n#undef HAVE_FCHDIR\n\n/* Define to 1 if you have the 'fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the 'fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H    1\n\n/* Define if you have the 'fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the 'finite' function. */\n#define HAVE_FINITE     1\n\n/* Define to 1 if you have the 'flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the 'fork' function. */\n#undef HAVE_FORK\n\n/* Define to 1 if you have the 'forkpty' function. */\n#undef HAVE_FORKPTY\n\n/* Define to 1 if you have the 'fpathconf' function. */\n#undef HAVE_FPATHCONF\n\n/* Define to 1 if you have the 'fseek64' function. */\n#undef HAVE_FSEEK64\n\n/* Define to 1 if you have the 'fseeko' function. */\n#define HAVE_FSEEKO     1\n\n/* Define to 1 if you have the 'fstatvfs' function. */\n#undef HAVE_FSTATVFS\n\n/* Define if you have the 'fsync' function. */\n#undef HAVE_FSYNC\n\n/* Define to 1 if you have the 'ftell64' function. */\n#undef HAVE_FTELL64\n\n/* Define to 1 if you have the 'ftello' function. */\n#define HAVE_FTELLO     1\n\n/* Define to 1 if you have the 'ftime' function. */\n#undef HAVE_FTIME\n\n/* Define to 1 if you have the 'ftruncate' function. */\n#undef HAVE_FTRUNCATE\n\n/* Define to 1 if you have the 'gai_strerror' function. */\n#undef HAVE_GAI_STRERROR\n\n/* Define to 1 if you have the 'gamma' function. */\n#undef HAVE_GAMMA\n\n/* Define if we can use gcc inline assembler to get and set x87 control word */\n#if defined(__GNUC__)\n  #define HAVE_GCC_ASM_FOR_X87  1\n#else\n  #undef HAVE_GCC_ASM_FOR_X87\n#endif\n\n/* Define if you have the getaddrinfo function. */\n//#undef HAVE_GETADDRINFO\n#define HAVE_GETADDRINFO  1\n\n/* Define to 1 if you have the 'getcwd' function. */\n#define HAVE_GETCWD   1\n\n/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */\n#undef HAVE_GETC_UNLOCKED\n\n/* Define to 1 if you have the 'getentropy' function. */\n#undef HAVE_GETENTROPY\n\n/* Define to 1 if you have the 'getgroups' function. */\n#undef HAVE_GETGROUPS\n\n/* Define to 1 if you have the 'gethostbyname' function. */\n//#undef HAVE_GETHOSTBYNAME\n#define HAVE_GETHOSTBYNAME  1\n\n/* Define this if you have some version of gethostbyname_r() */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define this if you have the 3-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_3_ARG\n\n/* Define this if you have the 5-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_5_ARG\n\n/* Define this if you have the 6-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_6_ARG\n\n/* Define to 1 if you have the 'getitimer' function. */\n#undef HAVE_GETITIMER\n\n/* Define to 1 if you have the 'getloadavg' function. */\n#undef HAVE_GETLOADAVG\n\n/* Define to 1 if you have the 'getlogin' function. */\n#undef HAVE_GETLOGIN\n\n/* Define to 1 if you have the 'getnameinfo' function. */\n//#undef HAVE_GETNAMEINFO\n#define HAVE_GETNAMEINFO 1\n\n/* Define if you have the 'getpagesize' function. */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the 'getpeername' function. */\n#define HAVE_GETPEERNAME  1\n\n/* Define to 1 if you have the 'getpgid' function. */\n#undef HAVE_GETPGID\n\n/* Define to 1 if you have the 'getpgrp' function. */\n#undef HAVE_GETPGRP\n\n/* Define to 1 if you have the 'getpid' function. */\n#undef HAVE_GETPID\n\n/* Define to 1 if you have the 'getpriority' function. */\n#undef HAVE_GETPRIORITY\n\n/* Define to 1 if you have the 'getpwent' function. */\n#undef HAVE_GETPWENT\n\n/* Define to 1 if you have the 'getresgid' function. */\n#undef HAVE_GETRESGID\n\n/* Define to 1 if you have the 'getresuid' function. */\n#undef HAVE_GETRESUID\n\n/* Define to 1 if you have the 'getsid' function. */\n#undef HAVE_GETSID\n\n/* Define to 1 if you have the 'getspent' function. */\n#undef HAVE_GETSPENT\n\n/* Define to 1 if you have the 'getspnam' function. */\n#undef HAVE_GETSPNAM\n\n/* Define to 1 if you have the 'gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the 'getwd' function. */\n#undef HAVE_GETWD\n\n/* Define to 1 if you have the <grp.h> header file. */\n#undef HAVE_GRP_H\n\n/* Define if you have the 'hstrerror' function. */\n#undef HAVE_HSTRERROR\n\n/* Define to 1 if you have the 'hypot' function. */\n#undef HAVE_HYPOT\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define if you have the 'inet_aton' function. */\n#define HAVE_INET_ATON    1\n\n/* Define if you have the 'inet_pton' function. */\n#define HAVE_INET_PTON    1\n\n/* Define to 1 if you have the 'initgroups' function. */\n#undef HAVE_INITGROUPS\n\n/* Define if your compiler provides int32_t. */\n#undef HAVE_INT32_T\n\n/* Define if your compiler provides int64_t. */\n#undef HAVE_INT64_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H   1\n\n/* Define to 1 if you have the <io.h> header file. */\n#undef HAVE_IO_H\n\n/* Define to 1 if you have the 'kill' function. */\n#undef HAVE_KILL\n\n/* Define to 1 if you have the 'killpg' function. */\n#undef HAVE_KILLPG\n\n/* Define if you have the 'kqueue' functions. */\n#undef HAVE_KQUEUE\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H   /* non-functional in EFI. */\n\n/* Defined to enable large file support when an off_t is bigger than a long\n   and long long is available and at least as big as an off_t. You may need to\n   add some flags for configuration and compilation to enable this mode. (For\n   Solaris and Linux, the necessary defines are already defined.) */\n#undef HAVE_LARGEFILE_SUPPORT\n\n/* Define to 1 if you have the 'lchflags' function. */\n#undef HAVE_LCHFLAGS\n\n/* Define to 1 if you have the 'lchmod' function. */\n#undef HAVE_LCHMOD\n\n/* Define to 1 if you have the 'lchown' function. */\n#undef HAVE_LCHOWN\n\n/* Define to 1 if you have the 'lgamma' function. */\n#undef HAVE_LGAMMA\n\n/* Define to 1 if you have the 'dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the 'dld' library (-ldld). */\n#undef HAVE_LIBDLD\n\n/* Define to 1 if you have the 'ieee' library (-lieee). */\n#undef HAVE_LIBIEEE\n\n/* Define to 1 if you have the <libintl.h> header file. */\n#undef HAVE_LIBINTL_H\n\n/* Define if you have the readline library (-lreadline). */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the 'resolv' library (-lresolv). */\n#undef HAVE_LIBRESOLV\n\n/* Define to 1 if you have the <libutil.h> header file. */\n#undef HAVE_LIBUTIL_H\n\n/* Define if you have the 'link' function. */\n#undef HAVE_LINK\n\n/* Define to 1 if you have the <linux/netlink.h> header file. */\n#undef HAVE_LINUX_NETLINK_H\n\n/* Define to 1 if you have the <linux/tipc.h> header file. */\n#undef HAVE_LINUX_TIPC_H\n\n/* Define to 1 if you have the 'log1p' function. */\n#undef HAVE_LOG1P\n\n/* Define this if you have the type long double. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define this if you have the type long long. */\n#define HAVE_LONG_LONG  1\n\n/* Define to 1 if you have the 'lstat' function. */\n#define HAVE_LSTAT      1\n\n/* Define this if you have the makedev macro. */\n#undef HAVE_MAKEDEV\n\n/* Define to 1 if you have the 'memmove' function. */\n#define HAVE_MEMMOVE    1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the 'mkfifo' function. */\n#undef HAVE_MKFIFO\n\n/* Define to 1 if you have the 'mknod' function. */\n#undef HAVE_MKNOD\n\n/* Define to 1 if you have the 'mktime' function. */\n#define HAVE_MKTIME     1\n\n/* Define to 1 if you have the 'mmap' function. */\n#undef HAVE_MMAP\n\n/* Define to 1 if you have the 'mremap' function. */\n#undef HAVE_MREMAP\n\n/* Define to 1 if you have the <ncurses.h> header file. */\n#undef HAVE_NCURSES_H\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netpacket/packet.h> header file. */\n#undef HAVE_NETPACKET_PACKET_H\n\n/* Define to 1 if you have the 'nice' function. */\n#undef HAVE_NICE\n\n/* Define to 1 if you have the 'openpty' function. */\n#undef HAVE_OPENPTY\n\n/* Define if compiling using MacOS X 10.5 SDK or later. */\n#undef HAVE_OSX105_SDK\n\n/* Define to 1 if you have the 'pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if you have the 'pause' function. */\n#undef HAVE_PAUSE\n\n/* Define to 1 if you have the 'plock' function. */\n#undef HAVE_PLOCK\n\n/* Define to 1 if you have the 'poll' function. */\n#define HAVE_POLL         1\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the <process.h> header file. */\n#undef HAVE_PROCESS_H\n\n/* Define if your compiler supports function prototype */\n#define HAVE_PROTOTYPES   1\n\n/* Define if you have GNU PTH threads. */\n#undef HAVE_PTH\n\n/* Define to 1 if you have the 'pthread_atfork' function. */\n#undef HAVE_PTHREAD_ATFORK\n\n/* Defined for Solaris 2.6 bug in pthread header. */\n#undef HAVE_PTHREAD_DESTRUCTOR\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#undef HAVE_PTHREAD_H\n\n/* Define to 1 if you have the 'pthread_init' function. */\n#undef HAVE_PTHREAD_INIT\n\n/* Define to 1 if you have the 'pthread_sigmask' function. */\n#undef HAVE_PTHREAD_SIGMASK\n\n/* Define to 1 if you have the <pty.h> header file. */\n#undef HAVE_PTY_H\n\n/* Define to 1 if you have the 'putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define if the libcrypto has RAND_egd */\n#undef HAVE_RAND_EGD\n\n/* Define to 1 if you have the 'readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the 'realpath' function. */\n#define HAVE_REALPATH   1\n\n/* Define if you have readline 2.1 */\n#undef HAVE_RL_CALLBACK\n\n/* Define if you can turn off readline's signal handling. */\n#undef HAVE_RL_CATCH_SIGNAL\n\n/* Define if you have readline 2.2 */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK\n\n/* Define if you have readline 4.2 */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define if you have rl_completion_suppress_append */\n#undef HAVE_RL_COMPLETION_SUPPRESS_APPEND\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_PRE_INPUT_HOOK\n\n/* Define to 1 if you have the 'round' function. */\n#undef HAVE_ROUND\n\n/* Define to 1 if you have the 'select' function. */\n#define HAVE_SELECT       1\n\n/* Define to 1 if you have the 'sem_getvalue' function. */\n#undef HAVE_SEM_GETVALUE\n\n/* Define to 1 if you have the 'sem_open' function. */\n#undef HAVE_SEM_OPEN\n\n/* Define to 1 if you have the 'sem_timedwait' function. */\n#undef HAVE_SEM_TIMEDWAIT\n\n/* Define to 1 if you have the 'sem_unlink' function. */\n#undef HAVE_SEM_UNLINK\n\n/* Define to 1 if you have the 'setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the 'seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the 'setgid' function. */\n#undef HAVE_SETGID\n\n/* Define if you have the 'setgroups' function. */\n#undef HAVE_SETGROUPS\n\n/* Define to 1 if you have the 'setitimer' function. */\n#undef HAVE_SETITIMER\n\n/* Define to 1 if you have the 'setlocale' function. */\n#define HAVE_SETLOCALE    1\n\n/* Define to 1 if you have the 'setpgid' function. */\n#undef HAVE_SETPGID\n\n/* Define to 1 if you have the 'setpgrp' function. */\n#undef HAVE_SETPGRP\n\n/* Define to 1 if you have the 'setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the 'setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the 'setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the 'setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the 'setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the 'setuid' function. */\n#undef HAVE_SETUID\n\n/* Define to 1 if you have the 'setvbuf' function. */\n#define HAVE_SETVBUF    1\n\n/* Define to 1 if you have the <shadow.h> header file. */\n#undef HAVE_SHADOW_H\n\n/* Define to 1 if you have the 'sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the 'siginterrupt' function. */\n#undef HAVE_SIGINTERRUPT\n\n/* Define to 1 if you have the <signal.h> header file. */\n#define HAVE_SIGNAL_H   1\n\n/* Define to 1 if you have the 'sigrelse' function. */\n#undef HAVE_SIGRELSE\n\n/* Define to 1 if you have the 'snprintf' function. */\n#define HAVE_SNPRINTF   1\n\n/* Define if sockaddr has sa_len member */\n#undef HAVE_SOCKADDR_SA_LEN\n\n/* struct sockaddr_storage (sys/socket.h) */\n#undef HAVE_SOCKADDR_STORAGE\n\n/* Define if you have the 'socketpair' function. */\n#undef HAVE_SOCKETPAIR\n\n/* Define to 1 if you have the <spawn.h> header file. */\n#undef HAVE_SPAWN_H\n\n/* Define if your compiler provides ssize_t */\n#define HAVE_SSIZE_T    1\n\n/* Define to 1 if you have the 'statvfs' function. */\n#undef HAVE_STATVFS\n\n/* Define if you have struct stat.st_mtim.tv_nsec */\n#undef HAVE_STAT_TV_NSEC\n\n/* Define if you have struct stat.st_mtimensec */\n#undef HAVE_STAT_TV_NSEC2\n\n/* Define if your compiler supports variable length function prototypes (e.g.\n   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */\n#define HAVE_STDARG_PROTOTYPES          1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H   1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H   1\n\n/* Define to 1 if you have the 'strdup' function. */\n#define HAVE_STRDUP     1\n\n/* Define to 1 if you have the 'strftime' function. */\n#define HAVE_STRFTIME   1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H   1\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#undef HAVE_STROPTS_H\n\n/* Define to 1 if 'st_birthtime' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BIRTHTIME   1\n\n/* Define to 1 if 'st_blksize' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BLKSIZE     1\n\n/* Define to 1 if 'st_blocks' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_BLOCKS\n\n/* Define to 1 if 'st_flags' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_FLAGS\n\n/* Define to 1 if 'st_gen' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_GEN\n\n/* Define to 1 if 'st_rdev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_RDEV\n\n/* Define to 1 if 'st_dev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_DEV\n\n/* Define to 1 if 'st_ino' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_INO\n\n/* Define to 1 if 'tm_zone' is a member of 'struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if your 'struct stat' has 'st_blocks'. Deprecated, use\n   'HAVE_STRUCT_STAT_ST_BLOCKS' instead. */\n#undef HAVE_ST_BLOCKS\n\n/* Define if you have the 'symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the 'sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the <sysexits.h> header file. */\n#undef HAVE_SYSEXITS_H\n\n/* Define to 1 if you have the <sys/audioio.h> header file. */\n#undef HAVE_SYS_AUDIOIO_H\n\n/* Define to 1 if you have the <sys/bsdtty.h> header file. */\n#undef HAVE_SYS_BSDTTY_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/epoll.h> header file. */\n#undef HAVE_SYS_EPOLL_H\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n#undef HAVE_SYS_EVENT_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/loadavg.h> header file. */\n#undef HAVE_SYS_LOADAVG_H\n\n/* Define to 1 if you have the <sys/lock.h> header file. */\n#undef HAVE_SYS_LOCK_H\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n#undef HAVE_SYS_MKDEV_H\n\n/* Define to 1 if you have the <sys/modem.h> header file. */\n#undef HAVE_SYS_MODEM_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#define HAVE_SYS_PARAM_H    1\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#define HAVE_SYS_POLL_H                 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H   1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H               1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H               1\n\n/* Define to 1 if you have the <sys/statvfs.h> header file. */\n#undef HAVE_SYS_STATVFS_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H   1\n\n/* Define to 1 if you have the <sys/termio.h> header file. */\n#undef HAVE_SYS_TERMIO_H\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n#undef HAVE_SYS_TIMES_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H     1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H    1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#undef HAVE_SYS_UTSNAME_H\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the system() command. */\n#define HAVE_SYSTEM       1\n\n/* Define to 1 if you have the 'tcgetpgrp' function. */\n#undef HAVE_TCGETPGRP\n\n/* Define to 1 if you have the 'tcsetpgrp' function. */\n#undef HAVE_TCSETPGRP\n\n/* Define to 1 if you have the 'tempnam' function. */\n#define HAVE_TEMPNAM      1\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <term.h> header file. */\n#undef HAVE_TERM_H\n\n/* Define to 1 if you have the 'tgamma' function. */\n#undef HAVE_TGAMMA\n\n/* Define to 1 if you have the <thread.h> header file. */\n#undef HAVE_THREAD_H\n\n/* Define to 1 if you have the 'timegm' function. */\n#undef HAVE_TIMEGM\n\n/* Define to 1 if you have the 'times' function. */\n#undef HAVE_TIMES\n\n/* Define to 1 if you have the 'tmpfile' function. */\n#define HAVE_TMPFILE    1\n\n/* Define to 1 if you have the 'tmpnam' function. */\n#define HAVE_TMPNAM     1\n\n/* Define to 1 if you have the 'tmpnam_r' function. */\n#undef HAVE_TMPNAM_R\n\n/* Define to 1 if your 'struct tm' has 'tm_zone'. Deprecated, use\n   'HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the 'truncate' function. */\n#undef HAVE_TRUNCATE\n\n/* Define to 1 if you don't have 'tm_zone' but do have the external array\n   'tzname'. */\n#undef HAVE_TZNAME\n\n/* Define this if you have tcl and TCL_UTF_MAX==6 */\n#undef HAVE_UCS4_TCL\n\n/* Define if your compiler provides uint32_t. */\n#undef HAVE_UINT32_T\n\n/* Define if your compiler provides uint64_t. */\n#undef HAVE_UINT64_T\n\n/* Define to 1 if the system has the type 'uintptr_t'. */\n#define HAVE_UINTPTR_T    1\n\n/* Define to 1 if you have the 'uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H                   1\n\n/* Define to 1 if you have the 'unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define if you have a useable wchar_t type defined in wchar.h; useable means\n   wchar_t must be an unsigned type with at least 16 bits. (see\n   Include/unicodeobject.h). */\n#define HAVE_USABLE_WCHAR_T             1\n\n/* Define to 1 if you have the <util.h> header file. */\n#undef HAVE_UTIL_H\n\n/* Define to 1 if you have the 'utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H    1\n\n/* Define to 1 if you have the 'wait3' function. */\n#undef HAVE_WAIT3\n\n/* Define to 1 if you have the 'wait4' function. */\n#undef HAVE_WAIT4\n\n/* Define to 1 if you have the 'waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define if the compiler provides a wchar.h header file. */\n#define HAVE_WCHAR_H    1\n\n/* Define to 1 if you have the 'wcscoll' function. */\n#define HAVE_WCSCOLL    1\n\n/* Define if tzset() actually switches the local timezone in a meaningful way.\n   */\n#undef HAVE_WORKING_TZSET\n\n/* Define if the zlib library has inflateCopy */\n#undef HAVE_ZLIB_COPY\n\n/* Define to 1 if you have the '_getpty' function. */\n#undef HAVE__GETPTY\n\n/* Define if you are using Mach cthreads directly under /include */\n#undef HURD_C_THREADS\n\n/* Define if you are using Mach cthreads under mach / */\n#undef MACH_C_THREADS\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in <mkdev.h>.\n   */\n#undef MAJOR_IN_MKDEV\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in\n   <sysmacros.h>. */\n#undef MAJOR_IN_SYSMACROS\n\n/* Define if mvwdelch in curses.h is an expression. */\n#undef MVWDELCH_IS_EXPRESSION\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT   \"edk2-devel@lists.01.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME    \"EDK II Python 2.7.10 Package\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING  \"EDK II Python 2.7.10 Package V0.1\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME   \"EADK_Python\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL   \"http://www.tianocore.org/\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION  \"V0.1\"\n\n/* Define if POSIX semaphores aren't enabled on your system */\n#define POSIX_SEMAPHORES_NOT_ENABLED    1\n\n/* Defined if PTHREAD_SCOPE_SYSTEM supported. */\n#undef PTHREAD_SYSTEM_SCHED_SUPPORTED\n\n/* Define as the preferred size in bits of long digits */\n#undef PYLONG_BITS_IN_DIGIT\n\n/* Define to printf format modifier for long long type */\n#define PY_FORMAT_LONG_LONG   \"ll\"\n\n/* Define to printf format modifier for Py_ssize_t */\n#define PY_FORMAT_SIZE_T    \"z\"\n\n/* Define as the integral type used for Unicode representation. */\n#define PY_UNICODE_TYPE     wchar_t\n\n/* Define if you want to build an interpreter with many run-time checks. */\n#undef Py_DEBUG\n\n/* Defined if Python is built as a shared library. */\n#undef Py_ENABLE_SHARED\n\n/* Define as the size of the unicode type. */\n#define Py_UNICODE_SIZE   2\n\n/* Define if you want to have a Unicode type. */\n#define Py_USING_UNICODE\n\n/* assume C89 semantics that RETSIGTYPE is always void */\n#undef RETSIGTYPE\n\n/* Define if setpgrp() must be called as setpgrp(0, 0). */\n#undef SETPGRP_HAVE_ARG\n\n/* Define this to be extension of shared libraries (including the dot!). */\n#undef SHLIB_EXT\n\n/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */\n#undef SIGNED_RIGHT_SHIFT_ZERO_FILLS\n\n/* The size of 'double', as computed by sizeof. */\n#define SIZEOF_DOUBLE     8\n\n/* The size of 'float', as computed by sizeof. */\n#define SIZEOF_FLOAT      4\n\n/* The size of 'fpos_t', as computed by sizeof. */\n#define SIZEOF_FPOS_T     8\n\n/* The size of 'int', as computed by sizeof. */\n#define SIZEOF_INT        4\n\n/* The size of 'long', as computed by sizeof. */\n#if defined(_MSC_VER)           /* Handle Microsoft VC++ compiler specifics. */\n#define SIZEOF_LONG       4\n#else\n#define SIZEOF_LONG       8\n#endif\n\n/* The size of 'long double', as computed by sizeof. */\n#undef SIZEOF_LONG_DOUBLE\n\n/* The size of 'long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG  8\n\n/* The size of 'off_t', as computed by sizeof. */\n#define SIZEOF_OFF_T      8\n\n/* The size of 'pid_t', as computed by sizeof. */\n#define SIZEOF_PID_T      4\n\n/* The size of 'pthread_t', as computed by sizeof. */\n#undef SIZEOF_PTHREAD_T\n\n/* The size of 'short', as computed by sizeof. */\n#define SIZEOF_SHORT      2\n\n/* The size of 'size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T     8\n\n/* The size of 'time_t', as computed by sizeof. */\n#define SIZEOF_TIME_T     4\n\n/* The size of 'uintptr_t', as computed by sizeof. */\n#define SIZEOF_UINTPTR_T  8\n\n/* The size of 'void *', as computed by sizeof. */\n#define SIZEOF_VOID_P     8\n\n/* The size of 'wchar_t', as computed by sizeof. */\n#define SIZEOF_WCHAR_T    2\n\n/* The size of '_Bool', as computed by sizeof. */\n#define SIZEOF__BOOL      1\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS    1\n\n/* Define if you can safely include both <sys/select.h> and <sys/time.h>\n   (which you can't on SCO ODT 3.0). */\n#undef SYS_SELECT_WITH_SYS_TIME\n\n/* Define if tanh(-0.) is -0., or if platform doesn't have signed zeros */\n#undef TANH_PRESERVES_ZERO_SIGN\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if your <sys/time.h> declares 'struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Enable extensions on AIX 3, Interix.  */\n#ifndef _ALL_SOURCE\n# undef _ALL_SOURCE\n#endif\n/* Enable GNU extensions on systems that have them.  */\n#ifndef _GNU_SOURCE\n# undef _GNU_SOURCE\n#endif\n/* Enable threading extensions on Solaris.  */\n#ifndef _POSIX_PTHREAD_SEMANTICS\n# undef _POSIX_PTHREAD_SEMANTICS\n#endif\n/* Enable extensions on HP NonStop.  */\n#ifndef _TANDEM_SOURCE\n# undef _TANDEM_SOURCE\n#endif\n/* Enable general extensions on Solaris.  */\n#ifndef __EXTENSIONS__\n# undef __EXTENSIONS__\n#endif\n\n\n/* Define if you want to use MacPython modules on MacOSX in unix-Python. */\n#undef USE_TOOLBOX_OBJECT_GLUE\n\n/* Define if a va_list is an array of some kind */\n#undef VA_LIST_IS_ARRAY\n\n/* Define if you want SIGFPE handled (see Include/pyfpe.h). */\n#undef WANT_SIGFPE_HANDLER\n\n/* Define if you want wctype.h functions to be used instead of the one\n   supplied by Python itself. (see Include/unicodectype.h). */\n#define WANT_WCTYPE_FUNCTIONS   1\n\n/* Define if WINDOW in curses.h offers a field _flags. */\n#undef WINDOW_HAS_FLAGS\n\n/* Define if you want documentation strings in extension modules */\n#undef WITH_DOC_STRINGS\n\n/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic\n   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).\n   Dyld is necessary to support frameworks. */\n#undef WITH_DYLD\n\n/* Define to 1 if libintl is needed for locale functions. */\n#undef WITH_LIBINTL\n\n/* Define if you want to produce an OpenStep/Rhapsody framework (shared\n   library plus accessory files). */\n#undef WITH_NEXT_FRAMEWORK\n\n/* Define if you want to compile in Python-specific mallocs */\n#undef WITH_PYMALLOC\n\n/* Define if you want to compile in rudimentary thread support */\n#undef WITH_THREAD\n\n/* Define to profile with the Pentium timestamp counter */\n#undef WITH_TSC\n\n/* Define if you want pymalloc to be disabled when running under valgrind */\n#undef WITH_VALGRIND\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define if arithmetic is subject to x87-style double rounding issue */\n#undef X87_DOUBLE_ROUNDING\n\n/* Define on OpenBSD to activate all library features */\n#undef _BSD_SOURCE\n\n/* Define on Irix to enable u_int */\n#undef _BSD_TYPES\n\n/* Define on Darwin to activate all library features */\n#undef _DARWIN_C_SOURCE\n\n/* This must be set to 64 on some systems to enable large file support. */\n#undef _FILE_OFFSET_BITS\n\n/* Define on Linux to activate all library features */\n#undef _GNU_SOURCE\n\n/* This must be defined on some systems to enable large file support. */\n#undef _LARGEFILE_SOURCE\n\n/* This must be defined on AIX systems to enable large file support. */\n#undef _LARGE_FILES\n\n/* Define to 1 if on MINIX. */\n#undef _MINIX\n\n/* Define on NetBSD to activate all library features */\n#define _NETBSD_SOURCE  1\n\n/* Define _OSF_SOURCE to get the makedev macro. */\n#undef _OSF_SOURCE\n\n/* Define to 2 if the system does not provide POSIX.1 features except with\n   this defined. */\n#undef _POSIX_1_SOURCE\n\n/* Define to activate features from IEEE Stds 1003.1-2001 */\n#undef _POSIX_C_SOURCE\n\n/* Define to 1 if you need to in order for 'stat' and other things to work. */\n#undef _POSIX_SOURCE\n\n/* Define if you have POSIX threads, and your system does not define that. */\n#undef _POSIX_THREADS\n\n/* Define to force use of thread-safe errno, h_errno, and other functions */\n#undef _REENTRANT\n\n/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT32_T\n\n/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT64_T\n\n/* Define to the level of X/Open that your system supports */\n#undef _XOPEN_SOURCE\n\n/* Define to activate Unix95-and-earlier features */\n#undef _XOPEN_SOURCE_EXTENDED\n\n/* Define on FreeBSD to activate all library features */\n#undef __BSD_VISIBLE\n\n/* Define to 1 if type 'char' is unsigned and you are not using gcc.  */\n#ifndef __CHAR_UNSIGNED__\n# undef __CHAR_UNSIGNED__\n#endif\n\n/* Defined on Solaris to see additional function prototypes. */\n#undef __EXTENSIONS__\n\n/* Define to 'long' if <time.h> doesn't define. */\n//#undef clock_t\n\n/* Define to empty if 'const' does not conform to ANSI C. */\n//#undef const\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef gid_t\n\n/* Define to the type of a signed integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int32_t\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int64_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef mode_t\n\n/* Define to 'long int' if <sys/types.h> does not define. */\n//#undef off_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef pid_t\n\n/* Define to empty if the keyword does not work. */\n//#undef signed\n\n/* Define to 'unsigned int' if <sys/types.h> does not define. */\n//#undef size_t\n\n/* Define to 'int' if <sys/socket.h> does not define. */\n//#undef socklen_t\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef uid_t\n\n/* Define to the type of an unsigned integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint32_t\n\n/* Define to the type of an unsigned integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint64_t\n\n/* Define to empty if the keyword does not work. */\n//#undef volatile\n\n#endif /*Py_PYCONFIG_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Python/sysmodule.c": "\n/* System module */\n\n/*\nVarious bits of information used by the interpreter are collected in\nmodule 'sys'.\nFunction member:\n- exit(sts): raise SystemExit\nData members:\n- stdin, stdout, stderr: standard file objects\n- modules: the table of modules (dictionary)\n- path: module search path (list of strings)\n- argv: script arguments (list of strings)\n- ps1, ps2: optional primary and secondary prompts (strings)\n*/\n\n#include \"Python.h\"\n#include \"structseq.h\"\n#include \"code.h\"\n#include \"frameobject.h\"\n#include \"eval.h\"\n\n#include \"osdefs.h\"\n\n#ifdef MS_WINDOWS\n#define WIN32_LEAN_AND_MEAN\n#include \"windows.h\"\n#endif /* MS_WINDOWS */\n\n#ifdef MS_COREDLL\nextern void *PyWin_DLLhModule;\n/* A string loaded from the DLL at startup: */\nextern const char *PyWin_DLLVersionString;\n#endif\n\n#ifdef __VMS\n#include <unixlib.h>\n#endif\n\n#ifdef MS_WINDOWS\n#include <windows.h>\n#endif\n\n#ifdef HAVE_LANGINFO_H\n#include <locale.h>\n#include <langinfo.h>\n#endif\n\nPyObject *\nPySys_GetObject(char *name)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *sd = tstate->interp->sysdict;\n    if (sd == NULL)\n        return NULL;\n    return PyDict_GetItemString(sd, name);\n}\n\nFILE *\nPySys_GetFile(char *name, FILE *def)\n{\n    FILE *fp = NULL;\n    PyObject *v = PySys_GetObject(name);\n    if (v != NULL && PyFile_Check(v))\n        fp = PyFile_AsFile(v);\n    if (fp == NULL)\n        fp = def;\n    return fp;\n}\n\nint\nPySys_SetObject(char *name, PyObject *v)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *sd = tstate->interp->sysdict;\n    if (v == NULL) {\n        if (PyDict_GetItemString(sd, name) == NULL)\n            return 0;\n        else\n            return PyDict_DelItemString(sd, name);\n    }\n    else\n        return PyDict_SetItemString(sd, name, v);\n}\n\nstatic PyObject *\nsys_displayhook(PyObject *self, PyObject *o)\n{\n    PyObject *outf;\n    PyInterpreterState *interp = PyThreadState_GET()->interp;\n    PyObject *modules = interp->modules;\n    PyObject *builtins = PyDict_GetItemString(modules, \"__builtin__\");\n\n    if (builtins == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"lost __builtin__\");\n        return NULL;\n    }\n\n    /* Print value except if None */\n    /* After printing, also assign to '_' */\n    /* Before, set '_' to None to avoid recursion */\n    if (o == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    if (PyObject_SetAttrString(builtins, \"_\", Py_None) != 0)\n        return NULL;\n    if (Py_FlushLine() != 0)\n        return NULL;\n    outf = PySys_GetObject(\"stdout\");\n    if (outf == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"lost sys.stdout\");\n        return NULL;\n    }\n    if (PyFile_WriteObject(o, outf, 0) != 0)\n        return NULL;\n    PyFile_SoftSpace(outf, 1);\n    if (Py_FlushLine() != 0)\n        return NULL;\n    if (PyObject_SetAttrString(builtins, \"_\", o) != 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(displayhook_doc,\n\"displayhook(object) -> None\\n\"\n\"\\n\"\n\"Print an object to sys.stdout and also save it in __builtin__._\\n\"\n);\n\nstatic PyObject *\nsys_excepthook(PyObject* self, PyObject* args)\n{\n    PyObject *exc, *value, *tb;\n    if (!PyArg_UnpackTuple(args, \"excepthook\", 3, 3, &exc, &value, &tb))\n        return NULL;\n    PyErr_Display(exc, value, tb);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(excepthook_doc,\n\"excepthook(exctype, value, traceback) -> None\\n\"\n\"\\n\"\n\"Handle an exception by displaying it with a traceback on sys.stderr.\\n\"\n);\n\nstatic PyObject *\nsys_exc_info(PyObject *self, PyObject *noargs)\n{\n    PyThreadState *tstate;\n    tstate = PyThreadState_GET();\n    return Py_BuildValue(\n        \"(OOO)\",\n        tstate->exc_type != NULL ? tstate->exc_type : Py_None,\n        tstate->exc_value != NULL ? tstate->exc_value : Py_None,\n        tstate->exc_traceback != NULL ?\n            tstate->exc_traceback : Py_None);\n}\n\nPyDoc_STRVAR(exc_info_doc,\n\"exc_info() -> (type, value, traceback)\\n\\\n\\n\\\nReturn information about the most recent exception caught by an except\\n\\\nclause in the current stack frame or in an older stack frame.\"\n);\n\nstatic PyObject *\nsys_exc_clear(PyObject *self, PyObject *noargs)\n{\n    PyThreadState *tstate;\n    PyObject *tmp_type, *tmp_value, *tmp_tb;\n\n    if (PyErr_WarnPy3k(\"sys.exc_clear() not supported in 3.x; \"\n                       \"use except clauses\", 1) < 0)\n        return NULL;\n\n    tstate = PyThreadState_GET();\n    tmp_type = tstate->exc_type;\n    tmp_value = tstate->exc_value;\n    tmp_tb = tstate->exc_traceback;\n    tstate->exc_type = NULL;\n    tstate->exc_value = NULL;\n    tstate->exc_traceback = NULL;\n    Py_XDECREF(tmp_type);\n    Py_XDECREF(tmp_value);\n    Py_XDECREF(tmp_tb);\n    /* For b/w compatibility */\n    PySys_SetObject(\"exc_type\", Py_None);\n    PySys_SetObject(\"exc_value\", Py_None);\n    PySys_SetObject(\"exc_traceback\", Py_None);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(exc_clear_doc,\n\"exc_clear() -> None\\n\\\n\\n\\\nClear global information on the current exception.  Subsequent calls to\\n\\\nexc_info() will return (None,None,None) until another exception is raised\\n\\\nin the current thread or the execution stack returns to a frame where\\n\\\nanother exception is being handled.\"\n);\n\nstatic PyObject *\nsys_exit(PyObject *self, PyObject *args)\n{\n    PyObject *exit_code = 0;\n    if (!PyArg_UnpackTuple(args, \"exit\", 0, 1, &exit_code))\n        return NULL;\n    /* Raise SystemExit so callers may catch it or clean up. */\n    PyErr_SetObject(PyExc_SystemExit, exit_code);\n    return NULL;\n}\n\nPyDoc_STRVAR(exit_doc,\n\"exit([status])\\n\\\n\\n\\\nExit the interpreter by raising SystemExit(status).\\n\\\nIf the status is omitted or None, it defaults to zero (i.e., success).\\n\\\nIf the status is an integer, it will be used as the system exit status.\\n\\\nIf it is another kind of object, it will be printed and the system\\n\\\nexit status will be one (i.e., failure).\"\n);\n\n#ifdef Py_USING_UNICODE\n\nstatic PyObject *\nsys_getdefaultencoding(PyObject *self)\n{\n    return PyString_FromString(PyUnicode_GetDefaultEncoding());\n}\n\nPyDoc_STRVAR(getdefaultencoding_doc,\n\"getdefaultencoding() -> string\\n\\\n\\n\\\nReturn the current default string encoding used by the Unicode \\n\\\nimplementation.\"\n);\n\nstatic PyObject *\nsys_setdefaultencoding(PyObject *self, PyObject *args)\n{\n    char *encoding;\n    if (!PyArg_ParseTuple(args, \"s:setdefaultencoding\", &encoding))\n        return NULL;\n    if (PyUnicode_SetDefaultEncoding(encoding))\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setdefaultencoding_doc,\n\"setdefaultencoding(encoding)\\n\\\n\\n\\\nSet the current default string encoding used by the Unicode implementation.\"\n);\n\nstatic PyObject *\nsys_getfilesystemencoding(PyObject *self)\n{\n    if (Py_FileSystemDefaultEncoding)\n        return PyString_FromString(Py_FileSystemDefaultEncoding);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(getfilesystemencoding_doc,\n\"getfilesystemencoding() -> string\\n\\\n\\n\\\nReturn the encoding used to convert Unicode filenames in\\n\\\noperating system filenames.\"\n);\n\n#endif\n\n/*\n * Cached interned string objects used for calling the profile and\n * trace functions.  Initialized by trace_init().\n */\nstatic PyObject *whatstrings[7] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL};\n\nstatic int\ntrace_init(void)\n{\n    static char *whatnames[7] = {\"call\", \"exception\", \"line\", \"return\",\n                                    \"c_call\", \"c_exception\", \"c_return\"};\n    PyObject *name;\n    int i;\n    for (i = 0; i < 7; ++i) {\n        if (whatstrings[i] == NULL) {\n            name = PyString_InternFromString(whatnames[i]);\n            if (name == NULL)\n                return -1;\n            whatstrings[i] = name;\n        }\n    }\n    return 0;\n}\n\n\nstatic PyObject *\ncall_trampoline(PyThreadState *tstate, PyObject* callback,\n                PyFrameObject *frame, int what, PyObject *arg)\n{\n    PyObject *args = PyTuple_New(3);\n    PyObject *whatstr;\n    PyObject *result;\n\n    if (args == NULL)\n        return NULL;\n    Py_INCREF(frame);\n    whatstr = whatstrings[what];\n    Py_INCREF(whatstr);\n    if (arg == NULL)\n        arg = Py_None;\n    Py_INCREF(arg);\n    PyTuple_SET_ITEM(args, 0, (PyObject *)frame);\n    PyTuple_SET_ITEM(args, 1, whatstr);\n    PyTuple_SET_ITEM(args, 2, arg);\n\n    /* call the Python-level function */\n    PyFrame_FastToLocals(frame);\n    result = PyEval_CallObject(callback, args);\n    PyFrame_LocalsToFast(frame, 1);\n    if (result == NULL)\n        PyTraceBack_Here(frame);\n\n    /* cleanup */\n    Py_DECREF(args);\n    return result;\n}\n\nstatic int\nprofile_trampoline(PyObject *self, PyFrameObject *frame,\n                   int what, PyObject *arg)\n{\n    PyThreadState *tstate = frame->f_tstate;\n    PyObject *result;\n\n    if (arg == NULL)\n        arg = Py_None;\n    result = call_trampoline(tstate, self, frame, what, arg);\n    if (result == NULL) {\n        PyEval_SetProfile(NULL, NULL);\n        return -1;\n    }\n    Py_DECREF(result);\n    return 0;\n}\n\nstatic int\ntrace_trampoline(PyObject *self, PyFrameObject *frame,\n                 int what, PyObject *arg)\n{\n    PyThreadState *tstate = frame->f_tstate;\n    PyObject *callback;\n    PyObject *result;\n\n    if (what == PyTrace_CALL)\n        callback = self;\n    else\n        callback = frame->f_trace;\n    if (callback == NULL)\n        return 0;\n    result = call_trampoline(tstate, callback, frame, what, arg);\n    if (result == NULL) {\n        PyEval_SetTrace(NULL, NULL);\n        Py_CLEAR(frame->f_trace);\n        return -1;\n    }\n    if (result != Py_None) {\n        PyObject *temp = frame->f_trace;\n        frame->f_trace = NULL;\n        Py_XDECREF(temp);\n        frame->f_trace = result;\n    }\n    else {\n        Py_DECREF(result);\n    }\n    return 0;\n}\n\nstatic PyObject *\nsys_settrace(PyObject *self, PyObject *args)\n{\n    if (trace_init() == -1)\n        return NULL;\n    if (args == Py_None)\n        PyEval_SetTrace(NULL, NULL);\n    else\n        PyEval_SetTrace(trace_trampoline, args);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(settrace_doc,\n\"settrace(function)\\n\\\n\\n\\\nSet the global debug tracing function.  It will be called on each\\n\\\nfunction call.  See the debugger chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_gettrace(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *temp = tstate->c_traceobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    Py_INCREF(temp);\n    return temp;\n}\n\nPyDoc_STRVAR(gettrace_doc,\n\"gettrace()\\n\\\n\\n\\\nReturn the global debug tracing function set with sys.settrace.\\n\\\nSee the debugger chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_setprofile(PyObject *self, PyObject *args)\n{\n    if (trace_init() == -1)\n        return NULL;\n    if (args == Py_None)\n        PyEval_SetProfile(NULL, NULL);\n    else\n        PyEval_SetProfile(profile_trampoline, args);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setprofile_doc,\n\"setprofile(function)\\n\\\n\\n\\\nSet the profiling function.  It will be called on each function call\\n\\\nand return.  See the profiler chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_getprofile(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *temp = tstate->c_profileobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    Py_INCREF(temp);\n    return temp;\n}\n\nPyDoc_STRVAR(getprofile_doc,\n\"getprofile()\\n\\\n\\n\\\nReturn the profiling function set with sys.setprofile.\\n\\\nSee the profiler chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_setcheckinterval(PyObject *self, PyObject *args)\n{\n    if (!PyArg_ParseTuple(args, \"i:setcheckinterval\", &_Py_CheckInterval))\n        return NULL;\n    _Py_Ticker = _Py_CheckInterval;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setcheckinterval_doc,\n\"setcheckinterval(n)\\n\\\n\\n\\\nTell the Python interpreter to check for asynchronous events every\\n\\\nn instructions.  This also affects how often thread switches occur.\"\n);\n\nstatic PyObject *\nsys_getcheckinterval(PyObject *self, PyObject *args)\n{\n    return PyInt_FromLong(_Py_CheckInterval);\n}\n\nPyDoc_STRVAR(getcheckinterval_doc,\n\"getcheckinterval() -> current check interval; see setcheckinterval().\"\n);\n\n#ifdef WITH_TSC\nstatic PyObject *\nsys_settscdump(PyObject *self, PyObject *args)\n{\n    int bool;\n    PyThreadState *tstate = PyThreadState_Get();\n\n    if (!PyArg_ParseTuple(args, \"i:settscdump\", &bool))\n        return NULL;\n    if (bool)\n        tstate->interp->tscdump = 1;\n    else\n        tstate->interp->tscdump = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n\n}\n\nPyDoc_STRVAR(settscdump_doc,\n\"settscdump(bool)\\n\\\n\\n\\\nIf true, tell the Python interpreter to dump VM measurements to\\n\\\nstderr.  If false, turn off dump.  The measurements are based on the\\n\\\nprocessor's time-stamp counter.\"\n);\n#endif /* TSC */\n\nstatic PyObject *\nsys_setrecursionlimit(PyObject *self, PyObject *args)\n{\n    int new_limit;\n    if (!PyArg_ParseTuple(args, \"i:setrecursionlimit\", &new_limit))\n        return NULL;\n    if (new_limit <= 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"recursion limit must be positive\");\n        return NULL;\n    }\n    Py_SetRecursionLimit(new_limit);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setrecursionlimit_doc,\n\"setrecursionlimit(n)\\n\\\n\\n\\\nSet the maximum depth of the Python interpreter stack to n.  This\\n\\\nlimit prevents infinite recursion from causing an overflow of the C\\n\\\nstack and crashing Python.  The highest possible limit is platform-\\n\\\ndependent.\"\n);\n\nstatic PyObject *\nsys_getrecursionlimit(PyObject *self)\n{\n    return PyInt_FromLong(Py_GetRecursionLimit());\n}\n\nPyDoc_STRVAR(getrecursionlimit_doc,\n\"getrecursionlimit()\\n\\\n\\n\\\nReturn the current value of the recursion limit, the maximum depth\\n\\\nof the Python interpreter stack.  This limit prevents infinite\\n\\\nrecursion from causing an overflow of the C stack and crashing Python.\"\n);\n\n#ifdef MS_WINDOWS\nPyDoc_STRVAR(getwindowsversion_doc,\n\"getwindowsversion()\\n\\\n\\n\\\nReturn information about the running version of Windows as a named tuple.\\n\\\nThe members are named: major, minor, build, platform, service_pack,\\n\\\nservice_pack_major, service_pack_minor, suite_mask, and product_type. For\\n\\\nbackward compatibility, only the first 5 items are available by indexing.\\n\\\nAll elements are numbers, except service_pack which is a string. Platform\\n\\\nmay be 0 for win32s, 1 for Windows 9x/ME, 2 for Windows NT/2000/XP/Vista/7,\\n\\\n3 for Windows CE. Product_type may be 1 for a workstation, 2 for a domain\\n\\\ncontroller, 3 for a server.\"\n);\n\nstatic PyTypeObject WindowsVersionType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field windows_version_fields[] = {\n    {\"major\", \"Major version number\"},\n    {\"minor\", \"Minor version number\"},\n    {\"build\", \"Build number\"},\n    {\"platform\", \"Operating system platform\"},\n    {\"service_pack\", \"Latest Service Pack installed on the system\"},\n    {\"service_pack_major\", \"Service Pack major version number\"},\n    {\"service_pack_minor\", \"Service Pack minor version number\"},\n    {\"suite_mask\", \"Bit mask identifying available product suites\"},\n    {\"product_type\", \"System product type\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc windows_version_desc = {\n    \"sys.getwindowsversion\",  /* name */\n    getwindowsversion_doc,    /* doc */\n    windows_version_fields,   /* fields */\n    5                         /* For backward compatibility,\n                                 only the first 5 items are accessible\n                                 via indexing, the rest are name only */\n};\n\nstatic PyObject *\nsys_getwindowsversion(PyObject *self)\n{\n    PyObject *version;\n    int pos = 0;\n    OSVERSIONINFOEX ver;\n    ver.dwOSVersionInfoSize = sizeof(ver);\n    if (!GetVersionEx((OSVERSIONINFO*) &ver))\n        return PyErr_SetFromWindowsErr(0);\n\n    version = PyStructSequence_New(&WindowsVersionType);\n    if (version == NULL)\n        return NULL;\n\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwMajorVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwMinorVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwBuildNumber));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwPlatformId));\n    PyStructSequence_SET_ITEM(version, pos++, PyString_FromString(ver.szCSDVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wServicePackMajor));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wServicePackMinor));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wSuiteMask));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wProductType));\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(version);\n        return NULL;\n    }\n    return version;\n}\n\n#endif /* MS_WINDOWS */\n\n#ifdef HAVE_DLOPEN\nstatic PyObject *\nsys_setdlopenflags(PyObject *self, PyObject *args)\n{\n    int new_val;\n    PyThreadState *tstate = PyThreadState_GET();\n    if (!PyArg_ParseTuple(args, \"i:setdlopenflags\", &new_val))\n        return NULL;\n    if (!tstate)\n        return NULL;\n    tstate->interp->dlopenflags = new_val;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setdlopenflags_doc,\n\"setdlopenflags(n) -> None\\n\\\n\\n\\\nSet the flags used by the interpreter for dlopen calls, such as when the\\n\\\ninterpreter loads extension modules.  Among other things, this will enable\\n\\\na lazy resolving of symbols when importing a module, if called as\\n\\\nsys.setdlopenflags(0).  To share symbols across extension modules, call as\\n\\\nsys.setdlopenflags(ctypes.RTLD_GLOBAL).  Symbolic names for the flag modules\\n\\\ncan be either found in the ctypes module, or in the DLFCN module. If DLFCN\\n\\\nis not available, it can be generated from /usr/include/dlfcn.h using the\\n\\\nh2py script.\");\n\nstatic PyObject *\nsys_getdlopenflags(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    if (!tstate)\n        return NULL;\n    return PyInt_FromLong(tstate->interp->dlopenflags);\n}\n\nPyDoc_STRVAR(getdlopenflags_doc,\n\"getdlopenflags() -> int\\n\\\n\\n\\\nReturn the current value of the flags that are used for dlopen calls.\\n\\\nThe flag constants are defined in the ctypes and DLFCN modules.\");\n\n#endif  /* HAVE_DLOPEN */\n\n#ifdef USE_MALLOPT\n/* Link with -lmalloc (or -lmpc) on an SGI */\n#include <malloc.h>\n\nstatic PyObject *\nsys_mdebug(PyObject *self, PyObject *args)\n{\n    int flag;\n    if (!PyArg_ParseTuple(args, \"i:mdebug\", &flag))\n        return NULL;\n    mallopt(M_DEBUG, flag);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n#endif /* USE_MALLOPT */\n\nsize_t\n_PySys_GetSizeOf(PyObject *o)\n{\n    static PyObject *str__sizeof__ = NULL;\n    PyObject *res = NULL;\n    Py_ssize_t size;\n\n    /* Make sure the type is initialized. float gets initialized late */\n    if (PyType_Ready(Py_TYPE(o)) < 0)\n        return (size_t)-1;\n\n    /* Instance of old-style class */\n    if (PyInstance_Check(o))\n        size = PyInstance_Type.tp_basicsize;\n    /* all other objects */\n    else {\n        PyObject *method = _PyObject_LookupSpecial(o, \"__sizeof__\",\n                                                   &str__sizeof__);\n        if (method == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_TypeError,\n                             \"Type %.100s doesn't define __sizeof__\",\n                             Py_TYPE(o)->tp_name);\n        }\n        else {\n            res = PyObject_CallFunctionObjArgs(method, NULL);\n            Py_DECREF(method);\n        }\n\n        if (res == NULL)\n            return (size_t)-1;\n\n        size = (size_t)PyInt_AsSsize_t(res);\n        Py_DECREF(res);\n        if (size == -1 && PyErr_Occurred())\n            return (size_t)-1;\n    }\n\n    if (size < 0) {\n        PyErr_SetString(PyExc_ValueError, \"__sizeof__() should return >= 0\");\n        return (size_t)-1;\n    }\n\n    /* add gc_head size */\n    if (PyObject_IS_GC(o))\n        return ((size_t)size) + sizeof(PyGC_Head);\n    return (size_t)size;\n}\n\nstatic PyObject *\nsys_getsizeof(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *kwlist[] = {\"object\", \"default\", 0};\n    size_t size;\n    PyObject *o, *dflt = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|O:getsizeof\",\n                                     kwlist, &o, &dflt))\n        return NULL;\n\n    size = _PySys_GetSizeOf(o);\n\n    if (size == (size_t)-1 && PyErr_Occurred()) {\n        /* Has a default value been given */\n        if (dflt != NULL && PyErr_ExceptionMatches(PyExc_TypeError)) {\n            PyErr_Clear();\n            Py_INCREF(dflt);\n            return dflt;\n        }\n        else\n            return NULL;\n    }\n\n    return PyInt_FromSize_t(size);\n}\n\nPyDoc_STRVAR(getsizeof_doc,\n\"getsizeof(object, default) -> int\\n\\\n\\n\\\nReturn the size of object in bytes.\");\n\nstatic PyObject *\nsys_getrefcount(PyObject *self, PyObject *arg)\n{\n    return PyInt_FromSsize_t(arg->ob_refcnt);\n}\n\n#ifdef Py_REF_DEBUG\nstatic PyObject *\nsys_gettotalrefcount(PyObject *self)\n{\n    return PyInt_FromSsize_t(_Py_GetRefTotal());\n}\n#endif /* Py_REF_DEBUG */\n\nPyDoc_STRVAR(getrefcount_doc,\n\"getrefcount(object) -> integer\\n\\\n\\n\\\nReturn the reference count of object.  The count returned is generally\\n\\\none higher than you might expect, because it includes the (temporary)\\n\\\nreference as an argument to getrefcount().\"\n);\n\n#ifdef COUNT_ALLOCS\nstatic PyObject *\nsys_getcounts(PyObject *self)\n{\n    extern PyObject *get_counts(void);\n\n    return get_counts();\n}\n#endif\n\nPyDoc_STRVAR(getframe_doc,\n\"_getframe([depth]) -> frameobject\\n\\\n\\n\\\nReturn a frame object from the call stack.  If optional integer depth is\\n\\\ngiven, return the frame object that many calls below the top of the stack.\\n\\\nIf that is deeper than the call stack, ValueError is raised.  The default\\n\\\nfor depth is zero, returning the frame at the top of the call stack.\\n\\\n\\n\\\nThis function should be used for internal and specialized\\n\\\npurposes only.\"\n);\n\nstatic PyObject *\nsys_getframe(PyObject *self, PyObject *args)\n{\n    PyFrameObject *f = PyThreadState_GET()->frame;\n    int depth = -1;\n\n    if (!PyArg_ParseTuple(args, \"|i:_getframe\", &depth))\n        return NULL;\n\n    while (depth > 0 && f != NULL) {\n        f = f->f_back;\n        --depth;\n    }\n    if (f == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"call stack is not deep enough\");\n        return NULL;\n    }\n    Py_INCREF(f);\n    return (PyObject*)f;\n}\n\nPyDoc_STRVAR(current_frames_doc,\n\"_current_frames() -> dictionary\\n\\\n\\n\\\nReturn a dictionary mapping each current thread T's thread id to T's\\n\\\ncurrent stack frame.\\n\\\n\\n\\\nThis function should be used for specialized purposes only.\"\n);\n\nstatic PyObject *\nsys_current_frames(PyObject *self, PyObject *noargs)\n{\n    return _PyThread_CurrentFrames();\n}\n\nPyDoc_STRVAR(call_tracing_doc,\n\"call_tracing(func, args) -> object\\n\\\n\\n\\\nCall func(*args), while tracing is enabled.  The tracing state is\\n\\\nsaved, and restored afterwards.  This is intended to be called from\\n\\\na debugger from a checkpoint, to recursively debug some other code.\"\n);\n\nstatic PyObject *\nsys_call_tracing(PyObject *self, PyObject *args)\n{\n    PyObject *func, *funcargs;\n    if (!PyArg_ParseTuple(args, \"OO!:call_tracing\", &func, &PyTuple_Type, &funcargs))\n        return NULL;\n    return _PyEval_CallTracing(func, funcargs);\n}\n\nPyDoc_STRVAR(callstats_doc,\n\"callstats() -> tuple of integers\\n\\\n\\n\\\nReturn a tuple of function call statistics, if CALL_PROFILE was defined\\n\\\nwhen Python was built.  Otherwise, return None.\\n\\\n\\n\\\nWhen enabled, this function returns detailed, implementation-specific\\n\\\ndetails about the number of function calls executed. The return value is\\n\\\na 11-tuple where the entries in the tuple are counts of:\\n\\\n0. all function calls\\n\\\n1. calls to PyFunction_Type objects\\n\\\n2. PyFunction calls that do not create an argument tuple\\n\\\n3. PyFunction calls that do not create an argument tuple\\n\\\n   and bypass PyEval_EvalCodeEx()\\n\\\n4. PyMethod calls\\n\\\n5. PyMethod calls on bound methods\\n\\\n6. PyType calls\\n\\\n7. PyCFunction calls\\n\\\n8. generator calls\\n\\\n9. All other calls\\n\\\n10. Number of stack pops performed by call_function()\"\n);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Defined in objects.c because it uses static globals if that file */\nextern PyObject *_Py_GetObjects(PyObject *, PyObject *);\n#endif\n\n#ifdef DYNAMIC_EXECUTION_PROFILE\n/* Defined in ceval.c because it uses static globals if that file */\nextern PyObject *_Py_GetDXProfile(PyObject *,  PyObject *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic PyObject *\nsys_clear_type_cache(PyObject* self, PyObject* args)\n{\n    PyType_ClearCache();\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(sys_clear_type_cache__doc__,\n\"_clear_type_cache() -> None\\n\\\nClear the internal type lookup cache.\");\n\n\nstatic PyMethodDef sys_methods[] = {\n    /* Might as well keep this in alphabetic order */\n    {\"callstats\", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,\n     callstats_doc},\n    {\"_clear_type_cache\",       sys_clear_type_cache,     METH_NOARGS,\n     sys_clear_type_cache__doc__},\n    {\"_current_frames\", sys_current_frames, METH_NOARGS,\n     current_frames_doc},\n    {\"displayhook\",     sys_displayhook, METH_O, displayhook_doc},\n    {\"exc_info\",        sys_exc_info, METH_NOARGS, exc_info_doc},\n    {\"exc_clear\",       sys_exc_clear, METH_NOARGS, exc_clear_doc},\n    {\"excepthook\",      sys_excepthook, METH_VARARGS, excepthook_doc},\n    {\"exit\",            sys_exit, METH_VARARGS, exit_doc},\n#ifdef Py_USING_UNICODE\n    {\"getdefaultencoding\", (PyCFunction)sys_getdefaultencoding,\n     METH_NOARGS, getdefaultencoding_doc},\n#endif\n#ifdef HAVE_DLOPEN\n    {\"getdlopenflags\", (PyCFunction)sys_getdlopenflags, METH_NOARGS,\n     getdlopenflags_doc},\n#endif\n#ifdef COUNT_ALLOCS\n    {\"getcounts\",       (PyCFunction)sys_getcounts, METH_NOARGS},\n#endif\n#ifdef DYNAMIC_EXECUTION_PROFILE\n    {\"getdxp\",          _Py_GetDXProfile, METH_VARARGS},\n#endif\n#ifdef Py_USING_UNICODE\n    {\"getfilesystemencoding\", (PyCFunction)sys_getfilesystemencoding,\n     METH_NOARGS, getfilesystemencoding_doc},\n#endif\n#ifdef Py_TRACE_REFS\n    {\"getobjects\",      _Py_GetObjects, METH_VARARGS},\n#endif\n#ifdef Py_REF_DEBUG\n    {\"gettotalrefcount\", (PyCFunction)sys_gettotalrefcount, METH_NOARGS},\n#endif\n    {\"getrefcount\",     (PyCFunction)sys_getrefcount, METH_O, getrefcount_doc},\n    {\"getrecursionlimit\", (PyCFunction)sys_getrecursionlimit, METH_NOARGS,\n     getrecursionlimit_doc},\n    {\"getsizeof\",   (PyCFunction)sys_getsizeof,\n     METH_VARARGS | METH_KEYWORDS, getsizeof_doc},\n    {\"_getframe\", sys_getframe, METH_VARARGS, getframe_doc},\n#ifdef MS_WINDOWS\n    {\"getwindowsversion\", (PyCFunction)sys_getwindowsversion, METH_NOARGS,\n     getwindowsversion_doc},\n#endif /* MS_WINDOWS */\n#ifdef USE_MALLOPT\n    {\"mdebug\",          sys_mdebug, METH_VARARGS},\n#endif\n#ifdef Py_USING_UNICODE\n    {\"setdefaultencoding\", sys_setdefaultencoding, METH_VARARGS,\n     setdefaultencoding_doc},\n#endif\n    {\"setcheckinterval\",        sys_setcheckinterval, METH_VARARGS,\n     setcheckinterval_doc},\n    {\"getcheckinterval\",        sys_getcheckinterval, METH_NOARGS,\n     getcheckinterval_doc},\n#ifdef HAVE_DLOPEN\n    {\"setdlopenflags\", sys_setdlopenflags, METH_VARARGS,\n     setdlopenflags_doc},\n#endif\n    {\"setprofile\",      sys_setprofile, METH_O, setprofile_doc},\n    {\"getprofile\",      sys_getprofile, METH_NOARGS, getprofile_doc},\n    {\"setrecursionlimit\", sys_setrecursionlimit, METH_VARARGS,\n     setrecursionlimit_doc},\n#ifdef WITH_TSC\n    {\"settscdump\", sys_settscdump, METH_VARARGS, settscdump_doc},\n#endif\n    {\"settrace\",        sys_settrace, METH_O, settrace_doc},\n    {\"gettrace\",        sys_gettrace, METH_NOARGS, gettrace_doc},\n    {\"call_tracing\", sys_call_tracing, METH_VARARGS, call_tracing_doc},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyObject *\nlist_builtin_module_names(void)\n{\n    PyObject *list = PyList_New(0);\n    int i;\n    if (list == NULL)\n        return NULL;\n    for (i = 0; PyImport_Inittab[i].name != NULL; i++) {\n        PyObject *name = PyString_FromString(\n            PyImport_Inittab[i].name);\n        if (name == NULL)\n            break;\n        PyList_Append(list, name);\n        Py_DECREF(name);\n    }\n    if (PyList_Sort(list) != 0) {\n        Py_DECREF(list);\n        list = NULL;\n    }\n    if (list) {\n        PyObject *v = PyList_AsTuple(list);\n        Py_DECREF(list);\n        list = v;\n    }\n    return list;\n}\n\nstatic PyObject *warnoptions = NULL;\n\nvoid\nPySys_ResetWarnOptions(void)\n{\n    if (warnoptions == NULL || !PyList_Check(warnoptions))\n        return;\n    PyList_SetSlice(warnoptions, 0, PyList_GET_SIZE(warnoptions), NULL);\n}\n\nvoid\nPySys_AddWarnOption(char *s)\n{\n    PyObject *str;\n\n    if (warnoptions == NULL || !PyList_Check(warnoptions)) {\n        Py_XDECREF(warnoptions);\n        warnoptions = PyList_New(0);\n        if (warnoptions == NULL)\n            return;\n    }\n    str = PyString_FromString(s);\n    if (str != NULL) {\n        PyList_Append(warnoptions, str);\n        Py_DECREF(str);\n    }\n}\n\nint\nPySys_HasWarnOptions(void)\n{\n    return (warnoptions != NULL && (PyList_Size(warnoptions) > 0)) ? 1 : 0;\n}\n\n/* XXX This doc string is too long to be a single string literal in VC++ 5.0.\n   Two literals concatenated works just fine.  If you have a K&R compiler\n   or other abomination that however *does* understand longer strings,\n   get rid of the !!! comment in the middle and the quotes that surround it. */\nPyDoc_VAR(sys_doc) =\nPyDoc_STR(\n\"This module provides access to some objects used or maintained by the\\n\\\ninterpreter and to functions that interact strongly with the interpreter.\\n\\\n\\n\\\nDynamic objects:\\n\\\n\\n\\\nargv -- command line arguments; argv[0] is the script pathname if known\\n\\\npath -- module search path; path[0] is the script directory, else ''\\n\\\nmodules -- dictionary of loaded modules\\n\\\n\\n\\\ndisplayhook -- called to show results in an interactive session\\n\\\nexcepthook -- called to handle any uncaught exception other than SystemExit\\n\\\n  To customize printing in an interactive session or to install a custom\\n\\\n  top-level exception handler, assign other functions to replace these.\\n\\\n\\n\\\nexitfunc -- if sys.exitfunc exists, this routine is called when Python exits\\n\\\n  Assigning to sys.exitfunc is deprecated; use the atexit module instead.\\n\\\n\\n\\\nstdin -- standard input file object; used by raw_input() and input()\\n\\\nstdout -- standard output file object; used by the print statement\\n\\\nstderr -- standard error object; used for error messages\\n\\\n  By assigning other file objects (or objects that behave like files)\\n\\\n  to these, it is possible to redirect all of the interpreter's I/O.\\n\\\n\\n\\\nlast_type -- type of last uncaught exception\\n\\\nlast_value -- value of last uncaught exception\\n\\\nlast_traceback -- traceback of last uncaught exception\\n\\\n  These three are only available in an interactive session after a\\n\\\n  traceback has been printed.\\n\\\n\\n\\\nexc_type -- type of exception currently being handled\\n\\\nexc_value -- value of exception currently being handled\\n\\\nexc_traceback -- traceback of exception currently being handled\\n\\\n  The function exc_info() should be used instead of these three,\\n\\\n  because it is thread-safe.\\n\\\n\"\n)\n/* concatenating string here */\nPyDoc_STR(\n\"\\n\\\nStatic objects:\\n\\\n\\n\\\nfloat_info -- a dict with information about the float inplementation.\\n\\\nlong_info -- a struct sequence with information about the long implementation.\\n\\\nmaxint -- the largest supported integer (the smallest is -maxint-1)\\n\\\nmaxsize -- the largest supported length of containers.\\n\\\nmaxunicode -- the largest supported character\\n\\\nbuiltin_module_names -- tuple of module names built into this interpreter\\n\\\nversion -- the version of this interpreter as a string\\n\\\nversion_info -- version information as a named tuple\\n\\\nhexversion -- version information encoded as a single integer\\n\\\ncopyright -- copyright notice pertaining to this interpreter\\n\\\nplatform -- platform identifier\\n\\\nexecutable -- absolute path of the executable binary of the Python interpreter\\n\\\nprefix -- prefix used to find the Python library\\n\\\nexec_prefix -- prefix used to find the machine-specific Python library\\n\\\nfloat_repr_style -- string indicating the style of repr() output for floats\\n\\\n\"\n)\n#ifdef MS_WINDOWS\n/* concatenating string here */\nPyDoc_STR(\n\"dllhandle -- [Windows only] integer handle of the Python DLL\\n\\\nwinver -- [Windows only] version number of the Python DLL\\n\\\n\"\n)\n#endif /* MS_WINDOWS */\nPyDoc_STR(\n\"__stdin__ -- the original stdin; don't touch!\\n\\\n__stdout__ -- the original stdout; don't touch!\\n\\\n__stderr__ -- the original stderr; don't touch!\\n\\\n__displayhook__ -- the original displayhook; don't touch!\\n\\\n__excepthook__ -- the original excepthook; don't touch!\\n\\\n\\n\\\nFunctions:\\n\\\n\\n\\\ndisplayhook() -- print an object to the screen, and save it in __builtin__._\\n\\\nexcepthook() -- print an exception and its traceback to sys.stderr\\n\\\nexc_info() -- return thread-safe information about the current exception\\n\\\nexc_clear() -- clear the exception state for the current thread\\n\\\nexit() -- exit the interpreter by raising SystemExit\\n\\\ngetdlopenflags() -- returns flags to be used for dlopen() calls\\n\\\ngetprofile() -- get the global profiling function\\n\\\ngetrefcount() -- return the reference count for an object (plus one :-)\\n\\\ngetrecursionlimit() -- return the max recursion depth for the interpreter\\n\\\ngetsizeof() -- return the size of an object in bytes\\n\\\ngettrace() -- get the global debug tracing function\\n\\\nsetcheckinterval() -- control how often the interpreter checks for events\\n\\\nsetdlopenflags() -- set the flags to be used for dlopen() calls\\n\\\nsetprofile() -- set the global profiling function\\n\\\nsetrecursionlimit() -- set the max recursion depth for the interpreter\\n\\\nsettrace() -- set the global debug tracing function\\n\\\n\"\n)\n/* end of sys_doc */ ;\n\nstatic int\n_check_and_flush (FILE *stream)\n{\n  int prev_fail = ferror (stream);\n  return fflush (stream) || prev_fail ? EOF : 0;\n}\n\n/* Subversion branch and revision management */\nstatic int svn_initialized;\nstatic char patchlevel_revision[50]; /* Just the number */\nstatic char branch[50];\nstatic char shortbranch[50];\nstatic const char *svn_revision;\n\nstatic void\nsvnversion_init(void)\n{\n    if (svn_initialized)\n        return;\n    svn_initialized = 1;\n    *patchlevel_revision = '\\0';\n    strcpy(branch, \"\");\n    strcpy(shortbranch, \"unknown\");\n    svn_revision = \"\";\n    return;\n}\n\n/* Return svnversion output if available.\n   Else return Revision of patchlevel.h if on branch.\n   Else return empty string */\nconst char*\nPy_SubversionRevision()\n{\n    svnversion_init();\n    return svn_revision;\n}\n\nconst char*\nPy_SubversionShortBranch()\n{\n    svnversion_init();\n    return shortbranch;\n}\n\n\nPyDoc_STRVAR(flags__doc__,\n\"sys.flags\\n\\\n\\n\\\nFlags provided through command line arguments or environment vars.\");\n\nstatic PyTypeObject FlagsType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field flags_fields[] = {\n    {\"debug\",                   \"-d\"},\n    {\"py3k_warning\",            \"-3\"},\n    {\"division_warning\",        \"-Q\"},\n    {\"division_new\",            \"-Qnew\"},\n    {\"inspect\",                 \"-i\"},\n    {\"interactive\",             \"-i\"},\n    {\"optimize\",                \"-O or -OO\"},\n    {\"dont_write_bytecode\",     \"-B\"},\n    {\"no_user_site\",            \"-s\"},\n    {\"no_site\",                 \"-S\"},\n    {\"ignore_environment\",      \"-E\"},\n    {\"tabcheck\",                \"-t or -tt\"},\n    {\"verbose\",                 \"-v\"},\n#ifdef RISCOS\n    {\"riscos_wimp\",             \"???\"},\n#endif\n    /* {\"unbuffered\",                   \"-u\"}, */\n    {\"unicode\",                 \"-U\"},\n    /* {\"skip_first\",                   \"-x\"}, */\n    {\"bytes_warning\", \"-b\"},\n    {\"hash_randomization\", \"-R\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc flags_desc = {\n    \"sys.flags\",        /* name */\n    flags__doc__,       /* doc */\n    flags_fields,       /* fields */\n#ifdef RISCOS\n    17\n#else\n    16\n#endif\n};\n\nstatic PyObject*\nmake_flags(void)\n{\n    int pos = 0;\n    PyObject *seq;\n\n    seq = PyStructSequence_New(&FlagsType);\n    if (seq == NULL)\n        return NULL;\n\n#define SetFlag(flag) \\\n    PyStructSequence_SET_ITEM(seq, pos++, PyInt_FromLong(flag))\n\n    SetFlag(Py_DebugFlag);\n    SetFlag(Py_Py3kWarningFlag);\n    SetFlag(Py_DivisionWarningFlag);\n    SetFlag(_Py_QnewFlag);\n    SetFlag(Py_InspectFlag);\n    SetFlag(Py_InteractiveFlag);\n    SetFlag(Py_OptimizeFlag);\n    SetFlag(Py_DontWriteBytecodeFlag);\n    SetFlag(Py_NoUserSiteDirectory);\n    SetFlag(Py_NoSiteFlag);\n    SetFlag(Py_IgnoreEnvironmentFlag);\n    SetFlag(Py_TabcheckFlag);\n    SetFlag(Py_VerboseFlag);\n#ifdef RISCOS\n    SetFlag(Py_RISCOSWimpFlag);\n#endif\n    /* SetFlag(saw_unbuffered_flag); */\n    SetFlag(Py_UnicodeFlag);\n    /* SetFlag(skipfirstline); */\n    SetFlag(Py_BytesWarningFlag);\n    SetFlag(Py_HashRandomizationFlag);\n#undef SetFlag\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(seq);\n        return NULL;\n    }\n    return seq;\n}\n\nPyDoc_STRVAR(version_info__doc__,\n\"sys.version_info\\n\\\n\\n\\\nVersion information as a named tuple.\");\n\nstatic PyTypeObject VersionInfoType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field version_info_fields[] = {\n    {\"major\", \"Major release number\"},\n    {\"minor\", \"Minor release number\"},\n    {\"micro\", \"Patch release number\"},\n    {\"releaselevel\", \"'alpha', 'beta', 'candidate', or 'release'\"},\n    {\"serial\", \"Serial release number\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc version_info_desc = {\n    \"sys.version_info\",     /* name */\n    version_info__doc__,    /* doc */\n    version_info_fields,    /* fields */\n    5\n};\n\nstatic PyObject *\nmake_version_info(void)\n{\n    PyObject *version_info;\n    char *s;\n    int pos = 0;\n\n    version_info = PyStructSequence_New(&VersionInfoType);\n    if (version_info == NULL) {\n        return NULL;\n    }\n\n    /*\n     * These release level checks are mutually exclusive and cover\n     * the field, so don't get too fancy with the pre-processor!\n     */\n#if PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_ALPHA\n    s = \"alpha\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_BETA\n    s = \"beta\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_GAMMA\n    s = \"candidate\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_FINAL\n    s = \"final\";\n#endif\n\n#define SetIntItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyInt_FromLong(flag))\n#define SetStrItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyString_FromString(flag))\n\n    SetIntItem(PY_MAJOR_VERSION);\n    SetIntItem(PY_MINOR_VERSION);\n    SetIntItem(PY_MICRO_VERSION);\n    SetStrItem(s);\n    SetIntItem(PY_RELEASE_SERIAL);\n#undef SetIntItem\n#undef SetStrItem\n\n    if (PyErr_Occurred()) {\n        Py_CLEAR(version_info);\n        return NULL;\n    }\n    return version_info;\n}\n\nPyObject *\n_PySys_Init(void)\n{\n    PyObject *m, *v, *sysdict;\n    PyObject *sysin, *sysout, *syserr;\n    char *s;\n\n    m = Py_InitModule3(\"sys\", sys_methods, sys_doc);\n    if (m == NULL)\n        return NULL;\n    sysdict = PyModule_GetDict(m);\n#define SET_SYS_FROM_STRING(key, value)                 \\\n    v = value;                                          \\\n    if (v != NULL)                                      \\\n        PyDict_SetItemString(sysdict, key, v);          \\\n    Py_XDECREF(v)\n\n    /* Check that stdin is not a directory\n    Using shell redirection, you can redirect stdin to a directory,\n    crashing the Python interpreter. Catch this common mistake here\n    and output a useful error message. Note that under MS Windows,\n    the shell already prevents that. */\n#if !defined(MS_WINDOWS)\n    {\n        struct stat sb;\n        if (fstat(fileno(stdin), &sb) == 0 &&\n            S_ISDIR(sb.st_mode)) {\n            /* There's nothing more we can do. */\n            /* Py_FatalError() will core dump, so just exit. */\n            PySys_WriteStderr(\"Python error: <stdin> is a directory, cannot continue\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif\n\n    /* Closing the standard FILE* if sys.std* goes aways causes problems\n     * for embedded Python usages. Closing them when somebody explicitly\n     * invokes .close() might be possible, but the FAQ promises they get\n     * never closed. However, we still need to get write errors when\n     * writing fails (e.g. because stdout is redirected), so we flush the\n     * streams and check for errors before the file objects are deleted.\n     * On OS X, fflush()ing stdin causes an error, so we exempt stdin\n     * from that procedure.\n     */\n    sysin = PyFile_FromFile(stdin, \"<stdin>\", \"r\", NULL);\n    sysout = PyFile_FromFile(stdout, \"<stdout>\", \"w\", _check_and_flush);\n    syserr = PyFile_FromFile(stderr, \"<stderr>\", \"w\", _check_and_flush);\n    if (PyErr_Occurred())\n        return NULL;\n\n    PyDict_SetItemString(sysdict, \"stdin\", sysin);\n    PyDict_SetItemString(sysdict, \"stdout\", sysout);\n    PyDict_SetItemString(sysdict, \"stderr\", syserr);\n    /* Make backup copies for cleanup */\n    PyDict_SetItemString(sysdict, \"__stdin__\", sysin);\n    PyDict_SetItemString(sysdict, \"__stdout__\", sysout);\n    PyDict_SetItemString(sysdict, \"__stderr__\", syserr);\n    PyDict_SetItemString(sysdict, \"__displayhook__\",\n                         PyDict_GetItemString(sysdict, \"displayhook\"));\n    PyDict_SetItemString(sysdict, \"__excepthook__\",\n                         PyDict_GetItemString(sysdict, \"excepthook\"));\n    Py_XDECREF(sysin);\n    Py_XDECREF(sysout);\n    Py_XDECREF(syserr);\n\n    SET_SYS_FROM_STRING(\"version\",\n                         PyString_FromString(Py_GetVersion()));\n    SET_SYS_FROM_STRING(\"hexversion\",\n                         PyInt_FromLong(PY_VERSION_HEX));\n    svnversion_init();\n    SET_SYS_FROM_STRING(\"subversion\",\n                         Py_BuildValue(\"(ssz)\", \"CPython\", branch,\n                                      svn_revision));\n    SET_SYS_FROM_STRING(\"_mercurial\",\n                        Py_BuildValue(\"(szz)\", \"CPython\", _Py_hgidentifier(),\n                                      _Py_hgversion()));\n    SET_SYS_FROM_STRING(\"dont_write_bytecode\",\n                         PyBool_FromLong(Py_DontWriteBytecodeFlag));\n    SET_SYS_FROM_STRING(\"api_version\",\n                        PyInt_FromLong(PYTHON_API_VERSION));\n    SET_SYS_FROM_STRING(\"copyright\",\n                        PyString_FromString(Py_GetCopyright()));\n    SET_SYS_FROM_STRING(\"platform\",\n                        PyString_FromString(Py_GetPlatform()));\n    SET_SYS_FROM_STRING(\"executable\",\n                        PyString_FromString(Py_GetProgramFullPath()));\n    SET_SYS_FROM_STRING(\"prefix\",\n                        PyString_FromString(Py_GetPrefix()));\n    SET_SYS_FROM_STRING(\"exec_prefix\",\n                        PyString_FromString(Py_GetExecPrefix()));\n    SET_SYS_FROM_STRING(\"maxsize\",\n                        PyInt_FromSsize_t(PY_SSIZE_T_MAX));\n    SET_SYS_FROM_STRING(\"maxint\",\n                        PyInt_FromLong(PyInt_GetMax()));\n    SET_SYS_FROM_STRING(\"py3kwarning\",\n                        PyBool_FromLong(Py_Py3kWarningFlag));\n    SET_SYS_FROM_STRING(\"float_info\",\n                        PyFloat_GetInfo());\n    SET_SYS_FROM_STRING(\"long_info\",\n                        PyLong_GetInfo());\n#ifdef Py_USING_UNICODE\n    SET_SYS_FROM_STRING(\"maxunicode\",\n                        PyInt_FromLong(PyUnicode_GetMax()));\n#endif\n    SET_SYS_FROM_STRING(\"builtin_module_names\",\n                        list_builtin_module_names());\n    {\n        /* Assumes that longs are at least 2 bytes long.\n           Should be safe! */\n        unsigned long number = 1;\n        char *value;\n\n        s = (char *) &number;\n        if (s[0] == 0)\n            value = \"big\";\n        else\n            value = \"little\";\n        SET_SYS_FROM_STRING(\"byteorder\",\n                            PyString_FromString(value));\n    }\n#ifdef MS_COREDLL\n    SET_SYS_FROM_STRING(\"dllhandle\",\n                        PyLong_FromVoidPtr(PyWin_DLLhModule));\n    SET_SYS_FROM_STRING(\"winver\",\n                        PyString_FromString(PyWin_DLLVersionString));\n#endif\n    if (warnoptions == NULL) {\n        warnoptions = PyList_New(0);\n    }\n    else {\n        Py_INCREF(warnoptions);\n    }\n    if (warnoptions != NULL) {\n        PyDict_SetItemString(sysdict, \"warnoptions\", warnoptions);\n    }\n\n    /* version_info */\n    if (VersionInfoType.tp_name == 0)\n        PyStructSequence_InitType(&VersionInfoType, &version_info_desc);\n    SET_SYS_FROM_STRING(\"version_info\", make_version_info());\n    /* prevent user from creating new instances */\n    VersionInfoType.tp_init = NULL;\n    VersionInfoType.tp_new = NULL;\n\n    /* flags */\n    if (FlagsType.tp_name == 0)\n        PyStructSequence_InitType(&FlagsType, &flags_desc);\n    SET_SYS_FROM_STRING(\"flags\", make_flags());\n    /* prevent user from creating new instances */\n    FlagsType.tp_init = NULL;\n    FlagsType.tp_new = NULL;\n\n\n#if defined(MS_WINDOWS)\n    /* getwindowsversion */\n    if (WindowsVersionType.tp_name == 0)\n        PyStructSequence_InitType(&WindowsVersionType, &windows_version_desc);\n    /* prevent user from creating new instances */\n    WindowsVersionType.tp_init = NULL;\n    WindowsVersionType.tp_new = NULL;\n#endif\n\n    /* float repr style: 0.03 (short) vs 0.029999999999999999 (legacy) */\n#ifndef PY_NO_SHORT_FLOAT_REPR\n    SET_SYS_FROM_STRING(\"float_repr_style\",\n                        PyString_FromString(\"short\"));\n#else\n    SET_SYS_FROM_STRING(\"float_repr_style\",\n                        PyString_FromString(\"legacy\"));\n#endif\n\n#undef SET_SYS_FROM_STRING\n    if (PyErr_Occurred())\n        return NULL;\n    return m;\n}\n\nstatic PyObject *\nmakepathobject(char *path, int delim)\n{\n    int i, n;\n    char *p;\n    PyObject *v, *w;\n\n    n = 1;\n    p = path;\n    while ((p = strchr(p, delim)) != NULL) {\n        n++;\n        p++;\n    }\n    v = PyList_New(n);\n    if (v == NULL)\n        return NULL;\n    for (i = 0; ; i++) {\n        p = strchr(path, delim);\n        if (p == NULL)\n            p = strchr(path, '\\0'); /* End of string */\n        w = PyString_FromStringAndSize(path, (Py_ssize_t) (p - path));\n        if (w == NULL) {\n            Py_DECREF(v);\n            return NULL;\n        }\n        PyList_SetItem(v, i, w);\n        if (*p == '\\0')\n            break;\n        path = p+1;\n    }\n    return v;\n}\n\nvoid\nPySys_SetPath(char *path)\n{\n    PyObject *v;\n    if ((v = makepathobject(path, DELIM)) == NULL)\n        Py_FatalError(\"can't create sys.path\");\n    if (PySys_SetObject(\"path\", v) != 0)\n        Py_FatalError(\"can't assign sys.path\");\n    Py_DECREF(v);\n}\n\nstatic PyObject *\nmakeargvobject(int argc, char **argv)\n{\n    PyObject *av;\n    if (argc <= 0 || argv == NULL) {\n        /* Ensure at least one (empty) argument is seen */\n        static char *empty_argv[1] = {\"\"};\n        argv = empty_argv;\n        argc = 1;\n    }\n    av = PyList_New(argc);\n    if (av != NULL) {\n        int i;\n        for (i = 0; i < argc; i++) {\n#ifdef __VMS\n            PyObject *v;\n\n            /* argv[0] is the script pathname if known */\n            if (i == 0) {\n                char* fn = decc$translate_vms(argv[0]);\n                if ((fn == (char *)0) || fn == (char *)-1)\n                    v = PyString_FromString(argv[0]);\n                else\n                    v = PyString_FromString(\n                        decc$translate_vms(argv[0]));\n            } else\n                v = PyString_FromString(argv[i]);\n#else\n            PyObject *v = PyString_FromString(argv[i]);\n#endif\n            if (v == NULL) {\n                Py_DECREF(av);\n                av = NULL;\n                break;\n            }\n            PyList_SetItem(av, i, v);\n        }\n    }\n    return av;\n}\n\nvoid\nPySys_SetArgvEx(int argc, char **argv, int updatepath)\n{\n#if defined(HAVE_REALPATH)\n    char fullpath[MAXPATHLEN];\n#elif defined(MS_WINDOWS) && !defined(MS_WINCE)\n    char fullpath[MAX_PATH];\n#endif\n    PyObject *av = makeargvobject(argc, argv);\n    PyObject *path = PySys_GetObject(\"path\");\n    if (av == NULL)\n        Py_FatalError(\"no mem for sys.argv\");\n    if (PySys_SetObject(\"argv\", av) != 0)\n        Py_FatalError(\"can't assign sys.argv\");\n    if (updatepath && path != NULL) {\n        char *argv0 = argv[0];\n        char *p = NULL;\n        Py_ssize_t n = 0;\n        PyObject *a;\n#ifdef HAVE_READLINK\n        char link[MAXPATHLEN+1];\n        char argv0copy[2*MAXPATHLEN+1];\n        int nr = 0;\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0)\n            nr = readlink(argv0, link, MAXPATHLEN);\n        if (nr > 0) {\n            /* It's a symlink */\n            link[nr] = '\\0';\n            if (link[0] == SEP)\n                argv0 = link; /* Link to absolute path */\n            else if (strchr(link, SEP) == NULL)\n                ; /* Link without path */\n            else {\n                /* Must join(dirname(argv0), link) */\n                char *q = strrchr(argv0, SEP);\n                if (q == NULL)\n                    argv0 = link; /* argv0 without path */\n                else {\n                    /* Must make a copy */\n                    strcpy(argv0copy, argv0);\n                    q = strrchr(argv0copy, SEP);\n                    strcpy(q+1, link);\n                    argv0 = argv0copy;\n                }\n            }\n        }\n#endif /* HAVE_READLINK */\n#if SEP == '\\\\' /* Special case for MS filename syntax */\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0) {\n            char *q;\n#if defined(MS_WINDOWS) && !defined(MS_WINCE)\n            /* This code here replaces the first element in argv with the full\n            path that it represents. Under CE, there are no relative paths so\n            the argument must be the full path anyway. */\n            char *ptemp;\n            if (GetFullPathName(argv0,\n                               sizeof(fullpath),\n                               fullpath,\n                               &ptemp)) {\n                argv0 = fullpath;\n            }\n#endif\n            p = strrchr(argv0, SEP);\n            /* Test for alternate separator */\n            q = strrchr(p ? p : argv0, '/');\n            if (q != NULL)\n                p = q;\n            if (p != NULL) {\n                n = p + 1 - argv0;\n                if (n > 1 && p[-1] != ':')\n                    n--; /* Drop trailing separator */\n            }\n        }\n#else /* All other filename syntaxes */\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0) {\n#if defined(HAVE_REALPATH)\n            if (realpath(argv0, fullpath)) {\n                argv0 = fullpath;\n            }\n#endif\n            p = strrchr(argv0, SEP);\n        }\n        if (p != NULL) {\n#ifndef RISCOS\n            n = p + 1 - argv0;\n#else /* don't include trailing separator */\n            n = p - argv0;\n#endif /* RISCOS */\n#if SEP == '/' /* Special case for Unix filename syntax */\n            if (n > 1)\n                n--; /* Drop trailing separator */\n#endif /* Unix */\n        }\n#endif /* All others */\n        a = PyString_FromStringAndSize(argv0, n);\n        if (a == NULL)\n            Py_FatalError(\"no mem for sys.path insertion\");\n        if (PyList_Insert(path, 0, a) < 0)\n            Py_FatalError(\"sys.path.insert(0) failed\");\n        Py_DECREF(a);\n    }\n    Py_DECREF(av);\n}\n\nvoid\nPySys_SetArgv(int argc, char **argv)\n{\n    PySys_SetArgvEx(argc, argv, 1);\n}\n\n\n/* APIs to write to sys.stdout or sys.stderr using a printf-like interface.\n   Adapted from code submitted by Just van Rossum.\n\n   PySys_WriteStdout(format, ...)\n   PySys_WriteStderr(format, ...)\n\n      The first function writes to sys.stdout; the second to sys.stderr.  When\n      there is a problem, they write to the real (C level) stdout or stderr;\n      no exceptions are raised.\n\n      Both take a printf-style format string as their first argument followed\n      by a variable length argument list determined by the format string.\n\n      *** WARNING ***\n\n      The format should limit the total size of the formatted output string to\n      1000 bytes.  In particular, this means that no unrestricted \"%s\" formats\n      should occur; these should be limited using \"%.<N>s where <N> is a\n      decimal number calculated so that <N> plus the maximum size of other\n      formatted text does not exceed 1000 bytes.  Also watch out for \"%f\",\n      which can print hundreds of digits for very large numbers.\n\n */\n\nstatic void\nmywrite(char *name, FILE *fp, const char *format, va_list va)\n{\n    PyObject *file;\n    PyObject *error_type, *error_value, *error_traceback;\n\n    PyErr_Fetch(&error_type, &error_value, &error_traceback);\n    file = PySys_GetObject(name);\n    if (file == NULL || PyFile_AsFile(file) == fp)\n        vfprintf(fp, format, va);\n    else {\n        char buffer[1001];\n        const int written = PyOS_vsnprintf(buffer, sizeof(buffer),\n                                           format, va);\n        if (PyFile_WriteString(buffer, file) != 0) {\n            PyErr_Clear();\n            fputs(buffer, fp);\n        }\n        if (written < 0 || (size_t)written >= sizeof(buffer)) {\n            const char *truncated = \"... truncated\";\n            if (PyFile_WriteString(truncated, file) != 0) {\n                PyErr_Clear();\n                fputs(truncated, fp);\n            }\n        }\n    }\n    PyErr_Restore(error_type, error_value, error_traceback);\n}\n\nvoid\nPySys_WriteStdout(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    mywrite(\"stdout\", stdout, format, va);\n    va_end(va);\n}\n\nvoid\nPySys_WriteStderr(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    mywrite(\"stderr\", stderr, format, va);\n    va_end(va);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Python/pystate.c": "\n/* Thread and interpreter state structures and their interfaces */\n\n#include \"Python.h\"\n\n/* --------------------------------------------------------------------------\nCAUTION\n\nAlways use malloc() and free() directly in this file.  A number of these\nfunctions are advertised as safe to call when the GIL isn't held, and in\na debug build Python redirects (e.g.) PyMem_NEW (etc) to Python's debugging\nobmalloc functions.  Those aren't thread-safe (they rely on the GIL to avoid\nthe expense of doing their own locking).\n-------------------------------------------------------------------------- */\n\n#ifdef HAVE_DLOPEN\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef WITH_THREAD\n#include \"pythread.h\"\nstatic PyThread_type_lock head_mutex = NULL; /* Protects interp->tstate_head */\n#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_allocate_lock()))\n#define HEAD_LOCK() PyThread_acquire_lock(head_mutex, WAIT_LOCK)\n#define HEAD_UNLOCK() PyThread_release_lock(head_mutex)\n\n/* The single PyInterpreterState used by this process'\n   GILState implementation\n*/\nstatic PyInterpreterState *autoInterpreterState = NULL;\nstatic int autoTLSkey = 0;\n#else\n#define HEAD_INIT() /* Nothing */\n#define HEAD_LOCK() /* Nothing */\n#define HEAD_UNLOCK() /* Nothing */\n#endif\n\nstatic PyInterpreterState *interp_head = NULL;\n\nPyThreadState *_PyThreadState_Current = NULL;\nPyThreadFrameGetter _PyThreadState_GetFrame = NULL;\n\n#ifdef WITH_THREAD\nstatic void _PyGILState_NoteThreadState(PyThreadState* tstate);\n#endif\n\n\nPyInterpreterState *\nPyInterpreterState_New(void)\n{\n    PyInterpreterState *interp = (PyInterpreterState *)\n                                 malloc(sizeof(PyInterpreterState));\n\n    if (interp != NULL) {\n        HEAD_INIT();\n#ifdef WITH_THREAD\n        if (head_mutex == NULL)\n            Py_FatalError(\"Can't initialize threads for interpreter\");\n#endif\n        interp->modules = NULL;\n        interp->modules_reloading = NULL;\n        interp->sysdict = NULL;\n        interp->builtins = NULL;\n        interp->tstate_head = NULL;\n        interp->codec_search_path = NULL;\n        interp->codec_search_cache = NULL;\n        interp->codec_error_registry = NULL;\n#ifdef HAVE_DLOPEN\n#ifdef RTLD_NOW\n        interp->dlopenflags = RTLD_NOW;\n#else\n        interp->dlopenflags = RTLD_LAZY;\n#endif\n#endif\n#ifdef WITH_TSC\n        interp->tscdump = 0;\n#endif\n\n        HEAD_LOCK();\n        interp->next = interp_head;\n        interp_head = interp;\n        HEAD_UNLOCK();\n    }\n\n    return interp;\n}\n\n\nvoid\nPyInterpreterState_Clear(PyInterpreterState *interp)\n{\n    PyThreadState *p;\n    HEAD_LOCK();\n    for (p = interp->tstate_head; p != NULL; p = p->next)\n        PyThreadState_Clear(p);\n    HEAD_UNLOCK();\n    Py_CLEAR(interp->codec_search_path);\n    Py_CLEAR(interp->codec_search_cache);\n    Py_CLEAR(interp->codec_error_registry);\n    Py_CLEAR(interp->modules);\n    Py_CLEAR(interp->modules_reloading);\n    Py_CLEAR(interp->sysdict);\n    Py_CLEAR(interp->builtins);\n}\n\n\nstatic void\nzapthreads(PyInterpreterState *interp)\n{\n    PyThreadState *p;\n    /* No need to lock the mutex here because this should only happen\n       when the threads are all really dead (XXX famous last words). */\n    while ((p = interp->tstate_head) != NULL) {\n        PyThreadState_Delete(p);\n    }\n}\n\n\nvoid\nPyInterpreterState_Delete(PyInterpreterState *interp)\n{\n    PyInterpreterState **p;\n    zapthreads(interp);\n    HEAD_LOCK();\n    for (p = &interp_head; ; p = &(*p)->next) {\n        if (*p == NULL)\n            Py_FatalError(\n                \"PyInterpreterState_Delete: invalid interp\");\n        if (*p == interp)\n            break;\n    }\n    if (interp->tstate_head != NULL)\n        Py_FatalError(\"PyInterpreterState_Delete: remaining threads\");\n    *p = interp->next;\n    HEAD_UNLOCK();\n    free(interp);\n}\n\n\n/* Default implementation for _PyThreadState_GetFrame */\nstatic struct _frame *\nthreadstate_getframe(PyThreadState *self)\n{\n    return self->frame;\n}\n\nstatic PyThreadState *\nnew_threadstate(PyInterpreterState *interp, int init)\n{\n    PyThreadState *tstate = (PyThreadState *)malloc(sizeof(PyThreadState));\n\n    if (_PyThreadState_GetFrame == NULL)\n        _PyThreadState_GetFrame = threadstate_getframe;\n\n    if (tstate != NULL) {\n        tstate->interp = interp;\n\n        tstate->frame = NULL;\n        tstate->recursion_depth = 0;\n        tstate->tracing = 0;\n        tstate->use_tracing = 0;\n        tstate->tick_counter = 0;\n        tstate->gilstate_counter = 0;\n        tstate->async_exc = NULL;\n#ifdef WITH_THREAD\n        tstate->thread_id = PyThread_get_thread_ident();\n#else\n        tstate->thread_id = 0;\n#endif\n\n        tstate->dict = NULL;\n\n        tstate->curexc_type = NULL;\n        tstate->curexc_value = NULL;\n        tstate->curexc_traceback = NULL;\n\n        tstate->exc_type = NULL;\n        tstate->exc_value = NULL;\n        tstate->exc_traceback = NULL;\n\n        tstate->c_profilefunc = NULL;\n        tstate->c_tracefunc = NULL;\n        tstate->c_profileobj = NULL;\n        tstate->c_traceobj = NULL;\n\n        tstate->trash_delete_nesting = 0;\n        tstate->trash_delete_later = NULL;\n\n        if (init)\n            _PyThreadState_Init(tstate);\n\n        HEAD_LOCK();\n        tstate->next = interp->tstate_head;\n        interp->tstate_head = tstate;\n        HEAD_UNLOCK();\n    }\n\n    return tstate;\n}\n\nPyThreadState *\nPyThreadState_New(PyInterpreterState *interp)\n{\n    return new_threadstate(interp, 1);\n}\n\nPyThreadState *\n_PyThreadState_Prealloc(PyInterpreterState *interp)\n{\n    return new_threadstate(interp, 0);\n}\n\nvoid\n_PyThreadState_Init(PyThreadState *tstate)\n{\n#ifdef WITH_THREAD\n    _PyGILState_NoteThreadState(tstate);\n#endif\n}\n\nvoid\nPyThreadState_Clear(PyThreadState *tstate)\n{\n    if (Py_VerboseFlag && tstate->frame != NULL)\n        fprintf(stderr,\n          \"PyThreadState_Clear: warning: thread still has a frame\\n\");\n\n    Py_CLEAR(tstate->frame);\n\n    Py_CLEAR(tstate->dict);\n    Py_CLEAR(tstate->async_exc);\n\n    Py_CLEAR(tstate->curexc_type);\n    Py_CLEAR(tstate->curexc_value);\n    Py_CLEAR(tstate->curexc_traceback);\n\n    Py_CLEAR(tstate->exc_type);\n    Py_CLEAR(tstate->exc_value);\n    Py_CLEAR(tstate->exc_traceback);\n\n    tstate->c_profilefunc = NULL;\n    tstate->c_tracefunc = NULL;\n    Py_CLEAR(tstate->c_profileobj);\n    Py_CLEAR(tstate->c_traceobj);\n}\n\n\n/* Common code for PyThreadState_Delete() and PyThreadState_DeleteCurrent() */\nstatic void\ntstate_delete_common(PyThreadState *tstate)\n{\n    PyInterpreterState *interp;\n    PyThreadState **p;\n    PyThreadState *prev_p = NULL;\n    if (tstate == NULL)\n        Py_FatalError(\"PyThreadState_Delete: NULL tstate\");\n    interp = tstate->interp;\n    if (interp == NULL)\n        Py_FatalError(\"PyThreadState_Delete: NULL interp\");\n    HEAD_LOCK();\n    for (p = &interp->tstate_head; ; p = &(*p)->next) {\n        if (*p == NULL)\n            Py_FatalError(\n                \"PyThreadState_Delete: invalid tstate\");\n        if (*p == tstate)\n            break;\n        /* Sanity check.  These states should never happen but if\n         * they do we must abort.  Otherwise we'll end up spinning in\n         * in a tight loop with the lock held.  A similar check is done\n         * in thread.c find_key().  */\n        if (*p == prev_p)\n            Py_FatalError(\n                \"PyThreadState_Delete: small circular list(!)\"\n                \" and tstate not found.\");\n        prev_p = *p;\n        if ((*p)->next == interp->tstate_head)\n            Py_FatalError(\n                \"PyThreadState_Delete: circular list(!) and\"\n                \" tstate not found.\");\n    }\n    *p = tstate->next;\n    HEAD_UNLOCK();\n    free(tstate);\n}\n\n\nvoid\nPyThreadState_Delete(PyThreadState *tstate)\n{\n    if (tstate == _PyThreadState_Current)\n        Py_FatalError(\"PyThreadState_Delete: tstate is still current\");\n    tstate_delete_common(tstate);\n#ifdef WITH_THREAD\n    if (autoInterpreterState && PyThread_get_key_value(autoTLSkey) == tstate)\n        PyThread_delete_key_value(autoTLSkey);\n#endif /* WITH_THREAD */\n}\n\n\n#ifdef WITH_THREAD\nvoid\nPyThreadState_DeleteCurrent()\n{\n    PyThreadState *tstate = _PyThreadState_Current;\n    if (tstate == NULL)\n        Py_FatalError(\n            \"PyThreadState_DeleteCurrent: no current tstate\");\n    _PyThreadState_Current = NULL;\n    if (autoInterpreterState && PyThread_get_key_value(autoTLSkey) == tstate)\n        PyThread_delete_key_value(autoTLSkey);\n    tstate_delete_common(tstate);\n    PyEval_ReleaseLock();\n}\n#endif /* WITH_THREAD */\n\n\nPyThreadState *\nPyThreadState_Get(void)\n{\n    if (_PyThreadState_Current == NULL)\n        Py_FatalError(\"PyThreadState_Get: no current thread\");\n\n    return _PyThreadState_Current;\n}\n\n\nPyThreadState *\nPyThreadState_Swap(PyThreadState *newts)\n{\n    PyThreadState *oldts = _PyThreadState_Current;\n\n    _PyThreadState_Current = newts;\n    /* It should not be possible for more than one thread state\n       to be used for a thread.  Check this the best we can in debug\n       builds.\n    */\n#if defined(Py_DEBUG) && defined(WITH_THREAD)\n    if (newts) {\n        /* This can be called from PyEval_RestoreThread(). Similar\n           to it, we need to ensure errno doesn't change.\n        */\n        int err = errno;\n        PyThreadState *check = PyGILState_GetThisThreadState();\n        if (check && check->interp == newts->interp && check != newts)\n            Py_FatalError(\"Invalid thread state for this thread\");\n        errno = err;\n    }\n#endif\n    return oldts;\n}\n\n/* An extension mechanism to store arbitrary additional per-thread state.\n   PyThreadState_GetDict() returns a dictionary that can be used to hold such\n   state; the caller should pick a unique key and store its state there.  If\n   PyThreadState_GetDict() returns NULL, an exception has *not* been raised\n   and the caller should assume no per-thread state is available. */\n\nPyObject *\nPyThreadState_GetDict(void)\n{\n    if (_PyThreadState_Current == NULL)\n        return NULL;\n\n    if (_PyThreadState_Current->dict == NULL) {\n        PyObject *d;\n        _PyThreadState_Current->dict = d = PyDict_New();\n        if (d == NULL)\n            PyErr_Clear();\n    }\n    return _PyThreadState_Current->dict;\n}\n\n\n/* Asynchronously raise an exception in a thread.\n   Requested by Just van Rossum and Alex Martelli.\n   To prevent naive misuse, you must write your own extension\n   to call this, or use ctypes.  Must be called with the GIL held.\n   Returns the number of tstates modified (normally 1, but 0 if `id` didn't\n   match any known thread id).  Can be called with exc=NULL to clear an\n   existing async exception.  This raises no exceptions. */\n\nint\nPyThreadState_SetAsyncExc(long id, PyObject *exc) {\n    PyThreadState *tstate = PyThreadState_GET();\n    PyInterpreterState *interp = tstate->interp;\n    PyThreadState *p;\n\n    /* Although the GIL is held, a few C API functions can be called\n     * without the GIL held, and in particular some that create and\n     * destroy thread and interpreter states.  Those can mutate the\n     * list of thread states we're traversing, so to prevent that we lock\n     * head_mutex for the duration.\n     */\n    HEAD_LOCK();\n    for (p = interp->tstate_head; p != NULL; p = p->next) {\n        if (p->thread_id == id) {\n            /* Tricky:  we need to decref the current value\n             * (if any) in p->async_exc, but that can in turn\n             * allow arbitrary Python code to run, including\n             * perhaps calls to this function.  To prevent\n             * deadlock, we need to release head_mutex before\n             * the decref.\n             */\n            PyObject *old_exc = p->async_exc;\n            Py_XINCREF(exc);\n            p->async_exc = exc;\n            HEAD_UNLOCK();\n            Py_XDECREF(old_exc);\n            return 1;\n        }\n    }\n    HEAD_UNLOCK();\n    return 0;\n}\n\n\n/* Routines for advanced debuggers, requested by David Beazley.\n   Don't use unless you know what you are doing! */\n\nPyInterpreterState *\nPyInterpreterState_Head(void)\n{\n    return interp_head;\n}\n\nPyInterpreterState *\nPyInterpreterState_Next(PyInterpreterState *interp) {\n    return interp->next;\n}\n\nPyThreadState *\nPyInterpreterState_ThreadHead(PyInterpreterState *interp) {\n    return interp->tstate_head;\n}\n\nPyThreadState *\nPyThreadState_Next(PyThreadState *tstate) {\n    return tstate->next;\n}\n\n/* The implementation of sys._current_frames().  This is intended to be\n   called with the GIL held, as it will be when called via\n   sys._current_frames().  It's possible it would work fine even without\n   the GIL held, but haven't thought enough about that.\n*/\nPyObject *\n_PyThread_CurrentFrames(void)\n{\n    PyObject *result;\n    PyInterpreterState *i;\n\n    result = PyDict_New();\n    if (result == NULL)\n        return NULL;\n\n    /* for i in all interpreters:\n     *     for t in all of i's thread states:\n     *          if t's frame isn't NULL, map t's id to its frame\n     * Because these lists can mutate even when the GIL is held, we\n     * need to grab head_mutex for the duration.\n     */\n    HEAD_LOCK();\n    for (i = interp_head; i != NULL; i = i->next) {\n        PyThreadState *t;\n        for (t = i->tstate_head; t != NULL; t = t->next) {\n            PyObject *id;\n            int stat;\n            struct _frame *frame = t->frame;\n            if (frame == NULL)\n                continue;\n            id = PyInt_FromLong(t->thread_id);\n            if (id == NULL)\n                goto Fail;\n            stat = PyDict_SetItem(result, id, (PyObject *)frame);\n            Py_DECREF(id);\n            if (stat < 0)\n                goto Fail;\n        }\n    }\n    HEAD_UNLOCK();\n    return result;\n\n Fail:\n    HEAD_UNLOCK();\n    Py_DECREF(result);\n    return NULL;\n}\n\n/* Python \"auto thread state\" API. */\n#ifdef WITH_THREAD\n\n/* Keep this as a static, as it is not reliable!  It can only\n   ever be compared to the state for the *current* thread.\n   * If not equal, then it doesn't matter that the actual\n     value may change immediately after comparison, as it can't\n     possibly change to the current thread's state.\n   * If equal, then the current thread holds the lock, so the value can't\n     change until we yield the lock.\n*/\nstatic int\nPyThreadState_IsCurrent(PyThreadState *tstate)\n{\n    /* Must be the tstate for this thread */\n    assert(PyGILState_GetThisThreadState()==tstate);\n    /* On Windows at least, simple reads and writes to 32 bit values\n       are atomic.\n    */\n    return tstate == _PyThreadState_Current;\n}\n\n/* Internal initialization/finalization functions called by\n   Py_Initialize/Py_Finalize\n*/\nvoid\n_PyGILState_Init(PyInterpreterState *i, PyThreadState *t)\n{\n    assert(i && t); /* must init with valid states */\n    autoTLSkey = PyThread_create_key();\n    autoInterpreterState = i;\n    assert(PyThread_get_key_value(autoTLSkey) == NULL);\n    assert(t->gilstate_counter == 0);\n\n    _PyGILState_NoteThreadState(t);\n}\n\nvoid\n_PyGILState_Fini(void)\n{\n    PyThread_delete_key(autoTLSkey);\n    autoInterpreterState = NULL;\n}\n\n/* When a thread state is created for a thread by some mechanism other than\n   PyGILState_Ensure, it's important that the GILState machinery knows about\n   it so it doesn't try to create another thread state for the thread (this is\n   a better fix for SF bug #1010677 than the first one attempted).\n*/\nstatic void\n_PyGILState_NoteThreadState(PyThreadState* tstate)\n{\n    /* If autoTLSkey isn't initialized, this must be the very first\n       threadstate created in Py_Initialize().  Don't do anything for now\n       (we'll be back here when _PyGILState_Init is called). */\n    if (!autoInterpreterState)\n        return;\n\n    /* Stick the thread state for this thread in thread local storage.\n\n       The only situation where you can legitimately have more than one\n       thread state for an OS level thread is when there are multiple\n       interpreters, when:\n\n           a) You shouldn't really be using the PyGILState_ APIs anyway,\n          and:\n\n           b) The slightly odd way PyThread_set_key_value works (see\n          comments by its implementation) means that the first thread\n          state created for that given OS level thread will \"win\",\n          which seems reasonable behaviour.\n    */\n    if (PyThread_set_key_value(autoTLSkey, (void *)tstate) < 0)\n        Py_FatalError(\"Couldn't create autoTLSkey mapping\");\n\n    /* PyGILState_Release must not try to delete this thread state. */\n    tstate->gilstate_counter = 1;\n}\n\n/* The public functions */\nPyThreadState *\nPyGILState_GetThisThreadState(void)\n{\n    if (autoInterpreterState == NULL)\n        return NULL;\n    return (PyThreadState *)PyThread_get_key_value(autoTLSkey);\n}\n\nPyGILState_STATE\nPyGILState_Ensure(void)\n{\n    int current;\n    PyThreadState *tcur;\n    /* Note that we do not auto-init Python here - apart from\n       potential races with 2 threads auto-initializing, pep-311\n       spells out other issues.  Embedders are expected to have\n       called Py_Initialize() and usually PyEval_InitThreads().\n    */\n    assert(autoInterpreterState); /* Py_Initialize() hasn't been called! */\n    tcur = (PyThreadState *)PyThread_get_key_value(autoTLSkey);\n    if (tcur == NULL) {\n        /* Create a new thread state for this thread */\n        tcur = PyThreadState_New(autoInterpreterState);\n        if (tcur == NULL)\n            Py_FatalError(\"Couldn't create thread-state for new thread\");\n        /* This is our thread state!  We'll need to delete it in the\n           matching call to PyGILState_Release(). */\n        tcur->gilstate_counter = 0;\n        current = 0; /* new thread state is never current */\n    }\n    else\n        current = PyThreadState_IsCurrent(tcur);\n    if (current == 0)\n        PyEval_RestoreThread(tcur);\n    /* Update our counter in the thread-state - no need for locks:\n       - tcur will remain valid as we hold the GIL.\n       - the counter is safe as we are the only thread \"allowed\"\n         to modify this value\n    */\n    ++tcur->gilstate_counter;\n    return current ? PyGILState_LOCKED : PyGILState_UNLOCKED;\n}\n\nvoid\nPyGILState_Release(PyGILState_STATE oldstate)\n{\n    PyThreadState *tcur = (PyThreadState *)PyThread_get_key_value(\n                                                            autoTLSkey);\n    if (tcur == NULL)\n        Py_FatalError(\"auto-releasing thread-state, \"\n                      \"but no thread-state for this thread\");\n    /* We must hold the GIL and have our thread state current */\n    /* XXX - remove the check - the assert should be fine,\n       but while this is very new (April 2003), the extra check\n       by release-only users can't hurt.\n    */\n    if (! PyThreadState_IsCurrent(tcur))\n        Py_FatalError(\"This thread state must be current when releasing\");\n    assert(PyThreadState_IsCurrent(tcur));\n    --tcur->gilstate_counter;\n    assert(tcur->gilstate_counter >= 0); /* illegal counter value */\n\n    /* If we're going to destroy this thread-state, we must\n     * clear it while the GIL is held, as destructors may run.\n     */\n    if (tcur->gilstate_counter == 0) {\n        /* can't have been locked when we created it */\n        assert(oldstate == PyGILState_UNLOCKED);\n        PyThreadState_Clear(tcur);\n        /* Delete the thread-state.  Note this releases the GIL too!\n         * It's vital that the GIL be held here, to avoid shutdown\n         * races; see bugs 225673 and 1061968 (that nasty bug has a\n         * habit of coming back).\n         */\n        PyThreadState_DeleteCurrent();\n    }\n    /* Release the lock if necessary */\n    else if (oldstate == PyGILState_UNLOCKED)\n        PyEval_SaveThread();\n}\n\n#endif /* WITH_THREAD */\n\n#ifdef __cplusplus\n}\n#endif\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Include/pystate.h": "\n/* Thread and interpreter state structures and their interfaces */\n\n\n#ifndef Py_PYSTATE_H\n#define Py_PYSTATE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* State shared between threads */\n\nstruct _ts; /* Forward */\nstruct _is; /* Forward */\n\ntypedef struct _is {\n\n    struct _is *next;\n    struct _ts *tstate_head;\n\n    PyObject *modules;\n    PyObject *sysdict;\n    PyObject *builtins;\n    PyObject *modules_reloading;\n\n    PyObject *codec_search_path;\n    PyObject *codec_search_cache;\n    PyObject *codec_error_registry;\n\n#ifdef HAVE_DLOPEN\n    int dlopenflags;\n#endif\n#ifdef WITH_TSC\n    int tscdump;\n#endif\n\n} PyInterpreterState;\n\n\n/* State unique per thread */\n\nstruct _frame; /* Avoid including frameobject.h */\n\n/* Py_tracefunc return -1 when raising an exception, or 0 for success. */\ntypedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);\n\n/* The following values are used for 'what' for tracefunc functions: */\n#define PyTrace_CALL 0\n#define PyTrace_EXCEPTION 1\n#define PyTrace_LINE 2\n#define PyTrace_RETURN 3\n#define PyTrace_C_CALL 4\n#define PyTrace_C_EXCEPTION 5\n#define PyTrace_C_RETURN 6\n\ntypedef struct _ts {\n    /* See Python/ceval.c for comments explaining most fields */\n\n    struct _ts *next;\n    PyInterpreterState *interp;\n\n    struct _frame *frame;\n    int recursion_depth;\n    /* 'tracing' keeps track of the execution depth when tracing/profiling.\n       This is to prevent the actual trace/profile code from being recorded in\n       the trace/profile. */\n    int tracing;\n    int use_tracing;\n\n    Py_tracefunc c_profilefunc;\n    Py_tracefunc c_tracefunc;\n    PyObject *c_profileobj;\n    PyObject *c_traceobj;\n\n    PyObject *curexc_type;\n    PyObject *curexc_value;\n    PyObject *curexc_traceback;\n\n    PyObject *exc_type;\n    PyObject *exc_value;\n    PyObject *exc_traceback;\n\n    PyObject *dict;  /* Stores per-thread state */\n\n    /* tick_counter is incremented whenever the check_interval ticker\n     * reaches zero. The purpose is to give a useful measure of the number\n     * of interpreted bytecode instructions in a given thread.  This\n     * extremely lightweight statistic collector may be of interest to\n     * profilers (like psyco.jit()), although nothing in the core uses it.\n     */\n    int tick_counter;\n\n    int gilstate_counter;\n\n    PyObject *async_exc; /* Asynchronous exception to raise */\n    long thread_id; /* Thread id where this tstate was created */\n\n    int trash_delete_nesting;\n    PyObject *trash_delete_later;\n\n    /* XXX signal handlers should also be here */\n\n} PyThreadState;\n\n\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);\nPyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);\nPyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) _PyThreadState_Prealloc(PyInterpreterState *);\nPyAPI_FUNC(void) _PyThreadState_Init(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);\n#ifdef WITH_THREAD\nPyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);\n#endif\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);\nPyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);\nPyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);\nPyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);\n\n\n/* Variable and macro for in-line access to current thread state */\n\nPyAPI_DATA(PyThreadState *) _PyThreadState_Current;\n\n#ifdef Py_DEBUG\n#define PyThreadState_GET() PyThreadState_Get()\n#else\n#define PyThreadState_GET() (_PyThreadState_Current)\n#endif\n\ntypedef\n    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}\n        PyGILState_STATE;\n\n/* Ensure that the current thread is ready to call the Python\n   C API, regardless of the current state of Python, or of its\n   thread lock.  This may be called as many times as desired\n   by a thread so long as each call is matched with a call to\n   PyGILState_Release().  In general, other thread-state APIs may\n   be used between _Ensure() and _Release() calls, so long as the\n   thread-state is restored to its previous state before the Release().\n   For example, normal use of the Py_BEGIN_ALLOW_THREADS/\n   Py_END_ALLOW_THREADS macros are acceptable.\n\n   The return value is an opaque \"handle\" to the thread state when\n   PyGILState_Ensure() was called, and must be passed to\n   PyGILState_Release() to ensure Python is left in the same state. Even\n   though recursive calls are allowed, these handles can *not* be shared -\n   each unique call to PyGILState_Ensure must save the handle for its\n   call to PyGILState_Release.\n\n   When the function returns, the current thread will hold the GIL.\n\n   Failure is a fatal error.\n*/\nPyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);\n\n/* Release any resources previously acquired.  After this call, Python's\n   state will be the same as it was prior to the corresponding\n   PyGILState_Ensure() call (but generally this state will be unknown to\n   the caller, hence the use of the GILState API.)\n\n   Every call to PyGILState_Ensure must be matched by a call to\n   PyGILState_Release on the same thread.\n*/\nPyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);\n\n/* Helper/diagnostic function - get the current thread state for\n   this thread.  May return NULL if no GILState API has been used\n   on the current thread.  Note that the main thread always has such a\n   thread-state, even if no auto-thread-state call has been made\n   on the main thread.\n*/\nPyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);\n\n/* The implementation of sys._current_frames()  Returns a dict mapping\n   thread id to that thread's current frame.\n*/\nPyAPI_FUNC(PyObject *) _PyThread_CurrentFrames(void);\n\n/* Routines for advanced debuggers, requested by David Beazley.\n   Don't use unless you know what you are doing! */\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);\n\ntypedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);\n\n/* hook for PyEval_GetFrame(), requested for Psyco */\nPyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYSTATE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/X64/pyconfig.h": "/** @file\n    Manually generated Python Configuration file for EDK II.\n\n    Copyright (c) 2015, Daryl McDaniel. All rights reserved.<BR>\n    Copyright (c) 2011 - 2016, Intel Corporation. All rights reserved.<BR>\n    This program and the accompanying materials are licensed and made available under\n    the terms and conditions of the BSD License that accompanies this distribution.\n    The full text of the license may be found at\n    http://opensource.org/licenses/bsd-license.\n\n    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n**/\n#ifndef Py_PYCONFIG_H\n#define Py_PYCONFIG_H\n\n#include  <Uefi.h>\n\n#define PLATFORM    \"uefi\"\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want\n   support for AIX C++ shared extension modules. */\n#undef AIX_GENUINE_CPLUSPLUS\n\n/* Define this if you have AtheOS threads. */\n#undef ATHEOS_THREADS\n\n/* Define this if you have BeOS threads. */\n#undef BEOS_THREADS\n\n/* Define if you have the Mach cthreads package */\n#undef C_THREADS\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM\n   mixed-endian order (byte order 45670123) */\n#undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most\n   significant byte first */\n#undef DOUBLE_IS_BIG_ENDIAN_IEEE754\n\n/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the\n   least significant byte first */\n#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n\n/* Define if --enable-ipv6 is specified */\n#undef ENABLE_IPV6\n\n/* Define if flock needs to be linked with bsd library. */\n#undef FLOCK_NEEDS_LIBBSD\n\n/* Define if getpgrp() must be called as getpgrp(0). */\n#undef GETPGRP_HAVE_ARG\n\n/* Define if gettimeofday() does not have second (timezone) argument This is\n   the case on Motorola V4 (R40V4.2) */\n#undef GETTIMEOFDAY_NO_TZ\n\n/* Define to 1 if you have the 'acosh' function. */\n#undef HAVE_ACOSH\n\n/* struct addrinfo (netdb.h) */\n#undef HAVE_ADDRINFO\n\n/* Define to 1 if you have the 'alarm' function. */\n#undef HAVE_ALARM\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#undef HAVE_ALLOCA_H\n\n/* Define this if your time.h defines altzone. */\n#undef HAVE_ALTZONE\n\n/* Define to 1 if you have the 'asinh' function. */\n#undef HAVE_ASINH\n\n/* Define to 1 if you have the <asm/types.h> header file. */\n#undef HAVE_ASM_TYPES_H\n\n/* Define to 1 if you have the 'atanh' function. */\n#undef HAVE_ATANH\n\n/* Define if GCC supports __attribute__((format(PyArg_ParseTuple, 2, 3))) */\n#undef HAVE_ATTRIBUTE_FORMAT_PARSETUPLE\n\n/* Define to 1 if you have the 'bind_textdomain_codeset' function. */\n#undef HAVE_BIND_TEXTDOMAIN_CODESET\n\n/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_BLUETOOTH_H\n\n/* Define to 1 if you have the <bluetooth.h> header file. */\n#undef HAVE_BLUETOOTH_H\n\n/* Define if nice() returns success/failure instead of the new priority. */\n#undef HAVE_BROKEN_NICE\n\n/* Define if the system reports an invalid PIPE_BUF value. */\n#undef HAVE_BROKEN_PIPE_BUF\n\n/* Define if poll() sets errno on invalid file descriptors. */\n#undef HAVE_BROKEN_POLL\n\n/* Define if the Posix semaphores do not work on your system */\n#define HAVE_BROKEN_POSIX_SEMAPHORES  1\n\n/* Define if pthread_sigmask() does not work on your system. */\n#define HAVE_BROKEN_PTHREAD_SIGMASK   1\n\n/* define to 1 if your sem_getvalue is broken. */\n#define HAVE_BROKEN_SEM_GETVALUE      1\n\n/* Define if 'unsetenv' does not return an int. */\n#undef HAVE_BROKEN_UNSETENV\n\n/* Define this if you have the type _Bool. */\n#define HAVE_C99_BOOL                 1\n\n/* Define to 1 if you have the 'chflags' function. */\n#undef HAVE_CHFLAGS\n\n/* Define to 1 if you have the 'chown' function. */\n#undef HAVE_CHOWN\n\n/* Define if you have the 'chroot' function. */\n#undef HAVE_CHROOT\n\n/* Define to 1 if you have the 'clock' function. */\n#define HAVE_CLOCK                    1\n\n/* Define to 1 if you have the 'confstr' function. */\n#undef HAVE_CONFSTR\n\n/* Define to 1 if you have the <conio.h> header file. */\n#undef HAVE_CONIO_H\n\n/* Define to 1 if you have the 'copysign' function. */\n#undef HAVE_COPYSIGN\n\n/* Define to 1 if you have the 'ctermid' function. */\n#undef HAVE_CTERMID\n\n/* Define if you have the 'ctermid_r' function. */\n#undef HAVE_CTERMID_R\n\n/* Define to 1 if you have the <curses.h> header file. */\n#undef HAVE_CURSES_H\n\n/* Define if you have the 'is_term_resized' function. */\n#undef HAVE_CURSES_IS_TERM_RESIZED\n\n/* Define if you have the 'resizeterm' function. */\n#undef HAVE_CURSES_RESIZETERM\n\n/* Define if you have the 'resize_term' function. */\n#undef HAVE_CURSES_RESIZE_TERM\n\n/* Define to 1 if you have the declaration of 'isfinite', and to 0 if you\n   don't. */\n#define HAVE_DECL_ISFINITE    0\n\n/* Define to 1 if you have the declaration of 'isinf', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISINF       1\n\n/* Define to 1 if you have the declaration of 'isnan', and to 0 if you don't.\n   */\n#define HAVE_DECL_ISNAN       1\n\n/* Define to 1 if you have the declaration of 'tzname', and to 0 if you don't.\n   */\n#define HAVE_DECL_TZNAME      0\n\n/* Define to 1 if you have the device macros. */\n#undef HAVE_DEVICE_MACROS\n\n/* Define to 1 if you have the /dev/ptc device file. */\n#undef HAVE_DEV_PTC\n\n/* Define to 1 if you have the /dev/ptmx device file. */\n#undef HAVE_DEV_PTMX\n\n/* Define to 1 if you have the <direct.h> header file. */\n#undef HAVE_DIRECT_H\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.\n   */\n#define HAVE_DIRENT_H   1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the 'dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the 'dup2' function. */\n#define HAVE_DUP2       1\n\n/* Defined when any dynamic module loading is enabled. */\n#undef HAVE_DYNAMIC_LOADING\n\n/* Define if you have the 'epoll' functions. */\n#undef HAVE_EPOLL\n\n/* Define to 1 if you have the 'erf' function. */\n#undef HAVE_ERF\n\n/* Define to 1 if you have the 'erfc' function. */\n#undef HAVE_ERFC\n\n/* Define to 1 if you have the <errno.h> header file. */\n#define HAVE_ERRNO_H    1\n\n/* Define to 1 if you have the 'execv' function. */\n#undef HAVE_EXECV\n\n/* Define to 1 if you have the 'expm1' function. */\n#undef HAVE_EXPM1\n\n/* Define if you have the 'fchdir' function. */\n#undef HAVE_FCHDIR\n\n/* Define to 1 if you have the 'fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the 'fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H    1\n\n/* Define if you have the 'fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the 'finite' function. */\n#define HAVE_FINITE     1\n\n/* Define to 1 if you have the 'flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the 'fork' function. */\n#undef HAVE_FORK\n\n/* Define to 1 if you have the 'forkpty' function. */\n#undef HAVE_FORKPTY\n\n/* Define to 1 if you have the 'fpathconf' function. */\n#undef HAVE_FPATHCONF\n\n/* Define to 1 if you have the 'fseek64' function. */\n#undef HAVE_FSEEK64\n\n/* Define to 1 if you have the 'fseeko' function. */\n#define HAVE_FSEEKO     1\n\n/* Define to 1 if you have the 'fstatvfs' function. */\n#undef HAVE_FSTATVFS\n\n/* Define if you have the 'fsync' function. */\n#undef HAVE_FSYNC\n\n/* Define to 1 if you have the 'ftell64' function. */\n#undef HAVE_FTELL64\n\n/* Define to 1 if you have the 'ftello' function. */\n#define HAVE_FTELLO     1\n\n/* Define to 1 if you have the 'ftime' function. */\n#undef HAVE_FTIME\n\n/* Define to 1 if you have the 'ftruncate' function. */\n#undef HAVE_FTRUNCATE\n\n/* Define to 1 if you have the 'gai_strerror' function. */\n#undef HAVE_GAI_STRERROR\n\n/* Define to 1 if you have the 'gamma' function. */\n#undef HAVE_GAMMA\n\n/* Define if we can use gcc inline assembler to get and set x87 control word\n*/\n#if defined(__GNUC__)\n  #define HAVE_GCC_ASM_FOR_X87  1\n#else\n  #undef HAVE_GCC_ASM_FOR_X87\n#endif\n\n/* Define if you have the getaddrinfo function. */\n//#undef HAVE_GETADDRINFO\n#define HAVE_GETADDRINFO  1\n\n/* Define to 1 if you have the 'getcwd' function. */\n#define HAVE_GETCWD   1\n\n/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */\n#undef HAVE_GETC_UNLOCKED\n\n/* Define to 1 if you have the 'getentropy' function. */\n#undef HAVE_GETENTROPY\n\n/* Define to 1 if you have the 'getgroups' function. */\n#undef HAVE_GETGROUPS\n\n/* Define to 1 if you have the 'gethostbyname' function. */\n//#undef HAVE_GETHOSTBYNAME\n#define HAVE_GETHOSTBYNAME  1\n\n/* Define this if you have some version of gethostbyname_r() */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define this if you have the 3-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_3_ARG\n\n/* Define this if you have the 5-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_5_ARG\n\n/* Define this if you have the 6-arg version of gethostbyname_r(). */\n#undef HAVE_GETHOSTBYNAME_R_6_ARG\n\n/* Define to 1 if you have the 'getitimer' function. */\n#undef HAVE_GETITIMER\n\n/* Define to 1 if you have the 'getloadavg' function. */\n#undef HAVE_GETLOADAVG\n\n/* Define to 1 if you have the 'getlogin' function. */\n#undef HAVE_GETLOGIN\n\n/* Define to 1 if you have the 'getnameinfo' function. */\n//#undef HAVE_GETNAMEINFO\n#define HAVE_GETNAMEINFO 1\n\n/* Define if you have the 'getpagesize' function. */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the 'getpeername' function. */\n#define HAVE_GETPEERNAME  1\n\n/* Define to 1 if you have the 'getpgid' function. */\n#undef HAVE_GETPGID\n\n/* Define to 1 if you have the 'getpgrp' function. */\n#undef HAVE_GETPGRP\n\n/* Define to 1 if you have the 'getpid' function. */\n#undef HAVE_GETPID\n\n/* Define to 1 if you have the 'getpriority' function. */\n#undef HAVE_GETPRIORITY\n\n/* Define to 1 if you have the 'getpwent' function. */\n#undef HAVE_GETPWENT\n\n/* Define to 1 if you have the 'getresgid' function. */\n#undef HAVE_GETRESGID\n\n/* Define to 1 if you have the 'getresuid' function. */\n#undef HAVE_GETRESUID\n\n/* Define to 1 if you have the 'getsid' function. */\n#undef HAVE_GETSID\n\n/* Define to 1 if you have the 'getspent' function. */\n#undef HAVE_GETSPENT\n\n/* Define to 1 if you have the 'getspnam' function. */\n#undef HAVE_GETSPNAM\n\n/* Define to 1 if you have the 'gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the 'getwd' function. */\n#undef HAVE_GETWD\n\n/* Define to 1 if you have the <grp.h> header file. */\n#undef HAVE_GRP_H\n\n/* Define if you have the 'hstrerror' function. */\n#undef HAVE_HSTRERROR\n\n/* Define to 1 if you have the 'hypot' function. */\n#undef HAVE_HYPOT\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define if you have the 'inet_aton' function. */\n#define HAVE_INET_ATON    1\n\n/* Define if you have the 'inet_pton' function. */\n#define HAVE_INET_PTON    1\n\n/* Define to 1 if you have the 'initgroups' function. */\n#undef HAVE_INITGROUPS\n\n/* Define if your compiler provides int32_t. */\n#undef HAVE_INT32_T\n\n/* Define if your compiler provides int64_t. */\n#undef HAVE_INT64_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H   1\n\n/* Define to 1 if you have the <io.h> header file. */\n#undef HAVE_IO_H\n\n/* Define to 1 if you have the 'kill' function. */\n#undef HAVE_KILL\n\n/* Define to 1 if you have the 'killpg' function. */\n#undef HAVE_KILLPG\n\n/* Define if you have the 'kqueue' functions. */\n#undef HAVE_KQUEUE\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H   /* non-functional in EFI. */\n\n/* Defined to enable large file support when an off_t is bigger than a long\n   and long long is available and at least as big as an off_t. You may need to\n   add some flags for configuration and compilation to enable this mode. (For\n   Solaris and Linux, the necessary defines are already defined.) */\n#undef HAVE_LARGEFILE_SUPPORT\n\n/* Define to 1 if you have the 'lchflags' function. */\n#undef HAVE_LCHFLAGS\n\n/* Define to 1 if you have the 'lchmod' function. */\n#undef HAVE_LCHMOD\n\n/* Define to 1 if you have the 'lchown' function. */\n#undef HAVE_LCHOWN\n\n/* Define to 1 if you have the 'lgamma' function. */\n#undef HAVE_LGAMMA\n\n/* Define to 1 if you have the 'dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the 'dld' library (-ldld). */\n#undef HAVE_LIBDLD\n\n/* Define to 1 if you have the 'ieee' library (-lieee). */\n#undef HAVE_LIBIEEE\n\n/* Define to 1 if you have the <libintl.h> header file. */\n#undef HAVE_LIBINTL_H\n\n/* Define if you have the readline library (-lreadline). */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the 'resolv' library (-lresolv). */\n#undef HAVE_LIBRESOLV\n\n/* Define to 1 if you have the <libutil.h> header file. */\n#undef HAVE_LIBUTIL_H\n\n/* Define if you have the 'link' function. */\n#undef HAVE_LINK\n\n/* Define to 1 if you have the <linux/netlink.h> header file. */\n#undef HAVE_LINUX_NETLINK_H\n\n/* Define to 1 if you have the <linux/tipc.h> header file. */\n#undef HAVE_LINUX_TIPC_H\n\n/* Define to 1 if you have the 'log1p' function. */\n#undef HAVE_LOG1P\n\n/* Define this if you have the type long double. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define this if you have the type long long. */\n#define HAVE_LONG_LONG  1\n\n/* Define to 1 if you have the 'lstat' function. */\n#define HAVE_LSTAT      1\n\n/* Define this if you have the makedev macro. */\n#undef HAVE_MAKEDEV\n\n/* Define to 1 if you have the 'memmove' function. */\n#define HAVE_MEMMOVE    1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the 'mkfifo' function. */\n#undef HAVE_MKFIFO\n\n/* Define to 1 if you have the 'mknod' function. */\n#undef HAVE_MKNOD\n\n/* Define to 1 if you have the 'mktime' function. */\n#define HAVE_MKTIME     1\n\n/* Define to 1 if you have the 'mmap' function. */\n#undef HAVE_MMAP\n\n/* Define to 1 if you have the 'mremap' function. */\n#undef HAVE_MREMAP\n\n/* Define to 1 if you have the <ncurses.h> header file. */\n#undef HAVE_NCURSES_H\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netpacket/packet.h> header file. */\n#undef HAVE_NETPACKET_PACKET_H\n\n/* Define to 1 if you have the 'nice' function. */\n#undef HAVE_NICE\n\n/* Define to 1 if you have the 'openpty' function. */\n#undef HAVE_OPENPTY\n\n/* Define if compiling using MacOS X 10.5 SDK or later. */\n#undef HAVE_OSX105_SDK\n\n/* Define to 1 if you have the 'pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if you have the 'pause' function. */\n#undef HAVE_PAUSE\n\n/* Define to 1 if you have the 'plock' function. */\n#undef HAVE_PLOCK\n\n/* Define to 1 if you have the 'poll' function. */\n#define HAVE_POLL         1\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the <process.h> header file. */\n#undef HAVE_PROCESS_H\n\n/* Define if your compiler supports function prototype */\n#define HAVE_PROTOTYPES   1\n\n/* Define if you have GNU PTH threads. */\n#undef HAVE_PTH\n\n/* Define to 1 if you have the 'pthread_atfork' function. */\n#undef HAVE_PTHREAD_ATFORK\n\n/* Defined for Solaris 2.6 bug in pthread header. */\n#undef HAVE_PTHREAD_DESTRUCTOR\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#undef HAVE_PTHREAD_H\n\n/* Define to 1 if you have the 'pthread_init' function. */\n#undef HAVE_PTHREAD_INIT\n\n/* Define to 1 if you have the 'pthread_sigmask' function. */\n#undef HAVE_PTHREAD_SIGMASK\n\n/* Define to 1 if you have the <pty.h> header file. */\n#undef HAVE_PTY_H\n\n/* Define to 1 if you have the 'putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define if the libcrypto has RAND_egd */\n#undef HAVE_RAND_EGD\n\n/* Define to 1 if you have the 'readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the 'realpath' function. */\n#define HAVE_REALPATH   1\n\n/* Define if you have readline 2.1 */\n#undef HAVE_RL_CALLBACK\n\n/* Define if you can turn off readline's signal handling. */\n#undef HAVE_RL_CATCH_SIGNAL\n\n/* Define if you have readline 2.2 */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK\n\n/* Define if you have readline 4.2 */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define if you have rl_completion_suppress_append */\n#undef HAVE_RL_COMPLETION_SUPPRESS_APPEND\n\n/* Define if you have readline 4.0 */\n#undef HAVE_RL_PRE_INPUT_HOOK\n\n/* Define to 1 if you have the 'round' function. */\n#undef HAVE_ROUND\n\n/* Define to 1 if you have the 'select' function. */\n#define HAVE_SELECT       1\n\n/* Define to 1 if you have the 'sem_getvalue' function. */\n#undef HAVE_SEM_GETVALUE\n\n/* Define to 1 if you have the 'sem_open' function. */\n#undef HAVE_SEM_OPEN\n\n/* Define to 1 if you have the 'sem_timedwait' function. */\n#undef HAVE_SEM_TIMEDWAIT\n\n/* Define to 1 if you have the 'sem_unlink' function. */\n#undef HAVE_SEM_UNLINK\n\n/* Define to 1 if you have the 'setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the 'seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the 'setgid' function. */\n#undef HAVE_SETGID\n\n/* Define if you have the 'setgroups' function. */\n#undef HAVE_SETGROUPS\n\n/* Define to 1 if you have the 'setitimer' function. */\n#undef HAVE_SETITIMER\n\n/* Define to 1 if you have the 'setlocale' function. */\n#define HAVE_SETLOCALE    1\n\n/* Define to 1 if you have the 'setpgid' function. */\n#undef HAVE_SETPGID\n\n/* Define to 1 if you have the 'setpgrp' function. */\n#undef HAVE_SETPGRP\n\n/* Define to 1 if you have the 'setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the 'setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the 'setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the 'setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the 'setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the 'setuid' function. */\n#undef HAVE_SETUID\n\n/* Define to 1 if you have the 'setvbuf' function. */\n#define HAVE_SETVBUF    1\n\n/* Define to 1 if you have the <shadow.h> header file. */\n#undef HAVE_SHADOW_H\n\n/* Define to 1 if you have the 'sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the 'siginterrupt' function. */\n#undef HAVE_SIGINTERRUPT\n\n/* Define to 1 if you have the <signal.h> header file. */\n#define HAVE_SIGNAL_H   1\n\n/* Define to 1 if you have the 'sigrelse' function. */\n#undef HAVE_SIGRELSE\n\n/* Define to 1 if you have the 'snprintf' function. */\n#define HAVE_SNPRINTF   1\n\n/* Define if sockaddr has sa_len member */\n#undef HAVE_SOCKADDR_SA_LEN\n\n/* struct sockaddr_storage (sys/socket.h) */\n#undef HAVE_SOCKADDR_STORAGE\n\n/* Define if you have the 'socketpair' function. */\n#undef HAVE_SOCKETPAIR\n\n/* Define to 1 if you have the <spawn.h> header file. */\n#undef HAVE_SPAWN_H\n\n/* Define if your compiler provides ssize_t */\n#define HAVE_SSIZE_T    1\n\n/* Define to 1 if you have the 'statvfs' function. */\n#undef HAVE_STATVFS\n\n/* Define if you have struct stat.st_mtim.tv_nsec */\n#undef HAVE_STAT_TV_NSEC\n\n/* Define if you have struct stat.st_mtimensec */\n#undef HAVE_STAT_TV_NSEC2\n\n/* Define if your compiler supports variable length function prototypes (e.g.\n   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */\n#define HAVE_STDARG_PROTOTYPES          1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H   1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H   1\n\n/* Define to 1 if you have the 'strdup' function. */\n#define HAVE_STRDUP     1\n\n/* Define to 1 if you have the 'strftime' function. */\n#define HAVE_STRFTIME   1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H   1\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#undef HAVE_STROPTS_H\n\n/* Define to 1 if 'st_birthtime' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BIRTHTIME   1\n\n/* Define to 1 if 'st_blksize' is a member of 'struct stat'. */\n#define HAVE_STRUCT_STAT_ST_BLKSIZE     1\n\n/* Define to 1 if 'st_blocks' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_BLOCKS\n\n/* Define to 1 if 'st_flags' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_FLAGS\n\n/* Define to 1 if 'st_gen' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_GEN\n\n/* Define to 1 if 'st_rdev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_RDEV\n\n/* Define to 1 if 'st_dev' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_DEV\n\n/* Define to 1 if 'st_ino' is a member of 'struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_INO\n\n/* Define to 1 if 'tm_zone' is a member of 'struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if your 'struct stat' has 'st_blocks'. Deprecated, use\n   'HAVE_STRUCT_STAT_ST_BLOCKS' instead. */\n#undef HAVE_ST_BLOCKS\n\n/* Define if you have the 'symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the 'sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the <sysexits.h> header file. */\n#undef HAVE_SYSEXITS_H\n\n/* Define to 1 if you have the <sys/audioio.h> header file. */\n#undef HAVE_SYS_AUDIOIO_H\n\n/* Define to 1 if you have the <sys/bsdtty.h> header file. */\n#undef HAVE_SYS_BSDTTY_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/epoll.h> header file. */\n#undef HAVE_SYS_EPOLL_H\n\n/* Define to 1 if you have the <sys/event.h> header file. */\n#undef HAVE_SYS_EVENT_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/loadavg.h> header file. */\n#undef HAVE_SYS_LOADAVG_H\n\n/* Define to 1 if you have the <sys/lock.h> header file. */\n#undef HAVE_SYS_LOCK_H\n\n/* Define to 1 if you have the <sys/mkdev.h> header file. */\n#undef HAVE_SYS_MKDEV_H\n\n/* Define to 1 if you have the <sys/modem.h> header file. */\n#undef HAVE_SYS_MODEM_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#define HAVE_SYS_PARAM_H    1\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#define HAVE_SYS_POLL_H                 1\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#define HAVE_SYS_RESOURCE_H   1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H               1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H               1\n\n/* Define to 1 if you have the <sys/statvfs.h> header file. */\n#undef HAVE_SYS_STATVFS_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H   1\n\n/* Define to 1 if you have the <sys/termio.h> header file. */\n#undef HAVE_SYS_TERMIO_H\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n#undef HAVE_SYS_TIMES_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H     1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H    1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#undef HAVE_SYS_UTSNAME_H\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the system() command. */\n#define HAVE_SYSTEM       1\n\n/* Define to 1 if you have the 'tcgetpgrp' function. */\n#undef HAVE_TCGETPGRP\n\n/* Define to 1 if you have the 'tcsetpgrp' function. */\n#undef HAVE_TCSETPGRP\n\n/* Define to 1 if you have the 'tempnam' function. */\n#define HAVE_TEMPNAM      1\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <term.h> header file. */\n#undef HAVE_TERM_H\n\n/* Define to 1 if you have the 'tgamma' function. */\n#undef HAVE_TGAMMA\n\n/* Define to 1 if you have the <thread.h> header file. */\n#undef HAVE_THREAD_H\n\n/* Define to 1 if you have the 'timegm' function. */\n#undef HAVE_TIMEGM\n\n/* Define to 1 if you have the 'times' function. */\n#undef HAVE_TIMES\n\n/* Define to 1 if you have the 'tmpfile' function. */\n#define HAVE_TMPFILE    1\n\n/* Define to 1 if you have the 'tmpnam' function. */\n#define HAVE_TMPNAM     1\n\n/* Define to 1 if you have the 'tmpnam_r' function. */\n#undef HAVE_TMPNAM_R\n\n/* Define to 1 if your 'struct tm' has 'tm_zone'. Deprecated, use\n   'HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the 'truncate' function. */\n#undef HAVE_TRUNCATE\n\n/* Define to 1 if you don't have 'tm_zone' but do have the external array\n   'tzname'. */\n#undef HAVE_TZNAME\n\n/* Define this if you have tcl and TCL_UTF_MAX==6 */\n#undef HAVE_UCS4_TCL\n\n/* Define if your compiler provides uint32_t. */\n#undef HAVE_UINT32_T\n\n/* Define if your compiler provides uint64_t. */\n#undef HAVE_UINT64_T\n\n/* Define to 1 if the system has the type 'uintptr_t'. */\n#define HAVE_UINTPTR_T    1\n\n/* Define to 1 if you have the 'uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H                   1\n\n/* Define to 1 if you have the 'unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define if you have a useable wchar_t type defined in wchar.h; useable means\n   wchar_t must be an unsigned type with at least 16 bits. (see\n   Include/unicodeobject.h). */\n#define HAVE_USABLE_WCHAR_T             1\n\n/* Define to 1 if you have the <util.h> header file. */\n#undef HAVE_UTIL_H\n\n/* Define to 1 if you have the 'utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H    1\n\n/* Define to 1 if you have the 'wait3' function. */\n#undef HAVE_WAIT3\n\n/* Define to 1 if you have the 'wait4' function. */\n#undef HAVE_WAIT4\n\n/* Define to 1 if you have the 'waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define if the compiler provides a wchar.h header file. */\n#define HAVE_WCHAR_H    1\n\n/* Define to 1 if you have the 'wcscoll' function. */\n#define HAVE_WCSCOLL    1\n\n/* Define if tzset() actually switches the local timezone in a meaningful way.\n   */\n#undef HAVE_WORKING_TZSET\n\n/* Define if the zlib library has inflateCopy */\n#undef HAVE_ZLIB_COPY\n\n/* Define to 1 if you have the '_getpty' function. */\n#undef HAVE__GETPTY\n\n/* Define if you are using Mach cthreads directly under /include */\n#undef HURD_C_THREADS\n\n/* Define if you are using Mach cthreads under mach / */\n#undef MACH_C_THREADS\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in <mkdev.h>.\n   */\n#undef MAJOR_IN_MKDEV\n\n/* Define to 1 if 'major', 'minor', and 'makedev' are declared in\n   <sysmacros.h>. */\n#undef MAJOR_IN_SYSMACROS\n\n/* Define if mvwdelch in curses.h is an expression. */\n#undef MVWDELCH_IS_EXPRESSION\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT   \"edk2-devel@lists.01.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME    \"EDK II Python 2.7.10 Package\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING  \"EDK II Python 2.7.10 Package V0.1\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME   \"EADK_Python\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL   \"http://www.tianocore.org/\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION  \"V0.1\"\n\n/* Define if POSIX semaphores aren't enabled on your system */\n#define POSIX_SEMAPHORES_NOT_ENABLED    1\n\n/* Defined if PTHREAD_SCOPE_SYSTEM supported. */\n#undef PTHREAD_SYSTEM_SCHED_SUPPORTED\n\n/* Define as the preferred size in bits of long digits */\n#undef PYLONG_BITS_IN_DIGIT\n\n/* Define to printf format modifier for long long type */\n#define PY_FORMAT_LONG_LONG   \"ll\"\n\n/* Define to printf format modifier for Py_ssize_t */\n#define PY_FORMAT_SIZE_T    \"z\"\n\n/* Define as the integral type used for Unicode representation. */\n#define PY_UNICODE_TYPE     wchar_t\n\n/* Define if you want to build an interpreter with many run-time checks. */\n#undef Py_DEBUG\n\n/* Defined if Python is built as a shared library. */\n#undef Py_ENABLE_SHARED\n\n/* Define as the size of the unicode type. */\n#define Py_UNICODE_SIZE   2\n\n/* Define if you want to have a Unicode type. */\n#define Py_USING_UNICODE\n\n/* assume C89 semantics that RETSIGTYPE is always void */\n#undef RETSIGTYPE\n\n/* Define if setpgrp() must be called as setpgrp(0, 0). */\n#undef SETPGRP_HAVE_ARG\n\n/* Define this to be extension of shared libraries (including the dot!). */\n#undef SHLIB_EXT\n\n/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */\n#undef SIGNED_RIGHT_SHIFT_ZERO_FILLS\n\n/* The size of 'double', as computed by sizeof. */\n#define SIZEOF_DOUBLE     8\n\n/* The size of 'float', as computed by sizeof. */\n#define SIZEOF_FLOAT      4\n\n/* The size of 'fpos_t', as computed by sizeof. */\n#define SIZEOF_FPOS_T     8\n\n/* The size of 'int', as computed by sizeof. */\n#define SIZEOF_INT        4\n\n/* The size of 'long', as computed by sizeof. */\n#if defined(_MSC_VER)           /* Handle Microsoft VC++ compiler specifics. */\n#define SIZEOF_LONG       4\n#else\n#define SIZEOF_LONG       8\n#endif\n\n/* The size of 'long double', as computed by sizeof. */\n#undef SIZEOF_LONG_DOUBLE\n\n/* The size of 'long long', as computed by sizeof. */\n#define SIZEOF_LONG_LONG  8\n\n/* The size of 'off_t', as computed by sizeof. */\n#define SIZEOF_OFF_T      8\n\n/* The size of 'pid_t', as computed by sizeof. */\n#define SIZEOF_PID_T      4\n\n/* The size of 'pthread_t', as computed by sizeof. */\n#undef SIZEOF_PTHREAD_T\n\n/* The size of 'short', as computed by sizeof. */\n#define SIZEOF_SHORT      2\n\n/* The size of 'size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T     8\n\n/* The size of 'time_t', as computed by sizeof. */\n#define SIZEOF_TIME_T     4\n\n/* The size of 'uintptr_t', as computed by sizeof. */\n#define SIZEOF_UINTPTR_T  8\n\n/* The size of 'void *', as computed by sizeof. */\n#define SIZEOF_VOID_P     8\n\n/* The size of 'wchar_t', as computed by sizeof. */\n#define SIZEOF_WCHAR_T    2\n\n/* The size of '_Bool', as computed by sizeof. */\n#define SIZEOF__BOOL      1\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS    1\n\n/* Define if you can safely include both <sys/select.h> and <sys/time.h>\n   (which you can't on SCO ODT 3.0). */\n#undef SYS_SELECT_WITH_SYS_TIME\n\n/* Define if tanh(-0.) is -0., or if platform doesn't have signed zeros */\n#undef TANH_PRESERVES_ZERO_SIGN\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if your <sys/time.h> declares 'struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Enable extensions on AIX 3, Interix.  */\n#ifndef _ALL_SOURCE\n# undef _ALL_SOURCE\n#endif\n/* Enable GNU extensions on systems that have them.  */\n#ifndef _GNU_SOURCE\n# undef _GNU_SOURCE\n#endif\n/* Enable threading extensions on Solaris.  */\n#ifndef _POSIX_PTHREAD_SEMANTICS\n# undef _POSIX_PTHREAD_SEMANTICS\n#endif\n/* Enable extensions on HP NonStop.  */\n#ifndef _TANDEM_SOURCE\n# undef _TANDEM_SOURCE\n#endif\n/* Enable general extensions on Solaris.  */\n#ifndef __EXTENSIONS__\n# undef __EXTENSIONS__\n#endif\n\n\n/* Define if you want to use MacPython modules on MacOSX in unix-Python. */\n#undef USE_TOOLBOX_OBJECT_GLUE\n\n/* Define if a va_list is an array of some kind */\n#undef VA_LIST_IS_ARRAY\n\n/* Define if you want SIGFPE handled (see Include/pyfpe.h). */\n#undef WANT_SIGFPE_HANDLER\n\n/* Define if you want wctype.h functions to be used instead of the one\n   supplied by Python itself. (see Include/unicodectype.h). */\n#define WANT_WCTYPE_FUNCTIONS   1\n\n/* Define if WINDOW in curses.h offers a field _flags. */\n#undef WINDOW_HAS_FLAGS\n\n/* Define if you want documentation strings in extension modules */\n#undef WITH_DOC_STRINGS\n\n/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic\n   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).\n   Dyld is necessary to support frameworks. */\n#undef WITH_DYLD\n\n/* Define to 1 if libintl is needed for locale functions. */\n#undef WITH_LIBINTL\n\n/* Define if you want to produce an OpenStep/Rhapsody framework (shared\n   library plus accessory files). */\n#undef WITH_NEXT_FRAMEWORK\n\n/* Define if you want to compile in Python-specific mallocs */\n#undef WITH_PYMALLOC\n\n/* Define if you want to compile in rudimentary thread support */\n#undef WITH_THREAD\n\n/* Define to profile with the Pentium timestamp counter */\n#undef WITH_TSC\n\n/* Define if you want pymalloc to be disabled when running under valgrind */\n#undef WITH_VALGRIND\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define if arithmetic is subject to x87-style double rounding issue */\n#undef X87_DOUBLE_ROUNDING\n\n/* Define on OpenBSD to activate all library features */\n#undef _BSD_SOURCE\n\n/* Define on Irix to enable u_int */\n#undef _BSD_TYPES\n\n/* Define on Darwin to activate all library features */\n#undef _DARWIN_C_SOURCE\n\n/* This must be set to 64 on some systems to enable large file support. */\n#undef _FILE_OFFSET_BITS\n\n/* Define on Linux to activate all library features */\n#undef _GNU_SOURCE\n\n/* This must be defined on some systems to enable large file support. */\n#undef _LARGEFILE_SOURCE\n\n/* This must be defined on AIX systems to enable large file support. */\n#undef _LARGE_FILES\n\n/* Define to 1 if on MINIX. */\n#undef _MINIX\n\n/* Define on NetBSD to activate all library features */\n  #define _NETBSD_SOURCE  1\n\n/* Define _OSF_SOURCE to get the makedev macro. */\n#undef _OSF_SOURCE\n\n/* Define to 2 if the system does not provide POSIX.1 features except with\n   this defined. */\n#undef _POSIX_1_SOURCE\n\n/* Define to activate features from IEEE Stds 1003.1-2001 */\n#undef _POSIX_C_SOURCE\n\n/* Define to 1 if you need to in order for 'stat' and other things to work. */\n#undef _POSIX_SOURCE\n\n/* Define if you have POSIX threads, and your system does not define that. */\n#undef _POSIX_THREADS\n\n/* Define to force use of thread-safe errno, h_errno, and other functions */\n#undef _REENTRANT\n\n/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT32_T\n\n/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,\n   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n   #define below would cause a syntax error. */\n#undef _UINT64_T\n\n/* Define to the level of X/Open that your system supports */\n#undef _XOPEN_SOURCE\n\n/* Define to activate Unix95-and-earlier features */\n#undef _XOPEN_SOURCE_EXTENDED\n\n/* Define on FreeBSD to activate all library features */\n#undef __BSD_VISIBLE\n\n/* Define to 1 if type 'char' is unsigned and you are not using gcc.  */\n#ifndef __CHAR_UNSIGNED__\n# undef __CHAR_UNSIGNED__\n#endif\n\n/* Defined on Solaris to see additional function prototypes. */\n#undef __EXTENSIONS__\n\n/* Define to 'long' if <time.h> doesn't define. */\n//#undef clock_t\n\n/* Define to empty if 'const' does not conform to ANSI C. */\n//#undef const\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef gid_t\n\n/* Define to the type of a signed integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int32_t\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef int64_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef mode_t\n\n/* Define to 'long int' if <sys/types.h> does not define. */\n//#undef off_t\n\n/* Define to 'int' if <sys/types.h> does not define. */\n//#undef pid_t\n\n/* Define to empty if the keyword does not work. */\n//#undef signed\n\n/* Define to 'unsigned int' if <sys/types.h> does not define. */\n//#undef size_t\n\n/* Define to 'int' if <sys/socket.h> does not define. */\n//#undef socklen_t\n\n/* Define to 'int' if <sys/types.h> doesn't define. */\n//#undef uid_t\n\n/* Define to the type of an unsigned integer type of width exactly 32 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint32_t\n\n/* Define to the type of an unsigned integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n//#undef uint64_t\n\n/* Define to empty if the keyword does not work. */\n//#undef volatile\n\n#endif /*Py_PYCONFIG_H*/\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_sys.py": "# -*- coding: iso-8859-1 -*-\nimport unittest, test.test_support\nimport sys, os, cStringIO\nimport struct\nimport operator\n\nclass SysModuleTest(unittest.TestCase):\n\n    def tearDown(self):\n        test.test_support.reap_children()\n\n    def test_original_displayhook(self):\n        import __builtin__\n        savestdout = sys.stdout\n        out = cStringIO.StringIO()\n        sys.stdout = out\n\n        dh = sys.__displayhook__\n\n        self.assertRaises(TypeError, dh)\n        if hasattr(__builtin__, \"_\"):\n            del __builtin__._\n\n        dh(None)\n        self.assertEqual(out.getvalue(), \"\")\n        self.assertTrue(not hasattr(__builtin__, \"_\"))\n        dh(42)\n        self.assertEqual(out.getvalue(), \"42\\n\")\n        self.assertEqual(__builtin__._, 42)\n\n        del sys.stdout\n        self.assertRaises(RuntimeError, dh, 42)\n\n        sys.stdout = savestdout\n\n    def test_lost_displayhook(self):\n        olddisplayhook = sys.displayhook\n        del sys.displayhook\n        code = compile(\"42\", \"<string>\", \"single\")\n        self.assertRaises(RuntimeError, eval, code)\n        sys.displayhook = olddisplayhook\n\n    def test_custom_displayhook(self):\n        olddisplayhook = sys.displayhook\n        def baddisplayhook(obj):\n            raise ValueError\n        sys.displayhook = baddisplayhook\n        code = compile(\"42\", \"<string>\", \"single\")\n        self.assertRaises(ValueError, eval, code)\n        sys.displayhook = olddisplayhook\n\n    def test_original_excepthook(self):\n        savestderr = sys.stderr\n        err = cStringIO.StringIO()\n        sys.stderr = err\n\n        eh = sys.__excepthook__\n\n        self.assertRaises(TypeError, eh)\n        try:\n            raise ValueError(42)\n        except ValueError, exc:\n            eh(*sys.exc_info())\n\n        sys.stderr = savestderr\n        self.assertTrue(err.getvalue().endswith(\"ValueError: 42\\n\"))\n\n    # FIXME: testing the code for a lost or replaced excepthook in\n    # Python/pythonrun.c::PyErr_PrintEx() is tricky.\n\n    def test_exc_clear(self):\n        self.assertRaises(TypeError, sys.exc_clear, 42)\n\n        # Verify that exc_info is present and matches exc, then clear it, and\n        # check that it worked.\n        def clear_check(exc):\n            typ, value, traceback = sys.exc_info()\n            self.assertTrue(typ is not None)\n            self.assertTrue(value is exc)\n            self.assertTrue(traceback is not None)\n\n            with test.test_support.check_py3k_warnings():\n                sys.exc_clear()\n\n            typ, value, traceback = sys.exc_info()\n            self.assertTrue(typ is None)\n            self.assertTrue(value is None)\n            self.assertTrue(traceback is None)\n\n        def clear():\n            try:\n                raise ValueError, 42\n            except ValueError, exc:\n                clear_check(exc)\n\n        # Raise an exception and check that it can be cleared\n        clear()\n\n        # Verify that a frame currently handling an exception is\n        # unaffected by calling exc_clear in a nested frame.\n        try:\n            raise ValueError, 13\n        except ValueError, exc:\n            typ1, value1, traceback1 = sys.exc_info()\n            clear()\n            typ2, value2, traceback2 = sys.exc_info()\n\n            self.assertTrue(typ1 is typ2)\n            self.assertTrue(value1 is exc)\n            self.assertTrue(value1 is value2)\n            self.assertTrue(traceback1 is traceback2)\n\n        # Check that an exception can be cleared outside of an except block\n        clear_check(exc)\n\n    def test_exit(self):\n        self.assertRaises(TypeError, sys.exit, 42, 42)\n\n        # call without argument\n        try:\n            sys.exit(0)\n        except SystemExit, exc:\n            self.assertEqual(exc.code, 0)\n        except:\n            self.fail(\"wrong exception\")\n        else:\n            self.fail(\"no exception\")\n\n        # call with tuple argument with one entry\n        # entry will be unpacked\n        try:\n            sys.exit(42)\n        except SystemExit, exc:\n            self.assertEqual(exc.code, 42)\n        except:\n            self.fail(\"wrong exception\")\n        else:\n            self.fail(\"no exception\")\n\n        # call with integer argument\n        try:\n            sys.exit((42,))\n        except SystemExit, exc:\n            self.assertEqual(exc.code, 42)\n        except:\n            self.fail(\"wrong exception\")\n        else:\n            self.fail(\"no exception\")\n\n        # call with string argument\n        try:\n            sys.exit(\"exit\")\n        except SystemExit, exc:\n            self.assertEqual(exc.code, \"exit\")\n        except:\n            self.fail(\"wrong exception\")\n        else:\n            self.fail(\"no exception\")\n\n        # call with tuple argument with two entries\n        try:\n            sys.exit((17, 23))\n        except SystemExit, exc:\n            self.assertEqual(exc.code, (17, 23))\n        except:\n            self.fail(\"wrong exception\")\n        else:\n            self.fail(\"no exception\")\n\n        # test that the exit machinery handles SystemExits properly\n        import subprocess\n        # both unnormalized...\n        rc = subprocess.call([sys.executable, \"-c\",\n                              \"raise SystemExit, 46\"])\n        self.assertEqual(rc, 46)\n        # ... and normalized\n        rc = subprocess.call([sys.executable, \"-c\",\n                              \"raise SystemExit(47)\"])\n        self.assertEqual(rc, 47)\n\n        def check_exit_message(code, expected, env=None):\n            process = subprocess.Popen([sys.executable, \"-c\", code],\n                                       stderr=subprocess.PIPE, env=env)\n            stdout, stderr = process.communicate()\n            self.assertEqual(process.returncode, 1)\n            self.assertTrue(stderr.startswith(expected),\n                \"%s doesn't start with %s\" % (repr(stderr), repr(expected)))\n\n        # test that stderr buffer if flushed before the exit message is written\n        # into stderr\n        check_exit_message(\n            r'import sys; sys.stderr.write(\"unflushed,\"); sys.exit(\"message\")',\n            b\"unflushed,message\")\n\n        # test that the unicode message is encoded to the stderr encoding\n        env = os.environ.copy()\n        env['PYTHONIOENCODING'] = 'latin-1'\n        check_exit_message(\n            r'import sys; sys.exit(u\"h\\xe9\")',\n            b\"h\\xe9\", env=env)\n\n    def test_getdefaultencoding(self):\n        if test.test_support.have_unicode:\n            self.assertRaises(TypeError, sys.getdefaultencoding, 42)\n            # can't check more than the type, as the user might have changed it\n            self.assertIsInstance(sys.getdefaultencoding(), str)\n\n    # testing sys.settrace() is done in test_sys_settrace.py\n    # testing sys.setprofile() is done in test_sys_setprofile.py\n\n    def test_setcheckinterval(self):\n        self.assertRaises(TypeError, sys.setcheckinterval)\n        orig = sys.getcheckinterval()\n        for n in 0, 100, 120, orig: # orig last to restore starting state\n            sys.setcheckinterval(n)\n            self.assertEqual(sys.getcheckinterval(), n)\n\n    def test_recursionlimit(self):\n        self.assertRaises(TypeError, sys.getrecursionlimit, 42)\n        oldlimit = sys.getrecursionlimit()\n        self.assertRaises(TypeError, sys.setrecursionlimit)\n        self.assertRaises(ValueError, sys.setrecursionlimit, -42)\n        sys.setrecursionlimit(10000)\n        self.assertEqual(sys.getrecursionlimit(), 10000)\n        sys.setrecursionlimit(oldlimit)\n\n    def test_getwindowsversion(self):\n        # Raise SkipTest if sys doesn't have getwindowsversion attribute\n        test.test_support.get_attribute(sys, \"getwindowsversion\")\n        v = sys.getwindowsversion()\n        self.assertEqual(len(v), 5)\n        self.assertIsInstance(v[0], int)\n        self.assertIsInstance(v[1], int)\n        self.assertIsInstance(v[2], int)\n        self.assertIsInstance(v[3], int)\n        self.assertIsInstance(v[4], str)\n        self.assertRaises(IndexError, operator.getitem, v, 5)\n        self.assertIsInstance(v.major, int)\n        self.assertIsInstance(v.minor, int)\n        self.assertIsInstance(v.build, int)\n        self.assertIsInstance(v.platform, int)\n        self.assertIsInstance(v.service_pack, str)\n        self.assertIsInstance(v.service_pack_minor, int)\n        self.assertIsInstance(v.service_pack_major, int)\n        self.assertIsInstance(v.suite_mask, int)\n        self.assertIsInstance(v.product_type, int)\n        self.assertEqual(v[0], v.major)\n        self.assertEqual(v[1], v.minor)\n        self.assertEqual(v[2], v.build)\n        self.assertEqual(v[3], v.platform)\n        self.assertEqual(v[4], v.service_pack)\n\n        # This is how platform.py calls it. Make sure tuple\n        #  still has 5 elements\n        maj, min, buildno, plat, csd = sys.getwindowsversion()\n\n    def test_dlopenflags(self):\n        if hasattr(sys, \"setdlopenflags\"):\n            self.assertTrue(hasattr(sys, \"getdlopenflags\"))\n            self.assertRaises(TypeError, sys.getdlopenflags, 42)\n            oldflags = sys.getdlopenflags()\n            self.assertRaises(TypeError, sys.setdlopenflags)\n            sys.setdlopenflags(oldflags+1)\n            self.assertEqual(sys.getdlopenflags(), oldflags+1)\n            sys.setdlopenflags(oldflags)\n\n    def test_refcount(self):\n        # n here must be a global in order for this test to pass while\n        # tracing with a python function.  Tracing calls PyFrame_FastToLocals\n        # which will add a copy of any locals to the frame object, causing\n        # the reference count to increase by 2 instead of 1.\n        global n\n        self.assertRaises(TypeError, sys.getrefcount)\n        c = sys.getrefcount(None)\n        n = None\n        self.assertEqual(sys.getrefcount(None), c+1)\n        del n\n        self.assertEqual(sys.getrefcount(None), c)\n        if hasattr(sys, \"gettotalrefcount\"):\n            self.assertIsInstance(sys.gettotalrefcount(), int)\n\n    def test_getframe(self):\n        self.assertRaises(TypeError, sys._getframe, 42, 42)\n        self.assertRaises(ValueError, sys._getframe, 2000000000)\n        self.assertTrue(\n            SysModuleTest.test_getframe.im_func.func_code \\\n            is sys._getframe().f_code\n        )\n\n    # sys._current_frames() is a CPython-only gimmick.\n    def test_current_frames(self):\n        have_threads = True\n        try:\n            import thread\n        except ImportError:\n            have_threads = False\n\n        if have_threads:\n            self.current_frames_with_threads()\n        else:\n            self.current_frames_without_threads()\n\n    # Test sys._current_frames() in a WITH_THREADS build.\n    @test.test_support.reap_threads\n    def current_frames_with_threads(self):\n        import threading, thread\n        import traceback\n\n        # Spawn a thread that blocks at a known place.  Then the main\n        # thread does sys._current_frames(), and verifies that the frames\n        # returned make sense.\n        entered_g = threading.Event()\n        leave_g = threading.Event()\n        thread_info = []  # the thread's id\n\n        def f123():\n            g456()\n\n        def g456():\n            thread_info.append(thread.get_ident())\n            entered_g.set()\n            leave_g.wait()\n\n        t = threading.Thread(target=f123)\n        t.start()\n        entered_g.wait()\n\n        # At this point, t has finished its entered_g.set(), although it's\n        # impossible to guess whether it's still on that line or has moved on\n        # to its leave_g.wait().\n        self.assertEqual(len(thread_info), 1)\n        thread_id = thread_info[0]\n\n        d = sys._current_frames()\n\n        main_id = thread.get_ident()\n        self.assertIn(main_id, d)\n        self.assertIn(thread_id, d)\n\n        # Verify that the captured main-thread frame is _this_ frame.\n        frame = d.pop(main_id)\n        self.assertTrue(frame is sys._getframe())\n\n        # Verify that the captured thread frame is blocked in g456, called\n        # from f123.  This is a litte tricky, since various bits of\n        # threading.py are also in the thread's call stack.\n        frame = d.pop(thread_id)\n        stack = traceback.extract_stack(frame)\n        for i, (filename, lineno, funcname, sourceline) in enumerate(stack):\n            if funcname == \"f123\":\n                break\n        else:\n            self.fail(\"didn't find f123() on thread's call stack\")\n\n        self.assertEqual(sourceline, \"g456()\")\n\n        # And the next record must be for g456().\n        filename, lineno, funcname, sourceline = stack[i+1]\n        self.assertEqual(funcname, \"g456\")\n        self.assertIn(sourceline, [\"leave_g.wait()\", \"entered_g.set()\"])\n\n        # Reap the spawned thread.\n        leave_g.set()\n        t.join()\n\n    # Test sys._current_frames() when thread support doesn't exist.\n    def current_frames_without_threads(self):\n        # Not much happens here:  there is only one thread, with artificial\n        # \"thread id\" 0.\n        d = sys._current_frames()\n        self.assertEqual(len(d), 1)\n        self.assertIn(0, d)\n        self.assertTrue(d[0] is sys._getframe())\n\n    def test_attributes(self):\n        self.assertIsInstance(sys.api_version, int)\n        self.assertIsInstance(sys.argv, list)\n        self.assertIn(sys.byteorder, (\"little\", \"big\"))\n        self.assertIsInstance(sys.builtin_module_names, tuple)\n        self.assertIsInstance(sys.copyright, basestring)\n        self.assertIsInstance(sys.exec_prefix, basestring)\n        self.assertIsInstance(sys.executable, basestring)\n        self.assertEqual(len(sys.float_info), 11)\n        self.assertEqual(sys.float_info.radix, 2)\n        self.assertEqual(len(sys.long_info), 2)\n        self.assertTrue(sys.long_info.bits_per_digit % 5 == 0)\n        self.assertTrue(sys.long_info.sizeof_digit >= 1)\n        self.assertEqual(type(sys.long_info.bits_per_digit), int)\n        self.assertEqual(type(sys.long_info.sizeof_digit), int)\n        self.assertIsInstance(sys.hexversion, int)\n        self.assertIsInstance(sys.maxint, int)\n        if test.test_support.have_unicode:\n            self.assertIsInstance(sys.maxunicode, int)\n        self.assertIsInstance(sys.platform, basestring)\n        self.assertIsInstance(sys.prefix, basestring)\n        self.assertIsInstance(sys.version, basestring)\n        vi = sys.version_info\n        self.assertIsInstance(vi[:], tuple)\n        self.assertEqual(len(vi), 5)\n        self.assertIsInstance(vi[0], int)\n        self.assertIsInstance(vi[1], int)\n        self.assertIsInstance(vi[2], int)\n        self.assertIn(vi[3], (\"alpha\", \"beta\", \"candidate\", \"final\"))\n        self.assertIsInstance(vi[4], int)\n        self.assertIsInstance(vi.major, int)\n        self.assertIsInstance(vi.minor, int)\n        self.assertIsInstance(vi.micro, int)\n        self.assertIn(vi.releaselevel, (\"alpha\", \"beta\", \"candidate\", \"final\"))\n        self.assertIsInstance(vi.serial, int)\n        self.assertEqual(vi[0], vi.major)\n        self.assertEqual(vi[1], vi.minor)\n        self.assertEqual(vi[2], vi.micro)\n        self.assertEqual(vi[3], vi.releaselevel)\n        self.assertEqual(vi[4], vi.serial)\n        self.assertTrue(vi > (1,0,0))\n        self.assertIsInstance(sys.float_repr_style, str)\n        self.assertIn(sys.float_repr_style, ('short', 'legacy'))\n\n    def test_43581(self):\n        # Can't use sys.stdout, as this is a cStringIO object when\n        # the test runs under regrtest.\n        self.assertTrue(sys.__stdout__.encoding == sys.__stderr__.encoding)\n\n    def test_sys_flags(self):\n        self.assertTrue(sys.flags)\n        attrs = (\"debug\", \"py3k_warning\", \"division_warning\", \"division_new\",\n                 \"inspect\", \"interactive\", \"optimize\", \"dont_write_bytecode\",\n                 \"no_site\", \"ignore_environment\", \"tabcheck\", \"verbose\",\n                 \"unicode\", \"bytes_warning\")\n        for attr in attrs:\n            self.assertTrue(hasattr(sys.flags, attr), attr)\n            self.assertEqual(type(getattr(sys.flags, attr)), int, attr)\n        self.assertTrue(repr(sys.flags))\n\n    def test_clear_type_cache(self):\n        sys._clear_type_cache()\n\n    def test_ioencoding(self):\n        import subprocess\n        env = dict(os.environ)\n\n        # Test character: cent sign, encoded as 0x4A (ASCII J) in CP424,\n        # not representable in ASCII.\n\n        env[\"PYTHONIOENCODING\"] = \"cp424\"\n        p = subprocess.Popen([sys.executable, \"-c\", 'print unichr(0xa2)'],\n                             stdout = subprocess.PIPE, env=env)\n        out = p.communicate()[0].strip()\n        self.assertEqual(out, unichr(0xa2).encode(\"cp424\"))\n\n        env[\"PYTHONIOENCODING\"] = \"ascii:replace\"\n        p = subprocess.Popen([sys.executable, \"-c\", 'print unichr(0xa2)'],\n                             stdout = subprocess.PIPE, env=env)\n        out = p.communicate()[0].strip()\n        self.assertEqual(out, '?')\n\n    def test_call_tracing(self):\n        self.assertEqual(sys.call_tracing(str, (2,)), \"2\")\n        self.assertRaises(TypeError, sys.call_tracing, str, 2)\n\n    def test_executable(self):\n        # Issue #7774: Ensure that sys.executable is an empty string if argv[0]\n        # has been set to an non existent program name and Python is unable to\n        # retrieve the real program name\n        import subprocess\n        # For a normal installation, it should work without 'cwd'\n        # argument. For test runs in the build directory, see #7774.\n        python_dir = os.path.dirname(os.path.realpath(sys.executable))\n        p = subprocess.Popen(\n            [\"nonexistent\", \"-c\", 'import sys; print repr(sys.executable)'],\n            executable=sys.executable, stdout=subprocess.PIPE, cwd=python_dir)\n        executable = p.communicate()[0].strip()\n        p.wait()\n        self.assertIn(executable, [\"''\", repr(sys.executable)])\n\nclass SizeofTest(unittest.TestCase):\n\n    TPFLAGS_HAVE_GC = 1<<14\n    TPFLAGS_HEAPTYPE = 1L<<9\n\n    def setUp(self):\n        self.c = len(struct.pack('c', ' '))\n        self.H = len(struct.pack('H', 0))\n        self.i = len(struct.pack('i', 0))\n        self.l = len(struct.pack('l', 0))\n        self.P = len(struct.pack('P', 0))\n        # due to missing size_t information from struct, it is assumed that\n        # sizeof(Py_ssize_t) = sizeof(void*)\n        self.header = 'PP'\n        self.vheader = self.header + 'P'\n        if hasattr(sys, \"gettotalrefcount\"):\n            self.header += '2P'\n            self.vheader += '2P'\n        self.longdigit = sys.long_info.sizeof_digit\n        import _testcapi\n        self.gc_headsize = _testcapi.SIZEOF_PYGC_HEAD\n        self.file = open(test.test_support.TESTFN, 'wb')\n\n    def tearDown(self):\n        self.file.close()\n        test.test_support.unlink(test.test_support.TESTFN)\n\n    def check_sizeof(self, o, size):\n        result = sys.getsizeof(o)\n        if ((type(o) == type) and (o.__flags__ & self.TPFLAGS_HEAPTYPE) or\\\n           ((type(o) != type) and (type(o).__flags__ & self.TPFLAGS_HAVE_GC))):\n            size += self.gc_headsize\n        msg = 'wrong size for %s: got %d, expected %d' \\\n                % (type(o), result, size)\n        self.assertEqual(result, size, msg)\n\n    def calcsize(self, fmt):\n        \"\"\"Wrapper around struct.calcsize which enforces the alignment of the\n        end of a structure to the alignment requirement of pointer.\n\n        Note: This wrapper should only be used if a pointer member is included\n        and no member with a size larger than a pointer exists.\n        \"\"\"\n        return struct.calcsize(fmt + '0P')\n\n    def test_gc_head_size(self):\n        # Check that the gc header size is added to objects tracked by the gc.\n        h = self.header\n        size = self.calcsize\n        gc_header_size = self.gc_headsize\n        # bool objects are not gc tracked\n        self.assertEqual(sys.getsizeof(True), size(h + 'l'))\n        # but lists are\n        self.assertEqual(sys.getsizeof([]), size(h + 'P PP') + gc_header_size)\n\n    def test_default(self):\n        h = self.header\n        size = self.calcsize\n        self.assertEqual(sys.getsizeof(True, -1), size(h + 'l'))\n\n    def test_objecttypes(self):\n        # check all types defined in Objects/\n        h = self.header\n        vh = self.vheader\n        size = self.calcsize\n        check = self.check_sizeof\n        # bool\n        check(True, size(h + 'l'))\n        # buffer\n        with test.test_support.check_py3k_warnings():\n            check(buffer(''), size(h + '2P2Pil'))\n        # builtin_function_or_method\n        check(len, size(h + '3P'))\n        # bytearray\n        samples = ['', 'u'*100000]\n        for sample in samples:\n            x = bytearray(sample)\n            check(x, size(vh + 'iPP') + x.__alloc__() * self.c)\n        # bytearray_iterator\n        check(iter(bytearray()), size(h + 'PP'))\n        # cell\n        def get_cell():\n            x = 42\n            def inner():\n                return x\n            return inner\n        check(get_cell().func_closure[0], size(h + 'P'))\n        # classobj (old-style class)\n        class class_oldstyle():\n            def method():\n                pass\n        check(class_oldstyle, size(h + '7P'))\n        # instance (old-style class)\n        check(class_oldstyle(), size(h + '3P'))\n        # instancemethod (old-style class)\n        check(class_oldstyle().method, size(h + '4P'))\n        # complex\n        check(complex(0,1), size(h + '2d'))\n        # code\n        check(get_cell().func_code, size(h + '4i8Pi3P'))\n        # BaseException\n        check(BaseException(), size(h + '3P'))\n        # UnicodeEncodeError\n        check(UnicodeEncodeError(\"\", u\"\", 0, 0, \"\"), size(h + '5P2PP'))\n        # UnicodeDecodeError\n        check(UnicodeDecodeError(\"\", \"\", 0, 0, \"\"), size(h + '5P2PP'))\n        # UnicodeTranslateError\n        check(UnicodeTranslateError(u\"\", 0, 1, \"\"), size(h + '5P2PP'))\n        # method_descriptor (descriptor object)\n        check(str.lower, size(h + '2PP'))\n        # classmethod_descriptor (descriptor object)\n        # XXX\n        # member_descriptor (descriptor object)\n        import datetime\n        check(datetime.timedelta.days, size(h + '2PP'))\n        # getset_descriptor (descriptor object)\n        import __builtin__\n        check(__builtin__.file.closed, size(h + '2PP'))\n        # wrapper_descriptor (descriptor object)\n        check(int.__add__, size(h + '2P2P'))\n        # dictproxy\n        class C(object): pass\n        check(C.__dict__, size(h + 'P'))\n        # method-wrapper (descriptor object)\n        check({}.__iter__, size(h + '2P'))\n        # dict\n        check({}, size(h + '3P2P' + 8*'P2P'))\n        x = {1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8}\n        check(x, size(h + '3P2P' + 8*'P2P') + 16*size('P2P'))\n        # dictionary-keyiterator\n        check({}.iterkeys(), size(h + 'P2PPP'))\n        # dictionary-valueiterator\n        check({}.itervalues(), size(h + 'P2PPP'))\n        # dictionary-itemiterator\n        check({}.iteritems(), size(h + 'P2PPP'))\n        # ellipses\n        check(Ellipsis, size(h + ''))\n        # EncodingMap\n        import codecs, encodings.iso8859_3\n        x = codecs.charmap_build(encodings.iso8859_3.decoding_table)\n        check(x, size(h + '32B2iB'))\n        # enumerate\n        check(enumerate([]), size(h + 'l3P'))\n        # file\n        check(self.file, size(h + '4P2i4P3i3P3i'))\n        # float\n        check(float(0), size(h + 'd'))\n        # sys.floatinfo\n        check(sys.float_info, size(vh) + self.P * len(sys.float_info))\n        # frame\n        import inspect\n        CO_MAXBLOCKS = 20\n        x = inspect.currentframe()\n        ncells = len(x.f_code.co_cellvars)\n        nfrees = len(x.f_code.co_freevars)\n        extras = x.f_code.co_stacksize + x.f_code.co_nlocals +\\\n                 ncells + nfrees - 1\n        check(x, size(vh + '12P3i' + CO_MAXBLOCKS*'3i' + 'P' + extras*'P'))\n        # function\n        def func(): pass\n        check(func, size(h + '9P'))\n        class c():\n            @staticmethod\n            def foo():\n                pass\n            @classmethod\n            def bar(cls):\n                pass\n            # staticmethod\n            check(foo, size(h + 'P'))\n            # classmethod\n            check(bar, size(h + 'P'))\n        # generator\n        def get_gen(): yield 1\n        check(get_gen(), size(h + 'Pi2P'))\n        # integer\n        check(1, size(h + 'l'))\n        check(100, size(h + 'l'))\n        # iterator\n        check(iter('abc'), size(h + 'lP'))\n        # callable-iterator\n        import re\n        check(re.finditer('',''), size(h + '2P'))\n        # list\n        samples = [[], [1,2,3], ['1', '2', '3']]\n        for sample in samples:\n            check(sample, size(vh + 'PP') + len(sample)*self.P)\n        # sortwrapper (list)\n        # XXX\n        # cmpwrapper (list)\n        # XXX\n        # listiterator (list)\n        check(iter([]), size(h + 'lP'))\n        # listreverseiterator (list)\n        check(reversed([]), size(h + 'lP'))\n        # long\n        check(0L, size(vh))\n        check(1L, size(vh) + self.longdigit)\n        check(-1L, size(vh) + self.longdigit)\n        PyLong_BASE = 2**sys.long_info.bits_per_digit\n        check(long(PyLong_BASE), size(vh) + 2*self.longdigit)\n        check(long(PyLong_BASE**2-1), size(vh) + 2*self.longdigit)\n        check(long(PyLong_BASE**2), size(vh) + 3*self.longdigit)\n        # module\n        check(unittest, size(h + 'P'))\n        # None\n        check(None, size(h + ''))\n        # object\n        check(object(), size(h + ''))\n        # property (descriptor object)\n        class C(object):\n            def getx(self): return self.__x\n            def setx(self, value): self.__x = value\n            def delx(self): del self.__x\n            x = property(getx, setx, delx, \"\")\n            check(x, size(h + '4Pi'))\n        # PyCObject\n        # PyCapsule\n        # XXX\n        # rangeiterator\n        check(iter(xrange(1)), size(h + '4l'))\n        # reverse\n        check(reversed(''), size(h + 'PP'))\n        # set\n        # frozenset\n        PySet_MINSIZE = 8\n        samples = [[], range(10), range(50)]\n        s = size(h + '3P2P' + PySet_MINSIZE*'lP' + 'lP')\n        for sample in samples:\n            minused = len(sample)\n            if minused == 0: tmp = 1\n            # the computation of minused is actually a bit more complicated\n            # but this suffices for the sizeof test\n            minused = minused*2\n            newsize = PySet_MINSIZE\n            while newsize <= minused:\n                newsize = newsize << 1\n            if newsize <= 8:\n                check(set(sample), s)\n                check(frozenset(sample), s)\n            else:\n                check(set(sample), s + newsize*struct.calcsize('lP'))\n                check(frozenset(sample), s + newsize*struct.calcsize('lP'))\n        # setiterator\n        check(iter(set()), size(h + 'P3P'))\n        # slice\n        check(slice(1), size(h + '3P'))\n        # str\n        check('', struct.calcsize(vh + 'li') + 1)\n        check('abc', struct.calcsize(vh + 'li') + 1 + 3*self.c)\n        # super\n        check(super(int), size(h + '3P'))\n        # tuple\n        check((), size(vh))\n        check((1,2,3), size(vh) + 3*self.P)\n        # tupleiterator\n        check(iter(()), size(h + 'lP'))\n        # type\n        # (PyTypeObject + PyNumberMethods +  PyMappingMethods +\n        #  PySequenceMethods + PyBufferProcs)\n        s = size(vh + 'P2P15Pl4PP9PP11PI') + size('41P 10P 3P 6P')\n        class newstyleclass(object):\n            pass\n        check(newstyleclass, s)\n        # builtin type\n        check(int, s)\n        # NotImplementedType\n        import types\n        check(types.NotImplementedType, s)\n        # unicode\n        usize = len(u'\\0'.encode('unicode-internal'))\n        samples = [u'', u'1'*100]\n        # we need to test for both sizes, because we don't know if the string\n        # has been cached\n        for s in samples:\n            check(s, size(h + 'PPlP') + usize * (len(s) + 1))\n        # weakref\n        import weakref\n        check(weakref.ref(int), size(h + '2Pl2P'))\n        # weakproxy\n        # XXX\n        # weakcallableproxy\n        check(weakref.proxy(int), size(h + '2Pl2P'))\n        # xrange\n        check(xrange(1), size(h + '3l'))\n        check(xrange(66000), size(h + '3l'))\n\n    def test_pythontypes(self):\n        # check all types defined in Python/\n        h = self.header\n        vh = self.vheader\n        size = self.calcsize\n        check = self.check_sizeof\n        # _ast.AST\n        import _ast\n        check(_ast.AST(), size(h + ''))\n        # imp.NullImporter\n        import imp\n        check(imp.NullImporter(self.file.name), size(h + ''))\n        try:\n            raise TypeError\n        except TypeError:\n            tb = sys.exc_info()[2]\n            # traceback\n            if tb != None:\n                check(tb, size(h + '2P2i'))\n        # symtable entry\n        # XXX\n        # sys.flags\n        check(sys.flags, size(vh) + self.P * len(sys.flags))\n\n\ndef test_main():\n    test_classes = (SysModuleTest, SizeofTest)\n\n    test.test_support.run_unittest(*test_classes)\n\nif __name__ == \"__main__\":\n    test_main()\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/tests/setuptools_build_ext.py": "from distutils.command.build_ext import build_ext as _du_build_ext\ntry:\n    # Attempt to use Pyrex for building extensions, if available\n    from Pyrex.Distutils.build_ext import build_ext as _build_ext\nexcept ImportError:\n    _build_ext = _du_build_ext\n\nimport os, sys\nfrom distutils.file_util import copy_file\n\nfrom distutils.tests.setuptools_extension import Library\n\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler, get_config_var\nget_config_var(\"LDSHARED\")  # make sure _config_vars is initialized\nfrom distutils.sysconfig import _config_vars\nfrom distutils import log\nfrom distutils.errors import *\n\nhave_rtld = False\nuse_stubs = False\nlibtype = 'shared'\n\nif sys.platform == \"darwin\":\n    use_stubs = True\nelif os.name != 'nt':\n    try:\n        from dl import RTLD_NOW\n        have_rtld = True\n        use_stubs = True\n    except ImportError:\n        pass\n\ndef if_dl(s):\n    if have_rtld:\n        return s\n    return ''\n\n\n\n\n\n\nclass build_ext(_build_ext):\n    def run(self):\n        \"\"\"Build extensions in build directory, then copy if --inplace\"\"\"\n        old_inplace, self.inplace = self.inplace, 0\n        _build_ext.run(self)\n        self.inplace = old_inplace\n        if old_inplace:\n            self.copy_extensions_to_source()\n\n    def copy_extensions_to_source(self):\n        build_py = self.get_finalized_command('build_py')\n        for ext in self.extensions:\n            fullname = self.get_ext_fullname(ext.name)\n            filename = self.get_ext_filename(fullname)\n            modpath = fullname.split('.')\n            package = '.'.join(modpath[:-1])\n            package_dir = build_py.get_package_dir(package)\n            dest_filename = os.path.join(package_dir,os.path.basename(filename))\n            src_filename = os.path.join(self.build_lib,filename)\n\n            # Always copy, even if source is older than destination, to ensure\n            # that the right extensions for the current Python/platform are\n            # used.\n            copy_file(\n                src_filename, dest_filename, verbose=self.verbose,\n                dry_run=self.dry_run\n            )\n            if ext._needs_stub:\n                self.write_stub(package_dir or os.curdir, ext, True)\n\n\n    if _build_ext is not _du_build_ext and not hasattr(_build_ext,'pyrex_sources'):\n        # Workaround for problems using some Pyrex versions w/SWIG and/or 2.4\n        def swig_sources(self, sources, *otherargs):\n            # first do any Pyrex processing\n            sources = _build_ext.swig_sources(self, sources) or sources\n            # Then do any actual SWIG stuff on the remainder\n            return _du_build_ext.swig_sources(self, sources, *otherargs)\n\n\n\n    def get_ext_filename(self, fullname):\n        filename = _build_ext.get_ext_filename(self,fullname)\n        ext = self.ext_map[fullname]\n        if isinstance(ext,Library):\n            fn, ext = os.path.splitext(filename)\n            return self.shlib_compiler.library_filename(fn,libtype)\n        elif use_stubs and ext._links_to_dynamic:\n            d,fn = os.path.split(filename)\n            return os.path.join(d,'dl-'+fn)\n        else:\n            return filename\n\n    def initialize_options(self):\n        _build_ext.initialize_options(self)\n        self.shlib_compiler = None\n        self.shlibs = []\n        self.ext_map = {}\n\n    def finalize_options(self):\n        _build_ext.finalize_options(self)\n        self.extensions = self.extensions or []\n        self.check_extensions_list(self.extensions)\n        self.shlibs = [ext for ext in self.extensions\n                        if isinstance(ext,Library)]\n        if self.shlibs:\n            self.setup_shlib_compiler()\n        for ext in self.extensions:\n            ext._full_name = self.get_ext_fullname(ext.name)\n        for ext in self.extensions:\n            fullname = ext._full_name\n            self.ext_map[fullname] = ext\n            ltd = ext._links_to_dynamic = \\\n                self.shlibs and self.links_to_dynamic(ext) or False\n            ext._needs_stub = ltd and use_stubs and not isinstance(ext,Library)\n            filename = ext._file_name = self.get_ext_filename(fullname)\n            libdir = os.path.dirname(os.path.join(self.build_lib,filename))\n            if ltd and libdir not in ext.library_dirs:\n                ext.library_dirs.append(libdir)\n            if ltd and use_stubs and os.curdir not in ext.runtime_library_dirs:\n                ext.runtime_library_dirs.append(os.curdir)\n\n    def setup_shlib_compiler(self):\n        compiler = self.shlib_compiler = new_compiler(\n            compiler=self.compiler, dry_run=self.dry_run, force=self.force\n        )\n        if sys.platform == \"darwin\":\n            tmp = _config_vars.copy()\n            try:\n                # XXX Help!  I don't have any idea whether these are right...\n                _config_vars['LDSHARED'] = \"gcc -Wl,-x -dynamiclib -undefined dynamic_lookup\"\n                _config_vars['CCSHARED'] = \" -dynamiclib\"\n                _config_vars['SO'] = \".dylib\"\n                customize_compiler(compiler)\n            finally:\n                _config_vars.clear()\n                _config_vars.update(tmp)\n        else:\n            customize_compiler(compiler)\n\n        if self.include_dirs is not None:\n            compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for (name,value) in self.define:\n                compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                compiler.undefine_macro(macro)\n        if self.libraries is not None:\n            compiler.set_libraries(self.libraries)\n        if self.library_dirs is not None:\n            compiler.set_library_dirs(self.library_dirs)\n        if self.rpath is not None:\n            compiler.set_runtime_library_dirs(self.rpath)\n        if self.link_objects is not None:\n            compiler.set_link_objects(self.link_objects)\n\n        # hack so distutils' build_extension() builds a library instead\n        compiler.link_shared_object = link_shared_object.__get__(compiler)\n\n\n\n    def get_export_symbols(self, ext):\n        if isinstance(ext,Library):\n            return ext.export_symbols\n        return _build_ext.get_export_symbols(self,ext)\n\n    def build_extension(self, ext):\n        _compiler = self.compiler\n        try:\n            if isinstance(ext,Library):\n                self.compiler = self.shlib_compiler\n            _build_ext.build_extension(self,ext)\n            if ext._needs_stub:\n                self.write_stub(\n                    self.get_finalized_command('build_py').build_lib, ext\n                )\n        finally:\n            self.compiler = _compiler\n\n    def links_to_dynamic(self, ext):\n        \"\"\"Return true if 'ext' links to a dynamic lib in the same package\"\"\"\n        # XXX this should check to ensure the lib is actually being built\n        # XXX as dynamic, and not just using a locally-found version or a\n        # XXX static-compiled version\n        libnames = dict.fromkeys([lib._full_name for lib in self.shlibs])\n        pkg = '.'.join(ext._full_name.split('.')[:-1]+[''])\n        for libname in ext.libraries:\n            if pkg+libname in libnames: return True\n        return False\n\n    def get_outputs(self):\n        outputs = _build_ext.get_outputs(self)\n        optimize = self.get_finalized_command('build_py').optimize\n        for ext in self.extensions:\n            if ext._needs_stub:\n                base = os.path.join(self.build_lib, *ext._full_name.split('.'))\n                outputs.append(base+'.py')\n                outputs.append(base+'.pyc')\n                if optimize:\n                    outputs.append(base+'.pyo')\n        return outputs\n\n    def write_stub(self, output_dir, ext, compile=False):\n        log.info(\"writing stub loader for %s to %s\",ext._full_name, output_dir)\n        stub_file = os.path.join(output_dir, *ext._full_name.split('.'))+'.py'\n        if compile and os.path.exists(stub_file):\n            raise DistutilsError(stub_file+\" already exists! Please delete.\")\n        if not self.dry_run:\n            f = open(stub_file,'w')\n            f.write('\\n'.join([\n                \"def __bootstrap__():\",\n                \"   global __bootstrap__, __file__, __loader__\",\n                \"   import sys, os, pkg_resources, imp\"+if_dl(\", dl\"),\n                \"   __file__ = pkg_resources.resource_filename(__name__,%r)\"\n                   % os.path.basename(ext._file_name),\n                \"   del __bootstrap__\",\n                \"   if '__loader__' in globals():\",\n                \"       del __loader__\",\n                if_dl(\"   old_flags = sys.getdlopenflags()\"),\n                \"   old_dir = os.getcwd()\",\n                \"   try:\",\n                \"     os.chdir(os.path.dirname(__file__))\",\n                if_dl(\"     sys.setdlopenflags(dl.RTLD_NOW)\"),\n                \"     imp.load_dynamic(__name__,__file__)\",\n                \"   finally:\",\n                if_dl(\"     sys.setdlopenflags(old_flags)\"),\n                \"     os.chdir(old_dir)\",\n                \"__bootstrap__()\",\n                \"\" # terminal \\n\n            ]))\n            f.close()\n        if compile:\n            from distutils.util import byte_compile\n            byte_compile([stub_file], optimize=0,\n                         force=True, dry_run=self.dry_run)\n            optimize = self.get_finalized_command('install_lib').optimize\n            if optimize > 0:\n                byte_compile([stub_file], optimize=optimize,\n                             force=True, dry_run=self.dry_run)\n            if os.path.exists(stub_file) and not self.dry_run:\n                os.unlink(stub_file)\n\n\nif use_stubs or os.name=='nt':\n    # Build shared libraries\n    #\n    def link_shared_object(self, objects, output_libname, output_dir=None,\n        libraries=None, library_dirs=None, runtime_library_dirs=None,\n        export_symbols=None, debug=0, extra_preargs=None,\n        extra_postargs=None, build_temp=None, target_lang=None\n    ):  self.link(\n            self.SHARED_LIBRARY, objects, output_libname,\n            output_dir, libraries, library_dirs, runtime_library_dirs,\n            export_symbols, debug, extra_preargs, extra_postargs,\n            build_temp, target_lang\n        )\nelse:\n    # Build static libraries everywhere else\n    libtype = 'static'\n\n    def link_shared_object(self, objects, output_libname, output_dir=None,\n        libraries=None, library_dirs=None, runtime_library_dirs=None,\n        export_symbols=None, debug=0, extra_preargs=None,\n        extra_postargs=None, build_temp=None, target_lang=None\n    ):\n        # XXX we need to either disallow these attrs on Library instances,\n        #     or warn/abort here if set, or something...\n        #libraries=None, library_dirs=None, runtime_library_dirs=None,\n        #export_symbols=None, extra_preargs=None, extra_postargs=None,\n        #build_temp=None\n\n        assert output_dir is None   # distutils build_ext doesn't pass this\n        output_dir,filename = os.path.split(output_libname)\n        basename, ext = os.path.splitext(filename)\n        if self.library_filename(\"x\").startswith('lib'):\n            # strip 'lib' prefix; this is kludgy if some platform uses\n            # a different prefix\n            basename = basename[3:]\n\n        self.create_static_lib(\n            objects, basename, output_dir, debug, target_lang\n        )\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Python/dynload_shlib.c": "\n/* Support for dynamic loading of extension modules */\n\n#include \"Python.h\"\n#include \"importdl.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(__NetBSD__)\n#include <sys/param.h>\n#if (NetBSD < 199712)\n#include <nlist.h>\n#include <link.h>\n#define dlerror() \"error in dynamic linking\"\n#endif\n#endif /* NetBSD */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#if defined(PYOS_OS2) && defined(PYCC_GCC)\n#include \"dlfcn.h\"\n#endif\n#endif\n\n#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(__ELF__)\n#define LEAD_UNDERSCORE \"_\"\n#else\n#define LEAD_UNDERSCORE \"\"\n#endif\n\n\nconst struct filedescr _PyImport_DynLoadFiletab[] = {\n#ifdef __CYGWIN__\n    {\".dll\", \"rb\", C_EXTENSION},\n    {\"module.dll\", \"rb\", C_EXTENSION},\n#else\n#if defined(PYOS_OS2) && defined(PYCC_GCC)\n    {\".pyd\", \"rb\", C_EXTENSION},\n    {\".dll\", \"rb\", C_EXTENSION},\n#else\n#ifdef __VMS\n    {\".exe\", \"rb\", C_EXTENSION},\n    {\".EXE\", \"rb\", C_EXTENSION},\n    {\"module.exe\", \"rb\", C_EXTENSION},\n    {\"MODULE.EXE\", \"rb\", C_EXTENSION},\n#else\n    {\".so\", \"rb\", C_EXTENSION},\n    {\"module.so\", \"rb\", C_EXTENSION},\n#endif\n#endif\n#endif\n    {0, 0}\n};\n\nstatic struct {\n    dev_t dev;\n#ifdef __VMS\n    ino_t ino[3];\n#else\n    ino_t ino;\n#endif\n    void *handle;\n} handles[128];\nstatic int nhandles = 0;\n\n\ndl_funcptr _PyImport_GetDynLoadFunc(const char *fqname, const char *shortname,\n                                    const char *pathname, FILE *fp)\n{\n    dl_funcptr p;\n    void *handle;\n    char funcname[258];\n    char pathbuf[260];\n    int dlopenflags=0;\n\n    if (strchr(pathname, '/') == NULL) {\n        /* Prefix bare filename with \"./\" */\n        PyOS_snprintf(pathbuf, sizeof(pathbuf), \"./%-.255s\", pathname);\n        pathname = pathbuf;\n    }\n\n    PyOS_snprintf(funcname, sizeof(funcname),\n                  LEAD_UNDERSCORE \"init%.200s\", shortname);\n\n    if (fp != NULL) {\n        int i;\n        struct stat statb;\n        fstat(fileno(fp), &statb);\n        for (i = 0; i < nhandles; i++) {\n            if (statb.st_dev == handles[i].dev &&\n                statb.st_ino == handles[i].ino) {\n                p = (dl_funcptr) dlsym(handles[i].handle,\n                                       funcname);\n                return p;\n            }\n        }\n        if (nhandles < 128) {\n            handles[nhandles].dev = statb.st_dev;\n#ifdef __VMS\n            handles[nhandles].ino[0] = statb.st_ino[0];\n            handles[nhandles].ino[1] = statb.st_ino[1];\n            handles[nhandles].ino[2] = statb.st_ino[2];\n#else\n            handles[nhandles].ino = statb.st_ino;\n#endif\n        }\n    }\n\n#if !(defined(PYOS_OS2) && defined(PYCC_GCC))\n    dlopenflags = PyThreadState_GET()->interp->dlopenflags;\n#endif\n\n    if (Py_VerboseFlag)\n        PySys_WriteStderr(\"dlopen(\\\"%s\\\", %x);\\n\", pathname,\n                          dlopenflags);\n\n#ifdef __VMS\n    /* VMS currently don't allow a pathname, use a logical name instead */\n    /* Concatenate 'python_module_' and shortname */\n    /* so \"import vms.bar\" will use the logical python_module_bar */\n    /* As C module use only one name space this is probably not a */\n    /* important limitation */\n    PyOS_snprintf(pathbuf, sizeof(pathbuf), \"python_module_%-.200s\",\n                  shortname);\n    pathname = pathbuf;\n#endif\n\n    handle = dlopen(pathname, dlopenflags);\n\n    if (handle == NULL) {\n        const char *error = dlerror();\n        if (error == NULL)\n            error = \"unknown dlopen() error\";\n        PyErr_SetString(PyExc_ImportError, error);\n        return NULL;\n    }\n    if (fp != NULL && nhandles < 128)\n        handles[nhandles++].handle = handle;\n    p = (dl_funcptr) dlsym(handle, funcname);\n    return p;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Python/sysmodule.c": "\n/* System module */\n\n/*\nVarious bits of information used by the interpreter are collected in\nmodule 'sys'.\nFunction member:\n- exit(sts): raise SystemExit\nData members:\n- stdin, stdout, stderr: standard file objects\n- modules: the table of modules (dictionary)\n- path: module search path (list of strings)\n- argv: script arguments (list of strings)\n- ps1, ps2: optional primary and secondary prompts (strings)\n*/\n\n#include \"Python.h\"\n#include \"structseq.h\"\n#include \"code.h\"\n#include \"frameobject.h\"\n#include \"eval.h\"\n\n#include \"osdefs.h\"\n\n#ifdef MS_WINDOWS\n#define WIN32_LEAN_AND_MEAN\n#include \"windows.h\"\n#endif /* MS_WINDOWS */\n\n#ifdef MS_COREDLL\nextern void *PyWin_DLLhModule;\n/* A string loaded from the DLL at startup: */\nextern const char *PyWin_DLLVersionString;\n#endif\n\n#ifdef __VMS\n#include <unixlib.h>\n#endif\n\n#ifdef MS_WINDOWS\n#include <windows.h>\n#endif\n\n#ifdef HAVE_LANGINFO_H\n#include <locale.h>\n#include <langinfo.h>\n#endif\n\nPyObject *\nPySys_GetObject(char *name)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *sd = tstate->interp->sysdict;\n    if (sd == NULL)\n        return NULL;\n    return PyDict_GetItemString(sd, name);\n}\n\nFILE *\nPySys_GetFile(char *name, FILE *def)\n{\n    FILE *fp = NULL;\n    PyObject *v = PySys_GetObject(name);\n    if (v != NULL && PyFile_Check(v))\n        fp = PyFile_AsFile(v);\n    if (fp == NULL)\n        fp = def;\n    return fp;\n}\n\nint\nPySys_SetObject(char *name, PyObject *v)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *sd = tstate->interp->sysdict;\n    if (v == NULL) {\n        if (PyDict_GetItemString(sd, name) == NULL)\n            return 0;\n        else\n            return PyDict_DelItemString(sd, name);\n    }\n    else\n        return PyDict_SetItemString(sd, name, v);\n}\n\nstatic PyObject *\nsys_displayhook(PyObject *self, PyObject *o)\n{\n    PyObject *outf;\n    PyInterpreterState *interp = PyThreadState_GET()->interp;\n    PyObject *modules = interp->modules;\n    PyObject *builtins = PyDict_GetItemString(modules, \"__builtin__\");\n\n    if (builtins == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"lost __builtin__\");\n        return NULL;\n    }\n\n    /* Print value except if None */\n    /* After printing, also assign to '_' */\n    /* Before, set '_' to None to avoid recursion */\n    if (o == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    if (PyObject_SetAttrString(builtins, \"_\", Py_None) != 0)\n        return NULL;\n    if (Py_FlushLine() != 0)\n        return NULL;\n    outf = PySys_GetObject(\"stdout\");\n    if (outf == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"lost sys.stdout\");\n        return NULL;\n    }\n    if (PyFile_WriteObject(o, outf, 0) != 0)\n        return NULL;\n    PyFile_SoftSpace(outf, 1);\n    if (Py_FlushLine() != 0)\n        return NULL;\n    if (PyObject_SetAttrString(builtins, \"_\", o) != 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(displayhook_doc,\n\"displayhook(object) -> None\\n\"\n\"\\n\"\n\"Print an object to sys.stdout and also save it in __builtin__._\\n\"\n);\n\nstatic PyObject *\nsys_excepthook(PyObject* self, PyObject* args)\n{\n    PyObject *exc, *value, *tb;\n    if (!PyArg_UnpackTuple(args, \"excepthook\", 3, 3, &exc, &value, &tb))\n        return NULL;\n    PyErr_Display(exc, value, tb);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(excepthook_doc,\n\"excepthook(exctype, value, traceback) -> None\\n\"\n\"\\n\"\n\"Handle an exception by displaying it with a traceback on sys.stderr.\\n\"\n);\n\nstatic PyObject *\nsys_exc_info(PyObject *self, PyObject *noargs)\n{\n    PyThreadState *tstate;\n    tstate = PyThreadState_GET();\n    return Py_BuildValue(\n        \"(OOO)\",\n        tstate->exc_type != NULL ? tstate->exc_type : Py_None,\n        tstate->exc_value != NULL ? tstate->exc_value : Py_None,\n        tstate->exc_traceback != NULL ?\n            tstate->exc_traceback : Py_None);\n}\n\nPyDoc_STRVAR(exc_info_doc,\n\"exc_info() -> (type, value, traceback)\\n\\\n\\n\\\nReturn information about the most recent exception caught by an except\\n\\\nclause in the current stack frame or in an older stack frame.\"\n);\n\nstatic PyObject *\nsys_exc_clear(PyObject *self, PyObject *noargs)\n{\n    PyThreadState *tstate;\n    PyObject *tmp_type, *tmp_value, *tmp_tb;\n\n    if (PyErr_WarnPy3k(\"sys.exc_clear() not supported in 3.x; \"\n                       \"use except clauses\", 1) < 0)\n        return NULL;\n\n    tstate = PyThreadState_GET();\n    tmp_type = tstate->exc_type;\n    tmp_value = tstate->exc_value;\n    tmp_tb = tstate->exc_traceback;\n    tstate->exc_type = NULL;\n    tstate->exc_value = NULL;\n    tstate->exc_traceback = NULL;\n    Py_XDECREF(tmp_type);\n    Py_XDECREF(tmp_value);\n    Py_XDECREF(tmp_tb);\n    /* For b/w compatibility */\n    PySys_SetObject(\"exc_type\", Py_None);\n    PySys_SetObject(\"exc_value\", Py_None);\n    PySys_SetObject(\"exc_traceback\", Py_None);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(exc_clear_doc,\n\"exc_clear() -> None\\n\\\n\\n\\\nClear global information on the current exception.  Subsequent calls to\\n\\\nexc_info() will return (None,None,None) until another exception is raised\\n\\\nin the current thread or the execution stack returns to a frame where\\n\\\nanother exception is being handled.\"\n);\n\nstatic PyObject *\nsys_exit(PyObject *self, PyObject *args)\n{\n    PyObject *exit_code = 0;\n    if (!PyArg_UnpackTuple(args, \"exit\", 0, 1, &exit_code))\n        return NULL;\n    /* Raise SystemExit so callers may catch it or clean up. */\n    PyErr_SetObject(PyExc_SystemExit, exit_code);\n    return NULL;\n}\n\nPyDoc_STRVAR(exit_doc,\n\"exit([status])\\n\\\n\\n\\\nExit the interpreter by raising SystemExit(status).\\n\\\nIf the status is omitted or None, it defaults to zero (i.e., success).\\n\\\nIf the status is numeric, it will be used as the system exit status.\\n\\\nIf it is another kind of object, it will be printed and the system\\n\\\nexit status will be one (i.e., failure).\"\n);\n\n#ifdef Py_USING_UNICODE\n\nstatic PyObject *\nsys_getdefaultencoding(PyObject *self)\n{\n    return PyString_FromString(PyUnicode_GetDefaultEncoding());\n}\n\nPyDoc_STRVAR(getdefaultencoding_doc,\n\"getdefaultencoding() -> string\\n\\\n\\n\\\nReturn the current default string encoding used by the Unicode \\n\\\nimplementation.\"\n);\n\nstatic PyObject *\nsys_setdefaultencoding(PyObject *self, PyObject *args)\n{\n    char *encoding;\n    if (!PyArg_ParseTuple(args, \"s:setdefaultencoding\", &encoding))\n        return NULL;\n    if (PyUnicode_SetDefaultEncoding(encoding))\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setdefaultencoding_doc,\n\"setdefaultencoding(encoding)\\n\\\n\\n\\\nSet the current default string encoding used by the Unicode implementation.\"\n);\n\nstatic PyObject *\nsys_getfilesystemencoding(PyObject *self)\n{\n    if (Py_FileSystemDefaultEncoding)\n        return PyString_FromString(Py_FileSystemDefaultEncoding);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(getfilesystemencoding_doc,\n\"getfilesystemencoding() -> string\\n\\\n\\n\\\nReturn the encoding used to convert Unicode filenames in\\n\\\noperating system filenames.\"\n);\n\n#endif\n\n/*\n * Cached interned string objects used for calling the profile and\n * trace functions.  Initialized by trace_init().\n */\nstatic PyObject *whatstrings[7] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL};\n\nstatic int\ntrace_init(void)\n{\n    static char *whatnames[7] = {\"call\", \"exception\", \"line\", \"return\",\n                                    \"c_call\", \"c_exception\", \"c_return\"};\n    PyObject *name;\n    int i;\n    for (i = 0; i < 7; ++i) {\n        if (whatstrings[i] == NULL) {\n            name = PyString_InternFromString(whatnames[i]);\n            if (name == NULL)\n                return -1;\n            whatstrings[i] = name;\n        }\n    }\n    return 0;\n}\n\n\nstatic PyObject *\ncall_trampoline(PyThreadState *tstate, PyObject* callback,\n                PyFrameObject *frame, int what, PyObject *arg)\n{\n    PyObject *args = PyTuple_New(3);\n    PyObject *whatstr;\n    PyObject *result;\n\n    if (args == NULL)\n        return NULL;\n    Py_INCREF(frame);\n    whatstr = whatstrings[what];\n    Py_INCREF(whatstr);\n    if (arg == NULL)\n        arg = Py_None;\n    Py_INCREF(arg);\n    PyTuple_SET_ITEM(args, 0, (PyObject *)frame);\n    PyTuple_SET_ITEM(args, 1, whatstr);\n    PyTuple_SET_ITEM(args, 2, arg);\n\n    /* call the Python-level function */\n    PyFrame_FastToLocals(frame);\n    result = PyEval_CallObject(callback, args);\n    PyFrame_LocalsToFast(frame, 1);\n    if (result == NULL)\n        PyTraceBack_Here(frame);\n\n    /* cleanup */\n    Py_DECREF(args);\n    return result;\n}\n\nstatic int\nprofile_trampoline(PyObject *self, PyFrameObject *frame,\n                   int what, PyObject *arg)\n{\n    PyThreadState *tstate = frame->f_tstate;\n    PyObject *result;\n\n    if (arg == NULL)\n        arg = Py_None;\n    result = call_trampoline(tstate, self, frame, what, arg);\n    if (result == NULL) {\n        PyEval_SetProfile(NULL, NULL);\n        return -1;\n    }\n    Py_DECREF(result);\n    return 0;\n}\n\nstatic int\ntrace_trampoline(PyObject *self, PyFrameObject *frame,\n                 int what, PyObject *arg)\n{\n    PyThreadState *tstate = frame->f_tstate;\n    PyObject *callback;\n    PyObject *result;\n\n    if (what == PyTrace_CALL)\n        callback = self;\n    else\n        callback = frame->f_trace;\n    if (callback == NULL)\n        return 0;\n    result = call_trampoline(tstate, callback, frame, what, arg);\n    if (result == NULL) {\n        PyEval_SetTrace(NULL, NULL);\n        Py_XDECREF(frame->f_trace);\n        frame->f_trace = NULL;\n        return -1;\n    }\n    if (result != Py_None) {\n        PyObject *temp = frame->f_trace;\n        frame->f_trace = NULL;\n        Py_XDECREF(temp);\n        frame->f_trace = result;\n    }\n    else {\n        Py_DECREF(result);\n    }\n    return 0;\n}\n\nstatic PyObject *\nsys_settrace(PyObject *self, PyObject *args)\n{\n    if (trace_init() == -1)\n        return NULL;\n    if (args == Py_None)\n        PyEval_SetTrace(NULL, NULL);\n    else\n        PyEval_SetTrace(trace_trampoline, args);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(settrace_doc,\n\"settrace(function)\\n\\\n\\n\\\nSet the global debug tracing function.  It will be called on each\\n\\\nfunction call.  See the debugger chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_gettrace(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *temp = tstate->c_traceobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    Py_INCREF(temp);\n    return temp;\n}\n\nPyDoc_STRVAR(gettrace_doc,\n\"gettrace()\\n\\\n\\n\\\nReturn the global debug tracing function set with sys.settrace.\\n\\\nSee the debugger chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_setprofile(PyObject *self, PyObject *args)\n{\n    if (trace_init() == -1)\n        return NULL;\n    if (args == Py_None)\n        PyEval_SetProfile(NULL, NULL);\n    else\n        PyEval_SetProfile(profile_trampoline, args);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setprofile_doc,\n\"setprofile(function)\\n\\\n\\n\\\nSet the profiling function.  It will be called on each function call\\n\\\nand return.  See the profiler chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_getprofile(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    PyObject *temp = tstate->c_profileobj;\n\n    if (temp == NULL)\n        temp = Py_None;\n    Py_INCREF(temp);\n    return temp;\n}\n\nPyDoc_STRVAR(getprofile_doc,\n\"getprofile()\\n\\\n\\n\\\nReturn the profiling function set with sys.setprofile.\\n\\\nSee the profiler chapter in the library manual.\"\n);\n\nstatic PyObject *\nsys_setcheckinterval(PyObject *self, PyObject *args)\n{\n    if (!PyArg_ParseTuple(args, \"i:setcheckinterval\", &_Py_CheckInterval))\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setcheckinterval_doc,\n\"setcheckinterval(n)\\n\\\n\\n\\\nTell the Python interpreter to check for asynchronous events every\\n\\\nn instructions.  This also affects how often thread switches occur.\"\n);\n\nstatic PyObject *\nsys_getcheckinterval(PyObject *self, PyObject *args)\n{\n    return PyInt_FromLong(_Py_CheckInterval);\n}\n\nPyDoc_STRVAR(getcheckinterval_doc,\n\"getcheckinterval() -> current check interval; see setcheckinterval().\"\n);\n\n#ifdef WITH_TSC\nstatic PyObject *\nsys_settscdump(PyObject *self, PyObject *args)\n{\n    int bool;\n    PyThreadState *tstate = PyThreadState_Get();\n\n    if (!PyArg_ParseTuple(args, \"i:settscdump\", &bool))\n        return NULL;\n    if (bool)\n        tstate->interp->tscdump = 1;\n    else\n        tstate->interp->tscdump = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n\n}\n\nPyDoc_STRVAR(settscdump_doc,\n\"settscdump(bool)\\n\\\n\\n\\\nIf true, tell the Python interpreter to dump VM measurements to\\n\\\nstderr.  If false, turn off dump.  The measurements are based on the\\n\\\nprocessor's time-stamp counter.\"\n);\n#endif /* TSC */\n\nstatic PyObject *\nsys_setrecursionlimit(PyObject *self, PyObject *args)\n{\n    int new_limit;\n    if (!PyArg_ParseTuple(args, \"i:setrecursionlimit\", &new_limit))\n        return NULL;\n    if (new_limit <= 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"recursion limit must be positive\");\n        return NULL;\n    }\n    Py_SetRecursionLimit(new_limit);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setrecursionlimit_doc,\n\"setrecursionlimit(n)\\n\\\n\\n\\\nSet the maximum depth of the Python interpreter stack to n.  This\\n\\\nlimit prevents infinite recursion from causing an overflow of the C\\n\\\nstack and crashing Python.  The highest possible limit is platform-\\n\\\ndependent.\"\n);\n\nstatic PyObject *\nsys_getrecursionlimit(PyObject *self)\n{\n    return PyInt_FromLong(Py_GetRecursionLimit());\n}\n\nPyDoc_STRVAR(getrecursionlimit_doc,\n\"getrecursionlimit()\\n\\\n\\n\\\nReturn the current value of the recursion limit, the maximum depth\\n\\\nof the Python interpreter stack.  This limit prevents infinite\\n\\\nrecursion from causing an overflow of the C stack and crashing Python.\"\n);\n\n#ifdef MS_WINDOWS\nPyDoc_STRVAR(getwindowsversion_doc,\n\"getwindowsversion()\\n\\\n\\n\\\nReturn information about the running version of Windows as a named tuple.\\n\\\nThe members are named: major, minor, build, platform, service_pack,\\n\\\nservice_pack_major, service_pack_minor, suite_mask, and product_type. For\\n\\\nbackward compatibility, only the first 5 items are available by indexing.\\n\\\nAll elements are numbers, except service_pack which is a string. Platform\\n\\\nmay be 0 for win32s, 1 for Windows 9x/ME, 2 for Windows NT/2000/XP/Vista/7,\\n\\\n3 for Windows CE. Product_type may be 1 for a workstation, 2 for a domain\\n\\\ncontroller, 3 for a server.\"\n);\n\nstatic PyTypeObject WindowsVersionType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field windows_version_fields[] = {\n    {\"major\", \"Major version number\"},\n    {\"minor\", \"Minor version number\"},\n    {\"build\", \"Build number\"},\n    {\"platform\", \"Operating system platform\"},\n    {\"service_pack\", \"Latest Service Pack installed on the system\"},\n    {\"service_pack_major\", \"Service Pack major version number\"},\n    {\"service_pack_minor\", \"Service Pack minor version number\"},\n    {\"suite_mask\", \"Bit mask identifying available product suites\"},\n    {\"product_type\", \"System product type\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc windows_version_desc = {\n    \"sys.getwindowsversion\",  /* name */\n    getwindowsversion_doc,    /* doc */\n    windows_version_fields,   /* fields */\n    5                         /* For backward compatibility,\n                                 only the first 5 items are accessible\n                                 via indexing, the rest are name only */\n};\n\nstatic PyObject *\nsys_getwindowsversion(PyObject *self)\n{\n    PyObject *version;\n    int pos = 0;\n    OSVERSIONINFOEX ver;\n    ver.dwOSVersionInfoSize = sizeof(ver);\n    if (!GetVersionEx((OSVERSIONINFO*) &ver))\n        return PyErr_SetFromWindowsErr(0);\n\n    version = PyStructSequence_New(&WindowsVersionType);\n    if (version == NULL)\n        return NULL;\n\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwMajorVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwMinorVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwBuildNumber));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.dwPlatformId));\n    PyStructSequence_SET_ITEM(version, pos++, PyString_FromString(ver.szCSDVersion));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wServicePackMajor));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wServicePackMinor));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wSuiteMask));\n    PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wProductType));\n\n    return version;\n}\n\n#endif /* MS_WINDOWS */\n\n#ifdef HAVE_DLOPEN\nstatic PyObject *\nsys_setdlopenflags(PyObject *self, PyObject *args)\n{\n    int new_val;\n    PyThreadState *tstate = PyThreadState_GET();\n    if (!PyArg_ParseTuple(args, \"i:setdlopenflags\", &new_val))\n        return NULL;\n    if (!tstate)\n        return NULL;\n    tstate->interp->dlopenflags = new_val;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nPyDoc_STRVAR(setdlopenflags_doc,\n\"setdlopenflags(n) -> None\\n\\\n\\n\\\nSet the flags used by the interpreter for dlopen calls, such as when the\\n\\\ninterpreter loads extension modules.  Among other things, this will enable\\n\\\na lazy resolving of symbols when importing a module, if called as\\n\\\nsys.setdlopenflags(0).  To share symbols across extension modules, call as\\n\\\nsys.setdlopenflags(ctypes.RTLD_GLOBAL).  Symbolic names for the flag modules\\n\\\ncan be either found in the ctypes module, or in the DLFCN module. If DLFCN\\n\\\nis not available, it can be generated from /usr/include/dlfcn.h using the\\n\\\nh2py script.\");\n\nstatic PyObject *\nsys_getdlopenflags(PyObject *self, PyObject *args)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    if (!tstate)\n        return NULL;\n    return PyInt_FromLong(tstate->interp->dlopenflags);\n}\n\nPyDoc_STRVAR(getdlopenflags_doc,\n\"getdlopenflags() -> int\\n\\\n\\n\\\nReturn the current value of the flags that are used for dlopen calls.\\n\\\nThe flag constants are defined in the ctypes and DLFCN modules.\");\n\n#endif  /* HAVE_DLOPEN */\n\n#ifdef USE_MALLOPT\n/* Link with -lmalloc (or -lmpc) on an SGI */\n#include <malloc.h>\n\nstatic PyObject *\nsys_mdebug(PyObject *self, PyObject *args)\n{\n    int flag;\n    if (!PyArg_ParseTuple(args, \"i:mdebug\", &flag))\n        return NULL;\n    mallopt(M_DEBUG, flag);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n#endif /* USE_MALLOPT */\n\nstatic PyObject *\nsys_getsizeof(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *res = NULL;\n    static PyObject *str__sizeof__ = NULL, *gc_head_size = NULL;\n    static char *kwlist[] = {\"object\", \"default\", 0};\n    PyObject *o, *dflt = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|O:getsizeof\",\n                                     kwlist, &o, &dflt))\n        return NULL;\n\n    /* Initialize static variable for GC head size */\n    if (gc_head_size == NULL) {\n        gc_head_size = PyInt_FromSsize_t(sizeof(PyGC_Head));\n        if (gc_head_size == NULL)\n            return NULL;\n    }\n\n    /* Make sure the type is initialized. float gets initialized late */\n    if (PyType_Ready(Py_TYPE(o)) < 0)\n        return NULL;\n\n    /* Instance of old-style class */\n    if (PyInstance_Check(o))\n        res = PyInt_FromSsize_t(PyInstance_Type.tp_basicsize);\n    /* all other objects */\n    else {\n        PyObject *method = _PyObject_LookupSpecial(o, \"__sizeof__\",\n                                                   &str__sizeof__);\n        if (method == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_TypeError,\n                             \"Type %.100s doesn't define __sizeof__\",\n                             Py_TYPE(o)->tp_name);\n        }\n        else {\n            res = PyObject_CallFunctionObjArgs(method, NULL);\n            Py_DECREF(method);\n        }\n    }\n\n    /* Has a default value been given? */\n    if ((res == NULL) && (dflt != NULL) &&\n        PyErr_ExceptionMatches(PyExc_TypeError))\n    {\n        PyErr_Clear();\n        Py_INCREF(dflt);\n        return dflt;\n    }\n    else if (res == NULL)\n        return res;\n\n    /* add gc_head size */\n    if (PyObject_IS_GC(o)) {\n        PyObject *tmp = res;\n        res = PyNumber_Add(tmp, gc_head_size);\n        Py_DECREF(tmp);\n    }\n    return res;\n}\n\nPyDoc_STRVAR(getsizeof_doc,\n\"getsizeof(object, default) -> int\\n\\\n\\n\\\nReturn the size of object in bytes.\");\n\nstatic PyObject *\nsys_getrefcount(PyObject *self, PyObject *arg)\n{\n    return PyInt_FromSsize_t(arg->ob_refcnt);\n}\n\n#ifdef Py_REF_DEBUG\nstatic PyObject *\nsys_gettotalrefcount(PyObject *self)\n{\n    return PyInt_FromSsize_t(_Py_GetRefTotal());\n}\n#endif /* Py_REF_DEBUG */\n\nPyDoc_STRVAR(getrefcount_doc,\n\"getrefcount(object) -> integer\\n\\\n\\n\\\nReturn the reference count of object.  The count returned is generally\\n\\\none higher than you might expect, because it includes the (temporary)\\n\\\nreference as an argument to getrefcount().\"\n);\n\n#ifdef COUNT_ALLOCS\nstatic PyObject *\nsys_getcounts(PyObject *self)\n{\n    extern PyObject *get_counts(void);\n\n    return get_counts();\n}\n#endif\n\nPyDoc_STRVAR(getframe_doc,\n\"_getframe([depth]) -> frameobject\\n\\\n\\n\\\nReturn a frame object from the call stack.  If optional integer depth is\\n\\\ngiven, return the frame object that many calls below the top of the stack.\\n\\\nIf that is deeper than the call stack, ValueError is raised.  The default\\n\\\nfor depth is zero, returning the frame at the top of the call stack.\\n\\\n\\n\\\nThis function should be used for internal and specialized\\n\\\npurposes only.\"\n);\n\nstatic PyObject *\nsys_getframe(PyObject *self, PyObject *args)\n{\n    PyFrameObject *f = PyThreadState_GET()->frame;\n    int depth = -1;\n\n    if (!PyArg_ParseTuple(args, \"|i:_getframe\", &depth))\n        return NULL;\n\n    while (depth > 0 && f != NULL) {\n        f = f->f_back;\n        --depth;\n    }\n    if (f == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"call stack is not deep enough\");\n        return NULL;\n    }\n    Py_INCREF(f);\n    return (PyObject*)f;\n}\n\nPyDoc_STRVAR(current_frames_doc,\n\"_current_frames() -> dictionary\\n\\\n\\n\\\nReturn a dictionary mapping each current thread T's thread id to T's\\n\\\ncurrent stack frame.\\n\\\n\\n\\\nThis function should be used for specialized purposes only.\"\n);\n\nstatic PyObject *\nsys_current_frames(PyObject *self, PyObject *noargs)\n{\n    return _PyThread_CurrentFrames();\n}\n\nPyDoc_STRVAR(call_tracing_doc,\n\"call_tracing(func, args) -> object\\n\\\n\\n\\\nCall func(*args), while tracing is enabled.  The tracing state is\\n\\\nsaved, and restored afterwards.  This is intended to be called from\\n\\\na debugger from a checkpoint, to recursively debug some other code.\"\n);\n\nstatic PyObject *\nsys_call_tracing(PyObject *self, PyObject *args)\n{\n    PyObject *func, *funcargs;\n    if (!PyArg_ParseTuple(args, \"OO!:call_tracing\", &func, &PyTuple_Type, &funcargs))\n        return NULL;\n    return _PyEval_CallTracing(func, funcargs);\n}\n\nPyDoc_STRVAR(callstats_doc,\n\"callstats() -> tuple of integers\\n\\\n\\n\\\nReturn a tuple of function call statistics, if CALL_PROFILE was defined\\n\\\nwhen Python was built.  Otherwise, return None.\\n\\\n\\n\\\nWhen enabled, this function returns detailed, implementation-specific\\n\\\ndetails about the number of function calls executed. The return value is\\n\\\na 11-tuple where the entries in the tuple are counts of:\\n\\\n0. all function calls\\n\\\n1. calls to PyFunction_Type objects\\n\\\n2. PyFunction calls that do not create an argument tuple\\n\\\n3. PyFunction calls that do not create an argument tuple\\n\\\n   and bypass PyEval_EvalCodeEx()\\n\\\n4. PyMethod calls\\n\\\n5. PyMethod calls on bound methods\\n\\\n6. PyType calls\\n\\\n7. PyCFunction calls\\n\\\n8. generator calls\\n\\\n9. All other calls\\n\\\n10. Number of stack pops performed by call_function()\"\n);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef Py_TRACE_REFS\n/* Defined in objects.c because it uses static globals if that file */\nextern PyObject *_Py_GetObjects(PyObject *, PyObject *);\n#endif\n\n#ifdef DYNAMIC_EXECUTION_PROFILE\n/* Defined in ceval.c because it uses static globals if that file */\nextern PyObject *_Py_GetDXProfile(PyObject *,  PyObject *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic PyObject *\nsys_clear_type_cache(PyObject* self, PyObject* args)\n{\n    PyType_ClearCache();\n    Py_RETURN_NONE;\n}\n\nPyDoc_STRVAR(sys_clear_type_cache__doc__,\n\"_clear_type_cache() -> None\\n\\\nClear the internal type lookup cache.\");\n\n\nstatic PyMethodDef sys_methods[] = {\n    /* Might as well keep this in alphabetic order */\n    {\"callstats\", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,\n     callstats_doc},\n    {\"_clear_type_cache\",       sys_clear_type_cache,     METH_NOARGS,\n     sys_clear_type_cache__doc__},\n    {\"_current_frames\", sys_current_frames, METH_NOARGS,\n     current_frames_doc},\n    {\"displayhook\",     sys_displayhook, METH_O, displayhook_doc},\n    {\"exc_info\",        sys_exc_info, METH_NOARGS, exc_info_doc},\n    {\"exc_clear\",       sys_exc_clear, METH_NOARGS, exc_clear_doc},\n    {\"excepthook\",      sys_excepthook, METH_VARARGS, excepthook_doc},\n    {\"exit\",            sys_exit, METH_VARARGS, exit_doc},\n#ifdef Py_USING_UNICODE\n    {\"getdefaultencoding\", (PyCFunction)sys_getdefaultencoding,\n     METH_NOARGS, getdefaultencoding_doc},\n#endif\n#ifdef HAVE_DLOPEN\n    {\"getdlopenflags\", (PyCFunction)sys_getdlopenflags, METH_NOARGS,\n     getdlopenflags_doc},\n#endif\n#ifdef COUNT_ALLOCS\n    {\"getcounts\",       (PyCFunction)sys_getcounts, METH_NOARGS},\n#endif\n#ifdef DYNAMIC_EXECUTION_PROFILE\n    {\"getdxp\",          _Py_GetDXProfile, METH_VARARGS},\n#endif\n#ifdef Py_USING_UNICODE\n    {\"getfilesystemencoding\", (PyCFunction)sys_getfilesystemencoding,\n     METH_NOARGS, getfilesystemencoding_doc},\n#endif\n#ifdef Py_TRACE_REFS\n    {\"getobjects\",      _Py_GetObjects, METH_VARARGS},\n#endif\n#ifdef Py_REF_DEBUG\n    {\"gettotalrefcount\", (PyCFunction)sys_gettotalrefcount, METH_NOARGS},\n#endif\n    {\"getrefcount\",     (PyCFunction)sys_getrefcount, METH_O, getrefcount_doc},\n    {\"getrecursionlimit\", (PyCFunction)sys_getrecursionlimit, METH_NOARGS,\n     getrecursionlimit_doc},\n    {\"getsizeof\",   (PyCFunction)sys_getsizeof,\n     METH_VARARGS | METH_KEYWORDS, getsizeof_doc},\n    {\"_getframe\", sys_getframe, METH_VARARGS, getframe_doc},\n#ifdef MS_WINDOWS\n    {\"getwindowsversion\", (PyCFunction)sys_getwindowsversion, METH_NOARGS,\n     getwindowsversion_doc},\n#endif /* MS_WINDOWS */\n#ifdef USE_MALLOPT\n    {\"mdebug\",          sys_mdebug, METH_VARARGS},\n#endif\n#ifdef Py_USING_UNICODE\n    {\"setdefaultencoding\", sys_setdefaultencoding, METH_VARARGS,\n     setdefaultencoding_doc},\n#endif\n    {\"setcheckinterval\",        sys_setcheckinterval, METH_VARARGS,\n     setcheckinterval_doc},\n    {\"getcheckinterval\",        sys_getcheckinterval, METH_NOARGS,\n     getcheckinterval_doc},\n#ifdef HAVE_DLOPEN\n    {\"setdlopenflags\", sys_setdlopenflags, METH_VARARGS,\n     setdlopenflags_doc},\n#endif\n    {\"setprofile\",      sys_setprofile, METH_O, setprofile_doc},\n    {\"getprofile\",      sys_getprofile, METH_NOARGS, getprofile_doc},\n    {\"setrecursionlimit\", sys_setrecursionlimit, METH_VARARGS,\n     setrecursionlimit_doc},\n#ifdef WITH_TSC\n    {\"settscdump\", sys_settscdump, METH_VARARGS, settscdump_doc},\n#endif\n    {\"settrace\",        sys_settrace, METH_O, settrace_doc},\n    {\"gettrace\",        sys_gettrace, METH_NOARGS, gettrace_doc},\n    {\"call_tracing\", sys_call_tracing, METH_VARARGS, call_tracing_doc},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyObject *\nlist_builtin_module_names(void)\n{\n    PyObject *list = PyList_New(0);\n    int i;\n    if (list == NULL)\n        return NULL;\n    for (i = 0; PyImport_Inittab[i].name != NULL; i++) {\n        PyObject *name = PyString_FromString(\n            PyImport_Inittab[i].name);\n        if (name == NULL)\n            break;\n        PyList_Append(list, name);\n        Py_DECREF(name);\n    }\n    if (PyList_Sort(list) != 0) {\n        Py_DECREF(list);\n        list = NULL;\n    }\n    if (list) {\n        PyObject *v = PyList_AsTuple(list);\n        Py_DECREF(list);\n        list = v;\n    }\n    return list;\n}\n\nstatic PyObject *warnoptions = NULL;\n\nvoid\nPySys_ResetWarnOptions(void)\n{\n    if (warnoptions == NULL || !PyList_Check(warnoptions))\n        return;\n    PyList_SetSlice(warnoptions, 0, PyList_GET_SIZE(warnoptions), NULL);\n}\n\nvoid\nPySys_AddWarnOption(char *s)\n{\n    PyObject *str;\n\n    if (warnoptions == NULL || !PyList_Check(warnoptions)) {\n        Py_XDECREF(warnoptions);\n        warnoptions = PyList_New(0);\n        if (warnoptions == NULL)\n            return;\n    }\n    str = PyString_FromString(s);\n    if (str != NULL) {\n        PyList_Append(warnoptions, str);\n        Py_DECREF(str);\n    }\n}\n\nint\nPySys_HasWarnOptions(void)\n{\n    return (warnoptions != NULL && (PyList_Size(warnoptions) > 0)) ? 1 : 0;\n}\n\n/* XXX This doc string is too long to be a single string literal in VC++ 5.0.\n   Two literals concatenated works just fine.  If you have a K&R compiler\n   or other abomination that however *does* understand longer strings,\n   get rid of the !!! comment in the middle and the quotes that surround it. */\nPyDoc_VAR(sys_doc) =\nPyDoc_STR(\n\"This module provides access to some objects used or maintained by the\\n\\\ninterpreter and to functions that interact strongly with the interpreter.\\n\\\n\\n\\\nDynamic objects:\\n\\\n\\n\\\nargv -- command line arguments; argv[0] is the script pathname if known\\n\\\npath -- module search path; path[0] is the script directory, else ''\\n\\\nmodules -- dictionary of loaded modules\\n\\\n\\n\\\ndisplayhook -- called to show results in an interactive session\\n\\\nexcepthook -- called to handle any uncaught exception other than SystemExit\\n\\\n  To customize printing in an interactive session or to install a custom\\n\\\n  top-level exception handler, assign other functions to replace these.\\n\\\n\\n\\\nexitfunc -- if sys.exitfunc exists, this routine is called when Python exits\\n\\\n  Assigning to sys.exitfunc is deprecated; use the atexit module instead.\\n\\\n\\n\\\nstdin -- standard input file object; used by raw_input() and input()\\n\\\nstdout -- standard output file object; used by the print statement\\n\\\nstderr -- standard error object; used for error messages\\n\\\n  By assigning other file objects (or objects that behave like files)\\n\\\n  to these, it is possible to redirect all of the interpreter's I/O.\\n\\\n\\n\\\nlast_type -- type of last uncaught exception\\n\\\nlast_value -- value of last uncaught exception\\n\\\nlast_traceback -- traceback of last uncaught exception\\n\\\n  These three are only available in an interactive session after a\\n\\\n  traceback has been printed.\\n\\\n\\n\\\nexc_type -- type of exception currently being handled\\n\\\nexc_value -- value of exception currently being handled\\n\\\nexc_traceback -- traceback of exception currently being handled\\n\\\n  The function exc_info() should be used instead of these three,\\n\\\n  because it is thread-safe.\\n\\\n\"\n)\n/* concatenating string here */\nPyDoc_STR(\n\"\\n\\\nStatic objects:\\n\\\n\\n\\\nfloat_info -- a dict with information about the float inplementation.\\n\\\nlong_info -- a struct sequence with information about the long implementation.\\n\\\nmaxint -- the largest supported integer (the smallest is -maxint-1)\\n\\\nmaxsize -- the largest supported length of containers.\\n\\\nmaxunicode -- the largest supported character\\n\\\nbuiltin_module_names -- tuple of module names built into this interpreter\\n\\\nversion -- the version of this interpreter as a string\\n\\\nversion_info -- version information as a named tuple\\n\\\nhexversion -- version information encoded as a single integer\\n\\\ncopyright -- copyright notice pertaining to this interpreter\\n\\\nplatform -- platform identifier\\n\\\nexecutable -- pathname of this Python interpreter\\n\\\nprefix -- prefix used to find the Python library\\n\\\nexec_prefix -- prefix used to find the machine-specific Python library\\n\\\nfloat_repr_style -- string indicating the style of repr() output for floats\\n\\\n\"\n)\n#ifdef MS_WINDOWS\n/* concatenating string here */\nPyDoc_STR(\n\"dllhandle -- [Windows only] integer handle of the Python DLL\\n\\\nwinver -- [Windows only] version number of the Python DLL\\n\\\n\"\n)\n#endif /* MS_WINDOWS */\nPyDoc_STR(\n\"__stdin__ -- the original stdin; don't touch!\\n\\\n__stdout__ -- the original stdout; don't touch!\\n\\\n__stderr__ -- the original stderr; don't touch!\\n\\\n__displayhook__ -- the original displayhook; don't touch!\\n\\\n__excepthook__ -- the original excepthook; don't touch!\\n\\\n\\n\\\nFunctions:\\n\\\n\\n\\\ndisplayhook() -- print an object to the screen, and save it in __builtin__._\\n\\\nexcepthook() -- print an exception and its traceback to sys.stderr\\n\\\nexc_info() -- return thread-safe information about the current exception\\n\\\nexc_clear() -- clear the exception state for the current thread\\n\\\nexit() -- exit the interpreter by raising SystemExit\\n\\\ngetdlopenflags() -- returns flags to be used for dlopen() calls\\n\\\ngetprofile() -- get the global profiling function\\n\\\ngetrefcount() -- return the reference count for an object (plus one :-)\\n\\\ngetrecursionlimit() -- return the max recursion depth for the interpreter\\n\\\ngetsizeof() -- return the size of an object in bytes\\n\\\ngettrace() -- get the global debug tracing function\\n\\\nsetcheckinterval() -- control how often the interpreter checks for events\\n\\\nsetdlopenflags() -- set the flags to be used for dlopen() calls\\n\\\nsetprofile() -- set the global profiling function\\n\\\nsetrecursionlimit() -- set the max recursion depth for the interpreter\\n\\\nsettrace() -- set the global debug tracing function\\n\\\n\"\n)\n/* end of sys_doc */ ;\n\nstatic int\n_check_and_flush (FILE *stream)\n{\n  int prev_fail = ferror (stream);\n  return fflush (stream) || prev_fail ? EOF : 0;\n}\n\n/* Subversion branch and revision management */\nstatic int svn_initialized;\nstatic char patchlevel_revision[50]; /* Just the number */\nstatic char branch[50];\nstatic char shortbranch[50];\nstatic const char *svn_revision;\n\nstatic void\nsvnversion_init(void)\n{\n    if (svn_initialized)\n        return;\n    svn_initialized = 1;\n    *patchlevel_revision = '\\0';\n    strcpy(branch, \"\");\n    strcpy(shortbranch, \"unknown\");\n    svn_revision = \"\";\n    return;\n}\n\n/* Return svnversion output if available.\n   Else return Revision of patchlevel.h if on branch.\n   Else return empty string */\nconst char*\nPy_SubversionRevision()\n{\n    svnversion_init();\n    return svn_revision;\n}\n\nconst char*\nPy_SubversionShortBranch()\n{\n    svnversion_init();\n    return shortbranch;\n}\n\n\nPyDoc_STRVAR(flags__doc__,\n\"sys.flags\\n\\\n\\n\\\nFlags provided through command line arguments or environment vars.\");\n\nstatic PyTypeObject FlagsType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field flags_fields[] = {\n    {\"debug\",                   \"-d\"},\n    {\"py3k_warning\",            \"-3\"},\n    {\"division_warning\",        \"-Q\"},\n    {\"division_new\",            \"-Qnew\"},\n    {\"inspect\",                 \"-i\"},\n    {\"interactive\",             \"-i\"},\n    {\"optimize\",                \"-O or -OO\"},\n    {\"dont_write_bytecode\",     \"-B\"},\n    {\"no_user_site\",            \"-s\"},\n    {\"no_site\",                 \"-S\"},\n    {\"ignore_environment\",      \"-E\"},\n    {\"tabcheck\",                \"-t or -tt\"},\n    {\"verbose\",                 \"-v\"},\n#ifdef RISCOS\n    {\"riscos_wimp\",             \"???\"},\n#endif\n    /* {\"unbuffered\",                   \"-u\"}, */\n    {\"unicode\",                 \"-U\"},\n    /* {\"skip_first\",                   \"-x\"}, */\n    {\"bytes_warning\", \"-b\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc flags_desc = {\n    \"sys.flags\",        /* name */\n    flags__doc__,       /* doc */\n    flags_fields,       /* fields */\n#ifdef RISCOS\n    16\n#else\n    15\n#endif\n};\n\nstatic PyObject*\nmake_flags(void)\n{\n    int pos = 0;\n    PyObject *seq;\n\n    seq = PyStructSequence_New(&FlagsType);\n    if (seq == NULL)\n        return NULL;\n\n#define SetFlag(flag) \\\n    PyStructSequence_SET_ITEM(seq, pos++, PyInt_FromLong(flag))\n\n    SetFlag(Py_DebugFlag);\n    SetFlag(Py_Py3kWarningFlag);\n    SetFlag(Py_DivisionWarningFlag);\n    SetFlag(_Py_QnewFlag);\n    SetFlag(Py_InspectFlag);\n    SetFlag(Py_InteractiveFlag);\n    SetFlag(Py_OptimizeFlag);\n    SetFlag(Py_DontWriteBytecodeFlag);\n    SetFlag(Py_NoUserSiteDirectory);\n    SetFlag(Py_NoSiteFlag);\n    SetFlag(Py_IgnoreEnvironmentFlag);\n    SetFlag(Py_TabcheckFlag);\n    SetFlag(Py_VerboseFlag);\n#ifdef RISCOS\n    SetFlag(Py_RISCOSWimpFlag);\n#endif\n    /* SetFlag(saw_unbuffered_flag); */\n    SetFlag(Py_UnicodeFlag);\n    /* SetFlag(skipfirstline); */\n    SetFlag(Py_BytesWarningFlag);\n#undef SetFlag\n\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n    return seq;\n}\n\nPyDoc_STRVAR(version_info__doc__,\n\"sys.version_info\\n\\\n\\n\\\nVersion information as a named tuple.\");\n\nstatic PyTypeObject VersionInfoType = {0, 0, 0, 0, 0, 0};\n\nstatic PyStructSequence_Field version_info_fields[] = {\n    {\"major\", \"Major release number\"},\n    {\"minor\", \"Minor release number\"},\n    {\"micro\", \"Patch release number\"},\n    {\"releaselevel\", \"'alpha', 'beta', 'candidate', or 'release'\"},\n    {\"serial\", \"Serial release number\"},\n    {0}\n};\n\nstatic PyStructSequence_Desc version_info_desc = {\n    \"sys.version_info\",     /* name */\n    version_info__doc__,    /* doc */\n    version_info_fields,    /* fields */\n    5\n};\n\nstatic PyObject *\nmake_version_info(void)\n{\n    PyObject *version_info;\n    char *s;\n    int pos = 0;\n\n    version_info = PyStructSequence_New(&VersionInfoType);\n    if (version_info == NULL) {\n        return NULL;\n    }\n\n    /*\n     * These release level checks are mutually exclusive and cover\n     * the field, so don't get too fancy with the pre-processor!\n     */\n#if PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_ALPHA\n    s = \"alpha\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_BETA\n    s = \"beta\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_GAMMA\n    s = \"candidate\";\n#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_FINAL\n    s = \"final\";\n#endif\n\n#define SetIntItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyInt_FromLong(flag))\n#define SetStrItem(flag) \\\n    PyStructSequence_SET_ITEM(version_info, pos++, PyString_FromString(flag))\n\n    SetIntItem(PY_MAJOR_VERSION);\n    SetIntItem(PY_MINOR_VERSION);\n    SetIntItem(PY_MICRO_VERSION);\n    SetStrItem(s);\n    SetIntItem(PY_RELEASE_SERIAL);\n#undef SetIntItem\n#undef SetStrItem\n\n    if (PyErr_Occurred()) {\n        Py_CLEAR(version_info);\n        return NULL;\n    }\n    return version_info;\n}\n\nPyObject *\n_PySys_Init(void)\n{\n    PyObject *m, *v, *sysdict;\n    PyObject *sysin, *sysout, *syserr;\n    char *s;\n\n    m = Py_InitModule3(\"sys\", sys_methods, sys_doc);\n    if (m == NULL)\n        return NULL;\n    sysdict = PyModule_GetDict(m);\n#define SET_SYS_FROM_STRING(key, value)                 \\\n    v = value;                                          \\\n    if (v != NULL)                                      \\\n        PyDict_SetItemString(sysdict, key, v);          \\\n    Py_XDECREF(v)\n\n    /* Check that stdin is not a directory\n    Using shell redirection, you can redirect stdin to a directory,\n    crashing the Python interpreter. Catch this common mistake here\n    and output a useful error message. Note that under MS Windows,\n    the shell already prevents that. */\n#if !defined(MS_WINDOWS)\n    {\n        struct stat sb;\n        if (fstat(fileno(stdin), &sb) == 0 &&\n            S_ISDIR(sb.st_mode)) {\n            /* There's nothing more we can do. */\n            /* Py_FatalError() will core dump, so just exit. */\n            PySys_WriteStderr(\"Python error: <stdin> is a directory, cannot continue\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif\n\n    /* Closing the standard FILE* if sys.std* goes aways causes problems\n     * for embedded Python usages. Closing them when somebody explicitly\n     * invokes .close() might be possible, but the FAQ promises they get\n     * never closed. However, we still need to get write errors when\n     * writing fails (e.g. because stdout is redirected), so we flush the\n     * streams and check for errors before the file objects are deleted.\n     * On OS X, fflush()ing stdin causes an error, so we exempt stdin\n     * from that procedure.\n     */\n    sysin = PyFile_FromFile(stdin, \"<stdin>\", \"r\", NULL);\n    sysout = PyFile_FromFile(stdout, \"<stdout>\", \"w\", _check_and_flush);\n    syserr = PyFile_FromFile(stderr, \"<stderr>\", \"w\", _check_and_flush);\n    if (PyErr_Occurred())\n        return NULL;\n\n    PyDict_SetItemString(sysdict, \"stdin\", sysin);\n    PyDict_SetItemString(sysdict, \"stdout\", sysout);\n    PyDict_SetItemString(sysdict, \"stderr\", syserr);\n    /* Make backup copies for cleanup */\n    PyDict_SetItemString(sysdict, \"__stdin__\", sysin);\n    PyDict_SetItemString(sysdict, \"__stdout__\", sysout);\n    PyDict_SetItemString(sysdict, \"__stderr__\", syserr);\n    PyDict_SetItemString(sysdict, \"__displayhook__\",\n                         PyDict_GetItemString(sysdict, \"displayhook\"));\n    PyDict_SetItemString(sysdict, \"__excepthook__\",\n                         PyDict_GetItemString(sysdict, \"excepthook\"));\n    Py_XDECREF(sysin);\n    Py_XDECREF(sysout);\n    Py_XDECREF(syserr);\n\n    SET_SYS_FROM_STRING(\"version\",\n                         PyString_FromString(Py_GetVersion()));\n    SET_SYS_FROM_STRING(\"hexversion\",\n                         PyInt_FromLong(PY_VERSION_HEX));\n    svnversion_init();\n    SET_SYS_FROM_STRING(\"subversion\",\n                         Py_BuildValue(\"(ssz)\", \"CPython\", branch,\n                                      svn_revision));\n    SET_SYS_FROM_STRING(\"_mercurial\",\n                        Py_BuildValue(\"(szz)\", \"CPython\", _Py_hgidentifier(),\n                                      _Py_hgversion()));\n    SET_SYS_FROM_STRING(\"dont_write_bytecode\",\n                         PyBool_FromLong(Py_DontWriteBytecodeFlag));\n    SET_SYS_FROM_STRING(\"api_version\",\n                        PyInt_FromLong(PYTHON_API_VERSION));\n    SET_SYS_FROM_STRING(\"copyright\",\n                        PyString_FromString(Py_GetCopyright()));\n    SET_SYS_FROM_STRING(\"platform\",\n                        PyString_FromString(Py_GetPlatform()));\n    SET_SYS_FROM_STRING(\"executable\",\n                        PyString_FromString(Py_GetProgramFullPath()));\n    SET_SYS_FROM_STRING(\"prefix\",\n                        PyString_FromString(Py_GetPrefix()));\n    SET_SYS_FROM_STRING(\"exec_prefix\",\n                        PyString_FromString(Py_GetExecPrefix()));\n    SET_SYS_FROM_STRING(\"maxsize\",\n                        PyInt_FromSsize_t(PY_SSIZE_T_MAX));\n    SET_SYS_FROM_STRING(\"maxint\",\n                        PyInt_FromLong(PyInt_GetMax()));\n    SET_SYS_FROM_STRING(\"py3kwarning\",\n                        PyBool_FromLong(Py_Py3kWarningFlag));\n    SET_SYS_FROM_STRING(\"float_info\",\n                        PyFloat_GetInfo());\n    SET_SYS_FROM_STRING(\"long_info\",\n                        PyLong_GetInfo());\n#ifdef Py_USING_UNICODE\n    SET_SYS_FROM_STRING(\"maxunicode\",\n                        PyInt_FromLong(PyUnicode_GetMax()));\n#endif\n    SET_SYS_FROM_STRING(\"builtin_module_names\",\n                        list_builtin_module_names());\n    {\n        /* Assumes that longs are at least 2 bytes long.\n           Should be safe! */\n        unsigned long number = 1;\n        char *value;\n\n        s = (char *) &number;\n        if (s[0] == 0)\n            value = \"big\";\n        else\n            value = \"little\";\n        SET_SYS_FROM_STRING(\"byteorder\",\n                            PyString_FromString(value));\n    }\n#ifdef MS_COREDLL\n    SET_SYS_FROM_STRING(\"dllhandle\",\n                        PyLong_FromVoidPtr(PyWin_DLLhModule));\n    SET_SYS_FROM_STRING(\"winver\",\n                        PyString_FromString(PyWin_DLLVersionString));\n#endif\n    if (warnoptions == NULL) {\n        warnoptions = PyList_New(0);\n    }\n    else {\n        Py_INCREF(warnoptions);\n    }\n    if (warnoptions != NULL) {\n        PyDict_SetItemString(sysdict, \"warnoptions\", warnoptions);\n    }\n\n    /* version_info */\n    if (VersionInfoType.tp_name == 0)\n        PyStructSequence_InitType(&VersionInfoType, &version_info_desc);\n    SET_SYS_FROM_STRING(\"version_info\", make_version_info());\n    /* prevent user from creating new instances */\n    VersionInfoType.tp_init = NULL;\n    VersionInfoType.tp_new = NULL;\n\n    /* flags */\n    if (FlagsType.tp_name == 0)\n        PyStructSequence_InitType(&FlagsType, &flags_desc);\n    SET_SYS_FROM_STRING(\"flags\", make_flags());\n    /* prevent user from creating new instances */\n    FlagsType.tp_init = NULL;\n    FlagsType.tp_new = NULL;\n\n\n#if defined(MS_WINDOWS)\n    /* getwindowsversion */\n    if (WindowsVersionType.tp_name == 0)\n        PyStructSequence_InitType(&WindowsVersionType, &windows_version_desc);\n    /* prevent user from creating new instances */\n    WindowsVersionType.tp_init = NULL;\n    WindowsVersionType.tp_new = NULL;\n#endif\n\n    /* float repr style: 0.03 (short) vs 0.029999999999999999 (legacy) */\n#ifndef PY_NO_SHORT_FLOAT_REPR\n    SET_SYS_FROM_STRING(\"float_repr_style\",\n                        PyString_FromString(\"short\"));\n#else\n    SET_SYS_FROM_STRING(\"float_repr_style\",\n                        PyString_FromString(\"legacy\"));\n#endif\n\n#undef SET_SYS_FROM_STRING\n    if (PyErr_Occurred())\n        return NULL;\n    return m;\n}\n\nstatic PyObject *\nmakepathobject(char *path, int delim)\n{\n    int i, n;\n    char *p;\n    PyObject *v, *w;\n\n    n = 1;\n    p = path;\n    while ((p = strchr(p, delim)) != NULL) {\n        n++;\n        p++;\n    }\n    v = PyList_New(n);\n    if (v == NULL)\n        return NULL;\n    for (i = 0; ; i++) {\n        p = strchr(path, delim);\n        if (p == NULL)\n            p = strchr(path, '\\0'); /* End of string */\n        w = PyString_FromStringAndSize(path, (Py_ssize_t) (p - path));\n        if (w == NULL) {\n            Py_DECREF(v);\n            return NULL;\n        }\n        PyList_SetItem(v, i, w);\n        if (*p == '\\0')\n            break;\n        path = p+1;\n    }\n    return v;\n}\n\nvoid\nPySys_SetPath(char *path)\n{\n    PyObject *v;\n    if ((v = makepathobject(path, DELIM)) == NULL)\n        Py_FatalError(\"can't create sys.path\");\n    if (PySys_SetObject(\"path\", v) != 0)\n        Py_FatalError(\"can't assign sys.path\");\n    Py_DECREF(v);\n}\n\nstatic PyObject *\nmakeargvobject(int argc, char **argv)\n{\n    PyObject *av;\n    if (argc <= 0 || argv == NULL) {\n        /* Ensure at least one (empty) argument is seen */\n        static char *empty_argv[1] = {\"\"};\n        argv = empty_argv;\n        argc = 1;\n    }\n    av = PyList_New(argc);\n    if (av != NULL) {\n        int i;\n        for (i = 0; i < argc; i++) {\n#ifdef __VMS\n            PyObject *v;\n\n            /* argv[0] is the script pathname if known */\n            if (i == 0) {\n                char* fn = decc$translate_vms(argv[0]);\n                if ((fn == (char *)0) || fn == (char *)-1)\n                    v = PyString_FromString(argv[0]);\n                else\n                    v = PyString_FromString(\n                        decc$translate_vms(argv[0]));\n            } else\n                v = PyString_FromString(argv[i]);\n#else\n            PyObject *v = PyString_FromString(argv[i]);\n#endif\n            if (v == NULL) {\n                Py_DECREF(av);\n                av = NULL;\n                break;\n            }\n            PyList_SetItem(av, i, v);\n        }\n    }\n    return av;\n}\n\nvoid\nPySys_SetArgvEx(int argc, char **argv, int updatepath)\n{\n#if defined(HAVE_REALPATH)\n    char fullpath[MAXPATHLEN];\n#elif defined(MS_WINDOWS) && !defined(MS_WINCE)\n    char fullpath[MAX_PATH];\n#endif\n    PyObject *av = makeargvobject(argc, argv);\n    PyObject *path = PySys_GetObject(\"path\");\n    if (av == NULL)\n        Py_FatalError(\"no mem for sys.argv\");\n    if (PySys_SetObject(\"argv\", av) != 0)\n        Py_FatalError(\"can't assign sys.argv\");\n    if (updatepath && path != NULL) {\n        char *argv0 = argv[0];\n        char *p = NULL;\n        Py_ssize_t n = 0;\n        PyObject *a;\n#ifdef HAVE_READLINK\n        char link[MAXPATHLEN+1];\n        char argv0copy[2*MAXPATHLEN+1];\n        int nr = 0;\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0)\n            nr = readlink(argv0, link, MAXPATHLEN);\n        if (nr > 0) {\n            /* It's a symlink */\n            link[nr] = '\\0';\n            if (link[0] == SEP)\n                argv0 = link; /* Link to absolute path */\n            else if (strchr(link, SEP) == NULL)\n                ; /* Link without path */\n            else {\n                /* Must join(dirname(argv0), link) */\n                char *q = strrchr(argv0, SEP);\n                if (q == NULL)\n                    argv0 = link; /* argv0 without path */\n                else {\n                    /* Must make a copy */\n                    strcpy(argv0copy, argv0);\n                    q = strrchr(argv0copy, SEP);\n                    strcpy(q+1, link);\n                    argv0 = argv0copy;\n                }\n            }\n        }\n#endif /* HAVE_READLINK */\n#if SEP == '\\\\' /* Special case for MS filename syntax */\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0) {\n            char *q;\n#if defined(MS_WINDOWS) && !defined(MS_WINCE)\n            /* This code here replaces the first element in argv with the full\n            path that it represents. Under CE, there are no relative paths so\n            the argument must be the full path anyway. */\n            char *ptemp;\n            if (GetFullPathName(argv0,\n                               sizeof(fullpath),\n                               fullpath,\n                               &ptemp)) {\n                argv0 = fullpath;\n            }\n#endif\n            p = strrchr(argv0, SEP);\n            /* Test for alternate separator */\n            q = strrchr(p ? p : argv0, '/');\n            if (q != NULL)\n                p = q;\n            if (p != NULL) {\n                n = p + 1 - argv0;\n                if (n > 1 && p[-1] != ':')\n                    n--; /* Drop trailing separator */\n            }\n        }\n#else /* All other filename syntaxes */\n        if (argc > 0 && argv0 != NULL && strcmp(argv0, \"-c\") != 0) {\n#if defined(HAVE_REALPATH)\n            if (realpath(argv0, fullpath)) {\n                argv0 = fullpath;\n            }\n#endif\n            p = strrchr(argv0, SEP);\n        }\n        if (p != NULL) {\n#ifndef RISCOS\n            n = p + 1 - argv0;\n#else /* don't include trailing separator */\n            n = p - argv0;\n#endif /* RISCOS */\n#if SEP == '/' /* Special case for Unix filename syntax */\n            if (n > 1)\n                n--; /* Drop trailing separator */\n#endif /* Unix */\n        }\n#endif /* All others */\n        a = PyString_FromStringAndSize(argv0, n);\n        if (a == NULL)\n            Py_FatalError(\"no mem for sys.path insertion\");\n        if (PyList_Insert(path, 0, a) < 0)\n            Py_FatalError(\"sys.path.insert(0) failed\");\n        Py_DECREF(a);\n    }\n    Py_DECREF(av);\n}\n\nvoid\nPySys_SetArgv(int argc, char **argv)\n{\n    PySys_SetArgvEx(argc, argv, 1);\n}\n\n\n/* APIs to write to sys.stdout or sys.stderr using a printf-like interface.\n   Adapted from code submitted by Just van Rossum.\n\n   PySys_WriteStdout(format, ...)\n   PySys_WriteStderr(format, ...)\n\n      The first function writes to sys.stdout; the second to sys.stderr.  When\n      there is a problem, they write to the real (C level) stdout or stderr;\n      no exceptions are raised.\n\n      Both take a printf-style format string as their first argument followed\n      by a variable length argument list determined by the format string.\n\n      *** WARNING ***\n\n      The format should limit the total size of the formatted output string to\n      1000 bytes.  In particular, this means that no unrestricted \"%s\" formats\n      should occur; these should be limited using \"%.<N>s where <N> is a\n      decimal number calculated so that <N> plus the maximum size of other\n      formatted text does not exceed 1000 bytes.  Also watch out for \"%f\",\n      which can print hundreds of digits for very large numbers.\n\n */\n\nstatic void\nmywrite(char *name, FILE *fp, const char *format, va_list va)\n{\n    PyObject *file;\n    PyObject *error_type, *error_value, *error_traceback;\n\n    PyErr_Fetch(&error_type, &error_value, &error_traceback);\n    file = PySys_GetObject(name);\n    if (file == NULL || PyFile_AsFile(file) == fp)\n        vfprintf(fp, format, va);\n    else {\n        char buffer[1001];\n        const int written = PyOS_vsnprintf(buffer, sizeof(buffer),\n                                           format, va);\n        if (PyFile_WriteString(buffer, file) != 0) {\n            PyErr_Clear();\n            fputs(buffer, fp);\n        }\n        if (written < 0 || (size_t)written >= sizeof(buffer)) {\n            const char *truncated = \"... truncated\";\n            if (PyFile_WriteString(truncated, file) != 0) {\n                PyErr_Clear();\n                fputs(truncated, fp);\n            }\n        }\n    }\n    PyErr_Restore(error_type, error_value, error_traceback);\n}\n\nvoid\nPySys_WriteStdout(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    mywrite(\"stdout\", stdout, format, va);\n    va_end(va);\n}\n\nvoid\nPySys_WriteStderr(const char *format, ...)\n{\n    va_list va;\n\n    va_start(va, format);\n    mywrite(\"stderr\", stderr, format, va);\n    va_end(va);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Python/pystate.c": "\n/* Thread and interpreter state structures and their interfaces */\n\n#include \"Python.h\"\n\n/* --------------------------------------------------------------------------\nCAUTION\n\nAlways use malloc() and free() directly in this file.  A number of these\nfunctions are advertised as safe to call when the GIL isn't held, and in\na debug build Python redirects (e.g.) PyMem_NEW (etc) to Python's debugging\nobmalloc functions.  Those aren't thread-safe (they rely on the GIL to avoid\nthe expense of doing their own locking).\n-------------------------------------------------------------------------- */\n\n#ifdef HAVE_DLOPEN\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#endif\n\n\n#ifdef WITH_THREAD\n#include \"pythread.h\"\nstatic PyThread_type_lock head_mutex = NULL; /* Protects interp->tstate_head */\n#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_allocate_lock()))\n#define HEAD_LOCK() PyThread_acquire_lock(head_mutex, WAIT_LOCK)\n#define HEAD_UNLOCK() PyThread_release_lock(head_mutex)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* The single PyInterpreterState used by this process'\n   GILState implementation\n*/\nstatic PyInterpreterState *autoInterpreterState = NULL;\nstatic int autoTLSkey = 0;\n#else\n#define HEAD_INIT() /* Nothing */\n#define HEAD_LOCK() /* Nothing */\n#define HEAD_UNLOCK() /* Nothing */\n#endif\n\nstatic PyInterpreterState *interp_head = NULL;\n\nPyThreadState *_PyThreadState_Current = NULL;\nPyThreadFrameGetter _PyThreadState_GetFrame = NULL;\n\n#ifdef WITH_THREAD\nstatic void _PyGILState_NoteThreadState(PyThreadState* tstate);\n#endif\n\n\nPyInterpreterState *\nPyInterpreterState_New(void)\n{\n    PyInterpreterState *interp = (PyInterpreterState *)\n                                 malloc(sizeof(PyInterpreterState));\n\n    if (interp != NULL) {\n        HEAD_INIT();\n#ifdef WITH_THREAD\n        if (head_mutex == NULL)\n            Py_FatalError(\"Can't initialize threads for interpreter\");\n#endif\n        interp->modules = NULL;\n        interp->modules_reloading = NULL;\n        interp->sysdict = NULL;\n        interp->builtins = NULL;\n        interp->tstate_head = NULL;\n        interp->codec_search_path = NULL;\n        interp->codec_search_cache = NULL;\n        interp->codec_error_registry = NULL;\n#ifdef HAVE_DLOPEN\n#ifdef RTLD_NOW\n        interp->dlopenflags = RTLD_NOW;\n#else\n        interp->dlopenflags = RTLD_LAZY;\n#endif\n#endif\n#ifdef WITH_TSC\n        interp->tscdump = 0;\n#endif\n\n        HEAD_LOCK();\n        interp->next = interp_head;\n        interp_head = interp;\n        HEAD_UNLOCK();\n    }\n\n    return interp;\n}\n\n\nvoid\nPyInterpreterState_Clear(PyInterpreterState *interp)\n{\n    PyThreadState *p;\n    HEAD_LOCK();\n    for (p = interp->tstate_head; p != NULL; p = p->next)\n        PyThreadState_Clear(p);\n    HEAD_UNLOCK();\n    Py_CLEAR(interp->codec_search_path);\n    Py_CLEAR(interp->codec_search_cache);\n    Py_CLEAR(interp->codec_error_registry);\n    Py_CLEAR(interp->modules);\n    Py_CLEAR(interp->modules_reloading);\n    Py_CLEAR(interp->sysdict);\n    Py_CLEAR(interp->builtins);\n}\n\n\nstatic void\nzapthreads(PyInterpreterState *interp)\n{\n    PyThreadState *p;\n    /* No need to lock the mutex here because this should only happen\n       when the threads are all really dead (XXX famous last words). */\n    while ((p = interp->tstate_head) != NULL) {\n        PyThreadState_Delete(p);\n    }\n}\n\n\nvoid\nPyInterpreterState_Delete(PyInterpreterState *interp)\n{\n    PyInterpreterState **p;\n    zapthreads(interp);\n    HEAD_LOCK();\n    for (p = &interp_head; ; p = &(*p)->next) {\n        if (*p == NULL)\n            Py_FatalError(\n                \"PyInterpreterState_Delete: invalid interp\");\n        if (*p == interp)\n            break;\n    }\n    if (interp->tstate_head != NULL)\n        Py_FatalError(\"PyInterpreterState_Delete: remaining threads\");\n    *p = interp->next;\n    HEAD_UNLOCK();\n    free(interp);\n}\n\n\n/* Default implementation for _PyThreadState_GetFrame */\nstatic struct _frame *\nthreadstate_getframe(PyThreadState *self)\n{\n    return self->frame;\n}\n\nstatic PyThreadState *\nnew_threadstate(PyInterpreterState *interp, int init)\n{\n    PyThreadState *tstate = (PyThreadState *)malloc(sizeof(PyThreadState));\n\n    if (_PyThreadState_GetFrame == NULL)\n        _PyThreadState_GetFrame = threadstate_getframe;\n\n    if (tstate != NULL) {\n        tstate->interp = interp;\n\n        tstate->frame = NULL;\n        tstate->recursion_depth = 0;\n        tstate->tracing = 0;\n        tstate->use_tracing = 0;\n        tstate->tick_counter = 0;\n        tstate->gilstate_counter = 0;\n        tstate->async_exc = NULL;\n#ifdef WITH_THREAD\n        tstate->thread_id = PyThread_get_thread_ident();\n#else\n        tstate->thread_id = 0;\n#endif\n\n        tstate->dict = NULL;\n\n        tstate->curexc_type = NULL;\n        tstate->curexc_value = NULL;\n        tstate->curexc_traceback = NULL;\n\n        tstate->exc_type = NULL;\n        tstate->exc_value = NULL;\n        tstate->exc_traceback = NULL;\n\n        tstate->c_profilefunc = NULL;\n        tstate->c_tracefunc = NULL;\n        tstate->c_profileobj = NULL;\n        tstate->c_traceobj = NULL;\n\n        if (init)\n            _PyThreadState_Init(tstate);\n\n        HEAD_LOCK();\n        tstate->next = interp->tstate_head;\n        interp->tstate_head = tstate;\n        HEAD_UNLOCK();\n    }\n\n    return tstate;\n}\n\nPyThreadState *\nPyThreadState_New(PyInterpreterState *interp)\n{\n    return new_threadstate(interp, 1);\n}\n\nPyThreadState *\n_PyThreadState_Prealloc(PyInterpreterState *interp)\n{\n    return new_threadstate(interp, 0);\n}\n\nvoid\n_PyThreadState_Init(PyThreadState *tstate)\n{\n#ifdef WITH_THREAD\n    _PyGILState_NoteThreadState(tstate);\n#endif\n}\n\nvoid\nPyThreadState_Clear(PyThreadState *tstate)\n{\n    if (Py_VerboseFlag && tstate->frame != NULL)\n        fprintf(stderr,\n          \"PyThreadState_Clear: warning: thread still has a frame\\n\");\n\n    Py_CLEAR(tstate->frame);\n\n    Py_CLEAR(tstate->dict);\n    Py_CLEAR(tstate->async_exc);\n\n    Py_CLEAR(tstate->curexc_type);\n    Py_CLEAR(tstate->curexc_value);\n    Py_CLEAR(tstate->curexc_traceback);\n\n    Py_CLEAR(tstate->exc_type);\n    Py_CLEAR(tstate->exc_value);\n    Py_CLEAR(tstate->exc_traceback);\n\n    tstate->c_profilefunc = NULL;\n    tstate->c_tracefunc = NULL;\n    Py_CLEAR(tstate->c_profileobj);\n    Py_CLEAR(tstate->c_traceobj);\n}\n\n\n/* Common code for PyThreadState_Delete() and PyThreadState_DeleteCurrent() */\nstatic void\ntstate_delete_common(PyThreadState *tstate)\n{\n    PyInterpreterState *interp;\n    PyThreadState **p;\n    PyThreadState *prev_p = NULL;\n    if (tstate == NULL)\n        Py_FatalError(\"PyThreadState_Delete: NULL tstate\");\n    interp = tstate->interp;\n    if (interp == NULL)\n        Py_FatalError(\"PyThreadState_Delete: NULL interp\");\n    HEAD_LOCK();\n    for (p = &interp->tstate_head; ; p = &(*p)->next) {\n        if (*p == NULL)\n            Py_FatalError(\n                \"PyThreadState_Delete: invalid tstate\");\n        if (*p == tstate)\n            break;\n        /* Sanity check.  These states should never happen but if\n         * they do we must abort.  Otherwise we'll end up spinning in\n         * in a tight loop with the lock held.  A similar check is done\n         * in thread.c find_key().  */\n        if (*p == prev_p)\n            Py_FatalError(\n                \"PyThreadState_Delete: small circular list(!)\"\n                \" and tstate not found.\");\n        prev_p = *p;\n        if ((*p)->next == interp->tstate_head)\n            Py_FatalError(\n                \"PyThreadState_Delete: circular list(!) and\"\n                \" tstate not found.\");\n    }\n    *p = tstate->next;\n    HEAD_UNLOCK();\n    free(tstate);\n}\n\n\nvoid\nPyThreadState_Delete(PyThreadState *tstate)\n{\n    if (tstate == _PyThreadState_Current)\n        Py_FatalError(\"PyThreadState_Delete: tstate is still current\");\n    tstate_delete_common(tstate);\n#ifdef WITH_THREAD\n    if (autoInterpreterState && PyThread_get_key_value(autoTLSkey) == tstate)\n        PyThread_delete_key_value(autoTLSkey);\n#endif /* WITH_THREAD */\n}\n\n\n#ifdef WITH_THREAD\nvoid\nPyThreadState_DeleteCurrent()\n{\n    PyThreadState *tstate = _PyThreadState_Current;\n    if (tstate == NULL)\n        Py_FatalError(\n            \"PyThreadState_DeleteCurrent: no current tstate\");\n    _PyThreadState_Current = NULL;\n    tstate_delete_common(tstate);\n    if (autoInterpreterState && PyThread_get_key_value(autoTLSkey) == tstate)\n        PyThread_delete_key_value(autoTLSkey);\n    PyEval_ReleaseLock();\n}\n#endif /* WITH_THREAD */\n\n\nPyThreadState *\nPyThreadState_Get(void)\n{\n    if (_PyThreadState_Current == NULL)\n        Py_FatalError(\"PyThreadState_Get: no current thread\");\n\n    return _PyThreadState_Current;\n}\n\n\nPyThreadState *\nPyThreadState_Swap(PyThreadState *newts)\n{\n    PyThreadState *oldts = _PyThreadState_Current;\n\n    _PyThreadState_Current = newts;\n    /* It should not be possible for more than one thread state\n       to be used for a thread.  Check this the best we can in debug\n       builds.\n    */\n#if defined(Py_DEBUG) && defined(WITH_THREAD)\n    if (newts) {\n        /* This can be called from PyEval_RestoreThread(). Similar\n           to it, we need to ensure errno doesn't change.\n        */\n        int err = errno;\n        PyThreadState *check = PyGILState_GetThisThreadState();\n        if (check && check->interp == newts->interp && check != newts)\n            Py_FatalError(\"Invalid thread state for this thread\");\n        errno = err;\n    }\n#endif\n    return oldts;\n}\n\n/* An extension mechanism to store arbitrary additional per-thread state.\n   PyThreadState_GetDict() returns a dictionary that can be used to hold such\n   state; the caller should pick a unique key and store its state there.  If\n   PyThreadState_GetDict() returns NULL, an exception has *not* been raised\n   and the caller should assume no per-thread state is available. */\n\nPyObject *\nPyThreadState_GetDict(void)\n{\n    if (_PyThreadState_Current == NULL)\n        return NULL;\n\n    if (_PyThreadState_Current->dict == NULL) {\n        PyObject *d;\n        _PyThreadState_Current->dict = d = PyDict_New();\n        if (d == NULL)\n            PyErr_Clear();\n    }\n    return _PyThreadState_Current->dict;\n}\n\n\n/* Asynchronously raise an exception in a thread.\n   Requested by Just van Rossum and Alex Martelli.\n   To prevent naive misuse, you must write your own extension\n   to call this, or use ctypes.  Must be called with the GIL held.\n   Returns the number of tstates modified (normally 1, but 0 if `id` didn't\n   match any known thread id).  Can be called with exc=NULL to clear an\n   existing async exception.  This raises no exceptions. */\n\nint\nPyThreadState_SetAsyncExc(long id, PyObject *exc) {\n    PyThreadState *tstate = PyThreadState_GET();\n    PyInterpreterState *interp = tstate->interp;\n    PyThreadState *p;\n\n    /* Although the GIL is held, a few C API functions can be called\n     * without the GIL held, and in particular some that create and\n     * destroy thread and interpreter states.  Those can mutate the\n     * list of thread states we're traversing, so to prevent that we lock\n     * head_mutex for the duration.\n     */\n    HEAD_LOCK();\n    for (p = interp->tstate_head; p != NULL; p = p->next) {\n        if (p->thread_id == id) {\n            /* Tricky:  we need to decref the current value\n             * (if any) in p->async_exc, but that can in turn\n             * allow arbitrary Python code to run, including\n             * perhaps calls to this function.  To prevent\n             * deadlock, we need to release head_mutex before\n             * the decref.\n             */\n            PyObject *old_exc = p->async_exc;\n            Py_XINCREF(exc);\n            p->async_exc = exc;\n            HEAD_UNLOCK();\n            Py_XDECREF(old_exc);\n            return 1;\n        }\n    }\n    HEAD_UNLOCK();\n    return 0;\n}\n\n\n/* Routines for advanced debuggers, requested by David Beazley.\n   Don't use unless you know what you are doing! */\n\nPyInterpreterState *\nPyInterpreterState_Head(void)\n{\n    return interp_head;\n}\n\nPyInterpreterState *\nPyInterpreterState_Next(PyInterpreterState *interp) {\n    return interp->next;\n}\n\nPyThreadState *\nPyInterpreterState_ThreadHead(PyInterpreterState *interp) {\n    return interp->tstate_head;\n}\n\nPyThreadState *\nPyThreadState_Next(PyThreadState *tstate) {\n    return tstate->next;\n}\n\n/* The implementation of sys._current_frames().  This is intended to be\n   called with the GIL held, as it will be when called via\n   sys._current_frames().  It's possible it would work fine even without\n   the GIL held, but haven't thought enough about that.\n*/\nPyObject *\n_PyThread_CurrentFrames(void)\n{\n    PyObject *result;\n    PyInterpreterState *i;\n\n    result = PyDict_New();\n    if (result == NULL)\n        return NULL;\n\n    /* for i in all interpreters:\n     *     for t in all of i's thread states:\n     *          if t's frame isn't NULL, map t's id to its frame\n     * Because these lists can mutate even when the GIL is held, we\n     * need to grab head_mutex for the duration.\n     */\n    HEAD_LOCK();\n    for (i = interp_head; i != NULL; i = i->next) {\n        PyThreadState *t;\n        for (t = i->tstate_head; t != NULL; t = t->next) {\n            PyObject *id;\n            int stat;\n            struct _frame *frame = t->frame;\n            if (frame == NULL)\n                continue;\n            id = PyInt_FromLong(t->thread_id);\n            if (id == NULL)\n                goto Fail;\n            stat = PyDict_SetItem(result, id, (PyObject *)frame);\n            Py_DECREF(id);\n            if (stat < 0)\n                goto Fail;\n        }\n    }\n    HEAD_UNLOCK();\n    return result;\n\n Fail:\n    HEAD_UNLOCK();\n    Py_DECREF(result);\n    return NULL;\n}\n\n/* Python \"auto thread state\" API. */\n#ifdef WITH_THREAD\n\n/* Keep this as a static, as it is not reliable!  It can only\n   ever be compared to the state for the *current* thread.\n   * If not equal, then it doesn't matter that the actual\n     value may change immediately after comparison, as it can't\n     possibly change to the current thread's state.\n   * If equal, then the current thread holds the lock, so the value can't\n     change until we yield the lock.\n*/\nstatic int\nPyThreadState_IsCurrent(PyThreadState *tstate)\n{\n    /* Must be the tstate for this thread */\n    assert(PyGILState_GetThisThreadState()==tstate);\n    /* On Windows at least, simple reads and writes to 32 bit values\n       are atomic.\n    */\n    return tstate == _PyThreadState_Current;\n}\n\n/* Internal initialization/finalization functions called by\n   Py_Initialize/Py_Finalize\n*/\nvoid\n_PyGILState_Init(PyInterpreterState *i, PyThreadState *t)\n{\n    assert(i && t); /* must init with valid states */\n    autoTLSkey = PyThread_create_key();\n    autoInterpreterState = i;\n    assert(PyThread_get_key_value(autoTLSkey) == NULL);\n    assert(t->gilstate_counter == 0);\n\n    _PyGILState_NoteThreadState(t);\n}\n\nvoid\n_PyGILState_Fini(void)\n{\n    PyThread_delete_key(autoTLSkey);\n    autoInterpreterState = NULL;\n}\n\n/* Reset the TLS key - called by PyOS_AfterFork.\n * This should not be necessary, but some - buggy - pthread implementations\n * don't flush TLS on fork, see issue #10517.\n */\nvoid\n_PyGILState_Reinit(void)\n{\n    PyThreadState *tstate = PyGILState_GetThisThreadState();\n    PyThread_delete_key(autoTLSkey);\n    if ((autoTLSkey = PyThread_create_key()) == -1)\n        Py_FatalError(\"Could not allocate TLS entry\");\n\n    /* re-associate the current thread state with the new key */\n    if (PyThread_set_key_value(autoTLSkey, (void *)tstate) < 0)\n        Py_FatalError(\"Couldn't create autoTLSkey mapping\");\n}\n\n/* When a thread state is created for a thread by some mechanism other than\n   PyGILState_Ensure, it's important that the GILState machinery knows about\n   it so it doesn't try to create another thread state for the thread (this is\n   a better fix for SF bug #1010677 than the first one attempted).\n*/\nstatic void\n_PyGILState_NoteThreadState(PyThreadState* tstate)\n{\n    /* If autoTLSkey isn't initialized, this must be the very first\n       threadstate created in Py_Initialize().  Don't do anything for now\n       (we'll be back here when _PyGILState_Init is called). */\n    if (!autoInterpreterState)\n        return;\n\n    /* Stick the thread state for this thread in thread local storage.\n\n       The only situation where you can legitimately have more than one\n       thread state for an OS level thread is when there are multiple\n       interpreters, when:\n\n           a) You shouldn't really be using the PyGILState_ APIs anyway,\n          and:\n\n           b) The slightly odd way PyThread_set_key_value works (see\n          comments by its implementation) means that the first thread\n          state created for that given OS level thread will \"win\",\n          which seems reasonable behaviour.\n    */\n    if (PyThread_set_key_value(autoTLSkey, (void *)tstate) < 0)\n        Py_FatalError(\"Couldn't create autoTLSkey mapping\");\n\n    /* PyGILState_Release must not try to delete this thread state. */\n    tstate->gilstate_counter = 1;\n}\n\n/* The public functions */\nPyThreadState *\nPyGILState_GetThisThreadState(void)\n{\n    if (autoInterpreterState == NULL)\n        return NULL;\n    return (PyThreadState *)PyThread_get_key_value(autoTLSkey);\n}\n\nPyGILState_STATE\nPyGILState_Ensure(void)\n{\n    int current;\n    PyThreadState *tcur;\n    /* Note that we do not auto-init Python here - apart from\n       potential races with 2 threads auto-initializing, pep-311\n       spells out other issues.  Embedders are expected to have\n       called Py_Initialize() and usually PyEval_InitThreads().\n    */\n    assert(autoInterpreterState); /* Py_Initialize() hasn't been called! */\n    tcur = (PyThreadState *)PyThread_get_key_value(autoTLSkey);\n    if (tcur == NULL) {\n        /* Create a new thread state for this thread */\n        tcur = PyThreadState_New(autoInterpreterState);\n        if (tcur == NULL)\n            Py_FatalError(\"Couldn't create thread-state for new thread\");\n        /* This is our thread state!  We'll need to delete it in the\n           matching call to PyGILState_Release(). */\n        tcur->gilstate_counter = 0;\n        current = 0; /* new thread state is never current */\n    }\n    else\n        current = PyThreadState_IsCurrent(tcur);\n    if (current == 0)\n        PyEval_RestoreThread(tcur);\n    /* Update our counter in the thread-state - no need for locks:\n       - tcur will remain valid as we hold the GIL.\n       - the counter is safe as we are the only thread \"allowed\"\n         to modify this value\n    */\n    ++tcur->gilstate_counter;\n    return current ? PyGILState_LOCKED : PyGILState_UNLOCKED;\n}\n\nvoid\nPyGILState_Release(PyGILState_STATE oldstate)\n{\n    PyThreadState *tcur = (PyThreadState *)PyThread_get_key_value(\n                                                            autoTLSkey);\n    if (tcur == NULL)\n        Py_FatalError(\"auto-releasing thread-state, \"\n                      \"but no thread-state for this thread\");\n    /* We must hold the GIL and have our thread state current */\n    /* XXX - remove the check - the assert should be fine,\n       but while this is very new (April 2003), the extra check\n       by release-only users can't hurt.\n    */\n    if (! PyThreadState_IsCurrent(tcur))\n        Py_FatalError(\"This thread state must be current when releasing\");\n    assert(PyThreadState_IsCurrent(tcur));\n    --tcur->gilstate_counter;\n    assert(tcur->gilstate_counter >= 0); /* illegal counter value */\n\n    /* If we're going to destroy this thread-state, we must\n     * clear it while the GIL is held, as destructors may run.\n     */\n    if (tcur->gilstate_counter == 0) {\n        /* can't have been locked when we created it */\n        assert(oldstate == PyGILState_UNLOCKED);\n        PyThreadState_Clear(tcur);\n        /* Delete the thread-state.  Note this releases the GIL too!\n         * It's vital that the GIL be held here, to avoid shutdown\n         * races; see bugs 225673 and 1061968 (that nasty bug has a\n         * habit of coming back).\n         */\n        PyThreadState_DeleteCurrent();\n    }\n    /* Release the lock if necessary */\n    else if (oldstate == PyGILState_UNLOCKED)\n        PyEval_SaveThread();\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* WITH_THREAD */\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Include/pystate.h": "\n/* Thread and interpreter state structures and their interfaces */\n\n\n#ifndef Py_PYSTATE_H\n#define Py_PYSTATE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* State shared between threads */\n\nstruct _ts; /* Forward */\nstruct _is; /* Forward */\n\ntypedef struct _is {\n\n    struct _is *next;\n    struct _ts *tstate_head;\n\n    PyObject *modules;\n    PyObject *sysdict;\n    PyObject *builtins;\n    PyObject *modules_reloading;\n\n    PyObject *codec_search_path;\n    PyObject *codec_search_cache;\n    PyObject *codec_error_registry;\n\n#ifdef HAVE_DLOPEN\n    int dlopenflags;\n#endif\n#ifdef WITH_TSC\n    int tscdump;\n#endif\n\n} PyInterpreterState;\n\n\n/* State unique per thread */\n\nstruct _frame; /* Avoid including frameobject.h */\n\n/* Py_tracefunc return -1 when raising an exception, or 0 for success. */\ntypedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);\n\n/* The following values are used for 'what' for tracefunc functions: */\n#define PyTrace_CALL 0\n#define PyTrace_EXCEPTION 1\n#define PyTrace_LINE 2\n#define PyTrace_RETURN 3\n#define PyTrace_C_CALL 4\n#define PyTrace_C_EXCEPTION 5\n#define PyTrace_C_RETURN 6\n\ntypedef struct _ts {\n    /* See Python/ceval.c for comments explaining most fields */\n\n    struct _ts *next;\n    PyInterpreterState *interp;\n\n    struct _frame *frame;\n    int recursion_depth;\n    /* 'tracing' keeps track of the execution depth when tracing/profiling.\n       This is to prevent the actual trace/profile code from being recorded in\n       the trace/profile. */\n    int tracing;\n    int use_tracing;\n\n    Py_tracefunc c_profilefunc;\n    Py_tracefunc c_tracefunc;\n    PyObject *c_profileobj;\n    PyObject *c_traceobj;\n\n    PyObject *curexc_type;\n    PyObject *curexc_value;\n    PyObject *curexc_traceback;\n\n    PyObject *exc_type;\n    PyObject *exc_value;\n    PyObject *exc_traceback;\n\n    PyObject *dict;  /* Stores per-thread state */\n\n    /* tick_counter is incremented whenever the check_interval ticker\n     * reaches zero. The purpose is to give a useful measure of the number\n     * of interpreted bytecode instructions in a given thread.  This\n     * extremely lightweight statistic collector may be of interest to\n     * profilers (like psyco.jit()), although nothing in the core uses it.\n     */\n    int tick_counter;\n\n    int gilstate_counter;\n\n    PyObject *async_exc; /* Asynchronous exception to raise */\n    long thread_id; /* Thread id where this tstate was created */\n\n    /* XXX signal handlers should also be here */\n\n} PyThreadState;\n\n\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);\nPyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);\nPyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) _PyThreadState_Prealloc(PyInterpreterState *);\nPyAPI_FUNC(void) _PyThreadState_Init(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);\n#ifdef WITH_THREAD\nPyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);\nPyAPI_FUNC(void) _PyGILState_Reinit(void);\n#endif\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);\nPyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);\nPyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);\nPyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);\n\n\n/* Variable and macro for in-line access to current thread state */\n\nPyAPI_DATA(PyThreadState *) _PyThreadState_Current;\n\n#ifdef Py_DEBUG\n#define PyThreadState_GET() PyThreadState_Get()\n#else\n#define PyThreadState_GET() (_PyThreadState_Current)\n#endif\n\ntypedef\n    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}\n        PyGILState_STATE;\n\n/* Ensure that the current thread is ready to call the Python\n   C API, regardless of the current state of Python, or of its\n   thread lock.  This may be called as many times as desired\n   by a thread so long as each call is matched with a call to\n   PyGILState_Release().  In general, other thread-state APIs may\n   be used between _Ensure() and _Release() calls, so long as the\n   thread-state is restored to its previous state before the Release().\n   For example, normal use of the Py_BEGIN_ALLOW_THREADS/\n   Py_END_ALLOW_THREADS macros are acceptable.\n\n   The return value is an opaque \"handle\" to the thread state when\n   PyGILState_Ensure() was called, and must be passed to\n   PyGILState_Release() to ensure Python is left in the same state. Even\n   though recursive calls are allowed, these handles can *not* be shared -\n   each unique call to PyGILState_Ensure must save the handle for its\n   call to PyGILState_Release.\n\n   When the function returns, the current thread will hold the GIL.\n\n   Failure is a fatal error.\n*/\nPyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);\n\n/* Release any resources previously acquired.  After this call, Python's\n   state will be the same as it was prior to the corresponding\n   PyGILState_Ensure() call (but generally this state will be unknown to\n   the caller, hence the use of the GILState API.)\n\n   Every call to PyGILState_Ensure must be matched by a call to\n   PyGILState_Release on the same thread.\n*/\nPyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);\n\n/* Helper/diagnostic function - get the current thread state for\n   this thread.  May return NULL if no GILState API has been used\n   on the current thread.  Note the main thread always has such a\n   thread-state, even if no auto-thread-state call has been made\n   on the main thread.\n*/\nPyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);\n\n/* The implementation of sys._current_frames()  Returns a dict mapping\n   thread id to that thread's current frame.\n*/\nPyAPI_FUNC(PyObject *) _PyThread_CurrentFrames(void);\n\n/* Routines for advanced debuggers, requested by David Beazley.\n   Don't use unless you know what you are doing! */\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);\n\ntypedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);\n\n/* hook for PyEval_GetFrame(), requested for Psyco */\nPyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYSTATE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.111.1.1 2013/04/12 18:48:47 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n\n/*\n** if needed, includes windows header before everything else\n*/\n#if defined(_WIN32) && !defined(UEFI_C_SOURCE) && !defined(_DOS_WATCOM)\n#include <windows.h>\n#endif\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_PATH and LUA_CPATH are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH)\n#define LUA_PATH    \"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH)\n#define LUA_CPATH   \"LUA_CPATH\"\n#endif\n\n#define LUA_PATHSUFFIX      \"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_PATHVERSION     LUA_PATH LUA_PATHSUFFIX\n#define LUA_CPATHVERSION    LUA_CPATH LUA_PATHSUFFIX\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_PATH_SEP)\n#define LUA_PATH_SEP        \";\"\n#endif\n#if !defined (LUA_PATH_MARK)\n#define LUA_PATH_MARK       \"?\"\n#endif\n#if !defined (LUA_EXEC_DIR)\n#define LUA_EXEC_DIR        \"!\"\n#endif\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK      \"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP     LUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP     LUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF     \"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP   \"_\"\n\n\n/* table (in the registry) that keeps handles for all loaded C libraries */\n#define CLIBS       \"_CLIBS\"\n\n#define LIB_FAIL    \"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB      1\n#define ERRFUNC     2\n\n#define setprogdir(L)       ((void)0)\n\n\n/*\n** system-dependent functions\n*/\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path, int seeglb);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_USE_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#undef setprogdir\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS   0\n#endif\n\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL    \"absent\"\n\n\n#define DLMSG   \"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\nstatic void *ll_checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\nstatic void ll_addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  int n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    ll_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = ll_load(L, path, *sym == '*');\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    ll_addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = ll_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module \" LUA_QS\n                         \" from file \" LUA_QS \":\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *funcname;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    funcname = lua_pushlstring(L, modname, mark - modname);\n    funcname = lua_pushfstring(L, LUA_POF\"%s\", funcname);\n    stat = ll_loadfunc(L, filename, funcname);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  funcname = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return ll_loadfunc(L, filename, funcname);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                         name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  lua_getfield(L, lua_upvalueindex(1), \"searchers\");  /* will be at index 3 */\n  if (!lua_istable(L, 3))\n    luaL_error(L, LUA_QL(\"package.searchers\") \" must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, 3, i);  /* get a searcher */\n    if (lua_isnil(L, -1)) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);  /* _LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_isnil(L, -1)) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK     \"\\1\"\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname1,\n                                   const char *envname2, const char *def) {\n  const char *path = getenv(envname1);\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname2);  /* try alternative name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with pre-defined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  /* create table CLIBS to keep track of loaded C libraries */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_createtable(L, 0, 1);  /* metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  /* create `package' table */\n  luaL_newlib(L, pk_funcs);\n  createsearcherstable(L);\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field `loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n  /* set field 'path' */\n  setpath(L, \"path\", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);\n  /* set field 'cpath' */\n  setpath(L, \"cpath\", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/StdLib/Include/nsswitch.h": "/*\t$NetBSD: nsswitch.h,v 1.20 2008/04/28 20:22:54 martin Exp $\t*/\n\n/*-\n * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Luke Mewburn.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _NSSWITCH_H\n#define _NSSWITCH_H\t1\n\n/*\n * Don't use va_list in prototypes.   va_list is typedef'd in two places\n * (<machine/varargs.h> and <machine/stdarg.h>), so if we include one of\n * them here we may collide with the utility's includes.  It's unreasonable\n * for utilities to have to include one of them to include nsswitch.h, so\n * we get _BSD_VA_LIST_ from <machine/ansi.h> and use it.\n */\n#include <machine/ansi.h>\n#include <sys/types.h>\n\n#define\tNSS_MODULE_INTERFACE_VERSION\t0\n\n#ifndef _PATH_NS_CONF\n#define _PATH_NS_CONF\t\"/etc/nsswitch.conf\"\n#endif\n\n#define\tNS_CONTINUE\t0\n#define\tNS_RETURN\t1\n\n/*\n * Layout of:\n *\tuint32_t ns_src.flags\n */ \n\t/* nsswitch.conf status codes and nsdispatch(3) return values */\n#define\tNS_SUCCESS\t(1<<0)\t\t/* entry was found */\n#define\tNS_UNAVAIL\t(1<<1)\t\t/* source not responding, or corrupt */\n#define\tNS_NOTFOUND\t(1<<2)\t\t/* source responded 'no such entry' */\n#define\tNS_TRYAGAIN\t(1<<3)\t\t/* source busy, may respond to retrys */\n#define\tNS_STATUSMASK\t0x000000ff\t/* bitmask to get the status flags */\n\n\t/* internal nsdispatch(3) flags; not settable in nsswitch.conf(5)  */\n#define\tNS_FORCEALL\t(1<<8)\t\t/* force all methods to be invoked; */\n\n/*\n * Currently implemented sources.\n */\n#define NSSRC_FILES\t\"files\"\t\t/* local files */\n#define\tNSSRC_DNS\t\"dns\"\t\t/* DNS; IN for hosts, HS for others */\n#define\tNSSRC_NIS\t\"nis\"\t\t/* YP/NIS */\n#define\tNSSRC_COMPAT\t\"compat\"\t/* passwd,group in YP compat mode */\n\n/*\n * Currently implemented databases.\n */\n#define NSDB_HOSTS\t\t\"hosts\"\n#define NSDB_GROUP\t\t\"group\"\n#define NSDB_GROUP_COMPAT\t\"group_compat\"\n#define NSDB_NETGROUP\t\t\"netgroup\"\n#define NSDB_NETWORKS\t\t\"networks\"\n#define NSDB_PASSWD\t\t\"passwd\"\n#define NSDB_PASSWD_COMPAT\t\"passwd_compat\"\n#define NSDB_SHELLS\t\t\"shells\"\n\n/*\n * Suggested databases to implement.\n */\n#define NSDB_ALIASES\t\t\"aliases\"\n#define NSDB_AUTH\t\t\"auth\"\n#define NSDB_AUTOMOUNT\t\t\"automount\"\n#define NSDB_BOOTPARAMS\t\t\"bootparams\"\n#define NSDB_ETHERS\t\t\"ethers\"\n#define NSDB_EXPORTS\t\t\"exports\"\n#define NSDB_NETMASKS\t\t\"netmasks\"\n#define NSDB_PHONES\t\t\"phones\"\n#define NSDB_PRINTCAP\t\t\"printcap\"\n#define NSDB_PROTOCOLS\t\t\"protocols\"\n#define NSDB_REMOTE\t\t\"remote\"\n#define NSDB_RPC\t\t\"rpc\"\n#define NSDB_SENDMAILVARS\t\"sendmailvars\"\n#define NSDB_SERVICES\t\t\"services\"\n#define NSDB_TERMCAP\t\t\"termcap\"\n#define NSDB_TTYS\t\t\"ttys\"\n\n/*\n * ns_dtab `callback' function signature.\n */\ntypedef\tint (*nss_method)(void *, void *, _BSD_VA_LIST_);\n\n/*\n * ns_dtab - `nsswitch dispatch table'\n * Contains an entry for each source and the appropriate function to call.\n */\ntypedef struct {\n\tconst char\t *src;\n\tnss_method\t callback;\n\tvoid\t\t *cb_data;\n} ns_dtab;\n\n/*\n * Macros to help build an ns_dtab[]\n */\n#define NS_FILES_CB(F,C)\t{ NSSRC_FILES,\tF,\t__UNCONST(C) },\n#define NS_COMPAT_CB(F,C)\t{ NSSRC_COMPAT,\tF,\t__UNCONST(C) },\n \n#ifdef HESIOD\n#   define NS_DNS_CB(F,C)\t{ NSSRC_DNS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_DNS_CB(F,C)\n#endif\n\n#ifdef YP\n#   define NS_NIS_CB(F,C)\t{ NSSRC_NIS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_NIS_CB(F,C)\n#endif\n#define\tNS_NULL_CB\t\t{ NULL, NULL, NULL },\n\n/*\n * ns_src - `nsswitch source'\n * Used by the nsparser routines to store a mapping between a source\n * and its dispatch control flags for a given database.\n */\ntypedef struct {\n\tconst char\t*name;\n\tuint32_t\t flags;\n} ns_src;\n\n\n/*\n * Default sourcelists (if nsswitch.conf is missing, corrupt,\n * or the requested database doesn't have an entry)\n */\nextern const ns_src __nsdefaultsrc[];\nextern const ns_src __nsdefaultcompat[];\nextern const ns_src __nsdefaultcompat_forceall[];\nextern const ns_src __nsdefaultfiles[];\nextern const ns_src __nsdefaultfiles_forceall[];\nextern const ns_src __nsdefaultnis[];\nextern const ns_src __nsdefaultnis_forceall[];\n\n\n/*\n * ns_mtab - `nsswitch method table'\n * An nsswitch module provides a mapping from (database name, method name)\n * tuples to the nss_method and associated callback data.  Effectively,\n * ns_dtab, but used for dynamically loaded modules.\n */\ntypedef struct {\n\tconst char\t*database;\n\tconst char\t*name;\n\tnss_method\t method;\n\tvoid\t\t*mdata;\n} ns_mtab;\n\n/*\n * nss_module_register_fn - module registration function\n *\tcalled at module load\n * nss_module_unregister_fn - module un-registration function\n *\tcalled at module unload\n */\ntypedef\tvoid (*nss_module_unregister_fn)(ns_mtab *, u_int);\ntypedef\tns_mtab *(*nss_module_register_fn)(const char *, u_int *,\n\t\t\t\t\t   nss_module_unregister_fn *);\n\n#ifdef _NS_PRIVATE\n\n/*\n * Private data structures for back-end nsswitch implementation.\n */\n\n/*\n * ns_dbt - `nsswitch database thang'\n * For each database in /etc/nsswitch.conf there is a ns_dbt, with its\n * name and a list of ns_src's containing the source information.\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* name of database */\n\tns_src\t\t*srclist;\t/* list of sources */\n\tu_int\t\t srclistsize;\t/* size of srclist */\n} ns_dbt;\n\n/*\n * ns_mod - `nsswitch module'\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* module name */\n\tvoid\t\t*handle;\t/* handle from dlopen() */\n\tns_mtab\t\t*mtab;\t\t/* method table */\n\tu_int\t\t mtabsize;\t/* size of mtab */\n\t\t\t\t\t/* called to unload module */\n\tnss_module_unregister_fn unregister;\n} ns_mod;\n\n#endif /* _NS_PRIVATE */\n\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\nint\tnsdispatch(void *, const ns_dtab [], const char *,\n\t\t\tconst char *, const ns_src [], ...);\n\n#ifdef _NS_PRIVATE\nint\t\t _nsdbtaddsrc(ns_dbt *, const ns_src *);\nvoid\t\t _nsdbtdump(const ns_dbt *);\nint\t\t _nsdbtput(const ns_dbt *);\nvoid\t\t _nsyyerror(const char *);\nint\t\t _nsyylex(void);\n#endif /* _NS_PRIVATE */\n\n__END_DECLS\n\n#endif /* !_NSSWITCH_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EmulatorPkg/build.sh": "#!/bin/bash\n#\n# Copyright (c) 2008 - 2011, Apple Inc. All rights reserved.<BR>\n# Copyright (c) 2010 - 2015, Intel Corporation. All rights reserved.<BR>\n#\n# This program and the accompanying materials\n# are licensed and made available under the terms and conditions of the BSD License\n# which accompanies this distribution.  The full text of the license may be found at\n# http://opensource.org/licenses/bsd-license.php\n#\n# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n#\n\nset -e\nshopt -s nocasematch\n\n\n#\n# Setup workspace if it is not set\n#\nif [ -z \"$WORKSPACE\" ]\nthen\n  echo Initializing workspace\n  if [ ! -e `pwd`/edksetup.sh ]\n  then\n    cd ..\n  fi\n# This version is for the tools in the BaseTools project.\n# this assumes svn pulls have the same root dir\n#  export EDK_TOOLS_PATH=`pwd`/../BaseTools\n# This version is for the tools source in edk2\n  export EDK_TOOLS_PATH=`pwd`/BaseTools\n  echo $EDK_TOOLS_PATH\n  source edksetup.sh BaseTools\nelse\n  echo Building from: $WORKSPACE\nfi\n\n#\n# Configure defaults for various options\n#\n\nPROCESSOR=\nBUILDTARGET=DEBUG\nBUILD_OPTIONS=\nPLATFORMFILE=\nLAST_ARG=\nRUN_EMULATOR=no\nCLEAN_TYPE=none\nTARGET_TOOLS=GCC44\nNETWORK_SUPPORT=\nBUILD_NEW_SHELL=\nBUILD_FAT=\nHOST_PROCESSOR=X64\n\ncase `uname` in\n  CYGWIN*) echo Cygwin not fully supported yet. ;;\n  Darwin*)\n      Major=$(uname -r | cut -f 1 -d '.')\n      if [[ $Major == 9 ]]\n      then\n        echo UnixPkg requires Snow Leopard or later OS\n        exit 1\n      else\n        CLANG_VER=$(clang -ccc-host-triple x86_64-pc-win32-macho 2>&1 >/dev/null) || true\n        if [[ \"$CLANG_VER\" == *-ccc-host-triple* ]]\n        then\n        # only older versions of Xcode support -ccc-host-tripe, for newer versions\n        # it is -target\n          HOST_TOOLS=XCODE32\n          TARGET_TOOLS=XCODE5\n        else\n          HOST_TOOLS=XCODE32\n          TARGET_TOOLS=XCLANG\n        fi\n      fi\n      BUILD_NEW_SHELL=\"-D BUILD_NEW_SHELL\"\n      BUILD_FAT=\"-D BUILD_FAT\"\n      ;;\n  Linux*)\n    case `uname -m` in\n      i386)\n        HOST_PROCESSOR=IA32\n        ;;\n      i686)\n        HOST_PROCESSOR=IA32\n        ;;\n      x86_64)\n        HOST_PROCESSOR=X64\n        ;;\n    esac\n\n    gcc_version=$(gcc -v 2>&1 | tail -1 | awk '{print $3}')\n    case $gcc_version in\n      [1-3].*|4.[0-3].*)\n        echo EmulatorPkg requires GCC4.4 or later\n        exit 1\n        ;;\n      4.4.*)\n        TARGET_TOOLS=GCC44\n        ;;\n      4.5.*)\n        TARGET_TOOLS=GCC45\n        ;;\n      4.6.*)\n        TARGET_TOOLS=GCC46\n        ;;\n      4.7.*)\n        TARGET_TOOLS=GCC47\n        ;;\n      4.8.*)\n        TARGET_TOOLS=GCC48\n        ;;\n      4.9.*|6.[0-2].*)\n        TARGET_TOOLS=GCC49\n        ;;\n      *)\n        TARGET_TOOLS=GCC5\n        ;;\n    esac\n    ;;\nesac\n\n#\n# Scan command line to override defaults\n#\n\nfor arg in \"$@\"\ndo\n  if [ -z \"$LAST_ARG\" ]; then\n    case $arg in\n      -a|-b|-t|-p)\n        LAST_ARG=$arg\n        ;;\n      run)\n        RUN_EMULATOR=yes\n        shift\n        break\n        ;;\n      clean|cleanall)\n        CLEAN_TYPE=$arg\n        shift\n        break\n        ;;\n      *)\n        BUILD_OPTIONS=\"$BUILD_OPTIONS $arg\"\n        ;;\n    esac\n  else\n    case $LAST_ARG in\n      -a)\n        PROCESSOR=$arg\n        ;;\n      -b)\n        BUILDTARGET=$arg\n        ;;\n      -p)\n        PLATFORMFILE=$arg\n        ;;\n      -t)\n        HOST_TOOLS=$arg\n        ;;\n      *)\n        BUILD_OPTIONS=\"$BUILD_OPTIONS $arg\"\n        ;;\n    esac\n    LAST_ARG=\n  fi\n  shift\ndone\nif [ -z \"$HOST_TOOLS\" ]\nthen\n  HOST_TOOLS=$TARGET_TOOLS\nfi\n\nif [ -z \"$PROCESSOR\" ]\nthen\n  PROCESSOR=$HOST_PROCESSOR\nfi\n\ncase $PROCESSOR in\n  IA32)\n    ARCH_SIZE=32\n    BUILD_OUTPUT_DIR=$WORKSPACE/Build/Emulator32\n    LIB_NAMES=\"ld-linux.so.2 libdl.so.2 crt1.o crti.o crtn.o\"\n    LIB_SEARCH_PATHS=\"/usr/lib/i386-linux-gnu /usr/lib32 /lib32 /usr/lib /lib\"\n    ;;\n  X64)\n    ARCH_SIZE=64\n    BUILD_OUTPUT_DIR=$WORKSPACE/Build/Emulator\n    LIB_NAMES=\"ld-linux-x86-64.so.2 libdl.so.2 crt1.o crti.o crtn.o\"\n    LIB_SEARCH_PATHS=\"/usr/lib/x86_64-linux-gnu /usr/lib64 /lib64 /usr/lib /lib\"\n    ;;\nesac\n\nfor libname in $LIB_NAMES\ndo\n  for dirname in $LIB_SEARCH_PATHS\n  do\n    if [ -e $dirname/$libname ]; then\n      export HOST_DLINK_PATHS=\"$HOST_DLINK_PATHS $dirname/$libname\"\n      break\n    fi\n  done\ndone\n\nPLATFORMFILE=$WORKSPACE/EmulatorPkg/EmulatorPkg.dsc\nBUILD_DIR=$BUILD_OUTPUT_DIR/DEBUG_\"$TARGET_TOOLS\"\nBUILD_ROOT_ARCH=$BUILD_DIR/$PROCESSOR\n\nif  [[ ! -f `which build` || ! -f `which GenFv` ]];\nthen\n  # build the tools if they don't yet exist. Bin scheme\n  echo Building tools as they are not in the path\n  make -C $WORKSPACE/BaseTools\nelif [[ ( -f `which build` ||  -f `which GenFv` )  && ! -d  $EDK_TOOLS_PATH/Source/C/bin ]];\nthen\n  # build the tools if they don't yet exist. BinWrapper scheme\n  echo Building tools no $EDK_TOOLS_PATH/Source/C/bin directory\n  make -C $WORKSPACE/BaseTools\nelse\n  echo using prebuilt tools\nfi\n\n\nif [[ \"$RUN_EMULATOR\" == \"yes\" ]]; then\n  case `uname` in\n    Darwin*)\n      #\n      # On Darwin we can't use dlopen, so we have to load the real PE/COFF images.\n      # This .gdbinit script sets a breakpoint that loads symbols for the PE/COFFEE\n      # images that get loaded in Host\n      #\n      if [[ \"$CLANG_VER\" == *-ccc-host-triple* ]]\n      then\n      # only older versions of Xcode support -ccc-host-tripe, for newer versions\n      # it is -target\n        cp $WORKSPACE/EmulatorPkg/Unix/lldbefi.py $BUILD_OUTPUT_DIR/DEBUG_\"$TARGET_TOOLS\"/$PROCESSOR\n        cd $BUILD_ROOT_ARCH; /usr/bin/lldb --source $WORKSPACE/EmulatorPkg/Unix/lldbinit Host\n        exit $? \n      else\n        cp $WORKSPACE/EmulatorPkg/Unix/.gdbinit $BUILD_OUTPUT_DIR/DEBUG_\"$TARGET_TOOLS\"/$PROCESSOR\n      fi\n      ;;\n  esac\n\n  /usr/bin/gdb $BUILD_ROOT_ARCH/Host -q -cd=$BUILD_ROOT_ARCH -x $WORKSPACE/EmulatorPkg/Unix/GdbRun\n  exit\nfi\n\ncase $CLEAN_TYPE in\n  clean)\n    build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc -a $PROCESSOR -b $BUILDTARGET -t $HOST_TOOLS -D UNIX_SEC_BUILD -n 3 clean\n    build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc -a $PROCESSOR -b $BUILDTARGET -t $TARGET_TOOLS -n 3 clean\n    exit $?\n    ;;\n  cleanall)\n    make -C $WORKSPACE/BaseTools clean\n    build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc -a $PROCESSOR -b $BUILDTARGET -t $HOST_TOOLS -D UNIX_SEC_BUILD -n 3 clean\n    build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc -a $PROCESSOR -b $BUILDTARGET -t $TARGET_TOOLS -n 3 clean\n    build -p $WORKSPACE/ShellPkg/ShellPkg.dsc -a IA32 -b $BUILDTARGET -t $TARGET_TOOLS -n 3 clean\n    exit $?\n    ;;\nesac\n\n\n#\n# Build the edk2 EmulatorPkg\n#\nif [[ $HOST_TOOLS == $TARGET_TOOLS ]]; then\n  build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc $BUILD_OPTIONS -a $PROCESSOR -b $BUILDTARGET -t $TARGET_TOOLS -D BUILD_$ARCH_SIZE -D UNIX_SEC_BUILD $NETWORK_SUPPORT $BUILD_NEW_SHELL $BUILD_FAT -n 3\nelse\n  build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc $BUILD_OPTIONS -a $PROCESSOR -b $BUILDTARGET -t $HOST_TOOLS  -D BUILD_$ARCH_SIZE -D UNIX_SEC_BUILD -D SKIP_MAIN_BUILD -n 3 modules\n  build -p $WORKSPACE/EmulatorPkg/EmulatorPkg.dsc $BUILD_OPTIONS -a $PROCESSOR -b $BUILDTARGET -t $TARGET_TOOLS -D BUILD_$ARCH_SIZE $NETWORK_SUPPORT $BUILD_NEW_SHELL $BUILD_FAT -n 3\n  cp $BUILD_OUTPUT_DIR/DEBUG_\"$HOST_TOOLS\"/$PROCESSOR/Host $BUILD_ROOT_ARCH\nfi\nexit $?\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EmulatorPkg/Unix/Host/Host.c": "/*++ @file\n\nCopyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>\nPortions copyright (c) 2008 - 2011, Apple Inc. All rights reserved.<BR>\nThis program and the accompanying materials\nare licensed and made available under the terms and conditions of the BSD License\nwhich accompanies this distribution.  The full text of the license may be found at\nhttp://opensource.org/licenses/bsd-license.php\n\nTHE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.\n\n**/\n\n#include \"Host.h\"\n\n#ifdef __APPLE__\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n\n//\n// Globals\n//\n\nEMU_THUNK_PPI mSecEmuThunkPpi = {\n  GasketSecUnixPeiAutoScan,\n  GasketSecUnixFdAddress,\n  GasketSecEmuThunkAddress\n};\n\nchar *gGdbWorkingFileName = NULL;\nunsigned int mScriptSymbolChangesCount = 0;\n\n\n//\n// Default information about where the FD is located.\n//  This array gets filled in with information from EFI_FIRMWARE_VOLUMES\n//  EFI_FIRMWARE_VOLUMES is a host environment variable set by system.cmd.\n//  The number of array elements is allocated base on parsing\n//  EFI_FIRMWARE_VOLUMES and the memory is never freed.\n//\nUINTN       gFdInfoCount = 0;\nEMU_FD_INFO *gFdInfo;\n\n//\n// Array that supports seperate memory rantes.\n//  The memory ranges are set in system.cmd via the EFI_MEMORY_SIZE variable.\n//  The number of array elements is allocated base on parsing\n//  EFI_MEMORY_SIZE and the memory is never freed.\n//\nUINTN              gSystemMemoryCount = 0;\nEMU_SYSTEM_MEMORY  *gSystemMemory;\n\n\n\nUINTN                        mImageContextModHandleArraySize = 0;\nIMAGE_CONTEXT_TO_MOD_HANDLE  *mImageContextModHandleArray = NULL;\n\nEFI_PEI_PPI_DESCRIPTOR  *gPpiList;\n\n\nint gInXcode = 0;\n\n\n/*++\n  Breakpoint target for Xcode project. Set in the Xcode XML\n\n  Xcode breakpoint will 'source Host.gdb'\n  gGdbWorkingFileName is set to Host.gdb\n\n**/\nVOID\nSecGdbConfigBreak (\n  VOID\n  )\n{\n}\n\n\n\n/*++\n\nRoutine Description:\n  Main entry point to SEC for Unix. This is a unix program\n\nArguments:\n  Argc - Number of command line arguments\n  Argv - Array of command line argument strings\n  Envp - Array of environment variable strings\n\nReturns:\n  0 - Normal exit\n  1 - Abnormal exit\n\n**/\nint\nmain (\n  IN  int   Argc,\n  IN  char  **Argv,\n  IN  char  **Envp\n  )\n{\n  EFI_STATUS            Status;\n  EFI_PHYSICAL_ADDRESS  InitialStackMemory;\n  UINT64                InitialStackMemorySize;\n  UINTN                 Index;\n  UINTN                 Index1;\n  UINTN                 Index2;\n  UINTN                 PeiIndex;\n  CHAR8                 *FileName;\n  BOOLEAN               Done;\n  EFI_PEI_FILE_HANDLE   FileHandle;\n  VOID                  *SecFile;\n  CHAR16                *MemorySizeStr;\n  CHAR16                *FirmwareVolumesStr;\n  UINTN                 *StackPointer;\n  FILE                  *GdbTempFile;\n\n  //\n  // Xcode does not support sourcing gdb scripts directly, so the Xcode XML\n  // has a break point script to source the GdbRun script.\n  //\n  SecGdbConfigBreak ();\n\n  //\n  // If dlopen doesn't work, then we build a gdb script to allow the\n  // symbols to be loaded.\n  //\n  Index = strlen (*Argv);\n  gGdbWorkingFileName = AllocatePool (Index + strlen(\".gdb\") + 1);\n  strcpy (gGdbWorkingFileName, *Argv);\n  strcat (gGdbWorkingFileName, \".gdb\");\n\n  //\n  // Empty out the gdb symbols script file.\n  //\n  GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n  if (GdbTempFile != NULL) {\n    fclose (GdbTempFile);\n  }\n\n  printf (\"\\nEDK II UNIX Host Emulation Environment from http://www.tianocore.org/edk2/\\n\");\n\n  setbuf (stdout, 0);\n  setbuf (stderr, 0);\n\n  MemorySizeStr      = (CHAR16 *) PcdGetPtr (PcdEmuMemorySize);\n  FirmwareVolumesStr = (CHAR16 *) PcdGetPtr (PcdEmuFirmwareVolume);\n\n  //\n  // PPIs pased into PEI_CORE\n  //\n  AddThunkPpi (EFI_PEI_PPI_DESCRIPTOR_PPI, &gEmuThunkPpiGuid, &mSecEmuThunkPpi);\n\n  SecInitThunkProtocol ();\n\n  //\n  // Emulator Bus Driver Thunks\n  //\n  AddThunkProtocol (&gX11ThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuGop), TRUE);\n  AddThunkProtocol (&gPosixFileSystemThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuFileSystem), TRUE);\n  AddThunkProtocol (&gBlockIoThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuVirtualDisk), TRUE);\n  AddThunkProtocol (&gSnpThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuNetworkInterface), TRUE);\n\n  //\n  // Emulator other Thunks\n  //\n  AddThunkProtocol (&gPthreadThunkIo, (CHAR16 *)PcdGetPtr (PcdEmuApCount), FALSE);\n\n  // EmuSecLibConstructor ();\n\n  gPpiList = GetThunkPpiList ();\n\n  //\n  // Allocate space for gSystemMemory Array\n  //\n  gSystemMemoryCount  = CountSeparatorsInString (MemorySizeStr, '!') + 1;\n  gSystemMemory       = AllocateZeroPool (gSystemMemoryCount * sizeof (EMU_SYSTEM_MEMORY));\n  if (gSystemMemory == NULL) {\n    printf (\"ERROR : Can not allocate memory for system.  Exiting.\\n\");\n    exit (1);\n  }\n  //\n  // Allocate space for gSystemMemory Array\n  //\n  gFdInfoCount  = CountSeparatorsInString (FirmwareVolumesStr, '!') + 1;\n  gFdInfo       = AllocateZeroPool (gFdInfoCount * sizeof (EMU_FD_INFO));\n  if (gFdInfo == NULL) {\n    printf (\"ERROR : Can not allocate memory for fd info.  Exiting.\\n\");\n    exit (1);\n  }\n\n  printf (\"  BootMode 0x%02x\\n\", (unsigned int)PcdGet32 (PcdEmuBootMode));\n\n  //\n  // Open up a 128K file to emulate temp memory for SEC.\n  //  on a real platform this would be SRAM, or using the cache as RAM.\n  //  Set InitialStackMemory to zero so UnixOpenFile will allocate a new mapping\n  //\n  InitialStackMemorySize  = STACK_SIZE;\n  InitialStackMemory = (UINTN)MapMemory (\n                                0, (UINT32) InitialStackMemorySize,\n                                PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE\n                                );\n  if (InitialStackMemory == 0) {\n    printf (\"ERROR : Can not open SecStack Exiting\\n\");\n    exit (1);\n  }\n\n  printf (\"  OS Emulator passing in %u KB of temp RAM at 0x%08lx to SEC\\n\",\n    (unsigned int)(InitialStackMemorySize / 1024),\n    (unsigned long)InitialStackMemory\n    );\n\n  for (StackPointer = (UINTN*) (UINTN) InitialStackMemory;\n     StackPointer < (UINTN*)(UINTN)((UINTN) InitialStackMemory + (UINT64) InitialStackMemorySize);\n     StackPointer ++) {\n    *StackPointer = 0x5AA55AA5;\n  }\n\n  //\n  // Open All the firmware volumes and remember the info in the gFdInfo global\n  //\n  FileName = (CHAR8 *) AllocatePool (StrLen (FirmwareVolumesStr) + 1);\n  if (FileName == NULL) {\n    printf (\"ERROR : Can not allocate memory for firmware volume string\\n\");\n    exit (1);\n  }\n\n  Index2 = 0;\n  for (Done = FALSE, Index = 0, PeiIndex = 0, SecFile = NULL;\n       FirmwareVolumesStr[Index2] != 0;\n       Index++) {\n    for (Index1 = 0; (FirmwareVolumesStr[Index2] != '!') && (FirmwareVolumesStr[Index2] != 0); Index2++) {\n      FileName[Index1++] = FirmwareVolumesStr[Index2];\n    }\n    if (FirmwareVolumesStr[Index2] == '!') {\n      Index2++;\n    }\n    FileName[Index1]  = '\\0';\n\n    if (Index == 0) {\n      // Map FV Recovery Read Only and other areas Read/Write\n      Status = MapFd0 (\n                FileName,\n                &gFdInfo[0].Address,\n                &gFdInfo[0].Size\n                );\n    } else {\n      //\n      // Open the FD and remember where it got mapped into our processes address space\n      // Maps Read Only\n      //\n      Status = MapFile (\n                FileName,\n                &gFdInfo[Index].Address,\n                &gFdInfo[Index].Size\n                );\n    }\n    if (EFI_ERROR (Status)) {\n      printf (\"ERROR : Can not open Firmware Device File %s (%x).  Exiting.\\n\", FileName, (unsigned int)Status);\n      exit (1);\n    }\n\n    printf (\"  FD loaded from %s at 0x%08lx\",FileName, (unsigned long)gFdInfo[Index].Address);\n\n    if (SecFile == NULL) {\n      //\n      // Assume the beginning of the FD is an FV and look for the SEC Core.\n      // Load the first one we find.\n      //\n      FileHandle = NULL;\n      Status = PeiServicesFfsFindNextFile (\n                  EFI_FV_FILETYPE_SECURITY_CORE,\n                  (EFI_PEI_FV_HANDLE)(UINTN)gFdInfo[Index].Address,\n                  &FileHandle\n                  );\n      if (!EFI_ERROR (Status)) {\n        Status = PeiServicesFfsFindSectionData (EFI_SECTION_PE32, FileHandle, &SecFile);\n        if (!EFI_ERROR (Status)) {\n          PeiIndex = Index;\n          printf (\" contains SEC Core\");\n        }\n      }\n    }\n\n    printf (\"\\n\");\n  }\n\n  if (SecFile == NULL) {\n    printf (\"ERROR : SEC not found!\\n\");\n    exit (1);\n  }\n\n  //\n  // Calculate memory regions and store the information in the gSystemMemory\n  //  global for later use. The autosizing code will use this data to\n  //  map this memory into the SEC process memory space.\n  //\n  Index1 = 0;\n  Index = 0;\n  while (1) {\n    UINTN val = 0;\n    //\n    // Save the size of the memory.\n    //\n    while (MemorySizeStr[Index1] >= '0' && MemorySizeStr[Index1] <= '9') {\n      val = val * 10 + MemorySizeStr[Index1] - '0';\n      Index1++;\n    }\n    gSystemMemory[Index++].Size = val * 0x100000;\n    if (MemorySizeStr[Index1] == 0) {\n      break;\n    }\n    Index1++;\n  }\n\n  printf (\"\\n\");\n\n  //\n  // Hand off to SEC\n  //\n  SecLoadFromCore ((UINTN) InitialStackMemory, (UINTN) InitialStackMemorySize, (UINTN) gFdInfo[0].Address, SecFile);\n\n  //\n  // If we get here, then the SEC Core returned. This is an error as SEC should\n  //  always hand off to PEI Core and then on to DXE Core.\n  //\n  printf (\"ERROR : SEC returned\\n\");\n  exit (1);\n}\n\n\nEFI_PHYSICAL_ADDRESS *\nMapMemory (\n  IN INTN   fd,\n  IN UINT64 length,\n  IN INTN   prot,\n  IN INTN   flags\n  )\n{\n  STATIC UINTN base  = 0x40000000;\n  CONST UINTN  align = (1 << 24);\n  VOID         *res  = NULL;\n  BOOLEAN      isAligned = 0;\n\n  //\n  // Try to get an aligned block somewhere in the address space of this\n  // process.\n  //\n  while((!isAligned) && (base != 0)) {\n    res = mmap ((void *)base, length, prot, flags, fd, 0);\n    if (res == MAP_FAILED) {\n      return NULL;\n    }\n    if ((((UINTN)res) & ~(align-1)) == (UINTN)res) {\n      isAligned=1;\n    } else {\n      munmap(res, length);\n      base += align;\n    }\n  }\n  return res;\n}\n\n\n/*++\n\nRoutine Description:\n  Opens and memory maps a file using Unix services. If BaseAddress is non zero\n  the process will try and allocate the memory starting at BaseAddress.\n\nArguments:\n  FileName            - The name of the file to open and map\n  MapSize             - The amount of the file to map in bytes\n  CreationDisposition - The flags to pass to CreateFile().  Use to create new files for\n                        memory emulation, and exiting files for firmware volume emulation\n  BaseAddress         - The base address of the mapped file in the user address space.\n                         If passed in as NULL the a new memory region is used.\n                         If passed in as non NULL the request memory region is used for\n                          the mapping of the file into the process space.\n  Length              - The size of the mapped region in bytes\n\nReturns:\n  EFI_SUCCESS      - The file was opened and mapped.\n  EFI_NOT_FOUND    - FileName was not found in the current directory\n  EFI_DEVICE_ERROR - An error occured attempting to map the opened file\n\n**/\nEFI_STATUS\nMapFile (\n  IN  CHAR8                     *FileName,\n  IN OUT  EFI_PHYSICAL_ADDRESS  *BaseAddress,\n  OUT UINT64                    *Length\n  )\n{\n  int     fd;\n  VOID    *res;\n  UINTN   FileSize;\n\n  fd = open (FileName, O_RDWR);\n  if (fd < 0) {\n    return EFI_NOT_FOUND;\n  }\n  FileSize = lseek (fd, 0, SEEK_END);\n\n\n  res = MapMemory (fd, FileSize, PROT_READ | PROT_EXEC, MAP_PRIVATE);\n\n  close (fd);\n\n  if (res == NULL) {\n    perror (\"MapFile() Failed\");\n    return EFI_DEVICE_ERROR;\n  }\n\n  *Length = (UINT64) FileSize;\n  *BaseAddress = (EFI_PHYSICAL_ADDRESS) (UINTN) res;\n\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS\nMapFd0 (\n  IN  CHAR8                     *FileName,\n  IN OUT  EFI_PHYSICAL_ADDRESS  *BaseAddress,\n  OUT UINT64                    *Length\n  )\n{\n  int     fd;\n  void    *res, *res2, *res3;\n  UINTN   FileSize;\n  UINTN   FvSize;\n  void    *EmuMagicPage;\n\n  fd = open (FileName, O_RDWR);\n  if (fd < 0) {\n    return EFI_NOT_FOUND;\n  }\n  FileSize = lseek (fd, 0, SEEK_END);\n\n  FvSize = FixedPcdGet64 (PcdEmuFlashFvRecoverySize);\n\n  // Assume start of FD is Recovery FV, and make it write protected\n  res = mmap (\n          (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase),\n          FvSize,\n          PROT_READ | PROT_EXEC,\n          MAP_PRIVATE,\n          fd,\n          0\n          );\n  if (res == MAP_FAILED) {\n    perror (\"MapFd0() Failed res =\");\n    close (fd);\n    return EFI_DEVICE_ERROR;\n  } else if (res != (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase)) {\n    // We could not load at the build address, so we need to allow writes\n    munmap (res, FvSize);\n    res = mmap (\n            (void *)(UINTN)FixedPcdGet64 (PcdEmuFlashFvRecoveryBase),\n            FvSize,\n            PROT_READ | PROT_WRITE | PROT_EXEC,\n            MAP_PRIVATE,\n            fd,\n            0\n            );\n    if (res == MAP_FAILED) {\n      perror (\"MapFd0() Failed res =\");\n      close (fd);\n      return EFI_DEVICE_ERROR;\n    }\n  }\n\n  // Map the rest of the FD as read/write\n  res2 = mmap (\n          (void *)(UINTN)(FixedPcdGet64 (PcdEmuFlashFvRecoveryBase) + FvSize),\n          FileSize - FvSize,\n          PROT_READ | PROT_WRITE | PROT_EXEC,\n          MAP_SHARED,\n          fd,\n          FvSize\n          );\n  close (fd);\n  if (res2 == MAP_FAILED) {\n    perror (\"MapFd0() Failed res2 =\");\n    return EFI_DEVICE_ERROR;\n  }\n\n  //\n  // If enabled use the magic page to communicate between modules\n  // This replaces the PI PeiServicesTable pointer mechanism that\n  // deos not work in the emulator. It also allows the removal of\n  // writable globals from SEC, PEI_CORE (libraries), PEIMs\n  //\n  EmuMagicPage = (void *)(UINTN)FixedPcdGet64 (PcdPeiServicesTablePage);\n  if (EmuMagicPage != NULL) {\n    res3 =  mmap (\n              (void *)EmuMagicPage,\n              4096,\n              PROT_READ | PROT_WRITE,\n              MAP_PRIVATE | MAP_ANONYMOUS,\n              0,\n              0\n              );\n    if (res3 != EmuMagicPage) {\n      printf (\"MapFd0(): Could not allocate PeiServicesTablePage @ %lx\\n\", (long unsigned int)EmuMagicPage);\n      return EFI_DEVICE_ERROR;\n    }\n  }\n\n  *Length = (UINT64) FileSize;\n  *BaseAddress = (EFI_PHYSICAL_ADDRESS) (UINTN) res;\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  This is the service to load the SEC Core from the Firmware Volume\n\nArguments:\n  LargestRegion           - Memory to use for SEC.\n  LargestRegionSize       - Size of Memory to use for PEI\n  BootFirmwareVolumeBase  - Start of the Boot FV\n  PeiCorePe32File         - SEC PE32\n\nReturns:\n  Success means control is transfered and thus we should never return\n\n**/\nVOID\nSecLoadFromCore (\n  IN  UINTN   LargestRegion,\n  IN  UINTN   LargestRegionSize,\n  IN  UINTN   BootFirmwareVolumeBase,\n  IN  VOID    *PeiCorePe32File\n  )\n{\n  EFI_STATUS                  Status;\n  EFI_PHYSICAL_ADDRESS        TopOfMemory;\n  VOID                        *TopOfStack;\n  EFI_PHYSICAL_ADDRESS        PeiCoreEntryPoint;\n  EFI_SEC_PEI_HAND_OFF        *SecCoreData;\n  UINTN                       PeiStackSize;\n\n  //\n  // Compute Top Of Memory for Stack and PEI Core Allocations\n  //\n  TopOfMemory  = LargestRegion + LargestRegionSize;\n  PeiStackSize = (UINTN)RShiftU64((UINT64)STACK_SIZE,1);\n\n  //\n  // |-----------| <---- TemporaryRamBase + TemporaryRamSize\n  // |   Heap    |\n  // |           |\n  // |-----------| <---- StackBase / PeiTemporaryMemoryBase\n  // |           |\n  // |  Stack    |\n  // |-----------| <---- TemporaryRamBase\n  //\n  TopOfStack  = (VOID *)(LargestRegion + PeiStackSize);\n  TopOfMemory = LargestRegion + PeiStackSize;\n\n  //\n  // Reservet space for storing PeiCore's parament in stack.\n  //\n  TopOfStack  = (VOID *)((UINTN)TopOfStack - sizeof (EFI_SEC_PEI_HAND_OFF) - CPU_STACK_ALIGNMENT);\n  TopOfStack  = ALIGN_POINTER (TopOfStack, CPU_STACK_ALIGNMENT);\n\n\n  //\n  // Bind this information into the SEC hand-off state\n  //\n  SecCoreData                         = (EFI_SEC_PEI_HAND_OFF*)(UINTN) TopOfStack;\n  SecCoreData->DataSize               = sizeof(EFI_SEC_PEI_HAND_OFF);\n  SecCoreData->BootFirmwareVolumeBase = (VOID*)BootFirmwareVolumeBase;\n  SecCoreData->BootFirmwareVolumeSize = PcdGet32 (PcdEmuFirmwareFdSize);\n  SecCoreData->TemporaryRamBase       = (VOID*)(UINTN)LargestRegion;\n  SecCoreData->TemporaryRamSize       = STACK_SIZE;\n  SecCoreData->StackBase              = SecCoreData->TemporaryRamBase;\n  SecCoreData->StackSize              = PeiStackSize;\n  SecCoreData->PeiTemporaryRamBase    = (VOID*) ((UINTN) SecCoreData->TemporaryRamBase + PeiStackSize);\n  SecCoreData->PeiTemporaryRamSize    = STACK_SIZE - PeiStackSize;\n\n  //\n  // Find the SEC Core Entry Point\n  //\n  Status = SecPeCoffGetEntryPoint (PeiCorePe32File, (VOID **)&PeiCoreEntryPoint);\n  if (EFI_ERROR (Status)) {\n    return ;\n  }\n\n  //\n  // Transfer control to the SEC Core\n  //\n  PeiSwitchStacks (\n    (SWITCH_STACK_ENTRY_POINT) (UINTN) PeiCoreEntryPoint,\n    SecCoreData,\n    (VOID *)gPpiList,\n    TopOfStack\n    );\n  //\n  // If we get here, then the SEC Core returned.  This is an error\n  //\n  return ;\n}\n\n\n/*++\n\nRoutine Description:\n  This service is called from Index == 0 until it returns EFI_UNSUPPORTED.\n  It allows discontinuous memory regions to be supported by the emulator.\n  It uses gSystemMemory[] and gSystemMemoryCount that were created by\n  parsing the host environment variable EFI_MEMORY_SIZE.\n  The size comes from the varaible and the address comes from the call to\n  UnixOpenFile.\n\nArguments:\n  Index      - Which memory region to use\n  MemoryBase - Return Base address of memory region\n  MemorySize - Return size in bytes of the memory region\n\nReturns:\n  EFI_SUCCESS - If memory region was mapped\n  EFI_UNSUPPORTED - If Index is not supported\n\n**/\nEFI_STATUS\nSecUnixPeiAutoScan (\n  IN  UINTN                 Index,\n  OUT EFI_PHYSICAL_ADDRESS  *MemoryBase,\n  OUT UINT64                *MemorySize\n  )\n{\n  void *res;\n\n  if (Index >= gSystemMemoryCount) {\n    return EFI_UNSUPPORTED;\n  }\n\n  *MemoryBase = 0;\n  res = MapMemory (\n          0, gSystemMemory[Index].Size,\n          PROT_READ | PROT_WRITE | PROT_EXEC,\n          MAP_PRIVATE | MAP_ANONYMOUS\n          );\n  if (res == MAP_FAILED) {\n    return EFI_DEVICE_ERROR;\n  }\n  *MemorySize = gSystemMemory[Index].Size;\n  *MemoryBase = (UINTN)res;\n  gSystemMemory[Index].Memory = *MemoryBase;\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n Check to see if an address range is in the EFI GCD memory map.\n\n This is all of GCD for system memory passed to DXE Core. FV\n mapping and other device mapped into system memory are not\n inlcuded in the check.\n\nArguments:\n  Index      - Which memory region to use\n  MemoryBase - Return Base address of memory region\n  MemorySize - Return size in bytes of the memory region\n\nReturns:\n  TRUE -  Address is in the EFI GCD memory map\n  FALSE - Address is NOT in memory map\n\n**/\nBOOLEAN\nEfiSystemMemoryRange (\n  IN  VOID *MemoryAddress\n  )\n{\n  UINTN                 Index;\n  EFI_PHYSICAL_ADDRESS  MemoryBase;\n\n  MemoryBase = (EFI_PHYSICAL_ADDRESS)(UINTN)MemoryAddress;\n  for (Index = 0; Index < gSystemMemoryCount; Index++) {\n    if ((MemoryBase >= gSystemMemory[Index].Memory) &&\n        (MemoryBase < (gSystemMemory[Index].Memory + gSystemMemory[Index].Size)) ) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\n\n/*++\n\nRoutine Description:\n  Since the SEC is the only Unix program in stack it must export\n  an interface to do POSIX calls.  gUnix is initialized in UnixThunk.c.\n\nArguments:\n  InterfaceSize - sizeof (EFI_WIN_NT_THUNK_PROTOCOL);\n  InterfaceBase - Address of the gUnix global\n\nReturns:\n  EFI_SUCCESS - Data returned\n\n**/\nVOID *\nSecEmuThunkAddress (\n  VOID\n  )\n{\n  return &gEmuThunkProtocol;\n}\n\n\n\nRETURN_STATUS\nEFIAPI\nSecPeCoffGetEntryPoint (\n  IN     VOID  *Pe32Data,\n  IN OUT VOID  **EntryPoint\n  )\n{\n  EFI_STATUS                    Status;\n  PE_COFF_LOADER_IMAGE_CONTEXT  ImageContext;\n\n  ZeroMem (&ImageContext, sizeof (ImageContext));\n  ImageContext.Handle     = Pe32Data;\n  ImageContext.ImageRead  = (PE_COFF_LOADER_READ_FILE) SecImageRead;\n\n  Status                  = PeCoffLoaderGetImageInfo (&ImageContext);\n  if (EFI_ERROR (Status)) {\n    return Status;\n  }\n\n  if (ImageContext.ImageAddress != (UINTN)Pe32Data) {\n    //\n    // Relocate image to match the address where it resides\n    //\n    ImageContext.ImageAddress = (UINTN)Pe32Data;\n    Status = PeCoffLoaderLoadImage (&ImageContext);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n\n    Status = PeCoffLoaderRelocateImage (&ImageContext);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n  } else {\n    //\n    // Or just return image entry point\n    //\n    ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer (Pe32Data);\n    Status = PeCoffLoaderGetEntryPoint (Pe32Data, EntryPoint);\n    if (EFI_ERROR (Status)) {\n      return Status;\n    }\n    ImageContext.EntryPoint = (UINTN)*EntryPoint;\n  }\n\n  // On Unix a dlopen is done that will change the entry point\n  SecPeCoffRelocateImageExtraAction (&ImageContext);\n  *EntryPoint = (VOID *)(UINTN)ImageContext.EntryPoint;\n\n  return Status;\n}\n\n\n\n/*++\n\nRoutine Description:\n  Return the FD Size and base address. Since the FD is loaded from a\n  file into host memory only the SEC will know it's address.\n\nArguments:\n  Index  - Which FD, starts at zero.\n  FdSize - Size of the FD in bytes\n  FdBase - Start address of the FD. Assume it points to an FV Header\n  FixUp  - Difference between actual FD address and build address\n\nReturns:\n  EFI_SUCCESS     - Return the Base address and size of the FV\n  EFI_UNSUPPORTED - Index does nto map to an FD in the system\n\n**/\nEFI_STATUS\nSecUnixFdAddress (\n  IN     UINTN                 Index,\n  IN OUT EFI_PHYSICAL_ADDRESS  *FdBase,\n  IN OUT UINT64                *FdSize,\n  IN OUT EFI_PHYSICAL_ADDRESS  *FixUp\n  )\n{\n  if (Index >= gFdInfoCount) {\n    return EFI_UNSUPPORTED;\n  }\n\n  *FdBase = gFdInfo[Index].Address;\n  *FdSize = gFdInfo[Index].Size;\n  *FixUp  = 0;\n\n  if (*FdBase == 0 && *FdSize == 0) {\n    return EFI_UNSUPPORTED;\n  }\n\n  if (Index == 0) {\n    //\n    // FD 0 has XIP code and well known PCD values\n    // If the memory buffer could not be allocated at the FD build address\n    // the Fixup is the difference.\n    //\n    *FixUp = *FdBase - PcdGet64 (PcdEmuFdBaseAddress);\n  }\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  Count the number of separators in String\n\nArguments:\n  String    - String to process\n  Separator - Item to count\n\nReturns:\n  Number of Separator in String\n\n**/\nUINTN\nCountSeparatorsInString (\n  IN  const CHAR16   *String,\n  IN  CHAR16         Separator\n  )\n{\n  UINTN Count;\n\n  for (Count = 0; *String != '\\0'; String++) {\n    if (*String == Separator) {\n      Count++;\n    }\n  }\n\n  return Count;\n}\n\n\nEFI_STATUS\nEFIAPI\nSecImageRead (\n  IN     VOID    *FileHandle,\n  IN     UINTN   FileOffset,\n  IN OUT UINTN   *ReadSize,\n  OUT    VOID    *Buffer\n  )\n/*++\n\nRoutine Description:\n  Support routine for the PE/COFF Loader that reads a buffer from a PE/COFF file\n\nArguments:\n  FileHandle - The handle to the PE/COFF file\n  FileOffset - The offset, in bytes, into the file to read\n  ReadSize   - The number of bytes to read from the file starting at FileOffset\n  Buffer     - A pointer to the buffer to read the data into.\n\nReturns:\n  EFI_SUCCESS - ReadSize bytes of data were read into Buffer from the PE/COFF file starting at FileOffset\n\n**/\n{\n  CHAR8 *Destination8;\n  CHAR8 *Source8;\n  UINTN Length;\n\n  Destination8  = Buffer;\n  Source8       = (CHAR8 *) ((UINTN) FileHandle + FileOffset);\n  Length        = *ReadSize;\n  while (Length--) {\n    *(Destination8++) = *(Source8++);\n  }\n\n  return EFI_SUCCESS;\n}\n\n\n/*++\n\nRoutine Description:\n  Store the ModHandle in an array indexed by the Pdb File name.\n  The ModHandle is needed to unload the image.\n\nArguments:\n  ImageContext - Input data returned from PE Laoder Library. Used to find the\n                 .PDB file name of the PE Image.\n  ModHandle    - Returned from LoadLibraryEx() and stored for call to\n                 FreeLibrary().\n\nReturns:\n  EFI_SUCCESS - ModHandle was stored.\n\n**/\nEFI_STATUS\nAddHandle (\n  IN  PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext,\n  IN  VOID                                 *ModHandle\n  )\n{\n  UINTN                       Index;\n  IMAGE_CONTEXT_TO_MOD_HANDLE *Array;\n  UINTN                       PreviousSize;\n\n\n  Array = mImageContextModHandleArray;\n  for (Index = 0; Index < mImageContextModHandleArraySize; Index++, Array++) {\n    if (Array->ImageContext == NULL) {\n      //\n      // Make a copy of the stirng and store the ModHandle\n      //\n      Array->ImageContext = ImageContext;\n      Array->ModHandle    = ModHandle;\n      return EFI_SUCCESS;\n    }\n  }\n\n  //\n  // No free space in mImageContextModHandleArray so grow it by\n  // IMAGE_CONTEXT_TO_MOD_HANDLE entires. realloc will\n  // copy the old values to the new locaiton. But it does\n  // not zero the new memory area.\n  //\n  PreviousSize = mImageContextModHandleArraySize * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE);\n  mImageContextModHandleArraySize += MAX_IMAGE_CONTEXT_TO_MOD_HANDLE_ARRAY_SIZE;\n\n  mImageContextModHandleArray = ReallocatePool (\n                                  (mImageContextModHandleArraySize - 1) * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE),\n                                  mImageContextModHandleArraySize * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE),\n                                  mImageContextModHandleArray\n                                  );\n  if (mImageContextModHandleArray == NULL) {\n    ASSERT (FALSE);\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  memset (mImageContextModHandleArray + PreviousSize, 0, MAX_IMAGE_CONTEXT_TO_MOD_HANDLE_ARRAY_SIZE * sizeof (IMAGE_CONTEXT_TO_MOD_HANDLE));\n\n  return AddHandle (ImageContext, ModHandle);\n}\n\n\n/*++\n\nRoutine Description:\n  Return the ModHandle and delete the entry in the array.\n\nArguments:\n  ImageContext - Input data returned from PE Laoder Library. Used to find the\n                 .PDB file name of the PE Image.\n\nReturns:\n  ModHandle - ModHandle assoicated with ImageContext is returned\n  NULL      - No ModHandle associated with ImageContext\n\n**/\nVOID *\nRemoveHandle (\n  IN  PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  UINTN                        Index;\n  IMAGE_CONTEXT_TO_MOD_HANDLE  *Array;\n\n  if (ImageContext->PdbPointer == NULL) {\n    //\n    // If no PDB pointer there is no ModHandle so return NULL\n    //\n    return NULL;\n  }\n\n  Array = mImageContextModHandleArray;\n  for (Index = 0; Index < mImageContextModHandleArraySize; Index++, Array++) {\n    if (Array->ImageContext == ImageContext) {\n      //\n      // If you find a match return it and delete the entry\n      //\n      Array->ImageContext = NULL;\n      return Array->ModHandle;\n    }\n  }\n\n  return NULL;\n}\n\n\n\nBOOLEAN\nIsPdbFile (\n  IN  CHAR8   *PdbFileName\n  )\n{\n  UINTN Len;\n\n  if (PdbFileName == NULL) {\n    return FALSE;\n  }\n\n  Len = strlen (PdbFileName);\n  if ((Len < 5)|| (PdbFileName[Len - 4] != '.')) {\n    return FALSE;\n  }\n\n  if ((PdbFileName[Len - 3] == 'P' || PdbFileName[Len - 3] == 'p') &&\n      (PdbFileName[Len - 2] == 'D' || PdbFileName[Len - 2] == 'd') &&\n      (PdbFileName[Len - 1] == 'B' || PdbFileName[Len - 1] == 'b')) {\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n#define MAX_SPRINT_BUFFER_SIZE 0x200\n\nvoid\nPrintLoadAddress (\n  IN PE_COFF_LOADER_IMAGE_CONTEXT          *ImageContext\n  )\n{\n  if (ImageContext->PdbPointer == NULL) {\n    fprintf (stderr,\n      \"0x%08lx Loading NO DEBUG with entry point 0x%08lx\\n\",\n      (unsigned long)(ImageContext->ImageAddress),\n      (unsigned long)ImageContext->EntryPoint\n      );\n  } else {\n    fprintf (stderr,\n      \"0x%08lx Loading %s with entry point 0x%08lx\\n\",\n      (unsigned long)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders),\n      ImageContext->PdbPointer,\n      (unsigned long)ImageContext->EntryPoint\n      );\n  }\n  // Keep output synced up\n  fflush (stderr);\n}\n\n\n/**\n  Loads the image using dlopen so symbols will be automatically\n  loaded by gdb.\n\n  @param  ImageContext  The PE/COFF image context\n\n  @retval TRUE - The image was successfully loaded\n  @retval FALSE - The image was successfully loaded\n\n**/\nBOOLEAN\nDlLoadImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n\n#ifdef __APPLE__\n\n  return FALSE;\n\n#else\n\n  void        *Handle = NULL;\n  void        *Entry = NULL;\n\n  if (ImageContext->PdbPointer == NULL) {\n    return FALSE;\n  }\n\n  if (!IsPdbFile (ImageContext->PdbPointer)) {\n    return FALSE;\n  }\n\n  fprintf (\n     stderr,\n     \"Loading %s 0x%08lx - entry point 0x%08lx\\n\",\n     ImageContext->PdbPointer,\n     (unsigned long)ImageContext->ImageAddress,\n     (unsigned long)ImageContext->EntryPoint\n     );\n\n  Handle = dlopen (ImageContext->PdbPointer, RTLD_NOW);\n  if (Handle != NULL) {\n    Entry = dlsym (Handle, \"_ModuleEntryPoint\");\n    AddHandle (ImageContext, Handle);\n  } else {\n    printf(\"%s\\n\", dlerror());\n  }\n\n  if (Entry != NULL) {\n    ImageContext->EntryPoint = (UINTN)Entry;\n    printf (\"Change %s Entrypoint to :0x%08lx\\n\", ImageContext->PdbPointer, (unsigned long)Entry);\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n\n#endif\n}\n\n\nVOID\nSecGdbScriptBreak (\n  char                *FileName,\n  int                 FileNameLength,\n  long unsigned int   LoadAddress,\n  int                 AddSymbolFlag\n  )\n{\n  return;\n}\n\n\n/**\n  Adds the image to a gdb script so it's symbols can be loaded.\n  The AddFirmwareSymbolFile helper macro is used.\n\n  @param  ImageContext  The PE/COFF image context\n\n**/\nVOID\nGdbScriptAddImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n\n  PrintLoadAddress (ImageContext);\n\n  if (ImageContext->PdbPointer != NULL && !IsPdbFile (ImageContext->PdbPointer)) {\n    FILE  *GdbTempFile;\n    if (FeaturePcdGet (PcdEmulatorLazyLoadSymbols)) {\n      GdbTempFile = fopen (gGdbWorkingFileName, \"a\");\n      if (GdbTempFile != NULL) {\n        long unsigned int SymbolsAddr = (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders);\n        mScriptSymbolChangesCount++;\n        fprintf (\n          GdbTempFile,\n          \"AddFirmwareSymbolFile 0x%x %s 0x%08lx\\n\",\n          mScriptSymbolChangesCount,\n          ImageContext->PdbPointer,\n          SymbolsAddr\n          );\n        fclose (GdbTempFile);\n        // This is for the lldb breakpoint only\n        SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders), 1);\n      } else {\n        ASSERT (FALSE);\n      }\n    } else {\n      GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n      if (GdbTempFile != NULL) {\n        fprintf (\n          GdbTempFile,\n          \"add-symbol-file %s 0x%08lx\\n\",\n          ImageContext->PdbPointer,\n          (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders)\n          );\n        fclose (GdbTempFile);\n\n        //\n        // Target for gdb breakpoint in a script that uses gGdbWorkingFileName to set a breakpoint.\n        // Hey what can you say scripting in gdb is not that great....\n        // Also used for the lldb breakpoint script. The lldb breakpoint script does\n        // not use the file, it uses the arguments.\n        //\n        SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, (long unsigned int)(ImageContext->ImageAddress + ImageContext->SizeOfHeaders), 1);\n      } else {\n        ASSERT (FALSE);\n      }\n    }\n  }\n}\n\n\nVOID\nEFIAPI\nSecPeCoffRelocateImageExtraAction (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  if (!DlLoadImage (ImageContext)) {\n    GdbScriptAddImage (ImageContext);\n  }\n}\n\n\n/**\n  Adds the image to a gdb script so it's symbols can be unloaded.\n  The RemoveFirmwareSymbolFile helper macro is used.\n\n  @param  ImageContext  The PE/COFF image context\n\n**/\nVOID\nGdbScriptRemoveImage (\n  IN OUT PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  FILE  *GdbTempFile;\n\n  //\n  // Need to skip .PDB files created from VC++\n  //\n  if (IsPdbFile (ImageContext->PdbPointer)) {\n    return;\n  }\n\n  if (FeaturePcdGet (PcdEmulatorLazyLoadSymbols)) {\n    //\n    // Write the file we need for the gdb script\n    //\n    GdbTempFile = fopen (gGdbWorkingFileName, \"a\");\n    if (GdbTempFile != NULL) {\n      mScriptSymbolChangesCount++;\n      fprintf (\n        GdbTempFile,\n        \"RemoveFirmwareSymbolFile 0x%x %s\\n\",\n        mScriptSymbolChangesCount,\n        ImageContext->PdbPointer\n        );\n      fclose (GdbTempFile);\n      SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, 0, 0);\n    } else {\n      ASSERT (FALSE);\n    }\n  } else {\n    GdbTempFile = fopen (gGdbWorkingFileName, \"w\");\n    if (GdbTempFile != NULL) {\n      fprintf (GdbTempFile, \"remove-symbol-file %s\\n\", ImageContext->PdbPointer);\n      fclose (GdbTempFile);\n\n      //\n      // Target for gdb breakpoint in a script that uses gGdbWorkingFileName to set a breakpoint.\n      // Hey what can you say scripting in gdb is not that great....\n      //\n      SecGdbScriptBreak (ImageContext->PdbPointer, strlen (ImageContext->PdbPointer) + 1, 0, 0);\n    } else {\n      ASSERT (FALSE);\n    }\n  }\n}\n\n\nVOID\nEFIAPI\nSecPeCoffUnloadImageExtraAction (\n  IN PE_COFF_LOADER_IMAGE_CONTEXT         *ImageContext\n  )\n{\n  VOID *Handle;\n\n  //\n  // Check to see if the image symbols were loaded with gdb script, or dlopen\n  //\n  Handle = RemoveHandle (ImageContext);\n  if (Handle != NULL) {\n#ifndef __APPLE__\n    dlclose (Handle);\n#endif\n    return;\n  }\n\n  GdbScriptRemoveImage (ImageContext);\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/StdLibPrivateInternalFiles/Include/namespace.h": "/*  $NetBSD: namespace.h,v 1.125 2006/11/08 20:37:14 drochner Exp $ */\n\n/*-\n * Copyright (c) 1997-2004 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *        This product includes software developed by the NetBSD\n *        Foundation, Inc. and its contributors.\n * 4. Neither the name of The NetBSD Foundation nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _NAMESPACE_H_\n#define _NAMESPACE_H_\n\n#include  <sys/EfiCdefs.h>\n\n#ifndef __lint__\n#define ftello        _ftello\n#define getcontext    _getcontext\n#define getenv_r      _getenv_r\n#define strtof        _strtof\n#define strtoimax     _strtoimax\n#define strtold       _strtold\n#define strtoll       _strtoll\n#define strtoull      _strtoull\n#define strtoumax     _strtoumax\n#define vfscanf       __svfscanf\n\n#if 0\n#define brk           _brk\n#define catclose      _catclose\n#define catgets       _catgets\n#define catopen       _catopen\n#define daylight      _daylight\n#define err           _err\n#define errx          _errx\n#ifdef _REENTRANT\n#define fileno        _fileno\n#endif /* _REENTRANT */\n#define fork          _fork\n#define fseeko        _fseeko\n#define inet_aton     _inet_aton\n#define inet_pton     _inet_pton\n#define pipe          _pipe\n#define sbrk          _sbrk\n#define strerror_r    _strerror_r\n#define strlcat       _strlcat\n#define strlcpy       _strlcpy\n#define sys_errlist   _sys_errlist\n#define sys_nerr      _sys_nerr\n#define sys_siglist   _sys_siglist\n#define sys_nsig      _sys_nsig\n#define sysconf       __sysconf\n#define verr          _verr\n#define verrx         _verrx\n#define vwarn         _vwarn\n#define vwarnx        _vwarnx\n#define warn          _warn\n#define warnx         _warnx\n\n//#ifdef __weak_alias\n#define MD2Data       _MD2Data\n#define MD2End        _MD2End\n#define MD2FileChunk  _MD2FileChunk\n#define MD2File       _MD2File\n#define MD2Final      _MD2Final\n#define MD2Init       _MD2Init\n#define MD2Transform  _MD2Transform\n#define MD2Update     _MD2Update\n#define MD4Data       _MD4Data\n#define MD4End        _MD4End\n#define MD4FileChunk  _MD4FileChunk\n#define MD4File       _MD4File\n#define MD4Final      _MD4Final\n#define MD4Init       _MD4Init\n#define MD4Transform  _MD4Transform\n#define MD4Update     _MD4Update\n#define MD5Data       _MD5Data\n#define MD5End        _MD5End\n#define MD5FileChunk  _MD5FileChunk\n#define MD5File       _MD5File\n#define MD5Final      _MD5Final\n#define MD5Init       _MD5Init\n#define MD5Transform  _MD5Transform\n#define MD5Update     _MD5Update\n#define RMD160Data    _RMD160Data\n#define RMD160End     _RMD160End\n#define RMD160FileChunk   _RMD160FileChunk\n#define RMD160File    _RMD160File\n#define RMD160Final   _RMD160Final\n#define RMD160Init    _RMD160Init\n#define RMD160Transform   _RMD160Transform\n#define RMD160Update  _RMD160Update\n#define SHA1Data      _SHA1Data\n#define SHA1End       _SHA1End\n#define SHA1FileChunk   _SHA1FileChunk\n#define SHA1File      _SHA1File\n#define SHA1Final     _SHA1Final\n#define SHA1Init      _SHA1Init\n#define SHA1Transform   _SHA1Transform\n#define SHA1Update    _SHA1Update\n#define SHA256_Data   _SHA256_Data\n#define SHA256_End    _SHA256_End\n#define SHA256_FileChunk  _SHA256_FileChunk\n#define SHA256_File   _SHA256_File\n#define SHA256_Final  _SHA256_Final\n#define SHA256_Init   _SHA256_Init\n#define SHA256_Transform  _SHA256_Transform\n#define SHA256_Update _SHA256_Update\n#define SHA384_Data   _SHA384_Data\n#define SHA384_End    _SHA384_End\n#define SHA384_FileChunk  _SHA384_FileChunk\n#define SHA384_File   _SHA384_File\n#define SHA384_Final  _SHA384_Final\n#define SHA384_Init   _SHA384_Init\n#define SHA384_Transform  _SHA384_Transform\n#define SHA384_Update _SHA384_Update\n#define SHA512_Data   _SHA512_Data\n#define SHA512_End    _SHA512_End\n#define SHA512_FileChunk  _SHA512_FileChunk\n#define SHA512_File   _SHA512_File\n#define SHA512_Final  _SHA512_Final\n#define SHA512_Init   _SHA512_Init\n#define SHA512_Transform  _SHA512_Transform\n#define SHA512_Update _SHA512_Update\n#define a64l          _a64l\n#define adjtime       _adjtime\n#define alarm         _alarm\n#define alphasort     _alphasort\n#define arc4random    _arc4random\n#define asctime_r     _asctime_r\n#define asprintf      _asprintf\n#define atoll       _atoll\n#define authnone_create         _authnone_create\n#define authunix_create         _authunix_create\n#define authunix_create_default _authunix_create_default\n#define basename                _basename\n#define bindresvport            _bindresvport\n#define bindresvport_sa         _bindresvport_sa\n#define bm_comp                 _bm_comp\n#define bm_exec       _bm_exec\n#define bm_free       _bm_free\n#define callrpc       _callrpc\n#define cfgetispeed   _cfgetispeed\n#define cfgetospeed   _cfgetospeed\n#define cfmakeraw     _cfmakeraw\n#define cfsetispeed   _cfsetispeed\n#define cfsetospeed   _cfsetospeed\n#define cfsetspeed    _cfsetspeed\n#define cgetcap       _cgetcap\n#define cgetclose     _cgetclose\n#define cgetent       _cgetent\n#define cgetfirst     _cgetfirst\n#define cgetmatch     _cgetmatch\n#define cgetnext      _cgetnext\n#define cgetnum       _cgetnum\n#define cgetset       _cgetset\n#define cgetstr       _cgetstr\n#define cgetustr      _cgetustr\n#define clnt_broadcast      _clnt_broadcast\n#define clnt_create         _clnt_create\n#define clnt_create_vers    _clnt_create_vers\n#define clnt_dg_create      _clnt_dg_create\n#define clnt_pcreateerror   _clnt_pcreateerror\n#define clnt_perrno         _clnt_perrno\n#define clnt_perror         _clnt_perror\n#define clnt_raw_create     _clnt_raw_create\n#define clnt_tli_create     _clnt_tli_create\n#define clnt_tp_create      _clnt_tp_create\n#define clnt_spcreateerror  _clnt_spcreateerror\n#define clnt_sperrno        _clnt_sperrno\n#define clnt_sperror        _clnt_sperror\n#define clnt_vc_create      _clnt_vc_create\n#define clntraw_create      _clntraw_create\n#define clnttcp_create      _clnttcp_create\n#define clntudp_bufcreate   _clntudp_bufcreate\n#define clntudp_create      _clntudp_create\n#define clock_settime       _clock_settime\n#define closedir      _closedir\n#define closelog      _closelog\n#define closelog_r    _closelog_r\n#define confstr       _confstr\n#define ctermid       _ctermid\n#define ctime_r       _ctime_r\n#define daemon        _daemon\n#define dbopen        _dbopen\n#define devname       _devname\n#define dirname       _dirname\n#define dn_expand     _dn_expand\n#define drand48       _drand48\n#define endfsent      _endfsent\n#define endgrent      _endgrent\n#define endhostent    _endhostent\n#define endnetconfig  _endnetconfig\n#define endnetent     _endnetent\n#define endnetgrent   _endnetgrent\n#define endnetpath    _endnetpath\n#define endprotoent   _endprotoent\n#define endprotoent_r   _endprotoent_r\n#define endpwent      _endpwent\n#define endrpcent     _endrpcent\n#define endservent    _endservent\n#define endservent_r  _endservent_r\n#define endttyent     _endttyent\n#define endusershell  _endusershell\n#define erand48       _erand48\n#define ether_aton    _ether_aton\n#define ether_hostton _ether_hostton\n#define ether_line    _ether_line\n#define ether_ntoa    _ether_ntoa\n#define ether_ntohost _ether_ntohost\n#define execl         _execl\n#define execle        _execle\n#define execlp        _execlp\n#define execv         _execv\n#define execvp        _execvp\n#define fdopen        _fdopen\n#define fgetln        _fgetln\n#define fgetwln       _fgetwln\n#define fhstatvfs     _fhstatvfs\n#define flockfile     _flockfile\n#define ftrylockfile  _ftrylockfile\n#define funlockfile   _funlockfile\n#define fnmatch       _fnmatch\n#define fpgetmask     _fpgetmask\n#define fpgetround    _fpgetround\n#define fpgetsticky   _fpgetsticky\n#define fpsetmask     _fpsetmask\n#define fpsetround    _fpsetround\n#define fpsetsticky   _fpsetsticky\n#define freenetconfigent  _freenetconfigent\n#define freeaddrinfo  _freeaddrinfo\n#define freeifaddrs   _freeifaddrs\n#define fstatvfs      _fstatvfs\n#define ftok          _ftok\n#define ftruncate     _ftruncate\n#define fts_children  _fts_children\n#define fts_close     _fts_close\n#define fts_open      _fts_open\n#define fts_read      _fts_read\n#define fts_set       _fts_set\n#define gai_strerror  _gai_strerror\n#define get_myaddress _get_myaddress\n#define getaddrinfo   _getaddrinfo\n#define getbsize      _getbsize\n#define getcwd        _getcwd\n#define getdevmajor   _getdevmajor\n#define getdiskbyname _getdiskbyname\n#define getdomainname _getdomainname\n#define getfsent      _getfsent\n#define getfsfile     _getfsfile\n#define getfsspec     _getfsspec\n#define getgrent      _getgrent\n#define getgrent_r    _getgrent_r\n#define getgrgid      _getgrgid\n#define getgrgid_r    _getgrgid_r\n#define getgrnam      _getgrnam\n#define getgrnam_r    _getgrnam_r\n#define getgrouplist  _getgrouplist\n#define getgroupmembership  _getgroupmembership\n#define gethostbyaddr _gethostbyaddr\n#define gethostbyname _gethostbyname\n#define gethostent    _gethostent\n#define gethostname   _gethostname\n#define getifaddrs    _getifaddrs\n#define getloadavg    _getloadavg\n#define getlogin      _getlogin\n#define getmntinfo    _getmntinfo\n#define getmode       _getmode\n#define getnameinfo   _getnameinfo\n#define getnetbyaddr  _getnetbyaddr\n#define getnetbyname  _getnetbyname\n#define getnetconfig  _getnetconfig\n#define getnetconfigent   _getnetconfigent\n#define getnetent     _getnetent\n#define getnetgrent   _getnetgrent\n#define getnetpath    _getnetpath\n#define getopt        _getopt\n#define getopt_long   _getopt_long\n#define getpagesize   _getpagesize\n#define getpass       _getpass\n#define getprogname   _getprogname\n#define getprotobyname      _getprotobyname\n#define getprotobyname_r    _getprotobyname_r\n#define getprotobynumber    _getprotobynumber\n#define getprotobynumber_r  _getprotobynumber_r\n#define getprotoent         _getprotoent\n#define getprotoent_r       _getprotoent_r\n#define getpwent            _getpwent\n#define getpwent_r          _getpwent_r\n#define getpwnam            _getpwnam\n#define getpwnam_r          _getpwnam_r\n#define getpwuid            _getpwuid\n#define getpwuid_r          _getpwuid_r\n#define getrpcbyname        _getrpcbyname\n#define getrpcbyname_r      _getrpcbyname_r\n#define getrpcbynumber      _getrpcbynumber\n#define getrpcbynumber_r    _getrpcbynumber_r\n#define getrpcent           _getrpcent\n#define getrpcent_r         _getrpcent_r\n#define getrpcport          _getrpcport\n#define getservbyname       _getservbyname\n#define getservbyname_r     _getservbyname_r\n#define getservbyport       _getservbyport\n#define getservbyport_r     _getservbyport_r\n#define getservent          _getservent\n#define getservent_r        _getservent_r\n#define getsubopt           _getsubopt\n#define getttyent           _getttyent\n#define getttynam           _getttynam\n#define getusershell        _getusershell\n#define glob                _glob\n#define globfree            _globfree\n#define gmtime_r            _gmtime_r\n#define group_from_gid    _group_from_gid\n#define heapsort    _heapsort\n#define herror      _herror\n#define hes_error   _hes_error\n#define hes_free    _hes_free\n#define hes_init    _hes_init\n#define hes_resolve   _hes_resolve\n#define hes_to_bind   _hes_to_bind\n#define hesiod_end    _hesiod_end\n#define hesiod_free_list  _hesiod_free_list\n#define hesiod_init   _hesiod_init\n#define hesiod_resolve    _hesiod_resolve\n#define hesiod_to_bind    _hesiod_to_bind\n#define iconv     _iconv\n#define iconv_open    _iconv_open\n#define iconv_close   _iconv_close\n#define if_freenameindex  _if_freenameindex\n#define if_indextoname    _if_indextoname\n#define if_nameindex    _if_nameindex\n#define if_nametoindex    _if_nametoindex\n#define in6addr_any   _in6addr_any\n#define in6addr_linklocal_allnodes  _in6addr_linklocal_allnodes\n#define in6addr_linklocal_allrouters  _in6addr_linklocal_allrouters\n#define in6addr_loopback  _in6addr_loopback\n#define in6addr_nodelocal_allnodes  _in6addr_nodelocal_allnodes\n#define inet6_option_alloc  _inet6_option_alloc\n#define inet6_option_append _inet6_option_append\n#define inet6_option_find _inet6_option_find\n#define inet6_option_init _inet6_option_init\n#define inet6_option_next _inet6_option_next\n#define inet6_option_space  _inet6_option_space\n#define inet6_opt_init    _inet6_opt_init\n#define inet6_opt_append  _inet6_opt_append\n#define inet6_opt_finish  _inet6_opt_finish\n#define inet6_opt_set_val _inet6_opt_set_val\n#define inet6_opt_next    _inet6_opt_next\n#define inet6_opt_find    _inet6_opt_find\n#define inet6_opt_get_val _inet6_opt_get_val\n#define inet6_rthdr_add   _inet6_rthdr_add\n#define inet6_rthdr_getaddr _inet6_rthdr_getaddr\n#define inet6_rthdr_getflags  _inet6_rthdr_getflags\n#define inet6_rthdr_init  _inet6_rthdr_init\n#define inet6_rthdr_lasthop _inet6_rthdr_lasthop\n#define inet6_rthdr_segments  _inet6_rthdr_segments\n#define inet6_rthdr_space _inet6_rthdr_space\n#define inet6_rth_space   _inet6_rth_space\n#define inet6_rth_init    _inet6_rth_init\n#define inet6_rth_add   _inet6_rth_add\n#define inet6_rth_reverse _inet6_rth_reverse\n#define inet6_rth_segments  _inet6_rth_segments\n#define inet6_rth_getaddr _inet6_rth_getaddr\n#define inet_cidr_ntop    _inet_cidr_ntop\n#define inet_cidr_pton    _inet_cidr_pton\n#define inet_lnaof    _inet_lnaof\n#define inet_makeaddr   _inet_makeaddr\n#define inet_net_ntop   _inet_net_ntop\n#define inet_net_pton   _inet_net_pton\n#define inet_neta   _inet_neta\n#define inet_netof    _inet_netof\n#define inet_network    _inet_network\n#define inet_nsap_addr    _inet_nsap_addr\n#define inet_nsap_ntoa    _inet_nsap_ntoa\n#define inet_ntoa   _inet_ntoa\n#define inet_ntop   _inet_ntop\n#define initgroups    _initgroups\n#define initstate   _initstate\n#define innetgr     _innetgr\n#define isatty      _isatty\n#define jrand48     _jrand48\n#define kill      _kill\n#define l64a      _l64a\n#define l64a_r      _l64a_r\n#define lcong48     _lcong48\n#define llabs     _llabs\n#define lldiv     _lldiv\n#define localtime_r   _localtime_r\n#define lockf     _lockf\n#define lrand48     _lrand48\n#define lseek     _lseek\n#define mergesort   _mergesort\n#define mkstemp     _mkstemp\n#define mmap      _mmap\n#define mpool_close   _mpool_close\n#define mpool_filter    _mpool_filter\n#define mpool_get   _mpool_get\n#define mpool_new   _mpool_new\n#define mpool_open    _mpool_open\n#define mpool_put   _mpool_put\n#define mpool_sync    _mpool_sync\n#define mrand48     _mrand48\n#define nc_perror   _nc_perror\n#define nc_sperror    _nc_sperror\n#define nice      _nice\n#define nrand48     _nrand48\n#define ntp_adjtime   _ntp_adjtime\n#define nsdispatch    _nsdispatch\n#define offtime     _offtime\n#define opendir     _opendir\n#define openlog     _openlog\n#define openlog_r   _openlog_r\n#define pause     _pause\n#define pclose      _pclose\n#define pmap_getmaps    _pmap_getmaps\n#define pmap_getport    _pmap_getport\n#define pmap_rmtcall    _pmap_rmtcall\n#define pmap_set    _pmap_set\n#define pmap_unset    _pmap_unset\n#define popen     _popen\n#define posix2time    _posix2time\n#define pread     _pread\n#define psignal     _psignal\n#define pthread_atfork    _pthread_atfork\n#define putenv      _putenv\n#define pwcache_groupdb   _pwcache_groupdb\n#define pwcache_userdb    _pwcache_userdb\n#define pwrite      _pwrite\n#define qabs      _qabs\n#define qdiv      _qdiv\n#define radixsort   _radixsort\n#define random      _random\n#define randomid    _randomid\n#define randomid_new    _randomid_new\n#define randomid_delete   _randomid_delete\n#define readdir     _readdir\n#define readdir_r   _readdir_r\n#define realpath    _realpath\n#define regcomp     _regcomp\n#define regerror    _regerror\n#define regexec     _regexec\n#define regfree     _regfree\n#define registerrpc   _registerrpc\n#define res_init    _res_init\n#define res_mkquery   _res_mkquery\n#define res_query   _res_query\n#define res_search    _res_search\n#define rewinddir   _rewinddir\n#define rpc_broadcast   _rpc_broadcast\n#define rpc_broadcast_exp _rpc_broadcast_exp\n#define rpc_call    _rpc_call\n#define rpc_control   _rpc_control\n#define rpc_reg     _rpc_reg\n#define rpcb_getmaps    _rpcb_getmaps\n#define rpcb_gettime    _rpcb_gettime\n#define rpcb_rmtcall    _rpcb_rmtcall\n#define rpcb_set    _rpcb_set\n#define rpcb_taddr2uaddr  _rpcb_taddr2uaddr\n#define rpcb_uaddr2taddr  _rpcb_uaddr2taddr\n#define rpcb_unset    _rpcb_unset\n#define scandir     _scandir\n#define seed48      _seed48\n#define seekdir     _seekdir\n#define send      _send\n#define setdomainname   _setdomainname\n#define setenv      _setenv\n#define setfsent    _setfsent\n#define setgrent    _setgrent\n#define setgroupent   _setgroupent\n#define sethostent    _sethostent\n#define sethostname   _sethostname\n#define setlogin    _setlogin\n#define setlogmask    _setlogmask\n#define setlogmask_r    _setlogmask_r\n#define setmode     _setmode\n#define setnetconfig    _setnetconfig\n#define setnetent   _setnetent\n#define setnetgrent   _setnetgrent\n#define setpassent    _setpassent\n#define setnetpath    _setnetpath\n#define setproctitle    _setproctitle\n#define setprotoent   _setprotoent\n#define setprotoent_r   _setprotoent_r\n#define setpwent    _setpwent\n#define setrpcent   _setrpcent\n#define setservent    _setservent\n#define setservent_r    _setservent_r\n#define setstate    _setstate\n#define setttyent   _setttyent\n#define setttyentpath   _setttyentpath\n#define settimeofday    _settimeofday\n#define setusershell    _setusershell\n#define shm_open    _shm_open\n#define shm_unlink    _shm_unlink\n#define shquote     _shquote\n#define siginterrupt    _siginterrupt\n#define signal      _signal\n#define sl_add      _sl_add\n#define sl_create   _sl_create\n#define sl_find     _sl_find\n#define sl_free     _sl_free\n#define sl_init     _sl_init\n#define sleep     _sleep\n#define snprintf    _snprintf\n#define snprintf_ss   _snprintf_ss\n#define sradixsort    _sradixsort\n#define srand48     _srand48\n#define srandom     _srandom\n#define statvfs(a, b)   _statvfs(a, b)\n#define strcasecmp    _strcasecmp\n#define strdup      _strdup\n#define stresep     _stresep\n#define strndup     _strndup\n#define strncasecmp   _strncasecmp\n#define strptime    _strptime\n#define strsep      _strsep\n#define strsignal   _strsignal\n#define strsuftoll    _strsuftoll\n#define strsuftollx   _strsuftollx\n#define strsvis     _strsvis\n#define strsvisx    _strsvisx\n#define strtok_r    _strtok_r\n#define strunvis    _strunvis\n#define strvis      _strvis\n#define strvisx     _strvisx\n#define svc_auth_reg    _svc_auth_reg\n#define svc_create    _svc_create\n#define svc_dg_create   _svc_dg_create\n#define svc_exit    _svc_exit\n#define svc_fd_create   _svc_fd_create\n#define svc_getreq    _svc_getreq\n#define svc_getreqset   _svc_getreqset\n#define svc_getreq_common _svc_getreq_common\n#define svc_raw_create    _svc_raw_create\n#define svc_register    _svc_register\n#define svc_reg     _svc_reg\n#define svc_run     _svc_run\n#define svc_sendreply   _svc_sendreply\n#define svc_tli_create    _svc_tli_create\n#define svc_tp_create   _svc_tp_create\n#define svc_unregister    _svc_unregister\n#define svc_unreg   _svc_unreg\n#define svc_vc_create   _svc_vc_create\n#define svcerr_auth   _svcerr_auth\n#define svcerr_decode   _svcerr_decode\n#define svcerr_noproc   _svcerr_noproc\n#define svcerr_noprog   _svcerr_noprog\n#define svcerr_progvers   _svcerr_progvers\n#define svcerr_systemerr  _svcerr_systemerr\n#define svcerr_weakauth   _svcerr_weakauth\n#define svcfd_create    _svcfd_create\n#define svcraw_create   _svcraw_create\n#define svctcp_create   _svctcp_create\n#define svcudp_bufcreate  _svcudp_bufcreate\n#define svcudp_create   _svcudp_create\n#define svcudp_enablecache  _svcudp_enablecache\n#define svis      _svis\n#define sysarch     _sys_sysarch\n#define sysctl      _sysctl\n#define sysctlbyname    _sysctlbyname\n#define sysctlgetmibinfo  _sysctlgetmibinfo\n#define sysctlnametomib   _sysctlnametomib\n#define syslog      _syslog\n#define syslog_r    _syslog_r\n#define syslog_ss   _syslog_ss\n#define taddr2uaddr   _taddr2uaddr\n#define tcdrain     _tcdrain\n#define tcflow      _tcflow\n#define tcflush     _tcflush\n#define tcgetattr   _tcgetattr\n#define tcgetpgrp   _tcgetpgrp\n#define tcgetsid    _tcgetsid\n#define tcsendbreak   _tcsendbreak\n#define tcsetattr   _tcsetattr\n#define tcsetpgrp   _tcsetpgrp\n#define telldir     _telldir\n#define time      _time\n#define time2posix    _time2posix\n#define timegm      _timegm\n#define timelocal   _timelocal\n#define timeoff     _timeoff\n#define times     _times\n#define ttyname     _ttyname\n#define ttyname_r   _ttyname_r\n#define ttyslot     _ttyslot\n#define tzname      _tzname\n#define tzset     _tzset\n#define tzsetwall   _tzsetwall\n#define uaddr2taddr   _uaddr2taddr\n#define ualarm      _ualarm\n#define uname     _uname\n#define unsetenv    _unsetenv\n#define unvis     _unvis\n#define user_from_uid   _user_from_uid\n#define usleep      _usleep\n#define utime     _utime\n#define uuid_create_nil   _uuid_create_nil\n#define uuid_is_nil   _uuid_is_nil\n#define valloc      _valloc\n#define vis     _vis\n#define vsnprintf   _vsnprintf\n#define vsnprintf_ss    _vsnprintf_ss\n#define vsyslog     _vsyslog\n#define vsyslog_r   _vsyslog_r\n#define vsyslog_ss    _vsyslog_ss\n#define wait      _wait\n#define wait3     _wait3\n#define waitpid     _waitpid\n#define wcscasecmp    _wcscasecmp\n#define wcsdup      _wcsdup\n#define wcsncasecmp   _wcsncasecmp\n#define wcstof      _wcstof\n#define wcstod      _wcstod\n#define wcstold     _wcstold\n#define wcwidth     _wcwidth\n#define xdr_accepted_reply  _xdr_accepted_reply\n#define xdr_array   _xdr_array\n#define xdr_authunix_parms  _xdr_authunix_parms\n#define xdr_bool    _xdr_bool\n#define xdr_bytes   _xdr_bytes\n#define xdr_callhdr   _xdr_callhdr\n#define xdr_callmsg   _xdr_callmsg\n#define xdr_char    _xdr_char\n#define xdr_datum   _xdr_datum\n#define xdr_des_block   _xdr_des_block\n#define xdr_domainname    _xdr_domainname\n#define xdr_double    _xdr_double\n#define xdr_enum    _xdr_enum\n#define xdr_float   _xdr_float\n#define xdr_free    _xdr_free\n#define xdr_hyper   _xdr_hyper\n#define xdr_int     _xdr_int\n#define xdr_int16_t   _xdr_int16_t\n#define xdr_int32_t   _xdr_int32_t\n#define xdr_int64_t   _xdr_int64_t\n#define xdr_long    _xdr_long\n#define xdr_longlong_t    _xdr_longlong_t\n#define xdr_mapname   _xdr_mapname\n#define xdr_netbuf    _xdr_netbuf\n#define xdr_netobj    _xdr_netobj\n#define xdr_opaque    _xdr_opaque\n#define xdr_opaque_auth   _xdr_opaque_auth\n#define xdr_peername    _xdr_peername\n#define xdr_pmap    _xdr_pmap\n#define xdr_pmaplist    _xdr_pmaplist\n#define xdr_pointer   _xdr_pointer\n#define xdr_reference   _xdr_reference\n#define xdr_rejected_reply  _xdr_rejected_reply\n#define xdr_replymsg    _xdr_replymsg\n#define xdr_rmtcall_args  _xdr_rmtcall_args\n#define xdr_rmtcallres    _xdr_rmtcallres\n#define xdr_rpcb    _xdr_rpcb\n#define xdr_rpcb_entry    _xdr_rpcb_entry\n#define xdr_rpcb_entry_list_ptr _xdr_rpcb_entry_list_ptr\n#define xdr_rpcb_rmtcallargs  _xdr_rpcb_rmtcallargs\n#define xdr_rpcb_rmtcallres _xdr_rpcb_rmtcallres\n#define xdr_rpcb_stat   _xdr_rpcb_stat\n#define xdr_rpcb_stat_byvers  _xdr_rpcb_stat_byvers\n#define xdr_rpcblist    _xdr_rpcblist\n#define xdr_rpcblist_ptr  _xdr_rpcblist_ptr\n#define xdr_rpcbs_addrlist  _xdr_rpcbs_addrlist\n#define xdr_rpcbs_addrlist_ptr  _xdr_rpcbs_addrlist_ptr\n#define xdr_rpcbs_proc    _xdr_rpcbs_proc\n#define xdr_rpcbs_rmtcalllist _xdr_rpcbs_rmtcalllist\n#define xdr_rpcbs_rmtcalllist_ptr _xdr_rpcbs_rmtcalllist_ptr\n#define xdr_rpcbs   _xdr_rpcbs\n#define xdr_rpcbs   _xdr_rpcbs\n#define xdr_short   _xdr_short\n#define xdr_string    _xdr_string\n#define xdr_u_char    _xdr_u_char\n#define xdr_u_hyper   _xdr_u_hyper\n#define xdr_u_int   _xdr_u_int\n#define xdr_u_int16_t   _xdr_u_int16_t\n#define xdr_u_int32_t   _xdr_u_int32_t\n#define xdr_u_int64_t   _xdr_u_int64_t\n#define xdr_u_long    _xdr_u_long\n#define xdr_u_longlong_t  _xdr_u_longlong_t\n#define xdr_u_short   _xdr_u_short\n#define xdr_union   _xdr_union\n#define xdr_vector    _xdr_vector\n#define xdr_void    _xdr_void\n#define xdr_wrapstring    _xdr_wrapstring\n#define xdr_yp_inaddr   _xdr_yp_inaddr\n#define xdr_ypall   _xdr_ypall\n#define xdr_ypbind_resp   _xdr_ypbind_resp\n#define xdr_ypbind_setdom _xdr_ypbind_setdom\n#define xdr_ypdomain_wrap_string  _xdr_ypdomain_wrap_string\n#define xdr_ypmap_parms   _xdr_ypmap_parms\n#define xdr_ypmap_wrap_string _xdr_ypmap_wrap_string\n#define xdr_ypmaplist   _xdr_ypmaplist\n#define xdr_ypowner_wrap_string _xdr_ypowner_wrap_string\n#define xdr_yppushresp_xfr  _xdr_yppushresp_xfr\n#define xdr_ypreq_key   _xdr_ypreq_key\n#define xdr_ypreq_nokey   _xdr_ypreq_nokey\n#define xdr_ypreq_xfr   _xdr_ypreq_xfr\n#define xdr_ypresp_key_val  _xdr_ypresp_key_val\n#define xdr_ypresp_maplist  _xdr_ypresp_maplist\n#define xdr_ypresp_master _xdr_ypresp_master\n#define xdr_ypresp_order  _xdr_ypresp_order\n#define xdr_ypresp_val    _xdr_ypresp_val\n#define xdrmem_create   _xdrmem_create\n#define xdrrec_create   _xdrrec_create\n#define xdrrec_endofrecord  _xdrrec_endofrecord\n#define xdrrec_eof    _xdrrec_eof\n#define xdrrec_skiprecord _xdrrec_skiprecord\n#define xdrstdio_create   _xdrstdio_create\n#define xprt_register   _xprt_register\n#define xprt_unregister   _xprt_unregister\n#define yp_all      _yp_all\n#define yp_bind     _yp_bind\n#define yp_first    _yp_first\n#define yp_get_default_domain _yp_get_default_domain\n#define yp_maplist    _yp_maplist\n#define yp_master   _yp_master\n#define yp_match    _yp_match\n#define yp_next     _yp_next\n#define yp_order    _yp_order\n#define yp_unbind   _yp_unbind\n#define yperr_string    _yperr_string\n#define ypprot_err    _ypprot_err\n#define dlopen      __dlopen\n#define dlclose     __dlclose\n#define dlsym     __dlsym\n#define dlerror     __dlerror\n#define dladdr      __dladdr\n#define fmtcheck    __fmtcheck\n\n/* rpc locks */\n#define authdes_lock          __rpc_authdes_lock\n#define authnone_lock         __rpc_authnone_lock\n#define authsvc_lock          __rpc_authsvc_lock\n#define clnt_fd_lock          __rpc_clnt_fd_lock\n#define clntraw_lock          __rpc_clntraw_lock\n#define dname_lock            __rpc_dname_lock\n#define dupreq_lock           __rpc_dupreq_lock\n#define keyserv_lock          __rpc_keyserv_lock\n#define libnsl_trace_lock     __rpc_libnsl_trace_lock\n#define loopnconf_lock        __rpc_loopnconf_lock\n#define ops_lock              __rpc_ops_lock\n#define portnum_lock          __rpc_portnum_lock\n#define proglst_lock          __rpc_proglst_lock\n#define rpcbaddr_cache_lock   __rpc_rpcbaddr_cache_lock\n#define rpcsoc_lock           __rpc_rpcsoc_lock\n#define svc_fd_lock           __rpc_svc_fd_lock\n#define svc_lock              __rpc_svc_lock\n#define svcraw_lock           __rpc_svcraw_lock\n#define xprtlist_lock         __rpc_xprtlist_lock\n\n#define __learn_tree    ___learn_tree\n#endif /* __weak_alias */\n#endif /* !__lint__ */\n\n#endif /* _NAMESPACE_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/arch/unix/plugins.c": "/* tag: plugin interface for openbios forth kernel\n *\n * Copyright (C) 2003, 2004 Stefan Reinauer\n *\n * See the file \"COPYING\" for further information about\n * the copyright and warranty status of this work.\n */\n\n#include \"sysinclude.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"unix/plugins.h\"\n\nunsigned char *plugindir = \"/usr/share/OpenBIOS/plugins\";\n#define PLUGINDIR  plugindir\n#define PATHSIZE   256\n\n#define CONFIG_DEBUG_PLUGINS\n\ntypedef struct iorange iorange_t;\nstruct iorange {\n\tconst char *name;\n\tunsigned int start;\n\tunsigned int end;\n\tio_ops_t *ops;\n\tiorange_t *next;\n};\n\nstatic iorange_t *ioranges = NULL;\n\ntypedef struct plugin plugin_t;\nstruct plugin {\n\tconst char *name;\n\tplugin_t *next;\n};\n\nstatic plugin_t *plugins = NULL;\n\nio_ops_t *find_iorange(u32 reg)\n{\n\tiorange_t *range = ioranges;\n\twhile (range) {\n\t\tif (range->start <= reg && range->end >= reg)\n\t\t\treturn range->ops;\n\t\trange = range->next;\n\t}\n\treturn NULL;\n}\n\nint register_iorange(const char *name, io_ops_t * ops, unsigned int rstart,\n\t\t     unsigned int rend)\n{\n\tiorange_t *newrange;\n\n\t/* intersection check */\n\tnewrange = ioranges;\n\twhile (newrange) {\n\t\tint fail = 0;\n\t\t/* new section swallows old section */\n\t\tif (newrange->start >= rstart && newrange->end <= rend)\n\t\t\tfail = -1;\n\t\t/* new section start or end point are within range */\n\t\tif (newrange->start <= rstart && newrange->end >= rstart)\n\t\t\tfail = -1;\n\t\tif (newrange->start <= rend && newrange->end >= rend)\n\t\t\tfail = -1;\n\t\tif (fail) {\n\t\t\tprintf(\"Error: overlapping IO regions: %s and %s\\n\",\n\t\t\t\tnewrange->name, name);\n\t\t\treturn -1;\n\t\t}\n\t\tnewrange = newrange->next;\n\t}\n\n\tnewrange = malloc(sizeof(iorange_t));\n\n\tnewrange->name = name;\n\tnewrange->ops = ops;\n\tnewrange->start = rstart;\n\tnewrange->end = rend;\n\tnewrange->next = ioranges;\n\n\tioranges = newrange;\n\n\treturn 0;\n}\n\nint is_loaded(const char *plugin_name)\n{\n\tplugin_t *p = plugins;\n\twhile (p) {\n\t\tif (!strcmp(plugin_name, p->name))\n\t\t\treturn -1;\n\t\tp = p->next;\n\t}\n\treturn 0;\n}\n\nint load_plugin(const char *plugin_name)\n{\n\tvoid *handle;\n\tchar *error;\n\tchar path[PATHSIZE];\n\n\tint (*init_plugin) (void);\n\tchar **deps;\n\tchar **plugin_info;\n\tplugin_t *p;\n\n\tif (is_loaded(plugin_name)) {\n\t\tprintf(\"Plugin %s already loaded.\\n\", plugin_name);\n\t\treturn 0;\n\t}\n\n\tstrncpy(path, PLUGINDIR, PATHSIZE);\n\tstrncat(path, \"/plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \".so\", PATHSIZE);\n\n#if DEBUG\n\tprintf(\"Opening plugin %s\\n\", path);\n#endif\n\n\thandle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n\tif (!handle) {\n\t\terror = dlerror();\n\t\tprintf(\"Error: Could not open plugin \\\"%s\\\": %s\\n\",\n\t\t       plugin_name, error);\n\t\texit(1);\n\t}\n#ifdef CONFIG_DEBUG_PLUGINS\n\tplugin_info = dlsym(handle, \"plugin_author\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s author:  %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_license\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s license: %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_description\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s descr.: %s\\n\", plugin_name, *plugin_info);\n#endif\n\tp = malloc(sizeof(plugin_t));\n\tp->next = plugins;\n\tp->name = plugin_name;\n\tplugins = p;\n\n\tdeps = dlsym(handle, \"plugin_deps\");\n\tif ((error = dlerror()) != NULL)\n\t\tdeps = NULL;\n\n\n\tstrncpy(path, \"plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \"_init\", PATHSIZE);\n\n\tinit_plugin = dlsym(handle, path);\n\tif ((error = dlerror()) != NULL) {\n\t\tprintf(\"error: %s\\n\", error);\n\t\texit(1);\n\t}\n\n\tif (deps) {\n\t\tint i = 0;\n\t\tchar *walk = deps[0];\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\tprintf(\"\\nPlugin %s dependencies:\", plugin_name);\n#endif\n\t\twhile (walk) {\n\t\t\tprintf(\" %s\", walk);\n\t\t\tif (!is_loaded(walk)) {\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\t\t\tprintf(\"(loading)\\n\");\n#endif\n\t\t\t\tload_plugin(walk);\n\t\t\t}\n#ifdef CONFIG_DEBUG_PLUGINS\n\t\t\telse {\n\t\t\t\tprintf(\"(loaded)\");\n\t\t\t}\n#endif\n\t\t\twalk = deps[++i];\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n#if DEBUG\n\tprintf(\"Initializing module:\\n\");\n#endif\n\n\treturn init_plugin();\n\n\t// We don't dlclose the handle here since\n\t// we want to keep our symbols for later use.\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/arch/unix/plugins/loader.c": "/* tag: openbios plugin loader\n *\n * Copyright (C) 2003 Stefan Reinauer\n *\n * See the file \"COPYING\" for further information about\n * the copyright and warranty status of this work.\n */\n\n/* This is a simple plugin loader. OpenBIOS duplicates some\n * of this code in kernel/arch/unix/plugins.c. This code is\n * here for reference and simple testing.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <unistd.h>\t\t// sleep\n\n#include \"unix/plugins.h\"\n\n#define PLUGINDIR  \"/usr/share/OpenBIOS/plugins\"\n#define PATHSIZE   256\n\n#define DEBUG_PLUGINS\n\ntypedef struct iorange iorange_t;\nstruct iorange {\n\tconst char *name;\n\tunsigned int start;\n\tunsigned int end;\n\tio_ops_t *ops;\n\tiorange_t *next;\n};\n\niorange_t *ioranges = NULL;\n\ntypedef struct plugin plugin_t;\nstruct plugin {\n\tconst char *name;\n\tplugin_t *next;\n};\n\nplugin_t *plugins = NULL;\n\nint register_iorange(const char *name, io_ops_t * ops, unsigned int rstart,\n\t\t     unsigned int rend)\n{\n\tiorange_t *newrange;\n\n\t/* intersection check */\n\tnewrange = ioranges;\n\twhile (newrange) {\n\t\tint fail = 0;\n\t\t/* new section swallows old section */\n\t\tif (newrange->start >= rstart && newrange->end <= rend)\n\t\t\tfail = -1;\n\t\t/* new section start or end point are within range */\n\t\tif (newrange->start <= rstart && newrange->end >= rstart)\n\t\t\tfail = -1;\n\t\tif (newrange->start <= rend && newrange->end >= rend)\n\t\t\tfail = -1;\n\t\tif (fail) {\n\t\t\tprintf(\"Error: overlapping IO regions: %s and %s\\n\",\n\t\t\t     newrange->name, name);\n\t\t\treturn -1;\n\t\t}\n\t\tnewrange = newrange->next;\n\t}\n\n\tnewrange = malloc(sizeof(iorange_t));\n\n\tnewrange->name = name;\n\tnewrange->ops = ops;\n\tnewrange->start = rstart;\n\tnewrange->end = rend;\n\tnewrange->next = ioranges;\n\n\tioranges = newrange;\n\n\treturn 0;\n}\n\nint is_loaded(const char *plugin_name)\n{\n\tplugin_t *p = plugins;\n\twhile (p) {\n\t\tif (!strcmp(plugin_name, p->name))\n\t\t\treturn -1;\n\t\tp = p->next;\n\t}\n\treturn 0;\n}\n\nint load_plugin(const char *plugin_name)\n{\n\tvoid *handle;\n\tchar *error;\n\tchar path[PATHSIZE];\n\n\tint (*init_plugin) (void);\n\tchar **deps;\n\tchar **plugin_info;\n\tplugin_t *p;\n\n\tif (is_loaded(plugin_name)) {\n\t\tprintf(\"Plugin %s already loaded.\\n\", plugin_name);\n\t\treturn 0;\n\t}\n\n\tstrncpy(path, PLUGINDIR, PATHSIZE);\n\tstrncat(path, \"/plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \".so\", PATHSIZE);\n\n#if DEBUG\n\tprintf(\"Opening plugin %s\\n\", path);\n#endif\n\n\thandle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n\tif (!handle) {\n\t\terror = dlerror();\n\t\tprintf(\"Error: Could not open plugin \\\"%s\\\": %s\\n\",\n\t\t       plugin_name, error);\n\t\texit(1);\n\t}\n#ifdef DEBUG_PLUGINS\n\tplugin_info = dlsym(handle, \"plugin_author\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s author:  %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_license\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s license: %s\\n\", plugin_name, *plugin_info);\n\tplugin_info = dlsym(handle, \"plugin_description\");\n\tif ((error = dlerror()) == NULL)\n\t\tprintf(\"Plugin %s descr.: %s\\n\", plugin_name, *plugin_info);\n#endif\n\tp = malloc(sizeof(plugin_t));\n\tp->next = plugins;\n\tp->name = plugin_name;\n\tplugins = p;\n\n\tdeps = dlsym(handle, \"plugin_deps\");\n\tif ((error = dlerror()) != NULL)\n\t\tdeps = NULL;\n\n\n\tstrncpy(path, \"plugin_\", PATHSIZE);\n\tstrncat(path, plugin_name, PATHSIZE);\n\tstrncat(path, \"_init\", PATHSIZE);\n\n\tinit_plugin = dlsym(handle, path);\n\tif ((error = dlerror()) != NULL) {\n\t\tprintf(\"error: %s\\n\", error);\n\t\texit(1);\n\t}\n\n\tif (deps) {\n\t\tint i = 0;\n\t\tchar *walk = deps[0];\n#ifdef DEBUG_PLUGINS\n\t\tprintf(\"\\nPlugin %s dependencies:\", plugin_name);\n#endif\n\t\twhile (walk) {\n\t\t\tprintf(\" %s\", walk);\n\t\t\tif (!is_loaded(walk)) {\n#ifdef DEBUG_PLUGINS\n\t\t\t\tprintf(\"(loading)\\n\");\n#endif\n\t\t\t\tload_plugin(walk);\n\t\t\t}\n#ifdef DEBUG_PLUGINS\n\t\t\telse {\n\t\t\t\tprintf(\"(loaded)\");\n\t\t\t}\n#endif\n\t\t\twalk = deps[++i];\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n#if DEBUG\n\tprintf(\"Initializing module:\\n\");\n#endif\n\n\treturn init_plugin();\n\n\t// We don't dlclose the handle here since\n\t// we want to keep our symbols for later use.\n}\n\nint main(void)\n{\n\tiorange_t *r;\n\n\t// load_plugin(\"kbd\");\n\t// load_plugin(\"pci\");\n\tload_plugin(\"qt\");\n\n\tprintf(\"\\nRegistered IO Ranges:\\n\");\n\tr = ioranges;\n\twhile (r) {\n\t\tprintf(\"  %s: %x-%x\\n\", r->name, r->start, r->end);\n\t\tr = r->next;\n\t}\n\n\tsleep(10);\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/Documentation/kernel/Changelog.stepan": "# tag: stepan's changelog for CVS\n\nMon Jul 14 02:16:49 CEST 2003\n - fix segv overrun while dumping dictionary in unix.c\n - implement first version of >number and $number\n - add stack diagram to digit\n - no newline after accept\n - new version of the interpreter\n - fix make run target\n\nMon Jul 14 20:15:40 CEST 2003\n - negate true value in prims \n - get rid of primitive word bounds. \n - get rid of some obsolete code.\n - implement io[cwl][@!]\n - reorganize [in|out][bwl]\n - start adding stack diagrams to primitives.\n \nMon Jul 14 23:57:46 CEST 2003\n - added some more stack diagrams in forth.h\n - move parse, parse-word, word to bootstrap.fs\n - include memory.fs from bootstrap.fs for above.\n\nWed Jul 16 22:57:31 CEST 2003\n - add include guards\n - add banner\n - fix primitives' dependencies\n\nSun Jul 20 03:27:40 CEST 2003\n - remove unneeded readcell\n - rename ' to ['] to meet specs\n\nSun Jul 20 14:08:43 CEST 2003\n - add rest of stack diagrams in forth.h\n - move here and here! to forth.h (from internal.h)\n - indent includes\n - merge system.h into forth.h\n - Change tag of forth.h (!) because the old one \n   did not meet the meaning of the code.\n - update comments in primitives.c\n\nSun Jul 27 01:53:18 CEST 2003\n - include great new do/?do/loop/+loop \n   implementation from Patrick.\n - include testsuite enhancement from Patrick\n - include trampoline from Patrick (fixes execute)\n\nSun Jul 27 21:11:50 CEST 2003\n - update x86 console code to become when using\n   multiboot (vga/keyboard).\n - fix exit properly\n - revert to old case..endcase code\n - fix >number and $number\n - add number parsing to interpreter\n - add simple stack checking to interpreter\n - add 2 testcases (exit and case2)\n\nMon Jul 28 14:49:31 CEST 2003\n - move 7.3.7 Flag constants up in bootstrap.fs\n - move 7.3.9.2.4 Miscellaneous dictionary down.\n - add reveal, recursive, recurse, environment? to 7.3.9.2.4\n - move (to) to bootstrap.fs\n \nMon Jul 28 17:08:58 CEST 2003\n - add stack overflow check to interpreter\n - check parse-word result in interpreter. \n - add ascii and char, add helper handle-lit\n\nTue Jul 29 09:20:18 CEST 2003\n - add s\" and .\"\n - add [char] and control\n - heavily move around words in bootstrap.fs \n   to get dependencies resolved.\n - fix skipws crash\n - rename query to refill\n - interpreter reads several words in a line now\n - interpreter stops now if error encountered in\n   currently parsed line.\n - add forth definitions of ( and \\\n - change c parser/interpreter to handle comments\n   correctly.\n - indent, clean up unix.c\n\nTue Jul 29 18:13:27 CEST 2003\n - add .(  (chapter 7.3.4.4)\n - add pack, -trailing (chapter 7.3.4.8)\n - add d#, h#, o# (chapter 7.3.5.2)\n - let first stack element start at 1 instead of 0\n   to have a 1 cell guard band.\n - set SA_NODEFER flag to signal handler to ensure\n   that it is entered recursively.\n\nTue Jul 29 19:06:18 CEST 2003\n - more simplification for unix.c\n - add ', ['], find\n - fix pack, count\n - add literal, compile, [compile], compile,\n - fix [\n\nWed Jul 30 01:24:24 CEST 2003\n - add >body, body>\n - add helpers: flags?, immediate?, compile-only?, header\n - add :, ;, constant, value, variable, buffer:\n - parse word's flags in interpreter to make colon \n   definitions work\n - add \"compiled\" acknowledge when interpreter is in compile mode\n\nWed Jul 30 07:27:58 CEST 2003\n - fix flags handling in interpreter\n - fix handle-text compile mode behaviour\n - add defer, struct, field\n - add behaviour, to\n - add $create, create, does> (missing c code DODOES)\n - add abort\n\nThu Jul 31 07:58:35 CEST 2003\n - fix DODOES cfa code\n - make 2@ and 2! colon definitions instead of primitives.\n - add word \"cell\" \n - add warning message as described in 7.3.9.1 if an already \n   existing word is created\n\nFri Aug  1 23:32:57 CEST 2003\n - fix s\" in C interpreter (compare case insensitive)\n - fix forth source dependencies\n - fix forth word sm/rem \n\nSat Aug  2 13:34:43 CEST 2003\n - add band guard around input buffer\n - make sure that \"header\" pads null bytes\n - define -1,0,1,2,3 early to safe dictionary space\n\nSat Aug  2 16:58:31 CEST 2003\n - use getopt/getopt_long for option parsing\n - add include path option -I to unix\n - don't create obsolete symlink in forth/Makefile\n - fix recurse\n - fix prim word /\n - implement postpone\n - fix 2!, ['] and '\n - implement evaluate/eval\n\nSun Aug  3 11:48:18 CEST 2003\n - implement \"bye\" to leave the engine\n - change initial word to \"initialize\" and\n   make quit restart the forth engine.\n - fix missing ; in u.\n - fix return value of find when handling an immediate\n - getting rid of primitives mod, /mod and /, replacing \n   them by floored variants as IEEE 1275-1994 says.\n - clean up primitives.\n   \nSun Aug  3 23:06:39 CEST 2003\n - fix >body, body>\n - make not a synonym for invert as described in IEEE 1275\n - todigit can now switch between capital and small letters via\n   value capital-hex?\n\nMon Aug  4 21:57:06 CEST 2003\n - indent unix.c\n - reimplement do, ?do, loop, +loop with prim helpers. It now\n   passes hayes' ans forth test suite.\n - adopt unix.c and bootstrap.fs to new (?)do..(+)loop\n - remove unneeded if around ?do..loop in \",\n - interpreter: clear input buffer before refilling it\n - serialize PC changes in dobranch and do?branch\n\nThu Aug  7 19:00:43 CEST 2003\n - add/change missing/incomplete copyright notices\n - implement \"\n\nSun Aug 10 19:52:20 CEST 2003\n - reimplement catch, through\n - implement abort\"\n - rephrase endcase\n - change interpreter to use exception words\n - implement forget\n - add dummy \"forth\"\n\nSun Aug 10 22:12:28 CEST 2003\n - fix \"spaces\"\n - create subdir util for types.sh and new bin2hex\n - enable forth.html again, running hayes test suite.\n - include dictionary in char array instead of elf section\n   when building an x86 \"full\" image\n - don't newline in accept.\n - fix \" compile mode behavior.\n - move throw/catch and use it with ' and [']\n - add :noname\n\nThu Aug 14 23:02:15 CEST 2003\n - fix \"field\"\n - implement second stage bootstrapping\n   NOTE: changes dictionary format!\n - drop initxt from dictionary, since we know \"last\" now.\n - output dictionary can be named on command line.\n - make segfault handler optional\n\nMon Sep  1 19:41:23 CEST 2003\n - move findword() et al to dict.c (needed by openbios.c due \n   to last dictionary change)\n - fix findword() return values and optimize it slightly.\n - indented some files.\n \nMon Sep  8 22:43:55 CEST 2003\n - add initial AMD64 support (cloned x86 target)\n - get vocabulary implementation working. maybe buggy, but operable\n - enable vocabulary support by default (vocabularies? set to true)\n - drop duplicate \"forth\"\n - fix some comments in forth files.\n \nSun Sep 28 14:26:41 CEST 2003\n - some documentation and comment fixes\n - fix parameter passing for io words.\n\nThu Oct  2 08:21:06 CEST 2003\n - clean up lit\n - inline some functions from internal.h (reduces size and execution \n   time)\n\nFri Oct  3 15:20:44 CEST 2003\n - make i and j primitives. This safes a lot of time in loops.\n   i.e. the following dummy loop executes 300% faster:\n   : fbar 1000 0 do 1000 0 do j drop i drop loop loop ;\n\nSat Oct 11 20:18:22 CEST 2003\n - include plugin interface for unix hosted version.\n - add plugin_pci and plugin_qt as examples.\n - add simple set of pci functions for testing the pci plugin\n - add state variable \"runforth\" to be changed by the qt plugin\n   on exit.\n\nSun Oct 12 14:57:54 CEST 2003\n - move internal.h and forth.h to kernel/\n - replace make by $(MAKE) in some places.\n\nTue Oct 14 01:06:39 CEST 2003\n - add (immediate) and (compile-only) \n\nWed Oct 15 00:52:49 CEST 2003\n - check whether dlopen() needs libdl.\n - include BSD compile fixes from oxygene\n - fix abort\"\n \nTue Oct 21 22:08:00 CEST 2003\n - fix forth.html dependencies\n - yet another indent orgy\n\nThu Oct 30 16:10:01 CET 2003\n - add \"call\" to execute native code functions\n - plugin_qt: fix framebuffer address on 64bit systems\n - plugin_pci: create position independent code.\n\nWed Nov  5 08:38:18 CET 2003\n - fix \"comp\" (from Samuel Rydh)\n - include instance support (from Samuel Rydh)\n\nSun Nov  9 15:53:33 CET 2003\n - some changes for \"see\"\n - apply more patches from Samuel.\n - smaller, better implementation of handle-text\n\nMon Nov 10 22:06:32 CET 2003\n - increase max dictionary size from 64k to 128k\n - add simple fcode to qt plugin\n - fix handle-text (move null-align up)\n\nTue Nov 11 22:53:27 CET 2003\n - rename ?key to key?.\n - clean up .s\n - add (cr\n\nTue Nov 17 22:42:54 CET 2003\n - enterforth rstack fix (from Samuel)\n - include latest version of qt interface \n   fcode driver\n - fix \"header\" (from Samuel)\n\nWed Nov 26 15:12:07 CET 2003\n - merge patches from Samuel:\n - add $buffer:\n - fill all of \"ib\", not only 80 characters\n - interpreted conditionals support\n - late initializers\n\nSun Nov 30 23:04:28 CET 2003\n - fix bug in enterforth (non-colon words would destroy PC)\n\nSat Dec 13 00:57:01 CET 2003\n - add initial ppc infrastructure\n - only search current wordlist in \"header\"\n - seperate unix host binary and bootstrap interpreter.\n\nSun Dec 14 18:13:29 CET 2003\n - add sys-debug word and use it to stop forth interpreter\n   during bootstrap if an error occurs.\n \nSat Mar 13 16:30:30 CET 2004\n - fix digit problem\n   \n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/capstone/bindings/vb6/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/capstone/bindings/vb6/CX86Operand.cls",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/capstone/docs/BHUSA2014-capstone.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SRAT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/APIC.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/APIC.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SRAT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SRAT.mmio64",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.bridge",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/NFIT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SRAT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.ipmibt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/DSDT.mmio64",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/q35/SRAT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/SRAT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/APIC.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/APIC.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/SRAT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.bridge",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/SSDT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/NFIT.dimmpxm",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/SRAT.memhp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.cphp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/SRAT.numamem",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/acpi/pc/DSDT.ipmikcs",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/uefi-boot-images/bios-tables-test.aarch64.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/uefi-boot-images/bios-tables-test.arm.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/uefi-boot-images/bios-tables-test.i386.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/data/uefi-boot-images/bios-tables-test.x86_64.iso.qcow2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/afl9.vmdk.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/iotest-version3.vmdk.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/iotest-dirtylog-10G-4M.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/parallels-v1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/empty.bochs.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/afl5.img.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/test-disk2vhd.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/parallels-v2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/iotest-dynamic-1G.vhdx.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/virtualpc-dynamic.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/hyperv2012r2-dynamic.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/simple-pattern.cloop.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/grub_mbr.raw.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/d2v-zerofilled.vhd.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/tests/qemu-iotests/sample_images/simple-dmg.dmg.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/qga/vss-win32/qga-vss.tlb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-ramfb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/ppc_rom.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/slof.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/bamboo.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-ne2k_pci.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-e1000.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/QEMU,cgthree.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-rtl8139.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-pcnet.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-rtl8139.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/bios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/linuxboot_dma.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/kvmvapic.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/bios-256k.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-cirrus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-virtio.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/QEMU,tcx.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/spapr-rtas.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-bochs-display.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/petalogix-ml605.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/s390-netboot.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/sgabios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-eepro100.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/s390-ccw.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/qemu-nsis.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-vmxnet3.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/multiboot.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-e1000.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/skiboot.lid",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-ne2k_pci.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-e1000e.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/hppa-firmware.img",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/linuxboot.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pvh.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-vmware.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-qxl.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/qemu-nsis.ico",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/petalogix-s3adsp1800.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-eepro100.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-virtio.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/vgabios-stdvga.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/efi-virtio.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/u-boot-sam460-20100605.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/canyonlands.dtb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/qemu_vga.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/u-boot.e500",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/pc-bios/pxe-pcnet.rom",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_24x24.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_32x32.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_512x512.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/ui/icons/qemu_256x256.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/qemu-palcode/osf.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/qemu-palcode/uart.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/qemu-palcode/uart.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/CHANGELOG-before-U-Boot-1.1.5",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/dev.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/fs.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/fdos.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/vfat.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/fat.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/dos.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/subdir.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/fs/fdos/fdos.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/common/cmd_fdos.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/sparc/cpu/leon3/usb_uhci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c2400.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c2410.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm946es/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm1136/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/lh7a40x/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/omap/reset.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm926ejs/versatile/reset.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm925t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm920t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/ixp/npe/include/IxOsal.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/ixp/npe/include/IxAtmdAccCtrl.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm_intcm/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/sa1100/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/arm/cpu/arm720t/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/mips/include/asm/inca-ip.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/powerpc/cpu/mpc8260/cpu_init.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pci_type1.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/video_bios.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pcat_interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/realmode_switch.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios_setup.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/realmode.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/video.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/zimage.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/pcat_timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/lib/bios_pci.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/realmode.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ibmpc.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/zimage.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/pci.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/processor.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/u-boot-i386.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/i8259.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/interrupt.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/i8254.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ic/pci.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/include/asm/ic/sc520.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/config.mk",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/start16.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/interrupts.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/cpu.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/resetvec.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/start.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_pci.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_ssi.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_timer.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520_asm.S",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/arch/i386/cpu/sc520/sc520.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/common/catweasel.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/common/cmd_boota.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/common/logo_sam460.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/common/cw4.firmware",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/common/logo_acube.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/board/ACube/bios_emulator/bios.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/lib/lzma/history.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/fdc.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/video_font.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/ali512x.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/sed13806.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/sm501.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/linux/mtd/mtd.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/configs/sc3.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/configs/sc520_spunk.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/configs/sc520_cdp.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/include/configs/sc520_spunk_rel.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/nand_spl/board/amcc/bamboo/sdram.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/video/ct69000.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/video/sed13806.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/video/sm501.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/rtc/s3c24x0_rtc.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/block/sata_sil3114.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/block/sata_sil3114.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/misc/ali512x.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/drivers/pcmcia/ti_pci1410a.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/ronetix.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/linux_logo_ttcontrol_palfin.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/atmel.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/denx.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/esd.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/logos/linux_logo_ttcontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/easylogo/linux_blackfin.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/tools/easylogo/linux_logo.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/doc/README.m5373evb",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/doc/README.mpc7448hpc2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot-sam460ex/doc/README.RPXClassic",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/ipxe/src/drivers/infiniband/MT25408_PRM.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/ipxe/src/drivers/bus/eisa.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/ipxe/src/drivers/net/smc9000.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/ipxe/src/drivers/net/smc9000.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Sockets/ReadMe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Sockets/OobRx/Windows/OobRx.suo",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Sockets/OobTx/Windows/OobTx.suo",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Lib/heapq.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Lib/encodings/string_escape.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Lib/encodings/punycode.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Objects/listsort.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Modules/_heapqmodule.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.10/Modules/unicodedata.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/tarfile.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/shlex.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/heapq.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/encodings/string_escape.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/encodings/punycode.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_shlex.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_marshal.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_csv.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/testtar.tar",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/zipdir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_pep263.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_cookielib.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/sgml_input.html",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/Sine-1000Hz-300ms.aif",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/185test.db",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/test_tarfile.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/johab.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/shift_jis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/gb18030.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/euc_jp.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/big5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/euc_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/big5hkscs.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/euc_kr.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/shift_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/gb2312.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/gbk.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/test/cjkencodings/cp949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/email/test/data/msg_15.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/email/test/data/PyBanner048.gif",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/email/test/data/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/wininst-9.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/wininst-8.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/wininst-6.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/bdist_msi.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/wininst-7.1.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Lib/distutils/command/wininst-9.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Tools/i18n/msgfmt.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Tools/i18n/pygettext.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Tools/scripts/hotshotmain.py",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Objects/listsort.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_heapqmodule.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/unicodedata.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/prepare_protocol.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/connection.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/cursor.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/cache.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/statement.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/sqlitecompat.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/statement.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/cache.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/util.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/module.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/row.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/util.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/prepare_protocol.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/module.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/row.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/connection.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Python/Python-2.7.2/Modules/_sqlite/cursor.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/AppPkg/Applications/Lua/doc/osi-certified-72x60.png",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BeagleBoardPkg/ConfigurationHeader.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BeagleBoardPkg/Debugger_scripts/rvi_dummy.axf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/StdLib/LibC/Main/Ia32/ftol2.obj",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Compatibility/FrameworkHiiOnUefiHiiThunk/Strings.uni",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/CHANGES_FROM_133.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/bin/Antlr.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/bin/Sorcerer.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/bin/Dlg.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/lib/pccts_release.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/lib/pccts_debug.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/h/pccts_release.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkCompatibilityPkg/Other/Maintained/Tools/Pccts/h/pccts_debug.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/GenBiosId.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/FCE.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/BfmLib.exe",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Library/MultiPlatformLib/BoardClkGens/BoardClkGens.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/PlatformPei/BootMode.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/Gcc/NvStorageFtwWorking.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/Gcc/NvStorageFtwSpare.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/Gcc/NvStorageVariable.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/IFWIHeader/Vacant.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/IFWIHeader/IFWI_HEADER.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Stitch/IFWIHeader/IFWI_HEADER_SPILOCK.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/FspAzaliaConfigData/AzaliaConfig.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/IntelGopDepex/IntelGopDriver.depex",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/Logo/Logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2TbltDevicePkg/PlatformInitPei/PchInitPeim.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.port80.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.serial.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.serial.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.x64.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/UefiCpuPkg/ResetVector/Vtf0/Bin/ResetVector.ia32.port80.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/bootsect.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Start.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/efi64.com2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Mbr.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/efi32.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/efi32.com2",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Start64.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/bs32.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/efi64.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Start16.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Start32.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/St16_64.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/Gpt.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/bs16.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/DuetPkg/BootSector/bin/St32_64.com",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellPkg/Application/ShellCTestApp/TestArgv.log",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/RELEASE_XCODE31/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/RELEASE_XCODE32/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/DEBUG_XCODE31/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Bin/Darwin-i386/Arm/DEBUG_XCODE32/CompilerIntrinsicsLib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/CHANGES_FROM_133.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/dlg/DlgPPC.mak",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/antlr/antlr.r",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/C/VfrCompile/Pccts/antlr/AntlrPPC.mak",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/C/BrotliCompress/docs/brotli-comparison-study-2015-09-22.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/Python/Rsa2048Sha256Sign/TestSigningPublicKey.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/Python/UPT/Dll/sqlite3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/Python/Eot/LzmaCompressor.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/BaseTools/Source/Python/Eot/EfiCompressor.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/IntelFsp2Pkg/FspSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/MinUefiShell/AArch64/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/MinUefiShell/Ia32/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/MinUefiShell/X64/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/MinUefiShell/Arm/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/UefiShell/AArch64/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/UefiShell/Ia32/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/UefiShell/X64/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ShellBinPkg/UefiShell/Arm/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/IntelFspWrapperPkg/FspWrapperSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/IntelFspPkg/FspSecCore/Vtf0/Bin/ResetVec.ia32.raw",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/IntelFspPkg/Tools/UserManuals/GenCfgOptUserManual.docx",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/IntelFspPkg/Tools/UserManuals/PatchFvUserManual.docx",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ArmPkg/Drivers/ArmScmiDxe/ArmScmiPerformanceProtocolPrivate.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ArmPkg/Library/GccLto/liblto-arm.a",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/ArmPkg/Library/GccLto/liblto-aarch64.a",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/Vlv2DeviceRefCodePkg/AcpiTablesPCAT/IoTVirtualDevice.asl",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/MdeModulePkg/Library/BrotliCustomDecompressLib/docs/brotli-comparison-study-2015-09-22.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/MdeModulePkg/Logo/Logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/MinimumShell/Ia32/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/MinimumShell/X64/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/MinimumShell/Ipf/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/MinimumShell/Arm/Shell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/stall.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/dmem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/SmbiosView.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/TelnetMgmt.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/dmpstore.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/sermode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/timezone.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/mode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/pci.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Ping.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Mount.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/efidecompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/err.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/mem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Devtree.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/IpConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/memmap.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Devices.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/LoadPciRom.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Dblk.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/hexedit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/edit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Openinfo.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/eficompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/mm.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/IfConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/comp.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ia32/Apps/Guid.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/stall.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/dmem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/SmbiosView.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/TelnetMgmt.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/dmpstore.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/sermode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/timezone.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/mode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/pci.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Ping.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Mount.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/efidecompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/err.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/mem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Devtree.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/IpConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/memmap.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Devices.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/LoadPciRom.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Dblk.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/hexedit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/edit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Openinfo.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/eficompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/mm.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/IfConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/comp.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/X64/Apps/Guid.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/stall.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/dmem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/SmbiosView.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/TelnetMgmt.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/dmpstore.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/sermode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/timezone.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/mode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/pci.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Ping.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Mount.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/efidecompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/err.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/mem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Devtree.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/IpConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/memmap.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Devices.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/LoadPciRom.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Dblk.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/hexedit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/edit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Openinfo.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/eficompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/mm.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/IfConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/comp.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Ipf/Apps/Guid.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/NShell.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/SmbiosView.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/TelnetMgmt.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Drivers.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Comp.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Type.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/DrvDiag.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/TimeZone.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Attrib.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/DrvCfg.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Stall.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Load.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Unload.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Vol.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Pci.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Ping.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/MemMap.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mount.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/HexEdit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/DmpStore.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Date.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Ver.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mv.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Devtree.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/IpConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Touch.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Devices.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Ls.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mkdir.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/LoadPciRom.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Rm.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/OpenInfo.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Dblk.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/SerMode.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Cls.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Cp.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Err.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Resets.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/IfConfig.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/EfiDecompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/EfiCompress.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Time.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Dmem.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Mm.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Guid.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/Bin/Arm/Edit.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/FullShell/AArch64/Shell_Full.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/FullShell/Ia32/Shell_Full.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/FullShell/X64/Shell_Full.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/FullShell/Ipf/Shell_Full.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EdkShellBinPkg/FullShell/Arm/Shell_Full.efi",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EmbeddedPkg/Scripts/LauterbachT32/README.txt",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/edk2/EmbeddedPkg/Library/GdbDebugAgent/GdbDebugAgent.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/QemuMacDrivers/builds/qemu_vga_debugosi.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/QemuMacDrivers/builds/qemu_vga.ndrv",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/QemuMacDrivers/QemuVGADriver/src/DriverQDCalls.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/QemuMacDrivers/QemuVGADriver/src/DriverQDCalls.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/forth/device/romfont.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/libopenbios/font_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/openbios/libopenbios/font_8x16.c",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/arch/arm/dts/sun4i-a10-inet97fv2.dts",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/include/video_font_data.h",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/drivers/video/fonts/ankacoder_c75_r.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/drivers/video/fonts/rufscript010.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/drivers/video/fonts/nimbus_sans_l_regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/drivers/video/fonts/cantoraone_regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/gateworks.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/compulab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/ronetix.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/u-boot_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/intercontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/toradex.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/solidrun.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/siemens.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/linux_logo_ttcontrol_palfin.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/atmel.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/denx.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/microchip.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/wandboard.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/engicam.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/denx-comp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/esd.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/linux_logo_ttcontrol.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/syteco.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/logos/freescale.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/easylogo/linux_blackfin.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/easylogo/linux_logo.tga",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/tools/binman/test/descriptor.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/doc/chromium/devkeys/kernel.keyblock",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/u-boot/doc/chromium/devkeys/kernel_data_key.vbprivk",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/gard/test/files/data1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/gard/test/files/data-p9.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/gard/test/files/blank.bin",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/ffspart/test/files/16-create-blank.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/ffspart/test/files/17-toc.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/ffspart/test/files/03-tiny-pnor.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/external/ffspart/test/files/04-tiny-pnor2.out",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/hdata/test/p81-811.spira",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/hdata/test/p8-840-spira.spirah",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/hdata/test/p81-811.spira.heap",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/hdata/test/op920.wsp.heap",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/skiboot/hdata/test/p8-840-spira.spiras",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/SLOF/FlashingSLOF.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/SLOF/lib/libipmi/libipmi.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/SLOF/clients/takeover/takeover.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/SLOF/board-js2x/rtas/ipmi_oem.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/roms/SLOF/board-js2x/rtas/i2c_bmc.oco",
        "/tmp/vanessa/spack-stage/spack-stage-qemu-4.0.1-5tvauf5y7xq2s54s7jsyrlikde4ef5un/spack-src/docs/qemu_logo.pdf"
    ],
    "total_files": 41662
}