{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/SAL/nfs4_recovery.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n * ---------------------------------------\n */\n\n/**\n * @defgroup SAL State abstraction layer\n * @{\n */\n\n/**\n * @file nfs4_recovery.c\n * @brief NFSv4 recovery\n */\n\n#include \"config.h\"\n#include \"log.h\"\n#include \"nfs_core.h\"\n#include \"nfs4.h\"\n#include \"sal_functions.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include \"bsd-base64.h\"\n#include \"client_mgr.h\"\n#include \"fsal.h\"\n\n/* The grace_mutex protects current_grace, clid_list, and clid_count */\nstatic pthread_mutex_t grace_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic struct timespec current_grace; /* current grace period timeout */\nstatic int clid_count; /* number of active clients */\nstatic struct glist_head clid_list = GLIST_HEAD_INIT(clid_list);  /* clients */\n\n/*\n * Low two bits of grace_status word are flags. One for whether we're currently\n * in a grace period and one if a change was requested.\n */\n#define GRACE_STATUS_ACTIVE_SHIFT\t0\n#define GRACE_STATUS_CHANGE_REQ_SHIFT\t1\n\n/* The remaining bits are for the refcount */\n#define GRACE_STATUS_COUNTER_SHIFT\t2\n\n#define GRACE_STATUS_ACTIVE\t\t(1U << GRACE_STATUS_ACTIVE_SHIFT)\n#define GRACE_STATUS_CHANGE_REQ\t\t(1U << GRACE_STATUS_CHANGE_REQ_SHIFT)\n#define GRACE_STATUS_REF_INCREMENT\t(1U << GRACE_STATUS_COUNTER_SHIFT)\n#define GRACE_STATUS_COUNT_MASK\t\t((~0U) << GRACE_STATUS_COUNTER_SHIFT)\n\nstatic uint32_t\tgrace_status;\n\nstatic int default_recovery_init(void)\n{\n\treturn 0;\n}\n\nstatic void default_end_grace(void)\n{\n}\n\nstatic void default_recovery_read_clids(nfs_grace_start_t *gsp,\n\t\t\t\t\tadd_clid_entry_hook add_clid_entry,\n\t\t\t\t\tadd_rfh_entry_hook add_rfs_entry)\n{\n}\n\nstatic void default_add_clid(nfs_client_id_t *clientid)\n{\n}\n\nstatic void default_rm_clid(nfs_client_id_t *clientid)\n{\n}\n\nstatic void default_add_revoke_fh(nfs_client_id_t *dlr_clid,\n\t\t\t\t  nfs_fh4 *dlr_handle)\n{\n}\n\nstatic struct nfs4_recovery_backend default_recovery_backend = {\n\t.recovery_init = default_recovery_init,\n\t.end_grace = default_end_grace,\n\t.recovery_read_clids = default_recovery_read_clids,\n\t.add_clid = default_add_clid,\n\t.rm_clid = default_rm_clid,\n\t.add_revoke_fh = default_add_revoke_fh,\n};\n\n\nstatic struct nfs4_recovery_backend *recovery_backend =\n\t\t\t\t\t&default_recovery_backend;\nint32_t reclaim_completes; /* atomic */\n\nstatic void nfs4_recovery_load_clids(nfs_grace_start_t *gsp);\nstatic void nfs_release_nlm_state(char *release_ip);\nstatic void nfs_release_v4_clients(char *ip);\n\n\n\n\nclid_entry_t *nfs4_add_clid_entry(char *cl_name)\n{\n\tclid_entry_t *new_ent = gsh_malloc(sizeof(clid_entry_t));\n\n\tglist_init(&new_ent->cl_rfh_list);\n\t(void) strlcpy(new_ent->cl_name, cl_name, sizeof(new_ent->cl_name));\n\tglist_add(&clid_list, &new_ent->cl_list);\n\t++clid_count;\n\treturn new_ent;\n}\n\nrdel_fh_t *nfs4_add_rfh_entry(clid_entry_t *clid_ent, char *rfh_name)\n{\n\trdel_fh_t *new_ent = gsh_malloc(sizeof(rdel_fh_t));\n\n\tnew_ent->rdfh_handle_str = gsh_strdup(rfh_name);\n\tglist_add(&clid_ent->cl_rfh_list, &new_ent->rdfh_list);\n\treturn new_ent;\n}\n\nvoid nfs4_cleanup_clid_entries(void)\n{\n\tstruct clid_entry *clid_entry;\n\t/* when not doing a takeover, start with an empty list */\n\twhile ((clid_entry = glist_first_entry(&clid_list,\n\t\t\t\t\t       struct clid_entry,\n\t\t\t\t\t       cl_list)) != NULL) {\n\t\tglist_del(&clid_entry->cl_list);\n\t\tgsh_free(clid_entry);\n\t\t--clid_count;\n\t}\n\tassert(clid_count == 0);\n\tatomic_store_int32_t(&reclaim_completes, 0);\n}\n\n/*\n * Check the current status of the grace period against what the caller needs.\n * If it's different then return false without taking a reference. If a change\n * has been requested, then we also don't want to give out a reference.\n */\nbool nfs_get_grace_status(bool want_grace)\n{\n\tuint32_t cur, pro, old;\n\n\told = atomic_fetch_uint32_t(&grace_status);\n\tdo {\n\t\tcur = old;\n\n\t\t/* If it's not the state we want, then no reference */\n\t\tif (want_grace != (bool)(cur & GRACE_STATUS_ACTIVE))\n\t\t\treturn false;\n\n\t\t/* If a change was requested, no reference */\n\t\tif (cur & GRACE_STATUS_CHANGE_REQ)\n\t\t\treturn false;\n\n\t\t/* Bump the counter */\n\t\tpro = cur + GRACE_STATUS_REF_INCREMENT;\n\t\told = __sync_val_compare_and_swap(&grace_status, cur, pro);\n\t} while (old != cur);\n\treturn true;\n}\n\n/*\n * Put grace status. If the refcount goes to zero, and a change was requested,\n * then wake the reaper thread to do its thing.\n */\nvoid nfs_put_grace_status(void)\n{\n\tuint32_t cur;\n\n\tcur = __sync_fetch_and_sub(&grace_status, GRACE_STATUS_REF_INCREMENT);\n\tif (cur & GRACE_STATUS_CHANGE_REQ &&\n\t    !(cur >> GRACE_STATUS_COUNTER_SHIFT))\n\t\treaper_wake();\n}\n\n/**\n * Lift the grace period if it's still active.\n */\nstatic void\nnfs_lift_grace_locked(void)\n{\n\tuint32_t cur;\n\n\t/*\n\t * Caller must hold grace_mutex. Only the thread that actually sets\n\t * the value to 0 gets to clean up the recovery db.\n\t */\n\tif (nfs_in_grace()) {\n\t\tnfs_end_grace();\n\t\t__sync_synchronize();\n\t\t/* Now change the actual status */\n\t\tcur = __sync_and_and_fetch(&grace_status,\n\t\t\t~(GRACE_STATUS_ACTIVE|GRACE_STATUS_CHANGE_REQ));\n\t\tassert(!(cur & GRACE_STATUS_COUNT_MASK));\n\t\tLogEvent(COMPONENT_STATE, \"NFS Server Now NOT IN GRACE\");\n\t}\n}\n\n/*\n * Report our new state to the cluster\n */\nstatic void nfs4_set_enforcing(void)\n{\n\tif (recovery_backend->set_enforcing)\n\t\trecovery_backend->set_enforcing();\n}\n\n/**\n * @brief Start grace period\n *\n * This routine can be called due to server start/restart or from\n * failover code.  If this node is taking over for a node, that nodeid\n * will be passed to this routine inside of the grace start structure.\n *\n * @param[in] gsp Grace period start information\n */\nvoid nfs_start_grace(nfs_grace_start_t *gsp)\n{\n\tint ret;\n\tbool was_grace;\n\tuint32_t cur, old, pro;\n\n\tPTHREAD_MUTEX_lock(&grace_mutex);\n\n\tif (nfs_param.nfsv4_param.graceless) {\n\t\tnfs_lift_grace_locked();\n\t\tLogEvent(COMPONENT_STATE,\n\t\t\t \"NFS Server skipping GRACE (Graceless is true)\");\n\t\tgoto out;\n\t}\n\n\t/* grace should always be greater than or equal to lease time,\n\t * some clients are known to have problems with grace greater than 60\n\t * seconds Lease_Lifetime should be set to a smaller value for those\n\t * setups.\n\t *\n\t * Checks against the grace period are lockless, so we want to ensure\n\t * that the callers see the\n\t * Full barrier to ensure enforcement begins ASAP.\n\t */\n\n\t/*\n\t * Ensure there are no outstanding references to the current state of\n\t * grace. If there are, set flag indicating that a change has been\n\t * requested and that no more references will be handed out until it\n\t * takes effect.\n\t */\n\tret = clock_gettime(CLOCK_MONOTONIC, &current_grace);\n\tif (ret != 0) {\n\t\tLogCrit(COMPONENT_MAIN, \"Failed to get timestamp\");\n\t\tassert(0);\t/* if this is broken, we are toast so die */\n\t}\n\n\tcur = atomic_fetch_uint32_t(&grace_status);\n\tdo {\n\t\told = cur;\n\t\twas_grace = cur & GRACE_STATUS_ACTIVE;\n\n\t\t/* If we're already in a grace period then we're done */\n\t\tif (was_grace)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Are there outstanding refs? If so, then set the change req\n\t\t * flag and nothing else. If not, then clear the change req\n\t\t * flag and flip the active bit.\n\t\t */\n\t\tif (old & GRACE_STATUS_COUNT_MASK) {\n\t\t\tpro = old | GRACE_STATUS_CHANGE_REQ;\n\t\t} else {\n\t\t\tpro = old | GRACE_STATUS_ACTIVE;\n\t\t\tpro &= ~GRACE_STATUS_CHANGE_REQ;\n\t\t}\n\n\t\t/* If there are no changes, then we don't need to update */\n\t\tif (pro == old)\n\t\t\tbreak;\n\t\tcur = __sync_val_compare_and_swap(&grace_status, old, pro);\n\t} while (cur != old);\n\n\t/*\n\t * If we were not in a grace period before and there were still\n\t * references outstanding, then we can't do anything else.\n\t */\n\tif (!was_grace && (old & GRACE_STATUS_COUNT_MASK))\n\t\tgoto out;\n\n\t__sync_synchronize();\n\n\tif ((int)nfs_param.nfsv4_param.grace_period <\n\t\t(int)nfs_param.nfsv4_param.lease_lifetime) {\n\t\tLogWarn(COMPONENT_STATE,\n\t\t \"NFS Server GRACE duration should at least match LEASE period. Current configured values are GRACE(%d), LEASE(%d)\",\n\t\t (int)nfs_param.nfsv4_param.grace_period,\n\t\t (int)nfs_param.nfsv4_param.lease_lifetime);\n\t}\n\n\tLogEvent(COMPONENT_STATE, \"NFS Server Now IN GRACE, duration %d\",\n\t\t (int)nfs_param.nfsv4_param.grace_period);\n\n\t/* Set enforcing flag here */\n\tif (!was_grace)\n\t\tnfs4_set_enforcing();\n\n\t/*\n\t * If we're just starting the grace period, then load the\n\t * clid database. Don't load it however if we're extending the\n\t * existing grace period.\n\t */\n\tif (!gsp && !was_grace) {\n\t\tnfs4_recovery_load_clids(NULL);\n\t} else if (gsp && gsp->event != EVENT_JUST_GRACE) {\n\t\t/*\n\t\t * if called from failover code and given a nodeid, then this\n\t\t * node is doing a take over.  read in the client ids from the\n\t\t * failing node.\n\t\t */\n\t\tLogEvent(COMPONENT_STATE,\n\t\t\t \"NFS Server recovery event %d nodeid %d ip %s\",\n\t\t\t gsp->event, gsp->nodeid, gsp->ipaddr);\n\n\t\tif (gsp->event == EVENT_CLEAR_BLOCKED)\n\t\t\tcancel_all_nlm_blocked();\n\t\telse {\n\t\t\tnfs_release_nlm_state(gsp->ipaddr);\n\t\t\tif (gsp->event == EVENT_RELEASE_IP) {\n\t\t\t\tPTHREAD_MUTEX_unlock(&grace_mutex);\n\t\t\t\tnfs_release_v4_clients(gsp->ipaddr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnfs4_recovery_load_clids(gsp);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tPTHREAD_MUTEX_unlock(&grace_mutex);\n}\n\n/**\n * @brief Check if we are in the grace period\n *\n * @retval true if so.\n * @retval false if not.\n */\nbool nfs_in_grace(void)\n{\n\treturn atomic_fetch_uint32_t(&grace_status) & GRACE_STATUS_ACTIVE;\n}\n\n/**\n * @brief Enter the grace period if another node in the cluster needs it\n *\n * Singleton servers generally won't use this operation. Clustered servers\n * call this function to check whether another node might need a grace period.\n */\nvoid nfs_maybe_start_grace(void)\n{\n\tif (!nfs_in_grace() && recovery_backend->maybe_start_grace)\n\t\trecovery_backend->maybe_start_grace();\n}\n\n/**\n * @brief Are all hosts in cluster enforcing the grace period?\n *\n * Singleton servers always return true here since the only grace period that\n * matters is the local one. Clustered backends should check to make sure that\n * the whole cluster is in grace.\n */\nbool nfs_grace_enforcing(void)\n{\n\tif (recovery_backend->grace_enforcing)\n\t\treturn recovery_backend->grace_enforcing();\n\treturn true;\n}\n\n/**\n * @brief Is this host still a member of the cluster?\n *\n * Singleton servers are always considered to be cluster members. This call\n * is mainly for clustered servers, which may need to handle things differently\n * on a clean shutdown depending on whether they are still a member of the\n * cluster.\n */\nbool nfs_grace_is_member(void)\n{\n\tif (recovery_backend->is_member)\n\t\treturn recovery_backend->is_member();\n\treturn true;\n}\n\n/**\n * @brief Return nodeid for the server\n *\n * If the recovery backend specifies a nodeid, return it. If it does not\n * specify one, default to using the server's hostname.\n *\n * Returns 0 on success and fills out pnodeid. Caller must free the returned\n * value with gsh_free. Returns negative POSIX error code on error.\n */\nint nfs_recovery_get_nodeid(char **pnodeid)\n{\n\tint rc;\n\tlong maxlen;\n\tchar *nodeid = NULL;\n\n\tif (recovery_backend->get_nodeid) {\n\t\trc = recovery_backend->get_nodeid(&nodeid);\n\n\t\t/* Return error if we got one */\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* If we got a nodeid, then we're done */\n\t\tif (nodeid) {\n\t\t\t*pnodeid = nodeid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Either the backend doesn't support get_nodeid or it handed back a\n\t * NULL pointer. Just use hostname.\n\t */\n\tmaxlen = sysconf(_SC_HOST_NAME_MAX);\n\tnodeid = gsh_malloc(maxlen);\n\trc = gethostname(nodeid, maxlen);\n\tif (rc != 0) {\n\t\tLogEvent(COMPONENT_CLIENTID, \"gethostname failed: %d\", errno);\n\t\trc = -errno;\n\t\tgsh_free(nodeid);\n\t} else {\n\t\t*pnodeid = nodeid;\n\t}\n\treturn rc;\n}\n\nvoid nfs_try_lift_grace(void)\n{\n\tbool in_grace = true;\n\tint32_t rc_count = 0;\n\tuint32_t cur, old, pro;\n\n\t/* Already lifted? Just return */\n\tif (!(atomic_fetch_uint32_t(&grace_status) & GRACE_STATUS_ACTIVE))\n\t\treturn;\n\n\t/*\n\t * If we know there are no NLM clients, then we can consider the grace\n\t * period done when all previous clients have sent a RECLAIM_COMPLETE.\n\t */\n\tPTHREAD_MUTEX_lock(&grace_mutex);\n\trc_count = atomic_fetch_int32_t(&reclaim_completes);\n\tif (!nfs_param.core_param.enable_NLM)\n\t\tin_grace = (rc_count != clid_count);\n\n\t/* Otherwise, wait for the timeout */\n\tif (in_grace) {\n\t\tstruct timespec timeout, now;\n\t\tint ret = clock_gettime(CLOCK_MONOTONIC, &now);\n\n\t\tif (ret != 0) {\n\t\t\tLogCrit(COMPONENT_MAIN, \"Failed to get timestamp\");\n\t\t\tassert(0);\n\t\t}\n\n\t\ttimeout = current_grace;\n\t\ttimeout.tv_sec += nfs_param.nfsv4_param.grace_period;\n\t\tin_grace = gsh_time_cmp(&timeout, &now) > 0;\n\t}\n\n\t/*\n\t * Ok, we're basically ready to lift. Ensure there are no outstanding\n\t * references to the current status of the grace period. If there are,\n\t * then set the flag saying that there is an upcoming change.\n\t */\n\n\t/*\n\t * Can we lift the grace period now? If there are any outstanding refs,\n\t * then just set the grace_change_req flag to indicate that we don't\n\t * want to hand any more refs out. Otherwise, we try to lift.\n\t *\n\t * Clustered backends may need extra checks before they can do so. If\n\t * the backend does not implement a try_lift_grace operation, then we\n\t * assume there are no external conditions and that it's always ok.\n\t */\n\tif (!in_grace) {\n\t\tcur = atomic_fetch_uint32_t(&grace_status);\n\t\tdo {\n\t\t\told = cur;\n\n\t\t\t/* Are we already done? Exit if so */\n\t\t\tif (!(cur & GRACE_STATUS_ACTIVE)) {\n\t\t\t\tPTHREAD_MUTEX_unlock(&grace_mutex);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Record that a change has now been requested */\n\t\t\tpro = old | GRACE_STATUS_CHANGE_REQ;\n\t\t\tif (pro == old)\n\t\t\t\tbreak;\n\t\t\tcur = __sync_val_compare_and_swap(&grace_status,\n\t\t\t\t\t\t\t  old, pro);\n\t\t} while (cur != old);\n\n\t\t/* Otherwise, go ahead and lift if we can */\n\t\tif (!(old & GRACE_STATUS_COUNT_MASK) &&\n\t\t    (!recovery_backend->try_lift_grace ||\n\t\t     recovery_backend->try_lift_grace()))\n\t\t\tnfs_lift_grace_locked();\n\t}\n\tPTHREAD_MUTEX_unlock(&grace_mutex);\n}\n\nstatic pthread_cond_t enforcing_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_mutex_t enforcing_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n/* Poll every 5s, just in case we miss the wakeup for some reason */\nvoid nfs_wait_for_grace_enforcement(void)\n{\n\tnfs_grace_start_t gsp = { .event = EVENT_JUST_GRACE };\n\n\tpthread_mutex_lock(&enforcing_mutex);\n\tnfs_try_lift_grace();\n\twhile (nfs_in_grace() && !nfs_grace_enforcing()) {\n\t\tstruct timespec\ttimeo = { .tv_sec = time(NULL) + 5,\n\t\t\t\t\t  .tv_nsec = 0 };\n\n\t\tpthread_cond_timedwait(&enforcing_cond, &enforcing_mutex,\n\t\t\t\t\t\t&timeo);\n\n\t\tpthread_mutex_unlock(&enforcing_mutex);\n\t\tnfs_start_grace(&gsp);\n\t\tnfs_try_lift_grace();\n\t\tpthread_mutex_lock(&enforcing_mutex);\n\t}\n\tpthread_mutex_unlock(&enforcing_mutex);\n}\n\nvoid nfs_notify_grace_waiters(void)\n{\n\tpthread_mutex_lock(&enforcing_mutex);\n\tpthread_cond_broadcast(&enforcing_cond);\n\tpthread_mutex_unlock(&enforcing_mutex);\n}\n\n/**\n * @brief Create an entry in the recovery directory\n *\n * This entry allows the client to reclaim state after a server\n * reboot/restart.\n *\n * @param[in] clientid Client record\n */\nvoid nfs4_add_clid(nfs_client_id_t *clientid)\n{\n\tPTHREAD_MUTEX_lock(&clientid->cid_mutex);\n\trecovery_backend->add_clid(clientid);\n\tPTHREAD_MUTEX_unlock(&clientid->cid_mutex);\n}\n\n/**\n * @brief Remove a client entry from the recovery directory\n *\n * This function would be called when a client expires.\n *\n */\nvoid nfs4_rm_clid(nfs_client_id_t *clientid)\n{\n\tPTHREAD_MUTEX_lock(&clientid->cid_mutex);\n\trecovery_backend->rm_clid(clientid);\n\tPTHREAD_MUTEX_unlock(&clientid->cid_mutex);\n}\n\nstatic bool check_clid(nfs_client_id_t *clientid, clid_entry_t *clid_ent)\n{\n\tbool ret = false;\n\n\n\tLogDebug(COMPONENT_CLIENTID, \"compare %s to %s\",\n\t\t clientid->cid_recov_tag, clid_ent->cl_name);\n\n\tif (clientid->cid_recov_tag &&\n\t    !strncmp(clientid->cid_recov_tag,\n\t\t     clid_ent->cl_name, PATH_MAX))\n\t\tret = true;\n\n\treturn ret;\n}\n\n/**\n * @brief Determine whether or not this client may reclaim state\n *\n * If the server is not in grace period, then no reclaim can happen.\n *\n * @param[in] clientid Client record\n */\nvoid  nfs4_chk_clid_impl(nfs_client_id_t *clientid, clid_entry_t **clid_ent_arg)\n{\n\tstruct glist_head *node;\n\tclid_entry_t *clid_ent;\n\t*clid_ent_arg = NULL;\n\n\tLogDebug(COMPONENT_CLIENTID, \"chk for %lu\",\n\t\t clientid->cid_clientid);\n\n\t/* If there were no clients at time of restart, we're done */\n\tif (clid_count == 0)\n\t\treturn;\n\n\t/*\n\t * loop through the list and try to find this client. If we\n\t * find it, mark it to allow reclaims.\n\t */\n\tPTHREAD_MUTEX_lock(&clientid->cid_mutex);\n\tglist_for_each(node, &clid_list) {\n\t\tclid_ent = glist_entry(node, clid_entry_t, cl_list);\n\t\tif (check_clid(clientid, clid_ent)) {\n\t\t\tif (isDebug(COMPONENT_CLIENTID)) {\n\t\t\t\tchar str[LOG_BUFF_LEN] = \"\\0\";\n\t\t\t\tstruct display_buffer dspbuf = {\n\t\t\t\t\tsizeof(str), str, str};\n\n\t\t\t\tdisplay_client_id_rec(&dspbuf, clientid);\n\n\t\t\t\tLogFullDebug(COMPONENT_CLIENTID,\n\t\t\t\t\t     \"Allowed to reclaim ClientId %s\",\n\t\t\t\t\t     str);\n\t\t\t}\n\t\t\tclientid->cid_allow_reclaim = true;\n\t\t\t*clid_ent_arg = clid_ent;\n\t\t\tbreak;\n\t\t}\n\t}\n\tPTHREAD_MUTEX_unlock(&clientid->cid_mutex);\n}\n\nvoid  nfs4_chk_clid(nfs_client_id_t *clientid)\n{\n\tclid_entry_t *dummy_clid_ent;\n\n\tPTHREAD_MUTEX_lock(&grace_mutex);\n\tnfs4_chk_clid_impl(clientid, &dummy_clid_ent);\n\tPTHREAD_MUTEX_unlock(&grace_mutex);\n}\n\n/**\n * @brief Load clients for recovery\n *\n * @param[in] nodeid Node, on takeover\n *\n * Caller must hold grace_mutex.\n */\nstatic void nfs4_recovery_load_clids(nfs_grace_start_t *gsp)\n{\n\tLogDebug(COMPONENT_STATE, \"Load recovery cli %p\", gsp);\n\n\t/* A NULL gsp pointer indicates an initial startup grace period */\n\tif (gsp == NULL)\n\t\tnfs4_cleanup_clid_entries();\n\trecovery_backend->recovery_read_clids(gsp, nfs4_add_clid_entry,\n\t\t\t\t\t\tnfs4_add_rfh_entry);\n}\n\n#ifdef USE_RADOS_RECOV\nstatic struct {\n\tvoid *dl;\n\tvoid (*kv_init)(struct nfs4_recovery_backend **);\n\tvoid (*ng_init)(struct nfs4_recovery_backend **);\n\tvoid (*cluster_init)(struct nfs4_recovery_backend **);\n\tint (*load_config_from_parse)(config_file_t,\n\t\t\t\t      struct config_error_type *);\n} rados = { NULL,};\n\nstatic int load_rados_recov(void)\n{\n\trados.dl = dlopen(\"libganesha_rados_recov.so\",\n#if defined(LINUX) && !defined(SANITIZE_ADDRESS)\n\t\t\t  RTLD_NOW | RTLD_LOCAL | RTLD_DEEPBIND);\n#elif defined(FREEBSD) || defined(SANITIZE_ADDRESS)\n\t\t\t  RTLD_NOW | RTLD_LOCAL);\n#endif\n\n\tif (rados.dl) {\n\t\trados.kv_init = dlsym(rados.dl, \"rados_kv_backend_init\");\n\t\trados.ng_init = dlsym(rados.dl, \"rados_ng_backend_init\");\n\t\trados.cluster_init = dlsym(rados.dl,\n\t\t\t\t\t   \"rados_cluster_backend_init\");\n\t\trados.load_config_from_parse = dlsym(rados.dl,\n\t\t\t\t\t   \"rados_load_config_from_parse\");\n\n\t\tif (!rados.kv_init || !rados.ng_init || !rados.cluster_init ||\n\t\t    !rados.load_config_from_parse) {\n\t\t\tdlclose(rados.dl);\n\t\t\trados.dl = NULL;\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif\n\nconst char *recovery_backend_str(enum recovery_backend recovery_backend)\n{\n\tswitch (recovery_backend) {\n\tcase RECOVERY_BACKEND_FS:\n\t\treturn \"fs\";\n\tcase RECOVERY_BACKEND_FS_NG:\n\t\treturn \"fs_ng\";\n\tcase RECOVERY_BACKEND_RADOS_KV:\n\t\treturn \"rados_kv\";\n\tcase RECOVERY_BACKEND_RADOS_NG:\n\t\treturn \"rados_ng\";\n\tcase RECOVERY_BACKEND_RADOS_CLUSTER:\n\t\treturn \"rados_cluster\";\n\t}\n\n\treturn \"Unknown recovery backend\";\n}\n\n/**\n * @brief Create the recovery directory\n *\n * The recovery directory may not exist yet, so create it.  This\n * should only need to be done once (if at all).  Also, the location\n * of the directory could be configurable.\n */\nint nfs4_recovery_init(void)\n{\n\tLogInfo(COMPONENT_CLIENTID, \"Recovery Backend Init for %s\",\n\t\trecovery_backend_str(nfs_param.nfsv4_param.recovery_backend));\n\n\tswitch (nfs_param.nfsv4_param.recovery_backend) {\n\tcase RECOVERY_BACKEND_FS:\n\t\tfs_backend_init(&recovery_backend);\n\t\tbreak;\n\tcase RECOVERY_BACKEND_FS_NG:\n\t\tfs_ng_backend_init(&recovery_backend);\n\t\tbreak;\n#ifdef USE_RADOS_RECOV\n\tcase RECOVERY_BACKEND_RADOS_KV:\n\t\trados.kv_init(&recovery_backend);\n\t\tbreak;\n\tcase RECOVERY_BACKEND_RADOS_NG:\n\t\trados.ng_init(&recovery_backend);\n\t\tbreak;\n\tcase RECOVERY_BACKEND_RADOS_CLUSTER:\n\t\trados.cluster_init(&recovery_backend);\n\t\tbreak;\n#else\n\tcase RECOVERY_BACKEND_RADOS_KV:\n\tcase RECOVERY_BACKEND_RADOS_NG:\n\tcase RECOVERY_BACKEND_RADOS_CLUSTER:\n#endif\n\tdefault:\n\t\tLogCrit(COMPONENT_CLIENTID, \"Unsupported Backend %s\",\n\t\t\trecovery_backend_str(\n\t\t\t\tnfs_param.nfsv4_param.recovery_backend));\n\t\treturn -ENOENT;\n\t}\n\n\treturn recovery_backend->recovery_init();\n}\n\n/**\n * @brief Shut down the recovery backend\n *\n * Shut down the recovery backend, cleaning up any clients or tracking\n * structures in preparation for server shutdown.\n */\nvoid nfs4_recovery_shutdown(void)\n{\n\tif (recovery_backend->recovery_shutdown)\n\t\trecovery_backend->recovery_shutdown();\n#ifdef USE_RADOS_RECOV\n\tif (rados.dl)\n\t\t(void) dlclose(rados.dl);\n\trados.dl = NULL;\n#endif\n}\n\n/**\n * @brief Clean up recovery directory\n */\nvoid nfs_end_grace(void)\n{\n\trecovery_backend->end_grace();\n}\n\n/**\n * @brief Record revoked filehandle under the client.\n *\n * @param[in] clientid Client record\n * @param[in] filehandle of the revoked file.\n */\nvoid nfs4_record_revoke(nfs_client_id_t *delr_clid, nfs_fh4 *delr_handle)\n{\n\t/* A client's lease is reserved while recalling or revoking a\n\t * delegation which means the client will not expire until we\n\t * complete this revoke operation. The only exception is when\n\t * the reaper thread revokes delegations of an already expired\n\t * client!\n\t */\n\tPTHREAD_MUTEX_lock(&delr_clid->cid_mutex);\n\tif (delr_clid->cid_confirmed == EXPIRED_CLIENT_ID) {\n\t\t/* Called from reaper thread, no need to record\n\t\t * revoked file handles for an expired client.\n\t\t */\n\t\tPTHREAD_MUTEX_unlock(&delr_clid->cid_mutex);\n\t\treturn;\n\t}\n\trecovery_backend->add_revoke_fh(delr_clid, delr_handle);\n\tPTHREAD_MUTEX_unlock(&delr_clid->cid_mutex);\n}\n\n/**\n * @brief Decides if it is allowed to reclaim a given delegation\n *\n * @param[in] clientid Client record\n * @param[in] filehandle of the revoked file.\n * @retval true if allowed and false if not.\n *\n */\nbool nfs4_check_deleg_reclaim(nfs_client_id_t *clid, nfs_fh4 *fhandle)\n{\n\tchar rhdlstr[NAME_MAX];\n\tstruct glist_head *node;\n\trdel_fh_t *rfh_entry;\n\tclid_entry_t *clid_ent;\n\tint b64ret;\n\tbool retval = true;\n\n\t/* Convert nfs_fh4_val into base64 encoded string */\n\tb64ret = base64url_encode(fhandle->nfs_fh4_val, fhandle->nfs_fh4_len,\n\t\t\t\t  rhdlstr, sizeof(rhdlstr));\n\tassert(b64ret != -1);\n\n\tPTHREAD_MUTEX_lock(&grace_mutex);\n\tnfs4_chk_clid_impl(clid, &clid_ent);\n\tif (clid_ent) {\n\t\tglist_for_each(node, &clid_ent->cl_rfh_list) {\n\t\t\trfh_entry = glist_entry(node, rdel_fh_t, rdfh_list);\n\t\t\tassert(rfh_entry != NULL);\n\t\t\tif (!strcmp(rhdlstr, rfh_entry->rdfh_handle_str)) {\n\t\t\t\tLogFullDebug(COMPONENT_CLIENTID,\n\t\t\t\t\t\"Can't reclaim revoked fh:%s\",\n\t\t\t\t\trfh_entry->rdfh_handle_str);\n\t\t\t\tretval = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tPTHREAD_MUTEX_unlock(&grace_mutex);\n\tLogFullDebug(COMPONENT_CLIENTID, \"Returning %s\",\n\t\t     retval ? \"TRUE\" : \"FALSE\");\n\treturn retval;\n}\n\n#ifdef _USE_NLM\n/**\n * @brief Release NLM state\n */\nstatic void nlm_releasecall(struct fridgethr_context *ctx)\n{\n\tstate_nsm_client_t *nsm_cp;\n\tstate_status_t err;\n\n\tnsm_cp = ctx->arg;\n\terr = state_nlm_notify(nsm_cp, false, 0);\n\tif (err != STATE_SUCCESS)\n\t\tLogDebug(COMPONENT_STATE,\n\t\t\t\"state_nlm_notify failed with %d\",\n\t\t\terr);\n\tdec_nsm_client_ref(nsm_cp);\n}\n#endif /* _USE_NLM */\n\nvoid extractv4(char *ipv6, char *ipv4, size_t size)\n{\n\tchar *token, *saveptr;\n\tchar *delim = \":\";\n\n\ttoken = strtok_r(ipv6, delim, &saveptr);\n\twhile (token != NULL) {\n\t\t/* IPv4 delimiter is '.' */\n\t\tif (strchr(token, '.') != NULL) {\n\t\t\t(void) strlcpy(ipv4, token, size);\n\t\t\treturn;\n\t\t}\n\t\ttoken = strtok_r(NULL, delim, &saveptr);\n\t}\n\t/* failed, copy a null string */\n\tipv4[0] = '\\0';\n}\n\nbool ip_str_match(char *release_ip, char *server_ip)\n{\n\tbool ripv6, sipv6;\n\tchar ipv4[SOCK_NAME_MAX];\n\n\t/* IPv6 delimiter is ':' */\n\tripv6 = (strchr(release_ip, ':') != NULL);\n\tsipv6 = (strchr(server_ip, ':') != NULL);\n\n\tif (ripv6) {\n\t\tif (sipv6)\n\t\t\treturn !strcmp(release_ip, server_ip);\n\t\telse {\n\t\t\t/* extract v4 addr from release_ip*/\n\t\t\textractv4(release_ip, ipv4, sizeof(ipv4));\n\t\t\treturn !strcmp(ipv4, server_ip);\n\t\t}\n\t} else {\n\t\tif (sipv6) {\n\t\t\t/* extract v4 addr from server_ip*/\n\t\t\textractv4(server_ip, ipv4, sizeof(ipv4));\n\t\t\treturn !strcmp(ipv4, release_ip);\n\t\t}\n\t}\n\t/* Both are ipv4 addresses */\n\treturn !strcmp(release_ip, server_ip);\n}\n\n/**\n * @brief Release all NLM state\n */\nstatic void nfs_release_nlm_state(char *release_ip)\n{\n#ifdef _USE_NLM\n\thash_table_t *ht = ht_nlm_client;\n\tstate_nlm_client_t *nlm_cp;\n\tstate_nsm_client_t *nsm_cp;\n\tstruct rbt_head *head_rbt;\n\tstruct rbt_node *pn;\n\tstruct hash_data *pdata;\n\tstate_status_t state_status;\n\tchar serverip[SOCK_NAME_MAX];\n\tint i;\n\n\tLogDebug(COMPONENT_STATE, \"Release all NLM locks\");\n\n\tcancel_all_nlm_blocked();\n\n\t/* walk the client list and call state_nlm_notify */\n\tfor (i = 0; i < ht->parameter.index_size; i++) {\n\t\tPTHREAD_RWLOCK_wrlock(&ht->partitions[i].lock);\n\t\thead_rbt = &ht->partitions[i].rbt;\n\t\t/* go through all entries in the red-black-tree */\n\t\tRBT_LOOP(head_rbt, pn) {\n\t\t\tpdata = RBT_OPAQ(pn);\n\t\t\tnlm_cp = (state_nlm_client_t *) pdata->val.addr;\n\n\t\t\tif (sprint_sockip(&nlm_cp->slc_server_addr,\n\t\t\t\t\t  serverip, sizeof(serverip)) &&\n\t\t\t    ip_str_match(release_ip, serverip)) {\n\t\t\t\tnsm_cp = nlm_cp->slc_nsm_client;\n\t\t\t\tinc_nsm_client_ref(nsm_cp);\n\t\t\t\tstate_status = fridgethr_submit(\n\t\t\t\t\t\tstate_async_fridge,\n\t\t\t\t\t\tnlm_releasecall,\n\t\t\t\t\t\tnsm_cp);\n\t\t\t\tif (state_status != STATE_SUCCESS) {\n\t\t\t\t\tdec_nsm_client_ref(nsm_cp);\n\t\t\t\t\tLogCrit(COMPONENT_STATE,\n\t\t\t\t\t\t\"failed to submit nlm release thread \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBT_INCREMENT(pn);\n\t\t}\n\t\tPTHREAD_RWLOCK_unlock(&ht->partitions[i].lock);\n\t}\n#endif /* _USE_NLM */\n}\n\nstatic int ip_match(char *ip, nfs_client_id_t *cid)\n{\n\tchar *haystack;\n\tchar *value = cid->cid_client_record->cr_client_val;\n\tint len = cid->cid_client_record->cr_client_val_len;\n\n\tLogDebug(COMPONENT_STATE, \"NFS Server V4 match ip %s with (%.*s)\",\n\t\t ip, len, value);\n\n\tif (strlen(ip) == 0)\t/* No IP all are matching */\n\t\treturn 1;\n\n\thaystack = alloca(len + 1);\n\tmemcpy(haystack, value, len);\n\thaystack[len] = '\\0';\n\tif (strstr(haystack, ip) != NULL)\n\t\treturn 1;\n\n\treturn 0;\t\t/* no match */\n}\n\n/*\n * try to find a V4 clients which match the IP we are releasing.\n * only search the confirmed clients, unconfirmed clients won't\n * have any state to release.\n */\nstatic void nfs_release_v4_clients(char *ip)\n{\n\thash_table_t *ht = ht_confirmed_client_id;\n\tstruct rbt_head *head_rbt;\n\tstruct rbt_node *pn;\n\tstruct hash_data *pdata;\n\tnfs_client_id_t *cp;\n\tnfs_client_record_t *recp;\n\tint i;\n\n\tLogEvent(COMPONENT_STATE, \"NFS Server V4 recovery release ip %s\", ip);\n\n\t/* go through the confirmed clients looking for a match */\n\tfor (i = 0; i < ht->parameter.index_size; i++) {\n\t\thead_rbt = &ht->partitions[i].rbt;\n\nrestart:\n\t\tPTHREAD_RWLOCK_wrlock(&ht->partitions[i].lock);\n\n\t\t/* go through all entries in the red-black-tree */\n\t\tRBT_LOOP(head_rbt, pn) {\n\t\t\tpdata = RBT_OPAQ(pn);\n\n\t\t\tcp = (nfs_client_id_t *) pdata->val.addr;\n\t\t\tPTHREAD_MUTEX_lock(&cp->cid_mutex);\n\t\t\tif ((cp->cid_confirmed == CONFIRMED_CLIENT_ID)\n\t\t\t     && ip_match(ip, cp)) {\n\t\t\t\tinc_client_id_ref(cp);\n\n\t\t\t\t/* Take a reference to the client record\n\t\t\t\t * before we drop cid_mutex. client record\n\t\t\t\t * may be decoupled, so check if it is still\n\t\t\t\t * coupled!\n\t\t\t\t */\n\t\t\t\trecp = cp->cid_client_record;\n\t\t\t\tif (recp)\n\t\t\t\t\tinc_client_record_ref(recp);\n\n\t\t\t\tPTHREAD_MUTEX_unlock(&cp->cid_mutex);\n\n\t\t\t\tPTHREAD_RWLOCK_unlock(&ht->partitions[i].lock);\n\n\t\t\t\t/* nfs_client_id_expire requires cr_mutex\n\t\t\t\t * if not decoupled alread\n\t\t\t\t */\n\t\t\t\tif (recp)\n\t\t\t\t\tPTHREAD_MUTEX_lock(&recp->cr_mutex);\n\n\t\t\t\tnfs_client_id_expire(cp, true);\n\n\t\t\t\tif (recp) {\n\t\t\t\t\tPTHREAD_MUTEX_unlock(&recp->cr_mutex);\n\t\t\t\t\tdec_client_record_ref(recp);\n\t\t\t\t}\n\n\t\t\t\tdec_client_id_ref(cp);\n\t\t\t\tgoto restart;\n\n\t\t\t} else {\n\t\t\t\tPTHREAD_MUTEX_unlock(&cp->cid_mutex);\n\t\t\t}\n\t\t\tRBT_INCREMENT(pn);\n\t\t}\n\t\tPTHREAD_RWLOCK_unlock(&ht->partitions[i].lock);\n\t}\n}\n\nint load_recovery_param_from_conf(config_file_t parse_tree,\n\t\t\t\t  struct config_error_type *err_type)\n{\n\tswitch (nfs_param.nfsv4_param.recovery_backend) {\n\tcase RECOVERY_BACKEND_FS:\n\tcase RECOVERY_BACKEND_FS_NG:\n\t\treturn 0;\n\n\tcase RECOVERY_BACKEND_RADOS_KV:\n\tcase RECOVERY_BACKEND_RADOS_NG:\n\tcase RECOVERY_BACKEND_RADOS_CLUSTER:\n#ifdef USE_RADOS_RECOV\n\t\t/*\n\t\t * see if we actually need the rados_recovery shlib loaded\n\t\t *\n\t\t * we are here because the config (explicitly) calls\n\t\t * for this recovery class. If we can't do it because\n\t\t * the (package with the) libganesha_rados_recovery\n\t\t * library wasn't installed, then we should return\n\t\t * an error and eventually die.\n\t\t */\n\t\tif (!rados.dl && load_rados_recov() < 0) {\n\t\t\tLogCrit(COMPONENT_CLIENTID,\n\t\t\t\t\"Failed to load Backend %s. Please install the appropriate package\",\n\t\t\t\trecovery_backend_str(\n\t\t\t\t       nfs_param.nfsv4_param.recovery_backend));\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn rados.load_config_from_parse(parse_tree, err_type);\n#endif\n\tdefault:\n\t\tLogCrit(COMPONENT_CLIENTID, \"Unsupported Backend %s\",\n\t\t\trecovery_backend_str(\n\t\t\t\tnfs_param.nfsv4_param.recovery_backend));\n\t}\n\n\treturn -1;\n}\n\n/** @} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/include/fsal_api.h": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n * -------------\n */\n\n/**\n * @defgroup FSAL File-System Abstraction Layer\n * @{\n */\n\n/**\n * @file fsal_api.h\n * @author Jim Lieb <jlieb@panasas.com>\n * @brief The object-oriented FSAL API\n */\n\n#ifndef FSAL_API\n#define FSAL_API\n\n#include \"fsal_types.h\"\n#include \"fsal_pnfs.h\"\n#include \"sal_shared.h\"\n#include \"config_parsing.h\"\n#include \"avltree.h\"\n#include \"abstract_atomic.h\"\n\n/**\n** Forward declarations to resolve circular dependency conflicts\n*/\nstruct gsh_client;\nstruct gsh_export;\nstruct fsal_up_vector;\t\t/* From fsal_up.h */\nstruct state_t;\n\n/**\n * @page newapi New FSAL API\n *\n * @section structs Public and Private Data Structures\n *\n * Shared FSAL data structures have two definitions, one that is\n * global and passed around by the core, the other private which\n * included the global definition within it.\n *\n * All these data structures are passed back to the core with the\n * global pointer and dereferenced with container_of within the FSAL\n * itself like so:\n *\n * @code{.c}\n *\n * struct private_obj_handle\n * {\n *         [private stuff]\n *         struct fsal_obj_handle *pub;\n * }\n *\n * fsal_getattr(struct fsal_obj_handle handle_pub)\n * {\n *         struct private_obj_handle *handle;\n *\n *         handle = container_of(handle_pub,\n *                               struct private_obj_handle, pub);\n *         [ do stuff ]\n * }\n * @endcode\n *\n * The @c container_of macro takes the public pointer/handle @c\n * handle_pub which is indicated as the element @c pub of structure\n * type @c private_obj_handle.  Throughout the function, where private\n * elements are dereferenced, the @c handle pointer is used.  The @c\n * handle_pub pointer is used in the public case.\n *\n * @section usage Object usage\n *\n * Mutex locks and reference counts are used to manage both concurrent\n * usage and state.  The reference counts are use to determine when\n * the object is \"free\".  Current use is for managing ref counts and\n * lists.  This will be expanded, though many cases are already\n * handled by the locks in Cache inode.\n *\n * Since we cannot create objects out of thin air, there is an order\n * based on one object being the \"context\" in which the other is\n * created.  In other words, a @c fsal_export is created from the @c\n * fsal_module that connects it to the backing store (filesystem). The\n * same applies to a @c fsal_obj_handle that only makes sense for a\n * specific 'fsal_export'.\n *\n * When an object is created, it is returned with a reference already\n * taken.  The callee of the creating method must then either keep a\n * persistent reference to it or @c put it back.  For example, a @c\n * fsal_export gets created for each export in the configuration.  A\n * pointer to it gets saved in @c gsh_export and it has a reference\n * to reflect this.  It is now safe to use it to do a @c lookup which\n * will return a @c fsal_obj_handle which can then be kept in a cache\n * inode entry.  If we had done a @c put on the export, it could be\n * freed at any point and make a @c lookup using it unsafe.\n *\n * In addition to a reference count, object that create other objects\n * have a list of all the objects they create.  This serves two\n * purposes. The obvious case is to keep the object \"busy\" until all\n * of its children are freed.  Second, it provides a means to visit\n * all of the objects it creates.\n *\n * Every object has a pointer to its parent.  This is used for such\n * things as managing the object list and for calling methods on the\n * parent.\n *\n * @section versioning Versioning\n *\n * One intent in this API is to be able to support fsals that are built\n * out-of-tree and possibly out of synch with the core of Ganesha.  This\n * is managed by version numbers in this file that are validated at load\n * time for the fsal.  There are major and minor version numbers which are\n * monotonically increasing numbers ( V1 < V2 means V2 is newer).\n *\n * API guarantee:\n *\n * * If major version numbers differ, the fsal will not be loaded because\n *   the api has changed enough to make it unsafe.\n *\n * * If the major versions are equal, the minor version determines loadability.\n *\n *   - A fsal that is older than the Ganesha core can safely load and run.\n *\n *   - A fsal that is newer than the Ganesha core is not safe and will not\n *     be loaded.\n *\n *\n * @section vector Operation Vectors\n *\n * Each structure carries with it an @c ops pointer.  Default\n * operation vectors are created at FSAL moduel initialziation time,\n * and may be overridden there.  Individual exports or handles may\n * have different operations vectors, but they should all be derived\n * from the module operations vector.\n *\n *\tThis vector is used to access methods e.g.:\n *\n * @code{.c}\n * exp_hdl->exp_ops.lookup(exp_hdl, name, ...);\n * @endcode\n *\n * Note that exp_hdl is used to dereference the method and it is also\n * *always* the first argument to the method/function.  Think of it as\n * the 'this' argument.\n *\n * @section Operation Context\n *\n * Protocol operations have lots of state such as user creds, the\n * export currently in use etc.  Rather than pass all this down the\n * stack we take advantage of the design decision that a protocol\n * operation runs to completion in the thread that dequeued the\n * request from the RPC.  All of the operation state (other than\n * some intermediate results passed as function args) are pointed\n * to by the thread local 'op_ctx'.  This will always point to a\n * valid and initialized 'struct req_op_context'.\n *\n *\tMethod code can reference through 'op_ctx' e.g.\n *\n * @code{.c}\n * if (op_ctx->req_type == 9P) { ... }\n * @endcode\n *\n */\n\n/**\n * @page handles File-Handles and You\n *\n * Overview\n * ========\n *\n * In the FSAL, file handles can take four forms.  There is the full,\n * internal handle structure, compose of the @c fsal_obj_handle and\n * the FSAL-private structure that contains it.\n *\n * There is the wire-handle, the FSAL-generated portion of the\n * file handles exchanged between Ganesha and its clients through the\n * FS protocol.  The wire-handle should contain everything necessary\n * to find and use the file even if the file has been completely\n * purged from cache or Ganesha has restarted from nothing.  There may\n * be multiple wire-handles per @c fsal_obj_handle.  The wire-handle\n * is produced by the @c handle_to_wire method on @c fsal_obj_handle.\n * FSALs can produce big endian or little endian wire-handles depending\n * on the architecture.\n *\n * A host-handle is a verion of the wire handle in host endian format.  It is\n * produced from wire-handle by @c wire_to_host to the host's native endian\n * type.  @c fsal_export operation @c create_handle produces a new @c\n * fsal_obj_handle from a host-handle.\n *\n * Finally, there is the handle-key, a portion of the handle that contains\n * all and only information that uniquely identifies the object within\n * the entire FSAL (it is insufficient if it only identifies it within\n * the export or within a filesystem.)  There are two functions that\n * generate a handle-key, one is the @c host_to_key method on @c\n * fsal_export.  It is used to get the key from a host-handle so that\n * it can be looked up in the cache.  The other is @c handle_to_key on\n * @c fsal_obj_handle.  This is used after lookup or some other\n * operation that produces a @c fsal_obj_handle so that it can be\n * stored or looked up in the cache.\n *\n * The invariant to be maintained is that given an @c fsal_obj_handle,\n * obj_hdl, exp_ops.host_to_key(wire_to_host(handle_to_wire(obj_hdl)))\n * is equal to obj_ops->handle_to_key(obj_hdl).\n *\n * History and Details\n * ===================\n *\n * The terminology is confusing here.  The old function names were\n * kept (up to a point), but the semantics differ in ways both subtle\n * and catastrophic. Making matters worse, that the first FSAL written\n * was VFS, where the internal @c file_handle for the syscalls is the\n * whole of the key, opaque, and syscall arg.  This does not imply any\n * equivalence.\n *\n * In the old regime, the only place available to store _anything_ was\n * the handle array in @c cache_entry_t.  People overloaded it with\n * all kinds of rubbish as a result, and the wire-handle, the\n * handle-key, and other stuff get mushed together.  To sort things\n * out,\n *\n * 1. The wire-handle opaque _must_ be enough to re-acquire the cache\n *    entry and its associated @c fsal_obj_handle.  Other than that,\n *    it doesn't matter a whit. The client treats the whole protocol\n *    handle (including what is in the opaque) as an opaque token.\n *\n * 2. The purpose of the @c export_id in the protocol \"handle\" is to\n *    locate the FSAL that knows what is inside the opaque.  The @c\n *    wire_to_host is an export method for that purpose.  It should\n *    be able to take the wire-handle opaque and translate it into\n *    a host-handle. handle-key should be derived from @c host_to_key\n *    that MDCACHE can use to find an entry.\n *\n * 3. OBSOLETE - cache_inode_get takes an fh_desc argument which is not a\n *    handle but a _key_.  It is used to generate the hash and to do\n *    the secondary key compares.  That is all it is used for.  The\n *    end result _must_ be a cache entry and its associated\n *    @c fsal_obj_handle. See how @c cache_inode_get transitions to\n *    cache_inode_new to see how this works.\n *\n * 4. The @c handle_to_key method, a @c fsal_obj_handle method,\n *    generates a key for the MDCACHE hash table from the contents\n *    of the @c fsal_obj_handle.  It is an analogue of fsal export\n *    @c host_to_key method. Note where it is called to see why it is\n *    there.\n *\n * 5. The @c handle_to_wire method is similar in scope but it is the\n *    inverse of @c wire_to_host.  It's job is to fill in the opaque\n *    part of a protocol handle.  Note that it gets passed a @c gsh_buffdesc\n *    that describes the full opaque storage in whatever protocol\n *    specific structure is used.  It's job is to put whatever it\n *    takes into the opaque so the second and third items in this list\n *    work.\n *\n * 6. Unlike the old API, a @c fsal_obj_handle is part of a FSAL\n *    private structure for the object.  Note that there is no handle\n *    member of this public structure.  The bits necessary to both\n *    create a wire handle and use a filesystem handle go into this\n *    private structure. You can put whatever is required into the\n *    private part.  Since both @c fsal_export and @c fsal_obj_handle\n *    have private object storage, you could even do things like have\n *    a container anchored in the export object that maps the\n *    FSAL-external handle to the filesystem data needed to talk to\n *    the filesystem.  If you need more info to deal with handles\n *    differing due to hard-links, this is where you would put\n *    it.  You would also have some other context in this private data\n *    to do the right thing.  Just make sure there is a way to\n *    disambiguate the multiple cases.  We do have to observe UNIX\n *    semantics here.\n *\n * The upper layers don't care about the private handle data.  All\n * they want is to be able to get something out from the object\n * (result of a lookup) so it can find the object again later.  The\n * obvious case is what you describe in @c nfs[34]_FhandleToCache.  These\n * various methods make that happen.\n *\n */\n\n/**\n * @brief Major Version\n *\n * Increment this whenever any part of the existing API is changed,\n * e.g.  the argument list changed or a method is removed.\n *\n * Technically this should also change if the libganesha_nfsd.so exported API\n * changes.\n */\n\n#define FSAL_MAJOR_VERSION 10\n\n/**\n * @brief Minor Version\n *\n * Increment this whenever a new method is appended to the m_ops vector.\n * The remainder of the API is unchanged.\n *\n * If the major version is incremented, reset the minor to 0 (zero).\n *\n * If new members are appended to struct req_op_context (following its own\n * rules), increment the minor version\n */\n\n#define FSAL_MINOR_VERSION 0\n\n/* Forward references for object methods */\n\nstruct fsal_module;\nstruct fsal_export;\nstruct fsal_obj_handle;\nstruct fsal_filesystem;\nstruct fsal_pnfs_ds;\nstruct fsal_pnfs_ds_ops;\nstruct fsal_ds_handle;\nstruct fsal_dsh_ops;\n\n#ifndef SEEK_SET\n#define SEEK_SET 0\n#endif\n#ifndef SEEK_CUR\n#define SEEK_CUR 1\n#endif\n#ifndef SEEK_END\n#define SEEK_END 2\n#endif\n#ifndef SEEK_DATA\n#define SEEK_DATA 3\n#endif\n#ifndef SEEK_HOLE\n#define SEEK_HOLE 4\n#endif\n\nstruct io_info {\n\tcontents io_content;\n\tuint32_t io_advise;\n\tbool_t   io_eof;\n};\n\nstruct io_hints {\n\toffset4  offset;\n\tlength4  count;\n\tuint32_t hints;\n};\n\n/**\n * @brief request op context\n *\n * This is created early in the operation with the context of the\n * operation.  The difference between \"context\" and request parameters\n * or arguments is that the context is derived information such as\n * the resolved credentials, socket (network and client host) data\n * and other bits of environment associated with the request.  It gets\n * passed down the call chain only as far as it needs to go for the op\n * i.e. don't put it in the function/method proto \"just because\".\n *\n * The lifetime of this structure and all the data it points to is the\n * operation for V2,3 and the compound for V4+.  All elements and what\n * they point to are invariant for the lifetime.\n *\n * NOTE: This is an across-the-api shared structure.  It must survive with\n *       older consumers of its contents.  Future development can change\n *       this struct so long as it follows the rules:\n *\n *       1. New elements are appended at the end, never inserted in the middle.\n *\n *       2. This structure _only_ contains pointers and simple scalar values.\n *\n *       3. Changing an already defined struct pointer is strictly not allowed.\n *\n *       4. This struct is always passed by reference, never by value.\n *\n *       5. This struct is never copied/saved.\n *\n *       6. Code changes are first introduced in the core.  Assume the fsal\n *          module does not know and the code will still do the right thing.\n */\n\nstruct req_op_context {\n\tstruct user_cred *creds;\t/*< resolved user creds from request */\n\tstruct user_cred original_creds;\t/*< Saved creds */\n\tstruct group_data *caller_gdata;\n\tgid_t *caller_garray_copy;\t/*< Copied garray from AUTH_SYS */\n\tgid_t *managed_garray_copy;\t/*< Copied garray from managed gids */\n\tint\tcred_flags;\t\t/* Various cred flags */\n\tsockaddr_t *caller_addr;\t/*< IP connection info */\n\tconst uint64_t *clientid;\t/*< Client ID of caller, NULL if\n\t\t\t\t\t   unknown/not applicable. */\n\tuint32_t nfs_vers;\t/*< NFS protocol version of request */\n\tuint32_t nfs_minorvers;\t/*< NFSv4 minor version */\n\tuint32_t req_type;\t/*< request_type NFS | 9P */\n\tstruct gsh_client *client;\t/*< client host info including stats */\n\tstruct gsh_export *ctx_export;\t/*< current export */\n\tstruct fsal_export *fsal_export;\t/*< current fsal export */\n\tstruct export_perms *export_perms;\t/*< Effective export perms */\n\tnsecs_elapsed_t start_time;\t/*< start time of this op/request */\n\tvoid *fsal_private;\t\t/*< private for FSAL use */\n\tstruct fsal_module *fsal_module;\t/*< current fsal module */\n\tstruct fsal_pnfs_ds *fsal_pnfs_ds;\t/*< current pNFS DS */\n\t/* add new context members here */\n};\n\n/**\n * @brief FSAL module methods\n */\n\nstruct fsal_ops {\n/**@{*/\n/**\n * Base methods for loading and lifetime.\n */\n\n/**\n * @brief Unload a module\n *\n * This function unloads the FSL module.  It should not be overridden.\n *\n * @param[in] fsal_hdl The module to unload.\n *\n * @retval 0     On success.\n * @retval EBUSY If there are outstanding references or exports.\n */\n\tint (*unload)(struct fsal_module *fsal_hdl);\n\n/**@}*/\n\n/**@{*/\n/**\n * Subclass/instance methods in each fsal\n */\n\n/**\n * @brief Initialize the configuration\n *\n * Given the root of the Ganesha configuration structure, initialize\n * the FSAL parameters.\n *\n * @param[in] fsal_hdl      The FSAL module\n * @param[in] config_struct Parsed ganesha configuration file\n * @param[out]err_type      config error processing state\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*init_config)(struct fsal_module *fsal_hdl,\n\t\t\t\t      config_file_t config_struct,\n\t\t\t\t      struct config_error_type *err_type);\n/**\n * @brief Dump configuration\n *\n * This function dumps a human readable representation of the FSAL\n * configuration.\n *\n * @param[in] fsal_hdl The FSAL module.\n * @param[in] log_fd   File descriptor to which to output the dump\n */\n\tvoid (*dump_config)(struct fsal_module *fsal_hdl, int log_fd);\n\n/**\n * @brief Create a new export\n *\n * This function creates a new export in the FSAL using the supplied\n * path and options.  The function is expected to allocate its own\n * export (the full, private structure).  It must then initialize the\n * public portion like so:\n *\n * @code{.c}\n *         fsal_export_init(&private_export_handle->pub);\n * @endcode\n *\n * After doing other private initialization, it must attach the export\n * to the module, like so:\n *\n *\n * @code{.c}\n *         fsal_attach_export(fsal_hdl,\n *                            &private_export->pub.exports);\n *\n * @endcode\n *\n * And create the parent link with:\n *\n * @code{.c}\n * private_export->pub.fsal = fsal_hdl;\n * @endcode\n *\n * @note This seems like something that fsal_attach_export should\n * do. -- ACE.\n *\n * @param[in]     fsal_hdl    FSAL module\n * @param[in]     parse_node  opaque pointer to parse tree node for\n *                            export options to be passed to\n *                            load_config_from_node\n * @param[out]    err_type    config proocessing error reporting\n * @param[in]     up_ops      Upcall ops\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*create_export)(struct fsal_module *fsal_hdl,\n\t\t\t\t\tvoid *parse_node,\n\t\t\t\t\tstruct config_error_type *err_type,\n\t\t\t\t\tconst struct fsal_up_vector *up_ops);\n\n/**\n * @brief Update an existing export\n *\n * This will result in a temporary fsal_export being created, and built into\n * a stacked export.\n *\n * On entry, op_ctx has the original gsh_export and no fsal_export.\n *\n * The caller passes the original fsal_export, as well as the new super_export's\n * FSAL when there is a stacked export. This will allow the underlying export to\n * validate that the stacking has not changed.\n *\n * This function does not actually create a new fsal_export, the only purpose is\n * to validate and update the config.\n *\n * @param[in]     fsal_hdl         FSAL module\n * @param[in]     parse_node       opaque pointer to parse tree node for\n *                                 export options to be passed to\n *                                 load_config_from_node\n * @param[out]    err_type         config proocessing error reporting\n * @param[in]     original         The original export that is being updated\n * @param[in]     updated_super    The updated super_export's FSAL\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*update_export)(struct fsal_module *fsal_hdl,\n\t\t\t\t\tvoid *parse_node,\n\t\t\t\t\tstruct config_error_type *err_type,\n\t\t\t\t\tstruct fsal_export *original,\n\t\t\t\t\tstruct fsal_module *updated_super);\n\n/**\n * @brief Minimal emergency cleanup on error\n *\n * This method is called only in the event of a catastrophic\n * failure. Currently, it will be called if some detail of the orderly\n * shutdown fails, so that FSALs will have the opportunity to leave\n * their underlying filesystems in a consistent state. It may at some\n * later time be called in the event of a crash. The majority of FSALs\n * will have no need to implement this call and should not do so.\n *\n * This function should, if implemented:\n *\n * 1. Do the bare minimum necessary to allow access to the each\n * underlying filesystem it serves. (the equivalent of a clean\n * unmount, so that a future instance of Ganesha or other tool can\n * mount the filesystem without difficulty.) How the FSAL defines\n * 'underlying filesystem' is FSAL specific. The FSAL handle itself\n * has a list of attached exports and that can be traversed if\n * suitable.\n *\n * 2. It /must not/ take any mutices, reader-writer locks, spinlocks,\n * sleep on any condition variables, or similar. Since other threads\n * may have crashed or been cancelled, locks may be left held,\n * overwritten with random garbage, or be similarly awful. The point\n * is to shut down cleanly, and you can't shut down cleanly if you're\n * hung. This does not create a race condition, since other threads in\n * Ganesha will have been cancelled by this point.\n *\n * 3. If it is at all possible to avoid, do not allocate memory on the\n * heap or use other services that require the user space to be in a\n * consistent state. If this is called from a crash handler, the Arena\n * may be corrupt. If you know that your FSAL *will* require memory,\n * you should either allocate it statically, or dynamically at\n * initialization time.\n */\n\tvoid (*emergency_cleanup)(void);\n\n/**\n * pNFS functions\n */\n\n/**\n * @brief Get information about a pNFS device\n *\n * When this function is called, the FSAL should write device\n * information to the @c da_addr_body stream.\n *\n * @param[in]  fsal_hdl     FSAL module\n * @param[out] da_addr_body An XDR stream to which the FSAL is to\n *                          write the layout type-specific information\n *                          corresponding to the deviceid.\n * @param[in]  type         The type of layout that specified the\n *                          device\n * @param[in]  deviceid     The device to look up\n *\n * @return Valid error codes in RFC 5661, p. 365.\n */\n\t nfsstat4(*getdeviceinfo)(struct fsal_module *fsal_hdl,\n\t\t\t\t  XDR * da_addr_body,\n\t\t\t\t  const layouttype4 type,\n\t\t\t\t  const struct pnfs_deviceid *deviceid);\n\n/**\n * @brief Max Size of the buffer needed for da_addr_body in getdeviceinfo\n *\n * This function sets policy for XDR buffer allocation in getdeviceinfo.\n * If FSAL has a const size, just return it here. If it is dependent on\n * what the client can take return ~0UL. In any case the buffer allocated will\n * not be bigger than client's requested maximum.\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Max size of the buffer needed for a da_addr_body\n */\n\t size_t (*fs_da_addr_size)(struct fsal_module *fsal_hdl);\n\n/**\n * @brief Create a FSAL pNFS data server\n *\n * @param[in]  fsal_hdl\t\tFSAL module\n * @param[in]  parse_node\topaque pointer to parse tree node for\n *\t\t\t\texport options to be passed to\n *\t\t\t\tload_config_from_node\n * @param[out] handle\t\tFSAL pNFS DS\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*fsal_pnfs_ds)(struct fsal_module *const fsal_hdl,\n\t\t\t\t       void *parse_node,\n\t\t\t\t       struct fsal_pnfs_ds **const handle);\n\n/**\n * @brief Initialize FSAL specific values for pNFS data server\n *\n * @param[in]  ops\tFSAL pNFS Data Server operations vector\n */\n\t void (*fsal_pnfs_ds_ops)(struct fsal_pnfs_ds_ops *ops);\n\n/**\n * @brief Provides function to extract FSAL stats\n *\n * @param[in] fsal_hdl\t\tFSAL module\n * @param[in] iter\t\topaque pointer to DBusMessageIter\n */\n\tvoid (*fsal_extract_stats)(struct fsal_module *const fsal_hdl,\n\t\t\t\t   void *iter);\n\n/**\n * @brief FSAL function to reset FSAL stats\n *\n * @param[in] fsal_hdl          FSAL module\n */\n\tvoid (*fsal_reset_stats)(struct fsal_module *const fsal_hdl);\n\n/**@}*/\n};\n\n/**\n * @brief Export operations\n */\n\nstruct export_ops {\n/**@{*/\n\n/**\n* Export information\n*/\n\n/**\n * @brief Get the name of the FSAL provisioning the export\n *\n * This function is used to find the name of the ultimate FSAL providing the\n * filesystem.  If FSALs are stacked, then the super-FSAL may want to pass this\n * through to the sub-FSAL to get the name, or add the sub-FSAL's name onto it's\n * own name.\n *\n * @param[in] exp_hdl The export to query.\n * @return Name of FSAL provisioning export\n */\n\t const char *(*get_name)(struct fsal_export *exp_hdl);\n/**@}*/\n\n/**@{*/\n\n/**\n* Export lifecycle management.\n*/\n\n/**\n * @brief Prepare an export to be unexported\n *\n * This function is called prior to unexporting an export. It should do any\n * preparation that the export requires prior to being removed.\n */\n\t void (*prepare_unexport)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Clean up an export when it's unexported\n *\n * This function is called when the export is unexported.  It should release any\n * working data that is not necessary when unexported, but not free the export\n * itself, as there are still references to it.\n *\n * @param[in] exp_hdl\tThe export to unexport.\n * @param[in] root_obj\tThe root object of the export\n */\n\t void (*unexport)(struct fsal_export *exp_hdl,\n\t\t\t  struct fsal_obj_handle *root_obj);\n\n/**\n * @brief Finalize an export\n *\n * This function is called as part of cleanup when the last reference to\n * an export is released and it is no longer part of the list.  It\n * should clean up all private resources and destroy the object.\n *\n * @param[in] exp_hdl The export to release.\n */\n\t void (*release)(struct fsal_export *exp_hdl);\n/**@}*/\n\n/**@{*/\n/**\n * Create an object handles within this export\n */\n\n/**\n * @brief Look up a path\n *\n * This function looks up a path within the export, it is typically\n * used to get a handle for the root directory of the export.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     exp_hdl   The export in which to look up\n * @param[in]     path      The path to look up\n * @param[out]    handle    The object found\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a handle has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*lookup_path)(struct fsal_export *exp_hdl,\n\t\t\t\t      const char *path,\n\t\t\t\t      struct fsal_obj_handle **handle,\n\t\t\t\t      struct attrlist *attrs_out);\n\n/**\n * @brief Look up a junction\n *\n * This function returns a handle for the directory behind a junction\n * object.\n *\n * @deprecated This function is not implemented by any FSAL nor is it\n * called.  It exists here as a placeholder for implementation in 2.1\n * as part of the PseudoFSAL work.  Its argument structure will almost\n * certainly change.\n *\n * @param[in]  exp_hdl  Export in which to look up\n * @param[in]  junction The junction object\n * @param[out] handle   The underlying directory handle\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*lookup_junction)(struct fsal_export *exp_hdl,\n\t\t\t\t\t  struct fsal_obj_handle *junction,\n\t\t\t\t\t  struct fsal_obj_handle **handle);\n/**\n * @brief Convert a wire handle to a host handle\n *\n * This function extracts a host handle from a wire handle.  That\n * is, when given a handle as passed to a client, this method will\n * extract the handle to create objects.\n *\n * @param[in]     exp_hdl Export handle\n * @param[in]     in_type Protocol through which buffer was received.\n * @param[in]     flags   Flags to describe the wire handle. Example, if\n *\t\t\t  the handle is a big endian handle.\n * @param[in,out] fh_desc Buffer descriptor.  The address of the\n *                        buffer is given in @c fh_desc->buf and must\n *                        not be changed.  @c fh_desc->len is the\n *                        length of the data contained in the buffer,\n *                        @c fh_desc->len must be updated to the correct\n *                        host handle size.\n *\n * @return FSAL type.\n */\n\t fsal_status_t (*wire_to_host)(struct fsal_export *exp_hdl,\n\t\t\t\t\t fsal_digesttype_t in_type,\n\t\t\t\t\t struct gsh_buffdesc *fh_desc,\n\t\t\t\t\t int flags);\n\n/**\n * @brief extract \"key\" from a host handle\n *\n * This function extracts a \"key\" from a host handle.  That is, when\n * given a handle that is extracted from wire_to_host() above, this\n * method will extract the unique bits used to index the inode cache.\n *\n * @param[in]     exp_hdl Export handle\n * @param[in,out] fh_desc Buffer descriptor.  The address of the\n *                        buffer is given in @c fh_desc->buf and must\n *                        not be changed.  @c fh_desc->len is the length\n *                        of the data contained in the buffer, @c\n *                        fh_desc->len must be updated to the correct\n *                        size. In other words, the key has to be placed\n *                        at the beginning of the buffer!\n */\n\t fsal_status_t (*host_to_key)(struct fsal_export *exp_hdl,\n\t\t\t\t      struct gsh_buffdesc *fh_desc);\n\n/**\n * @brief Create a FSAL object handle from a host handle\n *\n * This function creates a FSAL object handle from a host handle\n * (when an object is no longer in cache but the client still remembers\n * the handle).\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     exp_hdl   The export in which to create the handle\n * @param[in]     hdl_desc  Buffer descriptor for the host handle\n * @param[out]    handle    FSAL object handle\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a handle has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*create_handle)(struct fsal_export *exp_hdl,\n\t\t\t\t\tstruct gsh_buffdesc *fh_desc,\n\t\t\t\t\tstruct fsal_obj_handle **handle,\n\t\t\t\t\tstruct attrlist *attrs_out);\n/**@}*/\n\n/**@{*/\n/**\n * Statistics and configuration for this filesystem\n */\n\n/**\n * @brief Get filesystem statistics\n *\n * This function gets information on inodes and space in use and free\n * for a filesystem.  See @c fsal_dynamicinfo_t for details of what to\n * fill out.\n *\n * @param[in]  exp_hdl Export handle to interrogate\n * @param[in]  obj_hdl Directory\n * @param[out] info    Buffer to fill with information\n *\n * @retval FSAL status.\n */\n\t fsal_status_t (*get_fs_dynamic_info)(struct fsal_export *exp_hdl,\n\t\t\t\t\t      struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t      fsal_dynamicfsinfo_t *info);\n/**\n * @brief Export feature test\n *\n * This function checks whether a feature is supported on this\n * filesystem.  The features that can be interrogated are given in the\n * @c fsal_fsinfo_options_t enumeration.\n *\n * @param[in] exp_hdl The export to interrogate\n * @param[in] option  The feature to query\n *\n * @retval true if the feature is supported.\n * @retval false if the feature is unsupported or unknown.\n */\n\t bool (*fs_supports)(struct fsal_export *exp_hdl,\n\t\t\t     fsal_fsinfo_options_t option);\n/**\n * @brief Get the greatest file size supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest file size supported.\n */\n\t uint64_t (*fs_maxfilesize)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get the greatest read size supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest read size supported.\n */\n\t uint32_t (*fs_maxread)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get the greatest write size supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest write size supported.\n */\n\t uint32_t (*fs_maxwrite)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get the greatest link count supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest link count supported.\n */\n\t uint32_t (*fs_maxlink)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get the greatest name length supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest name length supported.\n */\n\t uint32_t (*fs_maxnamelen)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get the greatest path length supported\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Greatest path length supported.\n */\n\t uint32_t (*fs_maxpathlen)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get supported ACL types\n *\n * This function returns a bitmask indicating whether it supports\n * ALLOW, DENY, neither, or both types of ACL.\n *\n * @note Could someone with more ACL support tell me if this is sane?\n * Is it legitimate for an FSAL supporting ACLs to support just ALLOW\n * or just DENY without supporting the other?  It seems fishy to\n * me. -- ACE\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return supported ACL types.\n */\n\t fsal_aclsupp_t (*fs_acl_support)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get supported attributes\n *\n * This function returns a list of all attributes that this FSAL will\n * support.  Be aware that this is specifically the attributes in\n * struct attrlist, other NFS attributes (fileid and so forth) are\n * supported through other means.\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return supported attributes.\n */\n\t attrmask_t (*fs_supported_attrs)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get umask applied to created files\n *\n * @note This seems fishy to me.  Is this actually supported properly?\n * And is it something we want the FSAL being involved in?  We already\n * have the functions in Protocol/NFS specifying a default mode. -- ACE\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return creation umask.\n */\n\t uint32_t (*fs_umask)(struct fsal_export *exp_hdl);\n/**@}*/\n\n/**@{*/\n\n/**\n * Quotas are managed at the file system (export) level.  Someone who\n * uses quotas, please look over these comments to check/expand them.\n */\n\n/**\n * @brief Check if quotas allow an operation\n *\n * This function checks to see if a user has overrun a quota and\n * should be disallowed from performing an operation that would\n * consume blocks or inodes.\n *\n * @param[in] exp_hdl    The export to interrogate\n * @param[in] filepath   The path within the export to check\n * @param[in] quota_type Whether we are checking inodes or blocks\n *\n * @return FSAL types.\n */\n\t fsal_status_t (*check_quota)(struct fsal_export *exp_hdl,\n\t\t\t\t      const char *filepath, int quota_type);\n\n/**\n * @brief Get a user's quota\n *\n * This function retrieves a given user's quota.\n *\n * @param[in]  exp_hdl    The export to interrogate\n * @param[in]  filepath   The path within the export to check\n * @param[in]  quota_type Whether we are checking inodes or blocks\n * @param[in]  quota_id   Id for which quota is set\n * @param[out] quota      The user's quota\n *\n * @return FSAL types.\n */\n\t fsal_status_t (*get_quota)(struct fsal_export *exp_hdl,\n\t\t\t\t    const char *filepath, int quota_type,\n\t\t\t\t    int quota_id,\n\t\t\t\t    fsal_quota_t *quota);\n\n/**\n * @brief Set a user's quota\n *\n * This function sets a user's quota.\n *\n * @param[in]  exp_hdl    The export to interrogate\n * @param[in]  filepath   The path within the export to check\n * @param[in]  quota_type Whether we are checking inodes or blocks\n * @param[in]  quota_id   Id for which quota is set\n * @param[in]  quota      The values to set for the quota\n * @param[out] resquota   New values set (optional)\n *\n * @return FSAL types.\n */\n\t fsal_status_t (*set_quota)(struct fsal_export *exp_hdl,\n\t\t\t\t    const char *filepath, int quota_type,\n\t\t\t\t    int quota_id,\n\t\t\t\t    fsal_quota_t *quota,\n\t\t\t\t    fsal_quota_t *resquota);\n/**@}*/\n\n/**@{*/\n/**\n * pNFS functions\n */\n\n/**\n * @brief Get list of available devices\n *\n * This function should populate calls @c cb @c values representing the\n * low quad of deviceids it wishes to make the available to the\n * caller.  it should continue calling @c cb until @c cb returns false\n * or it runs out of deviceids to make available.  If @c cb returns\n * false, it should assume that @c cb has not stored the most recent\n * deviceid and set @c res->cookie to a value that will begin witht he\n * most recently provided.\n *\n * If it wishes to return no deviceids, it may set @c res->eof to true\n * without calling @c cb at all.\n *\n * @param[in]     exp_hdl Export handle\n * @param[in]     type    Type of layout to get devices for\n * @param[in]     cb      Function taking device ID halves\n * @param[in,out] res     In/out and output arguments of the function\n *\n * @return Valid error codes in RFC 5661, pp. 365-6.\n */\n\t nfsstat4(*getdevicelist)(struct fsal_export *exp_hdl,\n\t\t\t\t  layouttype4 type, void *opaque,\n\t\t\t\t  bool (*cb)(void *opaque, const uint64_t id),\n\t\t\t\t  struct fsal_getdevicelist_res *res);\n\n/**\n * @brief Get layout types supported by export\n *\n * This function is the handler of the NFS4.1 FATTR4_FS_LAYOUT_TYPES file\n * attribute. (See RFC)\n *\n * @param[in]  exp_hdl Filesystem to interrogate\n * @param[out] count   Number of layout types in array\n * @param[out] types   Static array of layout types that must not be\n *                     freed or modified and must not be dereferenced\n *                     after export reference is relinquished\n */\n\tvoid (*fs_layouttypes)(struct fsal_export *exp_hdl, int32_t *count,\n\t\t\t       const layouttype4 **types);\n\n/**\n * @brief Get layout block size for export\n *\n * This function is the handler of the NFS4.1 FATTR4_LAYOUT_BLKSIZE f-attribute.\n *\n * This is the preferred read/write block size.  Clients are requested\n * (but don't have to) read and write in multiples.\n *\n * NOTE: The linux client only asks for this in blocks-layout, where this is the\n * filesystem wide block-size. (Minimum write size and alignment)\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return The preferred layout block size.\n */\n\t uint32_t (*fs_layout_blocksize)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Maximum number of segments we will use\n *\n * This function returns the maximum number of segments that will be\n * used to construct the response to any single layoutget call.  Bear\n * in mind that current clients only support 1 segment.\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return The Maximum number of layout segments in a campound layoutget.\n */\n\t uint32_t (*fs_maximum_segments)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Size of the buffer needed for loc_body at layoutget\n *\n * This function sets policy for XDR buffer allocation in layoutget vector\n * below. If FSAL has a const size, just return it here. If it is dependent on\n * what the client can take return ~0UL. In any case the buffer allocated will\n * not be bigger than client's requested maximum.\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Max size of the buffer needed for a loc_body\n */\n\t size_t (*fs_loc_body_size)(struct fsal_export *exp_hdl);\n\n/**\n * @brief Get write verifier\n *\n * This function is called by write and commit to match the commit verifier\n * with the one returned on  write.\n *\n * @param[in] exp_hdl\tExport to query\n * @param[in,out] verf_desc Address and length of verifier\n */\n\tvoid (*get_write_verifier)(struct fsal_export *exp_hdl,\n\t\t\t\t   struct gsh_buffdesc *verf_desc);\n\n/**@}*/\n\n/**\n * @brief Allocate a state_t structure\n *\n * Note that this is not expected to fail since memory allocation is\n * expected to abort on failure.\n *\n * @param[in] exp_hdl               Export state_t will be associated with\n * @param[in] state_type            Type of state to allocate\n * @param[in] related_state         Related state if appropriate\n *\n * @returns a state structure.\n */\n\n\tstruct state_t *(*alloc_state)(struct fsal_export *exp_hdl,\n\t\t\t\t       enum state_type state_type,\n\t\t\t\t       struct state_t *related_state);\n\n/**\n * @brief Free a state_t structure\n *\n * @param[in] exp_hdl               Export state_t is associated with\n * @param[in] state                 state_t structure to free.\n *\n * @returns NULL on failure otherwise a state structure.\n */\n\n\tvoid (*free_state)(struct fsal_export *exp_hdl, struct state_t *state);\n\n/**\n * @brief Check to see if a user is superuser\n *\n * @param[in] exp_hdl               Export state_t is associated with\n * @param[in] creds                 Credentials to check for superuser\n *\n * @returns NULL on failure otherwise a state structure.\n */\n\n\tbool (*is_superuser)(struct fsal_export *exp_hdl,\n\t\t\t     const struct user_cred *creds);\n\n/**\n * @brief Get the expiration time for parent handle.\n *\n * @param[in] exp_hdl Filesystem to interrogate\n *\n * @return Expiration time for parent handle\n */\n\n\tint32_t (*fs_expiretimeparent)(struct fsal_export *exp_hdl);\n};\n\n/**\n * @brief Filesystem operations\n */\n\ntypedef void (*fsal_async_cb)(struct fsal_obj_handle *obj, fsal_status_t ret,\n\t\t\t      void *obj_data, void *caller_data);\n\ntypedef int (*claim_filesystem_cb)(struct fsal_filesystem *fs,\n\t\t\t\t   struct fsal_export *exp);\n\ntypedef void (*unclaim_filesystem_cb)(struct fsal_filesystem *fs);\n\nenum fsid_type {\n\tFSID_NO_TYPE,\n\tFSID_ONE_UINT64,\n\tFSID_MAJOR_64,\n\tFSID_TWO_UINT64,\n\tFSID_TWO_UINT32,\n\tFSID_DEVICE\n};\n\nstatic inline uint64_t squash_fsid(const struct fsal_fsid__ *fsid)\n{\n\treturn fsid->major ^ (fsid->minor << 32 | fsid->minor >> 32);\n}\n\nstatic inline int sizeof_fsid(enum fsid_type type)\n{\n\tswitch (type) {\n\tcase FSID_NO_TYPE:\n\t\treturn 0;\n\tcase FSID_ONE_UINT64:\n\tcase FSID_MAJOR_64:\n\t\treturn sizeof(uint64_t);\n\tcase FSID_TWO_UINT64:\n\t\treturn 2 * sizeof(uint64_t);\n\tcase FSID_TWO_UINT32:\n\tcase FSID_DEVICE:\n\t\treturn 2 * sizeof(uint32_t);\n\t}\n\n\treturn -1;\n}\n\n/**\n * @brief Directory cookie\n */\n\ntypedef uint64_t fsal_cookie_t;\n\n/* Cookie values 0, 1, and 2 are reserved by NFS:\n * 0 is \"start from beginning\"\n * 1 is the cookie associated with the \".\" entry\n * 2 is the cookie associated with the \"..\" entry\n *\n * FSALs that support compute_readdir_cookie that are for some reason unable\n * to compute the cookie for the very first entry (other than . and ..)\n * should return FIRST_COOKIE. Caching layers such as MDCACHE should treat an\n * insert of an entry with cookie 3 as inserting a new first entry, and then\n * compute a new cookie for the old first entry - they can safely assume the\n * sort order doesn't change which may allow for optimization of things like'\n * AVL trees.\n */\n#define FIRST_COOKIE 3\n\nenum fsal_dir_result {\n\t/** Continue readdir, call back with another dirent. */\n\tDIR_CONTINUE,\n\t/** Continue supplying entries if readahead is supported, otherwise\n\t *  stop providing entries.\n\t */\n\tDIR_READAHEAD,\n\t/** Terminate readdir. */\n\tDIR_TERMINATE,\n};\n\nconst char *fsal_dir_result_str(enum fsal_dir_result result);\n\n/**\n * @brief Callback to provide readdir caller with each directory entry\n *\n * The called function will indicate if readdir should continue, terminate,\n * terminate and mark cookie, or continue and mark cookie. In the last case,\n * the called function may also return a cookie if requested in the ret_cookie\n * parameter (which may be NULL if the caller doesn't need to mark cookies).\n * If ret_cookie is 0, the caller had no cookie to return.\n *\n * @param[in]      name         The name of the entry\n * @param[in]      obj          The fsal_obj_handle describing the entry\n * @param[in]      attrs        The requested attribues for the entry (see\n *                              readdir attrmask parameter)\n * @param[in]      dir_state    Opaque pointer to be passed to callback\n * @param[in]      cookie       An FSAL generated cookie for the entry\n *\n * @returns fsal_dir_result above\n */\ntypedef enum fsal_dir_result (*fsal_readdir_cb)(\n\t\t\t\tconst char *name, struct fsal_obj_handle *obj,\n\t\t\t\tstruct attrlist *attrs,\n\t\t\t\tvoid *dir_state, fsal_cookie_t cookie);\n\n/**\n * @brief Argument for read2/write2 and their callbacks\n *\n */\nstruct fsal_io_arg {\n\tsize_t io_amount;\t/**< Total amount of I/O actually done */\n\tstruct io_info *info;\t/**< More info about data for read_plus */\n\tunion {\n\t\tbool end_of_file;\t/**< True if end-of-file reached */\n\t\tbool fsal_stable;\t/**< requested/achieved stability */\n\t};\n\tstruct state_t *state;\t/**< State to use for read (or NULL) */\n\tuint64_t offset;\t/**< Offset into file to read */\n\tint iov_count;\t\t/**< Number of vectors in iov */\n\tstruct iovec iov[];\t/**< Vector of buffers to fill */\n};\n\n/**\n * @brief FSAL object operations vector\n */\n\nstruct fsal_obj_ops {\n/**@{*/\n\n/**\n * Lifecycle management\n */\n\n/**\n * @brief Get a reference to a handle\n *\n * Refcounting is required for all FSALs. An FSAL that will have FSAL_MDCACHE\n * stacked on top need not handle this as FSAL_MDCACHE will handle it.\n *\n * @param[in] obj_hdl Handle to release\n */\n\t void (*get_ref)(struct fsal_obj_handle *obj_hdl);\n\n/**\n * @brief Put a reference to a handle\n *\n * Refcounting is required for all FSALs. An FSAL that will have FSAL_MDCACHE\n * stacked on top need not handle this as FSAL_MDCACHE will handle it.\n *\n * @param[in] obj_hdl Handle to release\n */\n\t void (*put_ref)(struct fsal_obj_handle *obj_hdl);\n\n/**\n * @brief Clean up a filehandle\n *\n * This function cleans up private resources associated with a\n * filehandle and deallocates it.  Implement this method or you will\n * leak.  Refcount (if used) should be 1\n *\n * @param[in] obj_hdl Handle to release\n */\n\t void (*release)(struct fsal_obj_handle *obj_hdl);\n\n/**\n * @brief Merge a duplicate handle with an original handle\n *\n * This function is used if an upper layer detects that a duplicate\n * object handle has been created. It allows the FSAL to merge anything\n * from the duplicate back into the original.\n *\n * The caller must release the object (the caller may have to close\n * files if the merge is unsuccessful).\n *\n * @param[in]  orig_hdl  Original handle\n * @param[in]  dupe_hdl Handle to merge into original\n *\n * @return FSAL status.\n *\n */\n\t fsal_status_t (*merge)(struct fsal_obj_handle *orig_hdl,\n\t\t\t\tstruct fsal_obj_handle *dupe_hdl);\n\n/**@}*/\n\n/**@{*/\n\n/**\n * Directory operations\n */\n\n/**\n * @brief Look up a filename\n *\n * This function looks up the given name in the supplied directory.\n *\n * @note The old version of the FSAL had a special case for this\n * function, such that if the directory handle and path were both\n * NULL, a handle to the root of the export was returned.  This\n * special case is no longer supported and should not be implemented.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     dir_hdl   Directory to search\n * @param[in]     path      Name to look up\n * @param[out]    handle    Object found\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a handle has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*lookup)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\t const char *path,\n\t\t\t\t struct fsal_obj_handle **handle,\n\t\t\t\t struct attrlist *attrs_out);\n\n/**\n * @brief Read a directory\n *\n * This function reads directory entries from the FSAL and supplies\n * them to a callback.\n *\n * @param[in]  dir_hdl   Directory to read\n * @param[in]  whence    Point at which to start reading.  NULL to\n *                       start at beginning.\n * @param[in]  dir_state Opaque pointer to be passed to callback\n * @param[in]  cb        Callback to receive names\n * @param[in]  attrmask  Indicate which attributes the caller is interested in\n * @param[out] eof       true if the last entry was reached\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*readdir)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\t  fsal_cookie_t *whence,\n\t\t\t\t  void *dir_state,\n\t\t\t\t  fsal_readdir_cb cb,\n\t\t\t\t  attrmask_t attrmask,\n\t\t\t\t  bool *eof);\n\n/**\n * @brief Compute the readdir cookie for a given filename.\n *\n * Some FSALs are able to compute the cookie for a filename deterministically\n * from the filename. They also have a defined order of entries in a directory\n * based on the name (could be strcmp sort, could be strict alpha sort, could\n * be deterministic order based on cookie - in any case, the dirent_cmp method\n * will also be provided.\n *\n * The returned cookie is the cookie that can be passed as whence to FIND that\n * directory entry. This is different than the cookie passed in the readdir\n * callback (which is the cookie of the NEXT entry).\n *\n * @param[in]  parent  Directory file name belongs to.\n * @param[in]  name    File name to produce the cookie for.\n *\n * @retval 0 if not supported.\n * @returns The cookie value.\n */\n\tfsal_cookie_t (*compute_readdir_cookie)(struct fsal_obj_handle *parent,\n\t\t\t\t\t\tconst char *name);\n\n/**\n * @brief Help sort dirents.\n *\n * For FSALs that are able to compute the cookie for a filename\n * deterministically from the filename, there must also be a defined order of\n * entries in a directory based on the name (could be strcmp sort, could be\n * strict alpha sort, could be deterministic order based on cookie).\n *\n * Although the cookies could be computed, the caller will already have them\n * and thus will provide them to save compute time.\n *\n * @param[in]  parent   Directory entries belong to.\n * @param[in]  name1    File name of first dirent\n * @param[in]  cookie1  Cookie of first dirent\n * @param[in]  name2    File name of second dirent\n * @param[in]  cookie2  Cookie of second dirent\n *\n * @retval < 0 if name1 sorts before name2\n * @retval == 0 if name1 sorts the same as name2\n * @retval >0 if name1 sorts after name2\n */\n\tint (*dirent_cmp)(struct fsal_obj_handle *parent,\n\t\t\t  const char *name1, fsal_cookie_t cookie1,\n\t\t\t  const char *name2, fsal_cookie_t cookie2);\n/**@}*/\n\n/**@{*/\n\n/**\n * Creation operations\n */\n\n/**\n * @brief Create a directory\n *\n * This function creates a new directory.\n *\n * For support_ex, this method will handle attribute setting. The caller\n * MUST include the mode attribute and SHOULD NOT include the owner or\n * group attributes if they are the same as the op_ctx->cred.\n *\n * The caller is expected to invoke fsal_release_attrs to release any\n * resources held by the set attributes. The FSAL layer MAY have added an\n * inherited ACL.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     dir_hdl   Directory in which to create the directory\n * @param[in]     name      Name of directory to create\n * @param[in]     attrs_in  Attributes to set on newly created object\n * @param[out]    new_obj   Newly created object\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a new_obj has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*mkdir)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\tconst char *name, struct attrlist *attrs_in,\n\t\t\t\tstruct fsal_obj_handle **new_obj,\n\t\t\t\tstruct attrlist *attrs_out);\n\n/**\n * @brief Create a special file\n *\n * This function creates a new special file.\n *\n * For support_ex, this method will handle attribute setting. The caller\n * MUST include the mode attribute and SHOULD NOT include the owner or\n * group attributes if they are the same as the op_ctx->cred.\n *\n * If the node type has rawdev info, then @a attrs_in MUST have the rawdev field\n * set.\n *\n * The caller is expected to invoke fsal_release_attrs to release any\n * resources held by the set attributes. The FSAL layer MAY have added an\n * inherited ACL.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     dir_hdl   Directory in which to create the object\n * @param[in]     name      Name of object to create\n * @param[in]     nodetype  Type of special file to create\n * @param[in]     attrs_in  Attributes to set on newly created object\n * @param[out]    new_obj   Newly created object\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a new_obj has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*mknode)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\t const char *name,\n\t\t\t\t object_file_type_t nodetype,\n\t\t\t\t struct attrlist *attrs_in,\n\t\t\t\t struct fsal_obj_handle **new_obj,\n\t\t\t\t struct attrlist *attrs_out);\n\n/**\n * @brief Create a symbolic link\n *\n * This function creates a new symbolic link.\n *\n * For support_ex, this method will handle attribute setting. The caller\n * MUST include the mode attribute and SHOULD NOT include the owner or\n * group attributes if they are the same as the op_ctx->cred.\n *\n * The caller is expected to invoke fsal_release_attrs to release any\n * resources held by the set attributes. The FSAL layer MAY have added an\n * inherited ACL.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method instantiates a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * @param[in]     dir_hdl   Directory in which to create the object\n * @param[in]     name      Name of object to create\n * @param[in]     link_path Content of symbolic link\n * @param[in]     attrs_in  Attributes to set on newly created object\n * @param[out]    new_obj   Newly created object\n * @param[in,out] attrs_out Optional attributes for newly created object\n *\n * @note On success, @a new_obj has been ref'd\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*symlink)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\t  const char *name,\n\t\t\t\t  const char *link_path,\n\t\t\t\t  struct attrlist *attrs_in,\n\t\t\t\t  struct fsal_obj_handle **new_obj,\n\t\t\t\t  struct attrlist *attrs_out);\n/**@}*/\n\n/**@{*/\n\n/**\n * File object operations\n */\n\n/**\n * @brief Read the content of a link\n *\n * This function reads the content of a symbolic link.  The FSAL will\n * allocate a buffer and store its address and the link length in the\n * link_content gsh_buffdesc.  The caller *must* free this buffer with\n * gsh_free.\n *\n * The symlink content passed back *must* be null terminated and the\n * length indicated in the buffer description *must* include the\n * terminator.\n *\n * @param[in]  obj_hdl      Link to read\n * @param[out] link_content Buffdesc to which the FSAL will store\n *                          the address of the buffer holding the\n *                          link and the link length.\n * @param[out] refresh      true if the content are to be retrieved\n *                          from the underlying filesystem rather\n *                          than cache\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*readlink)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t   struct gsh_buffdesc *link_content,\n\t\t\t\t   bool refresh);\n\n/**\n * @brief Check access for a given user against a given object\n *\n * This function checks whether a given user is allowed to perform the\n * specified operations against the supplied file.  The goal is to\n * allow filesystem specific semantics to be applied to cached\n * metadata.\n *\n * This method must read attributes and/or get them from a cache.\n *\n * @param[in] obj_hdl     Handle to check\n * @param[in] access_type Access requested\n * @param[out] allowed    Returned access that could be granted\n * @param[out] denied     Returned access that would be granted\n * @param[in] owner_skip  Skip test if op_ctx->creds is owner\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*test_access)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t      fsal_accessflags_t access_type,\n\t\t\t\t      fsal_accessflags_t *allowed,\n\t\t\t\t      fsal_accessflags_t *denied,\n\t\t\t\t      bool owner_skip);\n\n/**\n * @brief Get attributes\n *\n * This function fetches the attributes for the object. The attributes\n * requested in the mask are copied out (though other attributes might\n * be copied out).\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * The caller MUST call fsal_release_attrs when done with the copied\n * out attributes. This will release any attributes that might take\n * additional memory.\n *\n * @param[in]  obj_hdl    Object to query\n * @param[out] attrs_out  Attribute list for file\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*getattrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t   struct attrlist *attrs_out);\n\n/**\n * @brief Create a new link\n *\n * This function creates a new name for an existing object.\n *\n * @param[in] obj_hdl     Object to be linked to\n * @param[in] destdir_hdl Directory in which to create the link\n * @param[in] name        Name for link\n *\n * @return FSAL status\n */\n\t fsal_status_t (*link)(struct fsal_obj_handle *obj_hdl,\n\t\t\t       struct fsal_obj_handle *destdir_hdl,\n\t\t\t       const char *name);\n\n/**\n * @brief Rename a file\n *\n * This function renames a file (technically it changes the name of\n * one link, which may be the only link to the file.)\n *\n * @param[in] olddir_hdl Old parent directory\n * @param[in] old_name   Old name\n * @param[in] newdir_hdl New parent directory\n * @param[in] new_name   New name\n *\n * @return FSAL status\n */\n\t fsal_status_t (*rename)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t struct fsal_obj_handle *olddir_hdl,\n\t\t\t\t const char *old_name,\n\t\t\t\t struct fsal_obj_handle *newdir_hdl,\n\t\t\t\t const char *new_name);\n/**\n * @brief Remove a name from a directory\n *\n * This function removes a name from a directory and possibly deletes\n * the file so named.\n *\n * @param[in] dir_hdl The directory from which to remove the name\n * @param[in] obj_hdl The object being removed\n * @param[in] name    The name to remove\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*unlink)(struct fsal_obj_handle *dir_hdl,\n\t\t\t\t struct fsal_obj_handle *obj_hdl,\n\t\t\t\t const char *name);\n\n/**@}*/\n\n/**@{*/\n/**\n * I/O management\n */\n\n/**\n * @brief Seek to data or hole\n *\n * This function seek to data or hole in a file.\n *\n * @param[in]  obj_hdl      File to be written\n * @param[in,out] info      Information about the data\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*seek)(struct fsal_obj_handle *obj_hdl,\n\t\t\t       struct io_info *info);\n/**\n * @brief IO Advise\n *\n * This function give hints to fs.\n *\n * @param[in]  obj_hdl      File to be written\n * @param[in,out] info      Information about the data\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*io_advise)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    struct io_hints *hints);\n\n/**\n * @brief Close a file\n *\n * This function closes a file.  It is protected by the Cache inode\n * content lock.  This should return ERR_FSAL_NOT_OPENED if the global FD for\n * this obj was not open.\n *\n * @param[in] obj_hdl File to close\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*close)(struct fsal_obj_handle *obj_hdl);\n\n/**\n * @brief Reserve/Deallocate space in a region of a file\n *\n * @param[in] obj_hdl File to which bytes should be allocated\n * @param[in] state   open stateid under which to do the allocation\n * @param[in] offset  offset at which to begin the allocation\n * @param[in] length  length of the data to be allocated\n * @param[in] allocate Should space be allocated or deallocated?\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*fallocate)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    struct state_t *state, uint64_t offset,\n\t\t\t\t    uint64_t length, bool allocate);\n/**@}*/\n\n/**@{*/\n\n/**\n * Extended attribute management\n */\n\n/**\n * @brief List extended attributes on a file\n *\n * This function gets a list of attributes on a given file.\n *\n * @param[in]  obj_hdl        File to interrogate\n * @param[in]  cookie         Attribute at which to start\n * @param[out] xattrs_tab     Array to which to write attributes\n * @param[in]  xattrs_tabsize Size of array\n * @param[out] nb_returned    Number of entries returned\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*list_ext_attrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t unsigned int cookie,\n\t\t\t\t\t struct fsal_xattrent *xattrs_tab,\n\t\t\t\t\t unsigned int xattrs_tabsize,\n\t\t\t\t\t unsigned int *nb_returned,\n\t\t\t\t\t int *end_of_list);\n\n/**\n * @brief Get a number for an attribute name\n *\n * This function returns an index for a given attribute specified by\n * name.\n *\n * @param[in]  obj_hdl  File to look up\n * @param[in]  name     Name to look up\n * @param[out] xattr_id Number uniquely identifying the attribute\n *                      within the scope of the file\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*getextattr_id_by_name)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t\tconst char *xattr_name,\n\t\t\t\t\t\tunsigned int *xattr_id);\n/**\n * @brief Get content of an attribute by name\n *\n * This function returns the value of an extended attribute as\n * specified by name.\n *\n * As a special rule, because it is implemented that way in the linux\n * getxattr call, giving a buffer_size of 0 is allowed and should set\n * output_size appropriately to fit the xattr.\n *\n * Please note that the xattr could change between the query-size call\n * and that actual fetch, so this is not fail-proof.\n *\n * @param[in]  obj_hdl     File to interrogate\n * @param[in]  xattr_name  Name of attribute\n * @param[out] buffer_addr Buffer to store content\n * @param[in]  buffer_size Buffer size\n * @param[out] output_size Size of content\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*getextattr_value_by_name)(struct fsal_obj_handle *\n\t\t\t\t\t\t   obj_hdl,\n\t\t\t\t\t\t   const char *xattr_name,\n\t\t\t\t\t\t   void *buffer_addr,\n\t\t\t\t\t\t   size_t buffer_size,\n\t\t\t\t\t\t   size_t *output_size);\n\n/**\n * @brief Get content of an attribute by id\n *\n * This function returns the value of an extended attribute as\n * specified by id.\n *\n * @param[in]  obj_hdl     File to interrogate\n * @param[in]  xattr_id    ID of attribute\n * @param[out] buffer_addr Buffer to store content\n * @param[in]  buffer_size Buffer size\n * @param[out] output_size Size of content\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*getextattr_value_by_id)(struct fsal_obj_handle *\n\t\t\t\t\t\t obj_hdl,\n\t\t\t\t\t\t unsigned int xattr_id,\n\t\t\t\t\t\t void *buffer_addr,\n\t\t\t\t\t\t size_t buffer_size,\n\t\t\t\t\t\t size_t *output_size);\n\n/**\n * @brief Set content of an attribute\n *\n * This function sets the value of an extended attribute.\n *\n * @param[in] obj_hdl     File to modify\n * @param[in] xattr_name  Name of attribute\n * @param[in] buffer_addr Content to set\n * @param[in] buffer_size Content size\n * @param[in] create      true if attribute is to be created\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*setextattr_value)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t   const char *xattr_name,\n\t\t\t\t\t   void *buffer_addr,\n\t\t\t\t\t   size_t buffer_size, int create);\n\n/**\n * @brief Set content of an attribute by id\n *\n * This function sets the value of an extended attribute by id.\n *\n * @param[in] obj_hdl     File to modify\n * @param[in] xattr_id    ID of attribute\n * @param[in] buffer_addr Content to set\n * @param[in] buffer_size Content size\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*setextattr_value_by_id)(struct fsal_obj_handle *\n\t\t\t\t\t\t obj_hdl,\n\t\t\t\t\t\t unsigned int xattr_id,\n\t\t\t\t\t\t void *buffer_addr,\n\t\t\t\t\t\t size_t buffer_size);\n\n/**\n * @brief Remove an extended attribute by id\n *\n * This function removes an extended attribute as specified by ID.\n *\n * @param[in] obj_hdl     File to modify\n * @param[in] xattr_id    ID of attribute\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*remove_extattr_by_id)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t       unsigned int xattr_id);\n\n/**\n * @brief Remove an extended attribute by name\n *\n * This function removes an extended attribute as specified by name.\n *\n * @param[in] obj_hdl     File to modify\n * @param[in] xattr_name  Name of attribute to remove\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*remove_extattr_by_name)(struct fsal_obj_handle *\n\t\t\t\t\t\t obj_hdl,\n\t\t\t\t\t\t const char *xattr_name);\n/**@}*/\n\n/**@{*/\n/**\n * Handle operations\n */\n\n/**\n * @brief Write wire handle\n *\n * This function writes a \"wire\" handle or file ID to the given\n * buffer.\n *\n * @param[in]     obj_hdl     The handle to digest\n * @param[in]     output_type The type of digest to write\n * @param[in,out] fh_desc     Buffer descriptor to which to write\n *                            digest.  Set fh_desc->len to final\n *                            output length.\n *\n * @return FSAL status\n */\n\t fsal_status_t (*handle_to_wire)(const struct fsal_obj_handle *obj_hdl,\n\t\t\t\t\t fsal_digesttype_t output_type,\n\t\t\t\t\t struct gsh_buffdesc *fh_desc);\n/**\n * @brief Get key for handle\n *\n * Indicate the unique part of the handle that should be used for\n * hashing.\n *\n * @param[in]  obj_hdl Handle whose key is to be got\n * @param[out] fh_desc Address and length giving sub-region of handle\n *                     to be used as key\n */\n\tvoid (*handle_to_key)(struct fsal_obj_handle *obj_hdl,\n\t\t\t      struct gsh_buffdesc *fh_desc);\n/**\n * @brief Compare two handles\n *\n * This function compares two handles to see if they reference the same file\n *\n * @param[in]     obj_hdl1    The first handle to compare\n * @param[in]     obj_hdl2    The second handle to compare\n *\n * @return True if match, false otherwise\n */\n\t bool (*handle_cmp)(struct fsal_obj_handle *obj_hdl1,\n\t\t\t    struct fsal_obj_handle *obj_hdl2);\n/**@}*/\n\n/**@{*/\n\n/**\n * pNFS functions\n */\n\n/**\n * @brief Grant a layout segment.\n *\n * This function is called by nfs41_op_layoutget.  It may be called\n * multiple times, to satisfy a request with multiple segments.  The\n * FSAL may track state (what portion of the request has been or\n * remains to be satisfied or any other information it wishes) in the\n * bookkeeper member of res.  Each segment may have FSAL-specific\n * information associated with it its segid.  This segid will be\n * supplied to the FSAL when the segment is committed or returned.\n * When the granting the last segment it intends to grant, the FSAL\n * must set the last_segment flag in res.\n *\n * @param[in]     obj_hdl  The handle of the file on which the layout is\n *                         requested.\n * @param[in]     req_ctx  Request context\n * @param[out]    loc_body An XDR stream to which the FSAL must encode\n *                         the layout specific portion of the granted\n *                         layout segment.\n * @param[in]     arg      Input arguments of the function\n * @param[in,out] res      In/out and output arguments of the function\n *\n * @return Valid error codes in RFC 5661, pp. 366-7.\n */\n\t nfsstat4(*layoutget)(struct fsal_obj_handle *obj_hdl,\n\t\t\t      struct req_op_context *req_ctx,\n\t\t\t      XDR * loc_body,\n\t\t\t      const struct fsal_layoutget_arg *arg,\n\t\t\t      struct fsal_layoutget_res *res);\n\n/**\n * @brief Potentially return one layout segment\n *\n * This function is called once on each segment matching the IO mode\n * and intersecting the range specified in a LAYOUTRETURN operation or\n * for all layouts corresponding to a given stateid on last close,\n * leas expiry, or a layoutreturn with a return-type of FSID or ALL.\n * Whther it is called in the former or latter case is indicated by\n * the synthetic flag in the arg structure, with synthetic being true\n * in the case of last-close or lease expiry.\n *\n * If arg->dispose is true, all resources associated with the\n * layout must be freed.\n *\n * @param[in] obj_hdl  The object on which a segment is to be returned\n * @param[in] req_ctx  Request context\n * @param[in] lrf_body In the case of a non-synthetic return, this is\n *                     an XDR stream corresponding to the layout\n *                     type-specific argument to LAYOUTRETURN.  In\n *                     the case of a synthetic or bulk return,\n *                     this is a NULL pointer.\n * @param[in] arg      Input arguments of the function\n *\n * @return Valid error codes in RFC 5661, p. 367.\n */\n\t nfsstat4(*layoutreturn)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t struct req_op_context *req_ctx,\n\t\t\t\t XDR * lrf_body,\n\t\t\t\t const struct fsal_layoutreturn_arg *arg);\n\n/**\n * @brief Commit a segment of a layout\n *\n * This function is called once on every segment of a layout.  The\n * FSAL may avoid being called again after it has finished all tasks\n * necessary for the commit by setting res->commit_done to true.\n *\n * The calling function does not inspect or act on the value of\n * size_supplied or new_size until after the last call to\n * FSAL_layoutcommit.\n *\n * @param[in]     obj_hdl  The object on which to commit\n * @param[in]     req_ctx  Request context\n * @param[in]     lou_body An XDR stream containing the layout\n *                         type-specific portion of the LAYOUTCOMMIT\n *                         arguments.\n * @param[in]     arg      Input arguments of the function\n * @param[in,out] res      In/out and output arguments of the function\n *\n * @return Valid error codes in RFC 5661, p. 366.\n */\n\t nfsstat4(*layoutcommit)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t struct req_op_context *req_ctx,\n\t\t\t\t XDR * lou_body,\n\t\t\t\t const struct fsal_layoutcommit_arg *arg,\n\t\t\t\t struct fsal_layoutcommit_res *res);\n\n/**\n * @brief Get Extended Attribute\n *\n * This function gets an extended attribute of an object.\n *\n * @param[in]  obj_hdl  Input object to query\n * @param[in]  xa_name  Input xattr name\n * @param[out] xa_value Output xattr value\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*getxattrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    xattrname4 *xa_name,\n\t\t\t\t    xattrvalue4 *xa_value);\n\n/**\n * @brief Set Extended Attribute\n *\n * This function sets an extended attribute of an object.\n *\n * @param[in]  obj_hdl  Input object to set\n * @param[in]  xa_type  Input xattr type\n * @param[in]  xa_name  Input xattr name to set\n * @param[in]  xa_value Input xattr value to set\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*setxattrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    setxattr_type4 sa_type,\n\t\t\t\t    xattrname4 *xa_name,\n\t\t\t\t    xattrvalue4 *xa_value);\n\n/**\n * @brief Remove Extended Attribute\n *\n * This function remove an extended attribute of an object.\n *\n * @param[in]  obj_hdl  Input object to set\n * @param[in]  xa_name  Input xattr name to remove\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*removexattrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    xattrname4 *xa_name);\n\n/**\n * @brief List Extended Attributes\n *\n * This function list the extended attributes of an object.\n *\n * @param[in]      obj_hdl       Input object to list\n * @param[in]      la_maxcount   Input maximum number of bytes for names\n * @param[in,out]  la_cookie     In/out cookie\n * @param[in,out]  la_cookieverf In/out cookie verifier\n * @param[out]     lr_eof        Output eof set if no more extended attributes\n * @param[out]     lr_names      Output list of extended attribute names\n *\t\t\t\t this buffer size is double the size of\n *\t\t\t\t la_maxcount to allow for component4 overhead\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*listxattrs)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t     count4 la_maxcount,\n\t\t\t\t     nfs_cookie4 *la_cookie,\n\t\t\t\t     verifier4 *la_cookieverf,\n\t\t\t\t     bool_t *lr_eof,\n\t\t\t\t     xattrlist4 * lr_names);\n\n\n/**@}*/\n\n/**@{*/\n\n/**\n * Extended API functions.\n *\n * With these new operations, the FSAL becomes responsible for managing\n * share reservations. The FSAL is also granted more control over the\n * state of a \"file descriptor\" and has more control of what a \"file\n * descriptor\" even is. Ultimately, it is whatever the FSAL needs in\n * order to manage the share reservations and lock state.\n *\n * The open2 method also allows atomic create/setattr/open (just like the\n * NFS v4 OPEN operation).\n *\n */\n\n/**\n * @brief Open a file descriptor for read or write and possibly create\n *\n * This function opens a file for read or write, possibly creating it.\n * If the caller is passing a state, it must hold the state_lock\n * exclusive.\n *\n * state can be NULL which indicates a stateless open (such as via the\n * NFS v3 CREATE operation), in which case the FSAL must assure protection\n * of any resources. If the file is being created, such protection is\n * simple since no one else will have access to the object yet, however,\n * in the case of an exclusive create, the common resources may still need\n * protection.\n *\n * If Name is NULL, obj_hdl is the file itself, otherwise obj_hdl is the\n * parent directory.\n *\n * On an exclusive create, the upper layer may know the object handle\n * already, so it MAY call with name == NULL. In this case, the caller\n * expects just to check the verifier.\n *\n * On a call with an existing object handle for an UNCHECKED create,\n * we can set the size to 0.\n *\n * At least the mode attribute must be set if createmode is not FSAL_NO_CREATE.\n * Some FSALs may still have to pass a mode on a create call for exclusive,\n * and even with FSAL_NO_CREATE, and empty set of attributes MUST be passed.\n *\n * If an open by name succeeds and did not result in Ganesha creating a file,\n * the caller will need to do a subsequent permission check to confirm the\n * open. This is because the permission attributes were not available\n * beforehand.\n *\n * The caller is expected to invoke fsal_release_attrs to release any\n * resources held by the set attributes. The FSAL layer MAY have added an\n * inherited ACL.\n *\n * The caller will set the request_mask in attrs_out to indicate the attributes\n * of interest. ATTR_ACL SHOULD NOT be requested and need not be provided. If\n * not all the requested attributes can be provided, this method MUST return\n * an error unless the ATTR_RDATTR_ERR bit was set in the request_mask.\n *\n * Since this method may instantiate a new fsal_obj_handle, it will be forced\n * to fetch at least some attributes in order to even know what the object\n * type is (as well as it's fileid and fsid). For this reason, the operation\n * as a whole can be expected to fail if the attributes were not able to be\n * fetched.\n *\n * The attributes will not be returned if this is an open by object as\n * opposed to an open by name.\n *\n * @note If the file was created, @a new_obj has been ref'd\n *\n * @param[in] obj_hdl               File to open or parent directory\n * @param[in,out] state             state_t to use for this operation\n * @param[in] openflags             Mode for open\n * @param[in] createmode            Mode for create\n * @param[in] name                  Name for file if being created or opened\n * @param[in] attrs_in              Attributes to set on created file\n * @param[in] verifier              Verifier to use for exclusive create\n * @param[in,out] new_obj           Newly created object\n * @param[in,out] attrs_out         Optional attributes for newly created object\n * @param[in,out] caller_perm_check The caller must do a permission check\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*open2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\tstruct state_t *state,\n\t\t\t\tfsal_openflags_t openflags,\n\t\t\t\tenum fsal_create_mode createmode,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct attrlist *attrs_in,\n\t\t\t\tfsal_verifier_t verifier,\n\t\t\t\tstruct fsal_obj_handle **new_obj,\n\t\t\t\tstruct attrlist *attrs_out,\n\t\t\t\tbool *caller_perm_check);\n\n/**\n * @brief Check the exclusive create verifier for a file.\n *\n * @param[in] obj_hdl     File to check verifier\n * @param[in] verifier    Verifier to use for exclusive create\n *\n * @retval true if verifier matches\n */\n\t bool (*check_verifier)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\tfsal_verifier_t verifier);\n\n/**\n * @brief Return open status of a state.\n *\n * This function returns open flags representing the current open\n * status for a state. The state_lock must be held.\n *\n * @param[in] obj_hdl     File owning state\n * @param[in] state File state to interrogate\n *\n * @retval Flags representing current open status\n */\n\tfsal_openflags_t (*status2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    struct state_t *state);\n\n/**\n * @brief Re-open a file that may be already opened\n *\n * This function supports changing the access mode of a share reservation and\n * thus should only be called with a share state. The state_lock must be held.\n *\n * This MAY be used to open a file the first time if there is no need for\n * open by name or create semantics. One example would be 9P lopen.\n *\n * @param[in] obj_hdl     File on which to operate\n * @param[in] state       state_t to use for this operation\n * @param[in] openflags   Mode for re-open\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*reopen2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t  struct state_t *state,\n\t\t\t\t  fsal_openflags_t openflags);\n\n/**\n * @brief Read data from a file\n *\n * This function reads data from the given file. The FSAL must be able to\n * perform the read whether a state is presented or not. This function also\n * is expected to handle properly bypassing or not share reservations.  This is\n * an (optionally) asynchronous call.  When the I/O is complete, the done\n * callback is called with the results.\n *\n * @param[in]     obj_hdl\tFile on which to operate\n * @param[in]     bypass\tIf state doesn't indicate a share reservation,\n *\t\t\t\tbypass any deny read\n * @param[in,out] done_cb\tCallback to call when I/O is done\n * @param[in,out] read_arg\tInfo about read, passed back in callback\n * @param[in,out] caller_arg\tOpaque arg from the caller for callback\n *\n * @return Nothing; results are in callback\n */\n\t void (*read2)(struct fsal_obj_handle *obj_hdl,\n\t\t       bool bypass,\n\t\t       fsal_async_cb done_cb,\n\t\t       struct fsal_io_arg *read_arg,\n\t\t       void *caller_arg);\n\n/**\n * @brief Write data to a file\n *\n * This function writes data to a file. The FSAL must be able to\n * perform the write whether a state is presented or not. This function also\n * is expected to handle properly bypassing or not share reservations. Even\n * with bypass == true, it will enforce a mandatory (NFSv4) deny_write if\n * an appropriate state is not passed).\n *\n * The FSAL is expected to enforce sync if necessary.\n *\n * This is an (optionally) asynchronous call.  When the I/O is complete, the @a\n * done_cb callback is called.\n *\n * @param[in]     obj_hdl       File on which to operate\n * @param[in]     bypass        If state doesn't indicate a share reservation,\n *                              bypass any non-mandatory deny write\n * @param[in,out] done_cb\tCallback to call when I/O is done\n * @param[in,out] write_arg\tInfo about write, passed back in callback\n * @param[in,out] caller_arg\tOpaque arg from the caller for callback\n */\n\t void (*write2)(struct fsal_obj_handle *obj_hdl,\n\t\t\tbool bypass,\n\t\t\tfsal_async_cb done_cb,\n\t\t\tstruct fsal_io_arg *write_arg,\n\t\t\tvoid *caller_arg);\n\n/**\n * @brief Seek to data or hole\n *\n * This function seek to data or hole in a file.\n *\n * @param[in]     obj_hdl   File on which to operate\n * @param[in]     state     state_t to use for this operation\n * @param[in,out] info      Information about the data\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*seek2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\tstruct state_t *state,\n\t\t\t\tstruct io_info *info);\n/**\n * @brief IO Advise\n *\n * This function give hints to fs.\n *\n * @param[in]     obj_hdl          File on which to operate\n * @param[in]     state            state_t to use for this operation\n * @param[in,out] info             Information about the data\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*io_advise2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t     struct state_t *state,\n\t\t\t\t     struct io_hints *hints);\n\n/**\n * @brief Commit written data\n *\n * This function flushes possibly buffered data to a file. This method\n * differs from commit due to the need to interact with share reservations\n * and the fact that the FSAL manages the state of \"file descriptors\". The\n * FSAL must be able to perform this operation without being passed a specific\n * state.\n *\n * @param[in] obj_hdl          File on which to operate\n * @param[in] state            state_t to use for this operation\n * @param[in] offset           Start of range to commit\n * @param[in] len              Length of range to commit\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*commit2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t  off_t offset,\n\t\t\t\t  size_t len);\n\n/**\n * @brief Perform a lock operation\n *\n * This function performs a lock operation (lock, unlock, test) on a\n * file. This method assumes the FSAL is able to support lock owners,\n * though it need not support asynchronous blocking locks. Passing the\n * lock state allows the FSAL to associate information with a specific\n * lock owner for each file (which may include use of a \"file descriptor\".\n *\n * @param[in]  obj_hdl          File on which to operate\n * @param[in]  state            state_t to use for this operation\n * @param[in]  owner            Lock owner\n * @param[in]  lock_op          Operation to perform\n * @param[in]  request_lock     Lock to take/release/test\n * @param[out] conflicting_lock Conflicting lock\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*lock_op2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t   struct state_t *state,\n\t\t\t\t   void *owner,\n\t\t\t\t   fsal_lock_op_t lock_op,\n\t\t\t\t   fsal_lock_param_t *request_lock,\n\t\t\t\t   fsal_lock_param_t *conflicting_lock);\n\n/**\n * @brief Acquire or Release delegation\n *\n * This functions acquires/releases delegation/lease_lock.\n *\n * @param[in]  obj_hdl          File on which to operate\n * @param[in]  state            state_t to use for this operation\n * @param[in]  owner            Opaque state owner token\n * @param[in]  deleg            Requested delegation state\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*lease_op2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t    struct state_t *state,\n\t\t\t\t    void *owner,\n\t\t\t\t    fsal_deleg_t deleg);\n\n/**\n * @brief Set attributes on an object\n *\n * This function sets attributes on an object.  Which attributes are\n * set is determined by attrib_set->mask. The FSAL must manage bypass\n * or not of share reservations, and a state may be passed.\n *\n * The caller is expected to invoke fsal_release_attrs to release any\n * resources held by the set attributes. The FSAL layer MAY have added an\n * inherited ACL.\n *\n * @param[in] obj_hdl    File on which to operate\n * @param[in] bypass     If state doesn't indicate a share reservation,\n *                       bypass any non-mandatory deny write\n * @param[in] state      state_t to use for this operation\n * @param[in] attrib_set Attributes to set\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*setattr2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t   bool bypass,\n\t\t\t\t   struct state_t *state,\n\t\t\t\t   struct attrlist *attrib_set);\n\n/**\n * @brief Manage closing a file when a state is no longer needed.\n *\n * When the upper layers are ready to dispense with a state, this method is\n * called to allow the FSAL to close any file descriptors or release any other\n * resources associated with the state. A call to free_state should be assumed\n * to follow soon.\n *\n * @param[in] obj_hdl    File on which to operate\n * @param[in] state      state_t to use for this operation\n *\n * @return FSAL status.\n */\n\t fsal_status_t (*close2)(struct fsal_obj_handle *obj_hdl,\n\t\t\t\t struct state_t *state);\n\n/**@}*/\n\n/**\n * @brief Determine if the given handle is a referral point\n *\n * @param[in]\t  obj_hdl\tHandle on which to operate\n * @param[in|out] attrs\t\tAttributes of the handle\n * @param[in]\t  cache_attrs\tCache the received attrs\n *\n * @return true if it is a referral point, false otherwise\n */\n\n\t bool (*is_referral)(struct fsal_obj_handle *obj_hdl,\n\t\t\t     struct attrlist *attrs,\n\t\t\t     bool cache_attrs);\n\n/**@{*/\n\n/**\n * ASYNC API functions.\n *\n * These are asyncronous versions of some of the API functions.  FSALs are\n * expected to implement these, but the upper layers are not expected to call\n * them.  Instead, they will be called by MDCACHE at the appropriate points.\n */\n\n/**@}*/\n};\n\n/**\n * @brief FSAL pNFS Data Server operations vector\n */\n\nstruct fsal_pnfs_ds_ops {\n/**@{*/\n\n/**\n * Lifecycle management.\n */\n\n/**\n * @brief Clean up a server\n *\n * This function cleans up private resources associated with a\n * server and deallocates it.  A default is supplied.\n *\n * This function should not be called directly.\n *\n * @param[in]  pds\tFSAL pNFS DS to release\n */\n\t void (*release)(struct fsal_pnfs_ds *const pds);\n\n/**\n * @brief Initialize FSAL specific permissions per pNFS DS\n *\n * @param[in]  pds      FSAL pNFS DS\n * @param[in]  req      Incoming request.\n *\n * @return NFSv4.1 error codes:\n *\t\t\tNFS4_OK, NFS4ERR_ACCESS, NFS4ERR_WRONGSEC.\n */\n\t nfsstat4(*permissions)(struct fsal_pnfs_ds *const pds,\n\t\t\t\tstruct svc_req *req);\n/**@}*/\n\n/**@{*/\n\n/**\n * @brief Create a FSAL data server handle from a wire handle\n *\n * This function creates a FSAL data server handle from a client\n * supplied \"wire\" handle.\n *\n * @param[in]  pds      FSAL pNFS DS\n * @param[in]  hdl_desc Buffer from which to create the struct\n * @param[out] handle   FSAL DS handle\n *\n * @return NFSv4.1 error codes.\n */\n\t nfsstat4(*make_ds_handle)(struct fsal_pnfs_ds *const pds,\n\t\t\t\t   const struct gsh_buffdesc *\n\t\t\t\t   const hdl_desc,\n\t\t\t\t   struct fsal_ds_handle **const handle,\n\t\t\t\t   int flags);\n\n/**\n * @brief Initialize FSAL specific values for DS handle\n *\n * @param[in]  ops\tFSAL DS handle operations vector\n */\n\t void (*fsal_dsh_ops)(struct fsal_dsh_ops *ops);\n\n/**@}*/\n};\n\n/**\n * @brief FSAL DS handle operations vector\n */\n\nstruct fsal_dsh_ops {\n/**@{*/\n\n/**\n * Lifecycle management.\n */\n\n/**\n * @brief Clean up a DS handle\n *\n * This function cleans up private resources associated with a\n * filehandle and deallocates it.  Implement this method or you will\n * leak.  This function should not be called directly.\n *\n * @param[in] ds_hdl Handle to release\n */\n\t void (*release)(struct fsal_ds_handle *const ds_hdl);\n/**@}*/\n\n/**@{*/\n\n/**\n * I/O Functions\n */\n\n/**\n * @brief Read from a data-server handle.\n *\n * NFSv4.1 data server handles are disjount from normal\n * filehandles (in Ganesha, there is a ds_flag in the filehandle_v4_t\n * structure) and do not get loaded into cache_inode or processed the\n * normal way.\n *\n * @param[in]  ds_hdl           FSAL DS handle\n * @param[in]  req_ctx          Credentials\n * @param[in]  stateid          The stateid supplied with the READ operation,\n *                              for validation\n * @param[in]  offset           The offset at which to read\n * @param[in]  requested_length Length of read requested (and size of buffer)\n * @param[out] buffer           The buffer to which to store read data\n * @param[out] supplied_length  Length of data read\n * @param[out] eof              true on end of file\n *\n * @return An NFSv4.1 status code.\n */\n\t nfsstat4(*read)(struct fsal_ds_handle *const ds_hdl,\n\t\t\t struct req_op_context *const req_ctx,\n\t\t\t const stateid4 * stateid,\n\t\t\t const offset4 offset,\n\t\t\t const count4 requested_length,\n\t\t\t void *const buffer,\n\t\t\t count4 * const supplied_length,\n\t\t\t bool *const end_of_file);\n\n/**\n * @brief Read plus from a data-server handle.\n *\n * NFSv4.2 data server handles are disjount from normal\n * filehandles (in Ganesha, there is a ds_flag in the filehandle_v4_t\n * structure) and do not get loaded into cache_inode or processed the\n * normal way.\n *\n * @param[in]  ds_hdl           FSAL DS handle\n * @param[in]  req_ctx          Credentials\n * @param[in]  stateid          The stateid supplied with the READ operation,\n *                              for validation\n * @param[in]  offset           The offset at which to read\n * @param[in]  requested_length Length of read requested (and size of buffer)\n * @param[out] buffer           The buffer to which to store read data\n * @param[out] supplied_length  Length of data read\n * @param[out] eof              true on end of file\n * @param[out] info             IO info\n *\n * @return An NFSv4.2 status code.\n */\n\t nfsstat4(*read_plus)(struct fsal_ds_handle *const ds_hdl,\n\t\t\t      struct req_op_context *const req_ctx,\n\t\t\t      const stateid4 * stateid,\n\t\t\t      const offset4 offset,\n\t\t\t      const count4 requested_length,\n\t\t\t      void *const buffer,\n\t\t\t      const count4 supplied_length,\n\t\t\t      bool *const end_of_file,\n\t\t\t      struct io_info *info);\n\n/**\n *\n * @brief Write to a data-server handle.\n *\n * NFSv4.1 data server filehandles are disjount from normal\n * filehandles (in Ganesha, there is a ds_flag in the filehandle_v4_t\n * structure) and do not get loaded into cache_inode or processed the\n * normal way.\n *\n * @param[in]  ds_hdl           FSAL DS handle\n * @param[in]  req_ctx          Credentials\n * @param[in]  stateid          The stateid supplied with the READ operation,\n *                              for validation\n * @param[in]  offset           The offset at which to read\n * @param[in]  write_length     Length of write requested (and size of buffer)\n * @param[out] buffer           The buffer to which to store read data\n * @param[in]  stability wanted Stability of write\n * @param[out] written_length   Length of data written\n * @param[out] writeverf        Write verifier\n * @param[out] stability_got    Stability used for write (must be as\n *                              or more stable than request)\n *\n * @return An NFSv4.1 status code.\n */\n\t nfsstat4(*write)(struct fsal_ds_handle *const ds_hdl,\n\t\t\t  struct req_op_context *const req_ctx,\n\t\t\t  const stateid4 * stateid,\n\t\t\t  const offset4 offset,\n\t\t\t  const count4 write_length,\n\t\t\t  const void *buffer,\n\t\t\t  const stable_how4 stability_wanted,\n\t\t\t  count4 * const written_length,\n\t\t\t  verifier4 * const writeverf,\n\t\t\t  stable_how4 * const stability_got);\n\n/**\n * @brief Commit a byte range to a DS handle.\n *\n * NFSv4.1 data server filehandles are disjount from normal\n * filehandles (in Ganesha, there is a ds_flag in the filehandle_v4_t\n * structure) and do not get loaded into cache_inode or processed the\n * normal way.\n *\n * @param[in]  ds_hdl    FSAL DS handle\n * @param[in]  req_ctx   Credentials\n * @param[in]  offset    Start of commit window\n * @param[in]  count     Length of commit window\n * @param[out] writeverf Write verifier\n *\n * @return An NFSv4.1 status code.\n */\n\t nfsstat4(*commit)(struct fsal_ds_handle *const ds_hdl,\n\t\t\t   struct req_op_context *const req_ctx,\n\t\t\t   const offset4 offset,\n\t\t\t   const count4 count,\n\t\t\t   verifier4 * const writeverf);\n/**@}*/\n};\n\n/**\n * @brief FSAL object definition\n *\n * This structure is the base FSAL instance definition, providing the\n * public face to a single, loaded FSAL.\n */\n\nstruct fsal_module {\n\tstruct glist_head fsals;\t/*< link in list of loaded fsals */\n\tstruct glist_head exports;\t/*< Head of list of exports from\n\t\t\t\t\t   this FSAL */\n\tstruct glist_head handles;\t/*< Head of list of object handles */\n\tstruct glist_head servers;\t/*< Head of list of Data Servers */\n\tchar *path;\t\t/*< Path to .so file */\n\tchar *name;\t\t/*< Name set from .so and/or config */\n\tvoid *dl_handle;\t/*< Handle to the dlopen()d shared\n\t\t\t\t   library. NULL if statically linked */\n\tstruct fsal_ops m_ops;\t/*< FSAL module methods vector */\n\n\tpthread_rwlock_t lock;\t\t/*< Lock to be held when\n\t\t\t\t\t    manipulating its lists (above). */\n\tint32_t refcount;\t\t/*< Reference count */\n\tstruct fsal_stats *stats;   /*< for storing the FSAL specific stats */\n\tstruct fsal_staticfsinfo_t fs_info; /*< for storing FSAL static info */\n};\n\n/**\n * @brief Get a reference to a module\n *\n * @param[in] fsal_hdl FSAL on which to acquire reference.\n */\n\nstatic inline void fsal_get(struct fsal_module *fsal_hdl)\n{\n\t(void) atomic_inc_int32_t(&fsal_hdl->refcount);\n\tassert(fsal_hdl->refcount > 0);\n}\n\n/**\n * @brief Relinquish a reference to the module\n *\n * This function relinquishes one reference to the FSAL.  After the\n * reference count falls to zero, the FSAL may be freed and unloaded.\n *\n * @param[in] fsal_hdl FSAL on which to release reference.\n */\n\nstatic inline void fsal_put(struct fsal_module *fsal_hdl)\n{\n\tint32_t refcount;\n\n\trefcount = atomic_dec_int32_t (&fsal_hdl->refcount);\n\n\tassert(refcount >= 0);\n\n\tif (refcount == 0) {\n\t\tLogInfo(COMPONENT_FSAL,\n\t\t\t\"FSAL %s now unused\",\n\t\t\tfsal_hdl->name);\n\t}\n}\n\n/**\n * @brief Export object\n *\n * This structure is created by the @c create_export method on the\n * FSAL module.  It is stored as part of the export list and is used\n * to manage individual exports, interrogate properties of the\n * filesystem, and create individual file handle objects.\n */\n\nstruct fsal_export {\n\tstruct glist_head exports;\t/*< Link in list of exports from\n\t\t\t\t\t   the same FSAL. */\n\tstruct fsal_module *fsal;\t/*< Link back to the FSAL module */\n\tconst struct fsal_up_vector *up_ops;\t/*< Upcall operations */\n\tstruct export_ops exp_ops;\t/*< Vector of operations */\n\tstruct fsal_export *sub_export;\t/*< Sub export for stacking */\n\tstruct fsal_export *super_export;/*< Super export for stacking */\n\tuint16_t export_id; /*< Export ID copied from gsh_export, initialized\n\t\t\t\tby  fsal_export_init */\n};\n\n/**\n * @brief Public structure for filesystem descriptions\n *\n * This stucture is provided along with a general interface to support those\n * FSALs that map into a traditional file system model. Note that\n * fsal_obj_handles do not link to an fsal_filesystem, that linkage is reserved\n * for FSAL's private obj handle if appropriate.\n *\n */\n\nstruct fsal_filesystem {\n\tstruct glist_head filesystems;\t/*< List of file systems */\n\tstruct glist_head children;\t/*< Child file systems */\n\tstruct glist_head siblings;\t/*< Entry in list of parent's child\n\t\t\t\t\t    file systems */\n\tstruct fsal_filesystem *parent;\t/*< Parent file system */\n\tstruct fsal_module *fsal;\t/*< Link back to fsal module */\n\tvoid *private_data;\t\t/*< Private data for owning FSAL */\n\tchar *path;\t\t\t/*< Path to root of this file system */\n\tchar *device;\t\t\t/*< Path to block device */\n\tchar *type;\t\t\t/*< fs type */\n\n\tunclaim_filesystem_cb unclaim;  /*< Call back to unclaim this fs */\n\tuint32_t pathlen;\t\t/*< Length of path */\n\tuint32_t namelen;\t\t/*< Name length from statfs */\n\n\tstruct avltree_node avl_fsid;\t/*< AVL indexed by fsid */\n\tstruct avltree_node avl_dev;\t/*< AVL indexed by dev */\n\tstruct fsal_fsid__ fsid;\t/*< file system id */\n\tfsal_dev_t dev;\t\t\t/*< device filesystem is on */\n\tenum fsid_type fsid_type;\t/*< type of fsid present */\n\tbool in_fsid_avl;\t\t/*< true if inserted in fsid avl */\n\tbool in_dev_avl;\t\t/*< true if inserted in dev avl */\n\tbool exported;\t\t\t/*< true if explicitly exported */\n};\n\n/**\n * @brief Public structure for filesystem objects\n *\n * This structure is used for files of all types including directories\n * and anything else that can be operated on via NFS.\n *\n * All functions that create a a new object handle should allocate\n * memory for the complete (public and private) handle and perform any\n * private initialization.  They should fill the\n * @c fsal_obj_handle::attributes structure.  They should also call the\n * @c fsal_obj_handle_init function with the public object handle,\n * object handle operations vector, public export, and file type.\n *\n * @note Do we actually need a lock and ref count on the fsal object\n * handle, since cache_inode is managing life cycle and concurrency?\n * That is, do we expect fsal_obj_handle to have a reference count\n * that would be separate from that managed by cache_inode_lru?\n */\n\nstruct fsal_obj_handle {\n\tstruct glist_head handles;\t/*< Link in list of handles under\n\t\t\t\t\t   the same FSAL. */\n\tstruct fsal_filesystem *fs;\t/*< Owning filesystem */\n\tstruct fsal_module *fsal;\t/*< Link back to fsal module */\n\tstruct fsal_obj_ops *obj_ops;\t/*< Operations vector */\n\n\tpthread_rwlock_t obj_lock;\t\t/*< Lock on handle */\n\n\t/* Static attributes */\n\tobject_file_type_t type;\t/*< Object file type */\n\tfsal_fsid_t fsid;\t/*< Filesystem on which this object is\n\t\t\t\t   stored */\n\tuint64_t fileid;\t/*< Unique identifier for this object within\n\t\t\t\t   the scope of the fsid, (e.g. inode number) */\n\n\tstruct state_hdl *state_hdl;\t/*< State related to this handle */\n};\n\n/**\n * @brief Public structure for pNFS Data Servers\n *\n * This structure is used for files of all types including directories\n * and anything else that can be operated on via NFS.  Having an\n * independent reference count and lock here makes sense, since there\n * is no caching infrastructure overlaying this system.\n *\n */\n\nenum pnfs_ds_status {\n\tPNFS_DS_READY,\t\t\t/*< searchable, usable */\n\tPNFS_DS_STALE,\t\t\t/*< is no longer valid */\n};\n\n/**\n * @brief PNFS Data Server\n *\n * This represents a Data Server for PNFS.  It may be stand-alone, or may be\n * associated with an export (which represents an MDS).\n */\nstruct fsal_pnfs_ds {\n\tstruct glist_head ds_list;\t/**< Entry in list of all DSs */\n\tstruct glist_head server;\t/**< Link in list of Data Servers under\n\t\t\t\t\t   the same FSAL. */\n\tstruct glist_head ds_handles;\t/**< Head of list of DS handles */\n\tstruct fsal_module *fsal;\t/**< Link back to fsal module */\n\tstruct fsal_pnfs_ds_ops s_ops;\t/**< Operations vector */\n\tstruct gsh_export *mds_export;\t/**< related export */\n\tstruct fsal_export *mds_fsal_export;\t/**< related FSAL export (avoids\n\t\t\t\t\t\t  MDS stacking) */\n\n\tstruct avltree_node ds_node;\t/**< Node in tree of all Data Servers */\n\tpthread_rwlock_t lock;\t\t/**< Lock to be held when\n\t\t\t\t\t    manipulating its list (above). */\n\tint32_t refcount;\t\t/**< Reference count */\n\tuint16_t id_servers;\t\t/**< Identifier */\n\tuint8_t pnfs_ds_status;\t\t/**< current condition */\n};\n\n/**\n * @brief Public structure for DS file handles\n *\n * This structure is used for files of all types including directories\n * and anything else that can be operated on via NFS.  Having an\n * independent reference count and lock here makes sense, since there\n * is no caching infrastructure overlaying this system.\n *\n */\n\nstruct fsal_ds_handle {\n\tstruct glist_head ds_handle;\t/*< Link in list of DS handles under\n\t\t\t\t\t   the same pDS. */\n\tstruct fsal_pnfs_ds *pds;\t/*< Link back to pDS */\n\tstruct fsal_dsh_ops dsh_ops;\t/*< Operations vector */\n\n\tint64_t refcount;\t\t/*< Reference count */\n};\n\n/**\n * @brief Get a reference on a DS handle\n *\n * This function increments the reference count on a DS handle.\n *\n * @param[in] ds_hdl The handle to reference\n */\n\nstatic inline void ds_handle_get_ref(struct fsal_ds_handle *const ds_hdl)\n{\n\t(void) atomic_inc_int64_t (&ds_hdl->refcount);\n}\n\n/**\n * @brief Release a reference on a DS handle\n *\n * This function releases a reference to a DS handle.  Once a caller's\n * reference is released they should make no attempt to access the\n * handle or even dereference a pointer to it.\n *\n * @param[in] ds_hdl The handle to relinquish\n */\n\nstatic inline void ds_handle_put(struct fsal_ds_handle *const ds_hdl)\n{\n\tint64_t refcount = atomic_dec_int64_t (&ds_hdl->refcount);\n\n\tif (refcount != 0) {\n\t\tassert(refcount > 0);\n\t\treturn;\n\t}\n\n\tds_hdl->dsh_ops.release(ds_hdl);\n}\n\n/**\n** Resolve forward declarations\n*/\n#include \"client_mgr.h\"\n#include \"export_mgr.h\"\n#include \"fsal_up.h\"\n\n#endif\t\t\t\t/* !FSAL_API */\n/** @} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/include/FSAL/fsal_init.h": "/**\n * @file fsal_init.h\n * @author Jim Lieb <jlieb@panasas.com>\n * @brief Module initialization\n */\n\n/**\n * @brief Initializer macro\n *\n * Every FSAL module has an initializer.  any function labeled as\n * MODULE_INIT will be called in order after the module is loaded and\n * before dlopen returns.  This is where you register your fsal.\n *\n * The initializer function should use register_fsal to initialize\n * public data and get the default operation vectors, then override\n * them with module-specific methods.\n */\n\n#define MODULE_INIT __attribute__((constructor))\n\n/**\n * @brief Finalizer macro\n *\n * Every FSAL module *must* have a destructor to free any resources.\n * the function should assert() that the module can be safely unloaded.\n * However, the core should do the same check prior to attempting an\n * unload. The function must be defined as void foo(void), i.e. no args\n * passed and no returns evaluated.\n */\n\n#define MODULE_FINI __attribute__((destructor))\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/config_parsing/conf_url.c": "/* ----------------------------------------------------------------------------\n * Copyright (C) 2017, Red Hat, Inc.\n * contributeur : Matt Benjamin  mbenjamin@redhat.com\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301 USA\n * ---------------------------------------\n */\n\n#include \"config.h\"\n#include <regex.h>\n#include <dlfcn.h>\n#include \"log.h\"\n#include \"sal_functions.h\"\n\n#include \"conf_url.h\"\n\nstatic pthread_rwlock_t url_rwlock = PTHREAD_RWLOCK_INITIALIZER;\nstatic struct glist_head url_providers;\nstatic regex_t url_regex;\n\n/** @brief register handler for new url type\n */\nint register_url_provider(struct gsh_url_provider *nurl_p)\n{\n\tstruct gsh_url_provider *url_p;\n\tstruct glist_head *gl;\n\tint code = 0;\n\n\tPTHREAD_RWLOCK_wrlock(&url_rwlock);\n\tglist_for_each(gl, &url_providers) {\n\t\turl_p = glist_entry(gl, struct gsh_url_provider, link);\n\t\tif (!strcasecmp(url_p->name, nurl_p->name)) {\n\t\t\tcode = EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnurl_p->url_init();\n\tglist_add_tail(&url_providers, &nurl_p->link);\n\n\tPTHREAD_RWLOCK_unlock(&url_rwlock);\n\treturn code;\n}\n\n/* simplistic URL syntax */\n#define CONFIG_URL_REGEX \\\n\t\"^\\\"?(rados)://([^\\\"]+)\\\"?\"\n\n/** @brief url regex initializer\n */\nstatic void init_url_regex(void)\n{\n\tint r;\n\n\tr = regcomp(&url_regex, CONFIG_URL_REGEX, REG_EXTENDED);\n\tif (!!r) {\n\t\tLogFatal(COMPONENT_INIT,\n\t\t\t\"Error initializing config url regex\");\n\t}\n}\n\n#ifdef RADOS_URLS\nstatic struct {\n\tvoid *dl;\n\tvoid (*pkginit)(void);\n\tint (*setup_watch)(void);\n\tvoid (*shutdown_watch)(void);\n} rados_urls = { NULL,};\n\nstatic void load_rados_config(void)\n{\n\trados_urls.dl = dlopen(\"libganesha_rados_urls.so\",\n#if defined(LINUX) && !defined(SANITIZE_ADDRESS)\n\t\t\t      RTLD_NOW | RTLD_LOCAL | RTLD_DEEPBIND);\n#elif defined(FREEBSD) || defined(SANITIZE_ADDRESS)\n\t\t\t      RTLD_NOW | RTLD_LOCAL);\n#endif\n\n\tif (rados_urls.dl) {\n\t\trados_urls.pkginit = dlsym(rados_urls.dl,\n\t\t\t\t\t   \"conf_url_rados_pkginit\");\n\t\trados_urls.setup_watch = dlsym(rados_urls.dl,\n\t\t\t\t\t       \"rados_url_setup_watch\");\n\t\trados_urls.shutdown_watch = dlsym(rados_urls.dl,\n\t\t\t\t\t\t  \"rados_url_shutdown_watch\");\n\n\t\tif (!rados_urls.pkginit || !rados_urls.setup_watch ||\n\t\t    !rados_urls.shutdown_watch) {\n\t\t\tdlclose(rados_urls.dl);\n\t\t\trados_urls.dl = NULL;\n\t\t\tLogCrit(COMPONENT_CONFIG, \"Unknown urls backend\");\n\t\t}\n\t} else {\n\t\tLogCrit(COMPONENT_CONFIG, \"Unknown urls backend\");\n\t}\n}\n\n#endif\n\n/** @brief package initializer\n */\nvoid config_url_init(void)\n{\n\tglist_init(&url_providers);\n\n/* init well-known URL providers */\n#ifdef RADOS_URLS\n\tif (!rados_urls.dl)\n\t\tload_rados_config();\n\n\tif (rados_urls.pkginit)\n\t\trados_urls.pkginit();\n#endif\n\tinit_url_regex();\n}\n\n/** @brief package shutdown\n */\nvoid config_url_shutdown(void)\n{\n\tstruct gsh_url_provider *url_p;\n\n\tPTHREAD_RWLOCK_wrlock(&url_rwlock);\n\twhile ((url_p = glist_first_entry(\n\t\t\t      &url_providers, struct gsh_url_provider, link))) {\n\t\tglist_del(&url_p->link);\n\t\turl_p->url_shutdown();\n\t}\n\tPTHREAD_RWLOCK_unlock(&url_rwlock);\n\n\tregfree(&url_regex);\n\n#ifdef RADOS_URLS\n\tif (rados_urls.dl)\n\t\tdlclose(rados_urls.dl);\n\trados_urls.dl = NULL;\n#endif\n}\n\nint gsh_rados_url_setup_watch(void)\n{\n#ifdef RADOS_URLS\n\treturn rados_urls.setup_watch ? rados_urls.setup_watch() : -1;\n#else\n\treturn -1;\n#endif\n}\n\nvoid gsh_rados_url_shutdown_watch(void)\n{\n#ifdef RADOS_URLS\n\tif (rados_urls.shutdown_watch)\n\t\trados_urls.shutdown_watch();\n#else\n\treturn; /* non-empty fn to avoid compile warning/error */\n#endif\n}\n\nstatic inline char *match_dup(regmatch_t *m, char *in)\n{\n\tchar *s = NULL;\n\n\tif (m->rm_so >= 0) {\n\t\tint size;\n\n\t\tsize = m->rm_eo - m->rm_so + 1;\n\t\ts = (char *)gsh_malloc(size);\n\t\t(void) snprintf(s, size, \"%s\", in + m->rm_so);\n\t}\n\treturn s;\n}\n\n/** @brief generic url dispatch\n */\nint config_url_fetch(const char *url, FILE **f, char **fbuf)\n{\n\tstruct gsh_url_provider *url_p;\n\tstruct glist_head *gl;\n\tregmatch_t match[3];\n\tchar *url_type = NULL, *m_url = NULL;\n\tint code = EINVAL;\n\n\tcode = regexec(&url_regex, url, 3, match, 0);\n\tif (likely(!code)) {\n\t\t/* matched */\n\t\tregmatch_t *m;\n\n\t\tm = &(match[1]);\n\t\turl_type = match_dup(m, (char *)url);\n\t\tm = &(match[2]);\n\t\tm_url = match_dup(m, (char *)url);\n\t\tif (!(url_type && m_url)) {\n\t\t\tLogWarn(COMPONENT_CONFIG,\n\t\t\t\t\"%s: Failed to match %s as a config URL\",\n\t\t\t\t__func__, url);\n\t\t\tgoto out;\n\t\t}\n\t} else if (code == REG_NOMATCH) {\n\t\tLogWarn(COMPONENT_CONFIG,\n\t\t\t\"%s: Failed to match %s as a config URL\",\n\t\t\t__func__, url);\n\t\tgoto out;\n\t} else {\n\t\tchar ebuf[100];\n\n\t\tregerror(code, &url_regex, ebuf, sizeof(ebuf));\n\t\tLogWarn(COMPONENT_CONFIG,\n\t\t\t\"%s: Error in regexec: %s\",\n\t\t\t__func__, ebuf);\n\t\tgoto out;\n\t}\n\n\tPTHREAD_RWLOCK_rdlock(&url_rwlock);\n\tglist_for_each(gl, &url_providers) {\n\t\turl_p = glist_entry(gl, struct gsh_url_provider, link);\n\t\tif (!strcasecmp(url_type, url_p->name)) {\n\t\t\tcode = url_p->url_fetch(m_url, f, fbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPTHREAD_RWLOCK_unlock(&url_rwlock);\nout:\n\tgsh_free(url_type);\n\tgsh_free(m_url);\n\n\treturn code;\n}\n\n/** @brief return resources allocated by url_fetch\n */\nvoid config_url_release(FILE *f, char *fbuf)\n{\n\tfclose(f);\n\tfree(fbuf);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/fsal_manager.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n * -------------\n */\n\n/**\n * @addtogroup FSAL\n * @{\n */\n\n/**\n * @file fsal_manager.c\n * @author Jim Lieb <jlieb@panasas.com>\n * @brief FSAL module manager\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include \"log.h\"\n#include \"fsal.h\"\n#include \"nfs_core.h\"\n#include \"config_parsing.h\"\n#include \"pnfs_utils.h\"\n#include \"fsal_private.h\"\n\n/**\n * @brief List of loaded fsal modules\n *\n * Static to be private to the functions in this module\n * fsal_lock is taken whenever the list is walked.\n */\n\npthread_mutex_t fsal_lock = PTHREAD_MUTEX_INITIALIZER;\nGLIST_HEAD(fsal_list);\n\n/**\n * @{\n *\n * Variables for passing status/errors between shared object\n * and this module. They must be accessed under lock.\n */\n\nstatic char *dl_error;\nstatic int so_error;\nstatic struct fsal_module *new_fsal;\n\n/**\n * @}\n */\n\n/**\n * @brief FSAL load state\n */\n\nstatic enum load_state {\n\tinit,\t\t/*< In server start state. .init sections can run */\n\tidle,\t\t/*< Switch from init->idle early in main() */\n\tloading,\t/*< In dlopen(). set by load_fsal() just prior */\n\tregistered,\t/*< signal by registration that all is well */\n\terror\t\t/*< signal by registration that all is not well */\n} load_state = init;\n\n\n/**\n * @brief Start a static FSAL\n *\n * Start a FSAL that's statically linked in.\n *\n * @param[in] name\tFSAL name\n * @param[in] init\tInitialization function for FSAL\n */\n\nstatic void load_fsal_static(const char *name, void (*init)(void))\n{\n\tchar *dl_path = gsh_concat(\"Builtin-\", name);\n\tstruct fsal_module *fsal;\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\n\tif (load_state != idle)\n\t\tLogFatal(COMPONENT_INIT, \"Couldn't Register FSAL_%s\", name);\n\n\tif (dl_error) {\n\t\tgsh_free(dl_error);\n\t\tdl_error = NULL;\n\t}\n\n\tload_state = loading;\n\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\n\t/* now it is the module's turn to register itself */\n\tinit();\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\n\tif (load_state != registered)\n\t\tLogFatal(COMPONENT_INIT, \"Couldn't Register FSAL_%s\", name);\n\n\t/* we now finish things up, doing things the module can't see */\n\n\tfsal = new_fsal;   /* recover handle from .ctor and poison again */\n\tnew_fsal = NULL;\n\tfsal->path = dl_path;\n\tfsal->dl_handle = NULL;\n\tso_error = 0;\n\tload_state = idle;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n}\n\n/**\n * @brief Start_fsals\n *\n * Called early server initialization.  Set load_state to idle\n * at this point as a check on dynamic loading not starting too early.\n */\n\nvoid start_fsals(void)\n{\n\n\t/* .init was a long time ago... */\n\tload_state = idle;\n\n\t/* Load FSAL_MDCACHE */\n\tload_fsal_static(\"MDCACHE\", mdcache_fsal_init);\n\n\t/* Load FSAL_PSEUDO */\n\tload_fsal_static(\"PSEUDO\", pseudo_fsal_init);\n}\n\n/**\n * Enforced filename for FSAL library objects.\n */\n\nstatic const char *pathfmt = \"%s/libfsal%s.so\";\n\n/**\n * @brief Load the fsal's shared object.\n *\n * The dlopen() will trigger a .init constructor which will do the\n * actual registration.  after a successful load, the returned handle\n * needs to be \"put\" back after any other initialization is done.\n *\n * @param[in]  name       Name of the FSAL to load\n * @param[out] fsal_hdl_p Newly allocated FSAL handle\n *\n * @retval 0 Success, when finished, put_fsal_handle() to free\n * @retval EBUSY the loader is busy (should not happen)\n * @retval EEXIST the module is already loaded\n * @retval ENOLCK register_fsal without load_fsal holding the lock.\n * @retval EINVAL wrong loading state for registration\n * @retval ENOMEM out of memory\n * @retval ENOENT could not find \"module_init\" function\n * @retval EFAULT module_init has a bad address\n * @retval other general dlopen errors are possible, all of them bad\n */\n\nint load_fsal(const char *name,\n\t      struct fsal_module **fsal_hdl_p)\n{\n\tvoid *dl = NULL;\n\tint retval = EBUSY;\t/* already loaded */\n\tchar *dl_path;\n\tstruct fsal_module *fsal;\n\tchar *bp;\n\tsize_t size = strlen(nfs_param.core_param.ganesha_modules_loc)\n\t\t      + strlen(name)\n\t\t      + strlen(pathfmt) + 1;\n\tchar *path = alloca(size);\n\n\t(void) snprintf(path, size, pathfmt,\n\t\t\tnfs_param.core_param.ganesha_modules_loc, name);\n\tbp = rindex(path, '/');\n\tbp++; /* now it is the basename, lcase it */\n\twhile (*bp != '\\0') {\n\t\tif (isupper(*bp))\n\t\t\t*bp = tolower(*bp);\n\t\tbp++;\n\t}\n\tdl_path = gsh_strdup(path);\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\tif (load_state != idle)\n\t\tgoto errout;\n\tif (dl_error) {\n\t\tgsh_free(dl_error);\n\t\tdl_error = NULL;\n\t}\n\n\tload_state = loading;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\n\tLogDebug(COMPONENT_INIT, \"Loading FSAL %s with %s\", name, path);\n#if defined(LINUX) && !defined(SANITIZE_ADDRESS)\n\tdl = dlopen(path, RTLD_NOW | RTLD_LOCAL | RTLD_DEEPBIND);\n#elif defined(FREEBSD) || defined(SANITIZE_ADDRESS)\n\tdl = dlopen(path, RTLD_NOW | RTLD_LOCAL);\n#endif\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\tif (dl == NULL) {\n\t\tdl_error = dlerror();\n\t\tLogFatal(COMPONENT_INIT,\n\t\t\t \"Could not dlopen module: %s Error: %s. You might want to install the nfs-ganesha-%s package\",\n\t\t\t path, dl_error, name);\n\t}\n\tdlerror();\t/* clear it */\n\n/* now it is the module's turn to register itself */\n\n\n\tif (load_state == loading) {\n\t\t/* constructor didn't fire */\n\t\tvoid (*module_init)(void);\n\t\tchar *sym_error;\n\n\t\tmodule_init = dlsym(dl, \"fsal_init\");\n\t\tsym_error = (char *)dlerror();\n\t\tif (sym_error != NULL) {\n\t\t\tdl_error = gsh_strdup(sym_error);\n\t\t\tso_error = ENOENT;\n\t\t\tLogCrit(COMPONENT_INIT,\n\t\t\t\t\"Could not execute symbol fsal_init from module:%s Error:%s\",\n\t\t\t\tpath, dl_error);\n\t\t\tgoto dlerr;\n\t\t}\n\t\tif ((void *)module_init == NULL) {\n\t\t\tso_error = EFAULT;\n\t\t\tLogCrit(COMPONENT_INIT,\n\t\t\t\t\"Could not execute symbol fsal_init from module:%s Error:%s\",\n\t\t\t\tpath, dl_error);\n\t\t\tgoto dlerr;\n\t\t}\n\t\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\n\t\t(*module_init) ();\t/* try registering by hand this time */\n\n\t\tPTHREAD_MUTEX_lock(&fsal_lock);\n\t}\n\tif (load_state == error) {\t/* we are in registration hell */\n\t\tretval = so_error;\t/* this is the registration error */\n\t\tLogCrit(COMPONENT_INIT,\n\t\t\t\"Could not execute symbol fsal_init from module:%s Error:%s\",\n\t\t\tpath, dl_error);\n\t\tgoto dlerr;\n\t}\n\tif (load_state != registered) {\n\t\tretval = EPERM;\n\t\tLogCrit(COMPONENT_INIT,\n\t\t\t\"Could not execute symbol fsal_init from module:%s Error:%s\",\n\t\t\tpath, dl_error);\n\t\tgoto dlerr;\n\t}\n\n/* we now finish things up, doing things the module can't see */\n\n\tfsal = new_fsal;   /* recover handle from .ctor and poison again */\n\tnew_fsal = NULL;\n\n\t/* take initial ref so we can pass it back... */\n\tfsal_get(fsal);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"FSAL %s refcount %\"PRIu32,\n\t\t     name, atomic_fetch_int32_t(&fsal->refcount));\n\n\tfsal->path = dl_path;\n\tfsal->dl_handle = dl;\n\tso_error = 0;\n\t*fsal_hdl_p = fsal;\n\tload_state = idle;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\treturn 0;\n\ndlerr:\n\tdlclose(dl);\nerrout:\n\tload_state = idle;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\tLogMajor(COMPONENT_INIT, \"Failed to load module (%s) because: %s\",\n\t\t path,\n\t\t strerror(retval));\n\tgsh_free(dl_path);\n\treturn retval;\n}\n\n/**\n * @brief Look up an FSAL\n *\n * Acquire a handle to the named FSAL and take a reference to it. This\n * must be done before using any methods.  Once done, release it with\n * @c put_fsal.\n *\n * @param[in] name Name to look up\n *\n * @return Module pointer or NULL if not found.\n */\n\nstruct fsal_module *lookup_fsal(const char *name)\n{\n\tstruct fsal_module *fsal;\n\tstruct glist_head *entry;\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\tglist_for_each(entry, &fsal_list) {\n\t\tfsal = glist_entry(entry, struct fsal_module, fsals);\n\t\tif (strcasecmp(name, fsal->name) == 0) {\n\t\t\tfsal_get(fsal);\n\t\t\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\t\t\top_ctx->fsal_module = fsal;\n\t\t\tLogFullDebug(COMPONENT_FSAL,\n\t\t\t\t     \"FSAL %s refcount %\"PRIu32,\n\t\t\t\t     name,\n\t\t\t\t     atomic_fetch_int32_t(&fsal->refcount));\n\t\t\treturn fsal;\n\t\t}\n\t}\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\treturn NULL;\n}\n\n/* functions only called by modules at ctor/dtor time\n */\n\n/**\n * @brief Register the fsal in the system\n *\n * This can be called from three places:\n *\n *  + the server program's .init section if the fsal was statically linked\n *  + the shared object's .init section when load_fsal() dynamically loads it.\n *  + from the shared object's 'fsal_init' function if dlopen does not support\n *    .init/.fini sections.\n *\n * Any other case is an error.\n * Change load_state only for dynamically loaded modules.\n *\n * @param[in] fsal_hdl      FSAL module handle\n * @param[in] name          FSAL name\n * @param[in] major_version Major version\n * @param[in] minor_version Minor version\n *\n * @return 0 on success, otherwise POSIX errors.\n */\n\n/** @todo implement api versioning and pass the major,minor here\n */\n\nint register_fsal(struct fsal_module *fsal_hdl, const char *name,\n\t\t  uint32_t major_version, uint32_t minor_version,\n\t\t  uint8_t fsal_id)\n{\n\tpthread_rwlockattr_t attrs;\n\n\tPTHREAD_MUTEX_lock(&fsal_lock);\n\tif ((major_version != FSAL_MAJOR_VERSION)\n\t    || (minor_version > FSAL_MINOR_VERSION)) {\n\t\tso_error = EINVAL;\n\t\tLogCrit(COMPONENT_INIT,\n\t\t\t\"FSAL \\\"%s\\\" failed to register because of version mismatch core = %d.%d, fsal = %d.%d\",\n\t\t\tname,\n\t\t\tFSAL_MAJOR_VERSION, FSAL_MINOR_VERSION, major_version,\n\t\t\tminor_version);\n\t\tload_state = error;\n\t\tgoto errout;\n\t}\n\tso_error = 0;\n\tif (!(load_state == loading || load_state == init)) {\n\t\tso_error = EACCES;\n\t\tgoto errout;\n\t}\n\tnew_fsal = fsal_hdl;\n\tif (name != NULL)\n\t\tnew_fsal->name = gsh_strdup(name);\n\n\t/* init ops vector to system wide defaults\n\t * from FSAL/default_methods.c\n\t */\n\tmemcpy(&fsal_hdl->m_ops, &def_fsal_ops, sizeof(struct fsal_ops));\n\n\tpthread_rwlockattr_init(&attrs);\n#ifdef GLIBC\n\tpthread_rwlockattr_setkind_np(\n\t\t&attrs,\n\t\tPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n#endif\n\tPTHREAD_RWLOCK_init(&fsal_hdl->lock, &attrs);\n\tpthread_rwlockattr_destroy(&attrs);\n\tglist_init(&fsal_hdl->servers);\n\tglist_init(&fsal_hdl->handles);\n\tglist_init(&fsal_hdl->exports);\n\tglist_add_tail(&fsal_list, &fsal_hdl->fsals);\n\tif (load_state == loading)\n\t\tload_state = registered;\n\tif (fsal_id != FSAL_ID_NO_PNFS && fsal_id < FSAL_ID_COUNT)\n\t\tpnfs_fsal[fsal_id] = fsal_hdl;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\treturn 0;\n\n errout:\n\n\tgsh_free(fsal_hdl->path);\n\tgsh_free(fsal_hdl->name);\n\tload_state = error;\n\tPTHREAD_MUTEX_unlock(&fsal_lock);\n\tLogCrit(COMPONENT_INIT, \"FSAL \\\"%s\\\" failed to register because: %s\",\n\t\tname, strerror(so_error));\n\treturn so_error;\n}\n\n/**\n * @brief Unregisterx an FSAL\n *\n * Verify that the fsal is not busy and release all its resources\n * owned at this level.  RW Lock is already freed.  Called from the\n * module's MODULE_FINI\n *\n * @param[in] fsal_hdl FSAL handle\n *\n * @retval 0 on success.\n * @retval EBUSY if FSAL is in use.\n */\n\nint unregister_fsal(struct fsal_module *fsal_hdl)\n{\n\tint32_t refcount = atomic_fetch_int32_t(&fsal_hdl->refcount);\n\n\tif (refcount != 0) {\n\t\t/* this would be very bad */\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"Unregister FSAL %s with non-zero refcount=%\"PRIi32,\n\t\t\tfsal_hdl->name, refcount);\n\t\treturn EBUSY;\n\t}\n\tgsh_free(fsal_hdl->path);\n\tgsh_free(fsal_hdl->name);\n\treturn 0;\n}\n\n/**\n * @brief Init and commit for FSAL sub-block\n */\n\n/**\n * @brief Initialize space for an FSAL sub-block.\n *\n * We allocate space to hold the name parameter so that\n * is available in the commit phase.\n */\n\nvoid *fsal_init(void *link_mem, void *self_struct)\n{\n\tstruct fsal_args *fp;\n\n\tassert(link_mem != NULL || self_struct != NULL);\n\n\tif (link_mem == NULL) {\n\t\treturn self_struct; /* NOP */\n\t} else if (self_struct == NULL) {\n\t\tvoid *args = gsh_calloc(1, sizeof(struct fsal_args));\n\n\t\tLogFullDebug(COMPONENT_CONFIG,\n\t\t\t     \"Allocating args %p/%p\",\n\t\t\t     link_mem, args);\n\t\treturn args;\n\t} else {\n\t\tfp = self_struct;\n\t\tgsh_free(fp->name);\n\t\tgsh_free(fp);\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief Load and initialize FSAL module\n *\n * Use the name parameter to lookup the fsal. If the fsal is not\n * loaded (yet), load it and call its init. This will trigger the\n * processing of a top level block of the same name as the fsal, i.e.\n * the VFS fsal will look for a VFS block and process it (if found).\n *\n * @param[in]  node       parse node of FSAL block\n * @param[in]  name       name of the FSAL to load and initialize (if\n *                        not already loaded)\n * @param[out] fsal_hdl   Pointer to FSAL module or NULL if not found\n * @param[out] err_type   pointer to error type\n *\n * @retval 0 on success, error count on errors\n */\n\nint fsal_load_init(void *node, const char *name, struct fsal_module **fsal_hdl,\n\t\t   struct config_error_type *err_type)\n{\n\tfsal_status_t status;\n\n\tif (name == NULL || strlen(name) == 0) {\n\t\tconfig_proc_error(node, err_type,\n\t\t\t\t  \"Name of FSAL is missing\");\n\t\terr_type->missing = true;\n\t\treturn 1;\n\t}\n\n\t*fsal_hdl = lookup_fsal(name);\n\tif (*fsal_hdl == NULL) {\n\t\tint retval;\n\t\tconfig_file_t myconfig;\n\n\t\tretval = load_fsal(name, fsal_hdl);\n\t\tif (retval != 0) {\n\t\t\tconfig_proc_error(node, err_type,\n\t\t\t\t\t  \"Failed to load FSAL (%s) because: %s\",\n\t\t\t\t\t  name,\tstrerror(retval));\n\t\t\terr_type->fsal = true;\n\t\t\treturn 1;\n\t\t}\n\t\top_ctx->fsal_module = *fsal_hdl;\n\t\tmyconfig = get_parse_root(node);\n\t\tstatus = (*fsal_hdl)->m_ops.init_config(*fsal_hdl,\n\t\t\t\t\t\t\tmyconfig, err_type);\n\t\tif (FSAL_IS_ERROR(status)) {\n\t\t\tconfig_proc_error(node, err_type,\n\t\t\t\t\t  \"Failed to initialize FSAL (%s)\",\n\t\t\t\t\t  name);\n\t\t\tfsal_put(*fsal_hdl);\n\t\t\terr_type->fsal = true;\n\t\t\tLogFullDebug(COMPONENT_FSAL,\n\t\t\t\t     \"FSAL %s refcount %\"PRIu32,\n\t\t\t\t     name,\n\t\t\t\t     atomic_fetch_int32_t(\n\t\t\t\t\t\t&(*fsal_hdl)->refcount));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * @brief Load and initialize sub-FSAL module\n *\n * @retval 0 on success, error count on errors\n */\n\nint subfsal_commit(void *node, void *link_mem, void *self_struct,\n\t\t   struct config_error_type *err_type)\n{\n\tstruct fsal_module *fsal_next;\n\tstruct subfsal_args *subfsal = (struct subfsal_args *)self_struct;\n\tint errcnt = fsal_load_init(node, subfsal->name, &fsal_next, err_type);\n\n\tif (errcnt == 0)\n\t\tsubfsal->fsal_node = node;\n\n\treturn errcnt;\n}\n\n/** @} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_GPFS/main.c": "/** @file main.c\n *  @brief GPFS FSAL module core functions\n *\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n#include <sys/types.h>\n#include \"fsal.h\"\n#include \"fsal_internal.h\"\n#include \"FSAL/fsal_init.h\"\n#include \"gpfs_methods.h\"\n#include \"gsh_config.h\"\n\nstatic const char myname[] = \"GPFS\";\n\n/** @struct GPFS\n *  @brief my module private storage\n */\nstruct gpfs_fsal_module GPFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = INT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = false,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.link_support = true,\n\t\t\t.symlink_support = true,\n\t\t\t.lock_support = true,\n\t\t\t.lock_support_async_block = true,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW |\n\t\t\t\t\t\t\tFSAL_ACLSUPPORT_DENY,\n\t\t\t.cansettime = true,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = GPFS_SUPPORTED_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.umask = 0,\n\t\t\t.auth_exportpath_xdev = true,\n\t\t\t/* @todo Update lease handling to use new interfaces */\n\t\t\t#if 0\n\t\t\t/** not working with pNFS */\n\t\t\t.delegations = FSAL_OPTION_FILE_READ_DELEG,\n\t\t\t#endif\n\t\t\t.pnfs_mds = true,\n\t\t\t.pnfs_ds = true,\n\t\t\t.fsal_trace = true,\n\t\t\t.fsal_grace = false,\n\t\t\t.link_supports_permission_checks = true,\n\t\t\t.expire_time_parent = 60,\n\t\t}\n\t}\n};\n\n/** @struct gpfs_params\n *  @brief Configuration items\n */\nstatic struct config_item gpfs_params[] = {\n\tCONF_ITEM_BOOL(\"link_support\", true,\n\t\t       fsal_staticfsinfo_t, link_support),\n\tCONF_ITEM_BOOL(\"symlink_support\", true,\n\t\t       fsal_staticfsinfo_t, symlink_support),\n\tCONF_ITEM_BOOL(\"cansettime\", true,\n\t\t       fsal_staticfsinfo_t, cansettime),\n\tCONF_ITEM_MODE(\"umask\", 0,\n\t\t       fsal_staticfsinfo_t, umask),\n\tCONF_ITEM_BOOL(\"auth_xdev_export\", false,\n\t\t       fsal_staticfsinfo_t, auth_exportpath_xdev),\n\t/** At the moment GPFS doesn't support WRITE delegations */\n\tCONF_ITEM_ENUM_BITS(\"Delegations\",\n\t\t\t    FSAL_OPTION_FILE_READ_DELEG,\n\t\t\t    FSAL_OPTION_FILE_DELEGATIONS,\n\t\t\t    deleg_types, fsal_staticfsinfo_t, delegations),\n\tCONF_ITEM_BOOL(\"PNFS_MDS\", true,\n\t\t       fsal_staticfsinfo_t, pnfs_mds),\n\tCONF_ITEM_BOOL(\"PNFS_DS\", true,\n\t\t       fsal_staticfsinfo_t, pnfs_ds),\n\tCONF_ITEM_BOOL(\"fsal_trace\", true,\n\t\t       fsal_staticfsinfo_t, fsal_trace),\n\tCONF_ITEM_BOOL(\"fsal_grace\", false,\n\t\t       fsal_staticfsinfo_t, fsal_grace),\n\tCONFIG_EOL\n};\n\n/** @struct gpfs_param\n *  @brief Configuration block\n */\nstatic struct config_block gpfs_param = {\n\t.dbus_interface_name = \"org.ganesha.nfsd.config.fsal.gpfs\",\n\t.blk_desc.name = \"GPFS\",\n\t.blk_desc.type = CONFIG_BLOCK,\n\t.blk_desc.u.blk.init = noop_conf_init,\n\t.blk_desc.u.blk.params = gpfs_params,\n\t.blk_desc.u.blk.commit = noop_conf_commit\n};\n\n/** @fn static int\n *      log_to_gpfs(log_header_t headers, void *private, log_levels_t level,\n *\tstruct display_buffer *buffer, char *compstr, char *message)\n *  @brief Log to gpfs\n */\nstatic int\nlog_to_gpfs(log_header_t headers, void *private, log_levels_t level,\n\t    struct display_buffer *buffer, char *compstr, char *message)\n{\n\tstruct trace_arg targ = {0};\n\n\tif (level <= 0)\n\t\treturn 0;\n\n\ttarg.level = level;\n\ttarg.len = strlen(compstr);\n\ttarg.str = compstr;\n\n\treturn gpfs_ganesha(OPENHANDLE_TRACE_ME, &targ);\n}\n\n/** @fn static fsal_status_t init_config(struct fsal_module *fsal_hdl,\n *\tconfig_file_t config_struct, struct config_error_type *err_type)\n *  @brief must be called with a reference taken (via lookup_fsal)\n */\nstatic fsal_status_t init_config(struct fsal_module *gpfs_fsal_module,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\tint rc;\n\n\t(void) prepare_for_stats(gpfs_fsal_module);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t\t\"Supported attributes default = 0x%\" PRIx64,\n\t\t\tgpfs_fsal_module->fs_info.supported_attrs);\n\n\t(void) load_config_from_parse(config_struct,\n\t\t\t\t\t&gpfs_param,\n\t\t\t\t\t&gpfs_fsal_module->fs_info,\n\t\t\t\t\ttrue,\n\t\t\t\t\terr_type);\n\n\tif (!config_error_is_harmless(err_type))\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\n\tdisplay_fsinfo(gpfs_fsal_module);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"Supported attributes constant = 0x%\" PRIx64,\n\t\t     GPFS_SUPPORTED_ATTRIBUTES);\n\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t gpfs_fsal_module->fs_info.supported_attrs);\n\n\trc = create_log_facility(myname, log_to_gpfs,\n\t\t\t\t NIV_FULL_DEBUG, LH_COMPONENT, NULL);\n\tif (rc != 0) {\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"Could not create GPFS logger (%s)\", strerror(-rc));\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\t}\n\n\tif (gpfs_fsal_module->fs_info.fsal_trace) {\n\t\trc = enable_log_facility(myname);\n\t\tif (rc == 0)\n\t\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\n\t\tLogCrit(COMPONENT_FSAL, \"Could not enable GPFS logger (%s)\",\n\t\t\tstrerror(-rc));\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\t}\n\n\trc = disable_log_facility(myname);\n\tif (rc == 0)\n\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\n\tLogCrit(COMPONENT_FSAL, \"Could not disable GPFS logger (%s)\",\n\t\tstrerror(-rc));\n\n\treturn fsalstat(ERR_FSAL_INVAL, 0);\n}\n\n/** @fn MODULE_INIT void gpfs_init(void)\n *  @brief  Module initialization.\n *\n *  Called by dlopen() to register the module\n *  keep a private pointer to me in myself\n */\nMODULE_INIT void gpfs_init(void)\n{\n\tstruct fsal_module *myself = &GPFS.module;\n\n\tif (register_fsal(myself, myname, FSAL_MAJOR_VERSION,\n\t\t\t  FSAL_MINOR_VERSION, FSAL_ID_GPFS) != 0) {\n\t\tfprintf(stderr, \"GPFS module failed to register\");\n\t\treturn;\n\t}\n\n\t/** Set up module operations */\n\tmyself->m_ops.fsal_pnfs_ds_ops = pnfs_ds_ops_init;\n\tmyself->m_ops.create_export = gpfs_create_export;\n\tmyself->m_ops.init_config = init_config;\n\tmyself->m_ops.getdeviceinfo = getdeviceinfo;\n\tmyself->m_ops.fs_da_addr_size = fs_da_addr_size;\n#ifdef USE_DBUS\n\tmyself->m_ops.fsal_extract_stats = fsal_gpfs_extract_stats;\n#endif\n\tmyself->m_ops.fsal_reset_stats = fsal_gpfs_reset_stats;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL GPFS */\n\tgpfs_handle_ops_init(&GPFS.handle_ops);\n\tgpfs_handle_ops_init(&GPFS.handle_ops_with_pnfs);\n\thandle_ops_pnfs(&GPFS.handle_ops_with_pnfs);\n}\n\n/** @fn MODULE_FINI void gpfs_unload(void)\n *  @brief unload module\n */\nMODULE_FINI void gpfs_unload(void)\n{\n\trelease_log_facility(myname);\n\n\tif (unregister_fsal(&GPFS.module) != 0)\n\t\tfprintf(stderr, \"GPFS module failed to unregister\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_VFS/vfs/main-c.in.cmake": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *                Patrice LUCAS     patrice.lucas@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"gsh_list.h\"\n#include \"fsal.h\"\n#include \"FSAL/fsal_init.h\"\n#include \"fsal_handle_syscalls.h\"\n#include \"vfs_methods.h\"\n\n/* VFS FSAL module private storage\n */\n\n/* defined the set of attributes supported with POSIX */\n#ifndef ENABLE_VFS_DEBUG_ACL\n#define VFS_SUPPORTED_ATTRIBUTES ((const attrmask_t) (ATTRS_POSIX | \\\n\t\t\t\t\t\t      ATTR4_FS_LOCATIONS))\n#else\n#define VFS_SUPPORTED_ATTRIBUTES ((const attrmask_t) (ATTRS_POSIX | ATTR_ACL | \\\n\t\t\t\t\t\t      ATTR4_FS_LOCATIONS))\n#endif\n\nconst char myname[] = \"@FSAL_LUSTRE_VFS_NAME@\";\n\n/* my module private storage\n */\n\nstatic struct vfs_fsal_module VFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = INT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.lock_support = false,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = VFS_SUPPORTED_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.link_supports_permission_checks = false,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t},\n\t.only_one_user = false\n};\n\nstatic struct config_item vfs_params[] = {\n\tCONF_ITEM_BOOL(\"link_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.link_support),\n\tCONF_ITEM_BOOL(\"symlink_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.symlink_support),\n\tCONF_ITEM_BOOL(\"cansettime\", true, vfs_fsal_module,\n\t\t       module.fs_info.cansettime),\n\tCONF_ITEM_UI64(\"maxread\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxread),\n\tCONF_ITEM_UI64(\"maxwrite\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxwrite),\n\tCONF_ITEM_MODE(\"umask\", 0, vfs_fsal_module,\n\t\t       module.fs_info.umask),\n\tCONF_ITEM_BOOL(\"auth_xdev_export\", false, vfs_fsal_module,\n\t\t       module.fs_info.auth_exportpath_xdev),\n\tCONF_ITEM_BOOL(\"only_one_user\", false, vfs_fsal_module,\n\t\t       only_one_user),\n\tCONFIG_EOL\n};\n\nstruct config_block vfs_param = {\n\t.dbus_interface_name = \"org.ganesha.nfsd.config.fsal.vfs\",\n\t.blk_desc.name = \"VFS\",\n\t.blk_desc.type = CONFIG_BLOCK,\n\t.blk_desc.u.blk.init = noop_conf_init,\n\t.blk_desc.u.blk.params = vfs_params,\n\t.blk_desc.u.blk.commit = noop_conf_commit\n};\n\n/* Module methods\n */\n\n/* init_config\n * must be called with a reference taken (via lookup_fsal)\n */\n\nstatic fsal_status_t init_config(struct fsal_module *vfs_fsal_module,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\tstruct vfs_fsal_module *vfs_module =\n\t    container_of(vfs_fsal_module, struct vfs_fsal_module, module);\n\tint prev_errors = err_type->errors;\n\n#ifdef F_OFD_GETLK\n\tint fd, rc;\n\tstruct flock lock;\n\tchar *temp_name;\n#endif\n\n#ifdef F_OFD_GETLK\n\t/* If on a system that might support OFD locks, verify them.\n\t * Only if they exist will we declare lock support.\n\t */\n\tLogInfo(COMPONENT_FSAL, \"FSAL_VFS testing OFD Locks\");\n\ttemp_name = gsh_strdup(\"/tmp/ganesha.nfsd.locktestXXXXXX\");\n\tfd = mkstemp(temp_name);\n\tif (fd >= 0) {\n\t\tlock.l_whence = SEEK_SET;\n\t\tlock.l_type = F_RDLCK;\n\t\tlock.l_start = 0;\n\t\tlock.l_len = 0;\n\t\tlock.l_pid = 0;\n\n\t\trc = fcntl(fd, F_OFD_GETLK, &lock);\n\n\t\tif (rc == 0)\n\t\t\tvfs_module->module.fs_info.lock_support = true;\n\t\telse\n\t\t\tLogInfo(COMPONENT_FSAL, \"Could not use OFD locks\");\n\n\t\tclose(fd);\n\t\tunlink(temp_name);\n\t} else {\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"Could not create file %s to test OFD locks\",\n\t\t\ttemp_name);\n\t}\n\tgsh_free(temp_name);\n#endif\n\n\tif (vfs_module->module.fs_info.lock_support)\n\t\tLogInfo(COMPONENT_FSAL, \"FSAL_VFS enabling OFD Locks\");\n\telse\n\t\tLogInfo(COMPONENT_FSAL, \"FSAL_VFS disabling lock support\");\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t\"Supported attributes default = 0x%\" PRIx64,\n\t\tvfs_module->module.fs_info.supported_attrs);\n\t(void) load_config_from_parse(config_struct,\n\t\t\t\t      &vfs_param,\n\t\t\t\t      vfs_module,\n\t\t\t\t      true,\n\t\t\t\t      err_type);\n\n\t/* Check for actual errors in vfs_param parsing.\n\t * err_type could have errors from previous block\n\t * parsing also.\n\t */\n\tif ((err_type->errors > prev_errors) &&\n\t    !config_error_is_harmless(err_type))\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\n\tdisplay_fsinfo(&vfs_module->module);\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"Supported attributes constant = 0x%\" PRIx64,\n\t\t     VFS_SUPPORTED_ATTRIBUTES);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t vfs_module->module.fs_info.supported_attrs);\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\nMODULE_INIT void vfs_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &VFS.module;\n\n\tretval = register_fsal(myself, myname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_VFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"VFS module failed to register\");\n\t\treturn;\n\t}\n\tmyself->m_ops.create_export = vfs_create_export;\n\tmyself->m_ops.update_export = vfs_update_export;\n\tmyself->m_ops.init_config = init_config;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL VFS/LUSTRE */\n\tvfs_handle_ops_init(&VFS.handle_ops);\n}\n\nMODULE_FINI void vfs_unload(void)\n{\n\tint retval;\n\n\tretval = unregister_fsal(&VFS.module);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"VFS module failed to unregister\");\n\t\treturn;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_VFS/xfs/main.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *                Patrice LUCAS     patrice.lucas@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"fsal.h\"\n#include \"FSAL/fsal_init.h\"\n#include \"fsal_handle_syscalls.h\"\n#include \"vfs_methods.h\"\n\n/* VFS FSAL module private storage\n */\n\n/* defined the set of attributes supported with POSIX */\n#ifndef ENABLE_VFS_DEBUG_ACL\n#define XFS_SUPPORTED_ATTRIBUTES ((const attrmask_t) (ATTRS_POSIX))\n#else\n#define XFS_SUPPORTED_ATTRIBUTES ((const attrmask_t) (ATTRS_POSIX | ATTR_ACL))\n#endif\n\nconst char myname[] = \"XFS\";\n\n/* my module private storage\n */\n\nstatic struct vfs_fsal_module XFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = INT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.lock_support = false,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = XFS_SUPPORTED_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.link_supports_permission_checks = false,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t},\n\t.only_one_user = false\n};\n\nstatic struct config_item xfs_params[] = {\n\tCONF_ITEM_BOOL(\"link_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.link_support),\n\tCONF_ITEM_BOOL(\"symlink_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.symlink_support),\n\tCONF_ITEM_BOOL(\"cansettime\", true, vfs_fsal_module,\n\t\t       module.fs_info.cansettime),\n\tCONF_ITEM_UI64(\"maxread\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxread),\n\tCONF_ITEM_UI64(\"maxwrite\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxwrite),\n\tCONF_ITEM_MODE(\"umask\", 0, vfs_fsal_module,\n\t\t       module.fs_info.umask),\n\tCONF_ITEM_BOOL(\"auth_xdev_export\", false, vfs_fsal_module,\n\t\t       module.fs_info.auth_exportpath_xdev),\n\tCONF_ITEM_BOOL(\"only_one_user\", false, vfs_fsal_module,\n\t\t       only_one_user),\n\tCONFIG_EOL\n};\n\nstruct config_block xfs_param = {\n\t.dbus_interface_name = \"org.ganesha.nfsd.config.fsal.xfs\",\n\t.blk_desc.name = \"XFS\",\n\t.blk_desc.type = CONFIG_BLOCK,\n\t.blk_desc.u.blk.init = noop_conf_init,\n\t.blk_desc.u.blk.params = xfs_params,\n\t.blk_desc.u.blk.commit = noop_conf_commit\n};\n\n\n/* Module methods\n */\n\n/* init_config\n * must be called with a reference taken (via lookup_fsal)\n */\n\nstatic fsal_status_t init_config(struct fsal_module *xfs_fsal_module,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\tstruct vfs_fsal_module *xfs_module =\n\t    container_of(xfs_fsal_module, struct vfs_fsal_module, module);\n\n#ifdef F_OFD_GETLK\n\tint fd, rc;\n\tstruct flock lock;\n\tchar *temp_name;\n#endif\n\n#ifdef F_OFD_GETLK\n\t/* If on a system that might support OFD locks, verify them.\n\t * Only if they exist will we declare lock support.\n\t */\n\tLogInfo(COMPONENT_FSAL, \"FSAL_XFS testing OFD Locks\");\n\ttemp_name = gsh_strdup(\"/tmp/ganesha.nfsd.locktestXXXXXX\");\n\tfd = mkstemp(temp_name);\n\tif (fd >= 0) {\n\t\tlock.l_whence = SEEK_SET;\n\t\tlock.l_type = F_RDLCK;\n\t\tlock.l_start = 0;\n\t\tlock.l_len = 0;\n\t\tlock.l_pid = 0;\n\n\t\trc = fcntl(fd, F_OFD_GETLK, &lock);\n\n\t\tif (rc == 0)\n\t\t\txfs_module->module.fs_info.lock_support = true;\n\t\telse\n\t\t\tLogInfo(COMPONENT_FSAL, \"Could not use OFD locks\");\n\n\t\tclose(fd);\n\t\tunlink(temp_name);\n\t} else {\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"Could not create file %s to test OFD locks\",\n\t\t\ttemp_name);\n\t}\n\tgsh_free(temp_name);\n#endif\n\n\tif (xfs_module->module.fs_info.lock_support)\n\t\tLogInfo(COMPONENT_FSAL, \"FSAL_XFS enabling OFD Locks\");\n\telse\n\t\tLogInfo(COMPONENT_FSAL, \"FSAL_XFS disabling lock support\");\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t\"Supported attributes default = 0x%\" PRIx64,\n\t\txfs_module->module.fs_info.supported_attrs);\n\n\t(void) load_config_from_parse(config_struct,\n\t\t\t\t      &xfs_param,\n\t\t\t\t      xfs_module,\n\t\t\t\t      true,\n\t\t\t\t      err_type);\n\tif (!config_error_is_harmless(err_type))\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\tdisplay_fsinfo(&xfs_module->module);\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"Supported attributes constant = 0x%\" PRIx64,\n\t\t     XFS_SUPPORTED_ATTRIBUTES);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t xfs_module->module.fs_info.supported_attrs);\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\nMODULE_INIT void xfs_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &XFS.module;\n\n\tretval = register_fsal(myself, myname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_NO_PNFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"XFS module failed to register\");\n\t\treturn;\n\t}\n\tmyself->m_ops.create_export = vfs_create_export;\n\tmyself->m_ops.update_export = vfs_update_export;\n\tmyself->m_ops.init_config = init_config;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL XFS */\n\tvfs_handle_ops_init(&XFS.handle_ops);\n}\n\nMODULE_FINI void xfs_unload(void)\n{\n\tint retval;\n\n\tretval = unregister_fsal(&XFS.module);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"XFS module failed to unregister\");\n\t\treturn;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_VFS/panfs/main.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *                Patrice LUCAS     patrice.lucas@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"gsh_list.h\"\n#include \"fsal.h\"\n#include \"FSAL/fsal_init.h\"\n#include \"vfs_methods.h\"\n\n/* PANFS FSAL module private storage\n */\n\n/* defined the set of attributes supported with POSIX */\n#define PANFS_SUPPORTED_ATTRIBUTES ((const attrmask_t) (ATTRS_POSIX | ATTR_ACL))\n\nconst char myname[] = \"PANFS\";\n\n/* my module private storage\n */\n\nstatic struct vfs_fsal_module PANFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = INT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.lock_support = false,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW |\n\t\t\t\t\t\tFSAL_ACLSUPPORT_DENY,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = PANFS_SUPPORTED_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.link_supports_permission_checks = false,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t},\n\t.only_one_user = false\n};\n\nstatic struct config_item panfs_params[] = {\n\tCONF_ITEM_BOOL(\"link_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.link_support),\n\tCONF_ITEM_BOOL(\"symlink_support\", true, vfs_fsal_module,\n\t\t       module.fs_info.symlink_support),\n\tCONF_ITEM_BOOL(\"cansettime\", true, vfs_fsal_module,\n\t\t       module.fs_info.cansettime),\n\tCONF_ITEM_UI64(\"maxread\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxread),\n\tCONF_ITEM_UI64(\"maxwrite\", 512, FSAL_MAXIOSIZE, FSAL_MAXIOSIZE,\n\t\t       vfs_fsal_module, module.fs_info.maxwrite),\n\tCONF_ITEM_MODE(\"umask\", 0, vfs_fsal_module,\n\t\t       module.fs_info.umask),\n\tCONF_ITEM_BOOL(\"auth_xdev_export\", false, vfs_fsal_module,\n\t\t       module.fs_info.auth_exportpath_xdev),\n\tCONF_ITEM_BOOL(\"only_one_user\", false, vfs_fsal_module,\n\t\t       only_one_user),\n\tCONFIG_EOL\n};\n\nstruct config_block panfs_param = {\n\t.dbus_interface_name = \"org.ganesha.nfsd.config.fsal.panfs\",\n\t.blk_desc.name = \"PANFS\",\n\t.blk_desc.type = CONFIG_BLOCK,\n\t.blk_desc.u.blk.init = noop_conf_init,\n\t.blk_desc.u.blk.params = panfs_params,\n\t.blk_desc.u.blk.commit = noop_conf_commit\n};\n\n/* Module methods\n */\n\n/* init_config\n * must be called with a reference taken (via lookup_fsal)\n */\n\nstatic fsal_status_t init_config(struct fsal_module *panfs_fsal_module,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\tstruct vfs_fsal_module *panfs_module =\n\t    container_of(panfs_fsal_module, struct vfs_fsal_module, module);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t\"Supported attributes default = 0x%\" PRIx64,\n\t\tpanfs_module->module.fs_info.supported_attrs);\n\n\t(void) load_config_from_parse(config_struct,\n\t\t\t\t      &panfs_param,\n\t\t\t\t      panfs_module,\n\t\t\t\t      true,\n\t\t\t\t      err_type);\n\tif (!config_error_is_harmless(err_type))\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\tdisplay_fsinfo(&panfs_module->module);\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"Supported attributes constant = 0x%\" PRIx64,\n\t\t     PANFS_SUPPORTED_ATTRIBUTES);\n\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t panfs_module->module.fs_info.supported_attrs);\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/* Internal PANFS method linkage to export object\n */\n\nfsal_status_t vfs_create_export(struct fsal_module *fsal_hdl,\n\t\t\t\tvoid *parse_node,\n\t\t\t\tstruct config_error_type *err_type,\n\t\t\t\tconst struct fsal_up_vector *up_ops);\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\nMODULE_INIT void panfs_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &PANFS.module;\n\n\tretval = register_fsal(myself, myname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_PANFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"PANFS module failed to register\");\n\t\treturn;\n\t}\n\tmyself->m_ops.create_export = vfs_create_export;\n\tmyself->m_ops.init_config = init_config;\n}\n\nMODULE_FINI void panfs_unload(void)\n{\n\tint retval;\n\n\tretval = unregister_fsal(&PANFS.module);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"PANFS module failed to unregister\");\n\t\treturn;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_MEM/mem_main.c": "/*\n * vim:shiftwidth=8:tabstop=8:\n *\n * Copyright 2017-2019 Red Hat, Inc.\n * Author: Daniel Gryniewicz  dang@redhat.com\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include \"fsal.h\"\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"FSAL/fsal_init.h\"\n#include \"mem_int.h\"\n#include \"fsal_convert.h\"\n#include \"../fsal_private.h\"\n\n/* MEM FSAL module private storage\n */\n\n/* defined the set of attributes supported with POSIX */\n#define MEM_SUPPORTED_ATTRIBUTES (ATTRS_POSIX)\n\nconst char memname[] = \"MEM\";\n\n/* my module private storage */\nstruct mem_fsal_module MEM = {\n\t.fsal = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = INT64_MAX,\n\t\t\t.maxlink = 0,\n\t\t\t.maxnamelen = MAXNAMLEN,\n\t\t\t.maxpathlen = MAXPATHLEN,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.link_support = true,\n\t\t\t.symlink_support = true,\n\t\t\t.lock_support = true,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = false,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = 0,\n\t\t\t.cansettime = true,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = MEM_SUPPORTED_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.umask = 0,\n\t\t\t.auth_exportpath_xdev = false,\n\t\t\t.link_supports_permission_checks = false,\n\t\t\t.readdir_plus = true,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t}\n};\n\nstatic struct config_item mem_items[] = {\n\tCONF_ITEM_UI32(\"Inode_Size\", 0, 0x200000, 0,\n\t\t       mem_fsal_module, inode_size),\n\tCONF_ITEM_UI32(\"Up_Test_Interval\", 0, UINT32_MAX, 0,\n\t\t       mem_fsal_module, up_interval),\n\tCONF_ITEM_UI32(\"Async_Threads\", 0, 100, 0,\n\t\t       mem_fsal_module, async_threads),\n\tCONF_ITEM_BOOL(\"Whence_is_name\", false,\n\t\t       mem_fsal_module, whence_is_name),\n\tCONFIG_EOL\n};\n\nstatic struct config_block mem_block = {\n\t.dbus_interface_name = \"org.ganesha.nfsd.config.fsal.mem\",\n\t.blk_desc.name = \"MEM\",\n\t.blk_desc.type = CONFIG_BLOCK,\n\t.blk_desc.u.blk.init = noop_conf_init,\n\t.blk_desc.u.blk.params = mem_items,\n\t.blk_desc.u.blk.commit = noop_conf_commit\n};\n\nstruct fridgethr *mem_async_fridge;\n\n/**\n * Initialize subsystem\n */\nstatic fsal_status_t\nmem_async_pkginit(void)\n{\n\t/* Return code from system calls */\n\tint code = 0;\n\tstruct fridgethr_params frp;\n\n\tif (MEM.async_threads == 0) {\n\t\t/* Don't run async-threads */\n\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\t}\n\n\tif (mem_async_fridge) {\n\t\t/* Already initialized */\n\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\t}\n\n\tmemset(&frp, 0, sizeof(struct fridgethr_params));\n\tfrp.thr_max = MEM.async_threads;\n\tfrp.thr_min = 1;\n\tfrp.flavor = fridgethr_flavor_worker;\n\n\t/* spawn MEM_ASYNC background thread */\n\tcode = fridgethr_init(&mem_async_fridge, \"MEM_ASYNC_fridge\", &frp);\n\tif (code != 0) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Unable to initialize MEM_ASYNC fridge, error code %d.\",\n\t\t\t code);\n\t}\n\n\tLogEvent(COMPONENT_FSAL,\n\t\t \"Initialized FSAL_MEM async thread pool with %\"\n\t\t PRIu32\" threads.\",\n\t\t MEM.async_threads);\n\n\treturn posix2fsal_status(code);\n}\n\n/**\n * Shutdown subsystem\n *\n * @return FSAL status\n */\nstatic fsal_status_t\nmem_async_pkgshutdown(void)\n{\n\tif (!mem_async_fridge) {\n\t\t/* Async wasn't configured */\n\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\t}\n\n\tint rc = fridgethr_sync_command(mem_async_fridge,\n\t\t\t\t\tfridgethr_comm_stop,\n\t\t\t\t\t120);\n\n\tif (rc == ETIMEDOUT) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Shutdown timed out, cancelling threads.\");\n\t\tfridgethr_cancel(mem_async_fridge);\n\t} else if (rc != 0) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Failed shutting down MEM_ASYNC threads: %d\", rc);\n\t}\n\n\tfridgethr_destroy(mem_async_fridge);\n\tmem_async_fridge = NULL;\n\treturn posix2fsal_status(rc);\n}\n\n/* private helper for export object\n */\n\n/* Initialize mem fs info */\nstatic fsal_status_t mem_init_config(struct fsal_module *fsal_hdl,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\tstruct mem_fsal_module *mem_me =\n\t    container_of(fsal_hdl, struct mem_fsal_module, fsal);\n\tfsal_status_t status = {0, 0};\n\n\tLogDebug(COMPONENT_FSAL, \"MEM module setup.\");\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t\t\t \"Supported attributes default = 0x%\" PRIx64,\n\t\t\t\t mem_me->fsal.fs_info.supported_attrs);\n\n\t/* if we have fsal specific params, do them here\n\t * fsal_hdl->name is used to find the block containing the\n\t * params.\n\t */\n\t(void) load_config_from_parse(config_struct,\n\t\t\t\t      &mem_block,\n\t\t\t\t      mem_me,\n\t\t\t\t      true,\n\t\t\t\t      err_type);\n\tif (!config_error_is_harmless(err_type))\n\t\treturn fsalstat(ERR_FSAL_INVAL, 0);\n\n\t/* Initialize UP calls */\n\tstatus = mem_up_pkginit();\n\tif (FSAL_IS_ERROR(status)) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Failed to initialize FSAL_MEM UP package %s\",\n\t\t\t fsal_err_txt(status));\n\t\treturn status;\n\t}\n\n\t/* Initialize ASYNC call back threads */\n\tstatus = mem_async_pkginit();\n\tif (FSAL_IS_ERROR(status)) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Failed to initialize FSAL_MEM ASYNC package %s\",\n\t\t\t fsal_err_txt(status));\n\t\treturn status;\n\t}\n\n\t/* Set whence_is_name in fsinfo */\n\tmem_me->fsal.fs_info.whence_is_name = mem_me->whence_is_name;\n\n\tdisplay_fsinfo(&mem_me->fsal);\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"Supported attributes constant = 0x%\" PRIx64,\n\t\t     (uint64_t) MEM_SUPPORTED_ATTRIBUTES);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t mem_me->fsal.fs_info.supported_attrs);\n\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\n/**\n * @brief Initialize and register the FSAL\n *\n * This function initializes the FSAL module handle.  It exists solely to\n * produce a properly constructed FSAL module handle.\n */\n\nMODULE_INIT void init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &MEM.fsal;\n\n\tretval = register_fsal(myself, memname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_NO_PNFS);\n\tif (retval != 0) {\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"MEM module failed to register.\");\n\t}\n\tmyself->m_ops.create_export = mem_create_export;\n\tmyself->m_ops.update_export = mem_update_export;\n\tmyself->m_ops.init_config = mem_init_config;\n\tglist_init(&MEM.mem_exports);\n\tMEM.next_inode = 0xc0ffee;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL MEM */\n\tmem_handle_ops_init(&MEM.handle_ops);\n}\n\nMODULE_FINI void finish(void)\n{\n\tint retval;\n\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"MEM module finishing.\");\n\n\t/* Shutdown UP calls */\n\tmem_up_pkgshutdown();\n\n\t/* Shutdown ASYNC threads */\n\tmem_async_pkgshutdown();\n\n\tretval = unregister_fsal(&MEM.fsal);\n\tif (retval != 0) {\n\t\tLogCrit(COMPONENT_FSAL,\n\t\t\t\"Unable to unload MEM FSAL.  Dying with extreme prejudice.\");\n\t\tabort();\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/FSAL_PSEUDO/main.c": "/*\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n *\n * -------------\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include \"fsal.h\"\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"FSAL/fsal_init.h\"\n#include \"pseudofs_methods.h\"\n#include \"../fsal_private.h\"\n\nconst char pseudoname[] = \"PSEUDO\";\n\n/* my module private storage\n */\n\nstruct pseudo_fsal_module PSEUDOFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = 512,\n\t\t\t.maxlink = 0,\n\t\t\t.maxnamelen = MAXNAMLEN,\n\t\t\t.maxpathlen = MAXPATHLEN,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.link_support = false,\n\t\t\t.symlink_support = false,\n\t\t\t.lock_support = false,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = false,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = 0,\n\t\t\t.cansettime = true,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = PSEUDO_SUPPORTED_ATTRS,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.umask = 0,\n\t\t\t.auth_exportpath_xdev = false,\n\t\t\t.link_supports_permission_checks = false,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t}\n};\n\n/* private helper for export object\n */\n\n/* Initialize pseudo fs info */\nstatic void init_config(struct fsal_module *pseudo_fsal_module)\n{\n\t/* if we have fsal specific params, do them here\n\t * fsal_hdl->name is used to find the block containing the\n\t * params.\n\t */\n\n\tdisplay_fsinfo(pseudo_fsal_module);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t pseudo_fsal_module->fs_info.supported_attrs);\n}\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\nint unload_pseudo_fsal(struct fsal_module *fsal_hdl)\n{\n\tint retval;\n\n\tretval = unregister_fsal(&PSEUDOFS.module);\n\tif (retval != 0)\n\t\tfprintf(stderr, \"PSEUDO module failed to unregister\");\n\n\treturn retval;\n}\n\nvoid pseudo_fsal_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &PSEUDOFS.module;\n\n\tretval = register_fsal(myself, pseudoname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_NO_PNFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"PSEUDO module failed to register\");\n\t\treturn;\n\t}\n\tmyself->m_ops.create_export = pseudofs_create_export;\n\tmyself->m_ops.unload = unload_pseudo_fsal;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL PSEUDO */\n\tpseudofs_handle_ops_init(&PSEUDOFS.handle_ops);\n\n\t/* initialize our config */\n\tinit_config(myself);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_main.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright 2015-2019 Red Hat, Inc. and/or its affiliates.\n * Author: Daniel Gryniewicz <dang@redhat.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n/**\n * @addtogroup FSAL_MDCACHE\n * @{\n */\n\n/**\n * @file  main.c\n * @brief FSAL entry functions\n */\n\n#include \"config.h\"\n\n#include \"fsal.h\"\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"gsh_list.h\"\n#ifdef USE_DBUS\n#include \"gsh_dbus.h\"\n#endif\n#include \"FSAL/fsal_init.h\"\n#include \"FSAL/fsal_commonlib.h\"\n#include \"mdcache_hash.h\"\n#include \"mdcache_lru.h\"\n\npool_t *mdcache_entry_pool;\n\nstruct mdcache_stats cache_st;\nstruct mdcache_stats *cache_stp = &cache_st;\n\n/* FSAL name determines name of shared library: libfsal<name>.so */\nconst char mdcachename[] = \"MDCACHE\";\n\n/* my module private storage\n */\nstruct mdcache_fsal_module MDCACHE = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = UINT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.link_support = true,\n\t\t\t.symlink_support = true,\n\t\t\t.lock_support = true,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW,\n\t\t\t.cansettime = true,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = ALL_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.umask = 0,\n\t\t\t.auth_exportpath_xdev = false,\n\t\t\t.link_supports_permission_checks = true,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t}\n};\n\n/* private helper for export object\n */\n\n/* Module methods\n */\n\n/* mdcache_fsal_init_config\n * must be called with a reference taken (via lookup_fsal)\n */\n\nstatic fsal_status_t\nmdcache_fsal_init_config(struct fsal_module *mdcache_fsal_module,\n\t\t\t config_file_t config_struct,\n\t\t\t struct config_error_type *err_type)\n{\n\t/* Configuration setting options:\n\t * 1. there are none that are changeable. (this case)\n\t *\n\t * 2. we set some here.  These must be independent of whatever\n\t *    may be set by lower level fsals.\n\t *\n\t * If there is any filtering or change of parameters in the stack,\n\t * this must be done in export data structures, not fsal params because\n\t * a stackable could be configured above multiple fsals for multiple\n\t * diverse exports.\n\t */\n\n\tdisplay_fsinfo(mdcache_fsal_module);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t mdcache_fsal_module->fs_info.supported_attrs);\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/**\n * @brief Clean up caching for a FSAL export on error\n *\n * If init has an error after @ref mdcache_export_init is called, this should be\n * called to clean up any MDCACHE state on the export.  This is only intended to\n * be called on startup error.\n *\n */\nvoid mdcache_export_uninit(void)\n{\n\tstruct mdcache_fsal_export *exp = mdc_cur_export();\n\tstruct fsal_export *sub_export = exp->mfe_exp.sub_export;\n\n\tfsal_put(sub_export->fsal);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"FSAL %s refcount %\"PRIu32,\n\t\t     sub_export->fsal->name,\n\t\t     atomic_fetch_int32_t(&sub_export->fsal->refcount));\n\n\tfsal_detach_export(op_ctx->fsal_export->fsal,\n\t\t\t   &op_ctx->fsal_export->exports);\n\tfree_export_ops(op_ctx->fsal_export);\n\n\tgsh_free(exp);\n\n\t/* Put back sub export */\n\top_ctx->fsal_export = sub_export;\n\top_ctx->fsal_module = sub_export->fsal;\n}\n\n/**\n * @brief Create an export for MDCACHE\n *\n * Create the stacked export for MDCACHE to allow metadata caching on another\n * export.  Unlike other Stackable FSALs, this one is created @b after the FSAL\n * underneath.  It assumes the sub-FSAL's export is already created and\n * available via the @e fsal_export member of @link op_ctx @endlink, the same\n * way that this export is returned.\n *\n * There is currently no config;\n *\n * @param[in] sub_fsal\t\tSub-FSAL module handle\n * @param[in] parse_node\tConfig node for export\n * @param[out] err_type\t\tParse errors\n * @param[in] super_up_ops\tUpcall ops for export\n * @return FSAL status\n */\nfsal_status_t\nmdcache_fsal_create_export(struct fsal_module *sub_fsal, void *parse_node,\n\t\t\t   struct config_error_type *err_type,\n\t\t\t   const struct fsal_up_vector *super_up_ops)\n{\n\tfsal_status_t status = {0, 0};\n\tstruct mdcache_fsal_export *myself;\n\tpthread_rwlockattr_t attrs;\n\n\tmyself = gsh_calloc(1, sizeof(struct mdcache_fsal_export));\n\tmyself->name = gsh_concat(sub_fsal->name, \"/MDC\");\n\n\tfsal_export_init(&myself->mfe_exp);\n\tmdcache_export_ops_init(&myself->mfe_exp.exp_ops);\n\n\tmyself->super_up_ops = *super_up_ops; /* Struct copy */\n\tmdcache_export_up_ops_init(&myself->up_ops, super_up_ops);\n\tmyself->up_ops.up_gsh_export = op_ctx->ctx_export;\n\tmyself->up_ops.up_fsal_export = &myself->mfe_exp;\n\tmyself->mfe_exp.up_ops = &myself->up_ops;\n\tmyself->mfe_exp.fsal = &MDCACHE.module;\n\n\tglist_init(&myself->entry_list);\n\tpthread_rwlockattr_init(&attrs);\n#ifdef GLIBC\n\tpthread_rwlockattr_setkind_np(&attrs,\n\t\tPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n#endif\n\tPTHREAD_RWLOCK_init(&myself->mdc_exp_lock, &attrs);\n\tpthread_rwlockattr_destroy(&attrs);\n\n\tstatus = sub_fsal->m_ops.create_export(sub_fsal,\n\t\t\t\t\t\t parse_node,\n\t\t\t\t\t\t err_type,\n\t\t\t\t\t\t &myself->up_ops);\n\tif (FSAL_IS_ERROR(status)) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Failed to call create_export on underlying FSAL %s\",\n\t\t\t sub_fsal->name);\n\t\tgsh_free(myself->name);\n\t\tgsh_free(myself);\n\t\treturn status;\n\t}\n\n\t/* Get ref for sub-FSAL */\n\tfsal_get(myself->mfe_exp.fsal);\n\n\tLogFullDebug(COMPONENT_FSAL,\n\t\t     \"FSAL %s refcount %\"PRIu32,\n\t\t     myself->mfe_exp.fsal->name,\n\t\t     atomic_fetch_int32_t(&myself->mfe_exp.fsal->refcount));\n\n\tfsal_export_stack(op_ctx->fsal_export, &myself->mfe_exp);\n\n\tstatus = dirmap_lru_init(myself);\n\tif (FSAL_IS_ERROR(status)) {\n\t\tLogMajor(COMPONENT_FSAL, \"Failed to call dirmap_lru_init\");\n\t\tgsh_free(myself->name);\n\t\tgsh_free(myself);\n\t\treturn status;\n\t}\n\n\t/* Set up op_ctx */\n\top_ctx->fsal_export = &myself->mfe_exp;\n\top_ctx->fsal_module = &MDCACHE.module;\n\n\t/* Stacking is setup and ready to take upcalls now */\n\tup_ready_set(&myself->up_ops);\n\n\treturn status;\n}\n\n/**\n * @brief Update an export for MDCACHE\n *\n * Create the stacked export for MDCACHE to allow metadata caching on another\n * export.  Unlike other Stackable FSALs, this one is created @b after the FSAL\n * underneath.  It assumes the sub-FSAL's export is already created and\n * available via the @e fsal_export member of @link op_ctx @endlink, the same\n * way that this export is returned.\n *\n * There is currently no config;\n *\n * @param[in] sub_fsal\t\tSub-FSAL module handle\n * @param[in] parse_node\tConfig node for export\n * @param[out] err_type\t\tParse errors\n * @param[in] existing_export\tThe existing export that is being updated\n * @return FSAL status\n */\nfsal_status_t\nmdcache_fsal_update_export(struct fsal_module *sub_fsal, void *parse_node,\n\t\t\t   struct config_error_type *err_type,\n\t\t\t   struct fsal_export *original)\n{\n\tfsal_status_t status = {0, 0};\n#if 0\n\t/* We currently don't actually have any MDCACHE EXPORT FSAL parameters\n\t * so we don't need an mdcache_fsal_export to fill in.\n\t */\n\tstruct mdcache_fsal_export myself;\n\n\tmemset(&myself, 0, sizeof(myself));\n\n\t/* Here's where we would parse the FSAL block to get our params and\n\t * then validate them.\n\t */\n#endif\n\n\t/* Now update the sub-fsal */\n\n\tstatus = sub_fsal->m_ops.update_export(sub_fsal,\n\t\t\t\t\t       parse_node,\n\t\t\t\t\t       err_type,\n\t\t\t\t\t       original->sub_export,\n\t\t\t\t\t       &MDCACHE.module);\n\n\tif (FSAL_IS_ERROR(status)) {\n\t\tLogMajor(COMPONENT_FSAL,\n\t\t\t \"Failed to call update_export on underlying FSAL %s\",\n\t\t\t sub_fsal->name);\n\t} else {\n\t\t/* And here's where we would actually update the parameters. */\n\t}\n\n\t/* We don't do any of the stuff mdcache_fsal_create_export does after\n\t * calling the sub_fsal's update_export because we aren't actually\n\t * creating a fsal_export stack.\n\t */\n\n\treturn status;\n}\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\n\n\nstatic int\nmdcache_fsal_unload(struct fsal_module *fsal_hdl)\n{\n\tfsal_status_t status;\n\tint retval;\n\n\t/* Destroy the cache inode AVL tree */\n\tcih_pkgdestroy();\n\n\tstatus = mdcache_lru_pkgshutdown();\n\tif (FSAL_IS_ERROR(status))\n\t\tfprintf(stderr, \"MDCACHE LRU failed to shut down\");\n\n\t/* Destroy the cache inode entry pool */\n\tpool_destroy(mdcache_entry_pool);\n\tmdcache_entry_pool = NULL;\n\n\tretval = unregister_fsal(&MDCACHE.module);\n\tif (retval != 0)\n\t\tfprintf(stderr, \"MDCACHE module failed to unregister\");\n\n\tif (FSAL_IS_ERROR(status))\n\t\treturn status.major;\n\treturn retval;\n}\n\nvoid mdcache_fsal_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &MDCACHE.module;\n\n\tretval = register_fsal(myself, mdcachename, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_NO_PNFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"MDCACHE module failed to register\");\n\t\treturn;\n\t}\n\t/*myself->m_ops.create_export = mdcache_fsal_create_export;*/\n\tmyself->m_ops.init_config = mdcache_fsal_init_config;\n\tmyself->m_ops.unload = mdcache_fsal_unload;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL MDCACHE */\n\tmdcache_handle_ops_init(&MDCACHE.handle_ops);\n}\n\n/**\n * @brief Initialize the MDCACHE package.\n *\n * This shuold be called once at startup, after parsing config\n *\n * @param[in] parm\tParameter description\n * @return FSAL status\n */\nfsal_status_t mdcache_pkginit(void)\n{\n\tfsal_status_t status;\n\n\tif (mdcache_entry_pool)\n\t\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n\n\tmdcache_entry_pool = pool_basic_init(\"MDCACHE Entry Pool\",\n\t\t\t\t\t     sizeof(mdcache_entry_t));\n\n\tstatus = mdcache_lru_pkginit();\n\tif (FSAL_IS_ERROR(status)) {\n\t\tpool_destroy(mdcache_entry_pool);\n\t\tmdcache_entry_pool = NULL;\n\t\treturn status;\n\t}\n\n\tcih_pkginit();\n\n\treturn status;\n}\n\n#ifdef USE_DBUS\nvoid mdcache_dbus_show(DBusMessageIter *iter)\n{\n\tDBusMessageIter struct_iter;\n\tchar *type;\n\n\tdbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL,\n\t\t\t\t\t &struct_iter);\n\ttype = \"cache_req\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_req);\n\ttype = \"cache_hit\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_hit);\n\ttype = \"cache_miss\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_miss);\n\ttype = \"cache_conf\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_conf);\n\ttype = \"cache_added\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_added);\n\ttype = \"cache_mapping\";\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &type);\n\tdbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_UINT64,\n\t\t\t\t\t&cache_st.inode_mapping);\n\n\tdbus_message_iter_close_container(iter, &struct_iter);\n}\n#endif /* USE_DBUS */\n\n/** @} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/FSAL/Stackable_FSALs/FSAL_NULL/main.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright (C) Panasas Inc., 2011\n * Author: Jim Lieb jlieb@panasas.com\n *\n * contributeur : Philippe DENIEL   philippe.deniel@cea.fr\n *                Thomas LEIBOVICI  thomas.leibovici@cea.fr\n *\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n/* main.c\n * Module core functions\n */\n\n#include \"config.h\"\n\n#include \"fsal.h\"\n#include <libgen.h>\t\t/* used for 'dirname' */\n#include <pthread.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"gsh_list.h\"\n#include \"FSAL/fsal_init.h\"\n#include \"nullfs_methods.h\"\n\n\n/* FSAL name determines name of shared library: libfsal<name>.so */\nconst char myname[] = \"NULL\";\n\n/* my module private storage\n */\n\nstruct null_fsal_module NULLFS = {\n\t.module = {\n\t\t.fs_info = {\n\t\t\t.maxfilesize = UINT64_MAX,\n\t\t\t.maxlink = _POSIX_LINK_MAX,\n\t\t\t.maxnamelen = 1024,\n\t\t\t.maxpathlen = 1024,\n\t\t\t.no_trunc = true,\n\t\t\t.chown_restricted = true,\n\t\t\t.case_insensitive = false,\n\t\t\t.case_preserving = true,\n\t\t\t.link_support = true,\n\t\t\t.symlink_support = true,\n\t\t\t.lock_support = true,\n\t\t\t.lock_support_async_block = false,\n\t\t\t.named_attr = true,\n\t\t\t.unique_handles = true,\n\t\t\t.acl_support = FSAL_ACLSUPPORT_ALLOW,\n\t\t\t.cansettime = true,\n\t\t\t.homogenous = true,\n\t\t\t.supported_attrs = ALL_ATTRIBUTES,\n\t\t\t.maxread = FSAL_MAXIOSIZE,\n\t\t\t.maxwrite = FSAL_MAXIOSIZE,\n\t\t\t.umask = 0,\n\t\t\t.auth_exportpath_xdev = false,\n\t\t\t.link_supports_permission_checks = true,\n\t\t\t.expire_time_parent = -1,\n\t\t}\n\t}\n};\n\n/* Module methods\n */\n\n/* init_config\n * must be called with a reference taken (via lookup_fsal)\n */\n\nstatic fsal_status_t init_config(struct fsal_module *nullfs_fsal_module,\n\t\t\t\t config_file_t config_struct,\n\t\t\t\t struct config_error_type *err_type)\n{\n\t/* Configuration setting options:\n\t * 1. there are none that are changeable. (this case)\n\t *\n\t * 2. we set some here.  These must be independent of whatever\n\t *    may be set by lower level fsals.\n\t *\n\t * If there is any filtering or change of parameters in the stack,\n\t * this must be done in export data structures, not fsal params because\n\t * a stackable could be configured above multiple fsals for multiple\n\t * diverse exports.\n\t */\n\n\tdisplay_fsinfo(nullfs_fsal_module);\n\tLogDebug(COMPONENT_FSAL,\n\t\t \"FSAL INIT: Supported attributes mask = 0x%\" PRIx64,\n\t\t nullfs_fsal_module->fs_info.supported_attrs);\n\treturn fsalstat(ERR_FSAL_NO_ERROR, 0);\n}\n\n/* Internal NULLFS method linkage to export object\n */\n\nfsal_status_t nullfs_create_export(struct fsal_module *fsal_hdl,\n\t\t\t\t   void *parse_node,\n\t\t\t\t   struct config_error_type *err_type,\n\t\t\t\t   const struct fsal_up_vector *up_ops);\n\nfsal_status_t nullfs_update_export(struct fsal_module *fsal_hdl,\n\t\t\t\t   void *parse_node,\n\t\t\t\t   struct config_error_type *err_type,\n\t\t\t\t   struct fsal_export *original,\n\t\t\t\t   struct fsal_module *updated_super);\n\n/* Module initialization.\n * Called by dlopen() to register the module\n * keep a private pointer to me in myself\n */\n\n/* linkage to the exports and handle ops initializers\n */\nMODULE_INIT void nullfs_init(void)\n{\n\tint retval;\n\tstruct fsal_module *myself = &NULLFS.module;\n\n\tretval = register_fsal(myself, myname, FSAL_MAJOR_VERSION,\n\t\t\t       FSAL_MINOR_VERSION, FSAL_ID_NO_PNFS);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"NULLFS module failed to register\");\n\t\treturn;\n\t}\n\tmyself->m_ops.create_export = nullfs_create_export;\n\tmyself->m_ops.update_export = nullfs_update_export;\n\tmyself->m_ops.init_config = init_config;\n\n\t/* Initialize the fsal_obj_handle ops for FSAL NULL */\n\tnullfs_handle_ops_init(&NULLFS.handle_ops);\n}\n\nMODULE_FINI void nullfs_unload(void)\n{\n\tint retval;\n\n\tretval = unregister_fsal(&NULLFS.module);\n\tif (retval != 0) {\n\t\tfprintf(stderr, \"NULLFS module failed to unregister\");\n\t\treturn;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nfs-ganesha-3.2-uyjavs63po43n77i62em5vz3dliq4dkr/spack-src/src/tracing/README.md": "Building and using LTTng an enabled server\n==========================================\n\nLTTng is a big topic.  Consult the online documentation for the\ndetails of running the tools. The development is being done using Fedora\nusing their packages, version 2.3.0.\n\nInstall the following RPMs on Fedora or, if on RHEL, use the EPEL repo.\nThere are other lttng related packages but these are the relevant ones\nfor this level.\n\nlttng-tools\nlttng-ust-devel\nlttng-ust\nbabeltrace\n\nBuild with `-DUSE_LTTNG=ON` to enable it.  All of the tracepoints\nhave an `#ifdev USE_LTTNG` around them so the default of 'OFF'\ncreates no build or runtime dependencies on lttng.\n\nThe build creates and installs an additional shared object.  The\n`libganesha_trace.so` object which contains all the defined tracepoint\ncode and the code in the application that uses it are constructed such\nthat the tracepoint code does not require the shared object to be\nloaded.  This means that the application can be built with LTTng code\nbut it can be run on a system that has no LTTng support.  Tracepoints are\nenabled once the module is loaded.  See below for details.\n\nI use the following script to run:\n```\n#!/bin/sh\n\nDIR=/usr/local/lib64/ganesha\n\nlttng create\nlttng enable-event -u -a\nlttng start\n\nLD_PRELOAD=$DIR/libganesha_trace.so /usr/local/bin/ganesha.nfsd ${*}\n```\nIn this case, I am preloading `libganesha_trace.so` which turns on tracing before\nbefore the server starts.  If you do not preload, ganesha runs as if tracing is\nnot there and the only overhead is the predicted missed branch to the tracer.\nLTTng supports the loading of the tracing module into a running application by\nloading (dlopen) the modul  This would be useful for production environments\nbut that feature is on the TODO list.\n\nThere are never enough tracepoints.  Like log messages, they get added from time\nto time as needed.  There are two paths for adding tracepoints.\n\n- Sets of tracepoints are categorized in *components*.  These should conform\n  to the same general categories as logging components.  All the tracepoints\n  in a component should be functionally related in some way.\n\n- Finer grained tracing adds new tracepoints to an existing category.\n\nCreating a New Component\n------------------------\nTwo files must be created and a number of other files must be edited to create\na new tracepoint component.\n\nThe tracepoint itself is created as a new include (.h) file in\n`src/include/gsh_lttng`.  This is the bulk of the work.  Note that the\nfile has a specific form.  It is best to copy and edit an existing file so as\nto get all the necessary definitions in the right places.  There can be any\nnumber of tracepoint definitions but each one *must* have a `TRACEPOINT_EVENT`\nand `TRACEPOINT_LOGLEVEL` defined (after it).\n\nThe tracepoint include file has a companion file in src/tracing that includes\nthe header after defining `TRACEPOINT_CREATE_PROBES`.  Add this file to the\nsources list in tracing/CMakeLists.txt so that it gets built into the tracing\nmodule.\n\nEvery source file that will use these tracepoints must also include the specific\ninclude file(s) for the tracepoint component(s).  Note that components are\ndefined separately.  Both the #include and the tracepoints themselves should be\nwrapped with an `#ifdef USE_LTTNG`.\n\nThe CMakeLists.txt file of a source sub-directory should be edited to add a\nconditional `include_directories` command so that `LTTNG_INCLUDE_DIR` will added\nto the includes path.\n\nThe last step in adding a component is to add an `#include` of the new header\nin `MainNFSD/nfs_main.c`.  This bit is LTTng magic to set up the dynamic linkage.\nEvery component header file is listed here ONLY ONCE.  This includes any\ntracepoints that may be added to `nfs_main.c`.\n\nAdding New Tracepoints\n----------------------\nAdding a new tracepoint to an existing component is really simple.  First,\nadd the `TRACEPOINT_EVENT` and its `TRACEPOINT_LOGLEVEL` to the component's\nheader file.  This is all that is necessary to create the tracepoint.  The\nnext step is to add the new tracepoint into the code.  There are a few extra\nbits to remember in adding the tracepoint.\n\n- If the tracepoint is added to a file in a subdirectory that had no\n  tracepoints before, add the `include_directories` directive to the\n  CMakeLists.txt file.\n\n- If the tracepoint category is new to the source file, add a `#include`\n  for it.\n\n- Wrap the #include and all tracepoints with `USE_LTTNG`.\n\nNotes on Using Tracepoints\n==========================\nAll this trace point organization is for the \"enable-event\" command above.\nThe `-a` turns them all on.  If all you wanted was logging, you would change\nthe `-a` to `ganesha_logger:log`.  See the LTTng docs for the details.\n\nTracepoint logs are placed in your `$HOME/lttng-traces` directory.  Note that\nif you are running as 'root' which is necessary for running nfs-ganesha, this\ndirectory is actually `/root/lttng-traces`, not your regular `$HOME`.  The lttng\ncommands will report the subdirectory where the traces are placed.  You can\nalso specify a directory name if you like.  If the lttng command reports\n`auto-20140804-102010` as the trace directory, you can find those files in\n`$HOME/lttng-traces/auto-20140804-102010`.\n\nThe `babeltrace` tool is used to process and display traces.  There are others\nbut this is the simplest and most general tool.  To do a simple dump of\nthe trace from above, use:\n```\n$ babeltrace $HOME/lttng-traces/auto-20140804-102010\n```\nThis will dump a trace in text form.  See the man page for all the options.\nThere are a number of other tools that can also munch traces.  Traces\nare in a common format that many tools can read and process/display them.\n"
    },
    "skipped": [],
    "total_files": 834
}