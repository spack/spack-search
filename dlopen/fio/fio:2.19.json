{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fio-2.19-lpfwy24b64camdpwozxmuyihgbkhc44n/spack-src/ioengines.c": "/*\n * The io parts of the fio tool, includes workers for sync and mmap'ed\n * io, as well as both posix and linux libaio support.\n *\n * sync io is implemented on top of aio.\n *\n * This is not really specific to fio, if the get_io_u/put_io_u and\n * structures was pulled into this as well it would be a perfectly\n * generic io engine that could be used for other projects.\n *\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#include \"fio.h\"\n#include \"diskutil.h\"\n\nstatic FLIST_HEAD(engine_list);\n\nstatic bool check_engine_ops(struct ioengine_ops *ops)\n{\n\tif (ops->version != FIO_IOOPS_VERSION) {\n\t\tlog_err(\"bad ioops version %d (want %d)\\n\", ops->version,\n\t\t\t\t\t\t\tFIO_IOOPS_VERSION);\n\t\treturn true;\n\t}\n\n\tif (!ops->queue) {\n\t\tlog_err(\"%s: no queue handler\\n\", ops->name);\n\t\treturn true;\n\t}\n\n\t/*\n\t * sync engines only need a ->queue()\n\t */\n\tif (ops->flags & FIO_SYNCIO)\n\t\treturn false;\n\n\tif (!ops->event || !ops->getevents) {\n\t\tlog_err(\"%s: no event/getevents handler\\n\", ops->name);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid unregister_ioengine(struct ioengine_ops *ops)\n{\n\tdprint(FD_IO, \"ioengine %s unregistered\\n\", ops->name);\n\tflist_del(&ops->list);\n\tINIT_FLIST_HEAD(&ops->list);\n}\n\nvoid register_ioengine(struct ioengine_ops *ops)\n{\n\tdprint(FD_IO, \"ioengine %s registered\\n\", ops->name);\n\tINIT_FLIST_HEAD(&ops->list);\n\tflist_add_tail(&ops->list, &engine_list);\n}\n\nstatic struct ioengine_ops *find_ioengine(const char *name)\n{\n\tstruct ioengine_ops *ops;\n\tstruct flist_head *entry;\n\n\tflist_for_each(entry, &engine_list) {\n\t\tops = flist_entry(entry, struct ioengine_ops, list);\n\t\tif (!strcmp(name, ops->name))\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ioengine_ops *dlopen_ioengine(struct thread_data *td,\n\t\t\t\t\t    const char *engine_lib)\n{\n\tstruct ioengine_ops *ops;\n\tvoid *dlhandle;\n\n\tdprint(FD_IO, \"dload engine %s\\n\", engine_lib);\n\n\tdlerror();\n\tdlhandle = dlopen(engine_lib, RTLD_LAZY);\n\tif (!dlhandle) {\n\t\ttd_vmsg(td, -1, dlerror(), \"dlopen\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Unlike the included modules, external engines should have a\n\t * non-static ioengine structure that we can reference.\n\t */\n\tops = dlsym(dlhandle, engine_lib);\n\tif (!ops)\n\t\tops = dlsym(dlhandle, \"ioengine\");\n\n\t/*\n\t * For some external engines (like C++ ones) it is not that trivial\n\t * to provide a non-static ionengine structure that we can reference.\n\t * Instead we call a method which allocates the required ioengine\n\t * structure.\n\t */\n\tif (!ops) {\n\t\tget_ioengine_t get_ioengine = dlsym(dlhandle, \"get_ioengine\");\n\n\t\tif (get_ioengine)\n\t\t\tget_ioengine(&ops);\n\t}\n\n\tif (!ops) {\n\t\ttd_vmsg(td, -1, dlerror(), \"dlsym\");\n\t\tdlclose(dlhandle);\n\t\treturn NULL;\n\t}\n\n\ttd->io_ops_dlhandle = dlhandle;\n\treturn ops;\n}\n\nstruct ioengine_ops *load_ioengine(struct thread_data *td, const char *name)\n{\n\tstruct ioengine_ops *ops;\n\tchar engine[64];\n\n\tdprint(FD_IO, \"load ioengine %s\\n\", name);\n\n\tengine[sizeof(engine) - 1] = '\\0';\n\tstrncpy(engine, name, sizeof(engine) - 1);\n\n\t/*\n\t * linux libaio has alias names, so convert to what we want\n\t */\n\tif (!strncmp(engine, \"linuxaio\", 8) || !strncmp(engine, \"aio\", 3))\n\t\tstrcpy(engine, \"libaio\");\n\n\tops = find_ioengine(engine);\n\tif (!ops)\n\t\tops = dlopen_ioengine(td, name);\n\n\tif (!ops) {\n\t\tlog_err(\"fio: engine %s not loadable\\n\", name);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Check that the required methods are there.\n\t */\n\tif (check_engine_ops(ops))\n\t\treturn NULL;\n\n\treturn ops;\n}\n\n/*\n * For cleaning up an ioengine which never made it to init().\n */\nvoid free_ioengine(struct thread_data *td)\n{\n\tdprint(FD_IO, \"free ioengine %s\\n\", td->io_ops->name);\n\n\tif (td->eo && td->io_ops->options) {\n\t\toptions_free(td->io_ops->options, td->eo);\n\t\tfree(td->eo);\n\t\ttd->eo = NULL;\n\t}\n\n\tif (td->io_ops_dlhandle)\n\t\tdlclose(td->io_ops_dlhandle);\n\n\ttd->io_ops = NULL;\n}\n\nvoid close_ioengine(struct thread_data *td)\n{\n\tdprint(FD_IO, \"close ioengine %s\\n\", td->io_ops->name);\n\n\tif (td->io_ops->cleanup) {\n\t\ttd->io_ops->cleanup(td);\n\t\ttd->io_ops_data = NULL;\n\t}\n\n\tfree_ioengine(td);\n}\n\nint td_io_prep(struct thread_data *td, struct io_u *io_u)\n{\n\tdprint_io_u(io_u, \"prep\");\n\tfio_ro_check(td, io_u);\n\n\tlock_file(td, io_u->file, io_u->ddir);\n\n\tif (td->io_ops->prep) {\n\t\tint ret = td->io_ops->prep(td, io_u);\n\n\t\tdprint(FD_IO, \"->prep(%p)=%d\\n\", io_u, ret);\n\t\tif (ret)\n\t\t\tunlock_file(td, io_u->file);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint td_io_getevents(struct thread_data *td, unsigned int min, unsigned int max,\n\t\t    const struct timespec *t)\n{\n\tint r = 0;\n\n\t/*\n\t * For ioengine=rdma one side operation RDMA_WRITE or RDMA_READ,\n\t * server side gets a message from the client\n\t * side that the task is finished, and\n\t * td->done is set to 1 after td_io_commit(). In this case,\n\t * there is no need to reap complete event in server side.\n\t */\n\tif (td->done)\n\t\treturn 0;\n\n\tif (min > 0 && td->io_ops->commit) {\n\t\tr = td->io_ops->commit(td);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tif (max > td->cur_depth)\n\t\tmax = td->cur_depth;\n\tif (min > max)\n\t\tmax = min;\n\n\tr = 0;\n\tif (max && td->io_ops->getevents)\n\t\tr = td->io_ops->getevents(td, min, max, t);\nout:\n\tif (r >= 0) {\n\t\t/*\n\t\t * Reflect that our submitted requests were retrieved with\n\t\t * whatever OS async calls are in the underlying engine.\n\t\t */\n\t\ttd->io_u_in_flight -= r;\n\t\tio_u_mark_complete(td, r);\n\t} else\n\t\ttd_verror(td, r, \"get_events\");\n\n\tdprint(FD_IO, \"getevents: %d\\n\", r);\n\treturn r;\n}\n\nint td_io_queue(struct thread_data *td, struct io_u *io_u)\n{\n\tconst enum fio_ddir ddir = acct_ddir(io_u);\n\tunsigned long buflen = io_u->xfer_buflen;\n\tint ret;\n\n\tdprint_io_u(io_u, \"queue\");\n\tfio_ro_check(td, io_u);\n\n\tassert((io_u->flags & IO_U_F_FLIGHT) == 0);\n\tio_u_set(td, io_u, IO_U_F_FLIGHT);\n\n\tassert(fio_file_open(io_u->file));\n\n\t/*\n\t * If using a write iolog, store this entry.\n\t */\n\tlog_io_u(td, io_u);\n\n\tio_u->error = 0;\n\tio_u->resid = 0;\n\n\tif (td_ioengine_flagged(td, FIO_SYNCIO)) {\n\t\tif (fio_fill_issue_time(td))\n\t\t\tfio_gettime(&io_u->issue_time, NULL);\n\n\t\t/*\n\t\t * only used for iolog\n\t\t */\n\t\tif (td->o.read_iolog_file)\n\t\t\tmemcpy(&td->last_issue, &io_u->issue_time,\n\t\t\t\t\tsizeof(struct timeval));\n\t}\n\n\tif (ddir_rw(ddir)) {\n\t\ttd->io_issues[ddir]++;\n\t\ttd->io_issue_bytes[ddir] += buflen;\n\t\ttd->rate_io_issue_bytes[ddir] += buflen;\n\t}\n\n\tret = td->io_ops->queue(td, io_u);\n\n\tunlock_file(td, io_u->file);\n\n\tif (ret == FIO_Q_BUSY && ddir_rw(ddir)) {\n\t\ttd->io_issues[ddir]--;\n\t\ttd->io_issue_bytes[ddir] -= buflen;\n\t\ttd->rate_io_issue_bytes[ddir] -= buflen;\n\t\tio_u_clear(td, io_u, IO_U_F_FLIGHT);\n\t}\n\n\t/*\n\t * If an error was seen and the io engine didn't propagate it\n\t * back to 'td', do so.\n\t */\n\tif (io_u->error && !td->error)\n\t\ttd_verror(td, io_u->error, \"td_io_queue\");\n\n\t/*\n\t * Add warning for O_DIRECT so that users have an easier time\n\t * spotting potentially bad alignment. If this triggers for the first\n\t * IO, then it's likely an alignment problem or because the host fs\n\t * does not support O_DIRECT\n\t */\n\tif (io_u->error == EINVAL && td->io_issues[io_u->ddir & 1] == 1 &&\n\t    td->o.odirect) {\n\n\t\tlog_info(\"fio: first direct IO errored. File system may not \"\n\t\t\t \"support direct IO, or iomem_align= is bad. Try \"\n\t\t\t \"setting direct=0.\\n\");\n\t}\n\n\tif (!td->io_ops->commit || io_u->ddir == DDIR_TRIM) {\n\t\tio_u_mark_submit(td, 1);\n\t\tio_u_mark_complete(td, 1);\n\t}\n\n\tif (ret == FIO_Q_COMPLETED) {\n\t\tif (ddir_rw(io_u->ddir)) {\n\t\t\tio_u_mark_depth(td, 1);\n\t\t\ttd->ts.total_io_u[io_u->ddir]++;\n\t\t}\n\t} else if (ret == FIO_Q_QUEUED) {\n\t\tint r;\n\n\t\ttd->io_u_queued++;\n\n\t\tif (ddir_rw(io_u->ddir))\n\t\t\ttd->ts.total_io_u[io_u->ddir]++;\n\n\t\tif (td->io_u_queued >= td->o.iodepth_batch) {\n\t\t\tr = td_io_commit(td);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (!td_ioengine_flagged(td, FIO_SYNCIO)) {\n\t\tif (fio_fill_issue_time(td))\n\t\t\tfio_gettime(&io_u->issue_time, NULL);\n\n\t\t/*\n\t\t * only used for iolog\n\t\t */\n\t\tif (td->o.read_iolog_file)\n\t\t\tmemcpy(&td->last_issue, &io_u->issue_time,\n\t\t\t\t\tsizeof(struct timeval));\n\t}\n\n\treturn ret;\n}\n\nint td_io_init(struct thread_data *td)\n{\n\tint ret = 0;\n\n\tif (td->io_ops->init) {\n\t\tret = td->io_ops->init(td);\n\t\tif (ret)\n\t\t\tlog_err(\"fio: io engine %s init failed.%s\\n\",\n\t\t\t\ttd->io_ops->name,\n\t\t\t\ttd->o.iodepth > 1 ?\n\t\t\t\t\" Perhaps try reducing io depth?\" : \"\");\n\t\telse\n\t\t\ttd->io_ops_init = 1;\n\t\tif (!td->error)\n\t\t\ttd->error = ret;\n\t}\n\n\treturn ret;\n}\n\nint td_io_commit(struct thread_data *td)\n{\n\tint ret;\n\n\tdprint(FD_IO, \"calling ->commit(), depth %d\\n\", td->cur_depth);\n\n\tif (!td->cur_depth || !td->io_u_queued)\n\t\treturn 0;\n\n\tio_u_mark_depth(td, td->io_u_queued);\n\n\tif (td->io_ops->commit) {\n\t\tret = td->io_ops->commit(td);\n\t\tif (ret)\n\t\t\ttd_verror(td, -ret, \"io commit\");\n\t}\n\n\t/*\n\t * Reflect that events were submitted as async IO requests.\n\t */\n\ttd->io_u_in_flight += td->io_u_queued;\n\ttd->io_u_queued = 0;\n\n\treturn 0;\n}\n\nint td_io_open_file(struct thread_data *td, struct fio_file *f)\n{\n\tassert(!fio_file_open(f));\n\tassert(f->fd == -1);\n\n\tif (td->io_ops->open_file(td, f)) {\n\t\tif (td->error == EINVAL && td->o.odirect)\n\t\t\tlog_err(\"fio: destination does not support O_DIRECT\\n\");\n\t\tif (td->error == EMFILE) {\n\t\t\tlog_err(\"fio: try reducing/setting openfiles (failed\"\n\t\t\t\t\" at %u of %u)\\n\", td->nr_open_files,\n\t\t\t\t\t\t\ttd->o.nr_files);\n\t\t}\n\n\t\tassert(f->fd == -1);\n\t\tassert(!fio_file_open(f));\n\t\treturn 1;\n\t}\n\n\tfio_file_reset(td, f);\n\tfio_file_set_open(f);\n\tfio_file_clear_closing(f);\n\tdisk_util_inc(f->du);\n\n\ttd->nr_open_files++;\n\tget_file(f);\n\n\tif (f->filetype == FIO_TYPE_PIPE) {\n\t\tif (td_random(td)) {\n\t\t\tlog_err(\"fio: can't seek on pipes (no random io)\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (td_ioengine_flagged(td, FIO_DISKLESSIO))\n\t\tgoto done;\n\n\tif (td->o.invalidate_cache && file_invalidate_cache(td, f))\n\t\tgoto err;\n\n\tif (td->o.fadvise_hint != F_ADV_NONE &&\n\t    (f->filetype == FIO_TYPE_BLOCK || f->filetype == FIO_TYPE_FILE)) {\n\t\tint flags;\n\n\t\tif (td->o.fadvise_hint == F_ADV_TYPE) {\n\t\t\tif (td_random(td))\n\t\t\t\tflags = POSIX_FADV_RANDOM;\n\t\t\telse\n\t\t\t\tflags = POSIX_FADV_SEQUENTIAL;\n\t\t} else if (td->o.fadvise_hint == F_ADV_RANDOM)\n\t\t\tflags = POSIX_FADV_RANDOM;\n\t\telse if (td->o.fadvise_hint == F_ADV_SEQUENTIAL)\n\t\t\tflags = POSIX_FADV_SEQUENTIAL;\n\t\telse {\n\t\t\tlog_err(\"fio: unknown fadvise type %d\\n\",\n\t\t\t\t\t\t\ttd->o.fadvise_hint);\n\t\t\tflags = POSIX_FADV_NORMAL;\n\t\t}\n\n\t\tif (posix_fadvise(f->fd, f->file_offset, f->io_size, flags) < 0) {\n\t\t\ttd_verror(td, errno, \"fadvise\");\n\t\t\tgoto err;\n\t\t}\n\t}\n#ifdef FIO_HAVE_STREAMID\n\tif (td->o.fadvise_stream &&\n\t    (f->filetype == FIO_TYPE_BLOCK || f->filetype == FIO_TYPE_FILE)) {\n\t\toff_t stream = td->o.fadvise_stream;\n\n\t\tif (posix_fadvise(f->fd, stream, f->io_size, POSIX_FADV_STREAMID) < 0) {\n\t\t\ttd_verror(td, errno, \"fadvise streamid\");\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\n#ifdef FIO_OS_DIRECTIO\n\t/*\n\t * Some OS's have a distinct call to mark the file non-buffered,\n\t * instead of using O_DIRECT (Solaris)\n\t */\n\tif (td->o.odirect) {\n\t\tint ret = fio_set_odirect(f->fd);\n\n\t\tif (ret) {\n\t\t\ttd_verror(td, ret, \"fio_set_odirect\");\n\t\t\tif (ret == ENOTTY) { /* ENOTTY suggests RAW device or ZFS */\n\t\t\t\tlog_err(\"fio: doing directIO to RAW devices or ZFS not supported\\n\");\n\t\t\t} else {\n\t\t\t\tlog_err(\"fio: the file system does not seem to support direct IO\\n\");\n\t\t\t}\n\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\ndone:\n\tlog_file(td, f, FIO_LOG_OPEN_FILE);\n\treturn 0;\nerr:\n\tdisk_util_dec(f->du);\n\tif (td->io_ops->close_file)\n\t\ttd->io_ops->close_file(td, f);\n\treturn 1;\n}\n\nint td_io_close_file(struct thread_data *td, struct fio_file *f)\n{\n\tif (!fio_file_closing(f))\n\t\tlog_file(td, f, FIO_LOG_CLOSE_FILE);\n\n\t/*\n\t * mark as closing, do real close when last io on it has completed\n\t */\n\tfio_file_set_closing(f);\n\n\tdisk_util_dec(f->du);\n\n\tif (td->o.file_lock_mode != FILE_LOCK_NONE)\n\t\tunlock_file_all(td, f);\n\n\treturn put_file(td, f);\n}\n\nint td_io_unlink_file(struct thread_data *td, struct fio_file *f)\n{\n\tif (td->io_ops->unlink_file)\n\t\treturn td->io_ops->unlink_file(td, f);\n\telse {\n\t\tint ret;\n\n\t\tret = unlink(f->file_name);\n\t\tif (ret < 0)\n\t\t\treturn errno;\n\n\t\treturn 0;\n\t}\n}\n\nint td_io_get_file_size(struct thread_data *td, struct fio_file *f)\n{\n\tif (!td->io_ops->get_file_size)\n\t\treturn 0;\n\n\treturn td->io_ops->get_file_size(td, f);\n}\n\nint fio_show_ioengine_help(const char *engine)\n{\n\tstruct flist_head *entry;\n\tstruct thread_data td;\n\tstruct ioengine_ops *io_ops;\n\tchar *sep;\n\tint ret = 1;\n\n\tif (!engine || !*engine) {\n\t\tlog_info(\"Available IO engines:\\n\");\n\t\tflist_for_each(entry, &engine_list) {\n\t\t\tio_ops = flist_entry(entry, struct ioengine_ops, list);\n\t\t\tlog_info(\"\\t%s\\n\", io_ops->name);\n\t\t}\n\t\treturn 0;\n\t}\n\tsep = strchr(engine, ',');\n\tif (sep) {\n\t\t*sep = 0;\n\t\tsep++;\n\t}\n\n\tmemset(&td, 0, sizeof(td));\n\n\tio_ops = load_ioengine(&td, engine);\n\tif (!io_ops) {\n\t\tlog_info(\"IO engine %s not found\\n\", engine);\n\t\treturn 1;\n\t}\n\n\tif (io_ops->options)\n\t\tret = show_cmd_help(io_ops->options, sep);\n\telse\n\t\tlog_info(\"IO engine %s has no options\\n\", io_ops->name);\n\n\tfree_ioengine(&td);\n\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-fio-2.19-lpfwy24b64camdpwozxmuyihgbkhc44n/spack-src/os/windows/posix.c": "/* This file contains functions which implement those POSIX and Linux functions\n * that MinGW and Microsoft don't provide. The implementations contain just enough\n * functionality to support fio.\n */\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <windows.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <pthread.h>\n#include <time.h>\n#include <semaphore.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <sys/poll.h>\n#include <sys/wait.h>\n#include <setjmp.h>\n\n#include \"../os-windows.h\"\n#include \"../../lib/hweight.h\"\n\nextern unsigned long mtime_since_now(struct timeval *);\nextern void fio_gettime(struct timeval *, void *);\n\n/* These aren't defined in the MinGW headers */\nHRESULT WINAPI StringCchCopyA(\n  char *pszDest,\n  size_t cchDest,\n  const char *pszSrc);\n\nHRESULT WINAPI StringCchPrintfA(\n  char *pszDest,\n  size_t cchDest,\n  const char *pszFormat,\n  ...);\n\nint win_to_posix_error(DWORD winerr)\n{\n\tswitch (winerr)\n\t{\n\tcase ERROR_FILE_NOT_FOUND:\t\treturn ENOENT;\n\tcase ERROR_PATH_NOT_FOUND:\t\treturn ENOENT;\n\tcase ERROR_ACCESS_DENIED:\t\treturn EACCES;\n\tcase ERROR_INVALID_HANDLE:\t\treturn EBADF;\n\tcase ERROR_NOT_ENOUGH_MEMORY:\treturn ENOMEM;\n\tcase ERROR_INVALID_DATA:\t\treturn EINVAL;\n\tcase ERROR_OUTOFMEMORY:\t\t\treturn ENOMEM;\n\tcase ERROR_INVALID_DRIVE:\t\treturn ENODEV;\n\tcase ERROR_NOT_SAME_DEVICE:\t\treturn EXDEV;\n\tcase ERROR_WRITE_PROTECT:\t\treturn EROFS;\n\tcase ERROR_BAD_UNIT:\t\t\treturn ENODEV;\n\tcase ERROR_SHARING_VIOLATION:\treturn EACCES;\n\tcase ERROR_LOCK_VIOLATION:\t\treturn EACCES;\n\tcase ERROR_SHARING_BUFFER_EXCEEDED:\treturn ENOLCK;\n\tcase ERROR_HANDLE_DISK_FULL:\treturn ENOSPC;\n\tcase ERROR_NOT_SUPPORTED:\t\treturn ENOSYS;\n\tcase ERROR_FILE_EXISTS:\t\t\treturn EEXIST;\n\tcase ERROR_CANNOT_MAKE:\t\t\treturn EPERM;\n\tcase ERROR_INVALID_PARAMETER:\treturn EINVAL;\n\tcase ERROR_NO_PROC_SLOTS:\t\treturn EAGAIN;\n\tcase ERROR_BROKEN_PIPE:\t\t\treturn EPIPE;\n\tcase ERROR_OPEN_FAILED:\t\t\treturn EIO;\n\tcase ERROR_NO_MORE_SEARCH_HANDLES:\treturn ENFILE;\n\tcase ERROR_CALL_NOT_IMPLEMENTED:\treturn ENOSYS;\n\tcase ERROR_INVALID_NAME:\t\treturn ENOENT;\n\tcase ERROR_WAIT_NO_CHILDREN:\treturn ECHILD;\n\tcase ERROR_CHILD_NOT_COMPLETE:\treturn EBUSY;\n\tcase ERROR_DIR_NOT_EMPTY:\t\treturn ENOTEMPTY;\n\tcase ERROR_SIGNAL_REFUSED:\t\treturn EIO;\n\tcase ERROR_BAD_PATHNAME:\t\treturn ENOENT;\n\tcase ERROR_SIGNAL_PENDING:\t\treturn EBUSY;\n\tcase ERROR_MAX_THRDS_REACHED:\treturn EAGAIN;\n\tcase ERROR_BUSY:\t\t\t\treturn EBUSY;\n\tcase ERROR_ALREADY_EXISTS:\t\treturn EEXIST;\n\tcase ERROR_NO_SIGNAL_SENT:\t\treturn EIO;\n\tcase ERROR_FILENAME_EXCED_RANGE:\treturn EINVAL;\n\tcase ERROR_META_EXPANSION_TOO_LONG:\treturn EINVAL;\n\tcase ERROR_INVALID_SIGNAL_NUMBER:\treturn EINVAL;\n\tcase ERROR_THREAD_1_INACTIVE:\treturn EINVAL;\n\tcase ERROR_BAD_PIPE:\t\t\treturn EINVAL;\n\tcase ERROR_PIPE_BUSY:\t\t\treturn EBUSY;\n\tcase ERROR_NO_DATA:\t\t\t\treturn EPIPE;\n\tcase ERROR_MORE_DATA:\t\t\treturn EAGAIN;\n\tcase ERROR_DIRECTORY:\t\t\treturn ENOTDIR;\n\tcase ERROR_PIPE_CONNECTED:\t\treturn EBUSY;\n\tcase ERROR_NO_TOKEN:\t\t\treturn EINVAL;\n\tcase ERROR_PROCESS_ABORTED:\t\treturn EFAULT;\n\tcase ERROR_BAD_DEVICE:\t\t\treturn ENODEV;\n\tcase ERROR_BAD_USERNAME:\t\treturn EINVAL;\n\tcase ERROR_OPEN_FILES:\t\t\treturn EAGAIN;\n\tcase ERROR_ACTIVE_CONNECTIONS:\treturn EAGAIN;\n\tcase ERROR_DEVICE_IN_USE:\t\treturn EAGAIN;\n\tcase ERROR_INVALID_AT_INTERRUPT_TIME:\treturn EINTR;\n\tcase ERROR_IO_DEVICE:\t\t\treturn EIO;\n\tcase ERROR_NOT_OWNER:\t\t\treturn EPERM;\n\tcase ERROR_END_OF_MEDIA:\t\treturn ENOSPC;\n\tcase ERROR_EOM_OVERFLOW:\t\treturn ENOSPC;\n\tcase ERROR_BEGINNING_OF_MEDIA:\treturn ESPIPE;\n\tcase ERROR_SETMARK_DETECTED:\treturn ESPIPE;\n\tcase ERROR_NO_DATA_DETECTED:\treturn ENOSPC;\n\tcase ERROR_POSSIBLE_DEADLOCK:\treturn EDEADLOCK;\n\tcase ERROR_CRC:\t\t\t\t\treturn EIO;\n\tcase ERROR_NEGATIVE_SEEK:\t\treturn EINVAL;\n\tcase ERROR_DISK_FULL:\t\t\treturn ENOSPC;\n\tcase ERROR_NOACCESS:\t\t\treturn EFAULT;\n\tcase ERROR_FILE_INVALID:\t\treturn ENXIO;\n\t}\n\n\treturn winerr;\n}\n\nint GetNumLogicalProcessors(void)\n{\n\tSYSTEM_LOGICAL_PROCESSOR_INFORMATION *processor_info = NULL;\n\tDWORD len = 0;\n\tDWORD num_processors = 0;\n\tDWORD error = 0;\n\tDWORD i;\n\n\twhile (!GetLogicalProcessorInformation(processor_info, &len)) {\n\t\terror = GetLastError();\n\t\tif (error == ERROR_INSUFFICIENT_BUFFER)\n\t\t\tprocessor_info = malloc(len);\n\t\telse {\n\t\t\tlog_err(\"Error: GetLogicalProcessorInformation failed: %d\\n\", error);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (processor_info == NULL) {\n\t\t\tlog_err(\"Error: failed to allocate memory for GetLogicalProcessorInformation\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < len / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++)\n\t{\n\t\tif (processor_info[i].Relationship == RelationProcessorCore)\n\t\t\tnum_processors += hweight64(processor_info[i].ProcessorMask);\n\t}\n\n\tfree(processor_info);\n\treturn num_processors;\n}\n\nlong sysconf(int name)\n{\n\tlong val = -1;\n\tlong val2 = -1;\n\tSYSTEM_INFO sysInfo;\n\tMEMORYSTATUSEX status;\n\n\tswitch (name)\n\t{\n\tcase _SC_NPROCESSORS_ONLN:\n\t\tval = GetNumLogicalProcessors();\n\t\tif (val == -1)\n\t\t\tlog_err(\"sysconf(_SC_NPROCESSORS_ONLN) failed\\n\");\n\n\t\tbreak;\n\n\tcase _SC_PAGESIZE:\n\t\tGetSystemInfo(&sysInfo);\n\t\tval = sysInfo.dwPageSize;\n\t\tbreak;\n\n\tcase _SC_PHYS_PAGES:\n\t\tstatus.dwLength = sizeof(status);\n\t\tval2 = sysconf(_SC_PAGESIZE);\n\t\tif (GlobalMemoryStatusEx(&status) && val2 != -1)\n\t\t\tval = status.ullTotalPhys / val2;\n\t\telse\n\t\t\tlog_err(\"sysconf(_SC_PHYS_PAGES) failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"sysconf(%d) is not implemented\\n\", name);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nchar *dl_error = NULL;\n\nint dlclose(void *handle)\n{\n\treturn !FreeLibrary((HMODULE)handle);\n}\n\nvoid *dlopen(const char *file, int mode)\n{\n\tHMODULE hMod;\n\n\thMod = LoadLibrary(file);\n\tif (hMod == INVALID_HANDLE_VALUE)\n\t\tdl_error = (char*)\"LoadLibrary failed\";\n\telse\n\t\tdl_error = NULL;\n\n\treturn hMod;\n}\n\nvoid *dlsym(void *handle, const char *name)\n{\n\tFARPROC fnPtr;\n\n\tfnPtr = GetProcAddress((HMODULE)handle, name);\n\tif (fnPtr == NULL)\n\t\tdl_error = (char*)\"GetProcAddress failed\";\n\telse\n\t\tdl_error = NULL;\n\n\treturn fnPtr;\n}\n\nchar *dlerror(void)\n{\n\treturn dl_error;\n}\n\n/* Copied from http://blogs.msdn.com/b/joshpoley/archive/2007/12/19/date-time-formats-and-conversions.aspx */\nvoid Time_tToSystemTime(time_t dosTime, SYSTEMTIME *systemTime)\n{\n    FILETIME utcFT;\n    LONGLONG jan1970;\n\n    jan1970 = Int32x32To64(dosTime, 10000000) + 116444736000000000;\n    utcFT.dwLowDateTime = (DWORD)jan1970;\n    utcFT.dwHighDateTime = jan1970 >> 32;\n\n    FileTimeToSystemTime((FILETIME*)&utcFT, systemTime);\n}\n\nchar* ctime_r(const time_t *t, char *buf)\n{\n    SYSTEMTIME systime;\n    const char * const dayOfWeek[] = { \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };\n    const char * const monthOfYear[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\n    Time_tToSystemTime(*t, &systime);\n    /* We don't know how long `buf` is, but assume it's rounded up from the minimum of 25 to 32 */\n    StringCchPrintfA(buf, 31, \"%s %s %d %02d:%02d:%02d %04d\\n\", dayOfWeek[systime.wDayOfWeek % 7], monthOfYear[(systime.wMonth - 1) % 12],\n\t\t\t\t\t\t\t\t\t\t systime.wDay, systime.wHour, systime.wMinute, systime.wSecond, systime.wYear);\n    return buf;\n}\n\nint gettimeofday(struct timeval *restrict tp, void *restrict tzp)\n{\n\tFILETIME fileTime;\n\tuint64_t unix_time, windows_time;\n\tconst uint64_t MILLISECONDS_BETWEEN_1601_AND_1970 = 11644473600000;\n\n\t/* Ignore the timezone parameter */\n\t(void)tzp;\n\n\t/*\n\t * Windows time is stored as the number 100 ns intervals since January 1 1601.\n\t * Conversion details from http://www.informit.com/articles/article.aspx?p=102236&seqNum=3\n\t * Its precision is 100 ns but accuracy is only one clock tick, or normally around 15 ms.\n\t */\n\tGetSystemTimeAsFileTime(&fileTime);\n\twindows_time = ((uint64_t)fileTime.dwHighDateTime << 32) + fileTime.dwLowDateTime;\n\t/* Divide by 10,000 to convert to ms and subtract the time between 1601 and 1970 */\n\tunix_time = (((windows_time)/10000) - MILLISECONDS_BETWEEN_1601_AND_1970);\n\t/* unix_time is now the number of milliseconds since 1970 (the Unix epoch) */\n\ttp->tv_sec = unix_time / 1000;\n\ttp->tv_usec = (unix_time % 1000) * 1000;\n\treturn 0;\n}\n\nint sigaction(int sig, const struct sigaction *act,\n\t\tstruct sigaction *oact)\n{\n\tint rc = 0;\n\tvoid (*prev_handler)(int);\n\n\tprev_handler = signal(sig, act->sa_handler);\n\tif (oact != NULL)\n\t\toact->sa_handler = prev_handler;\n\n\tif (prev_handler == SIG_ERR)\n\t\trc = -1;\n\n\treturn rc;\n}\n\nint lstat(const char * path, struct stat * buf)\n{\n\treturn stat(path, buf);\n}\n\nvoid *mmap(void *addr, size_t len, int prot, int flags,\n\t\tint fildes, off_t off)\n{\n\tDWORD vaProt = 0;\n\tDWORD mapAccess = 0;\n\tDWORD lenlow;\n\tDWORD lenhigh;\n\tHANDLE hMap;\n\tvoid* allocAddr = NULL;\n\n\tif (prot & PROT_NONE)\n\t\tvaProt |= PAGE_NOACCESS;\n\n\tif ((prot & PROT_READ) && !(prot & PROT_WRITE)) {\n\t\tvaProt |= PAGE_READONLY;\n\t\tmapAccess = FILE_MAP_READ;\n\t}\n\n\tif (prot & PROT_WRITE) {\n\t\tvaProt |= PAGE_READWRITE;\n\t\tmapAccess |= FILE_MAP_WRITE;\n\t}\n\n\tlenlow = len & 0xFFFF;\n\tlenhigh = len >> 16;\n\t/* If the low DWORD is zero and the high DWORD is non-zero, `CreateFileMapping`\n\t   will return ERROR_INVALID_PARAMETER. To avoid this, set both to zero. */\n\tif (lenlow == 0) {\n\t\tlenhigh = 0;\n\t}\n\n\tif (flags & MAP_ANON || flags & MAP_ANONYMOUS)\n\t{\n\t\tallocAddr = VirtualAlloc(addr, len, MEM_COMMIT, vaProt);\n\t\tif (allocAddr == NULL)\n\t\t\terrno = win_to_posix_error(GetLastError());\n\t}\n\telse\n\t{\n\t\thMap = CreateFileMapping((HANDLE)_get_osfhandle(fildes), NULL, vaProt, lenhigh, lenlow, NULL);\n\n\t\tif (hMap != NULL)\n\t\t{\n\t\t\tallocAddr = MapViewOfFile(hMap, mapAccess, off >> 16, off & 0xFFFF, len);\n\t\t}\n\n\t\tif (hMap == NULL || allocAddr == NULL)\n\t\t\terrno = win_to_posix_error(GetLastError());\n\n\t}\n\n\treturn allocAddr;\n}\n\nint munmap(void *addr, size_t len)\n{\n\tBOOL success;\n\n\t/* We may have allocated the memory with either MapViewOfFile or\n\t\t VirtualAlloc. Therefore, try calling UnmapViewOfFile first, and if that\n\t\t fails, call VirtualFree. */\n\tsuccess = UnmapViewOfFile(addr);\n\n\tif (!success)\n\t{\n\t\tsuccess = VirtualFree(addr, 0, MEM_RELEASE);\n\t}\n\n\treturn !success;\n}\n\nint msync(void *addr, size_t len, int flags)\n{\n\treturn !FlushViewOfFile(addr, len);\n}\n\nint fork(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\npid_t setsid(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nstatic HANDLE log_file = INVALID_HANDLE_VALUE;\n\nvoid openlog(const char *ident, int logopt, int facility)\n{\n\tif (log_file == INVALID_HANDLE_VALUE)\n\t\tlog_file = CreateFileA(\"syslog.txt\", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);\n}\n\nvoid closelog(void)\n{\n\tCloseHandle(log_file);\n\tlog_file = INVALID_HANDLE_VALUE;\n}\n\nvoid syslog(int priority, const char *message, ... /* argument */)\n{\n\tva_list v;\n\tint len;\n\tchar *output;\n\tDWORD bytes_written;\n\n\tif (log_file == INVALID_HANDLE_VALUE) {\n\t\tlog_file = CreateFileA(\"syslog.txt\", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);\n\t}\n\n\tif (log_file == INVALID_HANDLE_VALUE) {\n\t\tlog_err(\"syslog: failed to open log file\\n\");\n\t\treturn;\n\t}\n\n\tva_start(v, message);\n\tlen = _vscprintf(message, v);\n\toutput = malloc(len + sizeof(char));\n\tvsprintf(output, message, v);\n\tWriteFile(log_file, output, len, &bytes_written, NULL);\n\tva_end(v);\n\tfree(output);\n}\n\nint kill(pid_t pid, int sig)\n{\n\terrno = ESRCH;\n\treturn -1;\n}\n\n/*\n * This is assumed to be used only by the network code,\n * and so doesn't try and handle any of the other cases\n */\nint fcntl(int fildes, int cmd, ...)\n{\n\t/*\n\t * non-blocking mode doesn't work the same as in BSD sockets,\n\t * so ignore it.\n\t */\n#if 0\n\tva_list ap;\n\tint val, opt, status;\n\n\tif (cmd == F_GETFL)\n\t\treturn 0;\n\telse if (cmd != F_SETFL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tva_start(ap, 1);\n\n\topt = va_arg(ap, int);\n\tif (opt & O_NONBLOCK)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\tstatus = ioctlsocket((SOCKET)fildes, opt, &val);\n\n\tif (status == SOCKET_ERROR) {\n\t\terrno = EINVAL;\n\t\tval = -1;\n\t}\n\n\tva_end(ap);\n\n\treturn val;\n#endif\nreturn 0;\n}\n\n/*\n * Get the value of a local clock source.\n * This implementation supports 2 clocks: CLOCK_MONOTONIC provides high-accuracy\n * relative time, while CLOCK_REALTIME provides a low-accuracy wall time.\n */\nint clock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n\tint rc = 0;\n\n\tif (clock_id == CLOCK_MONOTONIC)\n\t{\n\t\tstatic LARGE_INTEGER freq = {{0,0}};\n\t\tLARGE_INTEGER counts;\n\t\tuint64_t t;\n\n\t\tQueryPerformanceCounter(&counts);\n\t\tif (freq.QuadPart == 0)\n\t\t\tQueryPerformanceFrequency(&freq);\n\n\t\ttp->tv_sec = counts.QuadPart / freq.QuadPart;\n\t\t/* Get the difference between the number of ns stored\n\t\t * in 'tv_sec' and that stored in 'counts' */\n\t\tt = tp->tv_sec * freq.QuadPart;\n\t\tt = counts.QuadPart - t;\n\t\t/* 't' now contains the number of cycles since the last second.\n\t\t * We want the number of nanoseconds, so multiply out by 1,000,000,000\n\t\t * and then divide by the frequency. */\n\t\tt *= 1000000000;\n\t\ttp->tv_nsec = t / freq.QuadPart;\n\t}\n\telse if (clock_id == CLOCK_REALTIME)\n\t{\n\t\t/* clock_gettime(CLOCK_REALTIME,...) is just an alias for gettimeofday with a\n\t\t * higher-precision field. */\n\t\tstruct timeval tv;\n\t\tgettimeofday(&tv, NULL);\n\t\ttp->tv_sec = tv.tv_sec;\n\t\ttp->tv_nsec = tv.tv_usec * 1000;\n\t} else {\n\t\terrno = EINVAL;\n\t\trc = -1;\n\t}\n\n\treturn rc;\n}\n\nint mlock(const void * addr, size_t len)\n{\n\tSIZE_T min, max;\n\tBOOL success;\n\tHANDLE process = GetCurrentProcess();\n\n\tsuccess = GetProcessWorkingSetSize(process, &min, &max);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\tmin += len;\n\tmax += len;\n\tsuccess = SetProcessWorkingSetSize(process, min, max);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\tsuccess = VirtualLock((LPVOID)addr, len);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint munlock(const void * addr, size_t len)\n{\n\tBOOL success = VirtualUnlock((LPVOID)addr, len);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\npid_t waitpid(pid_t pid, int *stat_loc, int options)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint usleep(useconds_t useconds)\n{\n\tSleep(useconds / 1000);\n\treturn 0;\n}\n\nchar *basename(char *path)\n{\n\tstatic char name[MAX_PATH];\n\tint i;\n\n\tif (path == NULL || strlen(path) == 0)\n\t\treturn (char*)\".\";\n\n\ti = strlen(path) - 1;\n\n\twhile (path[i] != '\\\\' && path[i] != '/' && i >= 0)\n\t\ti--;\n\n\tstrncpy(name, path + i + 1, MAX_PATH);\n\n\treturn name;\n}\n\nint fsync(int fildes)\n{\n\tHANDLE hFile = (HANDLE)_get_osfhandle(fildes);\n\tif (!FlushFileBuffers(hFile)) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint nFileMappings = 0;\nHANDLE fileMappings[1024];\n\nint shmget(key_t key, size_t size, int shmflg)\n{\n\tint mapid = -1;\n\tuint32_t size_low = size & 0xFFFFFFFF;\n\tuint32_t size_high = ((uint64_t)size) >> 32;\n\tHANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, (PAGE_EXECUTE_READWRITE | SEC_RESERVE), size_high, size_low, NULL);\n\tif (hMapping != NULL) {\n\t\tfileMappings[nFileMappings] = hMapping;\n\t\tmapid = nFileMappings;\n\t\tnFileMappings++;\n\t} else {\n\t\terrno = ENOSYS;\n\t}\n\n\treturn mapid;\n}\n\nvoid *shmat(int shmid, const void *shmaddr, int shmflg)\n{\n\tvoid* mapAddr;\n\tMEMORY_BASIC_INFORMATION memInfo;\n\tmapAddr = MapViewOfFile(fileMappings[shmid], FILE_MAP_ALL_ACCESS, 0, 0, 0);\n\tif (mapAddr == NULL) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\tif (VirtualQuery(mapAddr, &memInfo, sizeof(memInfo)) == 0) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\tmapAddr = VirtualAlloc(mapAddr, memInfo.RegionSize, MEM_COMMIT, PAGE_READWRITE);\n\tif (mapAddr == NULL) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\treturn mapAddr;\n}\n\nint shmdt(const void *shmaddr)\n{\n\tif (!UnmapViewOfFile(shmaddr)) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint shmctl(int shmid, int cmd, struct shmid_ds *buf)\n{\n\tif (cmd == IPC_RMID) {\n\t\tfileMappings[shmid] = INVALID_HANDLE_VALUE;\n\t\treturn 0;\n\t} else {\n\t\tlog_err(\"%s is not implemented\\n\", __func__);\n\t}\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint setuid(uid_t uid)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint setgid(gid_t gid)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint nice(int incr)\n{\n\tDWORD prioclass = NORMAL_PRIORITY_CLASS;\n\t\n\tif (incr < -15)\n\t\tprioclass = HIGH_PRIORITY_CLASS;\n\telse if (incr < 0)\n\t\tprioclass = ABOVE_NORMAL_PRIORITY_CLASS;\n\telse if (incr > 15)\n\t\tprioclass = IDLE_PRIORITY_CLASS;\n\telse if (incr > 0)\n\t\tprioclass = BELOW_NORMAL_PRIORITY_CLASS;\n\t\n\tif (!SetPriorityClass(GetCurrentProcess(), prioclass))\n\t\tlog_err(\"fio: SetPriorityClass failed\\n\");\n\n\treturn 0;\n}\n\nint getrusage(int who, struct rusage *r_usage)\n{\n\tconst uint64_t SECONDS_BETWEEN_1601_AND_1970 = 11644473600;\n\tFILETIME cTime, eTime, kTime, uTime;\n\ttime_t time;\n\tHANDLE h;\n\n\tmemset(r_usage, 0, sizeof(*r_usage));\n\n\tif (who == RUSAGE_SELF) {\n\t\th = GetCurrentProcess();\n\t\tGetProcessTimes(h, &cTime, &eTime, &kTime, &uTime);\n\t} else if (who == RUSAGE_THREAD) {\n\t\th = GetCurrentThread();\n\t\tGetThreadTimes(h, &cTime, &eTime, &kTime, &uTime);\n\t} else {\n\t\tlog_err(\"fio: getrusage %d is not implemented\\n\", who);\n\t\treturn -1;\n\t}\n\n\ttime = ((uint64_t)uTime.dwHighDateTime << 32) + uTime.dwLowDateTime;\n\t/* Divide by 10,000,000 to get the number of seconds and move the epoch from\n\t * 1601 to 1970 */\n\ttime = (time_t)(((time)/10000000) - SECONDS_BETWEEN_1601_AND_1970);\n\tr_usage->ru_utime.tv_sec = time;\n\t/* getrusage() doesn't care about anything other than seconds, so set tv_usec to 0 */\n\tr_usage->ru_utime.tv_usec = 0;\n\ttime = ((uint64_t)kTime.dwHighDateTime << 32) + kTime.dwLowDateTime;\n\t/* Divide by 10,000,000 to get the number of seconds and move the epoch from\n\t * 1601 to 1970 */\n\ttime = (time_t)(((time)/10000000) - SECONDS_BETWEEN_1601_AND_1970);\n\tr_usage->ru_stime.tv_sec = time;\n\tr_usage->ru_stime.tv_usec = 0;\n\treturn 0;\n}\n\nint posix_madvise(void *addr, size_t len, int advice)\n{\n\treturn ENOSYS;\n}\n\nint fdatasync(int fildes)\n{\n\treturn fsync(fildes);\n}\n\nssize_t pwrite(int fildes, const void *buf, size_t nbyte,\n\t\toff_t offset)\n{\n\tint64_t pos = _telli64(fildes);\n\tssize_t len = _write(fildes, buf, nbyte);\n\t_lseeki64(fildes, pos, SEEK_SET);\n\treturn len;\n}\n\nssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset)\n{\n\tint64_t pos = _telli64(fildes);\n\tssize_t len = read(fildes, buf, nbyte);\n\t_lseeki64(fildes, pos, SEEK_SET);\n\treturn len;\n}\n\nssize_t readv(int fildes, const struct iovec *iov, int iovcnt)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nssize_t writev(int fildes, const struct iovec *iov, int iovcnt)\n{\n\tint i;\n\tDWORD bytes_written = 0;\n\tfor (i = 0; i < iovcnt; i++)\n\t{\n\t\tint len = send((SOCKET)fildes, iov[i].iov_base, iov[i].iov_len, 0);\n\t\tif (len == SOCKET_ERROR)\n\t\t{\n\t\t\tDWORD err = GetLastError();\n\t\t\terrno = win_to_posix_error(err);\n\t\t\tbytes_written = -1;\n\t\t\tbreak;\n\t\t}\n\t\tbytes_written += len;\n\t}\n\n\treturn bytes_written;\n}\n\nlong long strtoll(const char *restrict str, char **restrict endptr,\n\t\tint base)\n{\n\treturn _strtoi64(str, endptr, base);\n}\n\nint poll(struct pollfd fds[], nfds_t nfds, int timeout)\n{\n\tstruct timeval tv;\n\tstruct timeval *to = NULL;\n\tfd_set readfds, writefds, exceptfds;\n\tint i;\n\tint rc;\n\n\tif (timeout != -1) {\n\t\tto = &tv;\n\t\tto->tv_sec = timeout / 1000;\n\t\tto->tv_usec = (timeout % 1000) * 1000;\n\t}\n\n\tFD_ZERO(&readfds);\n\tFD_ZERO(&writefds);\n\tFD_ZERO(&exceptfds);\n\n\tfor (i = 0; i < nfds; i++)\n\t{\n\t\tif (fds[i].fd < 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fds[i].events & POLLIN)\n\t\t\tFD_SET(fds[i].fd, &readfds);\n\n\t\tif (fds[i].events & POLLOUT)\n\t\t\tFD_SET(fds[i].fd, &writefds);\n\n\t\tFD_SET(fds[i].fd, &exceptfds);\n\t}\n\trc = select(nfds, &readfds, &writefds, &exceptfds, to);\n\n\tif (rc != SOCKET_ERROR) {\n\t\tfor (i = 0; i < nfds; i++)\n\t\t{\n\t\t\tif (fds[i].fd < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((fds[i].events & POLLIN) && FD_ISSET(fds[i].fd, &readfds))\n\t\t\t\tfds[i].revents |= POLLIN;\n\n\t\t\tif ((fds[i].events & POLLOUT) && FD_ISSET(fds[i].fd, &writefds))\n\t\t\t\tfds[i].revents |= POLLOUT;\n\n\t\t\tif (FD_ISSET(fds[i].fd, &exceptfds))\n\t\t\t\tfds[i].revents |= POLLHUP;\n\t\t}\n\t}\n\treturn rc;\n}\n\nint nanosleep(const struct timespec *rqtp, struct timespec *rmtp)\n{\n\tstruct timeval tv;\n\tDWORD ms_remaining;\n\tDWORD ms_total = (rqtp->tv_sec * 1000) + (rqtp->tv_nsec / 1000000.0);\n\n\tif (ms_total == 0)\n\t\tms_total = 1;\n\n\tms_remaining = ms_total;\n\n\t/* Since Sleep() can sleep for less than the requested time, add a loop to\n\t   ensure we only return after the requested length of time has elapsed */\n\tdo {\n\t\tfio_gettime(&tv, NULL);\n\t\tSleep(ms_remaining);\n\t\tms_remaining = ms_total - mtime_since_now(&tv);\n\t} while (ms_remaining > 0 && ms_remaining < ms_total);\n\n\t/* this implementation will never sleep for less than the requested time */\n\tif (rmtp != NULL) {\n\t\trmtp->tv_sec = 0;\n\t\trmtp->tv_nsec = 0;\n\t}\n\n\treturn 0;\n}\n\nDIR *opendir(const char *dirname)\n{\n\tstruct dirent_ctx *dc = NULL;\n\n\t/* See if we can open it. If not, we'll return an error here */\n\tHANDLE file = CreateFileA(dirname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tif (file != INVALID_HANDLE_VALUE) {\n\t\tCloseHandle(file);\n\t\tdc = (struct dirent_ctx*)malloc(sizeof(struct dirent_ctx));\n\t\tStringCchCopyA(dc->dirname, MAX_PATH, dirname);\n\t\tdc->find_handle = INVALID_HANDLE_VALUE;\n\t} else {\n\t\tDWORD error = GetLastError();\n\t\tif (error == ERROR_FILE_NOT_FOUND)\n\t\t\terrno = ENOENT;\n\n\t\telse if (error == ERROR_PATH_NOT_FOUND)\n\t\t\terrno = ENOTDIR;\n\t\telse if (error == ERROR_TOO_MANY_OPEN_FILES)\n\t\t\terrno = ENFILE;\n\t\telse if (error == ERROR_ACCESS_DENIED)\n\t\t\terrno = EACCES;\n\t\telse\n\t\t\terrno = error;\n\t}\n\n\treturn dc;\n}\n\nint closedir(DIR *dirp)\n{\n\tif (dirp != NULL && dirp->find_handle != INVALID_HANDLE_VALUE)\n\t\tFindClose(dirp->find_handle);\n\n\tfree(dirp);\n\treturn 0;\n}\n\nstruct dirent *readdir(DIR *dirp)\n{\n\tstatic struct dirent de;\n\tWIN32_FIND_DATA find_data;\n\n\tif (dirp == NULL)\n\t\treturn NULL;\n\n\tif (dirp->find_handle == INVALID_HANDLE_VALUE) {\n\t\tchar search_pattern[MAX_PATH];\n\t\tStringCchPrintfA(search_pattern, MAX_PATH-1, \"%s\\\\*\", dirp->dirname);\n\t\tdirp->find_handle = FindFirstFileA(search_pattern, &find_data);\n\t\tif (dirp->find_handle == INVALID_HANDLE_VALUE)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!FindNextFile(dirp->find_handle, &find_data))\n\t\t\treturn NULL;\n\t}\n\n\tStringCchCopyA(de.d_name, MAX_PATH, find_data.cFileName);\n\tde.d_ino = 0;\n\n\treturn &de;\n}\n\nuid_t geteuid(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nin_addr_t inet_network(const char *cp)\n{\n\tin_addr_t hbo;\n\tin_addr_t nbo = inet_addr(cp);\n\thbo = ((nbo & 0xFF) << 24) + ((nbo & 0xFF00) << 8) + ((nbo & 0xFF0000) >> 8) + ((nbo & 0xFF000000) >> 24);\n\treturn hbo;\n}\n\nconst char* inet_ntop(int af, const void *restrict src,\n\t\tchar *restrict dst, socklen_t size)\n{\n\tINT status = SOCKET_ERROR;\n\tWSADATA wsd;\n\tchar *ret = NULL;\n\n\tif (af != AF_INET && af != AF_INET6) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\n\tWSAStartup(MAKEWORD(2,2), &wsd);\n\n\tif (af == AF_INET) {\n\t\tstruct sockaddr_in si;\n\t\tDWORD len = size;\n\t\tmemset(&si, 0, sizeof(si));\n\t\tsi.sin_family = af;\n\t\tmemcpy(&si.sin_addr, src, sizeof(si.sin_addr));\n\t\tstatus = WSAAddressToString((struct sockaddr*)&si, sizeof(si), NULL, dst, &len);\n\t} else if (af == AF_INET6) {\n\t\tstruct sockaddr_in6 si6;\n\t\tDWORD len = size;\n\t\tmemset(&si6, 0, sizeof(si6));\n\t\tsi6.sin6_family = af;\n\t\tmemcpy(&si6.sin6_addr, src, sizeof(si6.sin6_addr));\n\t\tstatus = WSAAddressToString((struct sockaddr*)&si6, sizeof(si6), NULL, dst, &len);\n\t}\n\n\tif (status != SOCKET_ERROR)\n\t\tret = dst;\n\telse\n\t\terrno = ENOSPC;\n\n\tWSACleanup();\n\n\treturn ret;\n}\n\nint inet_pton(int af, const char *restrict src, void *restrict dst)\n{\n\tINT status = SOCKET_ERROR;\n\tWSADATA wsd;\n\tint ret = 1;\n\n\tif (af != AF_INET && af != AF_INET6) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tWSAStartup(MAKEWORD(2,2), &wsd);\n\n\tif (af == AF_INET) {\n\t\tstruct sockaddr_in si;\n\t\tINT len = sizeof(si);\n\t\tmemset(&si, 0, sizeof(si));\n\t\tsi.sin_family = af;\n\t\tstatus = WSAStringToAddressA((char*)src, af, NULL, (struct sockaddr*)&si, &len);\n\t\tif (status != SOCKET_ERROR)\n\t\t\tmemcpy(dst, &si.sin_addr, sizeof(si.sin_addr));\n\t} else if (af == AF_INET6) {\n\t\tstruct sockaddr_in6 si6;\n\t\tINT len = sizeof(si6);\n\t\tmemset(&si6, 0, sizeof(si6));\n\t\tsi6.sin6_family = af;\n\t\tstatus = WSAStringToAddressA((char*)src, af, NULL, (struct sockaddr*)&si6, &len);\n\t\tif (status != SOCKET_ERROR)\n\t\t\tmemcpy(dst, &si6.sin6_addr, sizeof(si6.sin6_addr));\n\t}\n\n\tif (status == SOCKET_ERROR) {\n\t\terrno = ENOSPC;\n\t\tret = 0;\n\t}\n\n\tWSACleanup();\n\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-fio-2.19-lpfwy24b64camdpwozxmuyihgbkhc44n/spack-src/os/windows/posix/include/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\n\n#define RTLD_LAZY 1\n\nvoid *dlopen(const char *file, int mode);\nint dlclose(void *handle);\nvoid *dlsym(void *restrict handle, const char *restrict name);\nchar *dlerror(void);\n\n#endif /* DLFCN_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-fio-2.19-lpfwy24b64camdpwozxmuyihgbkhc44n/spack-src/tools/plot/samples/fio-logs.tar.gz"
    ],
    "total_files": 375
}