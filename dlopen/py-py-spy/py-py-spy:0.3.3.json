{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_3_7.rs": "// Generated bindings for python v3.3.7\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_reserved: *mut ::std::os::raw::c_void,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_long,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = ::std::os::raw::c_uint;\npub type Py_UCS2 = ::std::os::raw::c_ushort;\npub type Py_UCS1 = ::std::os::raw::c_uchar;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,\n    pub __bindgen_padding_0: [u8; 3usize],\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictKeyEntry {\n    pub me_hash: Py_hash_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictKeyEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fscodec_initialized: ::std::os::raw::c_int,\n    pub dlopenflags: ::std::os::raw::c_int,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub dict: *mut PyObject,\n    pub tick_counter: ::std::os::raw::c_int,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_long,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *mut ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *mut ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut ::std::os::raw::c_uchar,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_exc_type: *mut PyObject,\n    pub f_exc_value: *mut PyObject,\n    pub f_exc_traceback: *mut PyObject,\n    pub f_tstate: *mut PyThreadState,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct _dictkeysobject {\n    pub _address: u8,\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_5_5.rs": "// Generated bindings for python v3.5.5\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n    pub nb_matrix_multiply: binaryfunc,\n    pub nb_inplace_matrix_multiply: binaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyAsyncMethods {\n    pub am_await: unaryfunc,\n    pub am_aiter: unaryfunc,\n    pub am_anext: unaryfunc,\n}\nimpl Default for PyAsyncMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_as_async: *mut PyAsyncMethods,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_ulong,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n    pub tp_finalize: destructor,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = ::std::os::raw::c_uint;\npub type Py_UCS2 = ::std::os::raw::c_ushort;\npub type Py_UCS1 = ::std::os::raw::c_uchar;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fscodec_initialized: ::std::os::raw::c_int,\n    pub dlopenflags: ::std::os::raw::c_int,\n    pub builtins_copy: *mut PyObject,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub prev: *mut _ts,\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub dict: *mut PyObject,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_long,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n    pub on_delete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub on_delete_data: *mut ::std::os::raw::c_void,\n    pub coroutine_wrapper: *mut PyObject,\n    pub in_coroutine_wrapper: ::std::os::raw::c_int,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *mut ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *mut ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut ::std::os::raw::c_uchar,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_exc_type: *mut PyObject,\n    pub f_exc_value: *mut PyObject,\n    pub f_exc_traceback: *mut PyObject,\n    pub f_gen: *mut PyObject,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_executing: ::std::os::raw::c_char,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictKeyEntry {\n    pub me_hash: Py_hash_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictKeyEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type dict_lookup_func = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        mp: *mut PyDictObject,\n        key: *mut PyObject,\n        hash: Py_hash_t,\n        value_addr: *mut *mut *mut PyObject,\n    ) -> *mut PyDictKeyEntry,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _dictkeysobject {\n    pub dk_refcnt: Py_ssize_t,\n    pub dk_size: Py_ssize_t,\n    pub dk_lookup: dict_lookup_func,\n    pub dk_usable: Py_ssize_t,\n    pub dk_entries: [PyDictKeyEntry; 1usize],\n}\nimpl Default for _dictkeysobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_8_0.rs": "// Generated bindings for python v3.8.0b4\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\n#[repr(C)]\n#[derive(Default)]\npub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);\nimpl<T> __IncompleteArrayField<T> {\n    #[inline]\n    pub fn new() -> Self {\n        __IncompleteArrayField(::std::marker::PhantomData)\n    }\n    #[inline]\n    pub unsafe fn as_ptr(&self) -> *const T {\n        ::std::mem::transmute(self)\n    }\n    #[inline]\n    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n        ::std::mem::transmute(self)\n    }\n    #[inline]\n    pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n        ::std::slice::from_raw_parts(self.as_ptr(), len)\n    }\n    #[inline]\n    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n    }\n}\nimpl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {\n    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        fmt.write_str(\"__IncompleteArrayField\")\n    }\n}\nimpl<T> ::std::clone::Clone for __IncompleteArrayField<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self::new()\n    }\n}\nimpl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_size_t = ::std::os::raw::c_ulong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_vectorcall_offset: Py_ssize_t,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_as_async: *mut PyAsyncMethods,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_ulong,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n    pub tp_finalize: destructor,\n    pub tp_vectorcall: vectorcallfunc,\n    pub tp_print: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut PyObject,\n            arg2: *mut FILE,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type vectorcallfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        callable: *mut PyObject,\n        args: *const *mut PyObject,\n        nargsf: usize,\n        kwnames: *mut PyObject,\n    ) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n    pub nb_matrix_multiply: binaryfunc,\n    pub nb_inplace_matrix_multiply: binaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyAsyncMethods {\n    pub am_await: unaryfunc,\n    pub am_aiter: unaryfunc,\n    pub am_anext: unaryfunc,\n}\nimpl Default for PyAsyncMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = u32;\npub type Py_UCS2 = u16;\npub type Py_UCS1 = u8;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_version_tag: u64,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThread_type_lock = *mut ::std::os::raw::c_void;\npub type PyThreadState = _ts;\npub type PyInterpreterState = _is;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyWideStringList {\n    pub length: Py_ssize_t,\n    pub items: *mut *mut wchar_t,\n}\nimpl Default for PyWideStringList {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyConfig {\n    pub _config_version: ::std::os::raw::c_int,\n    pub _config_init: ::std::os::raw::c_int,\n    pub isolated: ::std::os::raw::c_int,\n    pub use_environment: ::std::os::raw::c_int,\n    pub dev_mode: ::std::os::raw::c_int,\n    pub install_signal_handlers: ::std::os::raw::c_int,\n    pub use_hash_seed: ::std::os::raw::c_int,\n    pub hash_seed: ::std::os::raw::c_ulong,\n    pub faulthandler: ::std::os::raw::c_int,\n    pub tracemalloc: ::std::os::raw::c_int,\n    pub import_time: ::std::os::raw::c_int,\n    pub show_ref_count: ::std::os::raw::c_int,\n    pub show_alloc_count: ::std::os::raw::c_int,\n    pub dump_refs: ::std::os::raw::c_int,\n    pub malloc_stats: ::std::os::raw::c_int,\n    pub filesystem_encoding: *mut wchar_t,\n    pub filesystem_errors: *mut wchar_t,\n    pub pycache_prefix: *mut wchar_t,\n    pub parse_argv: ::std::os::raw::c_int,\n    pub argv: PyWideStringList,\n    pub program_name: *mut wchar_t,\n    pub xoptions: PyWideStringList,\n    pub warnoptions: PyWideStringList,\n    pub site_import: ::std::os::raw::c_int,\n    pub bytes_warning: ::std::os::raw::c_int,\n    pub inspect: ::std::os::raw::c_int,\n    pub interactive: ::std::os::raw::c_int,\n    pub optimization_level: ::std::os::raw::c_int,\n    pub parser_debug: ::std::os::raw::c_int,\n    pub write_bytecode: ::std::os::raw::c_int,\n    pub verbose: ::std::os::raw::c_int,\n    pub quiet: ::std::os::raw::c_int,\n    pub user_site_directory: ::std::os::raw::c_int,\n    pub configure_c_stdio: ::std::os::raw::c_int,\n    pub buffered_stdio: ::std::os::raw::c_int,\n    pub stdio_encoding: *mut wchar_t,\n    pub stdio_errors: *mut wchar_t,\n    pub check_hash_pycs_mode: *mut wchar_t,\n    pub pathconfig_warnings: ::std::os::raw::c_int,\n    pub pythonpath_env: *mut wchar_t,\n    pub home: *mut wchar_t,\n    pub module_search_paths_set: ::std::os::raw::c_int,\n    pub module_search_paths: PyWideStringList,\n    pub executable: *mut wchar_t,\n    pub base_executable: *mut wchar_t,\n    pub prefix: *mut wchar_t,\n    pub base_prefix: *mut wchar_t,\n    pub exec_prefix: *mut wchar_t,\n    pub base_exec_prefix: *mut wchar_t,\n    pub skip_source_first_line: ::std::os::raw::c_int,\n    pub run_command: *mut wchar_t,\n    pub run_module: *mut wchar_t,\n    pub run_filename: *mut wchar_t,\n    pub _install_importlib: ::std::os::raw::c_int,\n    pub _init_main: ::std::os::raw::c_int,\n}\nimpl Default for PyConfig {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _err_stackitem {\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub previous_item: *mut _err_stackitem,\n}\nimpl Default for _err_stackitem {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type _PyErr_StackItem = _err_stackitem;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub prev: *mut _ts,\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub stackcheck_counter: ::std::os::raw::c_int,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_state: _PyErr_StackItem,\n    pub exc_info: *mut _PyErr_StackItem,\n    pub dict: *mut PyObject,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_ulong,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n    pub on_delete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub on_delete_data: *mut ::std::os::raw::c_void,\n    pub coroutine_origin_tracking_depth: ::std::os::raw::c_int,\n    pub async_gen_firstiter: *mut PyObject,\n    pub async_gen_finalizer: *mut PyObject,\n    pub context: *mut PyObject,\n    pub context_ver: u64,\n    pub id: u64,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *const ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *const ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _PyOpcache {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_posonlyargcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut Py_ssize_t,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n    pub co_extra: *mut ::std::os::raw::c_void,\n    pub co_opcache_map: *mut ::std::os::raw::c_uchar,\n    pub co_opcache: *mut _PyOpcache,\n    pub co_opcache_flag: ::std::os::raw::c_int,\n    pub co_opcache_size: ::std::os::raw::c_uchar,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub const _Py_error_handler__Py_ERROR_UNKNOWN: _Py_error_handler = 0;\npub const _Py_error_handler__Py_ERROR_STRICT: _Py_error_handler = 1;\npub const _Py_error_handler__Py_ERROR_SURROGATEESCAPE: _Py_error_handler = 2;\npub const _Py_error_handler__Py_ERROR_REPLACE: _Py_error_handler = 3;\npub const _Py_error_handler__Py_ERROR_IGNORE: _Py_error_handler = 4;\npub const _Py_error_handler__Py_ERROR_BACKSLASHREPLACE: _Py_error_handler = 5;\npub const _Py_error_handler__Py_ERROR_SURROGATEPASS: _Py_error_handler = 6;\npub const _Py_error_handler__Py_ERROR_XMLCHARREFREPLACE: _Py_error_handler = 7;\npub const _Py_error_handler__Py_ERROR_OTHER: _Py_error_handler = 8;\npub type _Py_error_handler = u32;\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_trace_lines: ::std::os::raw::c_char,\n    pub f_trace_opcodes: ::std::os::raw::c_char,\n    pub f_gen: *mut PyObject,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_executing: ::std::os::raw::c_char,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictKeyEntry {\n    pub me_hash: Py_hash_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictKeyEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type dict_lookup_func = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        mp: *mut PyDictObject,\n        key: *mut PyObject,\n        hash: Py_hash_t,\n        value_addr: *mut *mut PyObject,\n    ) -> Py_ssize_t,\n>;\n#[repr(C)]\n#[derive(Debug)]\npub struct _dictkeysobject {\n    pub dk_refcnt: Py_ssize_t,\n    pub dk_size: Py_ssize_t,\n    pub dk_lookup: dict_lookup_func,\n    pub dk_usable: Py_ssize_t,\n    pub dk_nentries: Py_ssize_t,\n    pub dk_indices: __IncompleteArrayField<::std::os::raw::c_char>,\n}\nimpl Default for _dictkeysobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _warnings_runtime_state {\n    pub filters: *mut PyObject,\n    pub once_registry: *mut PyObject,\n    pub default_action: *mut PyObject,\n    pub filters_version: ::std::os::raw::c_long,\n}\nimpl Default for _warnings_runtime_state {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type _PyFrameEvalFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _frame, arg2: ::std::os::raw::c_int) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub id: i64,\n    pub id_refcount: i64,\n    pub requires_idref: ::std::os::raw::c_int,\n    pub id_mutex: PyThread_type_lock,\n    pub finalizing: ::std::os::raw::c_int,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub check_interval: ::std::os::raw::c_int,\n    pub num_threads: ::std::os::raw::c_long,\n    pub pythread_stacksize: usize,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fs_codec: _is__bindgen_ty_1,\n    pub config: PyConfig,\n    pub dlopenflags: ::std::os::raw::c_int,\n    pub dict: *mut PyObject,\n    pub builtins_copy: *mut PyObject,\n    pub import_func: *mut PyObject,\n    pub eval_frame: _PyFrameEvalFunction,\n    pub co_extra_user_count: Py_ssize_t,\n    pub co_extra_freefuncs: [freefunc; 255usize],\n    pub before_forkers: *mut PyObject,\n    pub after_forkers_parent: *mut PyObject,\n    pub after_forkers_child: *mut PyObject,\n    pub pyexitfunc: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>,\n    pub pyexitmodule: *mut PyObject,\n    pub tstate_next_unique_id: u64,\n    pub warnings: _warnings_runtime_state,\n    pub audit_hooks: *mut PyObject,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is__bindgen_ty_1 {\n    pub encoding: *mut ::std::os::raw::c_char,\n    pub errors: *mut ::std::os::raw::c_char,\n    pub error_handler: _Py_error_handler,\n}\nimpl Default for _is__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_4_8.rs": "// Generated bindings for python v3.4.8\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_reserved: *mut ::std::os::raw::c_void,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_ulong,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n    pub tp_finalize: destructor,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = ::std::os::raw::c_uint;\npub type Py_UCS2 = ::std::os::raw::c_ushort;\npub type Py_UCS1 = ::std::os::raw::c_uchar;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fscodec_initialized: ::std::os::raw::c_int,\n    pub dlopenflags: ::std::os::raw::c_int,\n    pub builtins_copy: *mut PyObject,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub prev: *mut _ts,\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub dict: *mut PyObject,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_long,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n    pub on_delete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub on_delete_data: *mut ::std::os::raw::c_void,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *mut ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *mut ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut ::std::os::raw::c_uchar,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_exc_type: *mut PyObject,\n    pub f_exc_value: *mut PyObject,\n    pub f_exc_traceback: *mut PyObject,\n    pub f_gen: *mut PyObject,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_executing: ::std::os::raw::c_char,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct _dictkeysobject {\n    pub _address: u8,\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_6_6.rs": "// Generated bindings for python v3.6.6\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n    pub nb_matrix_multiply: binaryfunc,\n    pub nb_inplace_matrix_multiply: binaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyAsyncMethods {\n    pub am_await: unaryfunc,\n    pub am_aiter: unaryfunc,\n    pub am_anext: unaryfunc,\n}\nimpl Default for PyAsyncMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_as_async: *mut PyAsyncMethods,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_ulong,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n    pub tp_finalize: destructor,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = u32;\npub type Py_UCS2 = u16;\npub type Py_UCS1 = u8;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_version_tag: u64,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type _PyFrameEvalFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _frame, arg2: ::std::os::raw::c_int) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fscodec_initialized: ::std::os::raw::c_int,\n    pub dlopenflags: ::std::os::raw::c_int,\n    pub builtins_copy: *mut PyObject,\n    pub import_func: *mut PyObject,\n    pub eval_frame: _PyFrameEvalFunction,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct _ts {\n    pub prev: *mut _ts,\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub dict: *mut PyObject,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_long,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n    pub on_delete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub on_delete_data: *mut ::std::os::raw::c_void,\n    pub coroutine_wrapper: *mut PyObject,\n    pub in_coroutine_wrapper: ::std::os::raw::c_int,\n    pub _preserve_36_ABI_1: Py_ssize_t,\n    pub _preserve_36_ABI_2: [freefunc; 255usize],\n    pub async_gen_firstiter: *mut PyObject,\n    pub async_gen_finalizer: *mut PyObject,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *mut ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *mut ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut ::std::os::raw::c_uchar,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n    pub co_extra: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_exc_type: *mut PyObject,\n    pub f_exc_value: *mut PyObject,\n    pub f_exc_traceback: *mut PyObject,\n    pub f_gen: *mut PyObject,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_executing: ::std::os::raw::c_char,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictKeyEntry {\n    pub me_hash: Py_hash_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictKeyEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type dict_lookup_func = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        mp: *mut PyDictObject,\n        key: *mut PyObject,\n        hash: Py_hash_t,\n        value_addr: *mut *mut *mut PyObject,\n        hashpos: *mut Py_ssize_t,\n    ) -> Py_ssize_t,\n>;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct _dictkeysobject {\n    pub dk_refcnt: Py_ssize_t,\n    pub dk_size: Py_ssize_t,\n    pub dk_lookup: dict_lookup_func,\n    pub dk_usable: Py_ssize_t,\n    pub dk_nentries: Py_ssize_t,\n    pub dk_indices: _dictkeysobject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union _dictkeysobject__bindgen_ty_1 {\n    pub as_1: [i8; 8usize],\n    pub as_2: [i16; 4usize],\n    pub as_4: [i32; 2usize],\n    pub as_8: [i64; 1usize],\n    _bindgen_union_align: u64,\n}\nimpl Default for _dictkeysobject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for _dictkeysobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v2_7_15.rs": "// Generated bindings for python v2.7.15\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type Py_ssize_t = isize;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type coercion = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut *mut PyObject,\n        arg2: *mut *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizessizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t, arg3: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type ssizessizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: Py_ssize_t,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type readbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut *mut ::std::os::raw::c_void,\n    ) -> Py_ssize_t,\n>;\npub type writebufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut *mut ::std::os::raw::c_void,\n    ) -> Py_ssize_t,\n>;\npub type segcountproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_ssize_t) -> Py_ssize_t,\n>;\npub type charbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut *mut ::std::os::raw::c_char,\n    ) -> Py_ssize_t,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub smalltable: [Py_ssize_t; 2usize],\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_divide: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_nonzero: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_coerce: coercion,\n    pub nb_int: unaryfunc,\n    pub nb_long: unaryfunc,\n    pub nb_float: unaryfunc,\n    pub nb_oct: unaryfunc,\n    pub nb_hex: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_divide: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub sq_slice: ssizessizeargfunc,\n    pub sq_ass_item: ssizeobjargproc,\n    pub sq_ass_slice: ssizessizeobjargproc,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getreadbuffer: readbufferproc,\n    pub bf_getwritebuffer: writebufferproc,\n    pub bf_getsegcount: segcountproc,\n    pub bf_getcharbuffer: charbufferproc,\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type cmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_long>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_compare: cmpfunc,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_long,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyIntObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_ival: ::std::os::raw::c_long,\n}\nimpl Default for PyIntObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    _unused: [u8; 0],\n}\npub type PyLongObject = _longobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyStringObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n    pub ob_shash: ::std::os::raw::c_long,\n    pub ob_sstate: ::std::os::raw::c_int,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyStringObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictEntry {\n    pub me_hash: Py_ssize_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictObject = _dictobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _dictobject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ma_fill: Py_ssize_t,\n    pub ma_used: Py_ssize_t,\n    pub ma_mask: Py_ssize_t,\n    pub ma_table: *mut PyDictEntry,\n    pub ma_lookup: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            mp: *mut PyDictObject,\n            key: *mut PyObject,\n            hash: ::std::os::raw::c_long,\n        ) -> *mut PyDictEntry,\n    >,\n    pub ma_smalltable: [PyDictEntry; 8usize],\n}\nimpl Default for _dictobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *mut ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *mut ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub modules: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub modules_reloading: *mut PyObject,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub dlopenflags: ::std::os::raw::c_int,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub dict: *mut PyObject,\n    pub tick_counter: ::std::os::raw::c_int,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_long,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n    pub ob_size: Py_ssize_t,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_exc_type: *mut PyObject,\n    pub f_exc_value: *mut PyObject,\n    pub f_exc_traceback: *mut PyObject,\n    pub f_tstate: *mut PyThreadState,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyMemberDef {\n    pub _address: u8,\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/src/python_bindings/v3_7_0.rs": "// Generated bindings for python v3.7.0\n#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(clippy::useless_transmute)]\n#![allow(clippy::default_trait_access)]\n#![allow(clippy::cast_lossless)]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\n/* automatically generated by rust-bindgen */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    storage: Storage,\n    align: [Align; 0],\n}\n\nimpl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn new(storage: Storage) -> Self {\n        Self { storage, align: [] }\n    }\n\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        byte & mask == mask\n    }\n\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n\n        let bit_index = index % 8;\n        let mask = 1 << bit_index;\n\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        let mut val = 0;\n\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                val |= 1 << i;\n            }\n        }\n\n        val\n    }\n\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            self.set_bit(i + bit_offset, val_bit_is_set);\n        }\n    }\n}\n#[repr(C)]\n#[derive(Default)]\npub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);\nimpl<T> __IncompleteArrayField<T> {\n    #[inline]\n    pub fn new() -> Self {\n        __IncompleteArrayField(::std::marker::PhantomData)\n    }\n    #[inline]\n    pub unsafe fn as_ptr(&self) -> *const T {\n        ::std::mem::transmute(self)\n    }\n    #[inline]\n    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n        ::std::mem::transmute(self)\n    }\n    #[inline]\n    pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n        ::std::slice::from_raw_parts(self.as_ptr(), len)\n    }\n    #[inline]\n    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n    }\n}\nimpl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {\n    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        fmt.write_str(\"__IncompleteArrayField\")\n    }\n}\nimpl<T> ::std::clone::Clone for __IncompleteArrayField<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self::new()\n    }\n}\nimpl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}\npub type __int64_t = ::std::os::raw::c_longlong;\npub type __darwin_size_t = ::std::os::raw::c_ulong;\npub type __darwin_wchar_t = ::std::os::raw::c_int;\npub type __darwin_ssize_t = ::std::os::raw::c_long;\npub type __darwin_off_t = __int64_t;\npub type fpos_t = __darwin_off_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sbuf {\n    pub _base: *mut ::std::os::raw::c_uchar,\n    pub _size: ::std::os::raw::c_int,\n}\nimpl Default for __sbuf {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILEX {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct __sFILE {\n    pub _p: *mut ::std::os::raw::c_uchar,\n    pub _r: ::std::os::raw::c_int,\n    pub _w: ::std::os::raw::c_int,\n    pub _flags: ::std::os::raw::c_short,\n    pub _file: ::std::os::raw::c_short,\n    pub _bf: __sbuf,\n    pub _lbfsize: ::std::os::raw::c_int,\n    pub _cookie: *mut ::std::os::raw::c_void,\n    pub _close: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub _read: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *mut ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _seek: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: fpos_t,\n            arg3: ::std::os::raw::c_int,\n        ) -> fpos_t,\n    >,\n    pub _write: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: *const ::std::os::raw::c_char,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub _ub: __sbuf,\n    pub _extra: *mut __sFILEX,\n    pub _ur: ::std::os::raw::c_int,\n    pub _ubuf: [::std::os::raw::c_uchar; 3usize],\n    pub _nbuf: [::std::os::raw::c_uchar; 1usize],\n    pub _lb: __sbuf,\n    pub _blksize: ::std::os::raw::c_int,\n    pub _offset: fpos_t,\n}\nimpl Default for __sFILE {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type FILE = __sFILE;\npub type wchar_t = __darwin_wchar_t;\npub type Py_ssize_t = isize;\npub type Py_hash_t = Py_ssize_t;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _object {\n    pub ob_refcnt: Py_ssize_t,\n    pub ob_type: *mut _typeobject,\n}\nimpl Default for _object {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyObject = _object;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyVarObject {\n    pub ob_base: PyObject,\n    pub ob_size: Py_ssize_t,\n}\nimpl Default for PyVarObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type unaryfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type binaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type ternaryfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type inquiry =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> ::std::os::raw::c_int>;\npub type lenfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_ssize_t>;\npub type ssizeargfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\npub type ssizeobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: Py_ssize_t,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type objobjargproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct bufferinfo {\n    pub buf: *mut ::std::os::raw::c_void,\n    pub obj: *mut PyObject,\n    pub len: Py_ssize_t,\n    pub itemsize: Py_ssize_t,\n    pub readonly: ::std::os::raw::c_int,\n    pub ndim: ::std::os::raw::c_int,\n    pub format: *mut ::std::os::raw::c_char,\n    pub shape: *mut Py_ssize_t,\n    pub strides: *mut Py_ssize_t,\n    pub suboffsets: *mut Py_ssize_t,\n    pub internal: *mut ::std::os::raw::c_void,\n}\nimpl Default for bufferinfo {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_buffer = bufferinfo;\npub type getbufferproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut Py_buffer,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type releasebufferproc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut Py_buffer)>;\npub type objobjproc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> ::std::os::raw::c_int,\n>;\npub type visitproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\npub type traverseproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: visitproc,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyNumberMethods {\n    pub nb_add: binaryfunc,\n    pub nb_subtract: binaryfunc,\n    pub nb_multiply: binaryfunc,\n    pub nb_remainder: binaryfunc,\n    pub nb_divmod: binaryfunc,\n    pub nb_power: ternaryfunc,\n    pub nb_negative: unaryfunc,\n    pub nb_positive: unaryfunc,\n    pub nb_absolute: unaryfunc,\n    pub nb_bool: inquiry,\n    pub nb_invert: unaryfunc,\n    pub nb_lshift: binaryfunc,\n    pub nb_rshift: binaryfunc,\n    pub nb_and: binaryfunc,\n    pub nb_xor: binaryfunc,\n    pub nb_or: binaryfunc,\n    pub nb_int: unaryfunc,\n    pub nb_reserved: *mut ::std::os::raw::c_void,\n    pub nb_float: unaryfunc,\n    pub nb_inplace_add: binaryfunc,\n    pub nb_inplace_subtract: binaryfunc,\n    pub nb_inplace_multiply: binaryfunc,\n    pub nb_inplace_remainder: binaryfunc,\n    pub nb_inplace_power: ternaryfunc,\n    pub nb_inplace_lshift: binaryfunc,\n    pub nb_inplace_rshift: binaryfunc,\n    pub nb_inplace_and: binaryfunc,\n    pub nb_inplace_xor: binaryfunc,\n    pub nb_inplace_or: binaryfunc,\n    pub nb_floor_divide: binaryfunc,\n    pub nb_true_divide: binaryfunc,\n    pub nb_inplace_floor_divide: binaryfunc,\n    pub nb_inplace_true_divide: binaryfunc,\n    pub nb_index: unaryfunc,\n    pub nb_matrix_multiply: binaryfunc,\n    pub nb_inplace_matrix_multiply: binaryfunc,\n}\nimpl Default for PyNumberMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PySequenceMethods {\n    pub sq_length: lenfunc,\n    pub sq_concat: binaryfunc,\n    pub sq_repeat: ssizeargfunc,\n    pub sq_item: ssizeargfunc,\n    pub was_sq_slice: *mut ::std::os::raw::c_void,\n    pub sq_ass_item: ssizeobjargproc,\n    pub was_sq_ass_slice: *mut ::std::os::raw::c_void,\n    pub sq_contains: objobjproc,\n    pub sq_inplace_concat: binaryfunc,\n    pub sq_inplace_repeat: ssizeargfunc,\n}\nimpl Default for PySequenceMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMappingMethods {\n    pub mp_length: lenfunc,\n    pub mp_subscript: binaryfunc,\n    pub mp_ass_subscript: objobjargproc,\n}\nimpl Default for PyMappingMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyAsyncMethods {\n    pub am_await: unaryfunc,\n    pub am_aiter: unaryfunc,\n    pub am_anext: unaryfunc,\n}\nimpl Default for PyAsyncMethods {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBufferProcs {\n    pub bf_getbuffer: getbufferproc,\n    pub bf_releasebuffer: releasebufferproc,\n}\nimpl Default for PyBufferProcs {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type freefunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\npub type destructor = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>;\npub type printfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut FILE,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int,\n>;\npub type getattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_char) -> *mut PyObject,\n>;\npub type getattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\npub type setattrfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type setattrofunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type reprfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type hashfunc = ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> Py_hash_t>;\npub type richcmpfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: ::std::os::raw::c_int,\n    ) -> *mut PyObject,\n>;\npub type getiterfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type iternextfunc =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject) -> *mut PyObject>;\npub type descrgetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type descrsetfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type initproc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\npub type newfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut _typeobject,\n        arg2: *mut PyObject,\n        arg3: *mut PyObject,\n    ) -> *mut PyObject,\n>;\npub type allocfunc = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _typeobject, arg2: Py_ssize_t) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _typeobject {\n    pub ob_base: PyVarObject,\n    pub tp_name: *const ::std::os::raw::c_char,\n    pub tp_basicsize: Py_ssize_t,\n    pub tp_itemsize: Py_ssize_t,\n    pub tp_dealloc: destructor,\n    pub tp_print: printfunc,\n    pub tp_getattr: getattrfunc,\n    pub tp_setattr: setattrfunc,\n    pub tp_as_async: *mut PyAsyncMethods,\n    pub tp_repr: reprfunc,\n    pub tp_as_number: *mut PyNumberMethods,\n    pub tp_as_sequence: *mut PySequenceMethods,\n    pub tp_as_mapping: *mut PyMappingMethods,\n    pub tp_hash: hashfunc,\n    pub tp_call: ternaryfunc,\n    pub tp_str: reprfunc,\n    pub tp_getattro: getattrofunc,\n    pub tp_setattro: setattrofunc,\n    pub tp_as_buffer: *mut PyBufferProcs,\n    pub tp_flags: ::std::os::raw::c_ulong,\n    pub tp_doc: *const ::std::os::raw::c_char,\n    pub tp_traverse: traverseproc,\n    pub tp_clear: inquiry,\n    pub tp_richcompare: richcmpfunc,\n    pub tp_weaklistoffset: Py_ssize_t,\n    pub tp_iter: getiterfunc,\n    pub tp_iternext: iternextfunc,\n    pub tp_methods: *mut PyMethodDef,\n    pub tp_members: *mut PyMemberDef,\n    pub tp_getset: *mut PyGetSetDef,\n    pub tp_base: *mut _typeobject,\n    pub tp_dict: *mut PyObject,\n    pub tp_descr_get: descrgetfunc,\n    pub tp_descr_set: descrsetfunc,\n    pub tp_dictoffset: Py_ssize_t,\n    pub tp_init: initproc,\n    pub tp_alloc: allocfunc,\n    pub tp_new: newfunc,\n    pub tp_free: freefunc,\n    pub tp_is_gc: inquiry,\n    pub tp_bases: *mut PyObject,\n    pub tp_mro: *mut PyObject,\n    pub tp_cache: *mut PyObject,\n    pub tp_subclasses: *mut PyObject,\n    pub tp_weaklist: *mut PyObject,\n    pub tp_del: destructor,\n    pub tp_version_tag: ::std::os::raw::c_uint,\n    pub tp_finalize: destructor,\n}\nimpl Default for _typeobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyTypeObject = _typeobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyBytesObject {\n    pub ob_base: PyVarObject,\n    pub ob_shash: Py_hash_t,\n    pub ob_sval: [::std::os::raw::c_char; 1usize],\n}\nimpl Default for PyBytesObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type Py_UCS4 = u32;\npub type Py_UCS2 = u16;\npub type Py_UCS1 = u8;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyASCIIObject {\n    pub ob_base: PyObject,\n    pub length: Py_ssize_t,\n    pub hash: Py_hash_t,\n    pub state: PyASCIIObject__bindgen_ty_1,\n    pub wstr: *mut wchar_t,\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyASCIIObject__bindgen_ty_1 {\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,\n    pub __bindgen_align: [u32; 0usize],\n}\nimpl PyASCIIObject__bindgen_ty_1 {\n    #[inline]\n    pub fn interned(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }\n    }\n    #[inline]\n    pub fn set_interned(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(0usize, 2u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn kind(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }\n    }\n    #[inline]\n    pub fn set_kind(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(2usize, 3u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn compact(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_compact(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(5usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ascii(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ascii(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(6usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn ready(&self) -> ::std::os::raw::c_uint {\n        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }\n    }\n    #[inline]\n    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {\n        unsafe {\n            let val: u32 = ::std::mem::transmute(val);\n            self._bitfield_1.set(7usize, 1u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(\n        interned: ::std::os::raw::c_uint,\n        kind: ::std::os::raw::c_uint,\n        compact: ::std::os::raw::c_uint,\n        ascii: ::std::os::raw::c_uint,\n        ready: ::std::os::raw::c_uint,\n    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =\n            Default::default();\n        __bindgen_bitfield_unit.set(0usize, 2u8, {\n            let interned: u32 = unsafe { ::std::mem::transmute(interned) };\n            interned as u64\n        });\n        __bindgen_bitfield_unit.set(2usize, 3u8, {\n            let kind: u32 = unsafe { ::std::mem::transmute(kind) };\n            kind as u64\n        });\n        __bindgen_bitfield_unit.set(5usize, 1u8, {\n            let compact: u32 = unsafe { ::std::mem::transmute(compact) };\n            compact as u64\n        });\n        __bindgen_bitfield_unit.set(6usize, 1u8, {\n            let ascii: u32 = unsafe { ::std::mem::transmute(ascii) };\n            ascii as u64\n        });\n        __bindgen_bitfield_unit.set(7usize, 1u8, {\n            let ready: u32 = unsafe { ::std::mem::transmute(ready) };\n            ready as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\nimpl Default for PyASCIIObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCompactUnicodeObject {\n    pub _base: PyASCIIObject,\n    pub utf8_length: Py_ssize_t,\n    pub utf8: *mut ::std::os::raw::c_char,\n    pub wstr_length: Py_ssize_t,\n}\nimpl Default for PyCompactUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct PyUnicodeObject {\n    pub _base: PyCompactUnicodeObject,\n    pub data: PyUnicodeObject__bindgen_ty_1,\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union PyUnicodeObject__bindgen_ty_1 {\n    pub any: *mut ::std::os::raw::c_void,\n    pub latin1: *mut Py_UCS1,\n    pub ucs2: *mut Py_UCS2,\n    pub ucs4: *mut Py_UCS4,\n    _bindgen_union_align: u64,\n}\nimpl Default for PyUnicodeObject__bindgen_ty_1 {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\nimpl Default for PyUnicodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyLongObject = _longobject;\npub type digit = u32;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _longobject {\n    pub ob_base: PyVarObject,\n    pub ob_digit: [digit; 1usize],\n}\nimpl Default for _longobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyFloatObject {\n    pub ob_base: PyObject,\n    pub ob_fval: f64,\n}\nimpl Default for PyFloatObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyTupleObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: [*mut PyObject; 1usize],\n}\nimpl Default for PyTupleObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyListObject {\n    pub ob_base: PyVarObject,\n    pub ob_item: *mut *mut PyObject,\n    pub allocated: Py_ssize_t,\n}\nimpl Default for PyListObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyDictKeysObject = _dictkeysobject;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictObject {\n    pub ob_base: PyObject,\n    pub ma_used: Py_ssize_t,\n    pub ma_version_tag: u64,\n    pub ma_keys: *mut PyDictKeysObject,\n    pub ma_values: *mut *mut PyObject,\n}\nimpl Default for PyDictObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyCFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut PyObject) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMethodDef {\n    pub ml_name: *const ::std::os::raw::c_char,\n    pub ml_meth: PyCFunction,\n    pub ml_flags: ::std::os::raw::c_int,\n    pub ml_doc: *const ::std::os::raw::c_char,\n}\nimpl Default for PyMethodDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThread_type_lock = *mut ::std::os::raw::c_void;\npub type _PyFrameEvalFunction = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut _frame, arg2: ::std::os::raw::c_int) -> *mut PyObject,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _PyCoreConfig {\n    pub install_signal_handlers: ::std::os::raw::c_int,\n    pub ignore_environment: ::std::os::raw::c_int,\n    pub use_hash_seed: ::std::os::raw::c_int,\n    pub hash_seed: ::std::os::raw::c_ulong,\n    pub allocator: *const ::std::os::raw::c_char,\n    pub dev_mode: ::std::os::raw::c_int,\n    pub faulthandler: ::std::os::raw::c_int,\n    pub tracemalloc: ::std::os::raw::c_int,\n    pub import_time: ::std::os::raw::c_int,\n    pub show_ref_count: ::std::os::raw::c_int,\n    pub show_alloc_count: ::std::os::raw::c_int,\n    pub dump_refs: ::std::os::raw::c_int,\n    pub malloc_stats: ::std::os::raw::c_int,\n    pub coerce_c_locale: ::std::os::raw::c_int,\n    pub coerce_c_locale_warn: ::std::os::raw::c_int,\n    pub utf8_mode: ::std::os::raw::c_int,\n    pub program_name: *mut wchar_t,\n    pub argc: ::std::os::raw::c_int,\n    pub argv: *mut *mut wchar_t,\n    pub program: *mut wchar_t,\n    pub nxoption: ::std::os::raw::c_int,\n    pub xoptions: *mut *mut wchar_t,\n    pub nwarnoption: ::std::os::raw::c_int,\n    pub warnoptions: *mut *mut wchar_t,\n    pub module_search_path_env: *mut wchar_t,\n    pub home: *mut wchar_t,\n    pub nmodule_search_path: ::std::os::raw::c_int,\n    pub module_search_paths: *mut *mut wchar_t,\n    pub executable: *mut wchar_t,\n    pub prefix: *mut wchar_t,\n    pub base_prefix: *mut wchar_t,\n    pub exec_prefix: *mut wchar_t,\n    pub base_exec_prefix: *mut wchar_t,\n    pub _disable_importlib: ::std::os::raw::c_int,\n}\nimpl Default for _PyCoreConfig {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _PyMainInterpreterConfig {\n    pub install_signal_handlers: ::std::os::raw::c_int,\n    pub argv: *mut PyObject,\n    pub executable: *mut PyObject,\n    pub prefix: *mut PyObject,\n    pub base_prefix: *mut PyObject,\n    pub exec_prefix: *mut PyObject,\n    pub base_exec_prefix: *mut PyObject,\n    pub warnoptions: *mut PyObject,\n    pub xoptions: *mut PyObject,\n    pub module_search_path: *mut PyObject,\n}\nimpl Default for _PyMainInterpreterConfig {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct _is {\n    pub next: *mut _is,\n    pub tstate_head: *mut _ts,\n    pub id: i64,\n    pub id_refcount: i64,\n    pub id_mutex: PyThread_type_lock,\n    pub modules: *mut PyObject,\n    pub modules_by_index: *mut PyObject,\n    pub sysdict: *mut PyObject,\n    pub builtins: *mut PyObject,\n    pub importlib: *mut PyObject,\n    pub check_interval: ::std::os::raw::c_int,\n    pub num_threads: ::std::os::raw::c_long,\n    pub pythread_stacksize: usize,\n    pub codec_search_path: *mut PyObject,\n    pub codec_search_cache: *mut PyObject,\n    pub codec_error_registry: *mut PyObject,\n    pub codecs_initialized: ::std::os::raw::c_int,\n    pub fscodec_initialized: ::std::os::raw::c_int,\n    pub core_config: _PyCoreConfig,\n    pub config: _PyMainInterpreterConfig,\n    pub dlopenflags: ::std::os::raw::c_int,\n    pub builtins_copy: *mut PyObject,\n    pub import_func: *mut PyObject,\n    pub eval_frame: _PyFrameEvalFunction,\n    pub co_extra_user_count: Py_ssize_t,\n    pub co_extra_freefuncs: [freefunc; 255usize],\n    pub before_forkers: *mut PyObject,\n    pub after_forkers_parent: *mut PyObject,\n    pub after_forkers_child: *mut PyObject,\n    pub pyexitfunc: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut PyObject)>,\n    pub pyexitmodule: *mut PyObject,\n    pub tstate_next_unique_id: u64,\n}\nimpl Default for _is {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyInterpreterState = _is;\npub type Py_tracefunc = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut _frame,\n        arg3: ::std::os::raw::c_int,\n        arg4: *mut PyObject,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _err_stackitem {\n    pub exc_type: *mut PyObject,\n    pub exc_value: *mut PyObject,\n    pub exc_traceback: *mut PyObject,\n    pub previous_item: *mut _err_stackitem,\n}\nimpl Default for _err_stackitem {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type _PyErr_StackItem = _err_stackitem;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _ts {\n    pub prev: *mut _ts,\n    pub next: *mut _ts,\n    pub interp: *mut PyInterpreterState,\n    pub frame: *mut _frame,\n    pub recursion_depth: ::std::os::raw::c_int,\n    pub overflowed: ::std::os::raw::c_char,\n    pub recursion_critical: ::std::os::raw::c_char,\n    pub stackcheck_counter: ::std::os::raw::c_int,\n    pub tracing: ::std::os::raw::c_int,\n    pub use_tracing: ::std::os::raw::c_int,\n    pub c_profilefunc: Py_tracefunc,\n    pub c_tracefunc: Py_tracefunc,\n    pub c_profileobj: *mut PyObject,\n    pub c_traceobj: *mut PyObject,\n    pub curexc_type: *mut PyObject,\n    pub curexc_value: *mut PyObject,\n    pub curexc_traceback: *mut PyObject,\n    pub exc_state: _PyErr_StackItem,\n    pub exc_info: *mut _PyErr_StackItem,\n    pub dict: *mut PyObject,\n    pub gilstate_counter: ::std::os::raw::c_int,\n    pub async_exc: *mut PyObject,\n    pub thread_id: ::std::os::raw::c_ulong,\n    pub trash_delete_nesting: ::std::os::raw::c_int,\n    pub trash_delete_later: *mut PyObject,\n    pub on_delete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub on_delete_data: *mut ::std::os::raw::c_void,\n    pub coroutine_origin_tracking_depth: ::std::os::raw::c_int,\n    pub coroutine_wrapper: *mut PyObject,\n    pub in_coroutine_wrapper: ::std::os::raw::c_int,\n    pub async_gen_firstiter: *mut PyObject,\n    pub async_gen_finalizer: *mut PyObject,\n    pub context: *mut PyObject,\n    pub context_ver: u64,\n    pub id: u64,\n}\nimpl Default for _ts {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyThreadState = _ts;\npub type getter = ::std::option::Option<\n    unsafe extern \"C\" fn(arg1: *mut PyObject, arg2: *mut ::std::os::raw::c_void) -> *mut PyObject,\n>;\npub type setter = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut PyObject,\n        arg2: *mut PyObject,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int,\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyGetSetDef {\n    pub name: *const ::std::os::raw::c_char,\n    pub get: getter,\n    pub set: setter,\n    pub doc: *const ::std::os::raw::c_char,\n    pub closure: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyGetSetDef {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyMemberDef {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyCodeObject {\n    pub ob_base: PyObject,\n    pub co_argcount: ::std::os::raw::c_int,\n    pub co_kwonlyargcount: ::std::os::raw::c_int,\n    pub co_nlocals: ::std::os::raw::c_int,\n    pub co_stacksize: ::std::os::raw::c_int,\n    pub co_flags: ::std::os::raw::c_int,\n    pub co_firstlineno: ::std::os::raw::c_int,\n    pub co_code: *mut PyObject,\n    pub co_consts: *mut PyObject,\n    pub co_names: *mut PyObject,\n    pub co_varnames: *mut PyObject,\n    pub co_freevars: *mut PyObject,\n    pub co_cellvars: *mut PyObject,\n    pub co_cell2arg: *mut Py_ssize_t,\n    pub co_filename: *mut PyObject,\n    pub co_name: *mut PyObject,\n    pub co_lnotab: *mut PyObject,\n    pub co_zombieframe: *mut ::std::os::raw::c_void,\n    pub co_weakreflist: *mut PyObject,\n    pub co_extra: *mut ::std::os::raw::c_void,\n}\nimpl Default for PyCodeObject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n#[repr(C)]\n#[derive(Debug, Default, Copy, Clone)]\npub struct PyTryBlock {\n    pub b_type: ::std::os::raw::c_int,\n    pub b_handler: ::std::os::raw::c_int,\n    pub b_level: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct _frame {\n    pub ob_base: PyVarObject,\n    pub f_back: *mut _frame,\n    pub f_code: *mut PyCodeObject,\n    pub f_builtins: *mut PyObject,\n    pub f_globals: *mut PyObject,\n    pub f_locals: *mut PyObject,\n    pub f_valuestack: *mut *mut PyObject,\n    pub f_stacktop: *mut *mut PyObject,\n    pub f_trace: *mut PyObject,\n    pub f_trace_lines: ::std::os::raw::c_char,\n    pub f_trace_opcodes: ::std::os::raw::c_char,\n    pub f_gen: *mut PyObject,\n    pub f_lasti: ::std::os::raw::c_int,\n    pub f_lineno: ::std::os::raw::c_int,\n    pub f_iblock: ::std::os::raw::c_int,\n    pub f_executing: ::std::os::raw::c_char,\n    pub f_blockstack: [PyTryBlock; 20usize],\n    pub f_localsplus: [*mut PyObject; 1usize],\n}\nimpl Default for _frame {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type PyFrameObject = _frame;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct PyDictKeyEntry {\n    pub me_hash: Py_hash_t,\n    pub me_key: *mut PyObject,\n    pub me_value: *mut PyObject,\n}\nimpl Default for PyDictKeyEntry {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\npub type dict_lookup_func = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        mp: *mut PyDictObject,\n        key: *mut PyObject,\n        hash: Py_hash_t,\n        value_addr: *mut *mut PyObject,\n    ) -> Py_ssize_t,\n>;\n#[repr(C)]\n#[derive(Debug)]\npub struct _dictkeysobject {\n    pub dk_refcnt: Py_ssize_t,\n    pub dk_size: Py_ssize_t,\n    pub dk_lookup: dict_lookup_func,\n    pub dk_usable: Py_ssize_t,\n    pub dk_nentries: Py_ssize_t,\n    pub dk_indices: __IncompleteArrayField<::std::os::raw::c_char>,\n}\nimpl Default for _dictkeysobject {\n    fn default() -> Self {\n        unsafe { ::std::mem::zeroed() }\n    }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/images/dump.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-py-spy-0.3.3-p77jw6wrd73jrb5wsts6gp52xun3bu47/spack-src/images/console_viewer.gif"
    ],
    "total_files": 62
}