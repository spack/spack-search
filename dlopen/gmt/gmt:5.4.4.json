{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/src/gmt_api.c": "/*--------------------------------------------------------------------\n *\t$Id$\n *\n *\tCopyright (c) 1991-2018 by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe\n *\tSee LICENSE.TXT file for copying and redistribution conditions.\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU Lesser General Public License as published by\n *\tthe Free Software Foundation; version 3 or any later version.\n *\n *\tThis program is distributed in the hope that it will be useful,\n *\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n *\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\tGNU Lesser General Public License for more details.\n *\n *\tContact info: gmt.soest.hawaii.edu\n *--------------------------------------------------------------------*/\n/*\n * Public functions for the GMT C/C++ API.  The API consist of functions\n * in gmt_api.c, gmt_parse.c, and all the GMT modules; see gmt.h for list.\n *\n * Author: \tPaul Wessel\n * Date:\t1-JUN-2013\n * Version:\t5\n *\n * The API presently consists of 66 documented functions.  For a full\n * description of the API, see the GMT_API documentation.\n * These functions have Fortran bindings as well, provided you add\n * -DFORTRAN_API to the C preprocessor flags [in ConfigUser.cmake].\n *\n * There are 2 public functions used for GMT API session handling.\n * This part of the API helps the developer create and delete GMT sessions:\n *\n * GMT_Create_Session\t  : Initialize a new GMT session\n * GMT_Destroy_Session\t  : Destroy a GMT session\n *\n * There is 2 public functions for common error reporting.\n * Errors will be reported to stderr or selected log file:\n *\n * GMT_Message\t\t      : Report an message given a verbosity level\n * GMT_Report\t\t      : Report an error given an error code\n *\n * There are 27 further public functions used for GMT i/o activities:\n *\n * GMT_Alloc_Segment      : Allocate a single DATASET or TEXTSET segment\n * GMT_Begin_IO\t\t      : Allow i/o to take place for rec-by-rec operations\n * GMT_Convert_Data       : Convert between different data sets, if possible\n * GMT_Create_Data\t      : Return an empty container for a new data set\n * GMT_Destroy_Data\t      : Destroy a data set and its container\n * GMT_Duplicate_Data     : Make an exact duplicate of a dataset\n * GMT_Duplicate_String   : Allocates a copy of a string to be freed by API\n * GMT_End_IO\t\t      : Disallow further rec-by-rec i/o\n * GMT_Get_Record\t      : Get the next single data record from the source(s)\n * GMT_Get_Row\t\t      : Read one row from a grid\n * GMT_Get_Matrix\t      : Get user matrix from GMT_MATRIX array\n * GMT_Get_Vector\t      : Get user vector from GMT_VECTOR column\n * GMT_Init_IO\t\t      : Initialize rec-by-rec i/o machinery before program use\n * GMT_Init_VirtualFile   : Reset a virtual file for reuse\n * GMT_Open_VirtualFile   : Open a memory location for reading or writing by a module\n * GMT_Put_Record\t      : Send the next output record to its destination\n * GMT_Put_Row\t\t      : Write one row to a grid\n * GMT_Put_Matrix\t      : Hook user matrix to GMT_MATRIX array\n * GMT_Put_Vector\t      : Hook user vector to GMT_VECTOR column\n * GMT_Read_Data\t      : Load data into program memory from selected source\n * GMT_Read_Group\t      : Read numerous files into an array of objects\n * GMT_Read_VirtualFile   : Obtain the memory resource that a module wrote to.\n * GMT_Register_IO\t      : Register a source (or destination) for i/o use\n * GMT_Set_Comment\t      : Update a comment for a data set\n * GMT_Status_IO\t      : Exmine current status of record-by-record i/o\n * GMT_Write_Data\t      : Place data set from program memory to selected destination\n * GMT_Encode_Options\t  : Used by external APIs to fill out options from implicit rules\n\n * The above 28 functions deal with registration of input sources (files,\n * streams, file handles, or memory locations) and output destinations\n * (same flavors as input), the setup of the i/o, and generic functions\n * to access the data either in one go (GMT_Get|Put_Data) or on a\n * record-by-record basis (GMT_Get|Put_Record).  Finally, data sets that\n * are allocated can then be destroyed when no longer needed.\n *\n * There are 5 functions that deal with options, defaults and arguments:\n *\n * GMT_Get_Common\t      : Checks for and returns values for GMT common options\n * GMT_Get_Default\t      : Return the value of a GMT parameter as a string\n * GMT_Get_Values\t      : Convert string to one or more coordinates or dimensions\n * GMT_Set_Default\t      : Set a GMT parameter via a strings\n * GMT_Option\t\t      : Display syntax for one or more GMT common options\n *\n * One function handles the listing of modules and the calling of any GMT module:\n *\n * GMT_Call_Module\t: Call the specified GMT module\n *\n * Four functions are used to get grid index from row, col, and to obtain coordinates\n *\n * GMT_Get_Coord\t      : Return array of coordinates for one dimension\n * GMT_Get_Index\t      : Return 1-D grid index given row, col\n * GMT_Get_Pixel\t      : Return 1-D image index given row, col, layer\n * GMT_Set_Columns        : Specify number of output columns for rec-by-rec writing\n *\n * For FFT operations there are 8 additional API functions:\n *\n * GMT_FFT\t\t          : Call the forward or inverse FFT\n * GMT_FFT_1D\t\t      : Lower-level 1-D FFT call\n * GMT_FFT_2D\t\t      : Lower-level 2-D FFT call\n * GMT_FFT_Create\t      : Initialize the FFT machinery for given dimension\n * GMT_FFT_Destroy\t      : Destroy FFT machinery\n * GMT_FFT_Option\t      : Display the syntax of the GMT FFT option settings\n * GMT_FFT_Parse\t      : Parse the GMT FFT option\n * GMT_FFT_Wavenumber\t  : Return selected wavenumber given its type\n *\n * There are also 13 functions for argument and option parsing.  See gmt_parse.c for these.\n *\n * Finally, three low-level F77-callable functions for grid i/o are given:\n *\n * gmt_f77_readgrdinfo_\t  : Read the header of a GMT grid\n * gmt_f77_readgrd_\t\t  : Read a GMT grid from file\n * gmt_f77_writegrd_\t  : Write a GMT grid to file\n *\n * --------------------------------------------------------------------------------------------\n * Guru notes on memory management: Paul Wessel, June 2013.\n *\n * GMT maintains control over allocating, reallocating, and freeing of GMT objects created by GMT.\n * Because GMT_modules may be given files, memory locations, streams, etc., as input and output we\n * have to impose some structure as how this will work seamlessly.  Here, \"GMT object\" refers to\n * any of the 5 GMT resources: grids, images, datasets, textsets, and palettes.\n *\n * 1. When GMT allocates memory for a GMT object it sets its alloc_mode to GMT_ALLOC_INTERNALLY (1)\n *    and its alloc_level to <module level>.  This is 0 for the gmt.c UNIX application as well as\n *    for any external API (MEX, Python, Julia), 1 for any GMT module called, 2 for modules called\n *    by top-level modules, etc., as far down as the thread goes.\n * 2. Memory not allocated by GMT will have an implicit alloc_mode = GMT_ALLOC_EXTERNALLY [0]\n *    and alloc_level = 0 (i.e., gmt executable or API level) but it does not matter since such memory is\n *    only used for reading and we may never free it or reallocate it within GMT. This alloc_mode\n *    only applies to data arrays inside objects (e.g., G->data), not the GMT objects themselves.\n *    The GMT objects (the \"containers\") are freed at the end of their level, if not before.\n * 3. Memory passed into modules as \"input file\" requires no special treatment since its level\n *    will be lower than that of the module it is used in, and when that module tries to free it\n *    (directly with GMT_Destroy_Data or via end-of-module gmtapi_garbage_collection) it will skip\n *    it as its level does not match the current module level.  A module can only free memory that\n *    it allocated; the exception is the top-level gmt application.\n * 4. Passing memory out of a module (i.e., \"writing to memory\") requires that the calling function\n *    first create an output object and use the ID to encode the memory filename (@GMTAPI@-######).\n *    The object stores the level it was called at.  Pass the encoded filename as the output file.\n *    When GMT_Create_Data is called with no dimensions then the direction is set to GMT_OUT and\n *    we set the object's messenger flag to true.  This is used so that when the dataset we wish to\n *    return out of a module is built it replaces the empty initial dataset but inherits that dataset's\n *    alloc_level so it may survive the life of the module process.\n *    Internally, the memory that the module allocates (e.g., grid, dataset, etc.) will initially\n *    have an alloc_level matching the module level (and would be freed if written to a regular\n *    file).  However, when GMT_Write_Data is called and we branch into the GMT_REFERENCE case we\n *    instead take the following steps:\n *\ta) The registered output API->object's data pointer is set to the GMT object that the\n *         module allocated (this is how we pass the data out of a module).\n *\tb) The GMT object's alloc_level is changed to equal the output API->object's level (this\n *         is how it will survive beyond the end of the module).\n *\tc) The API object originally pointing to the GMT object is flagged by having its variable\n *         no_longer_owner set to true (this is how we avoid freeing something twice). [PW: Why not just set it to NULL]\n *    When the module ends there are two API objects with references to the GMT object: the internal\n *    module object and the output object.  The first is set to NULL by gmtapi_garbage_collection because\n *    the object is no longer the owner of the data. The second is ignored because its level is too low.\n *    After that any empty API objects are removed (so the no_longer_owner one is removed), while\n *    the second survives the life of the module, as we require.\n *\n * Thus, at the session (gmt) level all GMT objects have alloc_level = 0 since anything higher will\n * have been freed by a module.  GMT_Destroy_Session finally calls gmtapi_garbage_collection a final\n * time and he frees any remaining GMT objects.\n *\n * Notes on family vs actual_family:\n * The S->actual_family contains the object type that we allocated.  However, we allow modules\n * that expect a DATASET to insted be passed a GMT_VECTOR or GMT_MATRIX.  If so then S->family\n * will be GMT_IS_DATASET while the actual_family remains GMT_VECTOR|GMT_MATRIX.  The i/o functions\n * GMT_Read_Data, GMT_Put_Record, etc knows how to deal with this.\n */\n\n/*!\n * \\file gmt_api.c\n * \\brief Public functions for the GMT C/C++ API.\n */\n\n#include \"gmt_dev.h\"\n#include \"gmt_internals.h\"\n#include \"gmt_sharedlibs.h\" \t/* Common shared libs structures */\n#include <stdarg.h>\n#include <curl/curl.h>\n\n#ifdef HAVE_DIRENT_H_\n#\tinclude <dirent.h>\n#endif\n\n#ifdef HAVE_SYS_DIR_H_\n#\tinclude <sys/dir.h>\n#endif\n\n/* Possibly define missing shared library constants */\n#ifndef DT_DIR\n#\tdefine DT_DIR 4\n#endif\n\n#ifndef RTLD_LAZY\n#\tdefine RTLD_LAZY 1\n#endif\n\n#ifdef WIN32\t/* Special for Windows */\n#\tinclude <process.h>\n#\tdefine getpid _getpid\n#endif\n\n/* extern functions from various gmt_* only used here */\nEXTERN_MSC void gmtfft_fourt_stats (struct GMT_CTRL *GMT, unsigned int n_columns, unsigned int n_rows, unsigned int *f, double *r, size_t *s, double *t);\nEXTERN_MSC unsigned int gmtgrdio_free_grid_ptr (struct GMT_CTRL *GMT, struct GMT_GRID *G, bool free_grid);\nEXTERN_MSC int gmtgrdio_init_grdheader (struct GMT_CTRL *GMT, unsigned int direction, struct GMT_GRID_HEADER *header, struct GMT_OPTION *options, uint64_t dim[], double wesn[], double inc[], unsigned int registration, unsigned int mode);\n\n#define GMTAPI_MAX_ID 999999\t/* Largest integer that will fit in the %06d format */\n#define GMTAPI_UNLIMITED\t0\t/* Using 0 to mean we may allow 1 or more data objects of this family */\n\n#ifdef FORTRAN_API\n/* Global structure pointer needed for FORTRAN-77 [PW: not tested yet - is it even needed?] */\nstatic struct GMTAPI_CTRL *GMT_FORTRAN = NULL;\n#endif\n\nstatic int GMTAPI_session_counter = 0;\t/* Keeps track of the ID of new sessions for multi-session programs */\n\n/*! Macros that report error, then return a NULL pointer, the error, or a value, respectively */\n#define return_null(API,err) { gmtapi_report_error(API,err); return (NULL);}\n#define return_error(API,err) { gmtapi_report_error(API,err); return (err);}\n#define return_value(API,err,val) { gmtapi_report_error(API,err); return (val);}\n\n/* We asked for subset of grid if the wesn pointer is not NULL and indicates a nonzero region */\n#define full_region(wesn) (!wesn || (wesn[XLO] == wesn[XHI] && wesn[YLO] == wesn[YHI]))\n\n/* DATASET and TEXTSET can be given via many individual files. */\n#define multiple_files_ok(family) (family == GMT_IS_DATASET || family == GMT_IS_TEXTSET)\n\n/* Misc. local text strings needed in this file only, used when debug verbose is on (-Vd).\n * NOTE: THe order of these depends on the order in the enums in gmt_resources.h! */\n\nstatic const char *GMT_method[] = {\"File\", \"Stream\", \"File Descriptor\", \"Memory Copy\", \"Memory Reference\"};\nstatic const char *GMT_family[] = {\"Data Table\", \"GMT Grid\", \"GMT Image\", \"CPT\", \"GMT PostScript\", \"Text Table\", \"GMT Matrix\", \"GMT Vector\", \"GMT Coord\"};\nstatic const char *GMT_direction[] = {\"Input\", \"Output\"};\nstatic const char *GMT_stream[] = {\"Standard\", \"User-supplied\"};\nstatic const char *GMT_status[] = {\"Unused\", \"In-use\", \"Used\"};\nstatic const char *GMT_geometry[] = {\"Not Set\", \"Point\", \"Line\", \"Polygon\", \"Point|Line|Poly\", \"Line|Poly\", \"Surface\", \"Non-Geographical\"};\n\n/*! Two different i/o mode: GMT_Put|Get_Data vs GMT_Put|Get_Record */\nenum GMT_enum_iomode {\n\tGMTAPI_BY_SET \t= 0,\t/* Default is to read the entire dataset or texset */\n\tGMTAPI_BY_REC\t= 1};\t/* Means we will access the registere files on a record-by-record basis */\n\n/*! Entries into dim[] for matrix or vector */\nenum GMT_dim {\n\tGMTAPI_HDR_POS = 3,\t/* Used with curr_pos to keep track of table headers only */\n\tGMTAPI_DIM_COL\t= 0,\t/* Holds the number of columns for vectors and x-nodes for matrix */\n\tGMTAPI_DIM_ROW = 1};\t/* Holds the number of rows for vectors and y-nodes for matrix */\n\nenum GMTAPI_enum_input {\n\tGMTAPI_OPTION_INPUT \t= 0,\t/* Input resource specified via an option (e.g., -G<file>) */\n\tGMTAPI_MODULE_INPUT \t= 1};\t/* Input resource specified via the module command line */\n\nenum GMTAPI_enum_status {\n\tGMTAPI_GOT_SEGHEADER \t= -1,\t/* Read a segment header */\n\tGMTAPI_GOT_SEGGAP \t= -2};\t/* Detected a gap and insertion of new segment header */\n\nenum GMTAPI_enum_via {\n\tGMT_VIA_VECTOR = 128,\t/* Data passed via user matrix */\n\tGMT_VIA_MATRIX = 256};\t/* Data passed via user vectors */\n\n/*==================================================================================================\n *\t\tPRIVATE FUNCTIONS ONLY USED BY THIS LIBRARY FILE\n *==================================================================================================\n *\n * api_* functions are static and only used in gmt_api.c\n * gmtapi_* functions are exported and may be used in other gmt_*.c files\n */\n\n/* A few functions are declared here since it is used in so many places */\nint gmtapi_report_error (void *V_API, int error);\nint gmtapi_validate_id (struct GMTAPI_CTRL *API, int family, int object_ID, int direction, int module_input);\nint gmtapi_unregister_io (struct GMTAPI_CTRL *API, int object_ID, unsigned int direction);\nunsigned int gmtapi_count_objects (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int direction, int *first_ID);\nvoid gmtapi_close_grd (struct GMT_CTRL *GMT, struct GMT_GRID *G);\nchar *gmtapi_create_header_item (struct GMTAPI_CTRL *API, unsigned int mode, void *arg);\n\n/* Series of one-line functions to assign val to a particular union member of array u at position row, rounding if integer output */\nGMT_LOCAL void api_put_val_double (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->f8[row]  =                  val; }\nGMT_LOCAL void api_put_val_float  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->f4[row]  = (float)          val; }\nGMT_LOCAL void api_put_val_ulong  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui8[row] = (uint64_t)lrint(val); }\nGMT_LOCAL void api_put_val_long   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si8[row] =  (int64_t)lrint(val); }\nGMT_LOCAL void api_put_val_uint   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui4[row] = (uint32_t)lrint(val); }\nGMT_LOCAL void api_put_val_int    (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si4[row] =  (int32_t)lrint(val); }\nGMT_LOCAL void api_put_val_ushort (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui2[row] = (uint16_t)lrint(val); }\nGMT_LOCAL void api_put_val_short  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si2[row] =  (int16_t)lrint(val); }\nGMT_LOCAL void api_put_val_uchar  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->uc1[row] =  (uint8_t)lrint(val); }\nGMT_LOCAL void api_put_val_char   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->sc1[row] =   (int8_t)lrint(val); }\n\nGMT_LOCAL void api_get_val_double (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->f8[row]; }\nGMT_LOCAL void api_get_val_float  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->f4[row]; }\nGMT_LOCAL void api_get_val_ulong  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = (double)u->ui8[row]; }\t/* Must cast/truncate since longs integer range exceed that of double */\nGMT_LOCAL void api_get_val_long   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = (double)u->si8[row]; }\t/* Must cast/truncate since longs integer range exceed that of double */\nGMT_LOCAL void api_get_val_uint   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->ui4[row]; }\nGMT_LOCAL void api_get_val_int    (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->si4[row]; }\nGMT_LOCAL void api_get_val_ushort (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->ui2[row]; }\nGMT_LOCAL void api_get_val_short  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->si2[row]; }\nGMT_LOCAL void api_get_val_uchar  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->uc1[row]; }\nGMT_LOCAL void api_get_val_char   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->sc1[row]; }\n\ntypedef void (*GMT_putfunction)(union GMT_UNIVECTOR *, uint64_t, double  );\ntypedef void (*GMT_getfunction)(union GMT_UNIVECTOR *, uint64_t, double *);\n\nGMT_LOCAL inline GMT_putfunction api_select_put_function (struct GMTAPI_CTRL *API, unsigned int type) {\n\tswitch (type) {\t/* Use type to select the correct put function with which to place a value in the union */\n\t\tcase GMT_DOUBLE:\treturn (api_put_val_double);\tbreak;\n\t\tcase GMT_FLOAT:\t\treturn (api_put_val_float);\tbreak;\n\t\tcase GMT_ULONG:\t\treturn (api_put_val_ulong);\tbreak;\n\t\tcase GMT_LONG:\t\treturn (api_put_val_long);\tbreak;\n\t\tcase GMT_UINT:\t\treturn (api_put_val_uint);\tbreak;\n\t\tcase GMT_INT:\t\treturn (api_put_val_int);\tbreak;\n\t\tcase GMT_USHORT:\treturn (api_put_val_ushort);\tbreak;\n\t\tcase GMT_SHORT:\t\treturn (api_put_val_short);\tbreak;\n\t\tcase GMT_UCHAR:\t\treturn (api_put_val_uchar);\tbreak;\n\t\tcase GMT_CHAR:\t\treturn (api_put_val_char);\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Internal error in api_select_put_function: Passed bad type (%d), Must abort\\n\", type);\n\t\t\tGMT_exit (API->GMT, GMT_RUNTIME_ERROR); return NULL;\n\t\t\tbreak;\n\t}\n}\n\nGMT_LOCAL inline GMT_getfunction api_select_get_function (struct GMTAPI_CTRL *API, unsigned int type) {\n\tswitch (type) {\t/* Use type to select the correct get function with which to extract a value from the union */\n\t\tcase GMT_DOUBLE:\treturn (api_get_val_double);\tbreak;\n\t\tcase GMT_FLOAT:\t\treturn (api_get_val_float);\tbreak;\n\t\tcase GMT_ULONG:\t\treturn (api_get_val_ulong);\tbreak;\n\t\tcase GMT_LONG:\t\treturn (api_get_val_long);\tbreak;\n\t\tcase GMT_UINT:\t\treturn (api_get_val_uint);\tbreak;\n\t\tcase GMT_INT:\t\treturn (api_get_val_int);\tbreak;\n\t\tcase GMT_USHORT:\treturn (api_get_val_ushort);\tbreak;\n\t\tcase GMT_SHORT:\t\treturn (api_get_val_short);\tbreak;\n\t\tcase GMT_UCHAR:\t\treturn (api_get_val_uchar);\tbreak;\n\t\tcase GMT_CHAR:\t\treturn (api_get_val_char);\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Internal error in api_select_get_function: Passed bad type (%d), Must abort\\n\", type);\n\t\t\tGMT_exit (API->GMT, GMT_RUNTIME_ERROR); return NULL;\n\t\t\tbreak;\n\t}\n}\n\n/*! . */\nGMT_LOCAL int api_get_item (struct GMTAPI_CTRL *API, unsigned int family, void *data) {\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tAPI->error = GMT_NOERROR;\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t\t\t\t/* Empty object */\n\t\tS_obj = API->object[i];\n\t\tif (!S_obj->data) continue;\t\t/* Empty data */\n\t\tif (S_obj->family != (enum GMT_enum_family)family) {\t\t/* Not the required data type; check for exceptions... */\n\t\t\tif (family == GMT_IS_DATASET && (S_obj->family == GMT_IS_VECTOR || S_obj->family == GMT_IS_MATRIX))\n\t\t\t\tS_obj->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse\t/* We don't like your kind */\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_obj->data == data) item = i;\t/* Found the requested data */\n\t}\n\tif (item == GMT_NOTSET) { API->error = GMT_NOT_A_VALID_ID; return (GMT_NOTSET); }\t/* No such data found */\n\treturn (item);\n}\n\n/*! . */\nGMT_LOCAL inline uint64_t api_n_cols_needed_for_gaps (struct GMT_CTRL *GMT, uint64_t n) {\n\t/* Return the actual items needed (which may be more than n if gap testing demands it) */\n\tif (GMT->common.g.active) return (MAX (n, GMT->common.g.n_col));\t/* n or n_col (if larger) */\n\treturn (n);\t/* No gap checking, n it is */\n}\n\n/*! . */\nGMT_LOCAL inline void api_update_prev_rec (struct GMT_CTRL *GMT, uint64_t n_use) {\n\t/* Update previous record before reading the new record, but only if needed */\n\tif (GMT->current.io.need_previous) gmt_M_memcpy (GMT->current.io.prev_rec, GMT->current.io.curr_rec, n_use, double);\n}\n\n/*! . */\nGMT_LOCAL int api_alloc_vectors (struct GMT_CTRL *GMT, struct GMT_VECTOR *V, uint64_t n_alloc) {\n\t/* Allocate space for each column according to data type; V->n_rows is not touched */\n\tuint64_t col;\n\tint error;\n\n\tif (!V) return (GMT_PTR_IS_NULL);\t\t\t/* Nothing to allocate to */\n\tif (V->n_columns == 0) return (GMT_PTR_IS_NULL);\t/* No columns specified */\n\tif (n_alloc == 0) return (GMT_N_ROWS_NOT_SET);\t\t/* No rows specified */\n\tif (!V->data) return (GMT_PTR_IS_NULL);\t\t\t/* Array of columns have not been allocated */\n\tfor (col = 0; col < V->n_columns; col++) {\n\t\tif ((error = gmtlib_alloc_univector (GMT, &V->data[col], V->type[col], n_alloc)) != GMT_OK) return (error);\n\t}\n\tV->alloc_mode = GMT_ALLOC_INTERNALLY;\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL int api_alloc_grid (struct GMT_CTRL *GMT, struct GMT_GRID *Grid) {\n\t/* Use information in Grid header to allocate the grid data.\n\t * We assume gmtgrdio_init_grdheader has been called. */\n\n\tif (Grid->data) return (GMT_PTR_NOT_NULL);\n\tif (Grid->header->size == 0U) return (GMT_SIZE_IS_ZERO);\n\tif ((Grid->data = gmt_M_memory_aligned (GMT, NULL, Grid->header->size, float)) == NULL) return (GMT_MEMORY_ERROR);\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_alloc_grid_xy (struct GMTAPI_CTRL *API, struct GMT_GRID *Grid) {\n\t/* Use information in Grid header to allocate the grid x/y vectors.\n\t * We assume gmtgrdio_init_grdheader has been called. */\n\n\tif (Grid->x || Grid->y) return (GMT_PTR_NOT_NULL);\n\tGrid->x = GMT_Get_Coord (API, GMT_IS_GRID, GMT_X, Grid);\t/* Get array of x coordinates */\n\tGrid->y = GMT_Get_Coord (API, GMT_IS_GRID, GMT_Y, Grid);\t/* Get array of y coordinates */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_alloc_image (struct GMT_CTRL *GMT, uint64_t *dim, struct GMT_IMAGE *Image) {\n\t/* Use information in Image header to allocate the image data.\n\t * We assume gmtgrdio_init_grdheader has been called.\n\t * If dim given and is 2 or 4 then we have 1 or 3 bands plus alpha channel */\n\n\tif (Image->data) return (GMT_PTR_NOT_NULL);\n\tif (Image->header->size == 0U) return (GMT_SIZE_IS_ZERO);\n\tif ((Image->data = gmt_M_memory_aligned (GMT, NULL, Image->header->size * Image->header->n_bands, unsigned char)) == NULL) return (GMT_MEMORY_ERROR);\n\tif (dim && (dim[GMT_Z] == 2 || dim[GMT_Z] == 4)) {\n\t\tif ((Image->alpha = gmt_M_memory_aligned (GMT, NULL, Image->header->size, unsigned char)) == NULL) return (GMT_MEMORY_ERROR);\n\t}\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_alloc_image_xy (struct GMTAPI_CTRL *API, struct GMT_IMAGE *Image) {\n\t/* Use information in Grid header to allocate the image x,y vectors.\n\t * We assume gmtgrdio_init_grdheader has been called. */\n\n\tif (Image->x || Image->y) return (GMT_PTR_NOT_NULL);\n\tImage->x = GMT_Get_Coord (API, GMT_IS_IMAGE, GMT_X, Image);\t/* Get array of x coordinates */\n\tImage->y = GMT_Get_Coord (API, GMT_IS_IMAGE, GMT_Y, Image);\t/* Get array of y coordinates */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_print_func (FILE *fp, const char *message) {\n\t/* Just print this message to fp.  It is being used indirectly via\n\t * API->print_func.  Purpose of this is to allow external APIs such\n\t * as MATLAB (which cannot use printf) to reset API->print_func to\n\t * mexPrintf or similar functions. Default is api_print_func. */\n\n\tfprintf (fp, \"%s\", message);\n\treturn 0;\n}\n\n/*! . */\nGMT_LOCAL unsigned int api_gmtry (unsigned int geometry) {\n\t/* Return index to text representation in GMT_geometry[] for debug messages */\n\tif (geometry == GMT_IS_POINT)   return 1;\n\tif (geometry == GMT_IS_LINE)    return 2;\n\tif (geometry == GMT_IS_POLY)    return 3;\n\tif (geometry == GMT_IS_PLP)     return 4;\n\tif ((geometry & GMT_IS_LINE) && (geometry & GMT_IS_POLY)) return 5;\n\tif (geometry == GMT_IS_SURFACE) return 6;\n\tif (geometry == GMT_IS_NONE)    return 7;\n\treturn 0;\n}\n/* We also need to return the pointer to an object given a void * address of that pointer.\n * This needs to be done on a per data-type basis, e.g., to cast that void * to a struct GMT_GRID **\n * so we may return the value at that address: */\n\nGMT_LOCAL inline struct GMTAPI_CTRL * api_get_api_ptr     (struct GMTAPI_CTRL *ptr)  {return (ptr);}\nGMT_LOCAL inline struct GMT_PALETTE * api_get_cpt_ptr     (struct GMT_PALETTE **ptr) {return (*ptr);}\nGMT_LOCAL inline struct GMT_DATASET * api_get_dataset_ptr (struct GMT_DATASET **ptr) {return (*ptr);}\nGMT_LOCAL inline struct GMT_TEXTSET * api_get_textset_ptr (struct GMT_TEXTSET **ptr) {return (*ptr);}\nGMT_LOCAL inline struct GMT_GRID    * api_get_grid_ptr    (struct GMT_GRID **ptr)    {return (*ptr);}\nGMT_LOCAL inline struct GMT_POSTSCRIPT      * api_get_ps_ptr      (struct GMT_POSTSCRIPT **ptr)      {return (*ptr);}\nGMT_LOCAL inline struct GMT_MATRIX  * api_get_matrix_ptr  (struct GMT_MATRIX **ptr)  {return (*ptr);}\nGMT_LOCAL inline struct GMT_VECTOR  * api_get_vector_ptr  (struct GMT_VECTOR **ptr)  {return (*ptr);}\nGMT_LOCAL inline double      \t    * api_get_coord_ptr   (double **ptr)             {return (*ptr);}\nGMT_LOCAL inline struct GMT_IMAGE   * api_get_image_ptr (struct GMT_IMAGE **ptr) {return (*ptr);}\n/* Various inline functs to convert void pointer to specific type */\nGMT_LOCAL inline struct GMT_GRID_ROWBYROW * api_get_rbr_ptr (struct GMT_GRID_ROWBYROW *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_INFO * api_get_fftinfo_ptr (struct GMT_FFT_INFO *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_WAVENUMBER * api_get_fftwave_ptr (struct GMT_FFT_WAVENUMBER *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_WAVENUMBER ** api_get_fftwave_addr (struct GMT_FFT_WAVENUMBER **ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_GRID    * api_get_grid_data (struct GMT_GRID *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_IMAGE   * api_get_image_data (struct GMT_IMAGE *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_DATASET * api_get_dataset_data (struct GMT_DATASET *ptr) {return (ptr);}\n\n/*! If API is not set or do_not_exit is false then we call system exit, else we move along */\nGMT_LOCAL inline void api_exit (struct GMTAPI_CTRL *API, int code) {\n\tif (API->do_not_exit == false)\n\t\tGMT_exit (API->GMT, code);\n}\n\n/*! api_return_address is a convenience function that, given type, calls the correct converter */\nGMT_LOCAL void *api_return_address (void *data, unsigned int type) {\n\tvoid *p = NULL;\n\tswitch (type) {\n\t\tcase GMT_IS_GRID:\tp = api_get_grid_ptr (data);\tbreak;\n\t\tcase GMT_IS_DATASET:\tp = api_get_dataset_ptr (data);\tbreak;\n\t\tcase GMT_IS_TEXTSET:\tp = api_get_textset_ptr (data);\tbreak;\n\t\tcase GMT_IS_PALETTE:\tp = api_get_cpt_ptr (data);\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\tp = api_get_ps_ptr (data);\tbreak;\n\t\tcase GMT_IS_MATRIX:\tp = api_get_matrix_ptr (data);\tbreak;\n\t\tcase GMT_IS_VECTOR:\tp = api_get_vector_ptr (data);\tbreak;\n\t\tcase GMT_IS_COORD:\tp = api_get_coord_ptr (data);\tbreak;\n\t\tcase GMT_IS_IMAGE:\tp = api_get_image_ptr (data);\tbreak;\n\t}\n\treturn (p);\n}\n\n/*! . */\nstruct GMTAPI_CTRL * gmt_get_api_ptr (struct GMTAPI_CTRL *ptr) {\n\t/* Clean casting of void to API pointer at start of a module\n \t * If ptr is NULL we are in deep trouble...\n\t */\n\tif (ptr == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\treturn (ptr);\n}\n\n/*! api_alloc_object_array is a convenience function that, given type, allocates an array of the corresponding container */\nGMT_LOCAL void *api_alloc_object_array (struct GMTAPI_CTRL *API, unsigned int n_items, unsigned int type) {\n\tvoid *p = NULL;\n\tswitch (type) {\n\t\tcase GMT_IS_GRID:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_GRID *);\t\tbreak;\n\t\tcase GMT_IS_DATASET:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_DATASET *);\tbreak;\n\t\tcase GMT_IS_TEXTSET:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_TEXTSET *);\tbreak;\n\t\tcase GMT_IS_PALETTE:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_PALETTE *);\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_POSTSCRIPT *);\tbreak;\n\t\tcase GMT_IS_IMAGE:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_IMAGE *);\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_MATRIX *);\tbreak;\n\t\tcase GMT_IS_VECTOR:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_VECTOR *);\tbreak;\n\t}\n\treturn (p);\n}\n\n/*! p_func_uint64_t is used as a pointer to functions that returns a uint64_t index */\ntypedef uint64_t (*p_func_uint64_t) (uint64_t row, uint64_t col, uint64_t dim);\n\n#ifdef DEBUG\n/*! Can be used to display API->object info wherever it is called as part of a debug operation */\nGMT_LOCAL void api_list_objects (struct GMTAPI_CTRL *API, char *txt) {\n\tunsigned int item, ext;\n\tstruct GMTAPI_DATA_OBJECT *S;\n\tchar message[GMT_LEN256] = {\"\"}, O, M;\n\t/* if (API->deep_debug == false) return; */\n\tif (!gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) return;\n\tsnprintf (message, GMT_LEN256, \"==> %d API Objects at end of %s\\n\", API->n_objects, txt);\n\tGMT_Message (API, GMT_TIME_NONE, message);\n\tif (API->n_objects == 0) return;\n\tGMT_Message (API, GMT_TIME_NONE, \"-----------------------------------------------------------\\n\");\n\tsnprintf (message, GMT_LEN256, \"K.. ID RESOURCE.... DATA........ FAMILY.... DIR... S O M L\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, message);\n\tGMT_Message (API, GMT_TIME_NONE, \"-----------------------------------------------------------\\n\");\n\tfor (item = 0; item < API->n_objects; item++) {\n\t\tif ((S = API->object[item]) == NULL) continue;\n\t\tO = (S->no_longer_owner) ? 'N' : 'Y';\n\t\tM = (S->messenger) ? 'Y' : 'N';\n\t\text = (S->alloc_mode == GMT_ALLOC_EXTERNALLY) ? '*' : ' ';\n\t\tsnprintf (message, GMT_LEN256, \"%c%2d %2d %12\" PRIxS \" %12\" PRIxS \" %10s %6s %d %c %c %d\\n\", ext, item, S->ID, (size_t)S->resource, (size_t)S->data,\n\t\t\tGMT_family[S->family], GMT_direction[S->direction], S->status, O, M, S->alloc_level);\n\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t}\n\tGMT_Message (API, GMT_TIME_NONE, \"-----------------------------------------------------------\\n\");\n}\n\n/*! Mostly for debugging */\nGMT_LOCAL void api_set_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *obj) {\n\t/* This is mostly for debugging and may go away or remain under DEBUG */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Set_Object for family: %d\\n\", obj->family);\n\tswitch (obj->family) {\n\t\tcase GMT_IS_GRID:\tobj->G = obj->data; break;\n\t\tcase GMT_IS_DATASET:\tobj->D = obj->data; break;\n\t\tcase GMT_IS_TEXTSET:\tobj->T = obj->data; break;\n\t\tcase GMT_IS_PALETTE:\tobj->C = obj->data; break;\n\t\tcase GMT_IS_POSTSCRIPT:\t\tobj->P = obj->data; break;\n\t\tcase GMT_IS_MATRIX:\tobj->M = obj->data; break;\n\t\tcase GMT_IS_VECTOR:\tobj->V = obj->data; break;\n\t\tcase GMT_IS_COORD:\tbreak;\t/* No worries */\n\t\tcase GMT_IS_IMAGE:\tobj->I = obj->data; break;\n\t\tcase GMT_N_FAMILIES:\tbreak;\n\t}\n}\n#endif\n\n/*! . */\nGMT_LOCAL int api_get_ppid (struct GMTAPI_CTRL *API) {\n\t/* Return the parent process ID [i.e., shell for command line use or gmt app for API] */\n\tint ppid = -1;\n\tgmt_M_unused(API);\n#if defined(WIN32)\n\t/* OK, the trouble is the following. On Win if the executables are run from within MSYS\n\t   api_get_ppid returns different values for each call, and this completely breaks the idea\n\t   using the PPID (parent PID) to create unique file names.\n\t   So, given that we didn't yet find a way to make this work from within MSYS (and likely Cygwin)\n\t   we are forcing PPID = 0 in all Windows variants. */\n\tppid = 0;\n#else\n\tif (API->external)\t/* Return ID of the gmt application instead for external interfaces */\n\t\tppid = getpid ();\n\telse\t/* Here we are probably running from the command line and want the shell's PID */\n\t\tppid = getppid(); /* parent process id */\n#endif\n\treturn (ppid);\n}\n\n#if 0\n/* This was our effort to get PPID under Windows.  Remains as comments for now */\n#ifdef _WIN32\n\tint pid = GetCurrentProcessId ();\n\tHANDLE h = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);\n\tPROCESSENTRY32 pe = { 0 };\n\tpe.dwSize = sizeof (PROCESSENTRY32);\n\n\tif (Process32First(h, &pe)) {\n\t\tdo {\n\t\t\tif (pe.th32ProcessID == pid)\n\t\t\t\tppid = pe.th32ParentProcessID;\n\t\t} while (ppid == -1 && Process32Next(h, &pe));\n\t}\n\tCloseHandle (h);\n#endif\n#endif\n\n/*! . */\nGMT_LOCAL char *api_lib_tag (char *name) {\n\t/* Pull out the tag from a name like <tag>[.extension] */\n\tchar *extension = NULL, *pch = NULL, *tag = NULL;\n\tif (!strchr (name, '.')) return NULL;\t/* No file with extension given, probably just a directory due to user confusion */\n\ttag = strdup (name);\n\textension = strrchr (tag, '.'); /* last period in name */\n\t*extension = '\\0'; /* remove extension */\n\t/* if name has the \"_w32|64\" suffix or any other suffix that starts with a '_', remove it. */\n\tpch = strrchr(tag, '_');\n\tif (pch) *pch = '\\0';\n\treturn (tag);\n}\n\n/*! . */\nGMT_LOCAL int api_init_sharedlibs (struct GMTAPI_CTRL *API) {\n\t/* At the end of GMT_Create_Session we are done with processing gmt.conf.\n\t * We can now determine how many shared libraries and plugins to consider, and open the core lib */\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tunsigned int n_custom_libs = 0, k, e, n_alloc = GMT_TINY_CHUNK;\n\tchar text[GMT_LEN256] = {\"\"}, plugindir[GMT_LEN256] = {\"\"}, path[GMT_LEN256] = {\"\"};\n\tchar *libname = NULL, **list = NULL;\n#ifdef WIN32\n\tchar *extension[1] = {\".dll\"};\n\tunsigned int n_extensions = 1;\n#elif  defined(__APPLE__)\t/* Look for both .so and .dylib shared libs on OSX */\n\tchar *extension[2] = {\".so\", \".dylib\"};\n\tunsigned int n_extensions = 2;\n#else\t/* Linux, etc. only use .so */\n\tchar *extension[1] = {\".so\"};\n\tunsigned int n_extensions = 1;\n#endif\n\n#ifdef SUPPORT_EXEC_IN_BINARY_DIR\n\t/* If SUPPORT_EXEC_IN_BINARY_DIR is defined we try to load plugins from the\n\t * build tree */\n\n\t/* Only true, when we are running in a subdir of GMT_BINARY_DIR_SRC_DEBUG: */\n\tbool running_in_bindir_src = !strncmp (GMT->init.runtime_bindir, GMT_BINARY_DIR_SRC_DEBUG, strlen(GMT_BINARY_DIR_SRC_DEBUG));\n#endif\n\n\tAPI->lib = gmt_M_memory (GMT, NULL, n_alloc, struct Gmt_libinfo);\n\n\t/* 1. Load the GMT core library by default [unless static build] */\n\t/* Note: To extract symbols from the currently executing process we need to load it as a special library.\n\t * This is done by passing NULL under Linux and by calling GetModuleHandleEx under Windows, hence we\n\t * use the dlopen_special call which is defined in gmt_sharedlibs.c */\n\n\tAPI->lib[0].name = strdup (\"core\");\n\tAPI->lib[0].path = strdup (GMT_CORE_LIB_NAME);\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # 0 (core). Path = %s\\n\", API->lib[0].path);\n\t++n_custom_libs;\n#ifdef BUILD_SHARED_LIBS\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading core GMT shared library: %s\\n\", API->lib[0].path);\n\tif ((API->lib[0].handle = dlopen_special (API->lib[0].path)) == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error loading core GMT shared library: %s\\n\", dlerror());\n\t\tapi_exit (API, GMT_RUNTIME_ERROR); return GMT_RUNTIME_ERROR;\n\t}\n\tdlerror (); /* Clear any existing error */\n#endif\n\n\t/* 3. Add any plugins installed in <installdir>/lib/gmt/plugins */\n\n\tif (GMT->init.runtime_libdir) {\t/* Successfully determined runtime dir for shared libs */\n#ifdef SUPPORT_EXEC_IN_BINARY_DIR\n\t\tif ( running_in_bindir_src && access (GMT_BINARY_DIR_SRC_DEBUG \"/plugins\", R_OK|X_OK) == 0 ) {\n\t\t\t/* Running in build dir: search plugins in build-dir/src/plugins */\n\t\t\tstrncat (plugindir, GMT_BINARY_DIR_SRC_DEBUG \"/plugins\", GMT_LEN256-1);\n#ifdef XCODER\n\t\t\tstrcat (plugindir, \"/Debug\");\t/* The Xcode plugin path for Debug */\n#endif\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t/* Set full path to the core library */\n\t\tsnprintf (plugindir, GMT_LEN256, \"%s/%s\", GMT->init.runtime_libdir, GMT_CORE_LIB_NAME);\n\t\tif (!GMT->init.runtime_library) GMT->init.runtime_library = strdup (plugindir);\n\n#ifdef WIN32\n\t\t\tsnprintf (plugindir, GMT_LEN256, \"%s/gmt_plugins\", GMT->init.runtime_libdir);\t/* Generate the Win standard plugins path */\n#else\n\t\t\tsnprintf (plugindir, GMT_LEN256, \"%s/gmt\" GMT_INSTALL_NAME_SUFFIX \"/plugins\", GMT->init.runtime_libdir);\t/* Generate the *nix standard plugins path */\n#endif\n\t\t}\n\t\tif (!GMT->init.runtime_plugindir) GMT->init.runtime_plugindir = strdup (plugindir);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading GMT plugins from: %s\\n\", plugindir);\n\t\tfor (e = 0; e < n_extensions; e++) {\t/* Handle case of more than one allowed shared library extension */\n\t\t\tif ((list = gmtlib_get_dir_list (GMT, plugindir, extension[e]))) {\t/* Add these files to the libs */\n\t\t\t\tk = 0;\n\t\t\t\twhile (list[k]) {\n\t\t\t\t\tsnprintf (path, GMT_LEN256, \"%s/%s\", plugindir, list[k]);\n\t\t\t\t\tif (access (path, R_OK))\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Shared Library %s cannot be found or read!\\n\", path);\n\t\t\t\t\telse {\n\t\t\t\t\t\tAPI->lib[n_custom_libs].name = api_lib_tag (list[k]);\n\t\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (path);\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = %s\\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\t\tn_custom_libs++;\t\t\t/* Add up entries found */\n\t\t\t\t\t\tif (n_custom_libs == n_alloc) {\t\t/* Allocate more memory for list */\n\t\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct Gmt_libinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tgmtlib_free_dir_list (GMT, &list);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* 4. Add any custom GMT libraries to the list of libraries/plugins to consider, if specified.\n\t      We will find when trying to open if any of these are actually available. */\n\n\tif (GMT->session.CUSTOM_LIBS) {\t/* We specified custom shared libraries */\n\t\tk = (unsigned int)strlen (GMT->session.CUSTOM_LIBS) - 1;\t/* Index of last char in CUSTOM_LIBS */\n\t\tif (GMT->session.CUSTOM_LIBS[k] == '/' || GMT->session.CUSTOM_LIBS[k] == '\\\\') {\t/* We gave CUSTOM_LIBS as a subdirectory, add all files found inside it to shared libs list */\n\t\t\tstrcpy (plugindir, GMT->session.CUSTOM_LIBS);\n\t\t\tplugindir[k] = '\\0';\t/* Chop off trailing slash */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading custom GMT plugins from: %s\\n\", plugindir);\n\t\t\tfor (e = 0; e < n_extensions; e++) {\n\t\t\t\tif ((list = gmtlib_get_dir_list (GMT, plugindir, extension[e]))) {\t/* Add these to the libs */\n\t\t\t\t\tk = 0;\n\t\t\t\t\twhile (list[k]) {\n\t\t\t\t\t\tsnprintf (path, GMT_LEN256, \"%s/%s\", plugindir, list[k]);\n\t\t\t\t\t\tif (access (path, R_OK)) {\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Shared Library %s cannot be found or read!\\n\", path);\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Check that your GMT_CUSTOM_LIBS (in gmt.conf, perhaps) is correct\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((API->lib[n_custom_libs].name = api_lib_tag (list[k]))) {\n\t\t\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (path);\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = \\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\t\t\tn_custom_libs++;\t\t/* Add up entries found */\n\t\t\t\t\t\t\tif (n_custom_libs == n_alloc) {\t/* Allocate more memory for list */\n\t\t\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct Gmt_libinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Shared Library %s has no extension! Ignored\\n\", list[k]);\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tgmtlib_free_dir_list (GMT, &list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\t/* Just a list with one or more comma-separated library paths */\n\t\t\tunsigned int pos = 0;\n\t\t\twhile (gmt_strtok (GMT->session.CUSTOM_LIBS, \",\", &pos, text)) {\n\t\t\t\tlibname = strdup (basename (text));\t\t/* Last component from the pathname */\n\t\t\t\tif (access (text, R_OK)) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Shared Library %s cannot be found or read!\\n\", text);\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Check that your GMT_CUSTOM_LIBS (in gmt.conf, perhaps) is correct\\n\");\n\t\t\t\t}\n\t\t\t\telse if ((API->lib[n_custom_libs].name = api_lib_tag (libname))) {\n\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (text);\n\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = \\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\tn_custom_libs++;\t\t/* Add up entries found */\n\t\t\t\t\tif (n_custom_libs == n_alloc) {\t/* Allocate more memory for list */\n\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct Gmt_libinfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Shared Library %s has no extension! Ignored\\n\", text);\n\t\t\t\tgmt_M_str_free (libname);\n\t\t\t}\n\t\t}\n\t}\n\n\tAPI->n_shared_libs = n_custom_libs;\t/* Update total number of shared libraries */\n\tAPI->lib = gmt_M_memory (GMT, API->lib, API->n_shared_libs, struct Gmt_libinfo);\n\n\treturn (GMT_NOERROR);\n}\n\n/*! Free items in the shared lib list */\nGMT_LOCAL void api_free_sharedlibs (struct GMTAPI_CTRL *API) {\n\tunsigned int k;\n\tfor (k = 0; k < API->n_shared_libs; k++) {\n\t\tif (k > 0 && API->lib[k].handle && dlclose (API->lib[k].handle))\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error closing GMT %s shared library: %s\\n\", API->lib[k].name, dlerror());\n\t\tgmt_M_str_free (API->lib[k].name);\n\t\tgmt_M_str_free (API->lib[k].path);\n\t}\n\tgmt_M_free (API->GMT, API->lib);\n\tAPI->n_shared_libs = 0;\n}\n\n/* Copy a file from the GMT auto-download directory or the Internet.  We recognize\n * different types and names of files.\n * 1. There are data sets of use to all GMT users, such as global relief:\n * \t   earth_relief_<res>.grd\tVarious global relief grids\n * We may add more data later but this is our start.\n * 2. Data sets only used to run an example or a test script\n * and these are all called @*, i.e., a '@' is pre-pended to the name.\n * They live in a cache subdirectory under the GMT_DATA_URL\n * and will be placed in a cache directory in the users ~/.gmt directory.\n * 3. Generic URLs starting with http:, https:, or ftp:  These will be\n * downloaded to the cache directory.\n * If auto-download is enabled and a requested input file matches these\n * names and not found by normal means then we download the file to the\n * user-directory.  All places that open files (GMT_Read_Data) will do\n * this check by first calling gmt_download_file_if_not_found.\n */\n\nstruct FtpFile {\n\tconst char *filename;\n\tFILE *fp;\n};\n\nstatic size_t fwrite_callback (void *buffer, size_t size, size_t nmemb, void *stream) {\n\tstruct FtpFile *out = (struct FtpFile *)stream;\n\tif (out && !out->fp) { /* open file for writing */\n\t\tout->fp = fopen (out->filename, \"wb\");\n\t\tif (!out->fp)\n\t\t\treturn -1; /* failure, can't open file to write */\n\t}\n\treturn fwrite (buffer, size, nmemb, out->fp);\n}\n\nunsigned int gmt_download_file_if_not_found (struct GMT_CTRL *GMT, const char* file_name) {\n\t/* Downloads a file if not found locally.  Returns the position in file_name of the\n \t * start of the actual file (e.g., if given an URL). */\n\tunsigned int kind = 0, dir = 0, pos = 0;\n\tint curl_err = 0;\n\tCURL *Curl = NULL;\n\tstatic char *ftp_dir[2] = {\"/cache\", \"\"}, *name[2] = {\"CACHE\", \"USER\"};\n\tchar *user_dir[2] = {GMT->session.CACHEDIR, GMT->session.USERDIR};\n\tchar url[PATH_MAX] = {\"\"}, local_path[PATH_MAX] = {\"\"}, *c = NULL, *file = strdup (file_name);\n\tstruct FtpFile ftpfile = {NULL, NULL};\n\n\t/* Because file_name may be <file>, @<file>, or URL/<file> we must find start of <file> */\n\tif (gmt_M_file_is_cache (file)) {\t/* A leading '@' was found */\n\t\tpos = 1;\n\t\tif ((c = strchr (file, '?')))\t/* Netcdf directive since URL was handled above */\n\t\t\tc[0] = '\\0';\n\t\telse if ((c = strchr (file, '=')))\t/* Grid attributes */\n\t\t\tc[0] = '\\0';\n\t}\n\telse if (gmt_M_file_is_url (file)) {\t/* A remote file given via an URL */\n\t\tpos = gmtlib_get_pos_of_filename (file);\t/* Start of file in URL (> 0) */\n\t\tif ((c = strchr (file, '?')) && !strchr (file, '='))\t/* Must be a netCDF sliced URL file so chop off the layer/variable specifications */\n\t\t\tc[0] = '\\0';\n\t\telse if ((c = strchr (file, '=')))\t/* Grid attributes */\n\t\t\tc[0] = '\\0';\n\t}\n\telse if ((c = strchr (file, '?')))\t/* Netcdf directive since URLs and caches were handled above */\n\t\tc[0] = '\\0';\t/* and pos = 0 */\n\n\t/* Return immediately if cannot be downloaded (for various reasons) */\n\tif (!gmtlib_file_is_downloadable (GMT, file, &kind)) {\n\t\tgmt_M_str_free (file);\n\t\treturn (pos);\n\t}\n\tdir = (kind == GMT_DATA_FILE) ? GMT_DATA_DIR : GMT_CACHE_DIR;\t/* Only GMT datasets should go data dir; all else in cache */\n\tif (user_dir[dir] == NULL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"The GMT_%s directory is not defined - download file to current directory\\n\", name[dir]);\n\t\tsprintf (local_path, \"%s\", &file[pos]);\n\t}\n\t/* Here we will try to download a file */\n\n  \tif ((Curl = curl_easy_init ()) == NULL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to initiate curl - cannot obtain %s\\n\", &file[pos]);\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\tif (curl_easy_setopt (Curl, CURLOPT_SSL_VERIFYPEER, 0L)) {\t\t/* Tell libcurl to not verify the peer */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to set curl option to not verify the peer\\n\");\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\tif (curl_easy_setopt (Curl, CURLOPT_FOLLOWLOCATION, 1L)) {\t\t/* Tell libcurl to follow 30x redirects */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to set curl option to follow redirects\\n\");\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\tif (user_dir[dir]) sprintf (local_path, \"%s/%s\", user_dir[dir], &file[pos]);\n\tif (kind == GMT_URL_QUERY) {\t/* Cannot have ?para=value etc in filename */\n\t\tc = strchr (local_path, '?');\n\t\tif (c) c[0] = '\\0';\t/* Chop off ?CGI parameters from local_path */\n\t}\n\tif (kind == GMT_URL_FILE || kind == GMT_URL_QUERY)\t/* General URL given */\n\t\tsprintf (url, \"%s\", file);\n\telse\t\t\t/* Use GMT ftp dir, possible from subfolder cache */\n\t\tsprintf (url, \"%s%s/%s\", GMT_DATA_URL, ftp_dir[dir], &file[pos]);\n\n \tif (curl_easy_setopt (Curl, CURLOPT_URL, url)) {\t/* Set the URL to copy */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to set curl option to read from %s\\n\", url);\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\tftpfile.filename = local_path;\t/* Set pointer to local filename */\n\t/* Define our callback to get called when there's data to be written */\n\tif (curl_easy_setopt (Curl, CURLOPT_WRITEFUNCTION, fwrite_callback)) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to set curl output callback function\\n\");\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\t/* Set a pointer to our struct to pass to the callback */\n\tif (curl_easy_setopt (Curl, CURLOPT_WRITEDATA, &ftpfile)) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Failed to set curl option to write to %s\\n\", local_path);\n\t\tgmt_M_str_free (file);\n\t\treturn 0;\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Downloading file %s ...\\n\", url);\n\tif ((curl_err = curl_easy_perform (Curl))) {\t/* Failed, give error message */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Libcurl Error: %s\\n\", curl_easy_strerror (curl_err));\n\t\tif (ftpfile.fp != NULL) {\n\t\t\tfclose (ftpfile.fp);\n\t\t\tftpfile.fp = NULL;\n\t\t}\n\t\tif (gmt_remove_file (GMT, local_path))\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Could not even remove file %s\\n\", local_path);\n\t}\n\tcurl_easy_cleanup (Curl);\n\tif (ftpfile.fp) /* close the local file */\n\t\tfclose (ftpfile.fp);\n\n\tif (kind == GMT_URL_QUERY) {\t/* Cannot have ?para=value etc in local filename */\n\t\tc = strchr (file_name, '?');\n\t\tif (c) c[0] = '\\0';\t/* Chop off ?CGI parameters from local_path */\n\t}\n\tif (gmt_M_is_verbose (GMT, GMT_MSG_VERBOSE)) {\t/* Say a few things about the file we got */\n\t\tstruct stat buf;\n\t\tif (stat (local_path, &buf))\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Error: Could not determine size of downloaded file %s\\n\", &file_name[pos]);\n\t\telse\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Download complete [Got %s].\\n\", gmt_memory_use (buf.st_size, 3));\n\t}\n\tgmt_M_str_free (file);\n\n\treturn (pos);\n}\n\n/* The basic gmtread|write module meat; used by external APIs only, such as the GMT/MATLAB API */\n\n/*! Duplicate ifile on ofile.  Calling program is responsible to ensure correct args are passed */\nint gmt_copy (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, char *ifile, char *ofile) {\n\tdouble *wesn = NULL;\t/* For grid and image subsets */\n\tstruct GMT_DATASET *D = NULL;\n\tstruct GMT_TEXTSET *T = NULL;\n\tstruct GMT_PALETTE *C = NULL;\n\tstruct GMT_GRID *G = NULL;\n\tstruct GMT_POSTSCRIPT *P = NULL;\n\tstruct GMT_IMAGE *I = NULL;\n\tstruct GMT_MATRIX *M = NULL;\n\tstruct GMT_VECTOR *V = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tAPI->error = GMT_NOERROR;\n\tGMT_Report (API, GMT_MSG_VERBOSE, \"Read %s from %s and write to %s\\n\", GMT_family[family], ifile, ofile);\n\tGMT = API->GMT;\n\n\tswitch (family) {\n\t\tcase GMT_IS_DATASET:\n\t\t\tif ((D = GMT_Read_Data (API, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_DATASET, GMT_IS_FILE, D->geometry, D->io_mode | GMT_IO_RESET, NULL, ofile, D) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\tif ((T = GMT_Read_Data (API, GMT_IS_TEXTSET, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_TEXTSET, GMT_IS_FILE, GMT_IS_NONE, T->io_mode | GMT_IO_RESET, NULL, ofile, T) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\n\t\t\twesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif ((G = GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_READ_NORMAL, wesn, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\twesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif (GMT_Write_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_IO_RESET, wesn, ofile, G) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\twesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif ((I = GMT_Read_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_READ_NORMAL, wesn, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\twesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif (GMT_Write_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_IO_RESET, wesn, ofile, I) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\tif ((C = GMT_Read_Data (API, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, C->mode | GMT_IO_RESET, NULL, ofile, C) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tif ((P = GMT_Read_Data (API, GMT_IS_POSTSCRIPT, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_POSTSCRIPT, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, P) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tif ((M = GMT_Read_Data (API, GMT_IS_MATRIX, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_MATRIX, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, M) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tif ((V = GMT_Read_Data (API, GMT_IS_VECTOR, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_VECTOR, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, V) != GMT_OK)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"No external read or write support yet for object %s\\n\", GMT_family[family]);\n\t\t\treturn_error(API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"Internal error, family = %d\\n\", family);\n\t\t\treturn_error(API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\n\treturn (API->error);\n}\n\n/* Note: Many/all of these do not need to check if API == NULL since they are called from functions that do. */\n/* Private functions used by this library only.  These are not accessed outside this file. */\n\nGMT_LOCAL unsigned int api_pick_out_col_number (struct GMT_CTRL *GMT, unsigned int col) {\n\t/* Return the next column to be reported on output */\n\tunsigned int col_pos;\n\tif (GMT->common.o.active)\t/* -o has selected some columns */\n\t\tcol_pos = GMT->current.io.col[GMT_OUT][col].col;\t/* Which data column to pick */\n\telse if (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\tcol_pos = 1 - col;\t/* Write lat/lon instead of lon/lat */\n\telse\n\t\tcol_pos = col;\t/* Just goto that column */\n\treturn (col_pos);\n}\n\n/*! . */\nGMT_LOCAL double api_select_dataset_value (struct GMT_CTRL *GMT, struct GMT_DATASEGMENT *S, unsigned int row, unsigned int col) {\n\t/* For binary output of a data table segment via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos = api_pick_out_col_number (GMT, col);\n\tval = (col_pos >= S->n_columns) ? GMT->session.d_NaN : S->data[col_pos][row];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];\t/* Write this value instead of NaNs */\n\tif (GMT->current.io.col_type[GMT_OUT][col_pos] == GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\n/*! . */\nGMT_LOCAL double api_select_record_value (struct GMT_CTRL *GMT, double *record, unsigned int col, unsigned int n_colums) {\n\t/* For binary output of data record via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos = api_pick_out_col_number (GMT, col);\n\tval = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];\t/* Write this value instead of NaNs */\n\tif (GMT->current.io.col_type[GMT_OUT][col_pos] == GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\nGMT_LOCAL unsigned int api_pick_in_col_number (struct GMT_CTRL *GMT, unsigned int col) {\n\t/* Return the next column to be selected on input */\n\tunsigned int col_pos;\n\tif (GMT->common.i.active)\t/* -i has selected some columns */\n\t\tcol_pos = GMT->current.io.col[GMT_IN][col].col;\t/* Which data column to pick */\n#if 0\n\telse if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\tcol_pos = 1 - col;\t/* Read lat/lon instead of lon/lat */\n#endif\n\telse\n\t\tcol_pos = col;\t/* Just goto that column */\n\treturn (col_pos);\n}\n\n/*! . */\nGMT_LOCAL double api_get_record_value (struct GMT_CTRL *GMT, double *record, uint64_t col, uint64_t n_colums) {\n\t/* For binary input of data record via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos;\n\tcol_pos = api_pick_in_col_number (GMT, (unsigned int)col);\n\tval = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_IN] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_IN];\t/* Write this value instead of NaNs */\n\tif (GMT->current.io.col_type[GMT_IN][col_pos] == GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\n/*! . */\nGMT_LOCAL int api_bin_input_memory (struct GMT_CTRL *GMT, uint64_t n, uint64_t n_use) {\n\t/* Read function which gets one record from the memory reference.\n \t * The current data record has already been read from wherever and is available in GMT->current.io.curr_rec */\n\tunsigned int status;\n\tgmt_M_unused(n);\n\n\tGMT->current.io.status = GMT_IO_DATA_RECORD;\t/* Default status we expect, but this may change below */\n\tGMT->current.io.rec_no++;\t\t\t/* One more input record read */\n\tstatus = gmtlib_process_binary_input (GMT, n_use);\t/* Check for segment headers */\n\tif (status == 1) return (GMTAPI_GOT_SEGHEADER);\t/* A segment header was found and we are done here */\n\tif (gmtlib_gap_detected (GMT)) { gmtlib_set_gap (GMT); return (GMTAPI_GOT_SEGGAP); }\t/* Gap forced a segment header to be issued and we get out */\n\tGMT->current.io.pt_no++;\t/* Actually got a valid data record */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL char * api_tictoc_string (struct GMTAPI_CTRL *API, unsigned int mode) {\n\t/* Optionally craft a leading timestamp.\n\t * mode = 0:\tNo time stamp\n\t * mode = 1:\tAbs time stamp formatted via GMT_TIME_STAMP\n\t * mode = 2:\tReport elapsed time since last reset.\n\t * mode = 4:\tReset elapsed time to 0, no time stamp.\n\t * mode = 6:\tReset elapsed time and report it as well.\n\t */\n\ttime_t right_now;\n\tclock_t toc = 0;\n\tunsigned int H, M, S, milli;\n\tdouble T;\n\tstatic char stamp[GMT_LEN256] = {\"\"};\n\n\tif (mode == 0) return NULL;\t\t/* no timestamp requested */\n\tif (mode > 1) toc = clock ();\t\t/* Elapsed time requested */\n\tif (mode & 4) API->GMT->current.time.tic = toc;\t/* Reset previous timestamp to now */\n\n\tswitch (mode) {\t/* Form output timestamp string */\n\t\tcase 1:\t/* Absolute time stamp */\n\t\t\tright_now = time ((time_t *)0);\n\t\t\tstrftime (stamp, sizeof(stamp), API->GMT->current.setting.format_time_stamp, localtime (&right_now));\n\t\t\tbreak;\n\t\tcase 2:\t/* Elapsed time stamp */\n\t\tcase 6:\n\t\t\tT = (double)(toc - (clock_t)API->GMT->current.time.tic);\t/* Elapsed time in ticks */\n\t\t\tT /= CLOCKS_PER_SEC;\t/* Elapsed time in seconds */\n\t\t\tH = urint (floor (T * GMT_SEC2HR));\n\t\t\tT -= H * GMT_HR2SEC_I;\n\t\t\tM = urint (floor (T * GMT_SEC2MIN));\n\t\t\tT -= M * GMT_MIN2SEC_I;\n\t\t\tS = urint (floor (T));\n\t\t\tT -= S;\n\t\t\tmilli = urint (T*1000.0);\t/* Residual milli-seconds */\n\t\t\tsnprintf (stamp, GMT_LEN256, \"Elapsed time %2.2u:%2.2u:%2.2u.%3.3u\", H, M, S, milli);\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\treturn (stamp);\n}\n\n/*! . */\nGMT_LOCAL unsigned int api_add_existing (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int direction, int *first_ID) {\n\t/* In this mode, we find all registrered resources of matching family,geometry,direction that are unused and turn variable selected to true. */\n\tunsigned int i, n;\n\n\t*first_ID = GMT_NOTSET;\t/* Not found yet */\n\tfor (i = n = 0; i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t/* A freed object, skip */\n\t\tif (API->object[i]->direction != (enum GMT_enum_std)direction) continue; /* Wrong direction */\n\t\tif (API->object[i]->geometry  != (enum GMT_enum_geometry)geometry) continue;  /* Wrong geometry */\n\t\tif (API->object[i]->status    != GMT_IS_UNUSED) continue;  /* Already used */\n\t\tif (family != API->object[i]->family) continue;\t\t   /* Wrong data type */\n\t\tn++;\t/* Found one that satisfied requirements */\n\t\tif (*first_ID == GMT_NOTSET) *first_ID = API->object[i]->ID;\t/* Get the ID of the first that passed the test */\n\t\tAPI->object[i]->selected = true;\t/* Make this an active object for the coming i/o operation */\n\t}\n\treturn (n);\n}\n\n/* These functions are support functions for the API function GMT_Encode_Options:\n *\tapi_key_to_family\n *\tapi_process_keys\n *\tapi_get_key\n *\tapi_found_marker\n *\n * The \"keys\" refer to the contents of the THIS_MODULE_KEYS set in each module.\n */\n\n/* Indices into the keys triple codes */\n#define K_OPT\t\t\t0\n#define K_FAMILY\t\t1\n#define K_DIR\t\t\t2\n#define K_EQUAL\t\t\t3\n#define K_MODIFIER\t\t4\n#define GMT_FILE_NONE\t\t0\n#define GMT_FILE_EXPLICIT\t1\n#define GMT_FILE_IMPLICIT\t2\n\n#define K_PRIMARY\t\t\t0\n#define K_SECONDARY\t\t\t1\n\n#define API_PRIMARY_INPUT\t\t'{'\n#define API_PRIMARY_OUTPUT\t\t'}'\n#define API_SECONDARY_INPUT\t\t'('\n#define API_SECONDARY_OUTPUT\t')'\n\nGMT_LOCAL int api_key_to_family (void *API, char *key, int *family, int *geometry) {\n\t/* Assign direction, family, and geometry based on the key.\n\t   Note: No Vector or Matrix here since those always masquarade as DATASET in modules. */\n\n\tswitch (key[K_FAMILY]) {\t/* 2nd char contains the data type code */\n\t\tcase 'G':\n\t\t\t*family = GMT_IS_GRID;\n\t\t\t*geometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_POLY;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_LINE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_POINT;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t*family = GMT_IS_PALETTE;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\t*family = GMT_IS_TEXTSET;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\t*family = GMT_IS_IMAGE;\n\t\t\t*geometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\t*family = GMT_IS_POSTSCRIPT;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t*family = GMT_IS_NONE;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_key_to_family: INTERNAL ERROR: key family (%c) not recognized\\n\", key[K_FAMILY]);\n\t\t\treturn GMT_NOTSET;\n\t\t\tbreak;\n\t}\n\n\t/* Third key character contains the in/out code */\n\treturn ((key[K_DIR] == API_SECONDARY_OUTPUT || key[K_DIR] == API_PRIMARY_OUTPUT) ? GMT_OUT : GMT_IN);\t/* Return the direction of the i/o */\n}\n\nGMT_LOCAL char **api_process_keys (void *API, const char *string, char type, struct GMT_OPTION *head, int *n_to_add, unsigned int *n_items) {\n\t/* Turn the comma-separated list of 3-char codes in string into an array of such codes.\n \t * In the process, replace any ?-types with the selected type if type is not 0.\n\t * We return the array of strings and its number (n_items). */\n\tsize_t len, k, kk, n;\n\tint o_id = GMT_NOTSET, family = GMT_NOTSET, geometry = GMT_NOTSET;\n\tbool change_type = false;\n\tchar **s = NULL, *next = NULL, *tmp = NULL, magic = 0, revised[GMT_LEN64] = {\"\"};\n\tstruct GMT_OPTION *opt = NULL;\n\t*n_items = 0;\t/* No keys yet */\n\n\tfor (k = 0; k < GMT_N_FAMILIES; k++) n_to_add[k] = GMT_NOTSET;\t/* Initially no input counts */\n\tif (!string) return NULL;\t/* Got NULL, so just give up */\n\tlen = strlen (string);\t\t/* Get the length of this item */\n\tif (len == 0) return NULL;\t/* Got no characters, so give up */\n\ttmp = strdup (string);\t\t/* Get a working copy of string */\n\t/* Replace unknown types (marked as ?) in tmp with selected type give by input variable \"type\" */\n\tif (type) {\t/* Got a nonzero type */\n\t\tfor (k = 0; k < strlen (tmp); k++)\n\t\t\tif (tmp[k] == '?') tmp[k] = type;\n\t}\n\t/* Count the number of items (start n at 1 since there are one less comma than items) */\n\tfor (k = 0, n = 1; k < len; k++)\n\t\tif (tmp[k] == ',') n++;\n\t/* Allocate and populate the character array, then return it and n_items */\n\ts = (char **) calloc (n, sizeof (char *));\n\tk = 0;\n\twhile ((next = strsep (&tmp, \",\")) != NULL) {\t/* Get each comma-separated key */\n\t\tif (strlen (next) < 3) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t            \"api_process_keys: INTERNAL ERROR: key %s contains less than 3 characters\\n\", next);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr (next, '!')) {\t/* Type did not get determined in GMT_Encode_Options so key is skipped */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG,\n\t\t\t            \"api_process_keys: key %s contains type = ! so we skip it\\n\", next);\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t}\n\t\ts[k] = strdup (next);\n\t\tif (next[K_DIR] == API_PRIMARY_OUTPUT) {\t/* Identified primary output key */\n\t\t\tif (o_id >= 0)\t/* Already had a primary output key */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t\t            \"api_process_keys: INTERNAL ERROR: keys %s contain more than one primary output key\\n\", string);\n\t\t\telse\n\t\t\t\to_id = (int)k;\n\t\t}\n\t\tk++;\n\t}\n\n\t/* While processing the array we also determine the key # for the primary output (if there is one) */\n\tfor (k = 0; k < n; k++) {\t/* Check for presence of any of the magic X,Y,Z keys */\n\t\tif (s[k][K_OPT] == '-') {\t/* Key letter X missing: Means that option -Y, if given, changes the type of input|output */\n\t\t\t/* Must first determine which data type we are dealing with via -Y<type> */\n\t\t\tif ((opt = GMT_Find_Option (API, s[k][K_FAMILY], head))) {\t/* A -Y<type> option was passed to the module */\n\t\t\t\ttype = (char)toupper (opt->arg[0]);\t/* Find type and replace any ? in keys with this type in uppercase (DGCITP) in api_process_keys below */\n\t\t\t\tif (!strchr (\"DGCITP\", type)) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_process_keys: INTERNAL ERROR: No or bad data type given to read|write (%c)\\n\", type);\n\t\t\t\t\treturn_null (NULL, GMT_NOT_A_VALID_TYPE);\t/* Unknown type */\n\t\t\t\t}\n\t\t\t\tif (type == 'P') type = 'X';\t/* We use X for PostScript internally since P may stand for polygon... */\n\t\t\t\tfor (kk = 0; kk < n; kk++) {\t/* Do the substitution for all keys that matches ? */\n\t\t\t\t\tif (s[kk][K_FAMILY] == '?' && strchr (\"-({\", s[kk][K_DIR])) s[kk][K_FAMILY] = type;\t/* Want input to handle this type of data */\n\t\t\t\t\tif (s[kk][K_FAMILY] == '?' && strchr (\"-)}\", s[kk][K_DIR])) s[kk][K_FAMILY] = type;\t/* Want output to handle this type of data */\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t\t            \"api_process_keys: INTERNAL ERROR: Required runtime type-getting option (-%c) was not given\\n\", s[k][K_FAMILY]);\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has now served its purpose */\n\t\t}\n\t\telse if (s[k][K_FAMILY] == '-') {\t/* Key letter Y missing: Means that -X, if given, changes primary input|output set by -Z to secondary (i.e., not required) */\n\t\t\t/* However, if +<mod> is appended then the primary input setting is left as is */\n\t\t\tif ((opt = GMT_Find_Option (API, s[k][K_OPT], head))) {\t/* Got the option that removes the requirement of an input or output dataset */\n\t\t\t\tif (!(s[k][3] == '+' && strstr (opt->arg, &s[k][3]))) {\t/* Got the option and no modifier to turn it off */\n\t\t\t\t\tfor (kk = 0; kk < n; kk++) {\t/* Change all primary input|output flags to secondary, depending on Z */\n\t\t\t\t\t\tif (!s[kk]) continue;\t\t/* A previously processed/freed key */\n\t\t\t\t\t\tif (s[kk][K_OPT] != s[k][K_DIR]) continue;\t\t/* Not the \"-Z \"option */\n\t\t\t\t\t\tif (s[kk][K_DIR] == API_PRIMARY_INPUT) s[kk][K_DIR] = API_SECONDARY_INPUT;\t\t/* No longer an implicit input */\n\t\t\t\t\t\telse if (s[kk][K_DIR] == API_PRIMARY_OUTPUT) s[kk][K_DIR] = API_SECONDARY_OUTPUT;\t/* No longer an implicit output */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has served its purpose */\n\t\t}\n\t\telse if (!strchr (\"{}()-\", s[k][K_DIR])) {\t/* Key letter Z not in {|(|}|)|-: which means that option -Z, if given, changes the type of primary output to Y */\n\t\t\t/* E.g, pscoast has >DM and this turns >X} to >D} only when -M is used.  Also, modifiers may be involved.\n\t\t\t   e.g, gmtspatial : New key \">TN+r\" means if -N+r is given then set >T}.  Just giving -N will not trigger the change.\n\t\t\t   e.g., pscoast \">TE+w-rR\" means if -E is given with modifier +w _and_ one of +r or +R is then set to >T}.\n\t\t\t   If X is not - then we will find the other KEY with X and select that as the one to change; this could\n\t\t\t   be used to change the primary INPUT type.  For instance, grdimage expects grid input (<G{+) but with\n\t\t\t   magic sequence <ID we change <G{+ to <I{+.  */\n\t\t\tmagic = s[k][K_DIR];\n\t\t\tif ((opt = GMT_Find_Option (API, magic, head))) {\t/* Got the magic option that changes output type */\n\t\t\t\tchar modifier[3] = {'+', '?', 0};\t/* We will replace ? with an actual modifier */\n\t\t\t\tsize_t this_k;\n\t\t\t\tif (o_id == GMT_NOTSET)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_process_keys: INTERNAL ERROR: No primary output identified but magic Z key present\\n\");\n\t\t\t\t/* Check if modifier(s) were given also and that one of them were selected */\n\t\t\t\tif (strlen (s[k]) > 3) {\t/* Not enough to just find option, must examine the modifiers */\n\t\t\t\t\t/* Full syntax: XYZ+abc...-def...: We do the substitution of output type to Y only if\n\t\t\t\t\t * 1. -Z is given\n\t\t\t\t\t * 2. -Z contains ALL the modifiers +a, +b, +c, ...\n\t\t\t\t\t * 3. -Z contains AT LEAST ONE of the modifers +d, +e, +f.\n\t\t\t\t\t */\n\t\t\t\t\tunsigned int kase = 0, count[2] = {0, 0}, given[2] = {0, 0};\n\t\t\t\t\tchange_type = false;\n\t\t\t\t\tfor (kk = 3; s[k][kk]; kk++) {\t/* Examine characters in the modifier string */\n\t\t\t\t\t\tif (strchr (\"-+\", s[k][kk])) {\t/* Start of all (+) versus at least one (-) */\n\t\t\t\t\t\t\tkase = (s[k][kk] == '-') ? 0 : 1;\t/* Set kase and go to next letter */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount[kase]++;\t/* How many AND and how many OR modifiers (depending on kase) */\n\t\t\t\t\t\tmodifier[1] = s[k][kk];\t/* Set current modifier */\n\t\t\t\t\t\tif (strstr (opt->arg, modifier)) given[kase]++;\t/* Match found with given option */\n\t\t\t\t\t}\n\t\t\t\t\t/* Only change the key if we found all the AND modifiers and at least one of the OR modifiers (if any were given) */\n\t\t\t\t\tif ((count[0] == 0 || (count[0] && given[0])) && count[1] == given[1]) change_type = true;\n\t\t\t\t}\n\t\t\t\telse\t/* true since we found the option and no modifiers were given */\n\t\t\t\t\tchange_type = true;\n\t\t\t\tif (s[k][K_OPT] != '-') {\t/* Find the relevant option to change [primary output key] */\n\t\t\t\t\tchar match = (s[k][K_OPT] == '<') ? API_PRIMARY_INPUT : API_PRIMARY_OUTPUT;\n\t\t\t\t\tfor (kk = 0, this_k = n; kk < n; kk++) {\n\t\t\t\t\t\tif (kk == k || s[kk] == NULL) continue;\n\t\t\t\t\t\tif (s[kk][K_OPT] == s[k][K_OPT] && s[kk][K_DIR] == match)\n\t\t\t\t\t\t\tthis_k = kk;\n\t\t\t\t\t}\n\t\t\t\t\tif (this_k == n) this_k = o_id;\n\t\t\t\t}\n\t\t\t\telse\t/* Select the primary output key */\n\t\t\t\t\tthis_k = o_id;\n\t\t\t\tif (change_type) {\n\t\t\t\t\tif (strchr (\"{<\", s[this_k][K_DIR])) {\n\t\t\t\t\t\tint new_family = 0, old_family = 0;\n\t\t\t\t\t\t(void)api_key_to_family (API, s[k], &new_family, &geometry);\n\t\t\t\t\t\t(void)api_key_to_family (API, s[this_k], &old_family, &geometry);\n\t\t\t\t\t\tif (new_family != old_family) gmt_M_int_swap (n_to_add[new_family], n_to_add[old_family]);\t/* Must swap our counts */\n\t\t\t\t\t}\n\t\t\t\t\ts[this_k][K_FAMILY] = s[k][K_FAMILY];\t/* Required input/output now implies this data type */\n\t\t\t\t\ts[this_k][K_OPT]    = s[k][K_OPT];\t/* Required input/output now implies this option */\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has served its purpose */\n\t\t}\n\t\telse if (s[k][K_DIR] == API_PRIMARY_INPUT) {\t/* Non-magic key: This one identified a primary input key */\n\t\t\t(void)api_key_to_family (API, s[k], &family, &geometry);\t/* Get datatype, and geometry, then set how many are requested */\n\t\t\tif (family != GMT_NOTSET) {\t/* Safeguard: If family not found then we don't want to crash below... */\n\t\t\t\tif (s[k][K_DIR+1])\t/* Gave an argument: This is either a number (a specific count) or + (1 or more) */\n\t\t\t\t\tn_to_add[family] = (s[k][K_DIR+1] == '+') ? GMTAPI_UNLIMITED : atoi (&s[k][K_DIR+1]);\n\t\t\t\telse\n\t\t\t\t\tn_to_add[family] = (family == GMT_IS_DATASET || family == GMT_IS_TEXTSET) ? GMTAPI_UNLIMITED : 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Shuffle away any NULL entries as a result of magic key processing */\n\tfor (k = kk = 0; k < n; k++) {\n\t\tif (s[k]) {\t/* Must keep this guy */\n\t\t\tif (k > kk) s[kk] = s[k];\n\t\t\tkk++;\n\t\t}\n\t}\n\tn = kk;\t/* May have lost some NULLs.  Make a revised string for debug output */\n\tfor (k = 0; k < n; k++) {\n\t\tstrcat (revised, \",\");\n\t\tstrcat (revised, s[k]);\n\t}\n\tif (revised[0]) GMT_Report (API, GMT_MSG_DEBUG, \"api_process_keys: Revised keys string is %s\\n\", &revised[1]);\n\t*n_items = (unsigned int)n;\t/* Total number of remaining keys for this module */\n\tgmt_M_str_free (tmp);\n\treturn s;\t/* The array of remaining keys */\n}\n\nGMT_LOCAL int api_get_key (void *API, char option, char *keys[], int n_keys) {\n\t/* Returns the position in the keys array that matches this option, or GMT_NOTSET if not found */\n\tint k;\n\tif (n_keys && keys == NULL)\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_get_key: INTERNAL ERROR: keys array is NULL but n_keys = %d\\n\", n_keys);\n\tfor (k = 0; keys && k < n_keys; k++) if (keys[k][K_OPT] == option) return (k);\n\treturn (GMT_NOTSET);\n}\n\nGMT_LOCAL bool api_found_marker (char *text) {\n\t/* A single questionmark and nothing else indicates a file marker */\n\tif (text[0] == '?' && text[1] == '\\0') return true;\n\treturn false;\t/* Not found */\n}\n\nGMT_LOCAL unsigned int api_determine_dimension (struct GMTAPI_CTRL *API, char *text) {\n\t/* Examine greenspline's -R option to learn the dimensionality of the domain (1, 2, or 3) */\n\tunsigned int n_slashes = 0;\n\tsize_t k;\n\tconst size_t s_length = strlen(text);\n\n\t/* First catch the simple -R? which means a grid is passed by the API, hence dimension is 2 */\n\tif (text[0] == '?' && text[1] == '\\0') return 2;\t/* A marker means a grid only, so done */\n\tfor (k = 0; k < s_length; k++)\n\t\tif (text[k] == '/') n_slashes++;\t\t\t/* Count slashes just in case */\n\tif ((text[0] == 'g' || text[0] == 'd') && (text[1] == '\\0' || text[1] == '/')) {\t/* Got -Rg or -Rd, possibly with trailing /zmin/zmax */\n\t\tif (text[1] == '\\0') return 2;\t/* Got -Rg or -Rd and no more */\n\t\tif (n_slashes == 2) return 3;\t/* Got -Rg/zmin/zmax or -Rd/zmin/zmax */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Syntax error -R option: Give 2, 4, or 6 coordinates, a gridfile, or use -Rd|g[/zmin/zmax]\\n\");\n\t\treturn 0;\n\t}\n\tif (!gmt_access (API->GMT, text, R_OK))\t/* Gave a readable file, we assume it is a grid since that is all that is allowed */\n\t\treturn 2;\n\t/* Only get here if the above cases did not trip */\n\tif (!(n_slashes == 1 || n_slashes == 3 || n_slashes == 5)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Syntax error -R option: Give 2, 4, or 6 coordinates\\n\");\n\t\treturn 0;\n\t}\n\treturn ((n_slashes + 1) / 2);\t/* Turns 1,3,5 into 1,2,3 */\n}\n\n/*! . */\nGMT_LOCAL void *api_retrieve_data (void *V_API, int object_ID) {\n\t/* Function to return pointer to the container for a registered data set.\n\t * Typically used when we wish a module to \"write\" its results to a memory\n\t * location that we wish to access from the calling program.  The procedure\n\t * is to use GMT_Register_IO with GMT_REF|COPY|READONLY and GMT_OUT but use\n\t * NULL as the source/destination.  Data are \"written\" by GMT allocating a\n\t * output container and updating the objects->resource pointer to this container.\n\t * api_retrieve_data simply returns that pointer given the registered ID.\n\t */\n\n\tint item;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\t/* Determine the item in the object list that matches this object_ID */\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\treturn_null (API, API->error);\n\t}\n\t/* Make sure the resource is present */\n\tif (API->object[item]->resource == NULL) {\n\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t}\n\t/* Make sure the data pointer has not been set */\n\tif (API->object[item]->data) {\n\t\treturn_null (API, GMT_PTR_NOT_NULL);\n\t}\n\t/* Assign data from resource and wipe resource pointer */\n\tAPI->object[item]->data = API->object[item]->resource;\n\tAPI->object[item]->resource = NULL;\n\n#ifdef DEBUG\n\tapi_list_objects (API, \"api_retrieve_data\");\n#endif\n\treturn (API->object[item]->data);\t/* Return pointer to the data container */\n}\n\n/*! . */\nGMT_LOCAL int api_begin_io (struct GMTAPI_CTRL *API, unsigned int direction) {\n\t/* Initializes the i/o mechanism for either input or output (depends on direction).\n\t * api_begin_io must be called before any bulk data i/o is allowed.\n\t * direction:\tEither GMT_IN or GMT_OUT.\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\n\tstruct GMT_CTRL *GMT = NULL;\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!API->registered[direction])\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_begin_io: Warning: No %s resources registered\\n\", GMT_direction[direction]);\n\t/* Passed basic sanity checks */\n\tGMT = API->GMT;\n\tAPI->io_mode[direction] = GMTAPI_BY_SET;\n\tAPI->io_enabled[direction] = true;\t/* OK to access resources */\n\tGMT->current.io.ogr = GMT_OGR_UNKNOWN;\n\tGMT->current.io.read_mixed = false;\n\tGMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);\n\tGMT->current.io.segment_header[0] = GMT->current.io.record[0] = 0;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_begin_io: %s resource access is now enabled [container]\\n\", GMT_direction[direction]);\n\n\treturn (GMT_OK);\t/* No error encountered */\n}\n\n/* Mapping of internal [row][col] indices to a single 1-D index.\n * Internally, row and col both starts at 0.  These will be accessed\n * via pointers to these functions, hence they are not macros.\n * They apply to GMT_MATRIX items, NOT grids/images with pads.\n */\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_c_normal (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C normal row-major grid */\n\treturn ((row * dim) + col);\t/* Normal scanline grid */\n}\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_c_cplx_real (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C complex row-major grid, real component */\n\treturn (2ULL*(row * dim) + col);\t/* Complex scanline grid, real(1) component */\n}\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_c_cplx_imag (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C complex row-major grid, imaginary component */\n\treturn (2ULL*(row * dim) + col + 1ULL);\t/* Complex grid, imag(2) component */\n}\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_f_normal (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran column-major grid */\n\treturn ((col * dim) + row);\n}\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_f_cplx_real (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran complex column-major grid, real component */\n\treturn (2ULL*(col * dim) + row);\t/* Complex grid, real(1) */\n}\n\n/*! . */\nGMT_LOCAL uint64_t api_2d_to_index_f_cplx_imag (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran complex column-major grid, imaginary component  */\n\treturn (2ULL*(col * dim) + row + 1ULL);\t/* Complex grid, imag(2) component */\n}\n\n/*! . */\nGMT_LOCAL p_func_uint64_t api_get_2d_to_index (struct GMTAPI_CTRL *API, enum GMT_enum_fmt shape, unsigned int mode) {\n\t/* Return pointer to the required 2D-index function above for MATRIX.  Here\n\t * shape is either GMT_IS_ROW_FORMAT (C) or GMT_IS_COL_FORMAT (Fortran);\n\t * mode is either 0 (regular grid), GMT_GRID_IS_COMPLEX_REAL (complex real) or GMT_GRID_IS_COMPLEX_IMAG (complex imag)\n\t */\n\tp_func_uint64_t p = NULL;\n\n\tswitch (mode & GMT_GRID_IS_COMPLEX_MASK) {\n\t\tcase GMT_GRID_IS_REAL:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? api_2d_to_index_c_normal : api_2d_to_index_f_normal;\n\t\t\tbreak;\n\t\tcase GMT_GRID_IS_COMPLEX_REAL:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? api_2d_to_index_c_cplx_real : api_2d_to_index_f_cplx_real;\n\t\t\tbreak;\n\t\tcase GMT_GRID_IS_COMPLEX_IMAG:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? api_2d_to_index_c_cplx_imag : api_2d_to_index_f_cplx_imag;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_get_2d_to_index: Illegal mode passed - aborting\\n\");\n\t\t\tapi_exit (API, GMT_RUNTIME_ERROR); return (NULL);\n\t}\n\treturn (p);\n}\n\n#if 0\t/* Unused at the present time */\nGMT_LOCAL void api_index_to_2d_c (int *row, int *col, size_t index, int dim, int mode) {\n\t/* Maps 1-D index to (row,col) for C */\n\tif (mode) index /= 2;\n\t*col = (index % dim);\n\t*row = (index / dim);\n}\n\nGMT_LOCAL void api_index_to_2d_f (int *row, int *col, size_t index, int dim, int mode) {\n\t/* Maps 1-D index to (row,col) for Fortran */\n\tif (mode) index /= 2;\n\t*col = (index / dim);\n\t*row = (index % dim);\n}\n#endif\n\n/* Mapping of internal [row][col][layer] indices to a single 1-D index for images.\n * Internally, row and col starts at 0.  These will be accessed\n * via pointers to these functions, hence they are not macros.\n */\n\nGMT_LOCAL uint64_t api_get_index_from_TRB (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a band-interleaved layout RRR...RGGG...GBBB...B */\n\treturn (h->pad[XLO] + col) + ((row + h->pad[YHI]) * h->mx) + (layer * h->size);\n}\n\nGMT_LOCAL uint64_t api_get_index_from_TRP (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a pixel-interleaved layout RGBRGBRGB...*/\n\treturn ((h->pad[XLO] + col) * h->n_bands) + layer + ((row + h->pad[YHI]) * h->mx * h->n_bands);\n}\n\nGMT_LOCAL uint64_t api_get_index_from_TRL (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a line-interleaved layout R...RG..GB...BR...RG...GB...B...*/\n\treturn (h->pad[XLO] + col) + (layer * h->mx) + ((row + h->pad[YHI]) * h->mx * h->n_bands);\n}\n\nGMT_LOCAL uint64_t api_get_index_from_TRS (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an default GMT grid */\n\tgmt_M_unused(layer);\n\treturn (gmt_M_ijp (h, row, col));\n}\n\nGMT_LOCAL uint64_t api_get_index_from_TRR (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index to the real component of an default complex GMT grid */\n\tgmt_M_unused(layer);\n\treturn (2ULL*gmt_M_ijp (h, row, col));\n}\n\nGMT_LOCAL uint64_t api_get_index_from_TRI (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index to the imag component of an default complex GMT grid */\n\tgmt_M_unused(layer);\n\treturn (2ULL*gmt_M_ijp (h, row, col)+1ULL);\n}\n\n/*! . */\nGMT_LOCAL unsigned int api_decode_layout (struct GMTAPI_CTRL *API, const char *code, enum GMT_enum_family *family) {\n\t/* Convert the 3-letter grid/image layout code to a single integer mode.\n\t * Defaults are TRS for grids and TRB for images. */\n\tunsigned int bits = 0;\t/* Default value */\n\t*family = GMT_IS_IMAGE;\t/* Default value, may be changed later */\n\tswitch (code[0]) {\t/* Char 1: The Y direction */\n\t\tcase 'T':\tbreak;\t\t\t /* Top-to-bottom [Default] */\n\t\tcase 'B':\tbits = 1; break; /* Bottom-to-top */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Illegal code [%c] for y-direction grid/image layout.  Must be T or B\\n\", code[0]);\n\t\t\tbreak;\n\t}\n\tswitch (code[1]) {\t/* Char 2: The storage mode (rows vs columns) */\n\t\tcase 'R':\tbreak;\t\t \t  /* rows, i.e., scanlines [Default] */\n\t\tcase 'C':\tbits |= 2; break; /* columns (e.g., Fortran) */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Illegal code [%c] for grid/image storage mode.  Must be R or C\\n\", code[1]);\n\t\t\tbreak;\n\t}\n\tswitch (code[2]) {\t/* Char 3: Grids: Single, complex-Real, complex-Imag.  Images: band interleaving mode B|L|P */\n\t\tcase 'S':\t*family = GMT_IS_GRID; break;\t/* Single-valued grid [Default] */\n\t\tcase 'R':\tbits |= 4; *family = GMT_IS_GRID; break;\t/* Real component of complex grid */\n\t\tcase 'I':\tbits |= 8; *family = GMT_IS_GRID; break;\t/* Imaginary component of complex grid */\n\t\tcase 'B':\tbreak;\t\t\t/* r/g/b separated into three bands (layers) */\n\t\tcase 'L':\tbits |= 4; break;\t/* r/g/b separated into three lines */\n\t\tcase 'P':\tbits |= 8; break;\t/* r/g/b separated into three values per pixel */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Illegal code [%c] for type of grid or image layout.  Must be SRI (grids) or BLP (images)\\n\", code[1]);\n\t\t\tbreak;\n\t}\n\treturn (bits);\n}\n\n/*! . */\nGMT_LOCAL int api_init_grid (struct GMTAPI_CTRL *API, struct GMT_OPTION *opt, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_GRID *G) {\n\tif (direction == GMT_OUT) return (GMT_OK);\t/* OK for creating a blank container for output */\n\tgmtgrdio_init_grdheader (API->GMT, direction, G->header, opt, dim, range, inc, registration, mode);\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL int api_init_image (struct GMTAPI_CTRL *API, struct GMT_OPTION *opt, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_IMAGE *I) {\n\tint alpha;\n\tif (direction == GMT_OUT) return (GMT_OK);\t/* OK for creating blank container for output */\n\talpha = (dim && (dim[GMT_Z] == 2 || dim[GMT_Z] == 4));\t/* Must allocate alpha array later */\n\tif (alpha) dim[GMT_Z]--;\t/* Remove this flag before grdheader is set */\n\tgmtgrdio_init_grdheader (API->GMT, direction, I->header, opt, dim, range, inc, registration, mode);\n\tif (alpha) dim[GMT_Z]++;\t/* Restore */\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL int api_init_matrix (struct GMTAPI_CTRL *API, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_MATRIX *M) {\n\tdouble off = 0.5 * registration;\n\tint error;\n\tunsigned int dims = (M->n_layers > 1) ? 3 : 2;\n\tsize_t size = 0;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Initializing a matrix for handing external %s [mode = %u]\\n\", GMT_direction[direction], mode);\n\tif (direction == GMT_OUT) return (GMT_OK);\t/* OK for creating blank container for output */\n\tif (full_region (range) && (dims == 2 || (!range || range[ZLO] == range[ZHI]))) {\t/* Not an equidistant vector arrangement, use dim */\n\t\tdouble dummy_range[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\t/* Flag vector as such */\n\t\tgmt_M_memcpy (M->range, dummy_range, 2 * dims, double);\n\t\tM->n_rows = dim[GMTAPI_DIM_ROW];\n\t\tM->n_columns = dim[GMTAPI_DIM_COL];\n\t}\n\telse {\t/* Was apparently given valid range and inc */\n\t\tif (!inc || (inc[GMT_X] == 0.0 && inc[GMT_Y] == 0.0)) return (GMT_VALUE_NOT_SET);\n\t\tgmt_M_memcpy (M->range, range, 2 * dims, double);\n\t\tM->n_rows    = gmt_M_get_n (API->GMT, range[YLO], range[YHI], inc[GMT_Y], off);\n\t\tM->n_columns = gmt_M_get_n (API->GMT, range[XLO], range[XHI], inc[GMT_X], off);\n\t}\n\tM->type = dim[3];\t/* Use selected data type for export */\n\tM->dim = (M->shape == GMT_IS_ROW_FORMAT) ? M->n_columns : M->n_rows;\n\tsize = M->n_rows * M->n_columns * ((size_t)M->n_layers);\t/* Size in bytes of the initial matrix allocation */\n\tif (size && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Must allocate memory */\n\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M->data), M->type, size)) != GMT_OK)\n\t\t\treturn (error);\n\t\tM->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL int api_init_vector (struct GMTAPI_CTRL *API, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_VECTOR *V) {\n\tint error;\n\tuint64_t col;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Initializing a vector for handing external %s\\n\", GMT_direction[direction]);\n\tif (direction == GMT_OUT) return (GMT_OK);\t/* OK for creating blank container for output */\n\tif (dim[GMTAPI_DIM_COL] == 0 && direction == GMT_IN) return (GMT_VALUE_NOT_SET);\t/* Must know the number of columns to do this */\n\tif (range == NULL || (range[XLO] == range[XHI])) {\t/* Not an equidistant vector arrangement, use dim */\n\t\tdouble dummy_range[2] = {0.0, 0.0};\t/* Flag vector as such */\n\t\tV->n_rows = dim[GMTAPI_DIM_ROW];\t\t/* If so, n_rows is passed via dim[GMTAPI_DIM_ROW], unless it is GMT_OUT when it is zero */\n\t\tgmt_M_memcpy (V->range, dummy_range, 2, double);\n\t}\n\telse {\t/* Equidistant vector */\n\t\tdouble off = 0.5 * registration;\n\t\tif (!inc || inc[GMT_X] == 0.0) return (GMT_VALUE_NOT_SET);\n\t\tV->n_rows = gmt_M_get_n (API->GMT, range[XLO], range[XHI], inc[GMT_X], off);\n\t\tgmt_M_memcpy (V->range, range, 2, double);\n\t}\n\tfor (col = 0; col < V->n_columns; col++)\t/* Set the same export data type for all vectors */\n\t\tV->type[col] = dim[2];\n\tif (V->n_rows && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Must allocate space */\n\t\tif ((error = api_alloc_vectors (API->GMT, V, V->n_rows)) != GMT_OK)\n\t\t\treturn (error);\n\t\tV->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL double * api_grid_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_GRID *G) {\n\treturn (gmt_grd_coord (API->GMT, G->header, dim));\n}\n\n/*! . */\nGMT_LOCAL double * api_image_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_IMAGE *I) {\n\treturn (gmt_grd_coord (API->GMT, I->header, dim));\n}\n\n/*! . */\nGMT_LOCAL double * api_matrix_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_MATRIX *M) {\n\t/* Allocate and compute coordinates along one dimension of a matrix */\n\tdouble *coord = NULL, off, inc;\n\tunsigned int min, max;\n\tuint64_t k, n;\n\n\tif (M->n_layers <= 1 && dim == GMT_Z) return (NULL);\t/* No z-dimension */\n\tn = (dim == GMT_X) ? M->n_columns : ((dim == GMT_Y) ? M->n_rows : M->n_layers);\n\tmin = 2*dim, max = 2*dim + 1;\t/* Indices into the min/max triplets in range */\n\tcoord = gmt_M_memory (API->GMT, NULL, n, double);\n\toff = 0.5 * M->registration;\n\tinc = gmt_M_get_inc (API->GMT, M->range[min], M->range[max], n, M->registration);\n\tfor (k = 0; k < n; k++) coord[k] = gmt_M_col_to_x (API->GMT, k, M->range[min], M->range[max], inc, off, n);\n\treturn (coord);\n}\n\n/*! . */\nGMT_LOCAL double * api_vector_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_VECTOR *V) {\n\t/* Allocate and compute coordinates for a vector, if equidistantly defined */\n\tunsigned int k;\n\tdouble *coord = NULL, off, inc;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_vector_coord called: dim = %d\\n\", dim);\n\tif (V->range[0] == 0.0 && V->range[1] == 0.0) return (NULL);\t/* Not an equidistant vector */\n\tcoord = gmt_M_memory (API->GMT, NULL, V->n_rows, double);\n\toff = 0.5 * V->registration;\n\tinc = gmt_M_get_inc (API->GMT, V->range[0], V->range[1], V->n_rows, V->registration);\n\tfor (k = 0; k < V->n_rows; k++) coord[k] = gmt_M_col_to_x (API->GMT, k, V->range[0], V->range[1], inc, off, V->n_rows);\n\treturn (coord);\n}\n\n/*! . */\nGMT_LOCAL void api_grdheader_to_matrixinfo (struct GMT_GRID_HEADER *h, struct GMT_MATRIX *M_obj) {\n\t/* Packs the necessary items of the grid header into the matrix parameters */\n\tM_obj->n_columns = h->n_columns;\n\tM_obj->n_rows = h->n_rows;\n\tM_obj->registration = h->registration;\n\tgmt_M_memcpy (M_obj->range, h->wesn, 4, double);\n}\n\n/*! . */\nGMT_LOCAL void api_matrixinfo_to_grdheader (struct GMT_CTRL *GMT, struct GMT_GRID_HEADER *h, struct GMT_MATRIX *M_obj) {\n\t/* Unpacks the necessary items into the grid header from the matrix parameters */\n\tgmt_M_unused(GMT);\n\th->n_columns = (unsigned int)M_obj->n_columns;\n\th->n_rows = (unsigned int)M_obj->n_rows;\n\th->registration = M_obj->registration;\n\tgmt_M_memcpy (h->wesn, M_obj->range, 4, double);\n\t/* Compute xy_off and increments */\n\th->xy_off = (h->registration == GMT_GRID_NODE_REG) ? 0.0 : 0.5;\n\th->inc[GMT_X] = gmt_M_get_inc (GMT, h->wesn[XLO], h->wesn[XHI], h->n_columns, h->registration);\n\th->inc[GMT_Y] = gmt_M_get_inc (GMT, h->wesn[YLO], h->wesn[YHI], h->n_rows, h->registration);\n}\n\n/*! . */\nGMT_LOCAL bool api_adjust_grdpadding (struct GMT_GRID_HEADER *h, unsigned int *pad) {\n\t/* Compares current grid pad status to output pad requested.  If we need\n\t * to adjust a pad we return true here, otherwise false. */\n\tunsigned int side;\n\n\tfor (side = 0; side < 4; side++) if (h->pad[side] != pad[side]) return (true);\n\treturn (false);\n}\n\n/*! . */\nGMT_LOCAL size_t api_set_grdarray_size (struct GMT_CTRL *GMT, struct GMT_GRID_HEADER *h, unsigned int mode, double *wesn) {\n\t/* Determines size of grid given grid spacing and grid domain in h.\n \t * However, if wesn is given and not empty we compute size using the sub-region instead.\n \t * Finally, the current pad is used when calculating the grid size.\n\t * NOTE: This function leaves h unchanged by testing on a temporary header. */\n\tstruct GMT_GRID_HEADER *h_tmp = NULL;\n\tsize_t size;\n\n\t/* Must duplicate header and possibly reset wesn, then set pad and recalculate all dims */\n\th_tmp = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_HEADER);\n\tgmt_M_memcpy (h_tmp, h, 1, struct GMT_GRID_HEADER);\n\th_tmp->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the mode-to-be so that if complex the size is doubled */\n\n\tif (!full_region (wesn)) {\n\t\tgmt_M_memcpy (h_tmp->wesn, wesn, 4, double);    /* Use wesn instead of header info */\n\t\tgmt_adjust_loose_wesn (GMT, wesn, h);           /* Subset requested; make sure wesn matches header spacing */\n\t\tgmt_M_memcpy(h_tmp->wesn, wesn, 4, double);\t    /* And update the eventually adjusted wesn */\n\t}\n\tgmt_M_grd_setpad (GMT, h_tmp, GMT->current.io.pad);\t/* Use the system pad setting by default */\n\tgmt_set_grddim (GMT, h_tmp);\t\t\t\t/* Computes all integer parameters */\n\tsize = h_tmp->size;\t\t\t\t\t/* This is the size needed to hold grid + padding */\n\tgmt_M_free (GMT, h_tmp);\n\treturn (size);\n}\n\n/*! . */\nGMT_LOCAL int api_open_grd (struct GMT_CTRL *GMT, char *file, struct GMT_GRID *G, char mode, unsigned int access_mode) {\n\t/* Read or write the header structure and initialize row-by-row machinery for grids.\n\t * We fill the GMT_GRID_ROWBYROW structure with all the required information.\n\t * mode can be w or r.  Upper case W or R refers to headerless\n\t * grdraster-type files.  The access_mode dictates if we automatically advance\n\t * row counter to next row after read/write or if we use the rec_no to seek\n\t * first.\n\t */\n\n\tint r_w, err;\n\tbool header = true, magic = true, alloc = false;\n\tint cdf_mode[3] = { NC_NOWRITE, NC_WRITE, NC_WRITE};\t/* These MUST be ints */\n\tchar *bin_mode[3] = { \"rb\", \"rb+\", \"wb\"};\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_ROWBYROW *R = api_get_rbr_ptr (G->extra);\t/* Shorthand to row-by-row book-keeping structure */\n\n\tif (mode == 'r' || mode == 'R') {\t/* Open file for reading */\n\t\tif (mode == 'R') {\t/* File has no header; can only work if G->header has been set already, somehow */\n\t\t\theader = false;\n\t\t\tif (G->header->n_columns == 0 || G->header->n_rows == 0) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unable to read header-less grid file %s without a preset header structure\\n\", file);\n\t\t\t\treturn (GMT_GRDIO_OPEN_FAILED);\n\t\t\t}\n\t\t}\n\t\tr_w = 0;\tmode = 'r';\n\t}\n\telse if (mode == 'W') {\t/* Write headerless grid */\n\t\tr_w = 2;\tmode = 'w';\n\t\theader = magic = false;\n\t}\n\telse {\t/* Regular writing of grid with header */\n\t\tr_w = 1;\n\t\tmagic = false;\n\t}\n\tif (header) {\n\t\tif (mode == 'r' && !R->open)\t/* First time reading the info */\n\t\t\tgmtlib_read_grd_info (GMT, file, G->header);\n\t\telse if (R->open)\t\t/* Coming back to update the header */\n\t\t\tgmt_update_grd_info (GMT, file, G->header);\n\t\telse\t\t\t\t/* First time writing the header */\n\t\t\tgmtlib_write_grd_info (GMT, file, G->header);\n\t}\n\telse /* Fallback to existing header */\n\t\tgmt_M_err_trap (gmt_grd_get_format (GMT, file, G->header, magic));\n\tif (R->open) return (GMT_NOERROR);\t/* Already set the first time */\n\tfmt = GMT->session.grdformat[G->header->type];\n\tif (fmt[0] == 'c') {\t\t/* Open netCDF file, old format */\n\t\tgmt_M_err_trap (nc_open (G->header->name, cdf_mode[r_w], &R->fid));\n\t\tR->edge[0] = G->header->n_columns;\n\t\tR->start[0] = 0;\n\t\tR->start[1] = 0;\n\t}\n\telse if (fmt[0] == 'n') {\t/* Open netCDF file, COARDS-compliant format */\n\t\tgmt_M_err_trap (nc_open (G->header->name, cdf_mode[r_w], &R->fid));\n\t\tR->edge[0] = 1;\n\t\tR->edge[1] = G->header->n_columns;\n\t\tR->start[0] = G->header->row_order == k_nc_start_north ? 0 : G->header->n_rows-1;\n\t\tR->start[1] = 0;\n\t}\n\telse {\t\t/* Regular binary file with/w.o standard GMT header, or Sun rasterfile */\n\t\tif (r_w == 0) {\t/* Open for plain reading */\n\t\t\tif ((R->fp = gmt_fopen (GMT, G->header->name, bin_mode[0])) == NULL)\n\t\t\t\treturn (GMT_GRDIO_OPEN_FAILED);\n\t\t}\n\t\telse if ((R->fp = gmt_fopen (GMT, G->header->name, bin_mode[r_w])) == NULL)\n\t\t\treturn (GMT_GRDIO_CREATE_FAILED);\n\t\t/* Seek past the grid header, unless there is none */\n\t\tif (header && fseek (R->fp, (off_t)GMT_GRID_HEADER_SIZE, SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\talloc = (fmt[1] != 'f');\t/* Only need to allocate the v_row array if grid is not float */\n#ifdef DEBUG\n\t\tR->pos = ftell (R->fp);\t/* Where we are */\n#endif\n\t}\n\n\tR->size = gmt_grd_data_size (GMT, G->header->type, &G->header->nan_value);\n\tR->check = !isnan (G->header->nan_value);\n\tR->open = true;\n\n\tif (fmt[1] == 'm')\t/* Bit mask */\n\t\tR->n_byte = lrint (ceil (G->header->n_columns / 32.0)) * R->size;\n\telse if (fmt[0] == 'r' && fmt[1] == 'b')\t/* Sun Raster uses multiple of 2 bytes */\n\t\tR->n_byte = lrint (ceil (G->header->n_columns / 2.0)) * 2 * R->size;\n\telse\t/* All other */\n\t\tR->n_byte = G->header->n_columns * R->size;\n\n\tif (alloc) R->v_row = gmt_M_memory (GMT, NULL, R->n_byte, char);\n\n\tR->row = 0;\n\tR->auto_advance = (access_mode & GMT_GRID_ROW_BY_ROW_MANUAL) ? false : true;\t/* Read sequentially or random-access rows */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL void api_update_txt_item (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, size_t length, char string[]) {\n\t/* Place desired text in string (fixed size array) which can hold up to length bytes */\n\tsize_t lim;\n\tstatic char buffer[GMT_BUFSIZ];\n\tchar *txt = (mode & GMT_COMMENT_IS_OPTION) ? GMT_Create_Cmd (API, arg) : (char *)arg;\n\tgmt_M_memset (buffer, GMT_BUFSIZ, char);\t/* Start with a clean slate */\n\tif ((mode & GMT_COMMENT_IS_OPTION) == 0 && (mode & GMT_COMMENT_IS_RESET) == 0 && string[0])\n\t\tstrncat (buffer, string, length-1);\t/* Use old text if we are not resetting */\n\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\tif (mode & GMT_COMMENT_IS_OPTION) {\t/* Must start with module name since it is not part of the option args */\n\t\tstrncat (buffer, API->GMT->init.module_name, lim);\n\t\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\t\tstrncat (buffer, \" \", lim);\n\t}\n\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\tstrncat (buffer, txt, lim);\t\t/* Append new text */\n\tgmt_M_memset (string, length, char);\t/* Wipe string completely */\n\tstrncpy (string, buffer, length);\t/* Only copy over max length bytes */\n\tif (mode & GMT_COMMENT_IS_OPTION) gmt_M_free (API->GMT, txt);\n}\n\n/*! . */\nGMT_LOCAL void api_GI_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_GRID_HEADER *H) {\n\t/* Replace or Append either command or remark field with text or commmand-line options */\n\tif (mode & GMT_COMMENT_IS_REMARK) \tapi_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  H->remark);\n\telse if (mode & GMT_COMMENT_IS_COMMAND) api_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, H->command);\n\telse if (mode & GMT_COMMENT_IS_TITLE)   api_update_txt_item (API, mode, arg, GMT_GRID_TITLE_LEN80,    H->title);\n\telse if (mode & GMT_COMMENT_IS_NAME_X)  api_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->x_units);\n\telse if (mode & GMT_COMMENT_IS_NAME_Y)  api_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->y_units);\n\telse if (mode & GMT_COMMENT_IS_NAME_Z)  api_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->z_units);\n}\n\n/*! Replace or Append either command or remark field with text or commmand-line options */\nGMT_LOCAL void api_grid_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_GRID *G) {\n\tapi_GI_comment (API, mode, arg, G->header);\n}\n\n/*! Update either command or remark field with text or commmand-line options */\nGMT_LOCAL void api_image_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_IMAGE *I) {\n\tapi_GI_comment (API, mode, arg, I->header);\n}\n\n/*! Update either command or remark field with text or commmand-line options */\nGMT_LOCAL void api_vector_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_VECTOR *V) {\n\tif (mode & GMT_COMMENT_IS_REMARK)  api_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  V->remark);\n\tif (mode & GMT_COMMENT_IS_COMMAND) api_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, V->command);\n}\n\n/*! Update either command or remark field with text or commmand-line options */\nGMT_LOCAL void api_matrix_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_MATRIX *M) {\n\tif (mode & GMT_COMMENT_IS_REMARK)  api_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  M->remark);\n\tif (mode & GMT_COMMENT_IS_COMMAND) api_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, M->command);\n}\n\n/*! Update common.h's various text items; return 1 if successful else 0 */\nGMT_LOCAL int api_add_comment (struct GMTAPI_CTRL *API, unsigned int mode, char *txt) {\n\tunsigned int k = 0;\n\tstruct GMT_COMMON *C = &API->GMT->common;\t/* Short-hand to the common arg structs */\n\n\tif (mode & GMT_COMMENT_IS_TITLE)  { gmt_M_str_free (C->h.title); C->h.title = strdup (txt); k++; }\n\tif (mode & GMT_COMMENT_IS_REMARK) { gmt_M_str_free (C->h.remark); C->h.remark = strdup (txt); k++; }\n\tif (mode & GMT_COMMENT_IS_COLNAMES) { gmt_M_str_free (C->h.colnames); C->h.colnames = strdup (txt); k++; }\n\treturn (k);\t/* 1 if we did any of the three above; 0 otherwise */\n}\n\n/*! Append or replace data table headers with given text or commmand-line options */\nGMT_LOCAL void api_dataset_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_DATASET *D) {\n\tunsigned int tbl, k;\n\tstruct GMT_DATATABLE *T = NULL;\n\tchar *txt = gmtapi_create_header_item (API, mode, arg);\n\n\tif (api_add_comment (API, mode, txt)) return;\t/* Updated one -h item, or nothing */\n\n\tif (D->table == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_dataset_comment: Trying to access an empty D->table object\\n\");\n\t\treturn;\n\t}\n\n\t/* Here we process free-form comments; these go into the dataset's header structures */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\t/* For each table in the dataset */\n\t\tT = D->table[tbl];\t/* Short-hand for this table */\n\t\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\t\tfor (k = 0; k < T->n_headers; k++) gmt_M_str_free (T->header[k]);\n\t\t\tT->n_headers = 0;\n\t\t}\n\t\tT->header = gmt_M_memory (API->GMT, T->header, T->n_headers + 1, char *);\n\t\tT->header[T->n_headers++] = strdup (txt);\n\t}\n}\n\n/*! Append or replace text table headers with given text or commmand-line options */\nGMT_LOCAL void api_textset_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_TEXTSET *D) {\n\tunsigned int tbl, k;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tchar *txt = gmtapi_create_header_item (API, mode, arg);\n\n\tif (api_add_comment (API, mode, txt)) return;\t/* Updated one -h item or nothing */\n\n\tif (D->table == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_textset_comment: Trying to access an empty D->table object\\n\");\n\t\treturn;\n\t}\n\n\t/* Here we process free-form comments; these go into the textset's header structures */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\t/* For each table in the dataset */\n\t\tT = D->table[tbl];\t/* Short-hand for this table */\n\t\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\t\tfor (k = 0; k < T->n_headers; k++) gmt_M_str_free (T->header[k]);\n\t\t\tT->n_headers = 0;\n\t\t}\n\t\tT->header = gmt_M_memory (API->GMT, T->header, T->n_headers + 1, char *);\n\t\tT->header[T->n_headers++] = strdup (txt);\n\t}\n}\n\n/*! Append or replace CPT headers with given text or commmand-line options */\nGMT_LOCAL void api_cpt_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_PALETTE *P) {\n\tunsigned int k;\n\tchar *txt = gmtapi_create_header_item (API, mode, arg);\n\n\tif (!api_add_comment (API, mode, txt)) return;\t/* Updated one -h item or nothing */\n\n\t/* Here we process free-form comments; these go into the CPT's header structures */\n\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\tfor (k = 0; k < P->n_headers; k++) gmt_M_str_free (P->header[k]);\n\t\tP->n_headers = 0;\n\t}\n\tP->header = gmt_M_memory (API->GMT, P->header, P->n_headers + 1, char *);\n\tP->header[P->n_headers++] = strdup (txt);\n}\n\n/*! Append or replace Postscript container headers with given text or commmand-line options */\nGMT_LOCAL void api_ps_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_POSTSCRIPT *P) {\n\tunsigned int k;\n\tchar *txt = gmtapi_create_header_item (API, mode, arg);\n\n\tif (!api_add_comment (API, mode, txt)) return;\t/* Updated one -h item or nothing */\n\n\t/* Here we process free-form comments; these go into the CPT's header structures */\n\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\tfor (k = 0; k < P->n_headers; k++) gmt_M_str_free (P->header[k]);\n\t\tP->n_headers = 0;\n\t}\n\tP->header = gmt_M_memory (API->GMT, P->header, P->n_headers + 1, char *);\n\tP->header[P->n_headers++] = strdup (txt);\n}\n\nGMT_LOCAL unsigned int api_set_method (struct GMTAPI_DATA_OBJECT *S) {\n\t/* Most objects have a one-to-one path but for vectors and matrices\n\t * we need to set the bit that correspond to their type */\n\tunsigned int m;\n\tif (S->method < GMT_IS_DUPLICATE) return S->method;\n\tswitch (S->actual_family) {\n\t\tcase GMT_IS_VECTOR: m = S->method | GMT_VIA_VECTOR; break;\n\t\tcase GMT_IS_MATRIX: m = S->method | GMT_VIA_MATRIX; break;\n\t\tdefault: m = S->method;\n\t}\n\treturn m;\n}\n\n/*! . */\nGMT_LOCAL int api_next_io_source (struct GMTAPI_CTRL *API, unsigned int direction) {\n\t/* Get ready for the next source/destination (open file, initialize counters, etc.).\n\t * Note this is only a mechanism for dataset and textset files where it is common\n\t * to give many files on the command line (e.g., *.txt) and we do rec-by-rec processing.\n\t * Not used by modules who read entire datasets in one go via GMT_{Read|Write}_Data,\n\t * such as grids, images, palettes, postscript, but also datasets and texsets when\n\t * GMT_Read_Data are used.  This section is strictly related to GMT_Get_Record. */\n\n\tint *fd = NULL;\t/* !!! This MUST be int* due to nature of UNIX system function */\n\tunsigned int method, kind, first = 0;\n\tstatic const char *dir[2] = {\"from\", \"to\"};\n\tstatic const char *operation[3] = {\"Reading\", \"Writing\", \"Appending\"};\n\tchar *mode = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tS_obj = API->object[API->current_item[direction]];\t/* For shorthand purposes only */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_next_io_source: Selected object %d\\n\", S_obj->ID);\n    gmt_M_memset (GMT->current.io.curr_pos[direction], 4U, int64_t);\t/* Reset file, seg, point, header counters */\n    if (direction == GMT_IN) {\t/* Set reading mode */\n\t\tmode = GMT->current.io.r_mode;\n\t\tGMT->current.io.curr_pos[GMT_IN][GMT_SEG] = -1;\t/* First segment of input is set to -1 until first segment header have been dealt with */\n\t}\n\telse\t/* Set writing mode (but could be changed to append if GMT_IS_FILE and filename starts with >) */\n\t\tmode = GMT->current.io.w_mode;\n\tS_obj->close_file = false;\t/* Do not want to close file pointers passed to us unless WE open them below */\n\t/* Either use binary n_columns settings or initialize to unknown if ascii input, i.e., GMT_MAX_COLUMNS */\n\tS_obj->n_expected_fields = (GMT->common.b.ncol[direction]) ? GMT->common.b.ncol[direction] : GMT_MAX_COLUMNS;\n\n\tmethod = api_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as DATASET */\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\t/* Filename given; we must open the file here */\n\t\t\tassert (S_obj->filename != NULL);\n\t\t\tif (S_obj->family == GMT_IS_GRID || S_obj->family == GMT_IS_IMAGE) return (gmtapi_report_error (API, GMT_NOT_A_VALID_TYPE));\t/* Grids or images not allowed here */\n\t\t\tfirst = gmt_download_file_if_not_found (API->GMT, S_obj->filename);\t/* Deal with downloadable GMT data sets first */\n\t\t\tif (direction == GMT_OUT && S_obj->filename[0] == '>') {\n\t\t\t\tmode = GMT->current.io.a_mode;\t/* Must append to an existing file (we have already checked the file exists) */\n\t\t\t\tfirst = 1;\n\t\t\t}\n\t\t\tif ((S_obj->fp = gmt_fopen (GMT, &(S_obj->filename[first]), mode)) == NULL) {\t/* Trouble opening file */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s for %s\\n\", &(S_obj->filename[first]), GMT_direction[direction]);\n\t\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t\t}\n\t\t\tS_obj->close_file = true;\t/* We do want to close files we are opening, but later */\n\t\t\tstrncpy (GMT->current.io.filename[direction], &(S_obj->filename[first]), GMT_BUFSIZ-1);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s file %s\\n\",\n\t\t\t\toperation[direction+first], GMT_family[S_obj->family], dir[direction], &(S_obj->filename[first]));\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s %d bytes of header %s binary file %s\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], &(S_obj->filename[first]));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_STREAM:\t/* Given a stream; no need to open (or close) anything */\n#ifdef SET_IO_MODE\n\t\t\tif (S_obj->family == GMT_IS_DATASET && S_obj->fp == GMT->session.std[direction])\n\t\t\t\tgmt_setmode (GMT, (int)direction);\t/* Windows may need to have its read mode changed from text to binary */\n#endif\n\t\t\tkind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;\t/* For message only: 0 if stdin/out, 1 otherwise for user pointer */\n\t\t\tsnprintf (GMT->current.io.filename[direction], GMT_BUFSIZ, \"<%s %s>\", GMT_stream[kind], GMT_direction[direction]);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s %s %s stream\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_stream[kind], GMT_direction[direction]);\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s %d bytes of header %s binary %s stream\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_FDESC:\t/* Given a pointer to a file handle; otherwise same as stream */\n\t\t\tfd = (int *)S_obj->fp;\t/* Extract the file handle integer */\n\t\t\tif ((S_obj->fp = fdopen (*fd, mode)) == NULL) {\t/* Reopen handle as stream */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file descriptor %d for %s\\n\", *fd, GMT_direction[direction]);\n\t\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t\t}\n\t\t\tS_obj->method = S_obj->method - GMT_IS_FDESC + GMT_IS_STREAM;\t/* Since fp now holds stream pointer an we have lost the handle */\n\t\t\tkind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;\t/* For message only: 0 if stdin/out, 1 otherwise for user pointer */\n\t\t\tsnprintf (GMT->current.io.filename[direction], GMT_BUFSIZ, \"<%s %s>\", GMT_stream[kind], GMT_direction[direction]);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s %s %s stream via supplied file descriptor\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_stream[kind], GMT_direction[direction]);\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s %d bytes of header %s binary %s stream via supplied file descriptor\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Copy, nothing to do [PW: not tested] */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s memory copy supplied by pointer\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction]);\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* Reference, nothing to do [PW: not tested] */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s memory reference supplied by pointer\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction]);\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* These 2 mean reading or writing a dataset record-by-record via a user matrix */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\tif (S_obj->family != GMT_IS_DATASET) return (gmtapi_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s %s memory location via matrix\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_direction[direction]);\n\t\t\tif (direction == GMT_IN) {\t/* Hard-wired limits are passed in from calling program; for outout we have nothing yet */\n\t\t\t\tif ((M_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: api_next_io_source got a matrix pointer that is NULL!!!\\n\");\n\t\t\t\t\treturn GMT_OK;\n\t\t\t\t}\n\t\t\t\tS_obj->n_rows    = M_obj->n_rows;\n\t\t\t\tS_obj->n_columns = M_obj->n_columns;\n\t\t\t\tS_obj->rec = 0;\t/* Start of this \"file\" */\n\t\t\t\tGMT->common.b.ncol[direction] = M_obj->n_columns;\t/* Basically doing binary i/o with specified number of columns */\n\t\t\t}\n\t\t\tGMT->common.b.active[direction] = true;\t/* Basically, we are doing what GMT calls binary i/o since it is all in memory */\n\t\t\tstrcpy (GMT->current.io.filename[direction], \"<matrix memory>\");\n\t\t\tbreak;\n\n\t\t case GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* These 2 mean reading or writing a dataset record-by-record via user vector arrays */\n\t\t case GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tif (S_obj->family != GMT_IS_DATASET) return (gmtapi_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"%s %s %s %s memory location via vector\\n\",\n\t\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_direction[direction]);\n\t\t\tif (direction == GMT_IN) {\t/* Hard-wired limits are passed in from calling program; for outout we have nothing yet */\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: api_next_io_source got a vector pointer that is NULL!!!\\n\");\n\t\t\t\t\treturn GMT_OK;\n\t\t\t\t}\n\t\t\t\tS_obj->n_rows    = V_obj->n_rows;\n\t\t\t\tS_obj->n_columns = V_obj->n_columns;\n\t\t\t\tS_obj->rec = 0;\t/* Start of this \"file\" */\n\t\t\t\tGMT->common.b.ncol[direction] = V_obj->n_columns;\t/* Basically doing binary i/o with specified number of columns */\n\t\t\t}\n\t\t\tGMT->common.b.active[direction] = true;\t/* Basically, we are doing what GMT calls binary i/o */\n\t\t\tstrcpy (GMT->current.io.filename[direction], \"<vector memory>\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: api_next_io_source called with illegal method\\n\");\n\t\t\tbreak;\n\t}\n\n\t/* A few things pertaining only to data/text tables */\n\tGMT->current.io.rec_in_tbl_no = 0;\t/* Start on new table */\n\tS_obj->import = (S_obj->family == GMT_IS_TEXTSET) ? &gmtio_ascii_textinput : GMT->current.io.input;\t/* The latter may point to ASCII or binary input functions */\n\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL int api_next_data_object (struct GMTAPI_CTRL *API, enum GMT_enum_family family, enum GMT_enum_std direction) {\n\t/* Sets up current_item to be the next unused item of the required direction; or return EOF.\n\t * When EOF is returned, API->current_item[direction] holds the last object ID used. */\n\tbool found = false;\n\tint item = API->current_item[direction] + 1;\t/* Advance to next item, if it exists */\n\twhile (item < (int)API->n_objects && !found) {\n\t\tif (API->object[item] && API->object[item]->selected && API->object[item]->status == GMT_IS_UNUSED\n\t\t    && API->object[item]->direction == direction && family == API->object[item]->family)\n\t\t\tfound = true;\t/* Got item that is selected and unused, has correct direction and family */\n\t\telse\n\t\t\titem++;\t/* No, keep looking */\n\t}\n\tif (found) {\t/* Update to use next item */\n\t\tAPI->current_item[direction] = item;\t/* The next item */\n\t\treturn (api_next_io_source (API, direction));\t/* Initialize the next source/destination */\n\t}\n\telse\n\t\treturn (EOF);\t/* No more objects available for this direction; return EOF */\n}\n\n/*! Hook object to end of linked list and assign unique id (> 0) which is returned */\nGMT_LOCAL int api_add_data_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *object) {\n\t/* Find the first entry in the API->object array which is unoccupied, and if\n\t * they are all occupied then reallocate the array to make more space.\n\t * We thus find and return the lowest available ID. */\n\tAPI->n_objects++;\t\t/* Must add one more entry to the tally */\n\tif (API->n_objects == API->n_objects_alloc) {\t/* Must allocate more space to hold all data descriptors */\n\t\tsize_t old_n_alloc = API->n_objects_alloc;\n\t\tAPI->n_objects_alloc <<= 1;\t/* Double it */\n\t\tAPI->object = gmt_M_memory (API->GMT, API->object, API->n_objects_alloc, struct GMTAPI_DATA_OBJECT *);\n\t\tif (!(API->object)) {\t\t/* Failed to allocate more memory */\n\t\t\tAPI->n_objects--;\t/* Undo our premature increment */\n\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\n\t\t}\n\t\telse\t/* Set new ones to NULL */\n\t\t\tgmt_M_memset (&(API->object[old_n_alloc]), API->n_objects_alloc - old_n_alloc, struct GMTAPI_DATA_OBJECT *);\n\t}\n\tobject->ID = API->unique_ID++;\t/* Assign a unique object ID */\n\tAPI->object[API->n_objects-1] = object;\t\t/* Hook the current object onto the end of the list */\n\n\treturn (object->ID);\n}\n\n/*! Sanity check that geometry and family are compatible; note they may not be set (GMT_NOTSET) hence the use of signed ints */\nGMT_LOCAL bool api_validate_geometry (struct GMTAPI_CTRL *API, int family, int geometry) {\n\tbool problem = false;\n\tgmt_M_unused(API);\n\tif (geometry == GMT_NOTSET || family == GMT_NOTSET) return false;\t/* No errors if nothing to check yet */\n\tswitch (family) {\n\t\tcase GMT_IS_TEXTSET:     if (!(geometry == GMT_IS_NONE || (geometry & GMT_IS_PLP))) problem = true; break;\t/* Textsets can hold many things... */\n\t\tcase GMT_IS_DATASET:     if (!(geometry == GMT_IS_NONE || (geometry & GMT_IS_PLP))) problem = true; break;\t/* Datasets can hold many things... */\n\t\tcase GMT_IS_GRID:        if (geometry != GMT_IS_SURFACE) problem = true;    break;\t/* Only surface is valid */\n\t\tcase GMT_IS_IMAGE:       if (geometry != GMT_IS_SURFACE) problem = true;    break;\t/* Only surface is valid */\n\t\tcase GMT_IS_PALETTE:     if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t\tcase GMT_IS_POSTSCRIPT:  if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t\tcase GMT_IS_VECTOR:      if ((geometry & GMT_IS_PLP) == 0) problem = true;  break; \t/* Must be one of those three */\n\t\tcase GMT_IS_MATRIX:      if (geometry == GMT_IS_NONE) problem = true;       break;\t/* Matrix can hold surfaces or TEXTSETs */\n\t\tcase GMT_IS_COORD:       if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t}\n\treturn (problem);\n}\n\n/*! . */\nGMT_LOCAL int api_decode_id (const char *filename) {\n\t/* Checking if filename contains a name with embedded GMTAPI Object ID.\n\t * If found we return the ID, otherwise we return GMT_NOTSET.\n \t*/\n\tint object_ID = GMT_NOTSET;\n\n\tif (gmt_M_file_is_memory (filename)) {\t/* Passing ID of a registered object */\n\t\tif (sscanf (&filename[9], \"%d\", &object_ID) != 1) return (GMT_NOTSET);\t/* Get the object ID unless we fail scanning */\n\t}\n\treturn (object_ID);\t/* Returns GMT_NOTSET if no embedded ID was found */\n}\n\n/*! . */\nGMT_LOCAL int api_get_object (struct GMTAPI_CTRL *API, int sfamily, void *ptr) {\n\t/* Returns the ID of the first object whose data pointer matches ptr.\n\t * Unless family is GMT_NOTSET the object must be of the specified family.\n\t */\n\tunsigned int item;\n\tenum GMT_enum_family family = GMT_NOTSET;\n\tint object_ID = GMT_NOTSET;\t/* Not found yet */\n\n\tif (sfamily != GMT_NOTSET) family = sfamily;\n\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\tif (!API->object[item]) continue;\t/* Skip freed objects */\n\t\tif (API->object[item]->data == NULL) continue;\t/* No data pointer */\n\t\tif (sfamily != GMT_NOTSET && API->object[item]->family != family) continue;\t/* Not the right family */\n\t\tif (API->object[item]->data == ptr && object_ID == GMT_NOTSET) object_ID = API->object[item]->ID;\t/* Found a matching data pointer */\n\t}\n\treturn (object_ID);\t/* Return ID or GMT_NOTSET if not found */\n}\n\n/*! . */\nGMT_LOCAL void *api_pass_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *object, unsigned int family, double *wesn) {\n\t/* Passes back the input object pointer after possibly performing some minor adjustments to metadata.\n\t * For grids and images we must worry about possible subset requests */\n\tvoid *data = (object->data) ? object->data : object->resource;\t/* Get pointer to the data TEMPORARY: SHOULD BE data, NO? */\n\tstruct GMT_GRID    *G = NULL;\n\tstruct GMT_IMAGE   *I = NULL;\n\tstruct GMT_DATASET *D = NULL;\n\n\tif (object->resource && object->data && (object->resource != object->data))\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"ERROR?: api_pass_object given resource = %\" PRIxS \" and data = %\" PRIxS \" and cannot choose sensibly: data was selected\\n\", object->resource, object->data);\n\n\tswitch (family) {\t/* Do family-specific prepping before passing back the input object */\n\t\tcase GMT_IS_PALETTE:\t/* Make sure the hidden support arrays etc. have been initialized as external interfaces may not care */\n\t\t\tif (data) gmtlib_init_cpt (API->GMT, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\t/* Grids need to update the grdtype setting, possibly rotate geographic grids, and maybe deal with subsets */\n\t\t\tG = api_get_grid_data (data);\t/* Get the right grid pointer */\n\t\t\tgmtlib_grd_get_units (API->GMT, G->header);\t/* Set the unit names */\n\t\t\tG->header->grdtype = gmtlib_get_grdtype (API->GMT, GMT_IN, G->header);\n\t\t\tif (wesn && G->data) {\t/* Subset or global rotation was requested */\n\t\t\t\tif (gmt_M_grd_is_global (API->GMT, G->header)) {\t/* May have to rotate a geographic grid since we are not reading from file this time */\n\t\t\t\t\tdouble shift_amount = wesn[XLO] - G->header->wesn[XLO];\n\t\t\t\t\tif (fabs (shift_amount) >= G->header->inc[GMT_X]) {\t/* Must do it */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shifting longitudes in grid by %g degrees to fit -R\\n\", shift_amount);\n\t\t\t\t\t\tgmt_grd_shift (API->GMT, G, shift_amount);\t/* In-memory rotation */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (object->region) {\t/* Possibly adjust the pad so inner region matches requested wesn */\n\t\t\t\t\t/* NOTE: This assumes the memory cannot be adjusted. Probably should distinaguish between GMT_IS_REFERENCE and GMT_IS_DUPLICATE\n\t\t\t\t\t * and offer different behavior.  As it is we assume read-only grids */\n\t\t\t\t\tif (object->reset_pad) {\t/* First undo any prior sub-region used with this memory grid */\n\t\t\t\t\t\tgmtlib_contract_headerpad (API->GMT, G->header, object->orig_pad, object->orig_wesn);\n\t\t\t\t\t\tobject->reset_pad = G->header->reset_pad = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Then apply the new pad adjustment.  Basically we cannot mess with the data so we change what constitute the pad */\n\t\t\t\t\tif (gmtlib_expand_headerpad (API->GMT, G->header, object->wesn, object->orig_pad, object->orig_wesn))\n\t\t\t\t\t\tobject->reset_pad = G->header->reset_pad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (API->GMT, G->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (API->GMT, gmt_grd_BC_set (API->GMT, G, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Failed to set boundary conditions */\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* Images need to update the grdtype setting, possibly rotate geographic grids, and maybe deal with subsets */\n\t\t\tI = api_get_image_data (data);\t/* Get the right image pointer */\n\t\t\tgmtlib_grd_get_units (API->GMT, I->header);\t/* Set the unit names */\n\t\t\tI->header->grdtype = gmtlib_get_grdtype (API->GMT, GMT_IN, I->header);\n\t\t\tif (wesn && I->data) {\t/* Subset or global rotation was requested */\n\t\t\t\tif (gmt_M_grd_is_global (API->GMT, I->header)) {\t/* May have to rotate geographic grid since we are not reading from file here */\n\t\t\t\t\tdouble shift_amount = wesn[XLO] - I->header->wesn[XLO];\n\t\t\t\t\tif (fabs (shift_amount) >= I->header->inc[GMT_X]) {\t/* Must do it */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Longitudinal roll for images not implemented yet\\n\");\n#if 0\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shifting longitudes in grid by %g degrees to fit -R\\n\", shift_amount);\n\t\t\t\t\t\tgmt_grd_shift (API->GMT, I, shift_amount);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (object->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\t\t/* NOTE: This assumes the memory cannot be adjusted. Probably should distinaguish between GMT_IS_REFERENCE and GMT_IS_DUPLICATE\n\t\t\t\t\t * and offer different behavior.  As it is we assume read-only images */\n\t\t\t\t\tif (object->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\t\tgmtlib_contract_headerpad (API->GMT, I->header, object->orig_pad, object->orig_wesn);\n\t\t\t\t\t\tobject->reset_pad = I->header->reset_pad = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Then apply the new pad adjustment.  Basically we cannot mess with the data so we change what constitute the pad */\n\t\t\t\t\tif (gmtlib_expand_headerpad (API->GMT, I->header, object->wesn, object->orig_pad, object->orig_wesn))\n\t\t\t\t\t\tobject->reset_pad = I->header->reset_pad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (API->GMT, I->header);\t/* Initialize image interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (API->GMT, gmtlib_image_BC_set (API->GMT, I), \"Image memory\"))\n\t\t\t\treturn_null (API, GMT_IMAGE_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* Just make sure the min/max values are updated for tables and dataset  */\n\t\t \tD = api_get_dataset_data (data);\t/* Get the right dataset pointer */\n\t\t\tgmtlib_set_dataset_minmax (API->GMT, D);\t/* Set the min/max values for the entire dataset */\n\t\t\tbreak;\n\t\tdefault:\t/* Nothing yet for other types */\n\t\t\tbreak;\n\t}\n\treturn (data);\n}\n\n/*! . */\nGMT_LOCAL int api_get_object_id_from_data_ptr (struct GMTAPI_CTRL *API, void *ptr) {\n\t/* Returns the ID of the first object whose data pointer matches *ptr.\n \t * This is necessary since many objects may have the same pointer\n\t * but we only want to destroy the memory once.  This function is\n\t * only used in GMT_Destroy_Data and gmtlib_is_an_object.\n\t */\n\tunsigned int item;\n\tint object_ID = GMT_NOTSET;\t/* Not found yet */\n\tvoid *data = NULL;\n\n\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\tif (!API->object[item]) continue;\t/* Skip freed objects */\n\t\tdata = api_return_address (ptr, API->object[item]->family);\t/* Get void* pointer to resource of this family */\n\t\t//if (API->object[item]->data == data && object_ID == GMT_NOTSET) object_ID = API->object[item]->ID;\t/* Found a matching data pointer */\n\t\t/* Try to look for either data or resource pointers since Open_VirtualFile shuffles these two and Destroy needs to find them even if the\n\t\t * function level test will tell it not to free anything */\n\t\tif (object_ID == GMT_NOTSET && (API->object[item]->data == data || API->object[item]->resource == data)) object_ID = API->object[item]->ID;\t/* Found a matching data pointer */\n\t}\n\treturn (object_ID);\t/* Return ID or GMT_NOTSET if not found */\n}\n\n/*! . */\nbool gmtlib_is_an_object (struct GMT_CTRL *GMT, void *ptr) {\n\t/* Needed by g*math.c so exported as part of the gmt_dev library */\n\treturn (api_get_object_id_from_data_ptr (GMT->parent, ptr) == GMT_NOTSET) ? false : true;\n}\n\n/*! . */\nGMT_LOCAL int api_is_registered (struct GMTAPI_CTRL *API, enum GMT_enum_family family, enum GMT_enum_geometry geometry, enum GMT_enum_std direction, unsigned int mode, char *filename, void *resource) {\n\t/* Checks to see if the given data pointer has already been registered.\n \t * This can happen for grids which first gets registered reading the header\n \t * and then is registered again when reading the whole grid.  In those cases\n\t * we don't want to register them twice.\n\t */\n\tunsigned int i;\n\tint item;\n\n\tif (API->n_objects == 0) return (GMT_NOTSET);\t/* There are no known resources yet */\n\n\t /* Search for the object in the active list.  However, if object_ID == GMT_NOTSET we instead pick the first in that direction */\n\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t/* Skip empty objects */\n\t\tif (API->object[i]->status != GMT_IS_UNUSED) {\t/* Has already been read - do we wish to reset this status ? */\n\t\t\tif (family == GMT_IS_GRID && (mode & GMT_DATA_ONLY)) {\t/* Requesting data only means we already did the header so OK to reset status */\n\t\t\t\tif (mode & GMT_GRID_IS_COMPLEX_MASK) {\t/* Complex grids are read in stages so handled separately */\n\t\t\t\t\t/* Check if complex grid already has one layer and that we are reading the next layer */\n\t\t\t\t\tstruct GMT_GRID *G = api_get_grid_data (resource);\t/* Get pointer to this grid */\n\t\t\t\t\tunsigned int cmplx = mode & GMT_GRID_IS_COMPLEX_MASK;\n\t\t\t\t\tif (G->header->complex_mode & GMT_GRID_IS_COMPLEX_MASK && G->header->complex_mode != cmplx && filename) {\n\t\t\t\t\t\t/* Apparently so, either had real and now getting imag, or vice versa. */\n\t\t\t\t\t\tgmt_M_str_free (API->object[i]->filename);\t/* Free previous grid name and replace with current name */\n\t\t\t\t\t\tAPI->object[i]->filename = strdup (filename);\n\t\t\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the 2nd component grid */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\t/* Just read the header earlier, do the reset */\n\t\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the grid data */\n\t\t\t}\n\t\t\telse if (family == GMT_IS_IMAGE && (mode & GMT_DATA_ONLY))\t/* Requesting data only means we already did the header so OK to reset status */\n\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the image data */\n\n\t\t\tif (!(mode & GMT_IO_RESET)) continue;\t/* No reset above so we refuse to do the work */\n\t\t\tAPI->object[i]->status = GMT_IS_UNUSED;\t/* Reset so we may continue to read it */\n\t\t}\n\t\tif (API->object[i]->direction != direction) continue;\t/* Wrong direction */\n\t\tif (API->object[i]->family != family) continue;\t\t/* Wrong family */\n\t\tif (API->object[i]->geometry != geometry) continue;\t/* Wrong geometry */\n\t\tif (resource && API->object[i]->resource == resource) item = API->object[i]->ID;\t/* Yes: already registered NOTE PW: One of these may not be needed? */\n\t\telse if (resource && API->object[i]->data == resource) item = API->object[i]->ID;\t/* Yes: already registered */\n\t}\n\treturn (item);\t\t/* The ID of the object (or GMT_NOTSET) */\n}\n\n/*! . */\nGMT_LOCAL struct GMT_PALETTE * api_import_palette (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a CPT palette table.\n \t * The mode controls how the back-, fore-, NaN-color entries are handled.\n\t * Note: Memory is allocated to hold the GMT_PALETTE structure except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item;\n\tunsigned int flag = 0, kind;\n\tchar tmp_cptfile[GMT_LEN64] = {\"\"};\n\tstruct GMT_PALETTE *P_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_palette: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\t/* Need to know the ID to do anything */\n\tif ((item = gmtapi_validate_id (API, GMT_IS_PALETTE, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failed basic sanity check */\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams since they are gone */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* OK, passed sanity and is allowed to read */\n\n\tswitch (S_obj->method) {\t/* From where are we getting the palette ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading CPT from %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tsnprintf (tmp_cptfile, GMT_LEN64, \"api_colors2cpt_%d.cpt\", (int)getpid());\n\t\t\tif (!strcmp (tmp_cptfile, S_obj->filename))\t/* This file was created when we gave \"name\" as red,blue,... instead */\n\t\t\t \tflag = GMT_CPT_TEMPORARY;\t/* So we can take action later when we learn if user wanted a discrete or continuous CPT */\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->filename, S_obj->method, mode|flag)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tif (flag == GMT_CPT_TEMPORARY) {\t/* Remove the temporary file */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Remove temporary CPT %s\\n\", S_obj->filename);\n\t\t\t\tremove (tmp_cptfile);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading CPT from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading CPT from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input CPT palette */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating CPT from GMT_PALETTE memory location\\n\");\n\t\t\tif (S_obj->resource == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tP_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_PALETTE);\n\t\t\tgmtlib_copy_palette (GMT, P_obj, S_obj->resource);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing CPT from GMT_PALETTE memory location\\n\");\n\t\t\tif ((P_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tgmtlib_init_cpt (GMT, P_obj);\t/* Make sure derived quantities are set */\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import GMT_PALETTE\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\tS_obj->data = P_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n#ifdef GMT_BACKWARDS_API\n\tP_obj->range = P_obj->data;\n\tP_obj->patch = P_obj->bfn;\n\tP_obj->cpt_flags = P_obj->mode;\n#endif\n\treturn (P_obj);\t/* Pass back the palette */\n}\n\n/*! . */\nGMT_LOCAL int api_export_palette (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_PALETTE *P_obj) {\n\t/* Does the actual work of writing out the specified CPT to a destination.\n\t * The mode controls how the back, for, NaN color entries are handled.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_PALETTE *P_copy = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_palette: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_PALETTE, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write CPT to %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->filename, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write CPT to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write CPT to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input cpt */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating CPT to GMT_PALETTE memory location\\n\");\n\t\t\tP_copy = gmt_M_memory (GMT, NULL, 1, struct GMT_PALETTE);\n\t\t\tgmtlib_copy_palette (GMT, P_copy, P_obj);\n\t\t\tS_obj->resource = P_copy;\t/* Set resource pointer from object to this palette */\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing CPT to GMT_PALETTE memory location\\n\");\n\t\t\tP_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = P_obj;\t/* Set resource pointer from object to this palette */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export CPTs\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\tS_obj->data = NULL;\n\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL struct GMT_POSTSCRIPT * api_import_postscript (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a PS struct.\n \t * The mode is not used yet.\n\t * Note: Memory is allocated to hold the GMT_POSTSCRIPT structure except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_POSTSCRIPT *P_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_postscript: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtapi_validate_id (API, GMT_IS_POSTSCRIPT, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC) return_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading PS from %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading PS from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading PS from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input CPT palette */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating PS from GMT_POSTSCRIPT memory location\\n\");\n\t\t\tif (S_obj->resource == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tP_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_POSTSCRIPT);\n\t\t\tgmtlib_copy_ps (GMT, P_obj, S_obj->resource);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing PS from GMT_POSTSCRIPT memory location\\n\");\n\t\t\tif ((P_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import PS\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->alloc_mode = P_obj->alloc_mode;\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\tS_obj->data = P_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\treturn (P_obj);\t/* Pass back the PS */\n}\n\n/*! . */\nGMT_LOCAL int api_export_postscript (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_POSTSCRIPT *P_obj) {\n\t/* Does the actual work of writing out the specified PS to a destination.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_POSTSCRIPT *P_copy = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_postscript: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_POSTSCRIPT, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write PS to %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->filename, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write PS to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write PS to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input cpt */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating PS to GMT_POSTSCRIPT memory location\\n\");\n\t\t\tP_copy = gmt_M_memory (GMT, NULL, 1, struct GMT_POSTSCRIPT);\n\t\t\tgmtlib_copy_ps (GMT, P_copy, P_obj);\n\t\t\tS_obj->resource = P_copy;\t/* Set resource pointer from object to this PS */\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing PS to GMT_POSTSCRIPT memory location\\n\");\n\t\t\tP_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = P_obj;\t/* Set resource pointer from object to this PS */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export PS\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\tS_obj->data = NULL;\t/* Since this is an output result */\n\n\treturn GMT_OK;\n}\n\nGMT_LOCAL struct GMT_MATRIX *api_read_matrix (struct GMT_CTRL *GMT, void *source, unsigned int src_type, unsigned int mode) {\n\t/* We read the MATRIX from fp [or stdin].\n\t * src_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * Notes: mode is not used yet.  We only do ascii file for now - later need to deal with -b, if needed.\n\t */\n\n\tbool close_file = false, first = true, add_first_segheader = false;\n\tint error = 0;\n\tuint64_t row = 0, col, ij, dim[4] = {0, 0, 0, GMT->current.setting.export_type};\n\tchar M_file[GMT_BUFSIZ] = {\"\"};\n\tchar line[GMT_BUFSIZ] = {\"\"};\n\tFILE *fp = NULL;\n\tstruct GMT_MATRIX *M = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tgmt_M_unused(mode);\n\n\tif (src_type == GMT_IS_FILE && !source) src_type = GMT_IS_STREAM;\t/* No filename given, default to stdin */\n\n\tif (src_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstrncpy (M_file, source, GMT_BUFSIZ-1);\n\t\tif ((fp = fopen (M_file, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot open Matrix file %s\\n\", M_file);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (src_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)source;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (M_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<input stream>\");\n\t}\n\telse if (src_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = source;\n\t\tif (fd && (fp = fdopen (*fd, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot convert Matrix file descriptor %d to stream in api_read_matrix\\n\", *fd);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (M_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<input file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unrecognized source type %d in api_read_matrix\\n\", src_type);\n\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Read Matrix from %s\\n\", M_file);\n\n\twhile (!error && fgets (line, GMT_BUFSIZ, fp)) {\n\t\tif (line[0] == '#') continue;\t/* Just skip headers */\n\t\tif (line[0] == '>') {\n\t\t\tif (first) {\t/* Have not allocated yet so just skip that row for now and deal with it later */\n\t\t\t\tfirst = false;\n\t\t\t\tadd_first_segheader = true;\n\t\t\t}\n\t\t\telse {\t/* Already allocated so place NaNs as segment header */\n\t\t\t\tgmt_prep_tmp_arrays (GMT, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;\n\t\t\t}\n\t\t}\n\t\telse {\t/* Regular data record */\n\t\t\tgmt_chop (line);\t/* Remove linefeeds */\n\t\t\tdim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\t\tgmt_prep_tmp_arrays (GMT, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];\n\t\t}\n\t\trow++;\n\t}\n\t/* Possibly restore the missing first segment header */\n\tif (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;\n\tdim[1] = row;\t/* Allocate all vectors using current type setting in the defaults [GMT_DOUBLE] */\n\tif ((M = GMT_Create_Data (GMT->parent, GMT_IS_MATRIX, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {\n\t\tif (close_file) fclose (fp);\n\t\treturn_null (GMT->parent, GMT_MEMORY_ERROR);\n\t}\n\tapi_put_val = api_select_put_function (GMT->parent, M->type);\t/* Get correct put function given data type */\n\tGMT_2D_to_index = api_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL);\t/* Get ij index function */\n\tfor (col = 0; col < M->n_columns; col++) {\n\t\tfor (row = 0; row < M->n_rows; row++) {\n\t\t\tij = GMT_2D_to_index (row, col, M->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_put_val (&(M->data), ij, GMT->hidden.mem_coord[col][row]);\n\t\t}\n\t}\n\n\tif (close_file) fclose (fp);\n\treturn (M);\n}\n\n/*! . */\nGMT_LOCAL struct GMT_MATRIX *api_import_matrix (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a GMT vector table.\n\t */\n\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_matrix: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtapi_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading MATRIX from %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((M_obj = api_read_matrix (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* Used for message: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading MATRIX from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((M_obj = api_read_matrix (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* Used for message: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading MATRIX from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((M_obj = api_read_matrix (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input MATRIX */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating MATRIX from MATRIX memory location [NOT IMPLEMENTED YET]\\n\");\n\t\t\tif (S_obj->resource == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t//M_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_VECTOR);\n\t\t\t//gmtlib_copy_vector (GMT, M_obj, S_obj->resource);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing MATRIX from MATRIX memory location\\n\");\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import MATRIX\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\tS_obj->data = M_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\treturn (M_obj);\t/* Pass back the vector */\n}\n\nGMT_LOCAL int api_write_matrix (struct GMT_CTRL *GMT, void *dest, unsigned int dest_type, unsigned int mode, struct GMT_MATRIX *M) {\n\t/* We write the MATRIX to fp [or stdout].\n\t * dest_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.\n\t */\n\n\tbool close_file = false, append = false;\n\tuint64_t row, col, ij;\n\tchar M_file[GMT_BUFSIZ] = {\"\"};\n\tstatic char *msg1[2] = {\"Writing\", \"Appending\"};\n\tFILE *fp = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (dest_type == GMT_IS_FILE && !dest) dest_type = GMT_IS_STREAM;\t/* No filename given, default to stdout */\n\n\tif (dest_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstatic char *msg2[2] = {\"create\", \"append to\"};\n\t\tstrncpy (M_file, dest, GMT_BUFSIZ-1);\n\t\tappend = (M_file[0] == '>');\t/* Want to append to existing file */\n\t\tif ((fp = fopen (&M_file[append], (append) ? \"a\" : \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot %s Matrix file %s\\n\", msg2[append], &M_file[append]);\n\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (dest_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)dest;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (M_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<output stream>\");\n\t}\n\telse if (dest_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = dest;\n\t\tif (fd && (fp = fdopen (*fd, \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot convert Matrix file descriptor %d to stream in api_write_matrix\\n\", *fd);\n\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (M_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<output file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unrecognized source type %d in api_write_matrix\\n\", dest_type);\n\t\treturn (GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"%s Matrix to %s\\n\", msg1[append], &M_file[append]);\n\n\t/* Start writing Matrix to fp */\n\n\tGMT_2D_to_index = api_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL);\n\tapi_get_val = api_select_get_function (GMT->parent, M->type);\n\n\tfor (row = 0; row < M->n_rows; row++) {\n\t\tfor (col = 0; col < M->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, M->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val (&(M->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t}\n\t\tif (api_bin_input_memory (GMT, M->n_columns, M->n_columns) < 0)\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\tgmt_write_segmentheader (GMT, fp, M->n_columns);\n\t\telse {\t/* Format an ascii output record */\n\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);\n\t\t\tfor (col = 1; col < M->n_columns; col++) {\n\t\t\t\tfprintf (fp, \"%s\", GMT->current.setting.io_col_separator);\n\t\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);\n\t\t\t}\n\t\t\tfprintf (fp, \"\\n\");\n\t\t}\n\t}\n\n\tif (close_file) fclose (fp);\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_export_matrix (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_MATRIX *M_obj) {\n\t/* Does the actual work of writing out the specified Matrix to a destination.  Only FILE supported for testing.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_matrix: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* api_write_matrix will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write MATRIX to %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((error = api_write_matrix (GMT, S_obj->filename, S_obj->method, mode, M_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* api_write_matrix will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write MATRIX to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = api_write_matrix (GMT, S_obj->fp, S_obj->method, mode, M_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* api_write_matrix will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write MATRIX to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = api_write_matrix (GMT, S_obj->fp, S_obj->method, mode, M_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export MATRIX\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\tS_obj->data = NULL;\n\n\treturn GMT_OK;\n}\n\nGMT_LOCAL int api_write_vector (struct GMT_CTRL *GMT, void *dest, unsigned int dest_type, unsigned int mode, struct GMT_VECTOR *V) {\n\t/* We write the VECTOR to fp [or stdout].\n\t * dest_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.\n\t */\n\n\tbool close_file = false, append = false;\n\tuint64_t row, col;\n\tchar V_file[GMT_BUFSIZ] = {\"\"};\n\tstatic char *msg1[2] = {\"Writing\", \"Appending\"};\n\tFILE *fp = NULL;\n\tGMT_getfunction *api_get_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (V == NULL) {\n\t\tGMT_Report(GMT->parent, GMT_MSG_NORMAL, \"GMTAPI: api_write_vector passed a NULL pointer *V\\n\");\n\t\treturn GMT_NOTSET;\n\t}\n\tif (dest_type == GMT_IS_FILE && !dest) dest_type = GMT_IS_STREAM;\t/* No filename given, default to stdout */\n\n\tif (dest_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstatic char *msg2[2] = {\"create\", \"append to\"};\n\t\tstrncpy (V_file, dest, GMT_BUFSIZ-1);\n\t\tappend = (V_file[0] == '>');\t/* Want to append to existing file */\n\t\tif ((fp = fopen (&V_file[append], (append) ? \"a\" : \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot %s Matrix file %s\\n\", msg2[append], &V_file[append]);\n\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (dest_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)dest;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (V_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<output stream>\");\n\t}\n\telse if (dest_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = dest;\n\t\tif (fd && (fp = fdopen (*fd, \"a\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot convert Matrix file descriptor %d to stream in api_write_matrix\\n\", *fd);\n\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (V_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<output file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unrecognized source type %d in api_write_matrix\\n\", dest_type);\n\t\treturn (GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"%s Matrix to %s\\n\", msg1[append], &V_file[append]);\n\n\t/* Start writing Vector to fp */\n\n\tapi_get_val = gmt_M_memory (GMT, NULL, V->n_columns, GMT_getfunction);\n\tfor (col = 0; col < V->n_columns; col++)\t/* Set get function per vector */\n\t\tapi_get_val[col] = api_select_get_function (GMT->parent, V->type[col]);\n\n\tfor (row = 0; row < V->n_rows; row++) {\n\t\tfor (col = 0; col < V->n_columns; col++)\n\t\t\tapi_get_val[col] (&(V->data[col]), row, &(GMT->current.io.curr_rec[col]));\n\t\tif (api_bin_input_memory (GMT, V->n_columns, V->n_columns) < 0)\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\tgmt_write_segmentheader (GMT, fp, V->n_columns);\n\t\telse {/* Format an ascii record for output */\n\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);\n\t\t\tfor (col = 1; col < V->n_columns; col++) {\n\t\t\t\tfprintf (fp, \"%s\", GMT->current.setting.io_col_separator);\n\t\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);\n\t\t\t}\n\t\t\tfprintf (fp, \"\\n\");\n\t\t}\n\t}\n\tgmt_M_free (GMT, api_get_val);\n\n\tif (close_file) fclose (fp);\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int api_export_vector (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_VECTOR *V_obj) {\n\t/* Does the actual work of writing out the specified Matrix to a destination.  Only FILE supported for testing.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_vector: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* api_write_vector will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write VECTOR to %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((error = api_write_vector (GMT, S_obj->filename, S_obj->method, mode, V_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* api_write_vector will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write VECTOR to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = api_write_vector (GMT, S_obj->fp, S_obj->method, mode, V_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* api_write_vector will report where it is writing from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Write VECTOR to %s %s output stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((error = api_write_vector (GMT, S_obj->fp, S_obj->method, mode, V_obj))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export VECTOR\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\tS_obj->data = NULL;\n\n\treturn GMT_OK;\n}\n\nGMT_LOCAL struct GMT_VECTOR *api_read_vector (struct GMT_CTRL *GMT, void *source, unsigned int src_type, unsigned int mode) {\n\t/* We read the VECTOR from fp [or stdin].\n\t * src_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.  We only do ascii file for now - later need to deal with -b\n\t */\n\n\tbool close_file = false, first = true, add_first_segheader = false;\n\tuint64_t row = 0, col, dim[GMT_DIM_SIZE] = {0, 0, GMT->current.setting.export_type, 0};\n\tchar V_file[GMT_BUFSIZ] = {\"\"};\n\tchar line[GMT_BUFSIZ] = {\"\"};\n\tFILE *fp = NULL;\n\tstruct GMT_VECTOR *V = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (src_type == GMT_IS_FILE && !source) src_type = GMT_IS_STREAM;\t/* No filename given, default to stdin */\n\n\tif (src_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstrncpy (V_file, source, GMT_BUFSIZ-1);\n\t\tif ((fp = fopen (V_file, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot open Vector file %s\\n\", V_file);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (src_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)source;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (V_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<input stream>\");\n\t}\n\telse if (src_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = source;\n\t\tif (fd && (fp = fdopen (*fd, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot convert Vector file descriptor %d to stream in api_read_vector\\n\", *fd);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (V_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<input file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unrecognized source type %d in api_read_vector\\n\", src_type);\n\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Read Vector from %s\\n\", V_file);\n\n\twhile (fgets (line, GMT_BUFSIZ, fp)) {\n\t\tif (line[0] == '#') continue;\t/* Just skip headers */\n\t\tif (line[0] == '>') {\n\t\t\tif (first) {\t/* Have not allocated yet so just skip that row for now */\n\t\t\t\tfirst = false;\n\t\t\t\tadd_first_segheader = true;\n\t\t\t}\n\t\t\telse {\t/* Already allocated so place NaNs */\n\t\t\t\tgmt_prep_tmp_arrays (GMT, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;\n\t\t\t}\n\t\t}\n\t\telse {\t/* Regular data record */\n\t\t\tgmt_chop (line);\t/* Remove linefeeds */\n\t\t\tdim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\t\tgmt_prep_tmp_arrays (GMT, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];\n\t\t}\n\t\trow++;\n\t}\n\tif (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;\n\tdim[1] = row;\t/* Allocate all vectors using current type setting in the defaults [GMT_DOUBLE] */\n\tif ((V = GMT_Create_Data (GMT->parent, GMT_IS_VECTOR, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {\n\t\tif (close_file) fclose (fp);\n\t\treturn_null (GMT->parent, GMT_MEMORY_ERROR);\n\t}\n\tfor (col = 0; col < V->n_columns; col++) {\n\t\tapi_put_val = api_select_put_function (GMT->parent, V->type[col]);\n\t\tfor (row = 0; row < V->n_rows; row++)\n\t\t\tapi_put_val (&(V->data[col]), row, GMT->hidden.mem_coord[col][row]);\n\t}\n\n\tif (close_file) fclose (fp);\n\treturn (V);\n}\n\n/*! . */\nGMT_LOCAL struct GMT_VECTOR * api_import_vector (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a GMT vector table.\n\t */\n\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_vector: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtapi_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading VECTOR from %s %s\\n\", GMT_method[S_obj->method], S_obj->filename);\n\t\t\tif ((V_obj = api_read_vector (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* For message only: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading VECTOR from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((V_obj = api_read_vector (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* api_read_vector will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* For message only: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading VECTOR from %s %s stream\\n\", GMT_method[S_obj->method], GMT_stream[kind]);\n\t\t\tif ((V_obj = api_read_vector (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input VECTOR */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating VECTOR from VECTOR memory location [NOT IMPLEMENTED YET]\\n\");\n\t\t\tif (S_obj->resource == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t//V_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_VECTOR);\n\t\t\t//gmtlib_copy_vector (GMT, V_obj, S_obj->resource);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing VECTOR from VECTOR memory location\\n\");\n\t\t\tif ((V_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import VECTOR\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\tS_obj->data = V_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\treturn (V_obj);\t/* Pass back the vector */\n}\n\n#if 0\nGMT_LOCAL bool api_col_check (struct GMT_DATATABLE *T, uint64_t *n_cols) {\n\tuint64_t seg;\n\t/* Checks that all segments in this table has the correct number of columns.\n\t * If *n_cols == 0 we set it to the number of columns found in the first segment. */\n\n\tfor (seg = 0; seg < T->n_segments; seg++) {\n\t\tif ((*n_cols) == 0 && seg == 0) *n_cols = T->segment[seg]->n_columns;\n\t\tif (T->segment[seg]->n_columns != (*n_cols)) return (true);\n\t}\n\treturn (false);\t/* All is well */\n}\n#endif\n\n/*! . */\nGMT_LOCAL void api_increment_d (struct GMT_DATASET *D_obj, uint64_t n_rows, uint64_t n_columns, uint64_t n_seg) {\n\t/* Increment dimensions for this single dataset's single table's last segment */\n\tuint64_t last_seg = n_seg - 1;\n\tassert (n_seg > 0);\n\tD_obj->table[D_obj->n_tables]->segment[last_seg]->n_rows = n_rows;\n\tD_obj->table[D_obj->n_tables]->segment[last_seg]->n_columns = D_obj->table[D_obj->n_tables]->n_columns = n_columns;\n\tD_obj->table[D_obj->n_tables]->n_records += n_rows;\n\tD_obj->table[D_obj->n_tables]->n_segments = n_seg;\n\tD_obj->n_tables++;\t/* Since we just read one table */\n}\n\n/*! . */\nGMT_LOCAL struct GMT_DATASET *api_import_dataset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in the entire virtual data set (possibly via many sources)\n\t * If object_ID == GMT_NOTSET we get all registered input tables, otherwise we just get the one requested.\n\t * Note: Memory is allocated for the Dataset except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item, first_item = 0, this_item = GMT_NOTSET, last_item, new_item, new_ID, status;\n\tunsigned int geometry = GMT_IS_PLP, n_used = 0, method;\n\tbool allocate = false, update = false, diff_types, use_GMT_io, greenwich = true;\n\tbool via = false, got_data = false;\n\tsize_t n_alloc, s_alloc = GMT_SMALL_CHUNK;\n\tuint64_t row, seg, col, ij, n_records = 0, n_columns = 0, col_pos, n_use;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tstruct GMT_DATASET *D_obj = NULL, *Din_obj = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_dataset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) {\t/* Means there is more than one source: Merge all registered data tables into a single virtual data set */\n\t\tlast_item = API->n_objects - 1;\t/* Must check all registered objects */\n\t\tallocate = true;\n\t\tn_alloc = GMT_TINY_CHUNK;\t/* We don't expect that many files to be given initially */\n\t}\n\telse {\t\t/* Requested a single, specific data table/file */\n\t\tint flag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\t/* Needed by Validate_ID */\n\t\tif ((first_item = gmtapi_validate_id (API, GMT_IS_DATASET, object_ID, GMT_IN, flag)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\n\t\tlast_item = first_item;\n\t\tn_alloc = 1;\n\t}\n\n\t/* Allocate a single data set and an initial allocated list of n_alloc tables */\n\tD_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASET);\n\tD_obj->table = gmt_M_memory (GMT, NULL, n_alloc, struct GMT_DATATABLE *);\n\tD_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\t/* So GMT_* modules can free this memory (may override below) */\n\tD_obj->alloc_level = GMT->hidden.func_level;\t/* So GMT_* modules can free this memory (may override below) */\n\tuse_GMT_io = !(mode & GMT_IO_ASCII);\t\t/* false if we insist on ASCII reading */\n\tGMT->current.io.seg_no = GMT->current.io.rec_no = GMT->current.io.rec_in_tbl_no = 0;\t/* Reset for each new dataset */\n\tif (GMT->common.R.active[RSET] && GMT->common.R.wesn[XLO] < -180.0 && GMT->common.R.wesn[XHI] > -180.0) greenwich = false;\n\n\tfor (item = first_item; item <= last_item; item++) {\t/* Look through all sources for registered inputs (or just one) */\n\t\tS_obj = API->object[item];\t/* S_obj is the current data object */\n\t\tif (!S_obj) {\t/* Probably not a good sign. NOTE: Probably cannot happen since skipped in api_next_source, no? */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_dataset: Skipped empty object (item = %d)\\n\", item);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_obj->selected) continue;\t\t\t/* Registered, but not selected */\n\t\tif (S_obj->direction == GMT_OUT) continue;\t/* We're doing reading here, so skip output objects */\n\t\tif (S_obj->family != GMT_IS_DATASET) continue;\t/* We're doing datasets here, so skip other data types */\n\t\tif (API->module_input && !S_obj->module_input) continue;\t/* Do not mix module-inputs and option inputs if knowable */\n\t\tif (S_obj->status != GMT_IS_UNUSED) { \t/* Already read this resource before; are we allowed to re-read? */\n\t\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC) {\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Cannot re-read streams */\n\t\t\t}\n\t\t\tif (!(mode & GMT_IO_RESET)) {\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t\t\t}\n\t\t}\n\t\tif (this_item == GMT_NOTSET) this_item = item;\t/* First item that worked */\n\t\tvia = false;\n\t\tgeometry = (GMT->common.a.output) ? GMT->common.a.geometry : S_obj->geometry;\t/* When reading GMT and writing OGR/GMT we must make sure we set this first */\n\t\tmethod = api_set_method (S_obj);\t/* Get the actual method to use */\n\t\tswitch (method) {\t/* File, array, stream, reference, etc ? */\n\t \t\tcase GMT_IS_FILE:\t/* Import all the segments, then count total number of records */\n#ifdef SET_IO_MODE\n\t\t\t\tif (item == first_item) gmt_setmode (GMT, GMT_IN);\t/* Windows may need to switch read mode from text to binary */\n#endif\n\t\t\t\t/* gmtlib_read_table will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\t\tif (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0) {\t/* Only single tables if GMT/OGR */\n\t\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\t\treturn_null (API, GMT_OGR_ONE_TABLE_ONLY);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE,\n\t\t\t\t            \"Reading %s from %s %s\\n\", GMT_family[S_obj->family], GMT_method[S_obj->method], S_obj->filename);\n\t\t\t\tif ((D_obj->table[D_obj->n_tables] = gmtlib_read_table (GMT, S_obj->filename, S_obj->method, greenwich, &geometry, use_GMT_io)) == NULL)\n\t\t\t\t\tcontinue;\t\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tD_obj->table[D_obj->n_tables]->id = D_obj->n_tables;\t/* Give sequential internal object_ID numbers to tables */\n\t\t\t\tD_obj->n_tables++;\t/* Since we just read one */\n\t\t\t\tupdate = true;\t\t/* Have reason to update min/max when done */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_STREAM:\t/* Import all the segments, then count total number of records */\n\t \t\tcase GMT_IS_FDESC:\n\t\t\t\t/* gmtlib_read_table will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n#ifdef SET_IO_MODE\n\t\t\t\tif (item == first_item) gmt_setmode (GMT, GMT_IN);\t/* Windows may need to switch read mode from text to binary */\n#endif\n\t\t\t\tif (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0)\t{\t/* Only single tables if GMT/OGR */\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_OGR_ONE_TABLE_ONLY);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading %s from %s %\" PRIxS \"\\n\", GMT_family[S_obj->family], GMT_method[S_obj->method], (size_t)S_obj->fp);\n\t\t\t\tif ((D_obj->table[D_obj->n_tables] = gmtlib_read_table (GMT, S_obj->fp, S_obj->method, greenwich, &geometry, use_GMT_io)) == NULL) continue;\t\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tD_obj->table[D_obj->n_tables]->id = D_obj->n_tables;\t/* Give sequential internal object_ID numbers to tables */\n\t\t\t\tD_obj->n_tables++;\t/* Since we just read one */\n\t\t\t\tupdate = true;\t\t/* Have reason to update min/max when done */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input dataset */\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t/* Free up what we allocated earlier since gmt_duplicate_dataset does it all */\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tif ((Din_obj = S_obj->resource) == NULL)\t/* Ooops, noting there? */\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table from GMT_DATASET memory location\\n\");\n\t\t\t\tD_obj = gmt_duplicate_dataset (GMT, Din_obj, GMT_ALLOC_NORMAL, NULL);\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so free up what we allocated earlier */\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t/* Free up what we allocated up front since we just wish to pass the pointer */\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing data table from GMT_DATASET memory location\\n\");\n\t\t\t\tif ((D_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tbreak;\n\n\t\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t\t/* Each matrix source becomes a separate table with a single segment unless there are NaN-records as segment headers */\n\t\t\t\tif ((M_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table from user matrix location\\n\");\n\t\t\t\t/* Allocate a table with a single segment given matrix dimensions, but if nan-record we may end up with more segments */\n\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : M_obj->n_columns;\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[0] =\n\t\t\t\t    GMT_Alloc_Segment (API, GMT_IS_DATASET, M_obj->n_rows, n_columns, NULL, NULL);\n\t\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\t\tapi_get_val = api_select_get_function (API, M_obj->type);\n\t\t\t\tn_use = api_n_cols_needed_for_gaps (GMT, M_obj->n_columns);\t/* Number of input columns to process */\n\t\t\t\tfor (row = seg = n_records = 0; row < M_obj->n_rows; row++) {\t/* This loop may include NaN-records and data records */\n\t\t\t\t\tapi_update_prev_rec (GMT, n_use);\t/* Make last current record the previous record if it is required by gap checking */\n\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\t/* Extract cols for a single record and store result in curr_rec */\n\t\t\t\t\t\tij = GMT_2D_to_index (row, col, M_obj->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\t\t\t\tapi_get_val (&(M_obj->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\t/* Now process the current record */\n\t\t\t\t\tif ((status = api_bin_input_memory (GMT, M_obj->n_columns, n_use)) < 0) {\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP) API->current_rec[GMT_IN]--;\t/* Since we inserted a segment header we must revisit this record as the first in next segment */\n\t\t\t\t\t\tif (got_data) {\t/* If first input segment has header then we already have that segment allocated */\n\t\t\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->n_records += n_records;\t\t\t/* Update record count for this table */\n\t\t\t\t\t\t\tseg++;\t/* Increment number of segments */\n\t\t\t\t\t\t\tif (seg == s_alloc) {\t/* Allocate more space for additional segments */\n\t\t\t\t\t\t\t\ts_alloc <<= 1;\t/* Double current alloc limit for segments, then allocate space for more segments */\n\t\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Allocate next segment with initial size the remainder of the data, which is the maximum length possible */\n\t\t\t\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[seg] = GMT_Alloc_Segment (API, GMT_IS_DATASET, M_obj->n_rows-n_records, n_columns, NULL, NULL);\n\t\t\t\t\t\t\tn_records = 0;\t/* This is number of recs in current segment so we reset it to zero */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Found a data record */\n\t\t\t\t\t\tfor (col = 0; col < n_columns; col++)\t/* Place the record into the dataset segment structure */\n\t\t\t\t\t\t\tS->data[col][n_records] = api_get_record_value (GMT, GMT->current.io.curr_rec, col, M_obj->n_columns);\n\t\t\t\t\t\tgot_data = true;\t/* No longer before first data record */\n\t\t\t\t\t\tn_records++;\t/* Update count of records in current segment */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (seg)\t/* Got more than one segment, so finalize the reallocation of last segment to exact record count */\n\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\tseg++;\t/* Now holds the total number of segments */\n\t\t\t\t/* Realloc this table's segment array to the actual length [i.e., seg] */\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, seg, struct GMT_DATASEGMENT *);\n\t\t\t\tapi_increment_d (D_obj, n_records, n_columns, seg);\t/* Update counters for D_obj's only table */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_DUPLICATE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->data = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tD_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\n\t \t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\n\t\t\t\t/* Each column array source becomes column arrays in a separate table with one (or more if NaN-records) segments */\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table from user %\" PRIu64 \" column arrays of length %\" PRIu64 \"\\n\",\n\t\t\t\t            V_obj->n_columns, V_obj->n_rows);\n\t\t\t\t/* Allocate a single table with one segment - there may be more if there are nan-records */\n\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : V_obj->n_columns;\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[0] = GMT_Alloc_Segment (API, GMT_IS_DATASET, V_obj->n_rows, n_columns, NULL, NULL);\n\t\t\t\tfor (col = 1, diff_types = false; !diff_types && col < V_obj->n_columns; col++) if (V_obj->type[col] != V_obj->type[col-1]) diff_types = true;\n\t\t\t\tapi_get_val = api_select_get_function (API, V_obj->type[0]);\n\t\t\t\tfor (row = seg = n_records = 0; row < V_obj->n_rows; row++) {\t/* This loop may include NaN-records and data records */\n\t\t\t\t\tn_use = api_n_cols_needed_for_gaps (GMT, V_obj->n_columns);\n\t\t\t\t\tapi_update_prev_rec (GMT, n_use);\n\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\t/* Process a single record into curr_rec */\n\t\t\t\t\t\tif (diff_types) api_get_val = api_select_get_function (API, V_obj->type[col]);\n\t\t\t\t\t\tapi_get_val (&(V_obj->data[col]), row, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\tif ((status = api_bin_input_memory (GMT, V_obj->n_columns, n_use)) < 0) {\t/* Segment header found, finish the one we had and add more */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP) API->current_rec[GMT_IN]--;\t/* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\t\t\tif (got_data) {\t/* If first input segment has header then we already have a segment allocated */\n\t\t\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\n\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->n_records += n_records;\n\t\t\t\t\t\t\tseg++;\t/* Increment number of segments */\n\t\t\t\t\t\t\tif (seg == s_alloc) {\t/* Allocate more space for segments */\n\t\t\t\t\t\t\t\ts_alloc <<= 1;\n\t\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Allocate next segment with initial size the remainder of the data */\n\t\t\t\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[seg] = GMT_Alloc_Segment (API, GMT_IS_DATASET, V_obj->n_rows-n_records, n_columns, NULL, NULL);\n\t\t\t\t\t\t\tn_records = 0;\t/* This is number of recs in current segment */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Data record */\n\t\t\t\t\t\tfor (col = 0; col < n_columns; col++)\t/* Place the record into the structure */\n\t\t\t\t\t\t\tS->data[col][n_records] = api_get_record_value (GMT, GMT->current.io.curr_rec, col, V_obj->n_columns);\n\t\t\t\t\t\tgot_data = true;\n\t\t\t\t\t\tn_records++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (seg)\t/* Got more than one segment, finalize the realloc of last segment */\n\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\tseg++;\t/* Total number of segments */\n\t\t\t\t/* Realloc this table's segment array to the actual length [i.e., seg] */\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, seg, struct GMT_DATASEGMENT *);\n\t\t\t\tapi_increment_d (D_obj, n_records, n_columns, seg);\t/* Update counters for D_obj's only table */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_DUPLICATE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->data = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t\t\t/* Mark as read */\n\t\t\t\tD_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\n\t\t \tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tif (V_obj->type[0] != GMT_DOUBLE) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\t\t}\n\t\t\t\t/* Each column double array source becomes preallocated column arrays in a separate table with a single segment */\n\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : V_obj->n_columns;\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing data table from user %\" PRIu64 \" column arrays of length %\" PRIu64 \"\\n\",\n\t\t\t\t            V_obj->n_columns, V_obj->n_rows);\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASEGMENT *);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment[0] = GMT_Alloc_Segment (API, GMT_IS_DATASET, 0, n_columns, NULL, NULL);\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\n\t\t\t\t\tif (GMT->common.i.active)\t/* -i has selected some columns */\n\t\t\t\t\t\tcol_pos = GMT->current.io.col[GMT_IN][col].col;\t/* Which data column to pick */\n\t\t\t\t\telse if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\t\t\t\t\tcol_pos = 1 - col;\t/* Read lat/lon instead of lon/lat */\n\t\t\t\t\telse\n\t\t\t\t\t\tcol_pos = col;\t/* Just goto that column */\n\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment[0]->data[col] = V_obj->data[col_pos].f8;\n\t\t\t\t}\n\t\t\t\tapi_increment_d (D_obj, V_obj->n_rows, n_columns, 1U);\t/* Update counters for D_obj with 1 segment */\n\t\t\t\tD_obj->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* Since we just hooked on the arrays */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_REFERENCE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->data = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tD_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tS_obj->family = GMT_IS_VECTOR;\t/* Done with the via business now */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import data tables\\n\");\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (update) {\t/* Means we got stuff and need to update the total dataset statistics so far */\n\t\t\tD_obj->n_segments += D_obj->table[D_obj->n_tables-1]->n_segments;\t/* Sum up total number of segments in the entire data set */\n\t\t\tD_obj->n_records  += D_obj->table[D_obj->n_tables-1]->n_records;\t\t/* Sum up total number of records in the entire data set */\n\t\t\t/* Update segment IDs so they are sequential across many tables (gmtlib_read_table sets the ids relative to current table). */\n\t\t\tif (D_obj->n_tables > 1) {\n\t\t\t\tfor (seg = 0; seg < D_obj->table[D_obj->n_tables-1]->n_segments; seg++)\n\t\t\t\t\tD_obj->table[D_obj->n_tables-1]->segment[seg]->id += D_obj->table[D_obj->n_tables-2]->n_segments;\n\t\t\t}\n\t\t\tif (allocate && D_obj->n_tables == n_alloc) {\t/* Must allocate more space for additional tables */\n\t\t\t\tsize_t old_n_alloc = n_alloc;\n\t\t\t\tn_alloc += GMT_TINY_CHUNK;\n\t\t\t\tD_obj->table = gmt_M_memory (GMT, D_obj->table, n_alloc, struct GMT_DATATABLE *);\n\t\t\t\tgmt_M_memset (&(D_obj->table[old_n_alloc]), n_alloc - old_n_alloc, struct GMT_DATATABLE *);\t/* Set new memory to NULL */\n\t\t\t}\n#ifdef GMT_BACKWARDS_API\n\t\t\tfor (seg = 0; seg < D_obj->table[D_obj->n_tables-1]->n_segments; seg++)\n\t\t\t\tD_obj->table[D_obj->n_tables-1]->segment[seg]->coord = D_obj->table[D_obj->n_tables-1]->segment[seg]->data;\n#endif\n\t\t}\n\t\tS_obj->alloc_mode = D_obj->alloc_mode;\t/* Clarify allocation mode for this object */\n#if 0\n\t\tif (api_col_check (D_obj->table[D_obj->n_tables-1], &n_cols)) {\t/* Different tables have different number of columns, which is not good */\n\t\t\treturn_null (API, GMT_N_COLS_VARY);\n\t\t}\n#endif\n\t\tS_obj->status = GMT_IS_USED;\t/* Mark input object as read */\n\t\tn_used++;\t/* Number of items actually processed */\n\t}\n\tif (D_obj->n_tables == 0) {\t/* Only found empty files (e.g., /dev/null) and we have nothing to show for our efforts.  Return an single empty table with no segments. */\n\t\tD_obj->table = gmt_M_memory (GMT, D_obj->table, 1, struct GMT_DATATABLE *);\n\t\tD_obj->table[0] = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\tD_obj->n_tables = 1;\t/* But we must indicate we found one (empty) table */\n\t}\n\telse {\t/* Found one or more tables, finalize table allocation, set number of columns, and possibly allocate min/max arrays if not there already */\n\t\tif (allocate && D_obj->n_tables < n_alloc) D_obj->table = gmt_M_memory (GMT, D_obj->table, D_obj->n_tables, struct GMT_DATATABLE *);\n\t\tD_obj->n_columns = D_obj->table[0]->n_columns;\n\t\tif (!D_obj->min) D_obj->min = gmt_M_memory (GMT, NULL, D_obj->n_columns, double);\n\t\tif (!D_obj->max) D_obj->max = gmt_M_memory (GMT, NULL, D_obj->n_columns, double);\n\t}\n\tD_obj->geometry = geometry;\t\t\t/* Since gmtlib_read_table may have changed it */\n\tgmtlib_set_dataset_minmax (GMT, D_obj);\t/* Set the min/max values for the entire dataset */\n\tif (!via) API->object[this_item]->data = D_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\treturn (D_obj);\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_data_ptr (struct GMTAPI_CTRL *API, enum GMT_enum_family family, void *ptr) {\n\t/* Like GMT_Destroy_Data but takes pointer to data rather than address of pointer.\n\t * We pass true to make sure we free the memory.  Some objects (grid, matrix, vector) may\n\t * point to externally allocated memory so we return the alloc_mode for those items.\n\t * This is mostly for information since the pointers to such external memory have now\n\t * been set to NULL instead of being freed.\n\t * The containers are always allocated by GMT so those are freed at the end.\n\t */\n\n\tstruct GMT_CTRL *GMT;\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\n\tif (!ptr) return (GMT_OK);\t/* Null pointer */\n\tGMT = API->GMT;\n\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\tgmtgrdio_free_grid_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\tgmtlib_free_dataset_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\tgmtlib_free_textset_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\tgmtlib_free_cpt_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tgmtlib_free_image_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tgmtlib_free_ps_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\t/* Nothing to do as gmt_M_free below will do it */\n\t\t\tbreak;\n\n\t\t/* Also allow destroying of intermediate vector and matrix containers */\n\t\tcase GMT_IS_MATRIX:\n\t\t\tgmtlib_free_matrix_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tgmtlib_free_vector_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_FAMILY));\n\t\t\tbreak;\n\t}\n\tgmt_M_free (GMT, ptr);\t/* OK to free container */\n\treturn (GMT_OK);\t/* Null pointer */\n}\n\n/*! . */\nGMT_LOCAL int api_export_dataset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_DATASET *D_obj) {\n \t/* Does the actual work of writing out the specified data set to a single destination.\n\t * If object_ID == GMT_NOTSET we use the first registered output destination, otherwise we just use the one specified.\n\t * See the GMT API documentation for how mode is used to create multiple files from segments or tables of a dataset.\n\t */\n\tint item, error, default_method;\n\tunsigned int method;\n\tuint64_t tbl, col, row_out, row, seg, ij;\n\tbool save;\n\tdouble value;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_DATASET *D_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tvoid *ptr = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_dataset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_DATASET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* S is the object whose data we will export */\n\tif (S_obj->family != GMT_IS_DATASET) return (gmtapi_report_error (API, GMT_NOT_A_VALID_FAMILY));\t/* Called with wrong data type */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\t/* Only allow writing of a data set once unless overridden by mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\t/* Remove the reset bit */\n\tif (mode >= GMT_WRITE_TABLE && !S_obj->filename) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\t/* Must have filename when segments are to be written */\n\tdefault_method = GMT_IS_FILE;\n\tif (S_obj->filename)\t/* Write to this file */\n\t\tptr = S_obj->filename;\n\telse {\t\t\t/* No filename so we switch default method to writing to a stream or fdesc */\n\t\tdefault_method = (S_obj->method == GMT_IS_FILE) ? GMT_IS_STREAM : S_obj->method;\n\t\tptr = S_obj->fp;\n#ifdef SET_IO_MODE\n\t\tgmt_setmode (GMT, GMT_OUT);\t/* Windows may need to switch write mode from text to binary */\n#endif\n\t}\n\tgmtlib_set_dataset_minmax (GMT, D_obj);\t/* Update all counters and min/max arrays */\n\tD_obj->io_mode = mode;\t/* Handles if tables or segments should be written to separate files, according to mode */\n\tmethod = api_set_method (S_obj);\t/* Get the actual method to use */\n\tswitch (method) {\t/* File, array, stream, etc. */\n\t \tcase GMT_IS_STREAM:\n#ifdef SET_IO_MODE\n\t\t\tgmt_setmode (GMT, GMT_OUT);\t/* Windows may need to switch write mode from text to binary */\n#endif\n\t\tcase GMT_IS_FILE:\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_dataset (or lower) will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tif ((error = gmtlib_write_dataset (GMT, ptr, default_method, D_obj, true, GMT_NOTSET))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input dataset on output */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table to GMT_DATASET memory location\\n\");\n\t\t\tD_copy = gmt_duplicate_dataset (GMT, D_obj, GMT_ALLOC_NORMAL, NULL);\n\t\t\tS_obj->resource = D_copy;\t/* Set resource pointer from object to this dataset */\n\t\t\tbreak;\n\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing data table to GMT_DATASET memory location\\n\");\n\t\t\tgmtlib_change_dataset (GMT, D_obj);\t/* Deal with any -o settings */\n\t\t\tS_obj->resource = D_obj;\t\t\t/* Set resource pointer from object to this dataset */\n\t\t\tD_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table to user matrix location\\n\");\n\t\t\tM_obj = gmtlib_create_matrix (GMT, 1U, GMT_OUT);\t/* 1-layer matrix (i.e., 2-D) */\n\t\t\t/* Allocate final output space since we now know all dimensions */\n\t\t\tsave = GMT->current.io.multi_segments[GMT_OUT];\n\t\t\tif (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;\n\t\t\tM_obj->n_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;\t/* Number of rows needed to hold the data [incl any segment headers] */\n\t\t\tM_obj->n_columns = (GMT->common.o.active) ? GMT->common.o.n_cols : D_obj->n_columns;\t\t\t\t\t/* Number of columns needed to hold the data records */\n\t\t\tM_obj->dim = (M_obj->shape == GMT_IS_ROW_FORMAT) ? D_obj->n_columns : M_obj->n_rows;\t\t\t\t\t\t/* Matrix layout order */\n\t\t\tS_obj->n_alloc = M_obj->n_rows * D_obj->n_columns;\t/* Get total number of elements as n_rows * n_columns */\n\t\t\tM_obj->type = GMT->current.setting.export_type;\t/* Use selected data type for the export */\n\t\t\t/* Allocate output matrix space or die */\n\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, S_obj->n_alloc)) != GMT_OK) return (gmtapi_report_error (API, error));\n\t\t\tM_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\tapi_put_val = api_select_put_function (API, M_obj->type);\n\n\t\t\tfor (tbl = row_out = 0; tbl < D_obj->n_tables; tbl++) {\t/* Loop over tables and segments */\n\t\t\t\tfor (seg = 0; seg < D_obj->table[tbl]->n_segments; seg++) {\n\t\t\t\t\tS = D_obj->table[tbl]->segment[seg];\t/* Shorthand for the current segment */\n\t\t\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t/* Must write a NaN-segment record to indicate segment break */\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\n\t\t\t\t\t\t\tij = GMT_2D_to_index (row_out, col, M_obj->dim);\n\t\t\t\t\t\t\tapi_put_val (&(M_obj->data), ij, GMT->session.d_NaN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t\t\t}\n\t\t\t\t\tfor (row = 0; row < S->n_rows; row++, row_out++) {\t/* Write this segment's data records to the matrix */\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\n\t\t\t\t\t\t\tij = GMT_2D_to_index (row_out, col, M_obj->dim);\n\t\t\t\t\t\t\tvalue = api_select_dataset_value (GMT, S, (unsigned int)row, (unsigned int)col);\n\t\t\t\t\t\t\tapi_put_val (&(M_obj->data), ij, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (M_obj->n_rows == row_out);\t/* Sanity check */\n\t\t\tM_obj->alloc_level = S_obj->alloc_level;\n\t\t\tS_obj->resource = M_obj;\t\t/* Set resource pointer from object to this matrix */\n\t\t\tGMT->current.io.multi_segments[GMT_OUT] = save;\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table to user column arrays location\\n\");\n\t\t\tcol = (GMT->common.o.active) ? GMT->common.o.n_cols : D_obj->n_columns;\t/* Number of columns needed to hold the data records */\n\t\t\tif ((V_obj = gmt_create_vector (GMT, col, GMT_OUT)) == NULL)\n\t\t\t\treturn (gmtapi_report_error (API, GMT_PTR_IS_NULL));\n\t\t\tsave = GMT->current.io.multi_segments[GMT_OUT];\n\t\t\tif (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;\n\t\t\tV_obj->n_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;\t/* Number of data records [and any segment headers] */\n\t\t\tfor (col = 0; col < V_obj->n_columns; col++) V_obj->type[col] = GMT->current.setting.export_type;\t/* Set same data type for all columns */\n\t\t\tif ((error = api_alloc_vectors (GMT, V_obj, V_obj->n_rows)) != GMT_OK) return (gmtapi_report_error (API, error));\t/* Allocate space for all columns */\n\t\t\tapi_put_val = api_select_put_function (API, GMT->current.setting.export_type);\t/* Since all columns are of same type we get the pointer here */\n\t\t\tfor (tbl = row_out = 0; tbl < D_obj->n_tables; tbl++) {\t/* Loop over all tables and segments */\n\t\t\t\tfor (seg = 0; seg < D_obj->table[tbl]->n_segments; seg++) {\n\t\t\t\t\tS = D_obj->table[tbl]->segment[seg];\t/* Shorthand for this segment */\n\t\t\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t\t/* Must write a NaN-segment record */\n\t\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++)\n\t\t\t\t\t\t\tapi_put_val (&(V_obj->data[col]), row_out, GMT->session.d_NaN);\n\t\t\t\t\t\trow_out++;\t/* Due to the extra NaN-data header */\n\t\t\t\t\t}\n\t\t\t\t\tfor (row = 0; row < S->n_rows; row++, row_out++) {\t/* Copy the data records */\n\t\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\n\t\t\t\t\t\t\tvalue = api_select_dataset_value (GMT, S, (unsigned int)row, (unsigned int)col);\n\t\t\t\t\t\t\tapi_put_val (&(V_obj->data[col]), row_out, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (V_obj->n_rows == row_out);\t/* Sanity check */\n\t\t\tV_obj->alloc_level = S_obj->alloc_level;\n\t\t\tS_obj->resource = V_obj;\n\t\t\tGMT->current.io.multi_segments[GMT_OUT] = save;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export data tables\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->alloc_mode = D_obj->alloc_mode;\t/* Clarify allocation mode for this entity */\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\tS_obj->data = NULL;\n\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL struct GMT_TEXTSET *api_import_textset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in the entire virtual text set (possibly via many sources)\n\t * If object_ID == GMT_NOTSET we get all registered input tables, otherwise we just get the one requested.\n\t * Note: Memory is allocated for the textset except for GMT_IS_REFERENCE.\n\t */\n\n\tint item, first_item = 0, last_item, this_item = GMT_NOTSET, new_item, new_ID;\n\tunsigned int n_used = 0;\n\tbool update = false, allocate = false, via = false;\n\tsize_t n_alloc;\n\tuint64_t row, seg;\n\tchar *t_ptr = NULL;\n\tstruct GMT_TEXTSET *T_obj = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_textset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tT_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSET);\n\n\tif (object_ID == GMT_NOTSET) {\t/* More than one source: Merge all registered data tables into a single virtual text set */\n\t\tlast_item = API->n_objects - 1;\t/* Must check all objects */\n\t\tallocate = true;\n\t\tn_alloc = GMT_TINY_CHUNK;\n\t}\n\telse {\t\t/* Requested a single, specific data table */\n\t\tint flag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\t/* Needed by Validate_ID */\n\t\tif ((first_item = gmtapi_validate_id (API, GMT_IS_TEXTSET, object_ID, GMT_IN, flag)) == GMT_NOTSET) {\n\t\t\tgmt_M_free (GMT, T_obj);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tlast_item = first_item;\n\t\tn_alloc = 1;\n\t}\n\tT_obj->table = gmt_M_memory (GMT, NULL, n_alloc, struct GMT_TEXTTABLE *);\n\tT_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\t/* So GMT_* modules can free this memory (may override below) */\n\tT_obj->alloc_level = GMT->hidden.func_level;\t/* So GMT_* modules can free this memory (may override below) */\n\n\tfor (item = first_item; item <= last_item; item++) {\t/* Look through all sources for registered inputs (or just one) */\n\t\tS_obj = API->object[item];\t/* Current object */\n\t\tif (!S_obj) {\t/* Probably not a good sign */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_textset: Skipped empty object (item = %d)\\n\", item);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_obj->selected) continue;\t\t\t/* Registered, but not selected */\n\t\tif (S_obj->direction == GMT_OUT) continue;\t/* We're doing reading here, so bugger off! */\n\t\tif (S_obj->family != GMT_IS_TEXTSET) continue;\t/* We're doing textsets here, so skip other things */\n\t\tif (API->module_input && !S_obj->module_input) continue;\t/* Do not mix module-inputs and option inputs if knowable */\n\t\tif (S_obj->status != GMT_IS_UNUSED) {\t/* Already read this resource before; are we allowed to re-read? */\n\t\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC) {\n\t\t\t\tgmt_M_free (GMT, T_obj->table);\tgmt_M_free (GMT, T_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Not allowed to re-read streams */\n\t\t\t}\n\t\t\tif (!(mode & GMT_IO_RESET)) {\n\t\t\t\tgmt_M_free (GMT, T_obj->table);\tgmt_M_free (GMT, T_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t\t\t}\n\t\t}\n\t\tif (this_item == GMT_NOTSET) this_item = item;\t/* First item that worked */\n\t\tvia = false;\n\t\tswitch (S_obj->method) {\t/* File, array, stream, etc. */\n\t\t\tcase GMT_IS_FILE:\t/* Import all the segments, then count total number of records */\n\t\t\t\t/* gmtlib_read_texttable will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading %s from %s %s\\n\", GMT_family[S_obj->family], GMT_method[S_obj->method], S_obj->filename);\n\t\t\t\tif ((T_obj->table[T_obj->n_tables] = gmtlib_read_texttable (GMT, S_obj->filename, S_obj->method)) == NULL) continue;\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tT_obj->table[T_obj->n_tables]->id = T_obj->n_tables;\t/* Give internal object_ID numbers to tables */\n\t\t\t\tupdate = true;\n\t\t\t\tbreak;\n\t \t\tcase GMT_IS_STREAM:\n\t \t\tcase GMT_IS_FDESC:\n\t\t\t\t/* gmtlib_read_texttable will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading %s from %s %\" PRIxS \"\\n\", GMT_family[S_obj->family], GMT_method[S_obj->method], (size_t)S_obj->fp);\n\t\t\t\tif ((T_obj->table[T_obj->n_tables] = gmtlib_read_texttable (GMT, S_obj->fp, S_obj->method)) == NULL) continue;\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tT_obj->table[T_obj->n_tables]->id = T_obj->n_tables;\t/* Give internal object_ID numbers to tables */\n\t\t\t\tupdate = true;\n\t\t\t\tbreak;\n\t\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input dataset */\n\t\t\t\tgmt_M_free (GMT, T_obj->table);\t/* Free up what we allocated since gmtlib_duplicate_textset does it all */\n\t\t\t\tgmt_M_free (GMT, T_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating text table from GMT_TEXTSET memory location\\n\");\n\t\t\t\tif (S_obj->resource == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tT_obj = gmtlib_duplicate_textset (GMT, S_obj->resource, GMT_ALLOC_NORMAL);\n\t\t\t\tbreak;\n\t\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so free up what we allocated first */\n\t\t\t\tgmt_M_free (GMT, T_obj->table);\t/* Free up what we allocated since we will just pass the pointer */\n\t\t\t\tgmt_M_free (GMT, T_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing data table from GMT_TEXTSET memory location\\n\");\n\t\t\t\tif ((T_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tbreak;\n\t\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t\t/* Each matrix source becomes a separate table with one segment */\n\t\t\t \tif ((M_obj = S_obj->resource) == NULL) {\t/* Disaster, why is it NULL? */\n\t\t\t\t\tgmt_M_free (GMT, T_obj->table);\tgmt_M_free (GMT, T_obj);\n\t\t\t \t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t \t}\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating text table from a user matrix location\\n\");\n\t\t\t\tT_obj->table[T_obj->n_tables] = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTTABLE);\n\t\t\t\tT_obj->table[T_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSEGMENT *);\n\t\t\t\tT_obj->table[T_obj->n_tables]->segment[0] = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSEGMENT);\n\t\t\t\tT_obj->table[T_obj->n_tables]->segment[0]->data = gmt_M_memory (GMT, NULL, M_obj->n_rows, char *);\n\t\t\t\tt_ptr = (char *)M_obj->data.sc1;\n\t\t\t\tfor (row = 0; row < M_obj->n_rows; row++)\n\t\t\t\t\tT_obj->table[T_obj->n_tables]->segment[0]->data[row] = strdup (&t_ptr[row*M_obj->dim]);\n\t\t\t\tT_obj->table[T_obj->n_tables]->segment[0]->n_rows = M_obj->n_rows;\n\t\t\t\tT_obj->table[T_obj->n_tables]->n_records += M_obj->n_rows;\n\t\t\t\tT_obj->table[T_obj->n_tables]->n_segments = 1;\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_TEXTSET, GMT_IS_DUPLICATE, S_obj->geometry, GMT_IN, NULL, T_obj);\t/* Register a new resource to hold T_obj */\n\t\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->data = T_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tT_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import data tables\\n\");\n\t\t\t\tgmt_M_free (GMT, T_obj->table);\n\t\t\t\tgmt_M_free (GMT, T_obj);\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (update) {\n\t\t\tT_obj->n_segments += T_obj->table[T_obj->n_tables]->n_segments;\t/* Sum up total number of segments across the data set */\n\t\t\tT_obj->n_records += T_obj->table[T_obj->n_tables]->n_records;\t/* Sum up total number of records across the data set */\n\t\t\t/* Update segment object_IDs so they are sequential across many tables (gmtlib_read_table sets the ids relative to current table). */\n\t\t\tif (T_obj->n_tables > 0)\n\t\t\t\tfor (seg = 0; seg < T_obj->table[T_obj->n_tables]->n_segments; seg++) {\n\t\t\t\t\tT_obj->table[T_obj->n_tables]->segment[seg]->id += T_obj->table[T_obj->n_tables-1]->n_segments;\n#ifdef GMT_BACKWARDS_API\n\t\t\t\t\tT_obj->table[T_obj->n_tables]->segment[seg]->record = T_obj->table[T_obj->n_tables]->segment[seg]->data;\n#endif\n\t\t\t\t}\n\t\t\tT_obj->n_tables++;\n\t\t}\n\t\tif (allocate && T_obj->n_tables == n_alloc) {\t/* Must allocate space for more tables */\n\t\t\tsize_t old_n_alloc = n_alloc;\n\t\t\tn_alloc += GMT_TINY_CHUNK;\n\t\t\tT_obj->table = gmt_M_memory (GMT, T_obj->table, n_alloc, struct GMT_TEXTTABLE *);\n\t\t\tgmt_M_memset (&(T_obj->table[old_n_alloc]), n_alloc - old_n_alloc, struct GMT_TEXTTABLE *);\t/* Set to NULL */\n\t\t}\n\t\tS_obj->alloc_mode = T_obj->alloc_mode;\t/* Clarify allocation mode for this entity */\n\t\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\t\tn_used++;\t/* Number of items actually processed */\n\t}\n\n\tif (T_obj->n_tables == 0) {\t/* Only found empty files (e.g., /dev/null) and we have nothing to show for our efforts.  Return an single empty table with no segments. */\n\t\tT_obj->table = gmt_M_memory (GMT, T_obj->table, 1, struct GMT_TEXTTABLE *);\n\t\tT_obj->table[0] = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTTABLE);\n\t\tT_obj->n_tables = 1;\t/* But we must indicate we found one (empty) table */\n\t}\n\telse {\t/* Found one or more tables */\n\t\tif (allocate && T_obj->n_tables < n_alloc) T_obj->table = gmt_M_memory (GMT, T_obj->table, T_obj->n_tables, struct GMT_TEXTTABLE *);\n\t}\n\tif (!via) T_obj->geometry = API->object[this_item]->geometry;\n\tAPI->object[this_item]->data = T_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\treturn (T_obj);\n}\n\n/*! . */\nGMT_LOCAL int api_export_textset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_TEXTSET *T_obj) {\n\t/* Does the actual work of writing out the specified text set to a single destination.\n\t * If object_ID == GMT_NOTSET we use the first registered output destination, otherwise we just use the one requested.\n\t * Again, see GMTAPI documentation for the meaning of mode.\n\t */\n\tint item, error, default_method;\n\tuint64_t tbl, row, seg, row_out;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_TEXTSET *T_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tchar *ptr = NULL;\n\tvoid *dest = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_textset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_TEXTSET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\t/* Only allow writing of a data set once, unless overridden by mode */\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\tdefault_method = GMT_IS_FILE;\n\tif (S_obj->filename)\t/* Write to this file */\n\t\tdest = S_obj->filename;\n\telse {\t\t\t/* No filename so we switch to writing to the stream */\n\t\tdefault_method = (S_obj->method == GMT_IS_FILE) ? GMT_IS_STREAM : S_obj->method;\n\t\tdest = S_obj->fp;\n\t}\n\tT_obj->io_mode = mode;\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t \tcase GMT_IS_STREAM:\n#ifdef SET_IO_MODE\n\t\t\tgmt_setmode (GMT, GMT_OUT);\n#endif\n\t\tcase GMT_IS_FILE:\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_textset (or lower) will report where it is reading from if level is GMT_MSG_LONG_VERBOSE */\n\t\t\tif ((error = gmtlib_write_textset (GMT, dest, default_method, T_obj, GMT_NOTSET))) return (gmtapi_report_error (API, error));\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input textset */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating data table to GMT_TEXTSET memory location\\n\");\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tT_copy = gmtlib_duplicate_textset (GMT, T_obj, GMT_ALLOC_NORMAL);\n\t\t\tS_obj->resource = T_copy;\t/* Set resource pointer from object to this textset */\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing data table to GMT_TEXTSET memory location\\n\");\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tT_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = T_obj;\t\t/* Set resource pointer from object to this textset */\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* Probably never tested [PW] */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating text table to user array location\\n\");\n\t\t\tM_obj = gmtlib_duplicate_matrix (GMT, S_obj->resource, false);\n\t\t\t/* Must allocate output space */\n\t\t\tM_obj->n_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? T_obj->n_records + T_obj->n_segments : T_obj->n_records;\t/* Number of rows needed [plus segment headers if active] */\n\t\t\tM_obj->n_columns = 1U;\t\t/* Number of columns needed to hold the data records */\n\t\t\tS_obj->n_alloc = gmt_M_get_nm (GMT, M_obj->n_rows, M_obj->dim);\t/* Get total number of elements as n_rows * dim */\n\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, S_obj->n_alloc)) != GMT_OK) return (gmtapi_report_error (API, error));\n\t\t\tM_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\n\t\t\tptr = (char *)M_obj->data.sc1;\n\t\t\tfor (tbl = row_out = 0; tbl < T_obj->n_tables; tbl++) {\n\t\t\t\tfor (seg = 0; seg < T_obj->table[tbl]->n_segments; seg++) {\n\t\t\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\n\t\t\t\t\t\tstrncpy (&ptr[row_out*M_obj->dim], T_obj->table[tbl]->segment[seg]->header, M_obj->dim);\n\t\t\t\t\t\trow_out++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (row = 0; row < T_obj->table[tbl]->segment[seg]->n_rows; row++, row_out++)\n\t\t\t\t\t\tstrncpy (&ptr[row_out*M_obj->dim], T_obj->table[tbl]->segment[seg]->data[row], M_obj->dim);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (M_obj->n_rows == row_out);\t/* Sanity check */\n\t\t\tM_obj->alloc_level = S_obj->alloc_level;\n\t\t\tS_obj->resource = M_obj;\t\t/* Set resource pointer from object to this matrix */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export text tables\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->alloc_mode = T_obj->alloc_mode;\t/* Clarify allocation mode for this entity */\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\tS_obj->data = NULL;\n\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL struct GMT_IMAGE *api_import_image (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_IMAGE *image) {\n\t/* Handles the reading of a 2-D grid given in one of several ways.\n\t * Get the entire image:\n \t * \tmode = GMT_CONTAINER_AND_DATA reads both header and image;\n\t * Get a subset of the image:  Call api_import_image twice:\n\t * \t1. first with mode = GMT_CONTAINER_ONLY which reads header only.  Then, pass\n\t *\t   the new S_obj-> wesn to match your desired subregion\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which reads image based on header's settings\n\t * If the image->data array is NULL it will be allocated for you.\n\t */\n\n\tint item, new_item, new_ID;\n\tbool done = true, via = false;\n\tuint64_t i0, i1, j0, j1, ij, ij_orig, row, col;\n\tunsigned int both_set = (GMT_CONTAINER_ONLY | GMT_DATA_ONLY);\n\tdouble dx, dy, d;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tstruct GMT_IMAGE *I_obj = NULL, *I_orig = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n#ifdef HAVE_GDAL\n\tbool new = false;\n\tsize_t size;\n#endif\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_image: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif ((item = gmtapi_validate_id (API, GMT_IS_IMAGE, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) return_null (API, API->error);\n\n\tS_obj = API->object[item];\t\t/* Current data object */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn_null (API, GMT_READ_ONCE);\t/* Already read this resources before, so fail unless overridden by mode */\n\tif ((mode & both_set) == both_set) mode -= both_set;\t/* Allow users to have set GMT_CONTAINER_ONLY | GMT_DATA_ONLY; reset to GMT_CONTAINER_AND_DATA */\n\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of a image file on disk */\n#ifdef HAVE_GDAL\n\t\t\tif (image == NULL) {\t/* Only allocate image struct when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tI_obj = gmtlib_create_image (GMT);\n\t\t\t\tnew = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tI_obj = image;\t/* We are passing in a image already allocated */\n\t\t\tI_obj->header->complex_mode = mode;\t\t/* Pass on any bitflags */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t\t/* Must init header and read the header information from file */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmtlib_read_image_info (GMT, S_obj->filename, I_obj), S_obj->filename)) {\n\t\t\t\t\tif (new) gmtlib_free_image (GMT, &I_obj, false);\n\t\t\t\t\treturn_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read the grid data themselves. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we extract the entire file domain */\n\t\t\tif (!I_obj->data) {\t/* Array is not allocated yet, do so now. We only expect header (and possibly w/e/s/n subset) to have been set correctly */\n\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned char);\n\t\t\t}\n\t\t\telse {\t/* Already have allocated space; check that it is enough */\n\t\t\t\tsize = api_set_grdarray_size (GMT, I_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which includes padding. DANGER DANGER JL*/\n\t\t\t\tif (size > I_obj->header->size) return_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading image from file %s\\n\", S_obj->filename);\n\t\t\tif (gmt_M_err_pass (GMT, gmtlib_read_image (GMT, S_obj->filename, I_obj, S_obj->wesn,\n\t\t\t\tI_obj->header->pad, mode), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\tif (gmt_M_err_pass (GMT, gmtlib_image_BC_set (GMT, I_obj), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_IMAGE_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tI_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n#else\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GDAL required to read image from file %s\\n\", S_obj->filename);\n#endif\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* GMT grid and header in a GMT_GRID container object. */\n\t\t\tif ((I_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (image == NULL) {\t/* Only allocate when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tI_obj = gmtlib_create_image (GMT);\n\t\t\t}\n\t\t\telse\n\t\t\t\tI_obj = image;\t/* We are passing in an image already */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t/* Must init header and copy the header information from the existing grid */\n\t\t\t\tgmt_M_memcpy (I_obj->header, I_orig->header, 1, struct GMT_GRID_HEADER);\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read grid data. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we use everything passed in */\n\t\t\tif (!I_obj->data) {\t/* Array is not allocated, do so now. We only expect header (and possibly subset w/e/s/n) to have been set correctly */\n\t\t\t\tI_obj->header->size = api_set_grdarray_size (GMT, I_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned char);\n\t\t\t\tif (I_orig->alpha) I_obj->alpha = gmt_M_memory (GMT, NULL, I_obj->header->size , unsigned char);\n\t\t\t}\n\t\t\tI_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tif (!S_obj->region && gmt_grd_pad_status (GMT, I_obj->header, GMT->current.io.pad)) {\t/* Want an exact copy with no subset and same padding */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating image data from GMT_IMAGE memory location\\n\");\n\t\t\t\tgmt_M_memcpy (I_obj->data, I_orig->data, I_orig->header->size * I_orig->header->n_bands, char);\n\t\t\t\tif (I_orig->alpha) gmt_M_memcpy (I_obj->alpha, I_orig->alpha, I_orig->header->size, char);\n\t\t\t\tbreak;\t\t/* Done with this image */\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Extracting subset image data from GMT_IMAGE memory location\\n\");\n\t\t\t/* Here we need to do more work: Either extract subset or add/change padding, or both. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\tdx = I_obj->header->inc[GMT_X] * I_obj->header->xy_off;\tdy = I_obj->header->inc[GMT_Y] * I_obj->header->xy_off;\n\t\t\tj1 = (uint64_t) gmt_M_grd_y_to_row (GMT, I_obj->header->wesn[YLO]+dy, I_orig->header);\n\t\t\tj0 = (uint64_t) gmt_M_grd_y_to_row (GMT, I_obj->header->wesn[YHI]-dy, I_orig->header);\n\t\t\ti0 = (uint64_t) gmt_M_grd_x_to_col (GMT, I_obj->header->wesn[XLO]+dx, I_orig->header);\n\t\t\ti1 = (uint64_t) gmt_M_grd_x_to_col (GMT, I_obj->header->wesn[XHI]-dx, I_orig->header);\n\t\t\tgmt_M_memcpy (I_obj->header->pad, GMT->current.io.pad, 4, int);\t/* Set desired padding */\n\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tij_orig = gmt_M_ijp (I_orig->header, row, col);\t/* Position of this (row,col) in original grid organization */\n\t\t\t\t\tij = gmt_M_ijp (I_obj->header, row, col);\t\t/* Position of this (row,col) in output grid organization */\n\t\t\t\t\tI_obj->data[ij] = I_orig->data[ij_orig];\n\t\t\t\t\tif (I_orig->alpha) I_obj->alpha[ij] = I_orig->alpha[ij_orig];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT image and header in a GMT_IMAGE container object by reference */\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing image data from GMT_IMAGE memory location\\n\");\n\t\t\tif ((I_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read image */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_image: Change alloc mode\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_image: Check pad\\n\");\n\t\t\tif (!api_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\t/* Here we extend G_obj->data to allow for padding, then rearrange rows, but only if item was allocated by GMT */\n\t\t\tif (I_obj->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_image: Add pad\\n\");\n#if 0\n\t\t\tgmt_grd_pad_on (GMT, image, GMT->current.io.pad);\n#endif\n\t\t\tif (done && S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 1;\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_image: Return from GMT_IS_REFERENCE\\n\");\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D image array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tI_obj = (image == NULL) ? gmtlib_create_image (GMT) : image;\t/* Only allocate when not already allocated */\n\t\t\tI_obj->header->complex_mode = mode;\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tapi_matrixinfo_to_grdheader (GMT, I_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tI_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t/* Must convert to new array */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Importing image data from user memory location\\n\");\n\t\t\tgmt_set_grddim (GMT, I_obj->header);\t/* Set all dimensions */\n\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size, unsigned char);\n\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\tapi_get_val = api_select_get_function (API, M_obj->type);\n\t\t\tgmt_M_grd_loop (GMT, I_obj, row, col, ij) {\n\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\n\t\t\t\tI_obj->data[ij] = (char)d;\n\t\t\t}\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_IMAGE, GMT_IS_DUPLICATE, S_obj->geometry, GMT_IN, NULL, I_obj);\t/* Register a new resource to hold I_obj */\n\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_IMAGE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->data = I_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tI_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tif (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tI_obj = (image == NULL) ? gmtlib_create_image (GMT) : image;\t/* Only allocate when not already allocated */\n\t\t\tI_obj->header->complex_mode = mode;\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tapi_matrixinfo_to_grdheader (GMT, I_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_FLOAT && M_obj->alloc_mode == GMT_ALLOC_EXTERNALLY && (mode & GMT_GRID_IS_COMPLEX_MASK)))\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_IO_ACCESS);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing image data from user memory location\\n\");\n\t\t\tI_obj->data = (unsigned char *)(M_obj->data.sc1);\n\t\t\tS_obj->alloc_mode = M_obj->alloc_mode;\t/* Pass on allocation mode of matrix */\n\t\t\tI_obj->alloc_mode = M_obj->alloc_mode;\n\t\t\tif (!api_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\tif (I_obj->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\t/* Here we extend I_obj->data to allow for padding, then rearrange rows */\n\t\t\t/* gmt_grd_pad_on (GMT, I, GMT->current.io.pad);*/\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_IMAGE, GMT_IS_REFERENCE, S_obj->geometry, GMT_IN, NULL, I_obj);\t/* Register a new resource to hold I_obj */\n\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_IMAGE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->data = I_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tI_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tif (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = I_obj->header->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import image\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as read (unless we just got the header) */\n\tif (!via) S_obj->data = I_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n#ifdef GMT_BACKWARDS_API\n\tI_obj->ColorMap = I_obj->colormap;\n\tI_obj->nIndexedColors = I_obj->n_indexed_colors;\n#endif\n\n\treturn ((mode & GMT_DATA_ONLY) ? NULL : I_obj);\t/* Pass back out what we have so far */\n}\n\nGMT_LOCAL int api_export_ppm (struct GMT_CTRL *GMT, char *fname, struct GMT_IMAGE *I) {\n\t/* Write a Portable Pixel Map (PPM) file if fname extension is .ppm, else returns */\n\t//uint32_t row, col, band;\n\tchar *ext = gmt_get_ext (fname), *magic = \"P6\\n# Produced by GMT\\n\", dim[GMT_LEN32] = {\"\"};\n\tFILE *fp = NULL;\n\tif (strcmp (ext, \"ppm\")) return 1;\t/* Not requesting a PPM file - return 1 and let GDAL take over */\n\n\tif ((fp = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {\t/* Return -1 to signify failure */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot create file %s\\n\", fname);\n\t\treturn -1;\n\t}\n\tfwrite (magic, sizeof (char), strlen (magic), fp);\t/* Write magic number, linefeed, comment, and another linefeed */\n\tsprintf (dim, \"%d %d\\n255\\n\", I->header->n_rows, I->header->n_columns);\n\tfwrite (dim, sizeof (char), strlen (dim), fp);\t/* Write dimensions and max color value + linefeeds */\n\t/* Now dump the image in scaneline order, with each pixel as (R, G, B) */\n\tif (strncmp (I->header->mem_layout, \"TRP\", 3U)) /* Easy street! */\n\t\tfwrite (I->data, sizeof(char), I->header->nm * I->header->n_bands, fp);\n#if 0\n\telse\n\tfor (row = 0; row < I->header->n_rows; row++) {\n\t\tfor (col = 0; col < I->header->n_columns; col++) {\n\t\t\tfor (band = 0; band < I->header->n_bands; band++) {\n\t\t\t\tfwrite (&(I->data[row+col*I->header->n_rows+band*I->header->nm]), sizeof(char), 1, fp);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tgmt_fclose (GMT, fp);\n\treturn GMT_NOERROR;\n}\n\n/*! Writes out a single image to destination */\nGMT_LOCAL int api_export_image (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_IMAGE *I_obj) {\n\tint item, error;\n\tbool done = true;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_IMAGE *I_copy = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_image: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif (I_obj->data == NULL && !(mode & GMT_CONTAINER_ONLY)) return (gmtapi_report_error (API, GMT_PTR_IS_NULL));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_IMAGE, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object whose data we will export */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\t/* Only allow writing of a data set once, unless overridden by mode */\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of an image file on disk */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Writing image to file %s\\n\", S_obj->filename);\n\t\t\tif ((error = api_export_ppm (API->GMT, S_obj->filename, I_obj)) == 0)\n\t\t\t\tbreak;\t/* OK, wrote a PPM and we are done */\n\t\t\telse if (error == -1) {\t/* Failed to open file */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to export image\\n\");\n\t\t\t\treturn (gmtapi_report_error (API, GMT_ERROR_ON_FOPEN));\n\t\t\t}\n#ifdef HAVE_GDAL\n\t\t\telse if (gmt_M_err_pass (API->GMT, gmt_export_image (API->GMT, S_obj->filename, I_obj), S_obj->filename))\n\t\t\t\treturn (gmtapi_report_error (API, GMT_IMAGE_WRITE_ERROR));\n#else\n\t\t\telse\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GDAL required to write image to file %s\\n\", S_obj->filename);\n#endif\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Duplicate GMT image to a new GMT_IMAGE container object */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource pointer must be NULL */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating image data to GMT_IMAGE memory location\\n\");\n\t\t\tI_copy = GMT_Duplicate_Data (API, GMT_IS_IMAGE, GMT_DUPLICATE_DATA, I_obj);\n\t\t\tS_obj->resource = I_copy;\t/* Set resource pointer to the image */\n\t\t\tbreak;\t\t/* Done with this image */\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT image and header in a GMT_IMAGE container object - just pass the reference */\n\t\t\tif (S_obj->region) return (gmtapi_report_error (API, GMT_SUBSET_NOT_ALLOWED));\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing image data to GMT_IMAGE memory location\\n\");\n\t\t\tS_obj->resource = I_obj;\t/* Set resource pointer to the image */\n\t\t\tI_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export image\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as written (unless we only updated header) */\n\tS_obj->data = NULL;\n\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL struct GMT_GRID *api_import_grid (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_GRID *grid) {\n\t/* Handles the reading of a 2-D grid given in one of several ways.\n\t * Get the entire grid:\n \t * \tmode = GMT_CONTAINER_AND_DATA reads both header and grid;\n\t * Get a subset of the grid:  Call api_import_grid twice:\n\t * \t1. first with mode = GMT_CONTAINER_ONLY which reads header only.  Then, pass\n\t *\t   the new S_obj-> wesn to match your desired subregion\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which reads grid based on header's settings\n\t * If the grid->data array is NULL it will be allocated for you.\n\t */\n\n\tint item, new_item, new_ID;\n\tbool done = true, new = false, row_by_row, via = false;\n \tuint64_t row, col, i0, i1, j0, j1, ij, ij_orig;\n\tsize_t size;\n\tunsigned int both_set = (GMT_CONTAINER_ONLY | GMT_DATA_ONLY);\n\tdouble dx, dy, d;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMT_GRID *G_obj = NULL, *G_orig = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_grid: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif ((item = gmtapi_validate_id (API, GMT_IS_GRID, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) return_null (API, API->error);\n\n\tS_obj = API->object[item];\t\t/* Current data object */\n\tif (S_obj->status != GMT_IS_UNUSED && S_obj->method == GMT_IS_FILE && !(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Already read this file before, so fail unless overridden by mode */\n\tif ((mode & both_set) == both_set) mode -= both_set;\t/* Allow users to have set GMT_CONTAINER_ONLY | GMT_DATA_ONLY; reset to GMT_CONTAINER_AND_DATA */\n\trow_by_row = ((mode & GMT_GRID_ROW_BY_ROW) || (mode & GMT_GRID_ROW_BY_ROW_MANUAL));\n\tif (row_by_row && S_obj->method != GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Can only use method GMT_IS_FILE when row-by-row reading of grid is selected\\n\");\n\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t}\n\n\tif (S_obj->region && grid) {\t/* See if this is really a subset or just the same region as the grid */\n\t\tif (grid->header->wesn[XLO] == S_obj->wesn[XLO] && grid->header->wesn[XHI] == S_obj->wesn[XHI] && grid->header->wesn[YLO] == S_obj->wesn[YLO] && grid->header->wesn[YHI] == S_obj->wesn[YHI]) S_obj->region = false;\n\t}\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of a grid file on disk */\n\t\t\tif (grid == NULL) {\t/* Only allocate grid struct when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tG_obj = gmt_create_grid (GMT);\n\t\t\t\tnew = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\t/* We are working on a grid already allocated */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t\t/* Must init header and read the header information from file */\n\t\t\t\tif (row_by_row) {\t/* Special row-by-row processing mode */\n\t\t\t\t\tchar r_mode = (mode & GMT_GRID_NO_HEADER) ? 'R' : 'r';\n\t\t\t\t\t/* If we get here more than once we only allocate extra once */\n\t\t\t\t\tif (G_obj->extra == NULL) G_obj->extra = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_ROWBYROW);\n\t\t\t\t\tif (api_open_grd (GMT, S_obj->filename, G_obj, r_mode, mode)) {\t/* Open the grid for incremental row reading */\n\t\t\t\t\t\tif (new) gmt_free_grid (GMT, &G_obj, false);\n\t\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (gmt_M_err_pass (GMT, gmtlib_read_grd_info (GMT, S_obj->filename, G_obj->header), S_obj->filename)) {\n\t\t\t\t\tif (new) gmt_free_grid (GMT, &G_obj, false);\n\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read the grid data themselves. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we extract the entire file domain */\n\t\t\tsize = api_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which includes padding */\n\t\t\tif (!G_obj->data) {\t/* Array is not allocated yet, do so now. We only expect header (and possibly w/e/s/n subset) to have been set correctly */\n\t\t\t\tG_obj->header->size = size;\n\t\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, float);\n\t\t\t}\n\t\t\telse {\t/* Already have allocated space; check that it is enough */\n\t\t\t\tif (size > G_obj->header->size) return_null (API, GMT_GRID_READ_ERROR);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Reading grid from file %s\\n\", S_obj->filename);\n\t\t\tif (gmt_M_err_pass (GMT, gmtlib_read_grd (GMT, S_obj->filename, G_obj->header, G_obj->data, S_obj->wesn,\n\t\t\t\t\t\t\tGMT->current.io.pad, mode), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tG_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tS_obj->resource = G_obj;\t/* Set resource pointer to the grid */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* GMT grid and header in a GMT_GRID container object. */\n\t\t\tif ((G_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (grid == NULL) {\t/* Only allocate when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tG_obj = gmt_create_grid (GMT);\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\t/* We are passing in a grid already */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t/* Must init header and copy the header information from the existing grid */\n\t\t\t\tgmt_M_memcpy (G_obj->header, G_orig->header, 1, struct GMT_GRID_HEADER);\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read grid data. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we use everything passed in */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating grid data from GMT_GRID memory location\\n\");\n\t\t\tif (!G_obj->data) {\t/* Array is not allocated, do so now. We only expect header (and possibly subset w/e/s/n) to have been set correctly */\n\t\t\t\tG_obj->header->size = api_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, float);\n\t\t\t}\n\t\t\tG_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tif (!S_obj->region && gmt_grd_pad_status (GMT, G_obj->header, GMT->current.io.pad)) {\t/* Want an exact copy with no subset and same padding */\n\t\t\t\tgmt_M_memcpy (G_obj->data, G_orig->data, G_orig->header->size, float);\n\t\t\t\tbreak;\t\t/* Done with this grid */\n\t\t\t}\n\t\t\t/* Here we need to do more work: Either extract subset or add/change padding, or both. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\tdx = G_obj->header->inc[GMT_X] * G_obj->header->xy_off;\tdy = G_obj->header->inc[GMT_Y] * G_obj->header->xy_off;\n\t\t\tj1 = (unsigned int)gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YLO]+dy, G_orig->header);\n\t\t\tj0 = (unsigned int)gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YHI]-dy, G_orig->header);\n\t\t\ti0 = (unsigned int)gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XLO]+dx, G_orig->header);\n\t\t\ti1 = (unsigned int)gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XHI]-dx, G_orig->header);\n\t\t\tgmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);\t/* Set desired padding */\n\t\t\t/* get stats */\n\t\t\tG_obj->header->z_min = DBL_MAX;\n\t\t\tG_obj->header->z_max = -DBL_MAX;\n\t\t\tG_obj->header->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tij_orig = gmt_M_ijp (G_orig->header, row, col);\t/* Position of this (row,col) in original grid organization */\n\t\t\t\t\tij = gmt_M_ijp (G_obj->header, row, col);\t\t/* Position of this (row,col) in output grid organization */\n\t\t\t\t\tG_obj->data[ij] = G_orig->data[ij_orig];\n\t\t\t\t\tif (gmt_M_is_fnan (G_obj->data[ij]))\n\t\t\t\t\t\tG_obj->header->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\telse {\n\t\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, G_obj->data[ij]);\n\t\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, G_obj->data[ij]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT grid and header in a GMT_GRID container object by reference */\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing grid data from GMT_GRID memory location\\n\");\n\t\t\tif ((G_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_grid: Change alloc mode\\n\");\n\t\t\tS_obj->alloc_mode = G_obj->alloc_mode;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_grid: Check pad\\n\");\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tif (!api_adjust_grdpadding (G_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\t/* Here we extend G_obj->data to allow for padding, then rearrange rows */\n\t\t\tif (G_obj->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_grid: Add pad\\n\");\n\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);\n\t\t\tif (done && S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, G_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = G_obj->header->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, G_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = G_obj->header->reset_pad = 1;\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_import_grid: Return from GMT_IS_REFERENCE\\n\");\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tG_obj = (grid == NULL) ? gmt_create_grid (GMT) : grid;\t/* Only allocate when not already allocated */\n\t\t\tG_obj->header->complex_mode = mode;\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tapi_matrixinfo_to_grdheader (GMT, G_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tG_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t/* Must convert to new array */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Importing grid data from user memory location\\n\");\n\t\t\tgmt_set_grddim (GMT, G_obj->header);\t/* Set all dimensions */\n\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, float);\n\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\tG_obj->header->z_min = +DBL_MAX;\n\t\t\tG_obj->header->z_max = -DBL_MAX;\n\t\t\tG_obj->header->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\tapi_get_val = api_select_get_function (API, M_obj->type);\n\t\t\tgmt_M_grd_loop (GMT, G_obj, row, col, ij) {\n\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\n\t\t\t\tG_obj->data[ij] = (float)d;\n\t\t\t\tif (gmt_M_is_fnan (G_obj->data[ij]))\n\t\t\t\t\tG_obj->header->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\telse {\n\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, G_obj->data[ij]);\n\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, G_obj->data[ij]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_GRID, GMT_IS_DUPLICATE, S_obj->geometry, GMT_IN, NULL, G_obj);\t/* Register a new resource to hold G_obj */\n\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_GRID, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->data = G_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tG_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tG_obj = (grid == NULL) ? gmt_create_grid (GMT) : grid;\t/* Only allocate when not already allocated */\n\t\t\tG_obj->header->complex_mode = mode;\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tapi_matrixinfo_to_grdheader (GMT, G_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_FLOAT && M_obj->alloc_mode == GMT_ALLOC_EXTERNALLY && (mode & GMT_GRID_IS_COMPLEX_MASK)))\n\t\t\t\t return_null (API, GMT_NOT_A_VALID_IO_ACCESS);\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing grid data from user memory location\\n\");\n\t\t\tG_obj->data = M_obj->data.f4;\n\t\t\tS_obj->alloc_mode = M_obj->alloc_mode;\t/* Pass on alloc_mode of matrix */\n\t\t\tG_obj->alloc_mode = M_obj->alloc_mode;\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tif (!api_adjust_grdpadding (G_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\tif (G_obj->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\t/* Here we extend G_obj->data to allow for padding, then rearrange rows */\n\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_GRID, GMT_IS_REFERENCE, S_obj->geometry, GMT_IN, NULL, G_obj);\t/* Register a new resource to hold G_obj */\n\t\t\tif ((new_item = gmtapi_validate_id (API, GMT_IS_GRID, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->data = G_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tG_obj->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tif (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, G_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = G_obj->header->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, G_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = G_obj->header->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to import grid\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n#ifdef GMT_BACKWARDS_API\n\tG_obj->header->nx = G_obj->header->n_columns;\n\tG_obj->header->ny = G_obj->header->n_rows;\n#endif\n\tif (mode & GMT_GRID_XY) {\t/* Also allocate and initialize the x and y vectors */\n\t\tG_obj->x = GMT_Get_Coord (API, GMT_IS_GRID, GMT_X, G_obj);\t/* Get array of x coordinates */\n\t\tG_obj->y = GMT_Get_Coord (API, GMT_IS_GRID, GMT_Y, G_obj);\t/* Get array of y coordinates */\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as read (unless we just got the header) */\n\tif (!via) S_obj->data = G_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\treturn (G_obj);\t/* Pass back out what we have so far */\n}\n\n/*! Writes out a single grid to destination */\nGMT_LOCAL int api_export_grid (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_GRID *G_obj) {\n\tint item, error;\n\tbool done = true, row_by_row;\n\tuint64_t row, col, i0, i1, j0, j1, ij, ijp, ij_orig;\n\tsize_t size;\n\tdouble dx, dy;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_GRID *G_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_grid: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtapi_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif (G_obj->data == NULL && !(mode & GMT_CONTAINER_ONLY)) return (gmtapi_report_error (API, GMT_PTR_IS_NULL));\n\tif ((item = gmtapi_validate_id (API, GMT_IS_GRID, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object whose data we will export */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn (gmtapi_report_error (API, GMT_WRITTEN_ONCE));\t/* Only allow writing of a data set once, unless overridden by mode */\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\trow_by_row = ((mode & GMT_GRID_ROW_BY_ROW) || (mode & GMT_GRID_ROW_BY_ROW_MANUAL));\n\tif (row_by_row && S_obj->method != GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Can only use method GMT_IS_FILE when row-by-row writing of grid is selected\\n\");\n\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t}\n\tif (S_obj->region) {\t/* See if this is really a subset or just the same region as the grid */\n\t\tif (G_obj->header->wesn[XLO] == S_obj->wesn[XLO] && G_obj->header->wesn[XHI] == S_obj->wesn[XHI] && G_obj->header->wesn[YLO] == S_obj->wesn[YLO] && G_obj->header->wesn[YHI] == S_obj->wesn[YHI]) S_obj->region = false;\n\t}\n\tif (mode & GMT_GRID_IS_GEO) gmt_set_geographic (GMT, GMT_OUT);\t/* From API to tell grid is geographic */\n\tgmtlib_grd_set_units (GMT, G_obj->header);\t/* Ensure unit strings are set, regardless of destination */\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of a grid file on disk */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) {\t/* Update header structure only */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Updating grid header for file %s\\n\", S_obj->filename);\n\t\t\t\tif (row_by_row) {\t/* Special row-by-row processing mode */\n\t\t\t\t\tchar w_mode = (mode & GMT_GRID_NO_HEADER) ? 'W' : 'w';\n\t\t\t\t\t/* Since we may get here twice (initial write; later update) we only allocate extra if NULL */\n\t\t\t\t\tif (G_obj->extra == NULL) G_obj->extra = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_ROWBYROW);\n\t\t\t\t\tif (api_open_grd (GMT, S_obj->filename, G_obj, w_mode, mode))\t/* Open the grid for incremental row writing */\n\t\t\t\t\t\treturn (gmtapi_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t\t}\n\t\t\t\telse if (gmt_update_grd_info (GMT, NULL, G_obj->header))\n\t\t\t\t\treturn (gmtapi_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t\tdone = false;\t/* Since we are not done with writing */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Writing grid to file %s\\n\", S_obj->filename);\n\t\t\t\tif (gmt_M_err_pass (GMT, gmtlib_write_grd (GMT, S_obj->filename, G_obj->header, G_obj->data, S_obj->wesn, G_obj->header->pad, mode), S_obj->filename)) return (gmtapi_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Duplicate GMT grid and header to a GMT_GRID container object. Subset allowed */\n\t\t\tif (S_obj->resource) return (gmtapi_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource pointer must be NULL */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Duplicating grid data to GMT_GRID memory location\\n\");\n\t\t\tif (!S_obj->region) {\t/* No subset, possibly same padding */\n\t\t\t\tG_copy = GMT_Duplicate_Data (API, GMT_IS_GRID, GMT_DUPLICATE_DATA, G_obj);\n\t\t\t\tif (api_adjust_grdpadding (G_copy->header, GMT->current.io.pad))\n\t\t\t\t\tgmt_grd_pad_on (GMT, G_copy, GMT->current.io.pad);\n\t\t\t\tgmt_BC_init (GMT, G_copy->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_copy, GMT_OUT), \"Grid memory\")) return (gmtapi_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\t\tS_obj->resource = G_copy;\t/* Set resource pointer to the grid */\n\t\t\t\tbreak;\t\t/* Done with this grid */\n\t\t\t}\n\t\t\t/* Here we need to extract subset, and possibly change padding. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\tG_copy = gmt_create_grid (GMT);\n\t\t\tgmt_M_memcpy (G_copy->header, G_obj->header, 1, struct GMT_GRID_HEADER);\n\t\t\tgmt_M_memcpy (G_copy->header->wesn, S_obj->wesn, 4, double);\n\t\t\tdx = G_obj->header->inc[GMT_X] * G_obj->header->xy_off;\tdy = G_obj->header->inc[GMT_Y] * G_obj->header->xy_off;\n\t\t\tj1 = (unsigned int) gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YLO]+dy, G_obj->header);\n\t\t\tj0 = (unsigned int) gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YHI]-dy, G_obj->header);\n\t\t\ti0 = (unsigned int) gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XLO]+dx, G_obj->header);\n\t\t\ti1 = (unsigned int) gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XHI]-dx, G_obj->header);\n\t\t\tgmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);\t\t/* Set desired padding */\n\t\t\tG_copy->header->size = api_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\tG_copy->data = gmt_M_memory_aligned (GMT, NULL, G_copy->header->size, float);\n\t\t\tG_copy->header->z_min = DBL_MAX;\tG_copy->header->z_max = -DBL_MAX;\t/* Must set zmin/zmax since we are not writing */\n\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tij_orig = gmt_M_ijp (G_obj->header, row, col);\t/* Position of this (row,col) in original grid organization */\n\t\t\t\t\tij = gmt_M_ijp (G_copy->header, row, col);\t/* Position of this (row,col) in output grid organization */\n\t\t\t\t\tG_copy->data[ij] = G_obj->data[ij_orig];\n\t\t\t\t\tif (gmt_M_is_fnan (G_copy->data[ij])) continue;\n\t\t\t\t\t/* Update z_min, z_max */\n\t\t\t\t\tG_copy->header->z_min = MIN (G_copy->header->z_min, (double)G_copy->data[ij]);\n\t\t\t\t\tG_copy->header->z_max = MAX (G_copy->header->z_max, (double)G_copy->data[ij]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, G_copy->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_copy, GMT_OUT), \"Grid memory\")) return (gmtapi_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\tS_obj->resource = G_copy;\t/* Set resource pointer to the grid */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT grid and header in a GMT_GRID container object - just pass the reference */\n\t\t\tif (S_obj->region) return (gmtapi_report_error (API, GMT_SUBSET_NOT_ALLOWED));\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing grid data to GMT_GRID memory location\\n\");\n#if 0\n\t\t\tif (api_adjust_grdpadding (G_obj->header, GMT->current.io.pad)) /* PW: 7/5/2016: Cannot do this since any change to region/pad would be overturned */\n\t\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);\t/* Adjust pad */\n#endif\n\t\t\tgmt_grd_zminmax (GMT, G_obj->header, G_obj->data);\t/* Must set zmin/zmax since we are not writing */\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_OUT), \"Grid memory\")) return (gmtapi_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\tS_obj->resource = G_obj;\t/* Set resource pointer to the grid */\n\t\t\tG_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT FULLY TESTED] */\n\t\t\tif (S_obj->resource == NULL) return (gmtapi_report_error (API, GMT_PTR_IS_NULL));\t/* The output resource pointer cannot be NULL for matrix */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tM_obj = gmtlib_duplicate_matrix (GMT, S_obj->resource, false);\n\t\t\tapi_grdheader_to_matrixinfo (G_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Exporting grid data to user memory location\\n\");\n\t\t\tsize = gmt_M_get_nm (GMT, G_obj->header->n_columns, G_obj->header->n_rows);\n\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, size)) != GMT_OK) return (error);\n\t\t\tM_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\tapi_put_val = api_select_put_function (API, M_obj->type);\n\t\t\tgmt_M_grd_loop (GMT, G_obj, row, col, ijp) {\n\t\t\t\tij = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\tapi_put_val (&(M_obj->data), ij, (double)G_obj->data[ijp]);\n\t\t\t}\n\t\t\tM_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT FULLY TESTED] */\n\t\t\tif (S_obj->resource == NULL) return (gmtapi_report_error (API, GMT_PTR_IS_NULL));\t/* The output resource pointer cannot be NULL for matrix */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtapi_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (api_adjust_grdpadding (G_obj->header, GMT->current.io.pad))\n\t\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);\t/* Adjust pad */\n\t\t\tM_obj = gmtlib_duplicate_matrix (GMT, S_obj->resource, false);\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_FLOAT && M_obj->alloc_mode == GMT_ALLOC_EXTERNALLY && (mode & GMT_GRID_IS_COMPLEX_MASK)))\n\t\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_IO_ACCESS));\n\t\t\tapi_grdheader_to_matrixinfo (G_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Referencing grid data to user memory location\\n\");\n\t\t\tM_obj->data.f4 = G_obj->data;\n\t\t\tM_obj->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Wrong method used to export grids\\n\");\n\t\t\treturn (gmtapi_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as written (unless we only updated header) */\n\tS_obj->data = NULL;\n\n\treturn (GMT_OK);\n}\n\n/*! . */\nGMT_LOCAL void *api_import_data (struct GMTAPI_CTRL *API, enum GMT_enum_family family, int object_ID, unsigned int mode, void *data) {\n\n\t/* Function that will import the data object referred to by the object_ID (or all registered inputs if object_ID == GMT_NOTSET).\n\t * This is a wrapper functions for CPT, Dataset, Textset, Grid and Image imports; see the specific functions\n\t * for details on the arguments, in particular the mode setting (or see the GMT API documentation).\n\t */\n\tint item, flag = GMT_NOTSET;\n\tvoid *new_obj = NULL;\n\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\t\t\t/* GMT_Create_Session has not been called */\n\tif (!API->registered[GMT_IN]) return_null (API, GMT_NO_INPUT);\t\t/* No sources registered yet */\n\n\t/* Get information about this resource first */\n\tif (multiple_files_ok (family)) {\n\t\tflag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\n\t}\n\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_IN, flag)) == GMT_NOTSET) return_null (API, API->error);\n\n\tswitch (family) {\n\t\tcase GMT_IS_PALETTE:\n\t\t\tnew_obj = api_import_palette (API, object_ID, mode);\t\t/* Try to import a CPT */\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\tnew_obj = api_import_dataset (API, object_ID, mode);\t\t/* Try to import data tables */\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\tnew_obj = api_import_textset (API, object_ID, mode);\t\t/* Try to import text tables */\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\n\t\t\tnew_obj = api_import_grid (API, object_ID, mode, data);\t/* Try to import a grid */\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tnew_obj = api_import_image (API, object_ID, mode, data);\t/* Try to import a image */\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tnew_obj = api_import_matrix (API, object_ID, mode);\t\t/* Try to import a matrix */\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tnew_obj = api_import_vector (API, object_ID, mode);\t\t/* Try to import a vector */\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tnew_obj = api_import_postscript (API, object_ID, mode);\t\t/* Try to import PS */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (new_obj == NULL) return_null (API, API->error);\t/* Return NULL as something went wrong */\n\treturn (new_obj);\t/* Successful, return pointer */\n}\n\n/*! . */\nGMT_LOCAL void *api_get_data (void *V_API, int object_ID, unsigned int mode, void *data) {\n\t/* Function to import registered data sources directly into program memory as a set (not record-by-record).\n\t * data is pointer to an existing grid container when we read a grid in two steps, otherwise use NULL.\n\t * ID is the registered resource from which to import.\n\t * Return: Pointer to data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tint item, family, flag = GMT_NOTSET;\n\tbool was_enabled;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\t/* Determine the item in the object list that matches this ID and direction */\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (object_ID == GMT_NOTSET) {\t/* Must pick up the family from the shelf */\n\t\tfamily = API->shelf;\n\t\tAPI->shelf = GMT_NOTSET;\n\t\tif (multiple_files_ok(family)) flag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\n\t}\n\telse\n\t\tfamily = GMT_NOTSET;\n\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_IN, flag)) == GMT_NOTSET) {\n\t\treturn_null (API, API->error);\n\t}\n\n\twas_enabled = API->io_enabled[GMT_IN];\n\tif (!was_enabled && api_begin_io (API, GMT_IN) != GMT_OK) {\t/* Enables data input if not already set and sets access mode */\n\t\treturn_null (API, API->error);\n\t}\n\tAPI->object[item]->selected = true;\t/* Make sure it the requested data set is selected */\n\n\t/* OK, try to do the importing */\n\tif ((new_obj = api_import_data (API, API->object[item]->family, object_ID, mode, data)) == NULL) {\n\t\treturn_null (API, API->error);\n\t}\n\n\tif (!was_enabled && GMT_End_IO (API, GMT_IN, 0) != GMT_OK) {\t/* Disables data input if we had to set it in this function */\n\t\treturn_null (API, API->error);\n\t}\n#ifdef DEBUG\n\tapi_set_object (API, API->object[item]);\n\tapi_list_objects (API, \"api_get_data\");\n#endif\n\treturn (new_obj);\t\t/* Return pointer to the data container */\n}\n\n/*! . */\nGMT_LOCAL int api_export_data (struct GMTAPI_CTRL *API, enum GMT_enum_family family, int object_ID, unsigned int mode, void *data) {\n\t/* Function that will export the single data object referred to by the object_ID as registered by GMT_Register_IO.\n\t */\n\tint error, item;\n\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tif (data == NULL) return (GMT_PTR_IS_NULL);\t\t/* Got a NULL data pointer */\n\tif (!API->registered[GMT_OUT]) return (gmtapi_report_error (API, GMT_NO_OUTPUT));\t\t/* No destination registered yet */\n\n\t/* Get information about this resource first */\n\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\t/* The case where object_ID is not set but a virtual (memory) file is found is a special case: we must supply the correct object_ID */\n\tif (object_ID == GMT_NOTSET && item && API->object[item]->method != GMT_IS_FILE)\n\t\tobject_ID = API->object[item]->ID;\t/* Found virtual file; set actual object_ID */\n\n\t/* Check if this is a container passed from the outside to capture output */\n\tif (API->object[item]->messenger && API->object[item]->data) {\t/* Need to destroy the dummy container before passing data out */\n\t\terror = api_destroy_data_ptr (API, API->object[item]->actual_family, API->object[item]->data);\t/* Do the dirty deed */\n\t\tif (error) return error;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_export_data: Messenger dummy output container for object %d [item %d] freed and set resource=data=NULL\\n\", API->object[item]->ID, item);\n\t\tAPI->object[item]->resource = API->object[item]->data = NULL;\t/* Since we now have nothing */\n\t\tAPI->object[item]->messenger = false;\t/* OK, now clean for output */\n\t}\n\n#ifdef DEBUG\n\tapi_list_objects (API, \"api_export_data-in\");\n#endif\n\tswitch (family) {\n\t\tcase GMT_IS_PALETTE:\t/* Export a CPT */\n\t\t\terror = api_export_palette (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* Export a Data set */\n\t\t\terror = api_export_dataset (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\t/* Export a Text set */\n\t\t\terror = api_export_textset (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\t/* Export a GMT grid */\n\t\t\terror = api_export_grid (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* Export a GMT image */\n\t\t\terror = api_export_image (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* Export PS */\n\t\t\terror = api_export_postscript (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* Export MATRIX */\n\t\t\terror = api_export_matrix (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* Export VECTOR */\n\t\t\terror = api_export_vector (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n#ifdef DEBUG\n\tapi_list_objects (API, \"api_export_data-out\");\n#endif\n\treturn (gmtapi_report_error (API, error));\t/* Return status */\n}\n\n/*! . */\nGMT_LOCAL int api_put_data (void *V_API, int object_ID, unsigned int mode, void *data) {\n\t/* Function to write data directly from program memory as a set (not record-by-record).\n\t * We can combine the <register resource - export resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * Here, *data is the pointer to the data object to save (CPT, dataset, textset, Grid)\n\t * ID is the registered destination.\n\t * While only one output destination is allowed, for DATA|TEXTSETS one can\n\t * have the tables and even segments be written to individual files (see the mode\n\t * description in the documentation for how to enable this feature.)\n\t * Return: false if all is well, true if there was an error (and set API->error).\n\t */\n\tint item;\n\tbool was_enabled;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\t/* Determine the item in the object list that matches this ID and direction */\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\n\n\twas_enabled = API->io_enabled[GMT_OUT];\n\tif (!was_enabled && api_begin_io (API, GMT_OUT) != GMT_OK) {\t/* Enables data output if not already set and sets access mode */\n\t\treturn_error (API, API->error);\n\t}\n\tif (api_export_data (API, API->object[item]->family, object_ID, mode, data) != GMT_OK) return_error (API, API->error);\n\n\tif (!was_enabled && GMT_End_IO (API, GMT_OUT, 0) != GMT_OK) {\t/* Disables data output if we had to set it in this function */\n\t\treturn_error (API, API->error);\n\t}\n#ifdef DEBUG\n\tapi_set_object (API, API->object[item]);\n\tapi_list_objects (API, \"api_put_data\");\n#endif\n\treturn (GMT_OK);\t/* No error encountered */\n}\n\n/*! See if this file has already been registered and used.  If so, do not add it again */\nGMT_LOCAL bool api_not_used (struct GMTAPI_CTRL *API, char *name) {\n\tunsigned int item = 0;\n\tbool not_used = true;\n\twhile (item < API->n_objects && not_used) {\n\t\tif (API->object[item] && API->object[item]->direction == GMT_IN && API->object[item]->status != GMT_IS_UNUSED &&\n\t\t    API->object[item]->filename && !strcmp (API->object[item]->filename, name))\n\t\t\t/* Used resource with same name */\n\t\t\tnot_used = false;\t/* Got item with same name, but used */\n\t\telse\n\t\t\titem++;\t/* No, keep looking */\n\t}\n\treturn (not_used);\n}\n\n/*! . */\nGMT_LOCAL int api_init_import (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int mode, struct GMT_OPTION *head) {\n\t/* Handle registration of data files given with option arguments and/or stdin as input sources.\n\t * These are the possible actions taken:\n\t * 1. If (mode | GMT_ADD_FILES_IF_NONE) is true and NO resources have previously been registered, then we scan the option list for files (option == '<' (input)).\n\t *    For each file found we register the item as a resource.\n\t * 2. If (mode | GMT_ADD_FILES_ALWAYS) is true then we always scan the option list for files (option == '<' (input)).\n\t *    For each file found we register the item as a resource.\n\t * 3. If (mode & GMT_ADD_STDIO_IF_NONE) is true we will register stdin as an input source only if there are NO input items registered.\n\t * 4. If (mode & GMT_ADD_STDIO_ALWAYS) is true we will register stdin as an input source, regardless of other items already registered.\n\t */\n\n\tint object_ID, first_ID = GMT_NOTSET, item;\n \tunsigned int n_reg = 0;\n\tstruct GMT_OPTION *current = NULL;\n\tdouble *wesn = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_import: Passed family = %s and geometry = %s\\n\", GMT_family[family], GMT_geometry[api_gmtry(geometry)]);\n\n\tif (mode & GMT_ADD_EXISTING)\n\t\tn_reg = api_add_existing (API, family, geometry, GMT_IN, &first_ID);\n\n\tif ((mode & GMT_ADD_FILES_ALWAYS) || ((mode & GMT_ADD_FILES_IF_NONE))) {\t/* Wish to register all command-line file args as sources */\n\t\tcurrent = head;\n\t\twhile (current) {\t/* Loop over the list and look for input files */\n\t\t\tif (current->option == GMT_OPT_INFILE && api_not_used (API, current->arg)) {\t/* File given, register it if has not already been used */\n\t\t\t\tif (geometry == GMT_IS_SURFACE) {\t/* Grids and images may require a subset */\n\t\t\t\t\tif (API->GMT->common.R.active[RSET]) {\t/* Global subset may have been specified (it might also match the grid/image domain) */\n\t\t\t\t\t\twesn = gmt_M_memory (API->GMT, NULL, 4U, double);\n\t\t\t\t\t\tgmt_M_memcpy (wesn, API->GMT->common.R.wesn, 4U, double);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((object_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_FILE, geometry, GMT_IN, wesn, current->arg)) == GMT_NOTSET)\n\t\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register */\n\t\t\t\tn_reg++;\t/* Count of new items registered */\n\t\t\t\tgmt_M_free (API->GMT, wesn);\n\t\t\t\tif (first_ID == GMT_NOTSET) first_ID = object_ID;\t/* Found our first ID */\n\t\t\t\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET)\n\t\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\t\t\tAPI->object[item]->selected = true;\t/* We will use this variable to find the files to read later */\n\t\t\t}\n\t\t\tcurrent = current->next;\t/* Go to next option */\n\t\t}\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_import: Added %d new sources\\n\", n_reg);\n\t}\n\n\t/* Note that n_reg can have changed if we added file args above */\n\n\tif ((mode & GMT_ADD_STDIO_ALWAYS) || ((mode & GMT_ADD_STDIO_IF_NONE) && n_reg == 0)) {\t/* Wish to register stdin pointer as a source */\n\t\tif ((object_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_STREAM, geometry, GMT_IN, NULL, API->GMT->session.std[GMT_IN])) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register stdin */\n\t\tn_reg++;\t\t/* Add the single item */\n\t\tif (first_ID == GMT_NOTSET) first_ID = object_ID;\t/* Found our first ID */\n\t\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\tAPI->object[item]->selected = true;\t/* We will use this variable to find stdin to read from later */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_import: Added stdin to registered sources\\n\");\n\t}\n\treturn (first_ID);\n}\n\n/*! . */\nGMT_LOCAL int api_init_export (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int mode, struct GMT_OPTION *head) {\n\t/* Handle registration of output file given with option arguments and/or stdout as output destinations.\n\t * Only a single output may be considered.  These are the possible actions taken:\n\t * 1. If (mode | GMT_ADD_FILES_IF_NONE) is true and NO destinations have previously been registered,\n\t *    then we scan the option list for files (option == '>' (output)).\n\t *    Only one file can be registered as a destination; finding more than one results in an error.\n\t * 2. If (mode | GMT_ADD_FILES_ALWAYS) is true then we always scan the option list for files (option == '>' (output)).\n\t *    Only one file can be registered as a destination; finding more than one results in an error.\n\t * 3. If (mode & GMT_ADD_STDIO_IF_NONE) is true we will register stdout as the only destination if there is NO output item registered.\n\t * 4. If (mode & GMT_ADD_STDIO_ALWAYS) is true we will register stdout as an destination,\n\t *    and give error if other output items have already been registered.\n\t */\n\n\tunsigned int n_reg = 0;\n\tint object_ID = GMT_NOTSET, item;\n\tstruct GMT_OPTION *current = NULL, *out_item = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_export: Passed family = %s and geometry = %s\\n\", GMT_family[family], GMT_geometry[api_gmtry(geometry)]);\n\n\tif (mode & GMT_ADD_EXISTING)\n\t\tn_reg = api_add_existing (API, family, geometry, GMT_OUT, &object_ID);\n\tif (n_reg > 1) return_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output allowed */\n\n\tif ((mode & GMT_ADD_FILES_ALWAYS) || (mode & GMT_ADD_FILES_IF_NONE)) {\t/* Wish to register a single output file arg as destination */\n\t\tcurrent = head;\n\t\twhile (current) {\t/* Loop over the list and look for output files */\n\t\t\tif (current->option == GMT_OPT_OUTFILE) {\t/* Output file given */\n\t\t\t\tn_reg++;\t/* Count it */\n\t\t\t\tout_item = current;\t/* Remember which one it was for later */\n\t\t\t}\n\t\t\tcurrent = current->next;\t\t\t\t/* Go to next option */\n\t\t}\n\t\tif (n_reg > 1) return_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output allowed */\n\n\t\tif (n_reg == 1 && out_item) {\t/* Register the single output file found above */\n\t\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_FILE, geometry, GMT_OUT, NULL, out_item->arg)) == GMT_NOTSET)\n\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register */\n\t\t\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\t\tAPI->object[item]->selected = true;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_export: Added 1 new destination\\n\");\n\t\t}\n\t}\n\t/* Note that n_reg may have changed if we added file arg */\n\n\tif ((mode & GMT_ADD_STDIO_ALWAYS) && n_reg == 1)\n\t\treturn_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output destination allowed at once */\n\n\tif (n_reg == 0 && ((mode & GMT_ADD_STDIO_ALWAYS) || (mode & GMT_ADD_STDIO_IF_NONE))) {\t/* Wish to register stdout pointer as a destination */\n\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, NULL, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register stdout?*/\n\t\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\tAPI->object[item]->selected = true;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_init_export: Added stdout to registered destinations\\n\");\n\t\tn_reg = 1;\t/* Only have one item */\n\t}\n\tif (n_reg == 0) return_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\t/* No output set */\n\treturn (object_ID);\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_image (struct GMTAPI_CTRL *API, struct GMT_IMAGE **I_obj) {\n\t/* Delete the given image resource */\n\n\tif (!(*I_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_image: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*I_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_image (API->GMT, I_obj, true);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_grid (struct GMTAPI_CTRL *API, struct GMT_GRID **G_obj) {\n\t/* Delete the given grid resource. */\n\n\tif (!(*G_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_grid: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*G_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_grid (API->GMT, G_obj, true);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_dataset (struct GMTAPI_CTRL *API, struct GMT_DATASET **D_obj) {\n\t/* Delete the given dataset resource. */\n\n\tif (!(*D_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_dataset: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*D_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_dataset (API->GMT, D_obj);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_textset (struct GMTAPI_CTRL *API, struct GMT_TEXTSET **T_obj) {\n\t/* Delete the given textset resource. */\n\n\tif (!(*T_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_textset: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*T_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_textset (API->GMT, T_obj);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_palette (struct GMTAPI_CTRL *API, struct GMT_PALETTE **P_obj) {\n\t/* Delete the given CPT resource. */\n\n\tif (!(*P_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_palette: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*P_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_palette (API->GMT, P_obj);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_postscript (struct GMTAPI_CTRL *API, struct GMT_POSTSCRIPT **P_obj) {\n\t/* Delete the given GMT_POSTSCRIPT resource. */\n\n\tif (!(*P_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_postscript: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*P_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_ps (API->GMT, P_obj);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_matrix (struct GMTAPI_CTRL *API, struct GMT_MATRIX **M_obj) {\n\t/* Delete the given Matrix resource. */\n\n\tif (!(*M_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_matrix: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*M_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_matrix (API->GMT, M_obj, true);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_vector (struct GMTAPI_CTRL *API, struct GMT_VECTOR **V_obj) {\n\t/* Delete the given Matrix resource. */\n\n\tif (!(*V_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_destroy_vector: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tif ((*V_obj)->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_vector (API->GMT, V_obj, true);\n\treturn GMT_OK;\n}\n\n/*! . */\nGMT_LOCAL struct GMTAPI_DATA_OBJECT * api_make_dataobject (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int method, unsigned int geometry, void *resource, unsigned int direction) {\n\t/* Simply the creation and initialization of this DATA_OBJECT structure */\n\tstruct GMTAPI_DATA_OBJECT *S_obj = gmt_M_memory (API->GMT, NULL, 1, struct GMTAPI_DATA_OBJECT);\n\n\tS_obj->family    = S_obj->actual_family = family;\t/* At creation we are all equal */\n\tS_obj->method    = method;\n\tS_obj->geometry  = geometry;\n\tS_obj->resource  = resource;\n\tS_obj->direction = direction;\n\n\treturn (S_obj);\n}\n\n/*! . */\nGMT_LOCAL int api_colors2cpt (struct GMTAPI_CTRL *API, char **str, unsigned int *mode) {\n\t/* Take comma-separated color entries given in lieu of a file and build a linear, discrete CPT.\n\t * This may be converted to a continuous CPT if -Z is used by makecpt/grd2cpt.\n\t * We check if a color is valid then write the given entries verbatim to the temp file.\n\t * Returns GMT_NOTSET on error, 0 if no CPT is created (str presumably held a CPT name) and 1 otherwise.\n\t*/\n\tunsigned int pos = 0, z = 0;\n\tchar *pch = NULL, color[GMT_LEN256] = {\"\"}, tmp_file[GMT_LEN64] = \"\";\n\tdouble rgb[4] = {0.0, 0.0, 0.0, 0.0};\n\tFILE *fp = NULL;\n\n\tif (!(pch = strchr (*str, ','))) {\t/* No comma so presumably a regular CPT name, but check for single color entry */\n\t\tbool gray = true;\n\t\tsize_t k;\n\t\tconst size_t s_length = strlen(*str);\n\t\t /* Since \"gray\" is both a master CPT and a shade we must let the CPT take precedence */\n\t\tif (!strcmp (*str, \"gray\"))\n\t\t\treturn (0);\n\t\t/* Because gmtlib_is_color cannot uniquely determine what a single number is, check for that separately first. */\n\t\tfor (k = 0; gray && k < s_length; k++)\n\t\t\tif (!isdigit ((*str)[k])) gray = false;\t/* Not just a bunch of integers */\n\t\tif (gray) {\t/* Must also rule out temporary files like 14334.cpt since the \".cpt\" is not present */\n\t\t\tsprintf (tmp_file, \"%s.cpt\", *str);\t/* Try this as a filename */\n\t\t\tif (!gmt_access (API->GMT, tmp_file, F_OK))\n\t\t\t\treturn 0;\t/* Probably a process id temp file like 13223.cpt */\n\t\t}\n\t\tif (!gray && !gmtlib_is_color (API->GMT, *str))\t/* Not a single color/shade, skip */\n\t\t\treturn (0);\n\t}\n\n\t/* OK, here we need to create the temporary palette file */\n\tsnprintf (tmp_file, GMT_LEN64, \"api_colors2cpt_%d.cpt\", (int)getpid());\n\tif ((fp = fopen (tmp_file, \"w\")) == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s file for writing\\n\", tmp_file);\n\t\treturn (GMT_NOTSET);\n\t}\n\n\tif ((*mode) & GMT_CPT_CONTINUOUS) {\t/* Make a continuous cpt from the colors */\n\t\tchar last_color[GMT_LEN256] = {\"\"};\n\t\tif (!gmt_strtok (*str, \",\", &pos, last_color)) {\t/* Get 1st color entry */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to find 1st color entry in: %s\\n\", *str);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t\tif (gmt_getrgb (API->GMT, last_color, rgb)) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Badly formatted color entry: %s\\n\", color);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t\twhile (gmt_strtok (*str, \",\", &pos, color)) {\t/* Get color entries */\n\t\t\tif (gmt_getrgb (API->GMT, color, rgb)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Badly formatted color entry: %s\\n\", color);\n\t\t\t\tfclose (fp);\n\t\t\t\treturn (GMT_NOTSET);\n\t\t\t}\n\t\t\tfprintf (fp, \"%d\\t%s\\t%d\\t%s\\n\", z, last_color, z+1, color);\n\t\t\tstrncpy (last_color, color, GMT_LEN256-1);\n\t\t\tz++;\t/* Increment z-slice values */\n\t\t}\n\t\t*mode -= GMT_CPT_CONTINUOUS;\t/* Served its purpose */\n\t\tif (z == 0) {\t/* Needed at least two colors to specify a ramp */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Cannot make a continuous color ramp from a single color: %s\\n\", *str);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t}\n\telse {\n\t\twhile (gmt_strtok (*str, \",\", &pos, color)) {\t/* Get color entries */\n\t\t\tif (gmt_getrgb (API->GMT, color, rgb)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Badly formatted color entry: %s\\n\", color);\n\t\t\t\tfclose (fp);\n\t\t\t\treturn (GMT_NOTSET);\n\t\t\t}\n\t\t\tfprintf (fp, \"%d\\t%s\\t%d\\t%s\\n\", z, color, z+1, color);\n\t\t\tz++;\t/* Increment z-slice values */\n\t\t}\n\t}\n\tfclose (fp);\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Converted %s to CPT %s\\n\", *str, tmp_file);\n\n\tgmt_M_str_free (*str);\t\t/* Because it was allocated with strdup */\n\t*str = strdup (tmp_file);\t/* Pass out the temp file name instead */\n\n\treturn (1);\t/* We replaced the name */\n}\n\n/*! . */\nGMT_LOCAL int api_destroy_coord (struct GMTAPI_CTRL *API, double **ptr) {\n\tgmt_M_free (API->GMT, *ptr);\n\treturn GMT_OK;\n}\n\n/*! Also called in gmt_init.c and prototyped in gmt_internals.h: */\nvoid gmtapi_garbage_collection (struct GMTAPI_CTRL *API, int level) {\n\t/* gmtapi_garbage_collection frees all registered memory associated with the\n\t * current module level or for the entire session if level == GMT_NOTSET (-1). */\n\n\tunsigned int i, j, n_free = 0, u_level = 0;\n\tint error = GMT_NOERROR;\n\tvoid *address = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (API->n_objects == 0) return;\t/* Nothing to do */\n\n\t/* Free memory allocated during data registration (e.g., via GMT_Get|Put_Data).\n\t * Because gmtapi_unregister_io will delete an object and shuffle\n\t * the API->object array, reducing API->n_objects by one we must\n\t * be aware that API->n_objects changes in the loop below, hence the while loop */\n\n\ti = n_free = 0;\n\tif (level != GMT_NOTSET) u_level = level;\n\twhile (i < API->n_objects) {\t/* While there are more objects to consider */\n\t\tS_obj = API->object[i];\t/* Shorthand for the the current object */\n\t\tif (!S_obj) {\t\t/* Skip empty object [NOTE: Should not happen?] */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"gmtapi_garbage_collection found empty object number %d [Bug?]\\n\", i++);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(level == GMT_NOTSET || S_obj->alloc_level == u_level)) {\t/* Not the right module level (or not end of session yet) */\n\t\t\tif (S_obj->reset_pad && S_obj->no_longer_owner == false) {\t/* Temporarily changed pad to access a sub-region of a memory grid - now reset this if still the owner */\n\t\t\t\taddress = (S_obj->data) ? S_obj->data : S_obj->resource;\t/* Try to get the data object */\n\t\t\t\tgmtlib_contract_pad (API->GMT, address, S_obj->family, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\tS_obj->reset_pad = 0;\n\t\t\t}\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\tif (!(S_obj->data || S_obj->resource)) {\t/* No memory to free (probably freed earlier); handle trashing of empty object after this loop */\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\tif (S_obj->no_longer_owner) {\t/* No memory to free since we passed it on; just NULL the pointers */\n\t\t\tS_obj->data = S_obj->resource = NULL;\t\t/* Since other objects own the data now */\n\t\t\tS_obj->alloc_level = u_level;\t\t\t/* To ensure it will be Unregistered below */\n\t\t\tS_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\t/* To ensure it will be Unregistered below */\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\t/* Here we will try to free the memory pointed to by S_obj->resource|data */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_garbage_collection: Destroying object: C=%d A=%d ID=%d W=%s F=%s M=%s S=%s P=%\" PRIxS \" D=%\" PRIxS \" N=%s\\n\",\n\t\t\tS_obj->close_file, S_obj->alloc_mode, S_obj->ID, GMT_direction[S_obj->direction],\n\t\t\tGMT_family[S_obj->family], GMT_method[S_obj->method], GMT_status[S_obj->status&2],\n\t\t\t(size_t)S_obj->resource, (size_t)S_obj->data, S_obj->filename);\n\t\tif (S_obj->data) {\n\t\t\taddress = S_obj->data;\t/* Keep a record of what the address was (since S_obj->data will be set to NULL when freed) */\n\t\t\terror = api_destroy_data_ptr (API, S_obj->actual_family, API->object[i]->data);\t/* Do the dirty deed */\n\t\t}\n\t\telse if (S_obj->resource) {\n\t\t\taddress = S_obj->resource;\t/* Keep a record of what the address was (since S_obj->data will be set to NULL when freed) */\n\t\t\terror = api_destroy_data_ptr (API, S_obj->actual_family, API->object[i]->resource);\t/* Do the dirty deed */\n\t\t}\n\n\t\tif (error < 0) {\t/* Failed to destroy this memory; that cannot be a good thing... */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"gmtapi_garbage_collection failed to destroy memory for object % d [Bug?]\\n\", i++);\n\t\t\t/* Skip it for now; but this is possibly a fatal error [Bug]? */\n\t\t}\n\t\telse  {\t/* Successfully freed.  See if this address occurs more than once (e.g., both for in and output); if so just set repeated data pointer to NULL */\n\t\t\tS_obj->data = S_obj->resource = NULL;\n\t\t\tfor (j = i; j < API->n_objects; j++) {\n\t\t\t\tif (API->object[j]->data == address)\n\t\t\t\t\tAPI->object[j]->data = NULL;\t\t/* Yes, set to NULL so we don't try to free twice */\n\t\t\t\tif (API->object[j]->resource == address)\n\t\t\t\t\tAPI->object[j]->resource = NULL;\t/* Yes, set to NULL so we don't try to free twice */\n\t\t\t}\n\t\t\tn_free++;\t/* Number of freed n_objects; do not increment i since GMT_Destroy_Data shuffled the array */\n\t\t}\n\t\ti++;\t/* Go to next object */\n\t}\n \tif (n_free) GMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI_Garbage_Collection freed %d memory objects\\n\", n_free);\n\n\t/* Deallocate all remaining objects associated with NULL pointers (e.g., rec-by-rec i/o or those set to NULL above) set during this module (or session) */\n\ti = 0;\n\twhile (i < API->n_objects) {\t/* While there are more objects to consider */\n\t\tS_obj = API->object[i];\t/* Shorthand for the the current object */\n\t\tif (S_obj && (level == GMT_NOTSET || (S_obj->alloc_level == u_level)))\t/* Yes, this object was added at this level, get rid of it; do not increment i */\n\t\t\tgmtapi_unregister_io (API, (int)S_obj->ID, (unsigned int)GMT_NOTSET);\t/* This shuffles the object array and reduces n_objects */\n\t\telse\n\t\t\ti++;\t/* Was allocated higher up, leave alone and go to next */\n\t}\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMTAPI_Garbage_Collection\");\n#endif\n}\n\n/*! Determine if resource is a filename and that it has already been registered */\nGMT_LOCAL int api_memory_registered (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, void *resource) {\n\tint object_ID = 0, item;\n\tunsigned int module_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we dealing with a resource that is a module input? */\n\tfamily -= module_input;\n\n\tif (family == GMT_IS_COORD) return (GMT_NOTSET);\t/* Coordinate arrays cannot be a registered memory resource */\n\tif ((object_ID = api_decode_id (resource)) == GMT_NOTSET) return (GMT_NOTSET);\t/* Not a registered resource */\n\tif ((item = gmtapi_validate_id (API, family, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return (GMT_NOTSET);\t/* Not the right attributes */\n\tif (module_input && direction == GMT_IN) API->object[item]->module_input = true;\t/* Flag this object as a module input resource */\n\treturn (object_ID);\t/* resource is a registered and valid item */\n}\n\n/*! Determine if file contains a netCDF directive to a specific variable, e.g., table.nc?time[2] */\nGMT_LOCAL bool api_file_with_netcdf_directive (struct GMTAPI_CTRL *API, const char *file) {\n\tchar *duplicate = NULL, *c = NULL;\n\tif (!strchr (file, '?')) return false;  /* No question mark found */\n\tduplicate = strdup (file);              /* Found a ?, duplicate this const char string and chop off the end */\n\tc = strchr (duplicate, '?');            /* Locate the location of ? again */\n\tif (c) c[0] = '\\0';                     /* Chop off text from ? onwards */\n\tif (gmt_access (API->GMT, duplicate, F_OK)) {\t/* No such file, presumably */\n\t\tfree (duplicate);\n\t\treturn false;\n\t}\n\telse {\t/* Since the file exist we know it is a netCDF directive */\n\t\tfree (duplicate);\n\t\treturn true;\n\t}\n}\n\n/* Several lower-level API function are needed in a few other gmt_*.c library codes and are thus NOT local.\n * They are listed here and declared via MSC_EXTERN where they occur:\n *   gmtapi_report_error\n *   gmtapi_validate_id\n *   gmtapi_unregister_io\n *   gmtapi_count_objects\n *   gmtapi_close_grd\n *   gmtapi_create_header_item\n * If DEBUG is defined then these two are also accessible:\n *   api_list_objects\n *   api_set_object\n */\n\n\n/*! ===>  Error message reporting */\n\nint gmtapi_report_error (void *V_API, int error) {\n\t/* Write error message to log or stderr, then return error code back.\n \t * All functions can call this, even if API has not been initialized. */\n\tFILE *fp = NULL;\n\tbool report;\n\tchar message[GMT_LEN256];\n\tstruct GMTAPI_CTRL *API = api_get_api_ptr (V_API);\n\n\treport = (API) ? API->error != API->last_error : true;\n\tif (report && error != GMT_OK) {\t/* Report error */\n\t\tif (!API || !API->GMT || (fp = API->GMT->session.std[GMT_ERR]) == NULL) fp = stderr;\n\t\tif (API && API->session_tag) {\n\t\t\tsnprintf (message, GMT_LEN256, \"[Session %s (%d)]: Error returned from GMT API: %s (%d)\\n\",\n\t\t\t\tAPI->session_tag, API->session_ID, gmt_api_error_string[error], error);\n\t\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t\t}\n\t\telse\n\t\t\tfprintf (fp, \"Error returned from GMT API: %s (%d)\\n\", gmt_api_error_string[error], error);\n\t}\n\tif (API) API->last_error = API->error, API->error = error;\t/* Update API error value if API exists */\n\treturn (error);\n}\n\n/*! . */\nint gmtapi_validate_id (struct GMTAPI_CTRL *API, int family, int object_ID, int direction, int module_input) {\n\t/* Checks to see if the given object_ID is listed and of the right direction.  If so\n \t * we return the item number; otherwise return GMT_NOTSET and set API->error to the error code.\n\t * Note: int arguments MAY be GMT_NOTSET, hence we use signed ints.  If object_ID == GMT_NOTSET\n\t * then we only look for TEXTSETS or DATASETS.  Note: module_input controls if we are being very specific\n\t * about the type of input resource.  There are module inputs and option inputs. We have:\n\t * module_input = GMT_NOTSET [-1]:\tDo not use the resource's module_input status in determining the next ID.\n\t * module_input = GMTAPI_OPTION_INPUT [0]:\tOnly validate resources with module_input = false.\n\t * module_input = GMTAPI_MODULE_INPUT [1]:\tOnly validate resources with module_input = true.\n\t * Finally, since we allow vectors and matrices to masqerade as DATASETs we check for this and\n\t * rebaptize such objects to become GMT_IS_DATASETs. */\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\t /* Search for the object in the active list.  However, if object_ID == GMT_NOTSET we pick the first in that direction */\n\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tS_obj = API->object[i];\t/* Shorthand only */\n\t\tif (!S_obj) continue;\t\t\t\t\t\t\t\t/* Empty object */\n\t\tif (direction == GMT_IN && S_obj->status != GMT_IS_UNUSED) continue;\t\t/* Already used this input object once */\n\t\tif (!(family == GMT_NOTSET || (int)S_obj->family == family)) {\t\t/* Not the required data type; check for exceptions... */\n\t\t\tif (family == GMT_IS_DATASET && (S_obj->family == GMT_IS_VECTOR || S_obj->family == GMT_IS_MATRIX))\n\t\t\t\tS_obj->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse\t/* We don't like your kind */\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (object_ID == GMT_NOTSET && (int)S_obj->direction == direction) item = i;\t/* Pick the first object with the specified direction */\n\t\tif (object_ID == GMT_NOTSET && !(S_obj->family == GMT_IS_DATASET || S_obj->family == GMT_IS_TEXTSET)) continue;\t/* Must be data/text-set */\n\t\telse if (direction == GMT_NOTSET && (int)S_obj->ID == object_ID) item = i;\t/* Pick the requested object regardless of direction */\n\t\telse if ((int)S_obj->ID == object_ID) item = i;\t\t\t\t\t/* Pick the requested object */\n\t\tif (item != GMT_NOTSET && direction == GMT_IN && module_input != GMT_NOTSET) {\t\t/* Must check that object's module_input status matches */\n\t\t\tbool status = (module_input == GMTAPI_MODULE_INPUT) ? true : false;\n\t\t\tif (status != S_obj->module_input) item = GMT_NOTSET;\t/* Not the right type of input resource */\n\t\t}\n\t}\n\tif (item == GMT_NOTSET) { API->error = GMT_NOT_A_VALID_ID; return (GMT_NOTSET); }\t\t/* No such object found */\n\n\t/* OK, we found the object; is it the right kind (input or output)? */\n\tif (direction != GMT_NOTSET && (int)(API->object[item]->direction) != direction) {\n\t\t/* Passing an input object but it is listed as output, or vice versa */\n\t\tif (direction == GMT_IN)  { API->error = GMT_NOT_INPUT_OBJECT;  return (GMT_NOTSET); }\n\t\tif (direction == GMT_OUT) { API->error = GMT_NOT_OUTPUT_OBJECT; return (GMT_NOTSET); }\n\t}\n\t/* Here we have been successful in finding the right object */\n\treturn (item);\n}\n\n/*! . */\nint gmtapi_unregister_io (struct GMTAPI_CTRL *API, int object_ID, unsigned int direction) {\n\t/* Remove specified object ID from active list of objects */\n\tint s_item;\n\tunsigned item;\n\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\t\t/* GMT_Create_Session has not been called */\n\tif (API->n_objects == 0) return (gmtapi_report_error (API, GMT_NO_RESOURCES));\t/* There are no known resources yet */\n\n\t/* Check if this is a valid ID and matches the direction */\n\tif ((s_item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return (gmtapi_report_error (API, API->error));\n\n\t/* OK, now it is safe to remove the object; item >= 0 */\n\n\titem = s_item;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_unregister_io: Unregistering object no %d [n_objects = %d]\\n\", API->object[item]->ID, API->n_objects-1);\n \tif (API->object[item]->data) GMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_unregister_io: Object no %d has non-NULL data pointer\\n\", API->object[item]->ID);\n \tif (API->object[item]->resource) GMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_unregister_io: Object no %d has non-NULL resource pointer\\n\", API->object[item]->ID);\n\n\tif (API->object[item]->method == GMT_IS_FILE) gmt_M_str_free (API->object[item]->filename);\t/* Free any strdup-allocated filenames */\n\tgmt_M_free (API->GMT, API->object[item]);\t\t/* Free the current data object */\n\tAPI->n_objects--;\t\t\t\t/* Tally of how many data sets are left */\n\twhile (item < API->n_objects) {\n\t\tAPI->object[item] = API->object[item+1];\t/* Shuffle pointers down one entry */\n\t\titem++;\n\t}\n\n\t/* All active resources are found consecutively from 0 to (API->n_objects-1); those with status == 0 (GMT_IS_UNUSED) are available for use. */\n\treturn GMT_OK;\n}\n\n/*! . */\nunsigned int gmtapi_count_objects (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int direction, int *first_ID) {\n\t/* Count how many data sets of the given family are currently registered and unused for the given direction (GMT_IN|GMT_OUT).\n \t * Also return the ID of the first unused data object for the given direction, geometry, and family (GMT_NOTSET if not found).\n\t */\n\tunsigned int i, n;\n\n\t*first_ID = GMT_NOTSET;\t/* Not found yet */\n\tfor (i = n = 0; i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t /* A freed object, skip it */\n\t\tif (API->object[i]->direction != (enum GMT_enum_std)direction) continue;\t  /* Wrong direction */\n\t\tif (API->object[i]->geometry  != (enum GMT_enum_geometry)geometry) continue;\t  /* Wrong geometry */\n\t\tif (API->object[i]->status    != GMT_IS_UNUSED) continue; /* Already used */\n\t\tif (family != API->object[i]->family) continue;\t\t  /* Wrong data type */\n\t\tn++;\t/* Found one that satisfied requirements */\n\t\tif (*first_ID == GMT_NOTSET) *first_ID = API->object[i]->ID;\n\t}\n\treturn (n);\n}\n\n/*! . */\nchar *gmtapi_create_header_item (struct GMTAPI_CTRL *API, unsigned int mode, void *arg) {\n\tsize_t lim;\n\tchar *txt = (mode & GMT_COMMENT_IS_OPTION) ? GMT_Create_Cmd (API, arg) : (char *)arg;\n\tstatic char buffer[GMT_BUFSIZ];\n\tgmt_M_memset (buffer, GMT_BUFSIZ, char);\n\tif (mode & GMT_COMMENT_IS_TITLE) strcat (buffer, \"  Title :\");\n\tif (mode & GMT_COMMENT_IS_COMMAND) {\n\t\tstrcat (buffer, \" Command : \");\n\t\tif (strlen(API->GMT->init.module_name) < 500)\t\t/* 500, just to shut up a Coverity issue */\n\t\t\tstrcat (buffer, API->GMT->init.module_name);\n\t\tstrcat (buffer, \" \");\n\t}\n    if (mode & GMT_COMMENT_IS_REMARK) strcat (buffer, \" Remark : \");\n\tif (mode & GMT_COMMENT_IS_MULTISEG) strcat (buffer, \"> \");\n\tlim = GMT_BUFSIZ - strlen (buffer) - 1;\t/* Max characters left */\n\tstrncat (buffer, txt, lim);\n\tif (mode & GMT_COMMENT_IS_OPTION) gmt_M_free (API->GMT, txt);\n\treturn (buffer);\n}\n\n/*! . */\nvoid gmtapi_close_grd (struct GMT_CTRL *GMT, struct GMT_GRID *G) {\n\tstruct GMT_GRID_ROWBYROW *R = api_get_rbr_ptr (G->extra);\t/* Shorthand to row-by-row book-keeping structure */\n\tgmt_M_free (GMT, R->v_row);\n\tif (GMT->session.grdformat[G->header->type][0] == 'c' || GMT->session.grdformat[G->header->type][0] == 'n')\n\t\tnc_close (R->fid);\n\telse\n\t\tgmt_fclose (GMT, R->fp);\n\tgmt_M_free (GMT, G->extra);\n}\n\n/*========================================================================================================\n *          HERE ARE THE PUBLIC GMT API UTILITY FUNCTIONS, WITH THEIR FORTRAN BINDINGS\n *========================================================================================================\n */\n\n/*! ===>  Create a new GMT Session */\n\nvoid *GMT_Create_Session (const char *session, unsigned int pad, unsigned int mode, int (*print_func) (FILE *, const char *)) {\n\t/* Initializes the GMT API for a new session. This is typically called once in a program,\n\t * but programs that manage many threads might call it several times to create as many\n\t * sessions as needed. [Note: There is of yet no thread support built into the GMT API\n\t * but you could still manage many sessions at once].\n\t * The session argument is a textstring used when reporting errors or messages from activity\n\t *   originating within this session.\n\t * Pad sets the default number or rows/cols used for grid padding.  GMT uses 2; users of\n\t *   the API may wish to use 0 if they have no need for BCs, etc.\n\t * The mode argument is a bitflag that controls a few things [0, or GMT_SESSION_NORMAL]:\n\t *   bit 1 (GMT_SESSION_NOEXIT)   means call return and not exit when returning from an error.\n\t *   bit 2 (GMT_SESSION_EXTERNAL) means we are called by an external API (e.g., MATLAB, Python).\n\t *   bit 3 (GMT_SESSION_COLMAJOR) means the external API uses column-major format (e.g., MATLAB, Fortran) [Default is row-major, i.e., C/C++, Python]\n\t *   We reserve the right to add future flags.\n\t * We return the pointer to the allocated API structure.\n\t * If any error occurs we report the error, set the error code via API->error, and return NULL.\n\t * We terminate each session with a call to GMT_Destroy_Session.\n\t */\n\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstatic char *unknown = \"unknown\";\n\tchar *dir = NULL;\n\n\tif ((API = calloc (1, sizeof (struct GMTAPI_CTRL))) == NULL) return_null (NULL, GMT_MEMORY_ERROR);\t/* Failed to allocate the structure */\n\tAPI->verbose = (mode >> 16);\t/* Pick up any -V settings from gmt.c */\n\tAPI->pad = pad;\t\t/* Preserve the default pad value for this session */\n\tAPI->print_func = (print_func == NULL) ? api_print_func : print_func;\t/* Pointer to the print function to use in GMT_Message|Report */\n\tAPI->do_not_exit = mode & GMT_SESSION_NOEXIT;\t/* if set, then api_exit & GMT_exit are simply a return; otherwise they call exit */\n\tAPI->external = mode & GMT_SESSION_EXTERNAL;\t/* if false|0 then we don't list read and write as modules */\n\tAPI->shape = (mode & GMT_SESSION_COLMAJOR) ? GMT_IS_COL_FORMAT : GMT_IS_ROW_FORMAT;\t\t/* if set then we must use column-major format [row-major] */\n\tAPI->runmode = mode & GMT_SESSION_RUNMODE;\t\t/* If nonzero we set up modern GMT run-mode, else classic */\n\tif (API->internal) API->leave_grid_scaled = 1;\t/* Do NOT undo grid scaling after write since modules do not reuse grids we save some CPU */\n\tif (session) {\t/* Pick up a tag for this session */\n\t\tchar *tmptag = strdup (session);\n\t\tAPI->session_tag = strdup (basename (tmptag));\t/* Only used in reporting and error messages */\n\t\tgmt_M_str_free (tmptag);\n\t}\n\n\t/* Set temp directory used by GMT */\n\n#ifdef WIN32\n\tif ((dir = getenv (\"TEMP\")))\t/* Standard Windows temp directory designation */\n\t\tAPI->tmp_dir = strdup (dir);\n\t/* If not found we leave it NULL */\n#else\n\tif ((dir = getenv (\"TMPDIR\")))\t/* Alternate tmp dir for *nix */\n\t\tAPI->tmp_dir = strdup (dir);\n\telse\t/* Set standard temporary directory under *nix */\n\t\tAPI->tmp_dir = strdup (\"/tmp\");\n#endif\n\tAPI->PPID = api_get_ppid (API);\t\t/* Save PPID for the rest of the session */\n\n\t/* gmt_begin initializes, among other things, the settings in the user's (or the system's) gmt.conf file */\n\tif (gmt_begin (API, session, pad) == NULL) {\t\t/* Initializing GMT and PSL machinery failed */\n\t\tgmt_M_str_free (API);\t/* Free API */\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Create_Session initialized GMT structure\\n\");\n\n\tAPI->n_cores = gmtlib_get_num_processors();\t/* Get number of available CPU cores */\n\n\t/* Allocate memory to keep track of registered data resources */\n\n\tAPI->n_objects_alloc = GMT_SMALL_CHUNK;\t/* Start small; this may grow as more resources are registered */\n\tAPI->object = gmt_M_memory (API->GMT, NULL, API->n_objects_alloc, struct GMTAPI_DATA_OBJECT *);\n\n\t/* Set the unique Session parameters */\n\n\tAPI->session_ID = GMTAPI_session_counter++;\t\t/* Guarantees each session ID will be unique and sequential from 0 up */\n\tif (session)\n\t\tAPI->GMT->init.module_name = API->session_tag;\t/* So non-modules can report name of program, */\n\telse\n\t\tAPI->GMT->init.module_name = unknown; /* or unknown */\n\n\tapi_init_sharedlibs (API);\t\t\t\t/* Count how many shared libraries we should know about, and get their names and paths */\n\n\treturn (API);\t/* Pass the structure back out */\n}\n\n#ifdef FORTRAN_API\n/* Fortran binding [THESE MAY CHANGE ONCE WE ACTUALLY TRY TO USE THESE] */\nstruct GMTAPI_CTRL *GMT_Create_Session_ (const char *tag, unsigned int *pad, unsigned int *mode, void *print, int len) {\n\t/* Fortran version: We pass the hidden global GMT_FORTRAN structure */\n\treturn (GMT_Create_Session (tag, *pad, *mode, print));\n}\n#endif\n\n/*! ===>  Destroy a registered GMT Session */\n\nint GMT_Destroy_Session (void *V_API) {\n\t/* GMT_Destroy_Session terminates the information for the specified session and frees all memory.\n\t * Returns false if all is well and true if there were errors. */\n\n\tunsigned int i;\n\tstruct GMTAPI_CTRL *API = api_get_api_ptr (V_API);\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Entering GMT_Destroy_Session\\n\");\n\tgmtapi_garbage_collection (API, GMT_NOTSET);\t/* Free any remaining memory from data registration during the session */\n\tapi_free_sharedlibs (API);\t\t\t/* Close shared libraries and free list */\n\n\t/* Deallocate all remaining objects associated with NULL pointers (e.g., rec-by-rec i/o) */\n\tfor (i = 0; i < API->n_objects; i++) gmtapi_unregister_io (API, (int)API->object[i]->ID, (unsigned int)GMT_NOTSET);\n\tgmt_M_free (API->GMT, API->object);\n\tgmt_end (API->GMT);\t/* Terminate GMT machinery */\n\tgmt_M_str_free (API->session_tag);\n\tgmt_M_str_free (API->tmp_dir);\n\tgmt_M_memset (API, 1U, struct GMTAPI_CTRL);\t/* Wipe it clean first */\n \tgmt_M_str_free (API);\t/* Not gmt_M_free since this item was allocated before GMT was initialized */\n\n\treturn (GMT_OK);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Session_ () {\n\t/* Fortran version: We pass the hidden global GMT_FORTRAN structure*/\n\treturn (GMT_Destroy_Session (GMT_FORTRAN));\n}\n#endif\n\n/*! . */\nGMT_LOCAL int api_encode_id (void *V_API, char *filename, int object_ID) {\n\t/* Creates a filename with the embedded GMTAPI Object ID.  Space must exist.\n\t * Limitation:  object_ID must be <= GMTAPI_MAX_ID */\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tif (!filename) return_error (V_API, GMT_MEMORY_ERROR);\t\t/* Oops, cannot write to that variable */\n\tif (object_ID == GMT_NOTSET) return_error (V_API, GMT_NOT_A_VALID_ID);\t/* ID is not set yet */\n\tif (object_ID > GMTAPI_MAX_ID) return_error (V_API, GMT_ID_TOO_LARGE);\t/* ID is too large to fit in %06d format below */\n\n\tsprintf (filename, \"@GMTAPI@-%06d\", object_ID);\t/* Place the object ID in the special GMT API format */\n\treturn_error (V_API, GMT_OK);\t/* No error encountered */\n}\n\n/* Data registration: The main reason for data registration is the following:\n * Unlike GMT 4, GMT 5 may be used as modules by another calling program.  In\n * that case, the input data file may not be a file but a memory location (i.e.,\n * a data array).  To allow the program to pass such information we needed a\n * way to abstract things so that the modules have no idea of where things are\n * coming from (and were output is going as well).\n * The API session maintains a single linked linear list of data objects; these\n * objects contain information about all the data resources (sources and destinations)\n * that it has been told about.  Because GMT programs (hence the GMT modules) must\n * be able to find data from stdin, command line files, and command options (e.g.,\n * -Gmyfile.txt) we must be flexible in how things are done.\n *\n * Source registration is done in one of several ways:\n *  1. Call GMT_Register_IO directly and specify the source.  The specifics about the\n *     source will be stored in a new data object which is added to the linked list.\n *     This is what top-level programs must do to allow a GMT module to read via a\n *     memory location.\n *  2. Give file names via the option list (this is what happens when stand-alone\n *     GMT programs process the command line argv list).  Depending on the GMT module,\n *     the module will call GMT_Init_IO to scan for such option arguments and then add\n *     each file found as a new data object.\n *  3. Again, depending on the GMT module, if no unused resources are found, the module\n *     will, via GMT_Init_IO, add stdin as an input resource.  This can be in addition\n *     to any other registered sources, but most often it is added because no other\n *     sources were found.\n *\n * The lower-level GMT i/o machinery will handle complications such as 0 (stdin), 1, or\n * many data files so that the modules themselves simply read the next record with\n * GMT_Get_Record until EOF (as if there is only one input source).  Modules that need\n * to store all the data in memory for further processing will call api_get_data instead,\n * which will return a single entity (grid, dataset, cpt, etc).\n *\n * Destination registration is done in the same way, with the exception that for most\n * modules (those processing data tables, at least), only one output destination (e.g., file)\n * can be specified.  However, data sets such as tables with segments can, via mode\n * options, be specified to be written to separate table files or even segment files.\n * The actual writing is done by lower-level functions so that the GMT modules are simply\n * calling api_put_data (all in one go).  For record-by-record output the modules will use\n * GMT_Put_Record.  This keeps data i/o in the modules uniform and simple across GMT.\n */\n\n /*! . */\nint GMT_Register_IO (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int direction, double wesn[], void *resource) {\n\t/* Adds a new data object to the list of registered objects and returns a unique object ID.\n\t * Arguments are as listed for api_Register_Im|Export (); see those for details.\n\t * During the registration we make sure files exist and are readable.\n\t *\n\t * if direction == GMT_IN:\n\t * A program uses this routine to pass information about input data to GMT.\n\t * family:\tSpecifies the data type we are trying to import; select one of 6 families:\n\t *   GMT_IS_PALETTE:\tA GMT_PALETTE structure:\n\t *   GMT_IS_DATASET:\tA GMT_DATASET structure:\n\t *   GMT_IS_TEXTSET:\tA GMT_TEXTSET structure:\n\t *   GMT_IS_GRID:\tA GMT_GRID structure:\n\t *   GMT_IS_IMAGE:\tA GMT_IMAGE structure:\n\t *   GMT_IS_POSTSCRIPT:\t\tA GMT_POSTSCRIPT structure:\n\t * method:\tSpecifies by what method we will import this data set:\n\t *   GMT_IS_FILE:\tA file name is given via input.  The program will read data from this file\n\t *   GMT_IS_STREAM:\tA file pointer to an open file is passed via input. --\"--\n\t *   GMT_IS_FDESC:\tA file descriptor to an open file is passed via input. --\"--\n\t *   GMT_IS_DUPLICATE:\tA pointer to a data set to be copied\n\t *   GMT_IS_REFERENCE:\tA pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]\n\t * The following approaches can be added to the method for all but CPT:\n\t *   GMT_VIA_MATRIX:\tA 2-D user matrix is passed via input as a source for copying.\n\t *\t\t\tThe GMT_MATRIX structure must have parameters filled out.\n\t *   GMT_VIA_VECTOR:\tAn array of user column vectors is passed via input as a source for copying.\n\t *\t\t\tThe GMT_VECTOR structure must have parameters filled out.\n\t * geometry:\tOne of GMT_IS_{TEXT|POINT|LINE|POLY|SURF} (the last for GMT grids)\n\t * input:\tPointer to the source filename, stream, handle, array position, etc.\n\t * wesn:\tGrid subset defined by 4 doubles; otherwise use NULL\n\t * RETURNED:\tUnique ID assigned to this input resource, or GMT_NOTSET (-1) if error.\n\t *\n\t * An error status is returned if problems are encountered via API->error [GMT_OK].\n\t *\n\t * GMT_IS_GRID & GMT_VIA_MATRIX: Since GMT internally uses floats in C arrangement, anything else will be converted to float.\n\t * GMT_IS_DATASET & GMT_VIA_MATRIX: Since GMT internally uses doubles in C arrangement, anything else will be converted to double.\n\t *\n\t * api_Register_Import will allocate and populate a GMTAPI_DATA_OBJECT structure which\n\t * is appended to the data list maintained by the GMTAPI_CTRL API structure.\n\t *\n\t * if direction == GMT_OUT:\n\t * The main program uses this routine to pass information about output data from GMT.\n\t * family:\tSpecifies the data type we are trying to export; select one of:\n\t *   GMT_IS_PALETTE:\tA GMT_PALETTE structure:\n\t *   GMT_IS_DATASET:\tA GMT_DATASET structure:\n\t *   GMT_IS_TEXTSET:\tA GMT_TEXTSET structure:\n\t *   GMT_IS_IMAGE:\tA GMT_IMAGE structure:\n\t *   GMT_IS_GRID:\tA GMT_GRID structure:\n\t *   GMT_IS_POSTSCRIPT:\tA GMT_POSTSCRIPT structure:\n\t * method:\tSpecifies by what method we will export this data set:\n\t *   GMT_IS_FILE:\tA file name is given via output.  The program will write data to this file\n\t *   GMT_IS_STREAM:\tA file pointer to an open file is passed via output. --\"--\n\t *   GMT_IS_FDESC:\tA file descriptor to an open file is passed via output. --\"--\n\t *   GMT_IS_DUPLICATE:\tA pointer to a data set to be copied\n\t *   GMT_IS_REFERENCE:\tA pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]\n\t * geometry:\tOne of GMT_IS_{TEXT|POINT|LINE|POLY|SURF} (the last for GMT grids)\n\t * output:\tPointer to the destination filename, stream, handle, array position, etc.\n\t * wesn:\tGrid subset defined by 4 doubles; otherwise use NULL\n\t * RETURNED:\tUnique ID assigned to this output resource, or GMT_NOTSET (-1) if error.\n\t *\n\t * An error status is returned if problems are encountered via API->error [GMT_OK].\n\t *\n\t * api_Register_Export will allocate and populate a GMTAPI_DATA_OBJECT structure which\n\t * is appended to the data list maintained by the GMTAPI_CTRL API structure.\n\t */\n\tint item, object_ID;\n\tunsigned int module_input, mode = method & GMT_IO_RESET;\t/* In case we wish to reuse this resource */\n\tunsigned int first = 0;\n\tchar message[GMT_LEN256], *file = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_value (V_API, GMT_NOT_A_SESSION, GMT_NOTSET);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_OK;\t/* Reset in case it has some previous error */\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we registering a resource that is a module input? */\n\tfamily -= module_input;\n\tif (api_validate_geometry (API, family, geometry)) return_value (API, GMT_BAD_GEOMETRY, GMT_NOTSET);\n\n\t/* Check if this filename is an embedded API Object ID passed via the filename and of the right kind.  */\n\tif ((object_ID = api_memory_registered (API, family|module_input, direction, resource)) != GMT_NOTSET)\n\t\treturn (object_ID);\t/* OK, return the object ID */\n\n\tif ((object_ID = api_is_registered (API, family, geometry, direction, mode, NULL, resource)) != GMT_NOTSET) {\t/* Registered before */\n\t\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return_value (API, API->error, GMT_NOTSET);\n\t\tif ((family == GMT_IS_GRID || family == GMT_IS_IMAGE) && !full_region (wesn)) {\t/* Update the subset region if given (for grids/images only) */\n\t\t\tS_obj = API->object[item];\t/* Use S as shorthand */\n\t\t\tgmt_M_memcpy (S_obj->wesn, wesn, 4, double);\n\t\t\tS_obj->region = true;\n\t\t}\n\t\treturn (object_ID);\t/* Already registered so we are done */\n\t}\n\tmethod -= mode;\t/* Remove GMT_IO_RESET if it was passed */\n\tGMT = API->GMT;\n\n\tswitch (method) {\t/* Consider CPT, data, text, and grids, accessed via a variety of methods */\n\t\tcase GMT_IS_FILE:\t/* Registration via a single file name */\n\t\t\t/* No, so presumably it is a regular file name */\n\t\t\tfile = strdup (resource);\n\t\t\tif (direction == GMT_IN) {\t/* For input we can check if the file exists and can be read. */\n\t\t\t\tchar *p = NULL;\n\t\t\t\tbool not_url = true;\n\t\t\t\tif ((family == GMT_IS_GRID || family == GMT_IS_IMAGE) && (p = strchr (file, '='))) *p = '\\0';\t/* Chop off any =<stuff> for grids and images so access can work */\n\t\t\t\telse if (family == GMT_IS_IMAGE && (p = strchr (file, '+'))) {\n\t\t\t\t\tchar *c = strchr (file, '.');\t/* The period before an extension */\n\t\t\t\t\t /* PW 1/30/2014: Protect images with band requests, e.g., my_image.jpg+b2 */\n\t\t\t\t\tif (c && c < p && p[1] == 'b' && isdigit (p[2])) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Truncating +b modifier for image filename %s\\n\", file);\n\t\t\t\t\t\t*p = '\\0';\t/* Chop off any +b<band> for images at end of extension so access can work */\n\t\t\t\t\t}\n\t\t\t\t\telse\t/* Make sure p is NULL so we don't restore a character below */\n\t\t\t\t\t\tp = NULL;\n\t\t\t\t}\n\t\t\t\tif (family == GMT_IS_GRID || family == GMT_IS_IMAGE)\t/* Only grid and images can be URLs so far */\n\t\t\t\t\tnot_url = !gmtlib_check_url_name (file);\n\t\t\t\tfirst = gmt_download_file_if_not_found (API->GMT, file);\t/* Deal with downloadable GMT data sets first */\n\t\t\t\tif (gmt_access (GMT, &file[first], F_OK) && not_url) {\t/* For input we can check if the file exists (except if via Web) */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"File %s not found\\n\", &file[first]);\n\t\t\t\t\tgmt_M_str_free (file);\n\t\t\t\t\treturn_value (API, GMT_FILE_NOT_FOUND, GMT_NOTSET);\n\t\t\t\t}\n\t\t\t\tif (gmt_access (GMT, &file[first], R_OK) && not_url) {\t/* Found it but we cannot read. */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Not permitted to read file %s\\n\", &file[first]);\n\t\t\t\t\tgmt_M_str_free (file);\n\t\t\t\t\treturn_value (API, GMT_BAD_PERMISSION, GMT_NOTSET);\n\t\t\t\t}\n\t\t\t\tif (p) p[0] = '=';\t/* Restore the extensions */\n\t\t\t}\n\t\t\telse if (resource == NULL) {\t/* No file given [should this mean stdin/stdout?] */\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\n\t\t\t}\n\t\t\t/* Create a new data object and initialize variables */\n\t\t\tif ((S_obj = api_make_dataobject (API, family, method, geometry, NULL, direction)) == NULL) {\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tif (strlen (resource)) {\n\t\t\t\tif (first)\t/* Must strip off the beginning of the name */\n\t\t\t\t\tS_obj->filename = strdup (&file[first]);\n\t\t\t\telse\n\t\t\t\t\tS_obj->filename = strdup (file);\n\t\t\t}\n\t\t\tgmt_M_str_free (file);\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %s as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], GMT_method[method], S_obj->filename, GMT_direction[direction], GMT_geometry[api_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_STREAM:\t/* Methods that indirectly involve a file */\n\t\tcase GMT_IS_FDESC:\n\t\t\tif (resource == NULL) {\t/* No file given [should this mean stdin/stdout?] */\n\t\t\t\treturn_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\n\t\t\t}\n\t\t\tif ((S_obj = api_make_dataobject (API, family, method, geometry, NULL, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tS_obj->fp = resource;\t/* Pass the stream of fdesc onward */\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %\" PRIxS \" as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], GMT_method[method], (size_t)resource, GMT_direction[direction], GMT_geometry[api_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\n\t\tcase GMT_IS_REFERENCE:\n\t\t\tif (direction == GMT_IN && resource == NULL) {\n\t\t\t\treturn_value (API, GMT_PTR_IS_NULL, GMT_NOTSET);\t/* Input registration of memory takes a resource */\n\t\t\t}\n\t\t\tif ((S_obj = api_make_dataobject (API, family, method, geometry, resource, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %\" PRIxS \" as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], GMT_method[method], (size_t)resource, GMT_direction[direction], GMT_geometry[api_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_COORD:\t/* Internal registration of coordinate arrays so that GMT_Destroy_Data can free them */\n\t\t\tif ((S_obj = api_make_dataobject (API, family, method, geometry, resource, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered double array %\" PRIxS \" as an %s resource [n_objects = %%d]\\n\", (size_t)resource, GMT_direction[direction]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error in GMT_Register_IO (%s): Unrecognized method %d\\n\", GMT_direction[direction], method);\n\t\t\treturn_value (API, GMT_NOT_A_VALID_METHOD, GMT_NOTSET);\n\t\t\tbreak;\n\t}\n\n\tif (!full_region (wesn)) {\t/* Copy the subset region if it was given (for grids) */\n\t\tgmt_M_memcpy (S_obj->wesn, wesn, 4, double);\n\t\tS_obj->region = true;\n\t}\n\n\tS_obj->alloc_level = GMT->hidden.func_level;\t/* Object was allocated at this module nesting level */\n\tif (module_input) S_obj->module_input = true;\n\n\t/* Here S is not NULL and no errors have occurred (yet) */\n\n\tif (direction == GMT_OUT && resource == NULL) S_obj->messenger = true;\t/* Output messenger */\n\tif (method != GMT_IS_COORD) API->registered[direction] = true;\t/* We have at least registered one item */\n\tobject_ID = api_add_data_object (API, S_obj);\n\tGMT_Report (API, GMT_MSG_DEBUG, message, object_ID, API->n_objects);\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMT_Register_IO\");\n#endif\n\treturn_value (API, API->error, object_ID);\n}\n\n#ifdef FORTRAN_API\nint GMT_Register_IO_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *direction, double wesn[], void *input) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Register_IO (GMT_FORTRAN, *family, *method, *geometry, *direction, wesn, input));\n}\n#endif\n\n\n /*! . */\nint GMT_Get_Family (void *V_API, unsigned int direction, struct GMT_OPTION *head) {\n\t/* Scan the registered module input|output resources to learn what their family is.\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * head:\tHead of the list of module options\n\t *\n\t * Returns:\tThe family value (GMT_IS_DATASET|TEXTSET|CPT|GRID|IMAGE|PS) or GMT_NOTSET if not known\n\t */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_OPTION *current = NULL;\n\tint item, object_ID, family = GMT_NOTSET, flag = (direction == GMT_IN) ? GMTAPI_MODULE_INPUT : GMT_NOTSET;\n\tunsigned int n_kinds = 0, k, counter[GMT_N_FAMILIES];\n\tchar desired_option = (direction == GMT_IN) ? GMT_OPT_INFILE : GMT_OPT_OUTFILE;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tgmt_M_memset (counter, GMT_N_FAMILIES, unsigned int);\t/* Initialize counter */\n\tAPI->error = GMT_OK;\t/* Reset in case it has some previous error */\n\n\tfor (current = head; current; current = current->next) {\t\t/* Loop over the list and look for input files */\n\t\tif (current->option != desired_option) continue;\t\t\t\t/* Not a module resource argument */\n\t\tif ((object_ID = api_decode_id (current->arg)) == GMT_NOTSET) continue;\t/* Not a registered resource */\n\t\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, direction, flag)) == GMT_NOTSET) continue;\t/* Not the right attributes */\n\t\tcounter[(API->object[item]->family)]++;\t/* Update counts of this family */\n\t}\n\tfor (k = 0; k < GMT_N_FAMILIES; k++) {\t/* Determine which family we found, if any */\n\t\tif (counter[k]) n_kinds++, family = k;\n\t}\n\tif (n_kinds != 1) {\t/* Could not determine family */\n\t\tfamily = GMT_NOTSET;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Get_Family: Could not determine family\\n\");\n\t}\n\telse\t/* Found a unique family */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Get_Family: Determined family to be %s\\n\", GMT_family[family]);\n\treturn (family);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Family_ (unsigned int *direction, struct GMT_OPTION *head) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Family (GMT_FORTRAN, *direction, head));\n}\n#endif\n\n /*! . */\nint GMT_Init_IO (void *V_API, unsigned int family, unsigned int geometry, unsigned int direction, unsigned int mode, unsigned int n_args, void *args) {\n\t/* Registers program option file arguments as sources/destinations for the current module.\n\t * All modules planning to use std* and/or command-line file args must call GMT_Init_IO to register these resources.\n\t * family:\tThe kind of data (GMT_IS_DATASET|TEXTSET|CPT|GRID|IMAGE|PS)\n\t * geometry:\tEither GMT_IS_NONE|POINT|LINE|POLYGON|SURFACE\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * mode:\tBitflags composed of 1 = add command line (option) files, 2 = add std* if no other input/output,\n\t *\t\t4 = add std* regardless.  mode must be > 0.\n\t * n_args:\tEither 0 if we pass linked option structs or argc if we pass argv[]\n\t * args:\tEither linked list of program option arguments (n_args == 0) or char *argv[].\n\t *\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\tint object_ID;\t/* ID of first object [only for debug purposes - not used in this function; ignore -Wunused-but-set-variable warning */\n\tstruct GMT_OPTION *head = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_OK;\t/* Reset in case it has some previous error */\n\tif (api_validate_geometry (API, family, geometry)) return_error (API, GMT_BAD_GEOMETRY);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!((mode & GMT_ADD_FILES_IF_NONE) || (mode & GMT_ADD_FILES_ALWAYS) || (mode & GMT_ADD_STDIO_IF_NONE) || (mode & GMT_ADD_STDIO_ALWAYS) || (mode & GMT_ADD_EXISTING))) return_error (API, GMT_NOT_A_VALID_MODE);\n\n\tif (n_args == 0) /* Passed the head of linked option structures */\n\t\thead = args;\n\telse\t\t/* Passed argc, argv, likely from Fortran */\n\t\thead = GMT_Create_Options (API, n_args, args);\n\tgmtlib_io_banner (API->GMT, direction);\t/* Message for binary i/o */\n\tif (direction == GMT_IN)\n\t\tobject_ID = api_init_import (API, family, geometry, mode, head);\n\telse\n\t\tobject_ID = api_init_export (API, family, geometry, mode, head);\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Init_IO: Returned first %s object ID = %d\\n\", GMT_direction[direction], object_ID);\n\treturn (API->error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Init_IO_ (unsigned int *family, unsigned int *geometry, unsigned int *direction, unsigned int *mode, unsigned int *n_args, void *args) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Init_IO (GMT_FORTRAN, *family, *geometry, *direction, *mode, *n_args, args));\n}\n#endif\n\n /*! . */\nint GMT_Begin_IO (void *V_API, unsigned int family, unsigned int direction, unsigned int header) {\n\t/* Initializes the rec-by-rec i/o mechanism for either input or output (given by direction).\n\t * GMT_Begin_IO must be called before any data i/o is allowed.\n\t * family:\tThe family of data must be GMT_IS_DATASET or TEXTSET.\n\t * direction:\tEither GMT_IN or GMT_OUT.\n\t * header:\tEither GMT_HEADER_ON|OFF, controls the writing of the table start header info block\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\tint error, item;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (V_API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!multiple_files_ok (family)) return_error (V_API, GMT_NOT_A_VALID_IO_ACCESS);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_OK;\t/* Reset in case it has some previous error */\n\tif (!API->registered[direction]) GMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: Warning: No %s resources registered\\n\", GMT_direction[direction]);\n\n\tGMT = API->GMT;\n\t/* Must initialize record-by-record machinery for dataset or textset */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: Initialize record-by-record access for %s\\n\", GMT_direction[direction]);\n\tAPI->current_item[direction] = -1;\t/* api_next_data_object (below) will wind it to the first item >= 0 */\n\tif ((error = api_next_data_object (API, family, direction))) return_error (API, GMT_NO_RESOURCES);\t/* Something went bad */\n\titem = API->current_item[direction];\t/* Next item */\n\tAPI->io_mode[direction] = GMTAPI_BY_REC;\n\tAPI->io_enabled[direction] = true;\t/* OK to access resources */\n\tGMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);\n\tGMT->current.io.ogr = GMT_OGR_UNKNOWN;\n\tGMT->current.io.segment_header[0] = GMT->current.io.record[0] = 0;\n\tif (direction == GMT_OUT && API->object[item]->messenger && API->object[item]->data) {\t/* Need to destroy the dummy container before passing data out */\n\t\tif ((error = api_destroy_data_ptr (API, API->object[item]->actual_family, API->object[item]->data)))\t/* Do the dirty deed */\n\t\t\treturn_error (API,error);\n\t\tAPI->object[item]->resource = API->object[item]->data = NULL;\t/* Since we now have nothing */\n\t\tAPI->object[item]->messenger = false;\t/* OK, now clean for output */\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: %s resource access is now enabled [record-by-record]\\n\", GMT_direction[direction]);\n\tif (direction == GMT_OUT && header == GMT_HEADER_ON && !GMT->common.b.active[GMT_OUT]) GMT_Put_Record (API, GMT_WRITE_TABLE_START, NULL);\t/* Write standard ASCII header block */\n\n\treturn_error (V_API, GMT_OK);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_Begin_IO_ (unsigned int *family, unsigned int *direction, unsigned int *header) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Begin_IO (GMT_FORTRAN, *family, *direction, *header));\n}\n#endif\n\nGMT_LOCAL int api_end_io_dataset (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_DATASET that was written to\n\t * record-by-record via GMT_Put_Record.  It needs to set number of records and set\n\t * the min/max per segments and table */\n\tint check, object_ID;\n\tint64_t *count = API->GMT->current.io.curr_pos[GMT_OUT];\t\t/* Short-hand for counts of tbl, seg, rows */\n\tstruct GMT_DATASET *D = S->resource;\n\tstruct GMT_DATATABLE *T = NULL;\n\tif (D == NULL || D->table == NULL || D->table[0] == NULL) return GMT_OK;\t/* Nothing to work on */\n\n\tT = D->table[0];\t/* Shorthand to the only table */\n\tif (count[GMT_SEG] >= 0) {\t/* Finalize segment allocations */\n\t\tif (!T->segment[count[GMT_SEG]]) T->segment[count[GMT_SEG]] = gmt_M_memory (API->GMT, NULL, 1, struct GMT_DATASEGMENT);\n\t\tgmtlib_assign_segment (API->GMT, T->segment[count[GMT_SEG]], count[GMT_ROW], T->n_columns);\t/* Allocate and place arrays into segment */\n\t\tif (T->segment[count[GMT_SEG]]->header == NULL && API->GMT->current.io.record[0]) T->segment[count[GMT_SEG]]->header = strdup (API->GMT->current.io.record);\n\t\tcount[GMT_SEG]++;\t/* Set final number of segments */\n\t\tT->n_segments++;\n\t}\n\t/* Realloc final number of segments */\n\tif (count[GMT_SEG] < (int64_t)T->n_alloc) T->segment = gmt_M_memory (API->GMT, T->segment, T->n_segments, struct GMT_DATASEGMENT *);\n\tD->n_segments = T->n_segments;\n\tgmtlib_set_dataset_minmax (API->GMT, D);\t/* Update the min/max values for this dataset */\n\tgmtlib_change_dataset (API->GMT, D);\t\t/* Deal with any -o settings */\n\tD->n_records = T->n_records = count[GMT_ROW];\n\tD->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\t/* Register this resource */\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_REFERENCE, D->geometry, GMT_OUT, NULL, D)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t\t/* Failure to register */\n\tif ((check = gmtapi_validate_id (API, GMT_IS_DATASET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t\t/* Failure to validate */\n\t*item = (unsigned int) check;\n\treturn (GMT_OK);\n}\n\nGMT_LOCAL int api_end_io_textset (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_TEXTSET that was written to\n\t * record-by-record via GMT_Put_Record.  It needs to set number of records and set\n\t * the min/max per segments and table */\n\tint check, object_ID;\n\tint64_t *count = API->GMT->current.io.curr_pos[GMT_OUT];\n\tstruct GMT_TEXTSET *D = S->resource;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tif (D == NULL || D->table == NULL || D->table[0] == NULL) return GMT_OK;\t/* Nothing to work on */\n\n\tT = D->table[0];\t/* Shorthand to the only table */\n\tif (count[GMT_SEG] >= 0) {\t/* Last segment */\n\t\tT->segment[count[GMT_SEG]]->data = gmt_M_memory (API->GMT, T->segment[count[GMT_SEG]]->data, count[GMT_ROW], char *);\n\t\tT->segment[count[GMT_SEG]]->n_rows = count[GMT_ROW];\n\t\tcount[GMT_SEG]++;\t/* Final number of segments */\n\t\tT->n_segments++;\n\t}\n\t/* Realloc final number of segments */\n\tif (count[GMT_SEG] < (int64_t)T->n_alloc) T->segment = gmt_M_memory (API->GMT, T->segment, T->n_segments, struct GMT_TEXTSEGMENT *);\n\tD->n_segments = T->n_segments;\n\tD->n_records = T->n_records = count[GMT_ROW];\n\tD->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n#ifdef GMT_BACKWARDS_API\n\t{\t/* Set record pointers to data pointers for backwardness */\n\t\tuint64_t seg;\n\t\tfor (seg = 0; seg < T->n_segments; seg++) T->segment[seg]->record = T->segment[seg]->data;\n\t}\n#endif\n\n\t/* Register this resource */\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_TEXTSET, GMT_IS_REFERENCE, GMT_IS_NONE, GMT_OUT, NULL, D)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to register */\n\tif ((check = gmtapi_validate_id (API, GMT_IS_TEXTSET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to validate */\n\t*item = (unsigned int) check;\n\treturn (GMT_OK);\n}\n\nGMT_LOCAL int api_end_io_matrix (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_MATRIX that was written to\n\t * record-by-record vai GMT_Put_Record.  It needs to set number of rows and possibly\n\t * add leading NaN-record(s) if there were segment headers at the beginning of file. */\n\tint error = 0, check, object_ID;\n\tstruct GMT_MATRIX *M = S->resource;\n\tif (S->alloc_mode != GMT_ALLOC_EXTERNALLY && S->n_alloc != S->rec) {\t/* Must finalize matrix memory */\n\t\tsize_t size = S->n_alloc = S->rec;\n\t\tsize *= M->n_columns;\n\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M->data), M->type, size)) != GMT_OK)\n\t\t\treturn_error (API, error);\n\t}\n\tM->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\tif (S->delay) {\t/* Must place delayed NaN record(s) signifying segment header(s) */\n\t\tGMT_putfunction api_put_val = api_select_put_function (API, M->type);\n\t\tp_func_uint64_t GMT_2D_to_index = NULL;\n\t\tuint64_t col, ij;\n\t\tGMT_2D_to_index = api_get_2d_to_index (API, GMT_IS_ROW_FORMAT, GMT_GRID_IS_REAL);\t/* Can only do row-format until end of this function */\n\t\twhile (S->delay) {\t/* Place delayed NaN-rows(s) up front */\n\t\t\tS->delay--;\n\t\t\tM->n_rows++;\t/* Since could not be incremented before M was created */\n\t\t\tfor (col = 0; col < M->n_columns; col++) {\t/* Place the output items */\n\t\t\t\tij = GMT_2D_to_index (S->delay, col, M->dim);\n\t\t\t\tapi_put_val (&(M->data), ij, API->GMT->session.d_NaN);\n\t\t\t}\n\t\t}\n\t}\n\tif (M->shape == GMT_IS_COL_FORMAT) {\t/* Oh no, must do a transpose in place */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_end_io_matrix: Must transpose union matrix to GMT_IS_COL_FORMAT arrangement\\n\");\n\t\tgmtlib_union_transpose (API->GMT, &(M->data), M->n_rows, M->n_columns, M->type);\n\t\tM->dim = M->n_rows;\t/* Since now it is in FORTRAN column format */\n\t}\n\t/* Register this resource */\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_MATRIX, GMT_IS_REFERENCE, GMT_IS_SURFACE, GMT_OUT, NULL, M)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to register */\n\tif ((check = gmtapi_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to validate */\n\t*item = (unsigned int) check;\n\treturn (GMT_OK);\n}\n\nGMT_LOCAL int api_end_io_vector (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_VECTOR that was written to\n\t * record-by-record vai GMT_Put_Record.  It needs to set number of rows and possibly\n\t * add leading NaN-record(s) if there were segment headers at the beginning of file. */\n\tint error = 0, check, object_ID;\n\tstruct GMT_VECTOR *V = S->resource;\n\tif (S->alloc_mode != GMT_ALLOC_EXTERNALLY && S->n_alloc != S->rec) {\t/* Must finalize memory */\n\t\tS->n_alloc = S->rec;\n\t\tif ((error = api_alloc_vectors (API->GMT, V, S->n_alloc)) != GMT_OK)\n\t\t\treturn_error (API, error);\n\t}\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_VECTOR, GMT_IS_REFERENCE, S->geometry, GMT_OUT, NULL, V)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to register */\n\tif ((check = gmtapi_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to validate */\n\tV->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\tif (S->delay) {\t/* Must place delayed NaN record(s) signifying segment header(s) */\n\t\tGMT_putfunction api_put_val = api_select_put_function (API, V->type[0]);\t/* Since vectors are probably all the same type */\n\t\tuint64_t col;\n\t\twhile (S->delay) {\t/* Place delayed NaN-record(s) as leading rows */\n\t\t\tS->delay--;\n\t\t\tV->n_rows++;\t/* Since could not be incremented before V was created */\n\t\t\tfor (col = 0; col < V->n_columns; col++) {\n\t\t\t\tif (col && V->type[col] != V->type[col-1]) api_put_val = api_select_put_function (API, V->type[col]);\t/* Update put function */\n\t\t\t\tapi_put_val (&(V->data[col]), S->delay, API->GMT->session.d_NaN);\n\t\t\t}\n\t\t}\n\t}\n\t*item = (unsigned int) check;\n\treturn (GMT_OK);\n}\n\n/*! . */\nint GMT_End_IO (void *V_API, unsigned int direction, unsigned int mode) {\n\t/* Terminates the i/o mechanism for either input or output (given by direction).\n\t * GMT_End_IO must be called after all data i/o is completed.\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * mode:\tEither GMT_IO_DONE (nothing), GMT_IO_RESET (let all resources be accessible again), or GMT_IO_UNREG (unreg all accessed resources).\n\t * NOTE: \tMode not yet implemented until we see a use.\n\t * Returns:\tfalse if successful, true if error.\n\t * For memory output we finalized the container, register it, sets the alloc_level to the calling entity\n\t * and pass the resource upwards.\n\t */\n\tunsigned int item = 0;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (V_API, GMT_NOT_A_VALID_DIRECTION);\n\tif (mode > GMT_IO_UNREG) return_error (V_API, GMT_NOT_A_VALID_IO_MODE);\n\n\tAPI = api_get_api_ptr (V_API);\n\tgmtlib_free_ogr (API->GMT, &(API->GMT->current.io.OGR), 0);\t/* Free segment-related array */\n\tif (direction == GMT_OUT && API->io_mode[GMT_OUT] == GMTAPI_BY_REC) {\n\t\t/* Finalize record-by-record output object dimensions */\n\t\tS_obj = API->object[API->current_item[GMT_OUT]];\t/* Shorthand for the data object we are working on */\n\t\tif (S_obj) {\n\t\t\tS_obj->status = GMT_IS_USED;\t/* Done \"writing\" to this destination */\n\t\t\tif ((S_obj->method == GMT_IS_DUPLICATE || S_obj->method == GMT_IS_REFERENCE)) {\t/* Used GMT_Put_Record: Must now realloc dimensions given known sizes */\n\t\t\t\tint error = GMT_OK;\t/* If all goes well */\n\t\t\t\tif (S_obj->actual_family == GMT_IS_DATASET)\t\t\t/* Dataset type */\n\t\t\t\t\terror = api_end_io_dataset (API, S_obj, &item);\n\t\t\t\telse if (S_obj->actual_family == GMT_IS_MATRIX)\t\t/* Matrix type */\n\t\t\t\t\terror = api_end_io_matrix (API, S_obj, &item);\n\t\t\t\telse if (S_obj->actual_family == GMT_IS_VECTOR)\t\t/* Vector type */\n\t\t\t\t\terror = api_end_io_vector (API, S_obj, &item);\n\t\t\t\telse if (S_obj->actual_family == GMT_IS_TEXTSET)\t/* Textset type */\n\t\t\t\t\terror = api_end_io_textset (API, S_obj, &item);\n\t\t\t\telse\t/* Should not get here... */\n\t\t\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\tif (error) return_error (API, error);\t/* Failure to finalize */\n\t\t\t\tAPI->object[item]->no_longer_owner = true;\t/* Since we passed it via S_obj */\n\t\t\t\tS_obj->data = NULL;\t/* Since S_obj->resources points to it too, and needed for api_retrieve_data to work */\n\t\t\t}\n\t\t\tif (S_obj->close_file) {\t/* Close any file that we opened earlier */\n\t\t\t\tgmt_fclose (API->GMT, S_obj->fp);\n\t\t\t\tS_obj->close_file = false;\n\t\t\t}\n\t\t}\n\t}\n\tAPI->io_enabled[direction] = false;\t/* No longer OK to access resources or destinations */\n\tAPI->current_rec[direction] = 0;\t/* Reset count for next time */\n\tfor (item = 0; item < API->n_objects; item++) {\t/* Deselect the used resources */\n\t\tif (!API->object[item]) continue;\t/* Skip empty object */\n\t\tif (API->object[item]->direction != (enum GMT_enum_std)direction) continue;\t/* Not the required direction */\n\t\tif (API->object[item]->selected) API->object[item]->selected = false;\t/* No longer a selected resource */\n\t}\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_End_IO: %s resource access is now disabled\\n\", GMT_direction[direction]);\n\n\treturn_error (V_API, GMT_OK);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_End_IO_ (unsigned int *direction, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_End_IO (GMT_FORTRAN, *direction, *mode));\n}\n#endif\n\n/*! . */\nint GMT_Status_IO (void *V_API, unsigned int mode) {\n\t/* Returns nonzero (true) or 0 (false) if the current io status\n\t * associated with record-by-record reading matches the\n\t * specified mode.  The modes are:\n\t * GMT_IO_TABLE_HEADER\t\t: Is current record a table header?\n\t * GMT_IO_SEGMENT_HEADER\t\t: Is current record a segment header?\n\t * GMT_IO_ANY_HEADER\t\t: Is current record a header or segment header?\n\t * GMT_IO_MISMATCH\t\t: Did current record result in a parsing error?\n\t * GMT_IO_EOF\t\t\t: Did we reach end-of-file for entire data set(EOF)?\n\t * GMT_IO_NAN\t\t\t: Did we encounter any NaNs in current record?\n\t * GMT_IO_GAP\t\t\t: Did current record indicate a data gap?\n\t * GMT_IO_NEW_SEGMENT\t\t: Is current record the start of a new segment (gap or header)\n\t * GMT_IO_LINE_BREAK\t\t: Any sort of new line break (gap, headers, nan)\n\t * GMT_IO_FILE_BREAK\t\t: Did we reach end-of-file for a single table (EOF)?\n\t * GMT_IO_DATA\t\t\t: Is current record a data record (including nans)?\n\t */\n\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_IO *IO = NULL;\n\n\tif (V_API == NULL) return_value (V_API, GMT_NOT_A_SESSION, GMT_NOTSET);\n\n\tAPI = api_get_api_ptr (V_API);\n\tIO = &(API->GMT->current.io);\t/* Pointer to the GMT IO structure */\n\tif (mode == GMT_IO_DATA_RECORD) return (IO->status == 0 || IO->status == GMT_IO_NAN);\n\treturn (IO->status & mode);\n}\n\n#ifdef FORTRAN_API\nint GMT_Status_IO_ (unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Status_IO (GMT_FORTRAN, *mode));\n}\n#endif\n\n/*! . */\nGMT_LOCAL int api_get_id (void *V_API, unsigned int family, unsigned int direction, void *resource) {\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t\t\t\t/* Empty object */\n\t\tif (!API->object[i]->resource) continue;\t\t/* Empty resource */\n\t\tif (API->object[i]->family != (enum GMT_enum_family)family) {\t\t/* Not the required data type, but check for exceptions */\n\t\t\tif (family == GMT_IS_DATASET && (API->object[i]->family == GMT_IS_MATRIX || API->object[i]->family == GMT_IS_VECTOR))\n\t\t\t\tAPI->object[i]->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (API->object[i]->direction != (enum GMT_enum_std)direction) continue;\t/* Not the required direction */\n\t\tif (API->object[i]->resource == resource) item = i;\t/* Pick the requested object regardless of direction */\n\t}\n\tif (item == GMT_NOTSET) { API->error = GMT_NOT_A_VALID_ID; return (GMT_NOTSET); }\t/* No such resource found */\n\treturn (API->object[item]->ID);\n}\n\n /*! . */\nint GMT_Open_VirtualFile (void *V_API, unsigned int family, unsigned int geometry, unsigned int direction, void *data, char *name) {\n\t/* Associate a virtual file with a data object for either reading or writing.\n\t * Family and geometry specifies the nature of the data to be read or written.\n\t * Direction is either GMT_IN or GMT_OUT and determines if we read or write.\n\t * Reading: data must point to a data container we wish to read from via a module.\n\t * Writing: data is either an existing output data container that the user created\n\t *  beforehand or it is NULL and we create an expanding output resource.\n\t * name is the name given to the virtual file and is returned. */\n\tint object_ID = GMT_NOTSET, item_s = 0;\n\tunsigned int item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return GMT_NOT_A_VALID_DIRECTION;\n\tif (direction == GMT_IN && data == NULL) return GMT_PTR_IS_NULL;\n\tif (name == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\n\tif (data) {\t/* Data container provided, see if registered */\n\t\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\t\tif (!API->object[item]) continue;\t/* Skip freed objects */\n\t\t\tif (API->object[item]->data == data) object_ID = API->object[item]->ID;\t/* Found a matching data pointer */\n\t\t}\n\t\tif (object_ID != GMT_NOTSET && (item_s = api_get_item (API, family, data)) == GMT_NOTSET) {\t/* Not found in list */\n\t\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find that item in the array despite finding its ID? */\n\t\t}\n\t\tS_obj = API->object[item_s];\t/* Short-hand for later */\n\t}\n\tif (direction == GMT_IN) {\t/* Set things up for reading */\n\t\t/* See if this one is known to us already */\n\t\tif (object_ID == GMT_NOTSET) {\t/* Register data as a new object for reading [GMT_IN] and reset its status to unread */\n\t\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_REFERENCE|GMT_IO_RESET, geometry, GMT_IN, NULL, data)) == GMT_NOTSET)\n\t\t\t\treturn (API->error);\n\t\t}\n\t\telse {\t/* Found the object earlier; recycle the address and ensure it is a readable object */\n\t\t\tS_obj->status = 0;\t\t\t\t\t/* Open for business */\n\t\t\tS_obj->resource = S_obj->data;\t\t/* Switch from consumer to provider */\n\t\t\tS_obj->data = NULL;\t\t\t\t\t/* No longer consumer */\n\t\t\tS_obj->method = GMT_IS_REFERENCE;\t/* Now a memory resource */\n\t\t\tS_obj->direction = GMT_IN;\t\t\t/* Make sure it now is flagged for reading */\n\t\t}\n\t}\n\telse {\t/* Set things up for writing */\n\t\tif (data) {\t/* Was provided an object to use */\n\t\t\tif (object_ID == GMT_NOTSET) {\t/* Register a new object for writing [GMT_OUT] and reset its status to unread */\n\t\t\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_REFERENCE|GMT_IO_RESET, geometry, GMT_OUT, NULL, data)) == GMT_NOTSET)\n\t\t\t\t\treturn (API->error);\n\t\t\t}\n\t\t\telse {\t/* Here we have the item and can recycle the address */\n\t\t\t\tS_obj->status = 0;\t\t\t/* Open for business */\n\t\t\t\tif (S_obj->data == NULL) {\t/* Switch from provider to consumer, if needed */\n\t\t\t\t\tS_obj->data = S_obj->resource;\n\t\t\t\t\tS_obj->resource = NULL;\t\t/* No longer consumer */\n\t\t\t\t}\n\t\t\t\tS_obj->method = GMT_IS_REFERENCE;\t/* Now a memory resource */\n\t\t\t\tS_obj->direction = GMT_OUT;\t\t\t/* Make sure it now is flagged for writing */\n\t\t\t}\n\t\t}\n\t\telse {\t/* New expanding output resource */\n\t\t\tvoid *object = NULL;\n\t\t\t/* GMT_Create_Data may return error code if there are issues with the values of family, or geometry */\n\t\t\t/* Creating an empty object with mode == GMT_IS_OUTPUT means it is intended to hold output [GMT_OUT] from a module */\n\t\t\tif ((object = GMT_Create_Data (API, family, geometry, GMT_IS_OUTPUT, NULL, NULL, NULL, 0, 0, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\t/* Obtain the object's ID */\n\t\t\tif ((object_ID = api_get_id (API, family, GMT_OUT, object)) == GMT_NOTSET)\n\t\t\t\treturn (API->error);\n\t\t}\n\t}\n\t/* Obtain the unique VirtualFile name */\n\tif (api_encode_id (API, name, object_ID) != GMT_NOERROR)\n\t\treturn (API->error);\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Open_VirtualFile_ (unsigned int *family, unsigned int *geometry, unsigned int *direction, void *data, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Open_VirtualFile (GMT_FORTRAN, *family, *geometry, *direction, data, string));\n}\n#endif\n\nint GMT_Close_VirtualFile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, close it */\n\tint object_ID, item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = api_decode_id (string)) == GMT_NOTSET)\n\t\treturn_error (V_API, GMT_OBJECT_NOT_FOUND);\n\tAPI = api_get_api_ptr (V_API);\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tS_obj = API->object[item];\t/* Short-hand */\n\tif (S_obj->direction == GMT_IN) {\n\t\tS_obj->data = S_obj->resource;\t/* Switch from provider to consumer */\n\t\tS_obj->resource = NULL;\t\t\t/* No longer provider */\n\t}\n\tif (S_obj->family != S_obj->actual_family)\t/* Reset the un-masquerading that GMT_Open_VirtualFile did */\n\t\tS_obj->family = S_obj->actual_family;\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Close_VirtualFile_ (unsigned int *family, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Close_VirtualFile (GMT_FORTRAN, string));\n}\n#endif\n\nvoid *GMT_Read_VirtualFile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, retrieve the resulting object */\n\tint object_ID;\n\tvoid *object = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_null (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = api_decode_id (string)) == GMT_NOTSET)\n\t\treturn_null (V_API, GMT_OBJECT_NOT_FOUND);\n\tif ((object = api_retrieve_data (V_API, object_ID)) == NULL)\n\t\treturn_null (V_API, GMT_OBJECT_NOT_FOUND);\n\treturn object;\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Read_VirtualFile_ (char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_VirtualFile (GMT_FORTRAN, string));\n}\n#endif\n\n /*! . */\nint GMT_Init_VirtualFile (void *V_API, unsigned int mode, const char *name) {\n\t/* Reset a virtual file back to its original configuration so that it can be\n\t * repurposed for reading or writing again.\n\t */\n\tint object_ID = GMT_NOTSET, item;\n\tstruct GMTAPI_DATA_OBJECT *S = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tgmt_M_unused (mode);\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (name == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tif ((object_ID = api_decode_id (name)) == GMT_NOTSET) return (GMT_OBJECT_NOT_FOUND);\t/* Not a registered resource */\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tS = API->object[item];\t/* Short-hand pointer */\n\tS->rec = 0;\t/* Start at first record */\n\tS->delay = 0;\t/* No Nan-fuckery yet */\n\tS->status = GMT_IS_UNUSED;\n\tS->selected = true;\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Init_VirtualFile_ (unsigned int mode, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Init_VirtualFile (GMT_FORTRAN, mode, string));\n}\n#endif\n\n/*! . */\nvoid *GMT_Read_Data (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], const char *infile, void *data) {\n\t/* Function to read data files directly into program memory as a set (not record-by-record).\n\t * We can combine the <register resource - import resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * data is pointer to an existing grid container when we read a grid in two steps, otherwise use NULL.\n\t * Case 1: infile != NULL: Register input as the source and import data.\n\t * Case 2: infile == NULL: Register stdin as the source and import data.\n\t * Case 3: geometry == 0: Loop over all previously registered AND unread sources and combine as virtual dataset [DATASET|TEXTSET only]\n\t * Case 4: family is GRID|IMAGE and method = GMT_DATA_ONLY: Just find already registered resource\n\t * Return: Pointer to data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tint in_ID = GMT_NOTSET, item = GMT_NOTSET;\n\tunsigned int module_input = 0;\n\tbool just_get_data, reset;\n\tvoid *new_obj = NULL;\n\tchar *input = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (infile) input = strdup (infile);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tjust_get_data = (gmt_M_file_is_memory (input));\t/* A regular GMT resource passed via memory */\n\treset = (mode & GMT_IO_RESET);\t/* We want to reset resource as unread after reading it */\n\tif (reset) mode -= GMT_IO_RESET;\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we reading a resource that should be considered a module input? */\n\tfamily -= module_input;\n\tAPI->module_input = (module_input) ? true : false;\n\tif (!gmt_M_file_is_cache(infile) && !gmt_M_file_is_url(infile) && infile && strpbrk (infile, \"*?[]\") && !api_file_with_netcdf_directive (API, infile)) {\t/* Gave a wildcard filename */\n\t\tuint64_t n_files;\n\t\tunsigned int k;\n\t\tchar **filelist = NULL;\n\t\tif (!multiple_files_ok (family)) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Data: Wildcards only allowed for DATASET and TEXTSET. \"\n\t\t\t                                 \"Use GMT_Read_Group to read groups of other data types\\n\");\n\t\t\tfree (input);\n\t\t\treturn_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t}\n\t\tif ((n_files = gmtlib_glob_list (API->GMT, infile, &filelist)) == 0) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Data: Expansion of \\\"%s\\\" gave no results\\n\", infile);\n\t\t\tfree (input);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t}\n\t\tAPI->shelf = family;\t/* Save which one it is so we know in api_get_data */\n\t\tAPI->module_input = true;\t/* Since we are passing NULL as file name we must loop over registered resources */\n\t\tfor (k = 0; k < n_files; k++) {\n\t\t\tif ((in_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_FILE, geometry, GMT_IN, NULL, filelist[k])) == GMT_NOTSET) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Data: Could not register file for input: \\n\", filelist[k]);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t\tif ((item = gmtapi_validate_id (API, family, in_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, API->error);\t/* Some internal error... */\n\t\t\tAPI->object[item]->selected = true;\n\t\t}\n\t\tgmtlib_free_list (API->GMT, filelist, n_files);\t/* Free the file list */\n\t\tin_ID = GMT_NOTSET;\n\t}\n\telse if ((family == GMT_IS_GRID || family == GMT_IS_IMAGE) && (mode & GMT_DATA_ONLY)) {\t/* Case 4: Already registered when we obtained header, find object ID */\n\t\tif ((in_ID = api_is_registered (API, family, geometry, GMT_IN, mode, input, data)) == GMT_NOTSET) {\n\t\t\tif (input) gmt_M_str_free (input);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find it */\n\t\t}\n\t\tif (!full_region (wesn)) {\t/* Must update subset selection */\n\t\t\tint item;\n\t\t\tif ((item = gmtapi_validate_id (API, family, in_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\t\tif (input) gmt_M_str_free (input);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t\tgmt_M_memcpy (API->object[item]->wesn, wesn, 4, double);\n\t\t}\n\t}\n\telse if (input) {\t/* Case 1: Load from a single input, given source. Register it first. */\n\t\tunsigned int first = 0;\n\t\tfirst = gmt_download_file_if_not_found (API->GMT, input);\t/* Deal with downloadable GMT data sets first */\n\t\t/* Must handle special case when a list of colors are given instead of a CPT name.  We make a temp CPT from the colors */\n\t\tif (family == GMT_IS_PALETTE && !just_get_data) { /* CPTs must be handled differently since the master files live in share/cpt and filename is missing .cpt */\n\t\t\tint c_err = 0;\n\t\t\tchar CPT_file[GMT_LEN256] = {\"\"}, *file = strdup (&input[first]);\n\t\t\tif ((c_err = api_colors2cpt (API, &file, &mode)) < 0) { /* Maybe converted colors to new CPT */\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\t/* Failed in the conversion */\n\t\t\t}\n\t\t\telse if (c_err == 0) {\t/* Regular cpt (master or local), append .cpt and set path */\n\t\t\t\tsize_t len = strlen (file);\n\t\t\t\tchar *ext = (len > 4 && strstr (file, \".cpt\")) ? \"\" : \".cpt\";\n\t\t\t\tif (!(strstr (file, \"+U\") || strstr (file, \"+u\")))\t/* Only append extension and supply path if not containing +u|U */\n\t\t\t\t\tgmt_getsharepath (API->GMT, \"cpt\", file, ext, CPT_file, R_OK);\n\t\t\t\telse\t/* Use name as is */\n\t\t\t\t\tstrncpy (CPT_file, file, GMT_LEN256-1);\n\t\t\t}\n\t\t\telse\t/* Got color list, now a temp CPT instead */\n\t\t\t\tstrncpy (CPT_file, file, GMT_LEN256-1);\n\t\t\tgmt_M_str_free (file);\t/* Free temp CPT name */\n\t\t\tif ((in_ID = GMT_Register_IO (API, family, method, geometry, GMT_IN, wesn, CPT_file)) == GMT_NOTSET) {\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t}\n\t\telse if ((in_ID = GMT_Register_IO (API, family|module_input, method, geometry, GMT_IN, wesn, &input[first])) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\n\t}\n\telse if (input == NULL && geometry) {\t/* Case 2: Load from stdin.  Register stdin first */\n\t\tif ((in_ID = GMT_Register_IO (API, family|module_input, GMT_IS_STREAM, geometry, GMT_IN, wesn, API->GMT->session.std[GMT_IN])) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\t/* Failure to register std??? */\n\t}\n\telse {\t/* Case 3: input == NULL && geometry == 0, so use all previously registered sources (unless already used). */\n\t\tif (!multiple_files_ok (family))\n\t\t\treturn_null (API, GMT_ONLY_ONE_ALLOWED);\t/* Virtual source only applies to data and text tables */\n\t\tAPI->shelf = family;\t/* Save which one it is so we know in api_get_data */\n\t\tAPI->module_input = true;\t/* Since we are passing NULL as file name we must loop over registered resources */\n\t}\n\tif (just_get_data) {\n\t\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, in_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (input);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\t/* Try to catch a matrix or vector masquerading as dataset by examining the object's actual family  */\n\t\tif (family == (unsigned int)API->object[item]->actual_family) {\t/* True to its word, otherwise we fall through and read the data */\n#ifdef DEBUG\n\t\t\tapi_set_object (API, API->object[item]);\n#endif\n\t\t\tif (reset) API->object[item]->status = 0;\t/* Reset  to unread */\n\t\t\treturn (api_pass_object (API, API->object[item], family, wesn));\n\t\t}\n\t}\n\n\t/* OK, try to do the importing */\n\tif (in_ID != GMT_NOTSET) {\t/* Make sure we select the item we just registered */\n\t\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, in_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (input);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tAPI->object[item]->selected = true;\t/* Make sure the item we want is now selected */\n\t}\n\tif ((new_obj = api_get_data (API, in_ID, mode, data)) == NULL)\n\t\treturn_null (API, API->error);\n\tif (reset) API->object[item]->status = 0;\t/* Reset  to unread */\n\tgmt_M_str_free (input);\t/* Done with this variable) */\n\tAPI->module_input = false;\t/* Reset to normal */\n\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMT_Read_Data\");\n#endif\n\n\treturn (new_obj);\t\t/* Return pointer to the data container */\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Read_Data_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, char *input, void *data, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_Data (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, input, data));\n}\n#endif\n\n/*! . */\nvoid *GMT_Read_Group (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], void *sources, unsigned int *n_items, void *data) {\n\t/* Function to read a group of data files directly into program memory givin an array of objects.\n\t * data is pointer to an existing array of grid container when we read a grid in two steps, otherwise use NULL.\n\t * *n_items = 0: sources is a character string with wildcard-specification for file names.\n\t * *n_items > 0: sources is an array of *n_items character strings with filenames.\n\t * If n_items == NULL then it means 0 but we do not return back the number of items.\n\t * Note: For DATASET and TEXTSET you can also use wildcard expressions in GMT_Read_Data but there we combine then into one data|test-set.\n\t * Return: Pointer to array of data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tunsigned int n_files, k;\n\tchar **file = NULL, *pattern = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tvoid **object = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (data && !(family == GMT_IS_GRID || family == GMT_IS_IMAGE)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Group: data pointer must be NULL except for GRID and IMAGE\\n\");\n\t\treturn_null (API, GMT_PTR_NOT_NULL);\n\t}\n\tif (n_items && *n_items > 0) {\t/* Gave list of files */\n\t\tn_files = *n_items;\n\t\tfile = (char **)sources;\n\t}\n\telse {\t/* Gave wildcard espression(s) */\n\t\tpattern = (void *)sources;\n\t\tif ((n_files = (unsigned int)gmtlib_glob_list (API->GMT, pattern, &file)) == 0) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Group: Expansion of \\\"%s\\\" gave no results\\n\", pattern);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t}\n\t}\n\t/* Reuse data or allocate empty array of containers */\n\tobject = (data == NULL) ? api_alloc_object_array (API, n_files, family) : data;\n\tfor (k = 0; k < n_files; k++) {\n\t\tif ((object[k] = GMT_Read_Data (API, family, method, geometry, mode, wesn, file[k], object[k])) == NULL)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Read_Group: Reading of %s failed, returning NULL\\n\", file[k]);\n\t}\n\tgmtlib_free_list (API->GMT, file, n_files);\t/* Free the file list */\n\tif (n_items) *n_items = n_files;\t/* Return how many items we allocated, if n_items is not NULL */\n\treturn (object);\t/* Return pointer to the data containers */\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Read_Group_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, void *sources, unsigned int *n_items, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_Group (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, sources, n_items, data));\n}\n#endif\n\n/*! . */\nvoid *GMT_Duplicate_Data (void *V_API, unsigned int family, unsigned int mode, void *data) {\n\t/* Create an duplicate container of the requested kind and optionally allocate space\n\t * or duplicate content.\n\t * The known families are GMT_IS_{DATASET,TEXTSET,GRID,PALETTE,IMAGE,POSTSCRIPT}.\n \t * Pass mode as one of GMT_DUPLICATE_{NONE|ALLOC|DATA} to just duplicate the\n\t * container and header structures, allocate space of same dimensions as original,\n\t * or allocate space and duplicate contents.  For GMT_IS_{DATA|TEXT}SET you may add\n\t * the modifiers GMT_ALLOC_VERTICAL or GMT_ALLOC_HORIZONTAL. Also, for GMT_IS_DATASET\n\t * you can manipulate the incoming data->dim to overwrite the number of items allocated.\n\t * [By default we follow the dimensions of hte incoming data].\n\t *\n\t * Return: Pointer to new resource, or NULL if an error (set via API->error).\n\t */\n\n\tint object_ID, item;\n\tunsigned int geometry = 0U, pmode = 0U;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\tswitch (family) {\t/* dataset, cpt, text, grid , image, vector, matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid, allocate header but not data array */\n\t\t\tnew_obj = gmt_duplicate_grid (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image, allocate header but not data array */\n\t\t\tnew_obj = gmtlib_duplicate_image (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset, allocate the requested tables, segments, rows, and columns */\n\t\t\tpmode = (mode & (GMT_ALLOC_VERTICAL + GMT_ALLOC_HORIZONTAL));\t/* Just isolate any special allocation modes */\n\t\t\tmode -= pmode;\t/* Remove the hor/ver flags from the rest of mode */\n\t\t\tif (mode == GMT_DUPLICATE_DATA)\n\t\t\t\tnew_obj = gmt_duplicate_dataset (GMT, data, pmode, &geometry);\n\t\t\telse if (mode == GMT_DUPLICATE_ALLOC) {\t/* Allocate data set of same size, possibly modulated by Din->dim (of > 0) and pmode */\n\t\t\t\tstruct GMT_DATASET *Din = data;\t/* We know this is a GMT_DATASET pointer */\n\t\t\t\tnew_obj = gmt_alloc_dataset (GMT, data, Din->dim[GMT_ROW], Din->dim[GMT_COL], pmode);\n\t\t\t\tgeometry = Din->geometry;\n\t\t\t\tgmt_M_memset (Din->dim, 4, uint64_t);\t/* Reset alloc dimensions */\n\t\t\t}\n\t\t\telse {\t/* Just want a dataset structure */\n\t\t\t\tstruct GMT_DATASET *Din = data;\t/* We know this is a GMT_DATASET pointer */\n\t\t\t\tnew_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASET);\n\t\t\t\tgeometry = Din->geometry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\t/* GMT text dataset, allocate the requested tables, segments, and rows */\n\t\t\tpmode = (mode & (GMT_ALLOC_VERTICAL + GMT_ALLOC_HORIZONTAL));\t/* Just isolate any special allocation modes */\n\t\t\tmode -= pmode;\t/* Remove the hor/ver flags from the rest of mode */\n\t\t\tif (mode == GMT_DUPLICATE_DATA)\n\t\t\t\tnew_obj = gmtlib_duplicate_textset (GMT, data, pmode);\n\t\t\telse if (mode == GMT_DUPLICATE_ALLOC)\t/* Allocate text set of same size, possibly modulated by pmode */\n\t\t\t\tnew_obj =  gmtlib_alloc_textset (GMT, data, pmode);\n\t\t\telse\t/* Just want a dataset structure */\n\t\t\t\tnew_obj = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSET);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT, allocate one with space for dim[0] color entries */\n\t\t\tnew_obj = gmtlib_duplicate_palette (GMT, data, 0);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* GMT PS, allocate one with space for the original */\n\t\t\tnew_obj = gmtlib_duplicate_ps (GMT, data, 0);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (API->error) return_null (API, API->error);\n\n\t/* Now register this dataset so it can be deleted by GMT_Destroy_Data */\n\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_REFERENCE, geometry, GMT_IN, NULL, new_obj)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failure to register */\n\tif ((item = gmtapi_validate_id (API, family, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->geometry = geometry;\t/* Ensure same geometry */\n\tAPI->object[item]->data = new_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Successfully duplicated a %s\\n\", GMT_family[family]);\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMT_Duplicate_Data\");\n#endif\n\n\treturn (new_obj);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Duplicate_Data_ (unsigned int *family,  unsigned int *mode, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Duplicate_Data (GMT_FORTRAN, *family, *mode, data));\n}\n#endif\n\n/*! . */\nint GMT_Write_Data (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], const char *outfile, void *data) {\n\t/* Function to write data directly from program memory as a set (not record-by-record).\n\t * We can combine the <register resource - export resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * Here, *data is the pointer to the data object to save (CPT, dataset, textset, Grid)\n\t * Case 1: outfile != NULL: Register this as the destination and export data.\n\t * Case 2: outfile == NULL: Register stdout as the destination and export data.\n\t * Case 3: geometry == 0: Use a previously registered single destination.\n\t * While only one output destination is allowed, for DATA|TEXTSETS one can\n\t * have the tables and even segments be written to individual files (see the mode\n\t * description in the documentation for how to enable this feature.)\n\t * Return: false if all is well, true if there was an error (and set API->error).\n\t */\n\tunsigned int n_reg;\n\tint out_ID;\n\tchar *output = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (outfile) output = strdup (outfile);\n\n\tif (output) {\t/* Case 1: Save to a single specified destination (file or memory).  Register it first. */\n\t\tif ((out_ID = api_memory_registered (API, family, GMT_OUT, output)) != GMT_NOTSET) {\n\t\t\t/* Output is a memory resource, passed via a @GMTAPI@-###### file name, and ###### is the out_ID.\n\t\t\t   In this case we must make some further checks.  We need to find the API object that holds data.\n\t\t\t   We do this below and get in_ID (the id of the data to write), while out_ID is the id of where\n\t\t\t   things go (the output \"memory\").  Having the in_ID we get the array index in_item that matches\n\t\t\t   this ID and of the correct family.  We set direction to GMT_NOTSET since otherwise we may be\n\t\t\t   denied a hit as we don't really know what the direction is for in_ID.  Once in_item has been\n\t\t\t   secured we transfer ownership of this data from the in_ID object to the out_ID object.  That\n\t\t\t   way we avoid accidental premature freeing of the data object via the in_ID object since it now\n\t\t\t   will live on via out_ID and outlive the current module.\n\t\t\t    */\n\t\t\tint in_ID = GMT_NOTSET,  in_item = GMT_NOTSET;\n\t\t\tin_ID = api_get_object (API, family, data);\t/* Get the object ID of the input source */\n\t\t\tif (in_ID != GMT_NOTSET) in_item = gmtapi_validate_id (API, family, in_ID, GMT_NOTSET, GMT_NOTSET);\t/* Get the item in the API array; pass dir = GMT_NOTSET to bypass status check */\n\t\t\tif (in_item != GMT_NOTSET) {\n\t\t\t\tint out_item = gmtapi_validate_id (API, GMT_NOTSET, out_ID, GMT_OUT, GMT_NOTSET);\t/* Get the item in the API array; pass family = GMT_NOTSET to bypass status check */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Write_Data: Writing %s to memory object %d from object %d which transfers ownership\\n\", GMT_family[family], out_ID, in_ID);\n\t\t\t\tif (API->object[out_item]->method < GMT_IS_VECTOR) API->object[in_item]->no_longer_owner = true;\t/* Since we have passed the content onto an output object */\n\t\t\t\tif (!API->object[out_item]->filename) API->object[out_item]->filename = strdup (output);\n\t\t\t}\n\t\t}\t/* else it is a regular file and we just register it and get the new out_ID needed below */\n\t\telse if ((out_ID = GMT_Register_IO (API, family, method, geometry, GMT_OUT, wesn, output)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (output);\t/* Done with this variable */\n\t\t\treturn_error (API, API->error);\n\t\t}\n\t}\n\telse if (output == NULL && geometry) {\t/* Case 2: Save to stdout.  Register stdout first. */\n\t\tif (family == GMT_IS_GRID) return_error (API, GMT_STREAM_NOT_ALLOWED);\t/* Cannot write grids to stream */\n\t\tif ((out_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, wesn, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET) return_error (API, API->error);\t/* Failure to register std??? */\n\t}\n\telse {\t/* Case 3: output == NULL && geometry == 0, so use the previously registered destination */\n\t\tif ((n_reg = gmtapi_count_objects (API, family, geometry, GMT_OUT, &out_ID)) != 1) {\n\t\t\tgmt_M_str_free (output);\t/* Done with this variable */\n\t\t\treturn_error (API, GMT_NO_OUTPUT);\t/* There is no registered output */\n\t\t}\n\t}\n\t/* With out_ID in hand we can now put the data where it should go */\n\tif (api_put_data (API, out_ID, mode, data) != GMT_OK) {\n\t\tgmt_M_str_free (output);\t/* Done with this variable */\n\t\treturn_error (API, API->error);\n\t}\n\tgmt_M_str_free (output);\t/* Done with this variable */\n\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMT_Write_Data\");\n#endif\n\treturn (GMT_OK);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_Write_Data_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, char *output, void *data, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Write_Data (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, output, data));\n}\n#endif\n\nstatic inline int api_wind_to_next_datarecord (int64_t *count, struct GMT_DATASET *D, unsigned int mode) {\n\t/* Increment row, seg, tbl to next record and return current record status */\n\tif (count[GMT_SEG] == -1) {\t/* Special flag to processes table header(s) */\n\t\tif (count[GMTAPI_HDR_POS] < D->table[count[GMT_TBL]]->n_headers) {\t/* Must first handle table headers */\n\t\t\tcount[GMTAPI_HDR_POS]++;\t/* Increment counter for each one we return until done */\n\t\t\treturn GMT_IO_TABLE_HEADER;\n\t\t}\n\t\t/* Must be out of table headers - time for the segment header */\n\t\tcount[GMT_SEG] = count[GMT_ROW] = 0;\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\tif (count[GMT_ROW] == (int64_t)D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->n_rows) {\t/* Previous record was last in segment, go to next */\n\t\tcount[GMT_SEG]++;\t/* Next segment number */\n\t\tcount[GMT_ROW] = 0;\n\t\tif (count[GMT_SEG] == (int64_t)D->table[count[GMT_TBL]]->n_segments) {\t\t/* Also the end of a table (\"file\") */\n\t\t\tcount[GMT_TBL]++;\t/* Next table number */\n\t\t\tcount[GMT_SEG] = -1;\t/* Reset to start at first segment in this table */\n\t\t\tcount[GMTAPI_HDR_POS] = 0;\t/* Ready to process headers from next table */\n\t\t\tif (count[GMT_TBL] == (int64_t)D->n_tables)\t/* End of entire data set */\n\t\t\t\treturn GMT_IO_EOF;\n\t\t\t/* Just end of a file */\n\t\t\tif (mode & GMT_READ_FILEBREAK)\t/* Return empty handed to indicate a break between files */\n\t\t\t\treturn GMT_IO_NEXT_FILE;\n\t\t}\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\t/* No drama, here we have a data record just go to next row */\n\treturn GMT_IO_DATA_RECORD;\n}\n\nstatic inline int api_wind_to_next_textrecord (int64_t *count, struct GMT_TEXTSET *D, unsigned int mode) {\n\t/* Increment row, seg, tbl to next record and return current record status */\n\tif (count[GMT_SEG] == -1) {\t/* Special flag to processes table header(s) */\n\t\tif (count[GMTAPI_HDR_POS] < D->table[count[GMT_TBL]]->n_headers) {\t/* Must first handle table headers */\n\t\t\tcount[GMTAPI_HDR_POS]++;\t/* Increment counter for each one we return until done */\n\t\t\treturn GMT_IO_TABLE_HEADER;\n\t\t}\n\t\t/* Must be out of table headers - time for the segment header */\n\t\tcount[GMT_SEG] = count[GMT_ROW] = 0;\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\tif (count[GMT_ROW] == (int64_t)D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->n_rows) {\t/* Previous record was last in segment, go to next */\n\t\tcount[GMT_SEG]++;\t/* Next segment number */\n\t\tcount[GMT_ROW] = 0;\n\t\tif (count[GMT_SEG] == (int64_t)D->table[count[GMT_TBL]]->n_segments) {\t\t/* Also the end of a table (\"file\") */\n\t\t\tcount[GMT_TBL]++;\t/* Next table number */\n\t\t\tcount[GMT_SEG] = -1;\t/* Reset to start at first segment in this table */\n\t\t\tcount[GMTAPI_HDR_POS] = 0;\t/* Ready to process headers from next table */\n\t\t\tif (count[GMT_TBL] == (int64_t)D->n_tables)\t/* End of entire data set */\n\t\t\t\treturn GMT_IO_EOF;\n\t\t\t/* Just end of a file */\n\t\t\tif (mode & GMT_READ_FILEBREAK)\t/* Return empty handed to indicate a break between files */\n\t\t\t\treturn GMT_IO_NEXT_FILE;\n\t\t}\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\t/* No drama, here we have a data record just go to next row */\n\treturn GMT_IO_DATA_RECORD;\n}\n\n/*! . */\nint GMT_Set_Geometry (void *V_API, unsigned int direction, unsigned int geometry) {\n\t/* Sets the geometry of direction resource for record-by-record i/o.\n\t * This currently only applies to external interfaces receiving data via rec-by-rc writing.\n\t */\n\tunsigned int method;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tif (!API->io_enabled[GMT_OUT]) return_error (API, GMT_ACCESS_NOT_ENABLED);\n\tAPI->error = GMT_NOERROR;\n\n\tS_obj = API->object[API->current_item[direction]];\t/* Shorthand for the data source we are working on */\n\tif (S_obj == NULL) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* No such object */\n\tmethod = api_set_method (S_obj);\t/* Get the actual method to use */\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_DUPLICATE:\n\t\tcase GMT_IS_REFERENCE:\n\t\t\tif (S_obj->family == GMT_IS_DATASET) {\n\t\t\t\tstruct GMT_DATASET *D_obj = S_obj->resource;\n\t\t\t\tif (!D_obj)\t/* Not allocated yet?*/\n\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: Warning: GMT_Set_Geometry called but no object available\\n\");\n\t\t\t\telse\n\t\t\t\t\tD_obj->geometry = geometry;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t/* For all others there is no geometry requirement, so quietly skip */\n\t\t\tbreak;\n\t}\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Geometry_ (unsigned int *direction, unsigned int *geometry) {\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Geometry (GMT_FORTRAN, *direction, *geometry));\n}\n#endif\n\n/*! . */\nvoid *GMT_Get_Record (void *V_API, unsigned int mode, int *retval) {\n\t/* Retrieves the next data record from the virtual input source and\n\t * returns the number of columns found via *retval (unless retval == NULL).\n\t * If current record is a segment header then we return 0.\n\t * If we reach EOF then we return EOF.\n\t * mode is either GMT_READ_DATA (data columns), GMT_READ_TEXT (text string) or\n\t *\tGMT_READ_MIXED (expect data but tolerate read errors).\n\t * Also, if (mode | GMT_READ_FILEBREAK) is true then we will return empty-handed\n\t *\twhen we get to the end of a file except the final file (which is EOF).\n\t *\tThe calling module can then take actions appropriate between data files.\n\t * The double array OR text string is returned via the pointer *record.\n\t * If not a data record we return NULL, and pass status via API->GMT->current.io.status.\n\t */\n\n\tint status;\n\tunsigned int method;\n\tint64_t *count = NULL, n_fields = 0;\n\tuint64_t col, ij, n_use, col_pos, n_columns = 0;\n\tbool get_next_record;\n\tvoid *record = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_TEXTSET *DT_obj = NULL;\n\tstruct GMT_DATASET *DS_obj = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (retval) *retval = 0;\n\tif (!API->io_enabled[GMT_IN]) return_null (API, GMT_ACCESS_NOT_ENABLED);\n\n\tS_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the current data source we are working on */\n\tAPI->GMT->current.io.read_mixed = (mode == GMT_READ_MIXED);\t/* Cannot worry about constant # of columns if text is present */\n\tGMT = API->GMT;\n\n\tmethod = api_set_method (S_obj);\t/* Get the actual method to use */\n\tdo {\t/* We do this until we can secure the next record or we run out of records (and return EOF) */\n\t\tget_next_record = false;\t/* We expect to read one data record and return */\n\t\tGMT->current.io.status = 0;\t/* Initialize status to OK */\n\t\tif (S_obj->status == GMT_IS_USED) {\t\t/* Finished reading from this resource, go to next resource */\n\t\t\tif (GMT->current.io.ogr == GMT_OGR_TRUE) return_null (API, GMT_OGR_ONE_TABLE_ONLY);\t/* Only allow single tables if GMT/OGR */\n\t\t\tif ((status = api_next_data_object (API, S_obj->family, GMT_IN)) == EOF)\t/* That was the last source, return */\n\t\t\t\tn_fields = EOF;\n\t\t\telse if (status) {\t/* This is not good... */\n\t\t\t\treturn_null (API, GMT_NO_RESOURCES);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tS_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\t\tget_next_record = true;\t\t\t\t/* Since we haven't read the next record yet */\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (method) {\n\t\t\tcase GMT_IS_FILE:\t/* File, stream, and fd are all the same for us, regardless of data or text input */\n\t\t \tcase GMT_IS_STREAM:\n\t\t \tcase GMT_IS_FDESC:\n\t\t \t\trecord = S_obj->import (GMT, S_obj->fp, &(S_obj->n_expected_fields), &status);\t/* Get that next record */\n\t\t\t\tn_fields = S_obj->n_columns = status;\t/* Get that next record */\n\t\t\t\tif (GMT->current.io.status & GMT_IO_EOF) {\t\t\t/* End-of-file in current file (but there may be many files) */\n\t\t\t\t\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\t\tif (S_obj->close_file) {\t/* Close if it was a file that we opened earlier */\n\t\t\t\t\t\tgmt_fclose (GMT, S_obj->fp);\n\t\t\t\t\t\tS_obj->close_file = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (api_next_data_object (API, S_obj->family, GMT_IN) == EOF)\t/* That was the last source, return */\n\t\t\t\t\t\tn_fields = EOF;\t\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\t\t\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t\t\t\tn_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\t\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Get ready to read the next data file */\n\t\t\t\t\t\tS_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\t\t\t\tget_next_record = true;\t\t\t\t/* Since we haven't read the next record yet */\n\t\t\t\t\t}\n\t\t\t\t\tGMT->current.io.tbl_no++;\t\t\t\t/* Update number of tables we have processed */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS_obj->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\n\t\t\t\tif (gmt_M_rec_is_data (GMT) && S_obj->n_expected_fields != GMT_MAX_COLUMNS)\n\t\t\t\t\tGMT->common.b.ncol[GMT_IN] = S_obj->n_expected_fields;\t/* Set the actual column count */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* Here we copy/read from a user memory location */\n\t\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t\tif (S_obj->rec >= S_obj->n_rows) {\t/* Our only way of knowing we are done is to quit when we reach the number of rows that was registered */\n\t\t\t\t\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\t\tif (api_next_data_object (API, S_obj->family, GMT_IN) == EOF) {\t/* That was the last source, return */\n\t\t\t\t\t\tn_fields = EOF;\t\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\t\t\t\t\tGMT->current.io.status = GMT_IO_EOF;\n\t\t\t\t\t}\n\t\t\t\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t\t\t\tn_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\t\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Get ready to read the next data file */\n\t\t\t\t\t\tS_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\t\t\t\tget_next_record = true;\t\t\t\t/* Since we haven't read the next record yet */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\t/* Read from this resource */\n\t\t\t\t\tS_obj->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\t\t\t\t\tM_obj = S_obj->resource;\n\t\t\t\t\tn_use = api_n_cols_needed_for_gaps (GMT, S_obj->n_columns);\n\t\t\t\t\tapi_update_prev_rec (GMT, n_use);\n\t\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : S_obj->n_columns;\n\t\t\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL);\n\t\t\t\t\tapi_get_val = api_select_get_function (API, M_obj->type);\n\t\t\t\t\tfor (col = 0; col < n_columns; col++) {\t/* We know the number of columns from registration */\n\t\t\t\t\t\tcol_pos = api_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\t\t\t\tij = GMT_2D_to_index (S_obj->rec, col_pos, M_obj->dim);\n\t\t\t\t\t\tapi_get_val (&(M_obj->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\tS_obj->rec++;\n\t\t\t\t\tif ((status = api_bin_input_memory (GMT, S_obj->n_columns, n_use)) < 0) {\t/* Process the data record */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP)\t /* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\t\t\t\tS_obj->rec--, API->current_rec[GMT_IN]--;\n\t\t\t\t\t\trecord = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse\t/* Valid data record */\n\t\t\t\t\t\trecord = GMT->current.io.curr_rec;\n\t\t\t\t\tn_fields = n_columns;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t case GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* Here we copy from a user memory location that points to an array of column vectors */\n\t\t\t case GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\t\tif (S_obj->rec == S_obj->n_rows) {\t/* Our only way of knowing we are done is to quit when we reach the number of rows in this vector */\n\t\t\t\t\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\t\tif (api_next_data_object (API, S_obj->family, GMT_IN) == EOF) {\t/* That was the last source, return */\n\t\t\t\t\t\tn_fields = EOF;\t\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\t\t\t\t\tGMT->current.io.status = GMT_IO_EOF;\n\t\t\t\t\t}\n\t\t\t\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t\t\t\tn_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\t\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Get ready to read the next data file */\n\t\t\t\t\t\tS_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\t\t\t\tget_next_record = true;\t\t\t\t/* Since we haven't read the next record yet */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\t/* Read from this resource */\n\t\t\t\t\tS_obj->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\t\t\t\t\tV_obj = S_obj->resource;\n\t\t\t\t\tn_use = api_n_cols_needed_for_gaps (GMT, S_obj->n_columns);\n\t\t\t\t\tapi_update_prev_rec (GMT, n_use);\n\t\t\t\t\tapi_get_val = api_select_get_function (API, V_obj->type[0]);\t/* For 1st column and probably all of them - if not we reset below */\n\t\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : S_obj->n_columns;\n\t\t\t\t\tfor (col = 0; col < n_columns; col++) {\t/* We know the number of columns from registration */\n\t\t\t\t\t\tcol_pos = api_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\t\t\t\tif (col_pos && V_obj->type[col_pos] != V_obj->type[col_pos-1]) api_get_val = api_select_get_function (API, V_obj->type[col_pos]);\n\t\t\t\t\t\tapi_get_val (&(V_obj->data[col_pos]), S_obj->rec, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\tS_obj->rec++;\n\t\t\t\t\tif ((status = api_bin_input_memory (GMT, S_obj->n_columns, n_use)) < 0) {\t/* Process the data record */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP)\t /* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\t\t\t\tS_obj->rec--, API->current_rec[GMT_IN]--;\n\t\t\t\t\t\trecord = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse\t/* Valid data record */\n\t\t\t\t\t\trecord = GMT->current.io.curr_rec;\n\t\t\t\t\tn_fields = n_columns;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_REFERENCE:\t/* Only for textsets and datasets */\n\t\t\t\tcount = GMT->current.io.curr_pos[GMT_IN];\t/* Shorthand used below */\n\t\t\t\tif (S_obj->family == GMT_IS_DATASET) {\n\t\t\t\t\tDS_obj = S_obj->resource;\t/* Get the right dataset */\n\t\t\t\t\tstatus = api_wind_to_next_datarecord (count, DS_obj, mode);\t/* Get current record status and wind counters if needed */\n\t\t\t\t\tn_columns = (GMT->common.i.active) ? GMT->common.i.n_cols : DS_obj->n_columns;\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase GMT_IO_DATA_RECORD:\t/* Got a data record */\n\t\t\t\t\t\t\tS_obj->status = GMT_IS_USING;\t\t/* Mark this resource as currently being read */\n\t\t\t\t\t\t\tfor (col = 0; col < n_columns; col++) {\t/* Copy from row to curr_rec */\n\t\t\t\t\t\t\t\tcol_pos = api_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\t\t\t\t\t\tGMT->current.io.curr_rec[col] = DS_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->data[col_pos][count[GMT_ROW]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trecord = GMT->current.io.curr_rec;\t/* We will return this double array */\n\t\t\t\t\t\t\tn_fields = GMT->common.b.ncol[GMT_IN] = n_columns;\n\t\t\t\t\t\t\tcount[GMT_ROW]++;\t/* Advance to next row for next time GMT_Get_Record is called */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_SEGMENT_HEADER:\t/* Segment break */\n\t\t\t\t\t\t\tif (DS_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header)\n\t\t\t\t\t\t\t\tstrncpy (GMT->current.io.segment_header, DS_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header, GMT_BUFSIZ-1);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tGMT->current.io.segment_header[0] = '\\0';\t/* No header for this segment */\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_TABLE_HEADER:\t/* Table header(s) */\n\t\t\t\t\t\t\tstrncpy (GMT->current.io.record, DS_obj->table[count[GMT_TBL]]->header[count[GMTAPI_HDR_POS]-1], GMT_BUFSIZ-1);\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_NEXT_FILE:\t/* End of a table but more tables to come */\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = GMT_IO_NEXT_FILE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_EOF:\t/* End of entire data set */\n\t\t\t\t\t\t\tS_obj->status = GMT_IS_USED;\t/* Mark this dataset as finished */\n\t\t\t\t\t\t\trecord = NULL;\t/* No more to return anyway */\n\t\t\t\t\t\t\tn_fields = EOF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tGMT->current.io.status = status;\n\t\t\t\t}\n\t\t\t\telse if (S_obj->family == GMT_IS_TEXTSET) {\n\t\t\t\t\tDT_obj = S_obj->resource;\n\t\t\t\t\tstatus = api_wind_to_next_textrecord (count, DT_obj, mode);\t/* Get current record status and wind counters if needed */\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase GMT_IO_DATA_RECORD:\t/* Got a data record */\n\t\t\t\t\t\t\tS_obj->status = GMT_IS_USING;\t\t/* Mark this resource as currently being read */\n\t\t\t\t\t\t\trecord = strncpy (GMT->current.io.record, DT_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->data[count[GMT_ROW]], GMT_BUFSIZ-1);\t/* Copy record */\n\t\t\t\t\t\t\tif (GMT->current.io.record[0] == GMT->current.setting.io_seg_marker[GMT_IN]) {\t/* Got a seg header pretending to be data */\n\t\t\t\t\t\t\t\tstrncpy (GMT->current.io.segment_header, gmtlib_trim_segheader (GMT, GMT->current.io.record), GMT_BUFSIZ-1);\n\t\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\t\tn_fields = 0;\n\t\t\t\t\t\t\t\tstatus = GMT_IO_SEGMENT_HEADER;\t/* Change our mind */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\t/* A read data record */\n\t\t\t\t\t\t\t\tn_fields = 1;\t/* Can only be one string since it is the entire record */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount[GMT_ROW]++;\t/* Advance to next row for next time GMT_Get_Record is called */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_SEGMENT_HEADER:\t/* Segment break */\n\t\t\t\t\t\t\tif (DT_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header)\t/* Copy segment header */\n\t\t\t\t\t\t\t\tstrncpy (GMT->current.io.segment_header, DT_obj->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header, GMT_BUFSIZ-1);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tGMT->current.io.segment_header[0] = '\\0';\t/* No header for this segment */\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_TABLE_HEADER:\t/* Table header(s) */\n\t\t\t\t\t\t\tstrncpy (GMT->current.io.record, DT_obj->table[count[GMT_TBL]]->header[count[GMTAPI_HDR_POS]-1], GMT_BUFSIZ-1);\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_NEXT_FILE:\t\t/* End of a table but more tables to come */\n\t\t\t\t\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t\t\t\t\tn_fields = GMT_IO_NEXT_FILE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GMT_IO_EOF:\t/* End of entire data set */\n\t\t\t\t\t\t\tS_obj->status = GMT_IS_USED;\t/* Mark this dataset as finished */\n\t\t\t\t\t\t\trecord = NULL;\t/* No more to return anyway */\n\t\t\t\t\t\t\tn_fields = EOF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tGMT->current.io.status = status;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: GMT_Get_Record called with illegal method\\n\");\n\t\t\t\tbreak;\n\t\t}\n\t} while (get_next_record);\n\n\tif (!(n_fields == EOF || n_fields == GMT_IO_NEXT_FILE)) API->current_rec[GMT_IN]++;\t/* Increase record count, unless EOF */\n\n\tif (retval) *retval = (int)n_fields;\t/* Requested we return the number of fields found */\n\treturn (record);\t/* Return pointer to current record */\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Get_Record_ (unsigned int *mode, int *status) {\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Record (GMT_FORTRAN, *mode, status));\n}\n#endif\n\n/*! . */\nint GMT_Put_Record (void *V_API, unsigned int mode, void *record) {\n\t/* Writes a single data record to destimation.\n\t * We use mode to signal the kind of record:\n\t *   GMT_WRITE_TABLE_HEADER: Write an ASCII table header\n\t *   GMT_WRITE_SEGMENT_HEADER: Write an ASCII or binary segment header\n\t *   GMT_WRITE_DATA:    Write an ASCII or binary data record\n\t *   GMT_WRITE_TEXT:      Write an ASCII data record\n\t * For text: If record == NULL use internal current record or header.\n\t * Returns 0 if a record was written successfully (See what -s[r] can do).\n\t * If an error occurs we return GMT_NOTSET and set API->error.\n\t */\n\tint error = 0;\n\tunsigned int method;\n\tint64_t *count = NULL;\n\tuint64_t col, ij;\n\tchar *s = NULL;\n\tdouble *d = NULL, value;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tif (!API->io_enabled[GMT_OUT]) return_error (API, GMT_ACCESS_NOT_ENABLED);\n\tAPI->error = GMT_NOERROR;\n\n\tS_obj = API->object[API->current_item[GMT_OUT]];\t/* Shorthand for the data source we are working on */\n\tif (S_obj->status == GMT_IS_USED) return_error (API, GMT_WRITTEN_ONCE);\t/* Only allow writing of a data set once [unless we reset status] */\n\tmethod = api_set_method (S_obj);\t/* Get the actual method to use */\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t \tcase GMT_IS_STREAM:\n\t \tcase GMT_IS_FDESC:\n\t\t\tswitch (mode) {\n\t\t\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\t\t\ts = (record) ? record : API->GMT->current.io.record;\t/* Default to last input record if NULL */\n\t\t\t\t\tgmtlib_write_tableheader (API->GMT, S_obj->fp, s);\terror = 1;\t/* Write one item */\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Export a segment header record; write NaNs if binary  */\n\t\t\t\t\tif (record) strncpy (API->GMT->current.io.segment_header, record, GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\t\t\tgmt_write_segmentheader (API->GMT, S_obj->fp, API->GMT->common.b.ncol[GMT_OUT]);\terror = 1;\t/* Write one item */\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_WRITE_DATA:\t\t/* Export either a formatted ASCII data record or a binary record */\n\t\t\t\t\tif (API->GMT->common.b.ncol[GMT_OUT] == UINT_MAX) API->GMT->common.b.ncol[GMT_OUT] = API->GMT->common.b.ncol[GMT_IN];\n\t\t\t\t\terror = API->GMT->current.io.output (API->GMT, S_obj->fp, API->GMT->common.b.ncol[GMT_OUT], record);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_WRITE_TEXT:\t\t/* Export the current text record; skip if binary */\n\t\t\t\t\ts = (record) ? record : API->GMT->current.io.record;\n\t\t\t\t\tgmtlib_write_textrecord (API->GMT, S_obj->fp, s);\terror = 1;\t/* Write one item */\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_WRITE_TABLE_START:\t/* Write title and command to start of file; skip if binary */\n\t\t\t\t\tgmtlib_write_newheaders (API->GMT, S_obj->fp, S_obj->n_columns);\terror = 1;\t/* Write one item */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: GMT_Put_Record called with illegal mode %u\\n\", mode);\n\t\t\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\t/* Fill in a DATASET structure with one table only */\n\t\tcase GMT_IS_REFERENCE:\t/* Fill in a DATASET structure with one table only */\n\t\t\tif (S_obj->family == GMT_IS_DATASET) {\n\t\t\t\tstruct GMT_DATASET *D_obj = S_obj->resource;\n\t\t\t\tstruct GMT_DATATABLE *T_obj = NULL;\n\t\t\t\tif (!D_obj) {\t/* First time allocation of the single output table */\n\t\t\t\t\tD_obj = gmtlib_create_dataset (API->GMT, 1, GMT_TINY_CHUNK, 0, 0, S_obj->geometry, true);\t/* 1 table, segments array; no cols or rows yet */\n\t\t\t\t\tS_obj->resource = D_obj;\t/* Save this pointer for next time we call GMT_Put_Record */\n\t\t\t\t\tAPI->GMT->current.io.curr_pos[GMT_OUT][GMT_SEG] = -1;\t/* Start at seg = -1 and increment at first segment header */\n\t\t\t\t\tif (API->GMT->common.b.ncol[GMT_OUT] == 0 && API->GMT->common.b.ncol[GMT_IN] < GMT_MAX_COLUMNS)\n\t\t\t\t\t\tAPI->GMT->common.b.ncol[GMT_OUT] = API->GMT->common.b.ncol[GMT_IN];\n\t\t\t\t\tD_obj->n_columns = D_obj->table[0]->n_columns = API->GMT->common.b.ncol[GMT_OUT];\n\t\t\t\t}\n\t\t\t\tT_obj = D_obj->table[0];\t/* GMT_Put_Record only writes one table with one or more segments */\n\t\t\t\tif ((D_obj->n_columns == 0 || D_obj->n_columns == GMT_MAX_COLUMNS || D_obj->n_columns < API->GMT->common.b.ncol[GMT_OUT]) && mode == GMT_WRITE_DATA) {\t/* Number of columns not set or set incorrectly, see if -b has it */\n\t\t\t\t\tif (API->GMT->common.b.ncol[GMT_OUT])\n\t\t\t\t\t\tD_obj->n_columns = T_obj->n_columns = API->GMT->common.b.ncol[GMT_OUT];\n\t\t\t\t\telse {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: Error: GMT_Put_Record does not know the number of columns\\n\");\n\t\t\t\t\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = API->GMT->current.io.curr_pos[GMT_OUT];\t/* Short hand to counters for table (not used as == 0), segment, row */\n\t\t\t\tswitch (mode) {\n\t\t\t\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\t\t\t\ts = (record) ? record : API->GMT->current.io.record;\t/* Default to last input record if NULL */\n\t\t\t\t\t\t/* Hook into table header list */\n\t\t\t\t\t\tif (count[GMT_SEG] == -1) {\t/* Only allow headers for first segment in a table */\n\t\t\t\t\t\t\tT_obj->header = gmt_M_memory (API->GMT, T_obj->header, T_obj->n_headers+1, char *);\n\t\t\t\t\t\t\tT_obj->header[T_obj->n_headers++] = strdup (s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Export a segment header record; write NaNs if binary  */\n\t\t\t\t\t\tcount[GMT_SEG]++;\t/* Start of new segment */\n\t\t\t\t\t\tif (count[GMT_SEG]) {\t/* Must first copy over records for the previous segments; last (or only) segment will be done by GMT_End_IO */\n\t\t\t\t\t\t\tgmtlib_assign_segment (API->GMT, T_obj->segment[count[GMT_SEG]-1], count[GMT_ROW], T_obj->n_columns);\t/* Allocate and place arrays into previous segment */\n\t\t\t\t\t\t\tcount[GMT_ROW] = 0;\t/* Reset for next segment */\n\t\t\t\t\t\t\tT_obj->n_segments++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (count[GMT_SEG] == (int64_t)T_obj->n_alloc) {\t/* Extend but set new members to NULL */\n\t\t\t\t\t\t\tsize_t was = T_obj->n_alloc;\n\t\t\t\t\t\t\tT_obj->segment = gmt_M_malloc (API->GMT, T_obj->segment, count[GMT_SEG], &T_obj->n_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t\tgmt_M_memset (&T_obj->segment[was], T_obj->n_alloc - was, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!T_obj->segment[count[GMT_SEG]]) T_obj->segment[count[GMT_SEG]] = gmt_M_memory (API->GMT, NULL, 1, struct GMT_DATASEGMENT);\n\t\t\t\t\t\ts = (record) ? record : API->GMT->current.io.segment_header;\t/* Default to last segment header record if NULL */\n\t\t\t\t\t\tif (s) {\t/* Found a segment header */\n\t\t\t\t\t\t\tif (T_obj->segment[count[GMT_SEG]]->header) gmt_M_str_free (T_obj->segment[count[GMT_SEG]]->header);\t/* Hm, better free the old guy before strdup'ing a new one */\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]]->header = strdup (s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_DATA:\t\t/* Export a segment row */\n\t\t\t\t\t\tif (gmt_skip_output (API->GMT, record, T_obj->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (count[GMT_SEG] == -1) {\t/* Most likely a file with one segment but no segment header */\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: Internal Warning: GMT_Put_Record (double) called before any segments declared\\n\");\n\t\t\t\t\t\t\tcount[GMT_SEG] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgmt_prep_tmp_arrays (API->GMT, count[GMT_ROW], T_obj->n_columns);\t/* Init or reallocate tmp read vectors */\n\t\t\t\t\t\tfor (col = 0; col < T_obj->n_columns; col++) {\n\t\t\t\t\t\t\tAPI->GMT->hidden.mem_coord[col][count[GMT_ROW]] = ((double *)record)[col];\n\t\t\t\t\t\t\tif (API->GMT->current.io.col_type[GMT_OUT][col] & GMT_IS_LON) gmt_lon_range_adjust (API->GMT->current.io.geo.range, &(API->GMT->hidden.mem_coord[col][count[GMT_ROW]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount[GMT_ROW]++;\t/* Increment rows in this segment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_TABLE_START:\t/* Write title and command to start of file; skip if binary */\n\t\t\t\t\t\tbreak;\t/* Ignore for this method */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: GMT_Put_Record called with illegal mode %u\\n\", mode);\n\t\t\t\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t/* TEXTSET */\n\t\t\t\tstruct GMT_TEXTSET *D_obj = S_obj->resource;\n\t\t\t\tstruct GMT_TEXTTABLE *T_obj = NULL;\n\t\t\t\tif (!D_obj) {\t/* First time allocation of one table */\n\t\t\t\t\tD_obj = gmtlib_create_textset (API->GMT, 1, GMT_TINY_CHUNK, 0, true);\n\t\t\t\t\tS_obj->resource = D_obj;\n\t\t\t\t\tAPI->GMT->current.io.curr_pos[GMT_OUT][GMT_SEG] = -1;\t/* Start at seg = -1 and increment at first segment header */\n\t\t\t\t}\n\t\t\t\tT_obj = D_obj->table[0];\t/* GMT_Put_Record only writes one table */\n\t\t\t\tcount = API->GMT->current.io.curr_pos[GMT_OUT];\t/* Short hand to counters for table, segment, row */\n\t\t\t\tswitch (mode) {\n\t\t\t\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\t\t\t\ts = (record) ? record : API->GMT->current.io.record;\t/* Default to last input record if NULL */\n\t\t\t\t\t\t/* Hook into table header list */\n\t\t\t\t\t\tif (count[GMT_SEG] == -1) {\t/* Only allow headers for first segment in a table */\n\t\t\t\t\t\t\tT_obj->header = gmt_M_memory (API->GMT, T_obj->header, T_obj->n_headers+1, char *);\n\t\t\t\t\t\t\tT_obj->header[T_obj->n_headers++] = strdup (s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Export a segment header record; write NaNs if binary  */\n\t\t\t\t\t\tcount[GMT_SEG]++;\t/* Start of new segment */\n\t\t\t\t\t\tif (count[GMT_SEG] > 0) {\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]-1]->data = gmt_M_memory (API->GMT, T_obj->segment[count[GMT_SEG]-1]->data, count[GMT_ROW], char *);\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]-1]->n_rows = count[GMT_ROW];\n\t\t\t\t\t\t\tT_obj->n_segments++;\n\t\t\t\t\t\t\tcount[GMT_ROW] = 0;\t/* Reset for next segment */\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (count[GMT_SEG] == (int64_t)T_obj->n_alloc) {\t/* Allocate more but set pointers to NULL */\n\t\t\t\t\t\t\tsize_t was = T_obj->n_alloc;\n\t\t\t\t\t\t\tT_obj->segment = gmt_M_malloc (API->GMT, T_obj->segment, count[GMT_SEG], &T_obj->n_alloc, struct GMT_TEXTSEGMENT *);\n\t\t\t\t\t\t\tgmt_M_memset (&T_obj->segment[was], T_obj->n_alloc - was, struct GMT_TEXTSEGMENT *);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!T_obj->segment[count[GMT_SEG]]) T_obj->segment[count[GMT_SEG]] = gmt_M_memory (API->GMT, NULL, 1, struct GMT_TEXTSEGMENT);\n\t\t\t\t\t\ts = (record) ? record : API->GMT->current.io.segment_header;\t/* Default to last segment header record if NULL */\n\t\t\t\t\t\tif (s) {\t/* Found a segment header */\n\t\t\t\t\t\t\tif (T_obj->segment[count[GMT_SEG]]->header)\n\t\t\t\t\t\t\t\tgmt_M_str_free (T_obj->segment[count[GMT_SEG]]->header);\t/* Hm, better free the old guy before strdup'ing a new one */\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]]->header = strdup (s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_TEXT:\t\t/* Export a record */\n\t\t\t\t\t\tif (count[GMT_SEG] == -1) {\t/* Most likely a file with one segment but no segment header */\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: Internal Warning: GMT_Put_Record (text) called before any segments declared\\n\");\n\t\t\t\t\t\t\tcount[GMT_SEG] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!T_obj->segment[count[GMT_SEG]]) T_obj->segment[count[GMT_SEG]] = gmt_M_memory (API->GMT, NULL, 1, struct GMT_TEXTSEGMENT);\t/* Allocate new segment */\n\t\t\t\t\t\tif (count[GMT_ROW] == (int64_t)T_obj->segment[count[GMT_SEG]]->n_alloc) {\t/* Allocate more records */\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]]->n_alloc = (T_obj->segment[count[GMT_SEG]]->n_alloc == 0) ? GMT_CHUNK : T_obj->segment[count[GMT_SEG]]->n_alloc << 1;\n\t\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]]->data = gmt_M_memory (API->GMT, NULL, T_obj->segment[count[GMT_SEG]]->n_alloc, char *);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tT_obj->segment[count[GMT_SEG]]->data[count[GMT_ROW]] = strdup (record);\n\t\t\t\t\t\tcount[GMT_ROW]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GMT_WRITE_TABLE_START:\t/* Write title and command to start of file; skip if binary */\n\t\t\t\t\t\tbreak;\t/* Ignore for this method */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: GMT_Put_Record (text) called with illegal mode\\n\");\n\t\t\t\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* Data matrix only */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t/* At the first output record the output matrix has not been allocated.\n\t\t\t * So first we do that, then later we can increment its size when needed.\n\t\t\t * The realloc to final size takes place in GMT_End_IO. */\n\t\t\tif (S_obj->n_rows && S_obj->rec >= S_obj->n_rows)\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: GMT_Put_Record exceeding limits on rows(?) - possible bug\\n\");\n\t\t\tif (S_obj->resource == NULL) {\t/* First time allocating space; S_obj->n_rows == S_obj->n_alloc == 0 */\n\t\t\t\tsize_t size;\n\t\t\t\tcol = (API->GMT->common.o.active) ? API->GMT->common.o.n_cols : API->GMT->common.b.ncol[GMT_OUT];\t/* Number of columns needed to hold the data records */\n\t\t\t\tif (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && API->GMT->current.io.multi_segments[GMT_OUT]) {\n\t\t\t\t\t/* Cannot place the NaN records since we don't know the number of columns yet */\n\t\t\t\t\tS_obj->delay++;\n\t\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = S_obj->n_alloc = GMT_CHUNK;\n\t\t\t\tM_obj = gmtlib_create_matrix (API->GMT, 1U, GMT_OUT);\n\t\t\t\tM_obj->type = API->GMT->current.setting.export_type;\t/* Use selected data type for export */\n\t\t\t\tM_obj->dim = M_obj->n_columns = col;\t/* If COL_FORMAT the dim will change in end_io_matrix after transpose */\n\t\t\t\tsize *= M_obj->n_columns;\t/* Size in bytes of the initial matrix allocation */\n\t\t\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M_obj->data), M_obj->type, size)) != GMT_OK) return (gmtapi_report_error (API, error));\n\t\t\t\tM_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t\tS_obj->resource = M_obj;\t/* Save so we can get it next time */\n\t\t\t}\n\t\t\tM_obj = S_obj->resource;\n\t\t\tGMT_2D_to_index = api_get_2d_to_index (API, GMT_IS_ROW_FORMAT, GMT_GRID_IS_REAL);\t/* Since we cannot do col_format without knowing dimension - see end_io_matrix */\n\t\t\tapi_put_val = api_select_put_function (API, M_obj->type);\n\t\t\tif (mode == GMT_WRITE_SEGMENT_HEADER && API->GMT->current.io.multi_segments[GMT_OUT]) {\t/* Segment header - flag in data as NaNs in current_record (d) */\n\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\tij = GMT_2D_to_index (S_obj->rec, col, M_obj->dim);\n\t\t\t\t\tapi_put_val (&(M_obj->data), ij, API->GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record becomes an actual data record that encodes a segment break */\n\t\t\t\tM_obj->n_rows++;\t\t/* Same */\n\t\t\t}\n\t\t\telse if (mode == GMT_WRITE_DATA) {\t/* Data record */\n\t\t\t\tif (!record)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: GMT_Put_Record passed a NULL data pointer for method GMT_IS_DUPLICATE_VIA_MATRIX\\n\");\n\t\t\t\telse {\n\t\t\t\t\td = record;\t/* Cast the void record to a double pointer */\n\t\t\t\t\tif (gmt_skip_output (API->GMT, d, M_obj->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\t\t\terror = GMT_NOTSET;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\t\t\tij = GMT_2D_to_index (S_obj->rec, col, M_obj->dim);\n\t\t\t\t\t\t\tvalue = api_select_record_value (API->GMT, d, (unsigned int)col, (unsigned int)API->GMT->common.b.ncol[GMT_OUT]);\n\t\t\t\t\t\t\tapi_put_val (&(M_obj->data), ij, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tM_obj->n_rows++;\t/* Note that API->current_rec[GMT_OUT] and S_obj->rec are incremented separately at end of function */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* List of column arrays */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tif (S_obj->n_rows && S_obj->rec >= S_obj->n_rows)\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: GMT_Put_Record exceeding limits on rows(?) - possible bug\\n\");\n\t\t\tif (S_obj->resource == NULL) {\t/* First time allocating space; S_obj->n_rows == S_obj->n_alloc == 0 */\n\t\t\t\tcol = (API->GMT->common.o.active) ? API->GMT->common.o.n_cols : API->GMT->common.b.ncol[GMT_OUT];\t/* Number of columns needed to hold the data records */\n\t\t\t\tif (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && API->GMT->current.io.multi_segments[GMT_OUT]) {\n\t\t\t\t\t/* Cannot place the NaN records since we don't know the number of columns yet */\n\t\t\t\t\tS_obj->delay++;\n\t\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tS_obj->n_alloc = GMT_CHUNK;\t/* Size in bytes of the initial matrix allocation */\n\t\t\t\tif ((V_obj = gmt_create_vector (API->GMT, col, GMT_OUT)) == NULL)\n\t\t\t\t\treturn_error (API, GMT_MEMORY_ERROR);\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\t\t\tV_obj->type[col] = API->GMT->current.setting.export_type;\n\t\t\t\tif ((error = api_alloc_vectors (API->GMT, V_obj, S_obj->n_alloc)) != GMT_OK) return (gmtapi_report_error (API, error));\n\t\t\t\tS_obj->resource = V_obj;\t/* Save so we can get it next time */\n\t\t\t}\n\t\t\tV_obj = S_obj->resource;\n\n\t\t\tapi_put_val = api_select_put_function (API, V_obj->type[0]);\t/* For 1st column and probably all of them - if not we reset below */\n\t\t\tif (mode == GMT_WRITE_SEGMENT_HEADER && API->GMT->current.io.multi_segments[GMT_OUT]) {\t/* Segment header - flag in data as NaNs */\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\tif (col && V_obj->type[col] != V_obj->type[col-1]) api_put_val = api_select_put_function (API, V_obj->type[col]);\n\t\t\t\t\tapi_put_val (&(V_obj->data[col]), S_obj->rec, API->GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\tV_obj->n_rows++;\t\t/* Same */\n\t\t\t}\n\t\t\telse if (mode == GMT_WRITE_DATA) {\t/* Data record */\n\t\t\t\tif (!record)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: GMT_Put_Record passed a NULL data pointer for method GMT_IS_DATASET_ARRAY\\n\");\n\t\t\t\telse {\n\t\t\t\t\td = record;\t/* Cast the void record to a double pointer */\n\t\t\t\t\tif (gmt_skip_output (API->GMT, d, V_obj->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\t\t\terror = GMT_NOTSET;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\t\t\tvalue = api_select_record_value (API->GMT, d, (unsigned int)col, (unsigned int)API->GMT->common.b.ncol[GMT_OUT]);\n\t\t\t\t\t\t\tif (col && V_obj->type[col] != V_obj->type[col-1]) api_put_val = api_select_put_function (API, V_obj->type[col]);\n\t\t\t\t\t\t\tapi_put_val (&(V_obj->data[col]), S_obj->rec, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tV_obj->n_rows++;\t/* Note that API->current_rec[GMT_OUT] and S_obj->rec are incremented separately at end of function */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMTAPI: Internal error: GMT_Put_Record called with illegal method\\n\");\n\t\t\treturn_error (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\n\tif (!error && (mode == GMT_WRITE_DATA || mode == GMT_WRITE_TEXT))\t{\t/* Only increment if we placed a data record on the output */\n\t\tAPI->current_rec[GMT_OUT]++;\n\t\tS_obj->rec++;\n\t}\n\n\tif (S_obj->n_alloc && S_obj->rec == S_obj->n_alloc) {\t/* Must allocate more memory for vectors or matrices */\n\t\tS_obj->n_alloc <<= 1;\n\t\tif (M_obj && (S_obj->method == GMT_IS_DUPLICATE || S_obj->method == GMT_IS_REFERENCE) && S_obj->actual_family == GMT_IS_MATRIX) {\n\t\t\tsize_t size = S_obj->n_alloc * M_obj->n_columns;\t/* Only one layer in this context */\n\t\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M_obj->data), M_obj->type, size)) != GMT_OK) return (error);\n\t\t}\n\t\telse if (V_obj) {\t/* VIA_VECTOR */\n\t\t\tif ((error = api_alloc_vectors (API->GMT, V_obj, S_obj->n_alloc)) != GMT_OK) return (error);\n\t\t}\n\t}\n\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\n\treturn ((error) ? GMT_NOTSET : 0);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Record_ (unsigned int *mode, void *record) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Record (GMT_FORTRAN, *mode, record));\n}\n#endif\n\n/*! . */\nint GMT_Get_Row (void *V_API, int row_no, struct GMT_GRID *G, float *row) {\n\t/* Reads the entire row vector form the grdfile\n\t * If row_no is NEGATIVE it is interpreted to mean that we want to\n\t * fseek to the start of the abs(row_no) record and no reading takes place.\n\t * If R->auto_advance is false we must set R->start explicitly to row_no.\n\t * If R->auto_advance is true it reads the current row and advances R->row++\n\t * In this case row_no is not used.\n\t */\n\tunsigned int err;\n \tunsigned int col;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_ROWBYROW *R = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\tfmt = GMT->session.grdformat[G->header->type];\n\tR = api_get_rbr_ptr (G->extra);\n\tif (fmt[0] == 'c') {\t\t/* Get one NetCDF row, old format */\n\t\tif (row_no < 0) {\t/* Special seek instruction, then return */\n\t\t\tR->row = abs (row_no);\n\t\t\tR->start[0] = R->row * R->edge[0];\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\telse if (!R->auto_advance) {\t/* Go to specified row and read it */\n\t\t\tR->row = row_no;\n\t\t\tR->start[0] = R->row * R->edge[0];\n\t\t}\n\t\tgmt_M_err_trap (nc_get_vara_float (R->fid, G->header->z_id, R->start, R->edge, row));\n\t\tif (R->auto_advance) R->start[0] += R->edge[0];\t/* Advance to next row if auto */\n\t}\n\telse if (fmt[0] == 'n') {\t/* Get one NetCDF row, COARDS-compliant format */\n\t\tif (row_no < 0) {\t/* Special seek instruction */\n\t\t\tR->row = abs (row_no);\n\t\t\tR->start[0] = G->header->row_order == k_nc_start_north ? R->row : G->header->n_rows - 1 - R->row;\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\telse if (!R->auto_advance) {\n\t\t\tR->row = row_no;\n\t\t\tR->start[0] = G->header->row_order == k_nc_start_north ? R->row : G->header->n_rows - 1 - R->row;\n\t\t}\n\t\tgmt_M_err_trap (nc_get_vara_float (R->fid, G->header->z_id, R->start, R->edge, row));\n\t\tif (R->auto_advance) R->start[0] -= G->header->row_order;\t/* Advance to next row if auto */\n\t}\n\telse {\t\t\t/* Get a native binary row */\n\t\tsize_t n_items;\n\t\tif (row_no < 0) {\t/* Special seek instruction */\n\t\t\tR->row = abs (row_no);\n\t\t\tif (fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + R->row * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\tR->row = row_no;\n\t\tif (!R->auto_advance && fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + R->row * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\n\t\tn_items = G->header->n_columns;\n\t\tif (fmt[1] == 'f') {\t/* Binary float, no need to mess with decoding */\n\t\t\tif (gmt_M_fread (row, R->size, n_items, R->fp) != n_items) return (GMT_GRDIO_READ_FAILED);\t/* Get one row */\n\t\t}\n\t\telse {\n\t\t\tif (gmt_M_fread (R->v_row, R->size, n_items, R->fp) != n_items) return (GMT_GRDIO_READ_FAILED);\t/* Get one row */\n\t\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\t\trow[col] = gmtlib_decode (GMT, R->v_row, col, fmt[1]);\t/* Convert whatever to float */\n\t\t}\n#ifdef DEBUG\n\t\tR->pos = ftell (R->fp);\t/* Update where we are */\n#endif\n\t}\n\tif (R->check) {\t/* Replace NaN-marker with actual NaN */\n\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\tif (row[col] == G->header->nan_value)\n\t\t\t\trow[col] = GMT->session.f_NaN;\n\t}\n\tgmt_scale_and_offset_f (GMT, row, G->header->n_columns, G->header->z_scale_factor, G->header->z_add_offset);\n\tif (R->auto_advance) R->row++;\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Row_ (int *rec_no, struct GMT_GRID *G, float *row) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Row (GMT_FORTRAN, *rec_no, G, row));\n}\n#endif\n\n/*! . */\nint GMT_Put_Row (void *V_API, int rec_no, struct GMT_GRID *G, float *row) {\n\t/* Writes the entire row vector to the grdfile\n\t * If row_no is NEGATIVE it is interpreted to mean that we want to\n\t * fseek to the start of the abs(row_no) record and no reading takes place.\n\t * If R->auto_advance is false we must set R->start explicitly to row_no.\n\t * If R->auto_advance is true it writes at the current row and advances R->row++\n\t * In this case row_no is not used.\n\t */\n\n\tunsigned int err;\t/* Required by gmt_M_err_trap */\n\tunsigned int col;\n\tsize_t n_items;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_ROWBYROW *R = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\tfmt = GMT->session.grdformat[G->header->type];\n\tR = api_get_rbr_ptr (G->extra);\n\tgmt_scale_and_offset_f (GMT, row, G->header->n_columns, G->header->z_scale_factor, G->header->z_add_offset);\n\tif (R->check) {\t/* Replace NaNs with special value */\n\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\tif (gmt_M_is_fnan (row[col]))\n\t\t\t\trow[col] = G->header->nan_value;\n\t}\n\n\tswitch (fmt[0]) {\n\t\tcase 'c':\n\t\t\tif (!R->auto_advance) R->start[0] = rec_no * R->edge[0];\n\t\t\tgmt_M_err_trap (nc_put_vara_float (R->fid, G->header->z_id, R->start, R->edge, row));\n\t\t\tif (R->auto_advance) R->start[0] += R->edge[0];\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (!R->auto_advance) R->start[0] = G->header->row_order = k_nc_start_north ? rec_no : G->header->n_rows - 1 - rec_no;\n\t\t\tgmt_M_err_trap (nc_put_vara_float (R->fid, G->header->z_id, R->start, R->edge, row));\n\t\t\tif (R->auto_advance) R->start[0] -= G->header->row_order;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!R->auto_advance && fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + rec_no * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\t\tn_items = G->header->n_columns;\n\t\t\tif (fmt[1] == 'f') {\t/* Regular floats */\n\t\t\t\tif (gmt_M_fwrite (row, R->size, n_items, R->fp) < n_items) return (GMT_GRDIO_WRITE_FAILED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (col = 0; col < G->header->n_columns; col++) gmtlib_encode (GMT, R->v_row, col, row[col], fmt[1]);\n\t\t\t\tif (gmt_M_fwrite (R->v_row, R->size, n_items, R->fp) < n_items) return (GMT_GRDIO_WRITE_FAILED);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (R->auto_advance) R->row++;\n\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Row_ (int *rec_no, struct GMT_GRID *G, float *row) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Row (GMT_FORTRAN, *rec_no, G, row));\n}\n#endif\n\nGMT_LOCAL char *ptrvoid (char ** p) { \t/* Handle as char ** just to determine if address is of a NULL pointer */\n\treturn *p;\n}\n\n/*! . */\nint GMT_Destroy_Data (void *V_API, void *object) {\n\t/* Destroy a resource that is no longer needed.\n\t * Returns the error code.\n\t */\n\tint error, item, object_ID;\n\tenum GMT_enum_family family;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* This is a cardinal sin */\n\tif (object == NULL) return (false);\t/* Null address, quietly skip */\n\tif (!ptrvoid(object)) return (false);\t/* Null pointer, quietly skip */\n\tAPI = api_get_api_ptr (V_API);\t\t/* Now we need to get that API pointer to check further */\n\tif ((object_ID = api_get_object_id_from_data_ptr (API, object)) == GMT_NOTSET) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find the object in the list */\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\t/* Could not find that item */\n\tfamily = API->object[item]->actual_family;\n\n\tswitch (family) {\t/* Standard 6 families, plus matrix/vector and coordinates */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\terror = api_destroy_grid (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\terror = api_destroy_dataset (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\terror = api_destroy_textset (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\terror = api_destroy_palette (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\terror = api_destroy_image (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\terror = api_destroy_postscript (API, object);\n\t\t\tbreak;\n\n\t\t/* Also allow destroying of intermediate vector and matrix containers */\n\t\tcase GMT_IS_MATRIX:\n\t\t\terror = api_destroy_matrix (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\terror = api_destroy_vector (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\terror = api_destroy_coord (API, object);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\tif (!error) {\t/* We successfully freed the items, now remove from IO list */\n\t\tunsigned int j;\n\t\tvoid *address = API->object[item]->data;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Destroy_Data: freed memory for a %s for object %d\\n\", GMT_family[family], object_ID);\n\t\tif ((error = gmtapi_unregister_io (API, object_ID, (unsigned int)GMT_NOTSET))) return_error (API, error);\t/* Did not find object */\n\t\tfor (j = 0; j < API->n_objects; j++) {\n\t\t\tif (API->object[j]->data == address) API->object[j]->data = NULL;\t\t/* Set repeated data references to NULL so we don't try to free twice */\n\t\t\tif (API->object[j]->resource == address) API->object[j]->resource = NULL;\t/* Set matching resources to NULL so we don't try to read from there again */\n\t\t}\n#ifdef DEBUG\n\t\tapi_list_objects (API, \"GMT_Destroy_Data\");\n#endif\n\n\t}\n\telse {\n\t\t/* Quietly ignore these errors: GMT_PTR_IS_NULL, GMT_FREE_EXTERNAL_NOT_ALLOWED, GMT_FREE_WRONG_LEVEL as they are not considered errors here. */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Destroy_Data: Ignored warning %d for object %d\\n\", error, object_ID);\n\t}\n\treturn_error (API, GMT_OK);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Data_ (void *object) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Destroy_Data (GMT_FORTRAN, object));\n}\n#endif\n\nint api_destroy_grids (struct GMTAPI_CTRL *API, struct GMT_GRID ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_GRID **G = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &G[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, G);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_datasets (struct GMTAPI_CTRL *API, struct GMT_DATASET ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_DATASET **D = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &D[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, D);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_textsets (struct GMTAPI_CTRL *API, struct GMT_TEXTSET ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_TEXTSET **T = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &T[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, T);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_images (struct GMTAPI_CTRL *API, struct GMT_IMAGE ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_IMAGE **I = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &I[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, I);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_palettes (struct GMTAPI_CTRL *API, struct GMT_PALETTE ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_PALETTE **C = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &C[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, C);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_postscripts (struct GMTAPI_CTRL *API, struct GMT_POSTSCRIPT ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_POSTSCRIPT **P = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &P[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, P);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_matrices (struct GMTAPI_CTRL *API, struct GMT_MATRIX ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_MATRIX **M = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &M[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, M);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nint api_destroy_vectors (struct GMTAPI_CTRL *API, struct GMT_VECTOR ***obj, unsigned int n_items)\n{\n\tunsigned int k;\n\tint error;\n\tstruct GMT_VECTOR **V = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &V[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, V);\t*obj = NULL;\n\treturn_error (API, GMT_OK);\n}\n\nvoid **void3_to_void2 (void ***p) { return (*p); }\n\n/*! . */\nint GMT_Destroy_Group (void *V_API, void *object, unsigned int n_items) {\n\t/* Destroy an array of resources that are no longer needed.\n\t * Returns the error code.\n\t */\n\tint error, object_ID, item;\n\tvoid **ptr = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* This is a cardinal sin */\n\tif (object == NULL) return (false);\t/* Null address, quietly skip */\n\tAPI = api_get_api_ptr (V_API);\t\t/* Now we need to get that API pointer to check further */\n\tptr = void3_to_void2 (object);\t\t/* Get the array of pointers */\n\tif ((object_ID = api_get_object_id_from_data_ptr (API, ptr)) == GMT_NOTSET) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find the object in the list */\n\tif ((item = gmtapi_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\t/* Could not find that item */\n\tswitch (API->object[item]->actual_family) {\n\t\tcase GMT_IS_GRID:       error = api_destroy_grids    (API, object, n_items); break;\n\t\tcase GMT_IS_DATASET:    error = api_destroy_datasets (API, object, n_items); break;\n\t\tcase GMT_IS_TEXTSET:    error = api_destroy_textsets (API, object, n_items); break;\n\t\tcase GMT_IS_IMAGE:      error = api_destroy_images   (API, object, n_items); break;\n\t\tcase GMT_IS_PALETTE:    error = api_destroy_palettes (API, object, n_items); break;\n\t\tcase GMT_IS_POSTSCRIPT: error = api_destroy_postscripts      (API, object, n_items); break;\n\t\tcase GMT_IS_MATRIX:     error = api_destroy_matrices (API, object, n_items); break;\n\t\tcase GMT_IS_VECTOR:     error = api_destroy_vectors  (API, object, n_items); break;\n\t\tdefault: return_error (API, GMT_NOT_A_VALID_FAMILY); break;\n\t}\n\treturn_error (API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Group_ (void *object, unsigned int *n_items) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Destroy_Group (GMT_FORTRAN, object, *n_items));\n}\n#endif\n\n/*! . */\nvoid *GMT_Create_Data (void *V_API, unsigned int family, unsigned int geometry, unsigned int mode, uint64_t dim[], double *range, double *inc, unsigned int registration, int pad, void *data) {\n\t/* Create an empty container of the requested kind and allocate space for content.\n\t * The known families are GMT_IS_{DATASET,TEXTSET,GRID,PALETTE,IMAGE,POSTSCRIPT}, but we\n\t * also allow for creation of the containers for GMT_IS_{VECTOR,MATRIX}. Note\n\t * that for VECTOR|MATRIX we don't allocate space to hold data as it is the users\n\t * responsibility to hook their data pointers in.  The VECTOR allocates the array\n\t * of column vector type and data pointers.\n\t * Geometry should reflect the resource, e.g. GMT_IS_SURFACE for grid, etc.\n\t * There are two ways to define the dimensions needed to actually allocate memory:\n\t * (A) Via uint64_t dim[]:\n\t *     The dim array contains up to 4 dimensions for:\n\t *\t   0: dim[GMT_TBL] = number of tables,\n\t *\t   1: dim[GMT_SEG] = number of segments per table\n\t *\t   2: dim[GMT_ROW] = number of rows per segment.\n\t *\t   3: dim[GMT_COL] = number of columns per row [ignored for GMT_TEXTSET].\n\t *     The dim array is ignored for CPTs.\n\t *     For GMT_IS_IMAGE & GMT_IS_MATRIX, par[GMT_Z] = GMT[2] holds the number of bands or layers (dim == NULL means just 1).\n\t *     For GMT_IS_GRID, GMT_IS_IMAGE, & GMT_IS_MATRIX: dim[0] holds the number of columns and dim[1] holds the number\n\t *         of rows; this implies that wesn = 0-<dim-1>, inc = 1, and registration is pixel-registration.\n\t *     For GMT_IS_VECTOR, dim[0] holds the number of columns, optionally dim[1] holds number of rows, if known, or 0.\n\t *\t   dim[2] can hold the data type (GMT_DOUBLE, etc). If dim[1] > 0 then we allocate the rows.\n\t * (B) Via range, inc, registration:\n\t *     Convert user domain range, increments, and registration into dimensions\n\t *     for the container.  For grids and images we fill out the GMT_GRID_HEADER;\n\t *     for vectors and matrices we fill out their internal parameters.\n\t *     For complex grids pass registration + GMT_GRID_IS_COMPLEX_{REAL|IMAG}\n\t *     For GMT_IS_MATRIX and GMT_IS_IMAGE, par[GMT_Z] = holds the number of layers or bands (dim == NULL means just 1).\n\t * pad sets the padding for grids and images, ignored for other resources.\n\t * Some default actions for grids:\n\t * range = NULL: Select current -R setting if present.\n\t * registration = GMT_NOTSET: Gridline unless -r is in effect.\n\t * Give -1 (GMT_NOTSET) to accept GMT default padding [2].\n\t *\n\t * For creating grids and images you can do it in one or two steps:\n \t * (A) Pass mode = GMT_CONTAINER_AND_DATA; this creates both header and allocates grid|image;\n\t * (B) Call GMT_Create_Data twice:\n\t * \t1. First with mode = GMT_CONTAINER_ONLY which creates header only\n\t *\t   and computes the dimensions based on the other arguments.\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which allocates the grid|image array\n\t *\t   based on the dimensions already set.  This time you pass NULL/0\n\t *\t   for dim, wesn, inc, registration, pad but let data be your grid|image\n\t *\t   returned to you after step 1.\n\t *\n\t * By default, the created resource is consider an input resource (direction == GMT_IN).\n\t * However, for the interface containers GMT_VECTOR and GMT_MATRIX they will have their\n\t * direction set to GMT_OUT if the row-dimension is not set.\n\t *\n\t * Return: Pointer to resource, or NULL if an error (set via API->error).\n\t */\n\n\tint error = GMT_OK;\n\tint def_direction = GMT_IN;\t/* Default direction is GMT_IN  */\n\tunsigned int module_input;\n\tuint64_t n_layers = 0, zero_dim[4] = {0, 0, 0, 0}, *this_dim = dim;\n\tbool already_registered = false, has_ID = false;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (mode == GMT_IS_OUTPUT) {\t/* Flagged to be an output container */\n\t\tdef_direction = GMT_OUT;\t/* Set output as default direction*/\n\t\tthis_dim = zero_dim;\t\t/* Provide dimensions set to zero */\n\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data pointer is not NULL */\n\t}\n\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we creating a resource that is a module input? */\n\tfamily -= module_input;\n\n\t/* Below, data can only be non-NULL for Grids or Images passing back G or I to allocate the data array */\n\n\tswitch (family) {\t/* dataset, cpt, text, grid , image, vector, matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid, allocate header but not data array */\n\t\t\tif (mode == GMT_IS_OUTPUT || (mode & GMT_DATA_ONLY) == 0) {\t/* Create new grid unless we only ask for data only */\n\t\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data pointer is not NULL */\n\t \t\t\tif ((new_obj = gmt_create_grid (API->GMT)) == NULL)\n\t \t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, pad);\t/* Change the default pad; give -1 to leave as is */\n\t\t\t\tif ((error = api_init_grid (API, NULL, this_dim, range, inc, registration, mode, def_direction, new_obj)))\n\t\t\t\t\treturn_null (API, error);\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, API->pad);\t/* Reset to the default pad */\n\t\t\t}\n\t\t\telse {\t/* Already registered so has_ID must be false */\n\t\t\t\tif (has_ID || (new_obj = data) == NULL)\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\t/* Error if data pointer is NULL */\n\t\t\t\talready_registered = true;\n\t\t\t}\n\t\t\tif (def_direction == GMT_IN && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Allocate the grid array unless we asked for header only */\n\t\t\t\tif ((error = api_alloc_grid (API->GMT, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tif (mode & GMT_GRID_XY) {\t/* Also allocate and populate the x,y vectors */\n\t\t\t\tif ((error = api_alloc_grid_xy (API, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image, allocate header but not data array */\n\t\t\tif (mode == GMT_IS_OUTPUT || (mode & GMT_DATA_ONLY) == 0) {\t/* Create new image unless we only ask for data only */\n\t\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t \t\t\tif ((new_obj = gmtlib_create_image (API->GMT)) == NULL)\n\t \t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, pad);\t/* Change the default pad; give -1 to leave as is */\n\t\t\t\tif ((error = api_init_image (API, NULL, this_dim, range, inc, registration, mode, def_direction, new_obj)))\n\t\t\t\t\treturn_null (API, error);\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, API->pad);\t/* Reset to the default pad */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((new_obj = data) == NULL)\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\t/* Error if data is NULL */\n\t\t\t\talready_registered = true;\n\t\t\t}\n\t\t\tif (def_direction == GMT_IN && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Allocate the image array unless we asked for header only */\n\t\t\t\tif ((error = api_alloc_image (API->GMT, dim, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tif (mode & GMT_GRID_XY) {\t/* Also allocate and populate the image x,y vectors */\n\t\t\t\tif ((error = api_alloc_image_xy (API, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset, allocate the requested tables, segments, rows, and columns */\n\t\t\tif (this_dim[GMT_TBL] > UINT_MAX || this_dim[GMT_ROW] > UINT_MAX)\n\t\t\t\treturn_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tif ((new_obj = gmtlib_create_dataset (API->GMT, this_dim[GMT_TBL], this_dim[GMT_SEG], this_dim[GMT_ROW], this_dim[GMT_COL], geometry, false)) == NULL)\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\t/* GMT text dataset, allocate the requested tables, segments, and rows */\n\t\t\tif (this_dim[GMT_TBL] > UINT_MAX) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tif ((new_obj = gmtlib_create_textset (API->GMT, this_dim[GMT_TBL], this_dim[GMT_SEG], this_dim[GMT_ROW], false)) == NULL)\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT, allocate one with space for dim[0] color entries */\n\t\t\t/* If dim is NULL then we ask for 0 color entries as direction here is GMT_OUT for return to an external API */\n\t\t \tif ((new_obj = gmtlib_create_palette (API->GMT, this_dim[0])) == NULL)\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* GMT PS struct, allocate one struct */\n\t\t \tif ((new_obj = gmtlib_create_ps (API->GMT, this_dim[0])) == NULL)\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT matrix container, allocate one with the requested number of layers, rows & columns */\n\t\t\tn_layers = (this_dim[GMTAPI_DIM_COL] == 0 && this_dim[GMTAPI_DIM_ROW] == 0) ? 1U : this_dim[GMT_Z];\n\t\t \tnew_obj = gmtlib_create_matrix (API->GMT, n_layers, def_direction);\n\t\t\tif (pad) GMT_Report (API, GMT_MSG_VERBOSE, \"Pad argument (%d) ignored in initialization of %s\\n\", pad, GMT_family[family]);\n\t\t\tif ((API->error = api_init_matrix (API, this_dim, range, inc, registration, mode, def_direction, new_obj))) {\t/* Failure, must free the object */\n\t\t\t\tstruct GMT_MATRIX *M = api_return_address (new_obj, GMT_IS_MATRIX);\t/* Get pointer to resource */\n\t\t\t\tgmtlib_free_matrix (API->GMT, &M, true);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT vector container, allocate one with the requested number of columns & rows */\n\t\t\tif (dim && dim[GMTAPI_DIM_COL] == 0) return_null (API, GMT_N_COLS_NOT_SET);\n\t \t\tnew_obj = gmt_create_vector (API->GMT, this_dim[GMTAPI_DIM_COL], def_direction);\n\t\t\tif (pad) GMT_Report (API, GMT_MSG_VERBOSE, \"Pad argument (%d) ignored in initialization of %s\\n\", pad, GMT_family[family]);\n\t\t\tif ((API->error = api_init_vector (API, this_dim, range, inc, registration, mode, def_direction, new_obj))) {\t/* Failure, must free the object */\n\t\t\t\tstruct GMT_VECTOR *V = api_return_address (new_obj, GMT_IS_VECTOR);\t/* Get pointer to resource */\n\t\t\t\tgmt_free_vector (API->GMT, &V, true);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (API->error) return_null (API, API->error);\t/* Failed to pass the right arguments */\n\n\tif (!already_registered) {\t/* Register this object so it can be deleted by GMT_Destroy_Data or gmtapi_garbage_collection */\n\t\tenum GMT_enum_method method = GMT_IS_REFERENCE;\t/* Since it is a memory object */\n\t\tint item = GMT_NOTSET, object_ID = GMT_NOTSET;\n\t\tif ((object_ID = GMT_Register_IO (API, family|module_input, method, geometry, def_direction, range, new_obj)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\t/* Failure to register */\n\t\tif ((item = gmtapi_validate_id (API, family, object_ID, def_direction, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\n\t\tAPI->object[item]->data = new_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\tAPI->object[item]->actual_family = family;\t/* No distinction between these at this point since usage is unknown */\n\t\tif (def_direction == GMT_OUT) API->object[item]->messenger = true;\t/* We are passing a dummy container that should be destroyed before returning actual data */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully created a new %s container\\n\", GMT_family[family]);\n\t}\n\telse\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully added data array to previously registered %s container\\n\", GMT_family[family]);\n\n\treturn (new_obj);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Create_Data_ (unsigned int *family, unsigned int *geometry, unsigned int *mode, uint64_t *dim, double *range, double *inc, unsigned int *registration, int *pad, void *container) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Create_Data (GMT_FORTRAN, *family, *geometry, *mode, dim, range, inc, *registration, *pad, container));\n}\n#endif\n\n/*! Convenience function to get grid or image node */\nuint64_t GMT_Get_Index (void *V_API, struct GMT_GRID_HEADER *header, int row, int col) {\n\t/* V_API not used but all API functions take V_API so no exceptions! */\n\tgmt_M_unused(V_API);\n\treturn (header->index_function (header, row, col, 0));\n}\n\n#ifdef FORTRAN_API\nuint64_t GMT_Get_Index_ (void *h, int *row, int *col) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Index (GMT_FORTRAN, h, *row, *col));\n}\n#endif\n\n/*! Convenience function to get grid or image node */\nuint64_t GMT_Get_Pixel (void *V_API, struct GMT_GRID_HEADER *header, int row, int col, int layer) {\n\t/* V_API not used but all API functions take V_API so no exceptions! */\n\tgmt_M_unused(V_API);\n\treturn (header->index_function (header, row, col, layer));\n}\n\n#ifdef FORTRAN_API\nuint64_t GMT_Get_Pixel_ (void *h, int *row, int *col, int *layer) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Pixel (GMT_FORTRAN, h, *row, *col, *layer));\n}\n#endif\n\n/*! Specify image memory layout */\nint GMT_Set_Index (void *V_API, struct GMT_GRID_HEADER *header, char *code) {\n\tstruct GMTAPI_CTRL *API = NULL;\n\tenum GMT_enum_family family;\n\tunsigned int mode;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tmode = api_decode_layout (API, code, &family);\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\t/* Default scanline C grid */\n\t\t\t\t\theader->index_function = api_get_index_from_TRS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Same for real component in complex grid */\n\t\t\t\t\theader->index_function = api_get_index_from_TRR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Same for imag component in complex grid */\n\t\t\t\t\theader->index_function = api_get_index_from_TRI;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unrecognized mode for grid layout [%u]\\n\", mode);\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_MODULE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\t/* band-interleaved layout */\n\t\t\t\t\theader->index_function = api_get_index_from_TRB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* pixel-interleaved layout */\n\t\t\t\t\theader->index_function = api_get_index_from_TRP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* line-interleaved layout */\n\t\t\t\t\theader->index_function = api_get_index_from_TRL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unrecognized mode for image layout [%u]\\n\", mode);\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_MODULE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unrecognized family for api_decode_layout [%s]\\n\", code);\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn API->error;\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Index_ (void *h, int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Index (GMT_FORTRAN, h, *mode));\n}\n#endif\n\n/*! . */\ndouble *GMT_Get_Coord (void *V_API, unsigned int family, unsigned int dim, void *container) {\n\t/* Return an array of coordinates for the nodes along the specified dimension.\n\t * For GMT_GRID and GMT_IMAGE, dim is either 0 (GMT_X) or 1 (GMT_Y) while for\n\t * GMT_MATRIX it may be 2 (GMT_Z), provided the matrix has more than 1 layer.\n\t * For GMT_VECTOR that was registered as equidistant it will return coordinates\n\t * along the single dimension.\n\t * Cannot be used on other resources (GMT_DATASET, GMT_TEXTSET, GMT_PALETTE).\n\t */\n\tint object_ID, item;\n\tdouble *coord = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (container == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tswitch (family) {\t/* grid, image, or matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\tif (dim > GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = api_grid_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image */\n\t\t\tif (dim > GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = api_image_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT vector */\n\t\t\tif (dim != GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = api_vector_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT matrix */\n\t\t\tif (dim > GMT_Z) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = api_matrix_coord (API, dim, container);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\t/* We register the coordinate array so that GMT_Destroy_Data can free them later */\n\tif ((object_ID = GMT_Register_IO (V_API, GMT_IS_COORD, GMT_IS_COORD, GMT_IS_NONE, GMT_IN, NULL, coord)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tif ((item = gmtapi_validate_id (API, GMT_IS_COORD, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->data = coord;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully created a new coordinate array for %s\\n\", GMT_family[family]);\n\n\treturn (coord);\n}\n\n#ifdef FORTRAN_API\ndouble *GMT_Get_Coord_ (unsigned int *family, unsigned int *dim, void *container) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Coord (GMT_FORTRAN, *family, *dim, container));\n}\n#endif\n\n/*! . */\nint GMT_Set_Comment (void *V_API, unsigned int family, unsigned int mode, void *arg, void *container) {\n\t/* Set new header comment or grid command|remark to container */\n\n\tint error = GMT_OK;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (container == NULL) return_error (V_API, GMT_ARG_IS_NULL);\n\tif (arg == NULL) return_error (V_API, GMT_ARG_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\n\tswitch (family) {\t/* grid, image, or matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\tapi_grid_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image */\n\t\t\tapi_image_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset */\n\t\t\tapi_dataset_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\t/* GMT textset */\n\t\t\tapi_textset_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT */\n\t\t\tapi_cpt_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t\t/* GMT PS */\n\t\t\tapi_ps_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT Vector [PW: Why do we need these?]*/\n\t\t\tapi_vector_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT Vector */\n\t\t\tapi_matrix_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn_error (API, error);\n}\n\n/* FFT Extension: Functions available to do FFT work within the API */\n\n/*! . */\nunsigned int GMT_FFT_Option (void *V_API, char option, unsigned int dim, const char *string) {\n\t/* For programs that needs to do either 1-D or 2-D FFT work */\n\tunsigned int d1 = dim - 1;\t/* Index into the info text strings below for 1-D (0) and 2-D (1) case */\n\tchar *data_type[2] = {\"table\", \"grid\"}, *dim_name[2] = {\"<n_columns>\", \"<n_columns>/<n_rows>\"}, *trend_type[2] = {\"line\", \"plane\"};\n\tchar *dim_ref[2] = {\"dimension\", \"dimensions\"}, *linear_type[2] = {\"linear\", \"planar\"};\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (dim > 2) return_error (V_API, GMT_DIM_TOO_LARGE);\n\tif (dim == 0) return_error (V_API, GMT_DIM_TOO_SMALL);\n\tif (string && string[0] == ' ') GMT_Report (V_API, GMT_MSG_NORMAL, \"Syntax error -%c option.  Correct syntax:\\n\", option);\n\tif (string)\n\t\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t-%c %s\\n\", option, string);\n\telse\n\t\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t-%c Choose or inquire about suitable %s %s for %u-D FFT, and set modifiers.\\n\", option, data_type[d1], dim_ref[d1], dim);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Setting the FFT %s:\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Na will select %s promising the most accurage results.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nf will force the FFT to use the %s of the %s.\\n\", dim_ref[d1], data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nm will select %s using the least work storage.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nr will select %s promising the most rapid calculation.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Ns will list Singleton's [1967] recommended %s, then exit.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -N%s will do FFT on array size %s (Must be >= %s size).\\n\", dim_name[d1], dim_name[d1], data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     Default chooses %s >= %s %s to optimize speed and accuracy of the FFT.\\n\", dim_ref[d1], data_type[d1], dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for removing a %s trend:\\n\", linear_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +d: Detrend data, i.e., remove best-fitting %s [Default].\\n\", trend_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +a: Only remove mean value.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +h: Only remove mid value, i.e., 0.5 * (max + min).\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +l: Leave data alone.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for extending the %s via symmetries:\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     If FFT %s > %s %s, data are extended via edge point symmetry\\n\", dim_ref[d1], data_type[d1], dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     and tapered to zero.  Several modifiers can be set to change this behavior:\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +e: Extend data via edge point symmetry [Default].\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +m: Extend data via edge mirror symmetry.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +n: Do NOT extend data.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +t<w>: Limit tapering to <w> %% of the extended margins [100].\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     If +n is set then +t instead sets the boundary width of the interior\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     %s margin to be tapered [0].\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for saving modified %s before or after the %u-D FFT is called:\\n\", data_type[d1], dim);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +w[<suffix>] will write the intermediate %s passed to FFT after detrending/extension/tapering.\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       File name will have _<suffix> [tapered] inserted before file extension.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +z[p] will write raw complex spectrum to two separate %s files.\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       File name will have _real/_imag inserted before the file extensions.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       Append p to store polar forms, using _mag/_phase instead.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for messages:\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +v will report all suitable dimensions (except when -Nf is selected).\\n\");\n\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nunsigned int GMT_FFT_Option_ (char *option, unsigned int *dim, const char *string, int *length) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Option (GMT_FORTRAN, *option, *dim, string));\n}\n#endif\n\n/* first 2 cols from table III of Singleton's paper on fft.... */\n#define N_SINGLETON_LIST\t117\nstatic int Singleton_list[N_SINGLETON_LIST] = {\n\t64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,\n\t216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,\n\t486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,\n\t972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,\n\t1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,\n\t2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,\n\t3600,3645,3750,3840,3888,4000,4096,4320,4374,4500,4608,4800,4860,5000};\n\nGMT_LOCAL void fft_Singleton_list (struct GMTAPI_CTRL *API) {\n\tunsigned int k;\n\tchar message[GMT_LEN16] = {\"\"};\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t\\\"Good\\\" numbers for FFT dimensions [Singleton, 1967]:\\n\");\n\tfor (k = 0; k < N_SINGLETON_LIST; k++) {\n\t\tsnprintf (message, GMT_LEN16, \"\\t%d\", Singleton_list[k]);\n\t\tif ((k+1) % 10 == 0 || k == (N_SINGLETON_LIST-1)) strcat (message, \"\\n\");\n\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t}\n}\n\n/*! . */\nvoid *GMT_FFT_Parse (void *V_API, char option, unsigned int dim, const char *args) {\n\t/* Parse the 1-D or 2-D FFT options such as -N in grdfft */\n\tunsigned int n_errors = 0, pos = 0;\n\tchar p[GMT_BUFSIZ] = {\"\"}, *c = NULL;\n\tstruct GMT_FFT_INFO *info = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (args == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tif (dim == 0) return_null (V_API, GMT_DIM_TOO_SMALL);\n\tif (dim > 2) return_null (V_API, GMT_DIM_TOO_LARGE);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tinfo = gmt_M_memory (API->GMT, NULL, 1, struct GMT_FFT_INFO);\n\tinfo->taper_width = -1.0;\t\t\t\t/* Not set yet */\n\tinfo->taper_mode = GMT_FFT_EXTEND_NOT_SET;\t\t/* Not set yet */\n\tinfo->trend_mode = GMT_FFT_REMOVE_NOT_SET;\t\t/* Not set yet */\n\tinfo->info_mode = GMT_FFT_UNSPECIFIED;\t\t\t/* Not set yet */\n\tinfo->suggest = GMT_FFT_N_SUGGEST;\t\t\t\t/* Not yet set */\n\n\tif ((c = strchr (args, '+'))) {\t/* Handle modifiers */\n\t\twhile ((gmt_strtok (c, \"+\", &pos, p))) {\n\t\t\tswitch (p[0]) {\n\t\t\t\t/* Detrending modifiers */\n\t\t\t\tcase 'a':  info->trend_mode = GMT_FFT_REMOVE_MEAN;  break;\n\t\t\t\tcase 'd':  info->trend_mode = GMT_FFT_REMOVE_TREND; break;\n\t\t\t\tcase 'h':  info->trend_mode = GMT_FFT_REMOVE_MID;   break;\n\t\t\t\tcase 'l':  info->trend_mode = GMT_FFT_REMOVE_NOTHING;  break;\n\t\t\t\t/* Taper modifiers */\n\t\t\t\tcase 'e':  info->taper_mode = GMT_FFT_EXTEND_POINT_SYMMETRY; break;\n\t\t\t\tcase 'n':  info->taper_mode = GMT_FFT_EXTEND_NONE; break;\n\t\t\t\tcase 'm':  info->taper_mode = GMT_FFT_EXTEND_MIRROR_SYMMETRY; break;\n\t\t\t\tcase 't':\t/* Set taper width */\n\t\t\t\t\tif ((info->taper_width = atof (&p[1])) < 0.0) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error -%c: Negative taper width given\\n\", option);\n\t\t\t\t\t\tn_errors++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/* i/o modifiers */\n\t\t\t\tcase 'w':\t/* Save FFT input; optionally append file suffix */\n\t\t\t\t\tinfo->save[GMT_IN] = true;\n\t\t\t\t\tif (p[1]) strncpy (info->suffix, &p[1], GMT_LEN64-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':  info->verbose = true; break;\t/* Report FFT suggestions */\n\t\t\t\tcase 'z': \t/* Save FFT output in two files; append p for polar form */\n\t\t\t\t\tinfo->save[GMT_OUT] = true;\n\t\t\t\t\tif (p[1] == 'p') info->polar = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error -%c: Unrecognized modifier +%s.\\n\", option, p);\n\t\t\t\t\tn_errors++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (info->taper_mode == GMT_FFT_EXTEND_NOT_SET)\n\t\tinfo->taper_mode = GMT_FFT_EXTEND_POINT_SYMMETRY;\t/* Default action is edge-point symmetry */\n\tif (info->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\tif (info->taper_width < 0.0) info->taper_width = 0.0;\t/* No tapering unless specified */\n\t}\n\tif (info->taper_width < 0.0)\n\t\tinfo->taper_width = 100.0;\t\t/* Taper over entire margin strip by default */\n\n\tswitch (args[0]) {\n\t\tcase '\\0': info->suggest = GMT_FFT_N_SUGGEST;  break;\t/* Pick dimensions for the \"best\" solution */\n\t\tcase 'a': info->suggest = GMT_FFT_ACCURATE;  break;\t/* Pick dimensions for most accurate solution */\n\t\tcase 'f': info->info_mode = GMT_FFT_FORCE; break;\t/* Default is force actual grid dimensions */\n\t\tcase 'm': info->suggest = GMT_FFT_STORAGE;  break;\t/* Pick dimensions for minimum storage */\n\t\tcase 'q': info->verbose = true; break;\t/* No longer a mode.  Backwards compatibility; see +v instead */\n\t\tcase 'r': info->suggest = GMT_FFT_FAST;  break;\t/* Pick dimensions for most rapid solution */\n\t\tcase 's': info->info_mode = GMT_FFT_LIST;  break;\n\t\tdefault:\n\t\t\tif (dim == 2U) {\t/* 2-D */\n\t\t\t\tpos = sscanf (args, \"%d/%d\", &info->n_columns, &info->n_rows);\n\t\t\t\tif (pos == 1) info->n_rows = info->n_columns;\n\t\t\t}\n\t\t\telse {\t/* 1-D */\n\t\t\t\tpos = sscanf (args, \"%d\", &info->n_columns);\n\t\t\t\tinfo->n_rows = 0;\n\t\t\t}\n\t\t\tif (pos) info->info_mode = GMT_FFT_SET;\n\t}\n\tif (info->suffix[0] == '\\0') strncpy (info->suffix, \"tapered\", GMT_LEN64-1);\t/* Default suffix */\n\tinfo->set = true;\t/* We parsed this option */\n\tif (info->info_mode == GMT_FFT_SET) {\n\t\tif (dim == 2U && (info->n_columns <= 0 || info->n_rows <= 0)) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error -%c: n_columns and/or n_rows are <= 0\\n\", option);\n\t\t\tn_errors++;\n\t\t}\n\t\telse if (dim == 1U && info->n_columns <= 0) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error -%c: n_columns is <= 0\\n\", option);\n\t\t\tn_errors++;\n\t\t}\n\t}\n\tif (info->taper_mode == GMT_FFT_EXTEND_NONE && info->taper_width == 100.0) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error -%c: +n requires +t with width << 100!\\n\", option);\n\t\tn_errors++;\n\t}\n\tif (info->info_mode == GMT_FFT_LIST) {\n\t\tfft_Singleton_list (API);\n\t\tn_errors++;\t/* So parsing fails and stops the program after this listing */\n\t}\n\tif (n_errors) {\n\t\tgmt_M_free (API->GMT, info);\n\t\tinfo = NULL;\n\t}\n\treturn (info);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_FFT_Parse_ (char *option, unsigned int *dim, char *args, int *length) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Parse (GMT_FORTRAN, *option, *dim, args));\n}\n#endif\n\n/*! . */\nGMT_LOCAL struct GMT_FFT_WAVENUMBER * api_fft_init_1d (struct GMTAPI_CTRL *API, struct GMT_DATASET *D, unsigned int mode, void *v_info) {\n\tstruct GMT_FFT_WAVENUMBER *K = NULL;\n\tgmt_M_unused(API); gmt_M_unused(D); gmt_M_unused(mode); gmt_M_unused(v_info);\n\n#if 0\t/* Have not finalized 1-D FFT usage in general; this will probably happen when we add gmtfft [1-D FFT equivalent to grdfft] */\n\tunsigned n_cols = 1;\n\tstruct GMT_FFT_INFO *F = api_get_fftinfo_ptr (v_info);\n\t/* Determine number of columns in [t] x [y] input */\n\tif (mode & GMT_FFT_CROSS_SPEC) n_cols++;\n\tif (Din->n_columns < n_cols) {\n\t\tGMT_report (API, GMT_MSG_NORMAL, \"Error: 2 columns needed but only 1 provided\\n\");\n\t\treturn NULL;\n\t}\n\tcross = (n_cols == 2);\n\tif (mode & GMT_FFT_DELTA) n_cols++;\n\tdelta_t = (mode & GMT_FFT_DELTA) ? F->delta_t : D->table[0]->segment[0]->data[0][1] - D->table[0]->segment[0]->data[0][0];\n\tK->delta_kx = 2.0 * M_PI / (F->n_columns * delta_t);\n\n\tGMT_table_detrend (C, D, F->trend_mode, K->coeff);\t/* Detrend data, if requested */\n\tgmt_table_taper (C, G, F);\t\t\t\t/* Taper data, if requested */\n\tK->dim = 1;\t/* 1-D FFT */\n#endif\n\treturn (K);\n}\n\n/*! . */\nGMT_LOCAL void fft_taper2d (struct GMT_CTRL *GMT, struct GMT_GRID *Grid, struct GMT_FFT_INFO *F) {\n\t/* mode sets if and how tapering will be performed [see GMT_FFT_EXTEND_* constants].\n\t * width is relative width in percent of the margin that will be tapered [100]. */\n\tint il1, ir1, il2, ir2, jb1, jb2, jt1, jt2, im, jm, j, end_i, end_j, min_i, min_j, one;\n\tint i, i_data_start, j_data_start, mx, i_width, j_width, width_percent;\n\tunsigned int ju, start_component = 0, stop_component = 0, component;\n\tuint64_t off;\n\tchar *method[2] = {\"edge-point\", \"mirror\"}, *comp[2] = {\"real\", \"imaginary\"};\n\tfloat *datac = Grid->data, scale, cos_wt;\n\tdouble width;\n\tstruct GMT_GRID_HEADER *h = Grid->header;\t/* For shorthand */\n\n\twidth_percent = irint (F->taper_width);\n\n\tif ((Grid->header->n_columns == F->n_columns && Grid->header->n_rows == F->n_rows) || F->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Data and FFT dimensions are equal - no data extension will take place\\n\");\n\t\t/* But there may still be interior tapering */\n\t\tif (F->taper_mode != GMT_FFT_EXTEND_NONE) {\t/* Nothing to do since no outside pad */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Data and FFT dimensions are equal - no tapering will be performed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE && width_percent == 100) {\t/* No interior taper specified */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"No interior tapering will be performed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (Grid->header->arrangement == GMT_GRID_IS_INTERLEAVED) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Demultiplexing complex grid before tapering can take place.\\n\");\n\t\tgmt_grd_mux_demux (GMT, Grid->header, Grid->data, GMT_GRID_IS_SERIAL);\n\t}\n\n\t/* Note that if nx2 = nx+1 and ny2 = n_rows + 1, then this routine\n\t * will do nothing; thus a single row/column of zeros may be\n\t * added to the bottom/right of the input array and it cannot\n\t * be tapered.  But when (nx2 - nx)%2 == 1 or ditto for y,\n\t * this is zero anyway.  */\n\n\ti_data_start = GMT->current.io.pad[XLO];\t/* Some shorthands for readability */\n\tj_data_start = GMT->current.io.pad[YHI];\n\tmx = h->mx;\n\tone = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : 1;\t/* 0 is the boundary point which we want to taper to 0 for the interior taper */\n\n\tif (width_percent == 0) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Tapering has been disabled via +t0\\n\");\n\t}\n\tif (width_percent == 100 && F->taper_mode == GMT_FFT_EXTEND_NONE) {\t/* Means user set +n but did not specify +t<taper> as 100% is unreasonable for interior */\n\t\twidth_percent = 0;\n\t\twidth = 0.0;\n\t}\n\telse\n\t\twidth = F->taper_width / 100.0;\t/* Was percent, now fraction */\n\n\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) {\t/* No extension, just tapering inside the data grid */\n\t\ti_width = irint (Grid->header->n_columns * width);\t/* Interior columns over which tapering will take place */\n\t\tj_width = irint (Grid->header->n_rows * width);\t/* Extended rows over which tapering will take place */\n\t}\n\telse {\t/* We wish to extend data into the margin pads between FFT grid and data grid */\n\t\ti_width = irint (i_data_start * width);\t/* Extended columns over which tapering will take place */\n\t\tj_width = irint (j_data_start * width);\t/* Extended rows over which tapering will take place */\n\t}\n\tif (i_width == 0 && j_width == 0) one = 1;\t/* So we do nothing further down */\n\n\t/* Determine how many complex components (1 or 2) to taper, and which one(s) */\n\tstart_component = (Grid->header->complex_mode & GMT_GRID_IS_COMPLEX_REAL) ? 0 : 1;\n\tstop_component  = (Grid->header->complex_mode & GMT_GRID_IS_COMPLEX_IMAG) ? 1 : 0;\n\n\tfor (component = start_component; component <= stop_component; component++) {\t/* Loop over 1 or 2 components */\n\t\toff = component * Grid->header->size / 2;\t/* offset to start of this component in grid */\n\n\t\t/* First reflect about xmin and xmax, either point symmetric about edge point OR mirror symmetric */\n\n\t\tif (F->taper_mode != GMT_FFT_EXTEND_NONE) {\n\t\t\tfor (im = 1; im <= i_width; im++) {\n\t\t\t\til1 = -im;\t/* Outside xmin; left of edge 1  */\n\t\t\t\tir1 = im;\t/* Inside xmin; right of edge 1  */\n\t\t\t\til2 = il1 + h->n_columns - 1;\t/* Inside xmax; left of edge 2  */\n\t\t\t\tir2 = ir1 + h->n_columns - 1;\t/* Outside xmax; right of edge 2  */\n\t\t\t\tfor (ju = 0; ju < h->n_rows; ju++) {\n\t\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_POINT_SYMMETRY) {\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,il1)+off] = 2.0f * datac[gmt_M_ijp(h,ju,0)+off]       - datac[gmt_M_ijp(h,ju,ir1)+off];\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,ir2)+off] = 2.0f * datac[gmt_M_ijp(h,ju,h->n_columns-1)+off] - datac[gmt_M_ijp(h,ju,il2)+off];\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Mirroring */\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,il1)+off] = datac[gmt_M_ijp(h,ju,ir1)+off];\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,ir2)+off] = datac[gmt_M_ijp(h,ju,il2)+off];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Next, reflect about ymin and ymax.\n\t\t * At the same time, since x has been reflected,\n\t\t * we can use these vals and taper on y edges */\n\n\t\tscale = (float)(M_PI / (j_width + 1));\t/* Full 2*pi over y taper range */\n\t\tmin_i = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : -i_width;\n\t\tend_i = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? (int)Grid->header->n_columns : mx - i_width;\n\t\tfor (jm = one; jm <= j_width; jm++) {\t/* Loop over width of strip to taper */\n\t\t\tjb1 = -jm;\t/* Outside ymin; bottom side of edge 1  */\n\t\t\tjt1 = jm;\t/* Inside ymin; top side of edge 1  */\n\t\t\tjb2 = jb1 + h->n_rows - 1;\t/* Inside ymax; bottom side of edge 2  */\n\t\t\tjt2 = jt1 + h->n_rows - 1;\t/* Outside ymax; bottom side of edge 2  */\n\t\t\tcos_wt = 0.5f * (1.0f + cosf (jm * scale));\n\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) cos_wt = 1.0f - cos_wt;\t/* Reverse weights for the interior */\n\t\t\tfor (i = min_i; i < end_i; i++) {\n\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_POINT_SYMMETRY) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb1,i)+off] = cos_wt * (2.0f * datac[gmt_M_ijp(h,0,i)+off]       - datac[gmt_M_ijp(h,jt1,i)+off]);\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt2,i)+off] = cos_wt * (2.0f * datac[gmt_M_ijp(h,h->n_rows-1,i)+off] - datac[gmt_M_ijp(h,jb2,i)+off]);\n\t\t\t\t}\n\t\t\t\telse if (F->taper_mode == GMT_FFT_EXTEND_MIRROR_SYMMETRY) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb1,i)+off] = cos_wt * datac[gmt_M_ijp(h,jt1,i)+off];\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt2,i)+off] = cos_wt * datac[gmt_M_ijp(h,jb2,i)+off];\n\t\t\t\t}\n\t\t\t\telse {\t/* Interior tapering only */\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt1,i)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb2,i)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Now, cos taper the x edges */\n\t\tscale = (float)(M_PI / (i_width + 1));\t/* Full 2*pi over x taper range */\n\t\tend_j = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? h->n_rows : h->my - j_data_start;\n\t\tmin_j = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : -j_width;\n\t\tfor (im = one; im <= i_width; im++) {\n\t\t\til1 = -im;\n\t\t\tir1 = im;\n\t\t\til2 = il1 + h->n_columns - 1;\n\t\t\tir2 = ir1 + h->n_columns - 1;\n\t\t\tcos_wt = (float)(0.5f * (1.0f + cosf (im * scale)));\n\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) cos_wt = 1.0f - cos_wt;\t/* Switch to weights for the interior */\n\t\t\tfor (j = min_j; j < end_j; j++) {\n\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,ir1)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,il2)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,il1)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,ir2)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE)\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Grid margin (%s component) tapered to zero over %d %% of data width and height\\n\", comp[component], width_percent);\n\t\telse\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Grid (%s component) extended via %s symmetry at all edges, then tapered to zero over %d %% of extended area\\n\", comp[component], method[F->taper_mode], width_percent);\n\t}\n}\n\n/*! . */\nGMT_LOCAL struct GMT_FFT_WAVENUMBER *api_fft_init_2d (struct GMTAPI_CTRL *API, struct GMT_GRID *G, unsigned int mode, void *v_info) {\n\t/* Initialize grid dimensions for FFT machinery and set up wavenumbers */\n\tunsigned int k, factors[32];\n\tuint64_t node;\n\tsize_t worksize;\n\tbool stop;\n\tdouble tdummy, edummy;\n\tstruct GMT_FFT_SUGGESTION fft_sug[GMT_FFT_N_SUGGEST];\n\tstruct GMT_FFT_INFO *F = NULL, *F_in = api_get_fftinfo_ptr (v_info);\n\tstruct GMT_FFT_WAVENUMBER *K = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tif (G == NULL) return_null (API, GMT_ARG_IS_NULL);\n\tGMT = API->GMT;\n\tK = gmt_M_memory (GMT, NULL, 1, struct GMT_FFT_WAVENUMBER);\n\n\tF = gmt_M_memory (GMT, NULL, 1, struct GMT_FFT_INFO);\n\tif (F_in) {\t/* User specified -N so default settings should take effect */\n\t\tgmt_M_memcpy (F, F_in, 1, struct GMT_FFT_INFO);\n\t\tif (F->K) GMT_Report (API, GMT_MSG_DEBUG, \"Warning: F->K already set; investigate.\\n\");\n\t}\n\tif (!F->set || F->info_mode == GMT_FFT_UNSPECIFIED) {\t/* User is accepting the default values of extend via edge-point symmetry over 100% of margin */\n\t\tF->info_mode = GMT_FFT_EXTEND_POINT_SYMMETRY;\n\t\tF->taper_width = 100.0;\n\t\tif (!F->set) F->suggest = GMT_FFT_N_SUGGEST;\n\t\tF->set = true;\n\t}\n\n\t/* Get dimensions as may be appropriate */\n\tif (F->info_mode == GMT_FFT_SET) {\t/* User specified the n_columns/n_rows dimensions */\n\t\tif (F->n_columns < G->header->n_columns || F->n_rows < G->header->n_rows) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: You specified a FFT n_columns/n_rows smaller than input grid.  Ignored.\\n\");\n\t\t\tF->info_mode = GMT_FFT_EXTEND;\n\t\t}\n\t}\n\n\tif (F->info_mode != GMT_FFT_SET) {\t/* Either adjust, force, inquiery */\n\t\tif (F->info_mode == GMT_FFT_FORCE) {\n\t\t\tF->n_columns = G->header->n_columns;\n\t\t\tF->n_rows = G->header->n_rows;\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Selected FFT dimensions == Grid dimensions.\\n\");\n\t\t}\n\t\telse {\t/* Determine best FFT dimensions */\n\t\t\tunsigned int pick;\n\t\t\tchar *mode[GMT_FFT_N_SUGGEST] = {\"fastest\", \"most accurate\", \"least storage\"};\n\t\t\tgmtlib_suggest_fft_dim (GMT, G->header->n_columns, G->header->n_rows, fft_sug, (gmt_M_is_verbose (GMT, GMT_MSG_VERBOSE) || F->verbose));\n\t\t\tif (F->suggest == GMT_FFT_N_SUGGEST) {\t/* Must choose smallest of accurate and fast */\n\t\t\t\tpick = (fft_sug[GMT_FFT_ACCURATE].totalbytes < fft_sug[GMT_FFT_FAST].totalbytes) ? GMT_FFT_ACCURATE : GMT_FFT_FAST;\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Selected FFT dimensions for the overall best solution (%s).\\n\", mode[pick]);\n\t\t\t}\n\t\t\telse {\t/* Pick the one we selected up front */\n\t\t\t\tpick = F->suggest;\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Selected FFT dimensions for the %s solution.\\n\", mode[pick]);\n\t\t\t}\n\t\t\tF->n_columns = fft_sug[pick].n_columns;\n\t\t\tF->n_rows    = fft_sug[pick].n_rows;\n\t\t}\n\t}\n\n\t/* Because we taper and reflect below we DO NOT want any BCs set since that code expects 2 BC rows/cols */\n\tfor (k = 0; k < 4; k++) G->header->BC[k] = GMT_BC_IS_DATA;\n\n\t/* Get here when F->n_columns and F->n_rows are set to the values we will use.  */\n\n\tgmtfft_fourt_stats (GMT, F->n_columns, F->n_rows, factors, &edummy, &worksize, &tdummy);\n\tGMT_Report (API, GMT_MSG_VERBOSE, \"Grid dimensions (n_rows by n_columns): %d x %d\\tFFT dimensions: %d x %d\\n\", G->header->n_rows, G->header->n_columns, F->n_rows, F->n_columns);\n\n\t/* Put the data in the middle of the padded array */\n\n\tGMT->current.io.pad[XLO] = (F->n_columns - G->header->n_columns) / 2;\t/* zero if n_columns < G->header->n_columns+1  */\n\tGMT->current.io.pad[YHI] = (F->n_rows - G->header->n_rows) / 2;\n\tGMT->current.io.pad[XHI] = F->n_columns - G->header->n_columns - GMT->current.io.pad[XLO];\n\tGMT->current.io.pad[YLO] = F->n_rows - G->header->n_rows - GMT->current.io.pad[YHI];\n\n\t/* Precompute wavenumber increments and initialize the GMT_FFT machinery */\n\n\tK->delta_kx = 2.0 * M_PI / (F->n_columns * G->header->inc[GMT_X]);\n\tK->delta_ky = 2.0 * M_PI / (F->n_rows * G->header->inc[GMT_Y]);\n\tK->nx2 = F->n_columns;\tK->ny2 = F->n_rows;\n\n\tif (gmt_M_is_geographic (GMT, GMT_IN)) {\t/* Give delta_kx, delta_ky units of 2pi/meters via Flat Earth assumtion  */\n\t\tK->delta_kx /= (GMT->current.proj.DIST_M_PR_DEG * cosd (0.5 * (G->header->wesn[YLO] + G->header->wesn[YHI])));\n\t\tK->delta_ky /= GMT->current.proj.DIST_M_PR_DEG;\n\t}\n\n\tgmt_fft_set_wave (GMT, GMT_FFT_K_IS_KR, K);\t/* Initialize for use with radial wavenumbers */\n\n\tF->K = K;\t/* So that F can access information in K later */\n\tK->info = F;\t/* So K can have access to information in F later */\n\n\t/* Read in the data or change pad to match the nx2/ny2 determined */\n\n\tif (G->data) {\t/* User already read the data, check padding and possibly extend it */\n\t\tif (G->header->complex_mode == 0) {\t/* Grid was not read in interleaved, must do so now */\n\t\t\t/* Because of no realloc for aligned memory we must do it the hard way */\n\t\t\tfloat *f = NULL;\n\t\t\tsize_t new_size = 2*G->header->size;\n\t\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"Must double memory and multiplex external grid before we can do FFT!\\n\", G->header->name);\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Extend grid via copy onto larger memory-aligned grid\\n\");\n\t\t\tf = gmt_M_memory_aligned (GMT, NULL, new_size, float);\t/* New, larger grid size */\n\t\t\tgmt_M_memcpy (f, G->data, G->header->size, float);\t/* Copy over previous grid values */\n\t\t\tgmt_M_free_aligned (GMT, G->data);\t\t\t/* Free previous aligned grid memory */\n\t\t\tG->data = f;\t\t\t\t\t\t/* Attach the new, larger aligned memory */\n\t\t\tG->header->complex_mode = GMT_GRID_IS_COMPLEX_REAL;\t/* Flag as complex grid with real components only */\n\t\t\tG->header->size = new_size;\t\t\t\t/* Update the size of complex grid */\n\t\t}\n\t\tif (!(G->header->mx == F->n_columns && G->header->my == F->n_rows)) {\t/* Must re-pad, possibly re-allocate the grid */\n\t\t\tgmt_grd_pad_on (GMT, G, GMT->current.io.pad);\n\t\t}\n\t}\n\telse {\t/* Read the data into a grid of approved dimension */\n\t\tG->header->mx = G->header->n_columns;\tG->header->my = G->header->n_rows;\t/* Undo misleading padding since we have not read the data yet and GMT pad has changed above */\n\t\tif (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | mode, NULL, G->header->name, G) == NULL)\t/* Get data only */\n\t\t\treturn (NULL);\n\t}\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"Read in FFT_Create\");\n#endif\n\t/* Make sure there are no NaNs in the grid - that is a fatal flaw */\n\n\tfor (node = 0, stop = false; !stop && node < G->header->size; node++) stop = gmt_M_is_fnan (G->data[node]);\n\tif (stop) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Input grid %s contain NaNs, cannot do FFT!\\n\", G->header->name);\n\t\treturn (NULL);\n\t}\n\n\tif (F->trend_mode == GMT_FFT_REMOVE_NOT_SET) F->trend_mode = GMT_FFT_REMOVE_NOTHING;\t/* Delayed default */\n\tgmt_grd_detrend (GMT, G, F->trend_mode, K->coeff);\t/* Detrend data, if requested */\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"After detrend\");\n#endif\n\tfft_taper2d (GMT, G, F);\t\t\t\t/* Taper data, if requested */\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"After Taper\");\n#endif\n\tK->dim = 2;\t/* 2-D FFT */\n\treturn (K);\n}\n\n/*! . */\nvoid *GMT_FFT_Create (void *V_API, void *X, unsigned int dim, unsigned int mode, void *v_info) {\n\t/* Initialize 1-D or 2-D FFT machinery and set up wavenumbers */\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (dim == 1) return (api_fft_init_1d (V_API, X, mode, v_info));\n\tif (dim == 2) return (api_fft_init_2d (V_API, X, mode, v_info));\n\tGMT_Report (V_API, GMT_MSG_NORMAL, \"GMT FFT only supports dimensions 1 and 2, not %u\\n\", dim);\n\treturn_null (V_API, (dim == 0) ? GMT_DIM_TOO_SMALL : GMT_DIM_TOO_LARGE);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_FFT_Create_ (void *X, unsigned int *dim, unsigned int *mode, void *v_info) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Create (GMT_FORTRAN, X, *dim, *mode, v_info));\n}\n#endif\n\n/*! . */\nGMT_LOCAL int api_fft_1d (struct GMTAPI_CTRL *API, struct GMT_DATASET *D, int direction, unsigned int mode, struct GMT_FFT_WAVENUMBER *K) {\n\t/* The 1-D FFT operating on DATASET segments */\n\tint status = 0;\n\tuint64_t seg, row, tbl, last = 0, col = 0;\n\tfloat *data = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tgmt_M_unused(K);\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\t/* Not at all finished; will require gmtfft.c to be developed and tested */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\n\t\tfor (seg = 0; seg < D->table[tbl]->n_segments; seg++) {\n\t\t\tS = D->table[tbl]->segment[seg];\n\t\t\tif (S->n_rows > last) {\t/* Extend array */\n\t\t\t\tdata = gmt_M_memory (API->GMT, data, S->n_rows, float);\n\t\t\t\tlast = S->n_rows;\n\t\t\t}\n\t\t\tfor (row = 0; S->n_rows; row++) data[row] = (float)S->data[col][row];\n\t\t\tstatus = GMT_FFT_1D (API, data, S->n_rows, direction, mode);\n\t\t\tfor (row = 0; S->n_rows; row++) S->data[col][row] = data[row];\n\t\t}\n\t}\n\tgmt_M_free (API->GMT, data);\n\treturn (status);\n}\n\nGMT_LOCAL char *fft_file_name_with_suffix (struct GMT_CTRL *GMT, char *name, char *suffix) {\n\tstatic char file[GMT_LEN256] = {\"\"};\n\tuint64_t i, j;\n\tsize_t len;\n\n\tif ((len = strlen (name)) == 0) {\t/* Grids that are being created have no filename yet */\n\t\tsnprintf (file, GMT_LEN256, \"tmpgrid_%s.grd\", suffix);\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Created grid has no name to derive new names from; choose %s\\n\", file);\n\t\treturn (file);\n\t}\n\tfor (i = len; i > 0 && !(name[i] == '/' || name[i] == '\\\\'); i--);\t/* i points to 1st char in name after slash, or 0 if no leading dirs */\n\tif (i) i++;\t/* Move to 1st char after / */\n\tfor (j = len; j > 0 && name[j] != '.'; j--);\t/* j points to period before extension, or it is 0 if no extension */\n\tlen = strlen (&name[i]);\n\tstrncpy (file, &name[i], GMT_LEN256-1);\t\t/* Make a full copy of filename without leading directories */\n\tfor (i = len; i > 0 && file[i] != '.'; i--);\t/* i now points to period before extension in file, or it is 0 if no extension */\n\tif (i) file[i] = '\\0';\t/* Truncate at the extension */\n\t/* Determine length of new filename and make sure it fits */\n\tlen = strlen (file);\n\tif (j) len += strlen (&name[j]);\n\tlen += (1 + strlen(suffix));\n\tif ((GMT_BUFSIZ - len) > 0) {\t/* Have enough space */\n\t\tstrcat (file, \"_\");\n\t\tstrcat (file, suffix);\n\t\tif (j) strcat (file, &name[j]);\n#if 0\n\t\tstrcat (file, \"=bf\"); /* Make native for debugging */\n#endif\n\t}\n\telse\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"File name [ %s] way too long - trouble in fft_file_name_with_suffix\\n\", file);\n\treturn (file);\n}\n\nGMT_LOCAL void fft_grd_save_taper (struct GMT_CTRL *GMT, struct GMT_GRID *Grid, char *suffix) {\n\t/* Write the intermediate grid that will be passed to the FFT to file.\n\t * This grid may have been a mean, mid-value, or plane removed, may\n\t * have data filled into an extended margin, and may have been taperer.\n\t * Normally, the complex grid will be in serial layout, but just in case\n\t * we check and add a demux step if required.  The FFT will also check\n\t * and multiplex the grid (again) if needed.\n\t */\n\tunsigned int pad[4];\n\tstruct GMT_GRID_HEADER save;\n\tchar *file = NULL;\n\n\tif (Grid->header->arrangement == GMT_GRID_IS_INTERLEAVED) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Demultiplexing complex grid before saving can take place.\\n\");\n\t\tgmt_grd_mux_demux (GMT, Grid->header, Grid->data, GMT_GRID_IS_SERIAL);\n\t}\n\tgmt_M_memcpy (&save, Grid->header, 1U, struct GMT_GRID_HEADER);\t/* Save what we have before messing around */\n\tgmt_M_memcpy (pad, Grid->header->pad, 4U, unsigned int);\t\t/* Save current pad, then set pad to zero */\n\t/* Extend w/e/s/n to what it would be if the pad was not present */\n\tGrid->header->wesn[XLO] -= Grid->header->pad[XLO] * Grid->header->inc[GMT_X];\n\tGrid->header->wesn[XHI] += Grid->header->pad[XHI] * Grid->header->inc[GMT_X];\n\tGrid->header->wesn[YLO] -= Grid->header->pad[YLO] * Grid->header->inc[GMT_Y];\n\tGrid->header->wesn[YHI] += Grid->header->pad[YHI] * Grid->header->inc[GMT_Y];\n\tgmt_M_memset (Grid->header->pad,   4U, unsigned int);\t/* Set header pad to {0,0,0,0} */\n\tgmt_M_memset (GMT->current.io.pad, 4U, unsigned int);\t/* set GMT default pad to {0,0,0,0} */\n\tgmt_set_grddim (GMT, Grid->header);\t/* Recompute all dimensions */\n\tif ((file = fft_file_name_with_suffix (GMT, Grid->header->name, suffix)) == NULL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unable to get file name for file %s\\n\", Grid->header->name);\n\t\treturn;\n\t}\n\n\tif (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | GMT_GRID_IS_COMPLEX_REAL, NULL, file, Grid) != GMT_OK)\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Intermediate detrended, extended, and tapered grid could not be written to %s\\n\", file);\n\telse\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Intermediate detrended, extended, and tapered grid written to %s\\n\", file);\n\n\tgmt_M_memcpy (Grid->header, &save, 1U, struct GMT_GRID_HEADER);\t/* Restore original, including the original pad */\n\tgmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);\t/* Restore GMT default pad */\n}\n\nGMT_LOCAL void fft_grd_save_fft (struct GMT_CTRL *GMT, struct GMT_GRID *G, struct GMT_FFT_INFO *F) {\n\t/* Save the raw spectrum as two files (real,imag) or (mag,phase), depending on mode.\n\t * We must first do an \"fftshift\" operation as in Matlab, to put the 0 frequency\n\t * value in the center of the grid. */\n\tuint64_t i_ij, o_ij,  offset;\n\tint row_in, col_in, row_out, col_out, nx_2, ny_2;\n\tsize_t len;\n\tunsigned int k, pad[4], mode, wmode[2] = {GMT_GRID_IS_COMPLEX_REAL, GMT_GRID_IS_COMPLEX_IMAG};\n\tdouble wesn[4], inc[2];\n\tfloat re, im, i_scale;\n\tchar *file = NULL, *suffix[2][2] = {{\"real\", \"imag\"}, {\"mag\", \"phase\"}};\n\tstruct GMT_GRID *Out = NULL;\n\tstruct GMT_FFT_WAVENUMBER *K = F->K;\n\n\tif (K == NULL) return;\n\n\tmode = (F->polar) ? 1 : 0;\n\n\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Write components of complex raw spectrum with file suffix %s and %s\\n\", suffix[mode][0], suffix[mode][1]);\n\n\tif (G->header->arrangement == GMT_GRID_IS_SERIAL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Cannot save complex grid unless it is interleaved.\\n\");\n\t\treturn;\n\t}\n\t/* Prepare wavenumber domain limits and increments */\n\tnx_2 = K->nx2 / 2;\tny_2 = K->ny2 / 2;\n\twesn[XLO] = -K->delta_kx * nx_2;\twesn[XHI] =  K->delta_kx * (nx_2 - 1);\n\twesn[YLO] = -K->delta_ky * (ny_2 - 1);\twesn[YHI] =  K->delta_ky * ny_2;\n\tinc[GMT_X] = K->delta_kx;\t\tinc[GMT_Y] = K->delta_ky;\n\tgmt_M_memcpy (pad, GMT->current.io.pad, 4U, unsigned int);\t/* Save current GMT pad */\n\tfor (k = 0; k < 4; k++) GMT->current.io.pad[k] = 0;\t\t/* No pad is what we need for this application */\n\n\t/* Set up and allocate the temporary grid which is always gridline registered. */\n\tif ((Out = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_GRID_IS_COMPLEX_MASK, NULL, wesn, inc, \\\n\t\tGMT_GRID_NODE_REG, 0, NULL)) == NULL) {\t/* Note: 0 for pad since no BC work needed for this temporary grid */\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unable to create complex output grid for %s\\n\", G->header->name);\n\t\treturn;\n\t}\n\n\tstrcpy (Out->header->x_units, \"xunit^(-1)\");\tstrcpy (Out->header->y_units, \"yunit^(-1)\");\n\tstrcpy (Out->header->z_units, G->header->z_units);\n\tstrcpy (Out->header->remark, \"Applied fftshift: kx,ky = (0,0) now at (n_columns/2 + 1,n_rows/2\");\n\n\toffset = Out->header->size / 2;\n\ti_scale = (float)(1.0  / Out->header->nm);\n\tfor (row_in = 0; row_in < K->ny2; row_in++) {\n\t\trow_out = (row_in + ny_2) % K->ny2;\n\t\tfor (col_in = 0; col_in < K->nx2; col_in++) {\n\t\t\tcol_out = (col_in + nx_2) % K->nx2;\n\t\t\to_ij = gmt_M_ij0 (Out->header, row_out, col_out);\n\t\t\ti_ij = 2 * gmt_M_ij0 (G->header,   row_in,  col_in);\n\t\t\tre = G->data[i_ij] * i_scale; im = G->data[i_ij+1] * i_scale;\n\t\t\tif (F->polar) {\t/* Want magnitude and phase */\n\t\t\t\tOut->data[o_ij]   = (float)hypot (re, im);\n\t\t\t\tOut->data[o_ij+offset] = (float)d_atan2 (im, re);\n\t\t\t}\n\t\t\telse {\t\t/* Retain real and imag components as is */\n\t\t\t\tOut->data[o_ij] = re;\tOut->data[o_ij+offset] = im;\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k < 2; k++) {\t/* Write the two grids */\n\t\tif ((file = fft_file_name_with_suffix (GMT, G->header->name, suffix[mode][k])) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Unable to get file name for file %s\\n\", G->header->name);\n\t\t\treturn;\n\t\t}\n\t\tOut->header->complex_mode = wmode[k];\n\t\tfor (len = strlen (G->header->name); len > 0 && !(G->header->name[len-1] == '/' || G->header->name[len-1] == '\\\\'); len--);\t/* Find start of file name minus any leading directories */\n\t\tsnprintf (Out->header->title, GMT_GRID_TITLE_LEN80, \"The %s part of FFT transformed grid %s\", suffix[mode][k], &G->header->name[len]);\n\t\tif (k == 1 && mode) strcpy (Out->header->z_units, \"radians\");\n\t\tif (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | wmode[k], NULL, file, Out) != GMT_OK) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"%s could not be written\\n\", file);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (GMT_Destroy_Data (GMT->parent, &Out) != GMT_OK) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Error freeing temporary grid\\n\");\n\t}\n\n\tgmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);\t/* Restore GMT pad */\n}\n\nGMT_LOCAL void fft_save2d (struct GMT_CTRL *GMT, struct GMT_GRID *G, unsigned int direction, struct GMT_FFT_WAVENUMBER *K) {\n\t/* Handle the writing of the grid going into the FFT and comping out of the FFT, per F settings */\n\n\tif (G == NULL || (K == NULL ||  K->info == NULL)) return;\n\tif (direction == GMT_IN  && K->info->save[GMT_IN])  fft_grd_save_taper (GMT, G, K->info->suffix);\n\tif (direction == GMT_OUT && K->info->save[GMT_OUT]) fft_grd_save_fft (GMT, G, K->info);\n}\n\n/*! . */\nGMT_LOCAL int api_fft_2d (struct GMTAPI_CTRL *API, struct GMT_GRID *G, int direction, unsigned int mode, struct GMT_FFT_WAVENUMBER *K) {\n\t/* The 2-D FFT operating on GMT_GRID arrays */\n\tint status;\n\tif (K && direction == GMT_FFT_FWD) fft_save2d (API->GMT, G, GMT_IN, K);\t/* Save intermediate grid, if requested, before interleaving */\n\tgmt_grd_mux_demux (API->GMT, G->header, G->data, GMT_GRID_IS_INTERLEAVED);\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, true, \"After demux\");\n#endif\n\tstatus = GMT_FFT_2D (API, G->data, G->header->mx, G->header->my, direction, mode);\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, true, \"After FFT\");\n#endif\n\tif (K && direction == GMT_FFT_FWD) fft_save2d (API->GMT, G, GMT_OUT, K);\t/* Save complex grid, if requested */\n\treturn (status);\n}\n\n/*! . */\nint GMT_FFT (void *V_API, void *X, int direction, unsigned int mode, void *v_K) {\n\t/* The 1-D or 2-D FFT operating on GMT_DATASET or GMT_GRID arrays */\n\tstruct GMT_FFT_WAVENUMBER *K = api_get_fftwave_ptr (v_K);\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (K->dim == 2) return (api_fft_2d (V_API, X, direction, mode, K));\n\telse return (api_fft_1d (V_API, X, direction, mode, K));\n}\n\n#ifdef FORTRAN_API\nint GMT_FFT_ (void *X, int *direction, unsigned int *mode, void *v_K) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT (GMT_FORTRAN, X, *direction, *mode, v_K));\n}\n#endif\n\n/*! . */\nint GMT_FFT_Destroy (void *V_API, void *v_info) {\n\t/* Perform any final duties, perhaps report.  For now just free */\n\tstruct GMT_FFT_WAVENUMBER **K = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tK = api_get_fftwave_addr (v_info);\n\tgmt_M_free (API->GMT, (*K)->info);\n\tgmt_M_free (API->GMT, (*K));\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_FFT_Destroy_ (void *v_K) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Destroy (GMT_FORTRAN, v_K));\n}\n#endif\n\n/*! Pretty print core module names and purposes */\nvoid gmt_show_name_and_purpose (void *API, const char *component, const char *name, const char *purpose) {\n\tchar message[GMT_LEN256] = {\"\"};\n\tconst char *lib = NULL;\n\tstatic char *core = \"core\";\n\tassert (name != NULL);\n\tassert (purpose != NULL);\n\tlib = (component) ? component : core;\n\tsnprintf (message, GMT_LEN256, \"%s(%s) %s - %s\\n\\n\", name, lib, GMT_version(), purpose);\n\tGMT_Message (API, GMT_TIME_NONE, message);\n}\n\n/* Module Extension: Allow listing and calling modules by name */\n\n/*! . */\nGMT_LOCAL void *api_get_shared_module_func (struct GMTAPI_CTRL *API, const char *module, unsigned int lib_no) {\n\t/* Function that returns a pointer to the function named module in specified shared library lib_no, or NULL if not found  */\n\tvoid *p_func = NULL;       /* function pointer */\n\tif (API->lib[lib_no].skip) return (NULL);\t/* Tried to open this shared library before and it was not available */\n\tif (API->lib[lib_no].handle == NULL && (API->lib[lib_no].handle = dlopen (API->lib[lib_no].path, RTLD_LAZY)) == NULL) {\t/* Not opened this shared library yet */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open GMT shared %s library: %s\\n\", API->lib[lib_no].name, dlerror());\n\t\tAPI->lib[lib_no].skip = true;\t/* Not bother the next time... */\n\t\treturn (NULL);\t\t\t/* ...and obviously no function would be found */\n\t}\n\t/* Here the library handle is available; try to get pointer to specified module */\n\t*(void **) (&p_func) = dlsym (API->lib[lib_no].handle, module);\n\treturn (p_func);\n}\n\n#ifndef BUILD_SHARED_LIBS\nEXTERN_MSC void *gmt_core_module_lookup (struct GMTAPI_CTRL *API, const char *candidate);\n#endif\n\n/*! . */\nGMT_LOCAL void *api_get_module_func (struct GMTAPI_CTRL *API, const char *module, unsigned int lib_no) {\n#ifndef BUILD_SHARED_LIBS\n\tif (lib_no == 0)\t/* Get core module */\n\t\treturn (gmt_core_module_lookup (API, module));\n\t/* Else we get custom module below */\n#endif\n\treturn (api_get_shared_module_func (API, module, lib_no));\n}\n\n/*! . */\nint GMT_Call_Module (void *V_API, const char *module, int mode, void *args) {\n\t/* Call the specified shared module and pass it the mode and args.\n \t * mode can be one of the following:\n\t * GMT_MODULE_LIST [-4]:\tAs GMT_MODULE_PURPOSE, but only lists the modules.\n\t * GMT_MODULE_EXIST [-3]:\tReturn GMT_NOERROR (0) if module exists, GMT_NOT_A_VALID_MODULE otherwise.\n\t * GMT_MODULE_PURPOSE [-2]:\tAs GMT_MODULE_EXIST, but also print the module purpose.\n\t * GMT_MODULE_OPT [-1]:\t\tArgs is a linked list of option structures.\n\t * GMT_MODULE_CMD [0]:\t\tArgs is a single textstring with multiple options\n\t * mode > 0:\t\t\t\tArgs is an array of text strings (e.g., argv[]).\n\t */\n\tint status = GMT_NOERROR;\n\tunsigned int lib;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar gmt_module[GMT_LEN32] = \"GMT_\";\n\tint (*p_func)(void*, int, void*) = NULL;       /* function pointer */\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (module == NULL && !(mode == GMT_MODULE_LIST || mode == GMT_MODULE_PURPOSE))\n\t\treturn_error (V_API, GMT_ARG_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (module == NULL) {\t/* Did not specify any specific module, so list purpose of all modules in all shared libs */\n\t\tchar gmt_module[GMT_LEN256] = {\"\"};\t/* To form name of gmt_<lib>_module_show|list_all function */\n\t\tchar *listfunc = (mode == GMT_MODULE_LIST) ? \"list\" : \"show\";\n\t\tvoid (*l_func)(void*);       /* function pointer to gmt_<lib>_module_show|list_all which takes one arg (the API) */\n\n\t\t/* Here we list purpose of all the available modules in each shared library */\n\t\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\n\t\t\tsnprintf (gmt_module, GMT_LEN32, \"gmt_%s_module_%s_all\", API->lib[lib].name, listfunc);\n\t\t\t*(void **) (&l_func) = api_get_module_func (API, gmt_module, lib);\n\t\t\tif (l_func == NULL) continue;\t/* Not found in this shared library */\n\t\t\t(*l_func) (V_API);\t/* Run this function */\n\t\t}\n\t\treturn (status);\n\t}\n\n\t/* Here we call a named module */\n\n\tstrncat (gmt_module, module, GMT_LEN32-5);\t\t/* Concatenate GMT_-prefix and module name to get function name */\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for gmt_module in any of the shared libs */\n\t\t*(void **) (&p_func) = api_get_module_func (API, gmt_module, lib);\n\t\tif (p_func) break;\t/* Found it in this shared library */\n\t}\n\tif (p_func == NULL) {\t/* Not in any of the shared libraries */\n\t\tstatus = GMT_NOT_A_VALID_MODULE;\n\t\tif (strncasecmp (module, \"gmt\", 3)) {\t/* For any module not already starting with \"gmt...\" */\n\t\t\tchar gmt_module[32] = \"gmt\";\n\t\t\tstrncat (gmt_module, module, 28);\t/* Prepend \"gmt\" to module and try again */\n\t\t\tstatus = GMT_Call_Module (V_API, gmt_module, mode, args);\t/* Recursive call to try with the 'gmt' prefix */\n\t\t}\n\t}\n\telse if (mode == GMT_MODULE_EXIST)\t/* Just wanted to know it is there */\n\t\treturn (GMT_NOERROR);\n\telse\t/* Call the function and pass back its return value */\n\t\tstatus = (*p_func) (V_API, mode, args);\n\treturn (status);\n}\n\n#ifdef FORTRAN_API\nint GMT_Call_Module_ (const char *module, int *mode, void *args, int *length) {\n\treturn (GMT_Call_Module (GMT_FORTRAN, module, *mode, args));\n}\n#endif\n\n/*! . */\nGMT_LOCAL const char * gmt_get_shared_module_info (struct GMTAPI_CTRL *API, char *module, unsigned int lib_no) {\n\t/* Function that returns a pointer to the module keys in specified shared library lib_no, or NULL if not found  */\n\t/* DO not rename this function */\n\tchar function[GMT_LEN64] = {\"\"};\n\tconst char *keys = NULL;       /* char pointer to module keys */\n\tconst char * (*func)(void*, char*) = NULL;       /* function pointer */\n\tif (API->lib[lib_no].skip) return (NULL);\t/* Tried to open this shared library before and it was not available */\n\tif (API->lib[lib_no].handle == NULL && (API->lib[lib_no].handle = dlopen (API->lib[lib_no].path, RTLD_LAZY)) == NULL) {\t/* Not opened this shared library yet */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open GMT shared %s library: %s\\n\", API->lib[lib_no].name, dlerror());\n\t\tAPI->lib[lib_no].skip = true;\t/* Not bother the next time... */\n\t\treturn (NULL);\t\t\t/* ...and obviously no keys would be found */\n\t}\n\tsnprintf (function, GMT_LEN64, \"gmt_%s_module_info\", API->lib[lib_no].name);\n\t/* Here the library handle is available; try to get pointer to specified module */\n\t*(void **) (&func) = dlsym (API->lib[lib_no].handle, function);\n\tif (func) keys = (*func) (API, module);\n\treturn (keys);\n}\n\n/*! . */\nGMT_LOCAL const char * gmt_get_module_info (struct GMTAPI_CTRL *API, char *module, unsigned int lib_no) {\n\t/* DO not rename this function */\n\tif (lib_no == 0)\t/* Get core module */\n\t\treturn (gmt_core_module_info (API, module));\n\t/* Else we get custom module below */\n\treturn (gmt_get_shared_module_info (API, module, lib_no));\n}\n\n/*! . */\nGMT_LOCAL const char * api_get_moduleinfo (void *V_API, char *module) {\n\t/* Call the specified shared module and retrieve the API developer options keys.\n \t * This function, while in the API, is only for API developers and thus has a\n\t * \"undocumented\" status in the API documentation.\n\t */\n\tunsigned int lib;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar gmt_module[GMT_LEN32] = \"gmt\";\n\tconst char *keys = NULL;\n\n\tif (V_API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for module in any of the shared libs */\n\t\tkeys = gmt_get_module_info (API, module, lib);\n\t\tif (keys) return (keys);\t/* Found it in this shared library, return the keys */\n\t}\n\t/* If we get here we did not found it.  Try to prefix module with gmt */\n\tstrncat (gmt_module, module, GMT_LEN32-4);\t\t/* Concatenate gmt and module name to get function name */\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for gmt_module in any of the shared libs */\n\t\tkeys = gmt_get_module_info (API, gmt_module, lib);\n\t\tif (keys) {\t/* Found it in this shared library, adjust module name and return the keys */\n\t\t\tstrncpy(module, gmt_module, strlen(gmt_module));\t/* Rewrite module name to contain prefix of gmt */\n\t\t\treturn (keys);\n\t\t}\n\t}\n\t/* Not in any of the shared libraries */\n\tGMT_Report (API, GMT_MSG_VERBOSE, \"Shared GMT module not found: %s \\n\", module);\n\treturn_null (V_API, GMT_NOT_A_VALID_MODULE);\n}\n\nGMT_LOCAL int api_extract_argument (char *optarg, char *argument, char **key, int k, bool colon, int *n_pre) {\n\t/* Two separate actions:\n\t * 1) If key ends with \"=\" then we pull out the option argument after stripping off +<stuff>.\n\t * 2) If key ends with \"=q\" then we see if +q is given and return pos to this modifiers argument.\n\t * 3) Else we just copy input to output.\n\t * We also set n_pre which is the number of characters to skip after the -X option\n\t *   before looking for an argument.\n\t * If colon is true we also strip argument from the first colon onwards.\n\t * If this all sounds messy it is because the GMT command-line syntax of some modules are\n\t *   messy and predate the whole API business...\n\t */\n\tchar *c = NULL;\n\tunsigned int pos = 0;\n\t*n_pre = 0;\n\tif (k >= 0 && key[k][K_EQUAL] == '=') {\t/* Special handling */\n\t\t*n_pre = (key[k][K_MODIFIER] && isdigit (key[k][K_MODIFIER])) ? (int)(key[k][K_MODIFIER]-'0') : 0;\n\t\tif ((*n_pre || key[k][K_MODIFIER] == 0) && (c = strchr (optarg, '+'))) {\t/* Strip off trailing +<modifiers> */\n\t\t\tc[0] = 0;\n\t\t\tstrcpy (argument, optarg);\n\t\t\tc[0] = '+';\n\t\t}\n\t\telse if (key[k][K_MODIFIER]) {\t/* Look for +<mod> */\n\t\t\tchar code[3] = {\"+?\"};\n\t\t\tcode[1] = key[k][K_MODIFIER];\n\t\t\tif ((c = strstr (optarg, code))) {\t/* Found +<modifier> */\n\t\t\t\tstrcpy (argument, optarg);\n\t\t\t\tpos = (unsigned int) (c - optarg + 2);\t/* Position of this modifiers argument */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrcpy (argument, optarg);\n\t\t}\n\t\telse\n\t\t\tstrcpy (argument, optarg);\n\t}\n\telse\n\t\tstrcpy (argument, optarg);\n\tif (colon && (c = strchr (argument, ':')))\t/* Also chop of :<more arguments> */\n\t\tc[0] = '\\0';\n\n\treturn pos;\n}\n\n#define api_is_required_IO(key) (key == API_PRIMARY_INPUT || key == API_PRIMARY_OUTPUT)\t\t\t/* Returns true if this is a primary input or output item */\n#define api_not_required_io(key) ((key == API_PRIMARY_INPUT || key == API_SECONDARY_INPUT) ? API_SECONDARY_INPUT : API_SECONDARY_OUTPUT)\t/* Returns the optional input or output flag */\n\n/*! . */\nstruct GMT_RESOURCE *GMT_Encode_Options (void *V_API, const char *module_name, int n_in, struct GMT_OPTION **head, unsigned int *n) {\n\t/* This function determines which input sources and output destinations are required given the module options.\n\t * It is only used to assist developers of external APIs, such as the MATLAB, Julia, Python, R, and others.\n\t * \"Keys\" referred to below is the unique combination given near the top of every module via the macro\n\t * THIS_MODULE_KEYS.  For instance, here are the keys for grdtrack:\n\t *\n\t * #define THIS_MODULE_KEYS        \"<D{,DD),GG(,>D}\"\n\t *\n\t * Here are the GMT_Encode_Options arguments:\n\t *   API\tControls all things within GMT.\n\t *   module\tName of the GMT module.\n\t *   n_in\tKnown number of objects given as input resources (-1 if not known).\n\t *   head\tLinked list of GMT options passed for this module. We may hook on 1-2 additional options.\n\t *   *n\t\tNumber of structures returned by the function. Struct GMT_RESOURCE is defined in gmt.h\n\t *\n\t * We also return an array of structures with information about registered resources going to/from GMT.\n\t * Basically, given the module we look up the keys for that module, which tells us which options provide\n\t * the input and output selections and which ones are required and which ones are optional.  We then\n\t * scan the given options and if file arguments to the options listed in the keys are missing we are\n\t * to insert ? as the filename. Some options may already have the question mark. After scanning\n\t * the options we examine the keys for any required input or output argument that have yet to be specified\n\t * explicitly. If so we create the missing options, with filename = ?, and append them to the end of\n\t * the option list (head). The API developers can then use this array of encoded options in concert with\n\t * the information passed back via the structure list to attach actual resources.\n\t *\n\t * For each option that may take a file we need to know what kind of file and if it is input or output.\n\t * We encode this information in a 3-character word XYZ, explained below.  Note that each module may\n\t * need several comma-separated XYZ words and these are returned as one string via GMT_Get_Moduleinfo.\n\t * The X, Y, and Z letter position represent different information, as discussed below:\n\t *\n\t * X stands for the specific program OPTION (e.g., L for -L, F for -F). For tables or grids read from files or\n\t * tables processed via standard input we use '<', while '>' is used for standard (table) output.\n\t * Y stands for data TYPE (C = CPT, D = Dataset/Point, L = Dataset/Line, P = Dataset/Polygon,\n\t *    G = Grid, I = Image, T = Textset, X = PostScript, ? = type specified via a module option [more later]),\n\t *    while a hyphen (-) means there is NO data when this option is set (see Z for whether this is for in- or output).\n\t * Z stands for PRIMARY inputs '{', primary output '}' OR SECONDARY input '(', or secondary output ')'.\n\t *   Primary inputs and outputs MUST be assigned, and if not explicitly given will result in\n\t *   a syntax error. However, external APIs (mex, Python) can override this and supply the missing items\n\t *   via any given left- and right-hand side arguments to supply inputs or accept outputs.\n\t *   Secondary inputs means they are only assigned if an option is actually given.  If the in|out designation\n\t *   is irrelevant for an option we use '-'.\n\t *\n\t * There are a few special cases where X, Y, or Z take on \"magic\" behavior:\n\t *\n\t *   A few modules with have X = - (hyphen). This means the primary input or output (determined by Z)\n\t *   has a data type that is not known until runtime.  A module option will tells us which type it is, and this\n\t *   option is encoded in Y.  So a -Y<type> option is _required_ and that is how we can update the primary\n\t *   data type.  Example: gmtread can read any GMT object but requires -T<type>.  It thus has the keys\n\t *   \"<?{,>?},-T-\".  Hence, we examine -T<type> and replace ? with the dataset implied by <type> both for input\n\t *   AND output (since Z was indeterminate).  Use i|o if only input or output should have this treatment.\n\t *\n\t *   A few modules will have Y = - which is another magic key: If the -X option is given then either the input\n\t *   or output (depending on what Z is) will NOT be required. As an example of this behavior, consider psxy\n\t *   which has a -T option that means \"read no input, just write trailer\". So the key \"T-(\" in psxy means that\n\t *   when -T is used then NO input is required.  This means the primary input key \"<D{\" is changed to \"<D(\" (secondary)\n\t *   and no attempt is made to connect external input to the psxy input.  If Z is none of () then we expect Z to\n\t *   be one of the options with required input (or output) and we change that option to option input (or output).\n\t *   Example: grdtrack has two required inputs (the grid(s) and the track/point file.  However, if -E is set then\n\t *   the track/point file is not expected so we need to change it to secondary.  We thus add E-< which then will\n\t *   change <D{ to <D(.  A modifier is also possible.  For instance -F<grid>[+d] is used by several modules, such\n\t *   as triangulate, to use the non-NaN nodes in a grid as the input data instead of reading the primary input\n\t *   source.  So F-( would turn of primary input.  However, if +d is present then we want to combine the grid with\n\t *   the primary input and hence we read that as well.\n\t *\n\t *   A few modules will specify Z as some letter not in {|(|}|)|-, which means that normally these modules\n\t *   will expect/produce whatever input/output is specified by the primary setting, but if the \"-Z\" option is given the primary\n\t *   input/output will be changed to the given type Y.  Also, modifiers may be involved. The full syntax for this is\n\t *   XYZ+abc...-def...: We do the substitution of output type to Y only if\n\t *      1. -Z is given\n\t *      2. -Z contains ALL the modifiers +a, +b, +c, ...\n\t *      3. -Z contains AT LEAST ONE of the modifers +d, +e, +f.\n\t *   The Z magic is a bit confusing so here are several examples:\n\t *   1. pscoast normally writes PostScript but pscoast -M will instead export data to stdout, so its keys\n\t *      contain the entry \">DM\", which means that when -M is active then PostScript key \">X}\" morphs into \">D}\" and\n\t *      thus allows for data set export instead.\n\t *   2. grdinfo normally writes a textset (key \">T}\") but with -C it should write a dataset.  It has the magic\n\t *      key \">DC\": If the -C option is given then the \">T}\" is morphed to \">D}\".\n\t *   3. grdcontour normally writes PostScript but grdcontour -D will instead export data to a file set by -D, so its key\n\t *      contains the entry \"DDD\": When -D is active then the PostScript key \">X}\" morphs into \"DD}\" and\n\t *      thus allows for a data set export instead.\n\t *   4. gmtspatial : New key \">TN+r\" means if -N[...]+r is given then set >T}.  Just giving -N without the given\n\t *      modifier +r will not trigger the change.\n\t *   5. pscoast \">TE+w-rR\" means if -E given with modifier +w and one of +r or +R are then set to >T}.\n\t *\n\t *   After processing, all magic key sequences are set to \"---\" to render them inactive.\n\t *\n\t */\n\n\tunsigned int n_keys, direction = 0, kind, pos = 0, n_items = 0, ku, n_out = 0, nn[2][2];\n\tunsigned int output_pos = 0, input_pos = 0, mod_pos;\n\tint family = GMT_NOTSET;\t/* -1, or one of GMT_IS_DATASET, GMT_IS_TEXTSET, GMT_IS_GRID, GMT_IS_PALETTE, GMT_IS_IMAGE */\n\tint geometry = GMT_NOTSET;\t/* -1, or one of GMT_IS_NONE, GMT_IS_POINT, GMT_IS_LINE, GMT_IS_POLY, GMT_IS_SURFACE */\n\tint sdir, k, n_in_added = 0, n_to_add, e, n_pre_arg, n_per_family[GMT_N_FAMILIES];\n\tbool deactivate_output = false, strip_colon = false, strip = false;\n\tsize_t n_alloc, len;\n\tconst char *keys = NULL;\t/* This module's option keys */\n\tchar **key = NULL;\t\t/* Array of items in keys */\n\tchar *text = NULL, *LR[2] = {\"rhs\", \"lhs\"}, *S[2] = {\" IN\", \"OUT\"}, txt[GMT_LEN256] = {\"\"}, type = 0;\n\tchar *module = NULL, argument[GMT_LEN256] = {\"\"}, strip_colon_opt = 0;\n\tchar *special_text[3] = {\" [satisfies required input]\", \" [satisfies required output]\", \"\"}, *satisfy = NULL;\n\tstruct GMT_OPTION *opt = NULL, *new_ptr = NULL;\t/* Pointer to a GMT option structure */\n\tstruct GMT_RESOURCE *info = NULL;\t/* Our return array of n_items info structures */\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\t*n = 0;\t/* Initialize counter to zero in case we return prematurely */\n\n\tif (V_API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module_name == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\n\tif ((*head) && ((*head)->option == GMT_OPT_USAGE || (*head)->option == GMT_OPT_SYNOPSIS)) {\t/* Nothing to do */\n\t\t*n = UINT_MAX;\n\t\treturn NULL;\n\t}\n\tmodule = calloc (strlen (module_name) + 4, sizeof(char));\t/* Allow space for any \"gmt\" prefix added to module in api_get_moduleinfo */\n\tstrcpy (module, module_name);\t\t\t/* This string can grow by 3 if need be */\n\t/* 0. Get the keys for the module, possibly prepend \"gmt\" to module if required, or list modules and return NULL if unknown module */\n\tif ((keys = api_get_moduleinfo (V_API, module)) == NULL) {\t/* Gave an unknown module */\n\t\tif (GMT_Call_Module (V_API, NULL, GMT_MODULE_PURPOSE, NULL))\t/* List the available modules */\n\t\t\treturn_null (NULL, GMT_NOT_A_VALID_MODULE);\n\t\tgmt_M_str_free (module);\n\t\treturn_null (NULL, GMT_NOT_A_VALID_MODULE);\t/* Unknown module code */\n\t}\n\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\t/* First some special checks related to unusual GMT syntax or hidden modules */\n\n\t/* 1a. Check if this is the write special module, which has flagged its output file as input... */\n\tif (!strncmp (module, \"gmtwrite\", 8U) && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, *head))) {\n\t\t/* Found a -<\"file\" option; this is actually the output file so we simply change the option to output */\n\t\topt->option = GMT_OPT_OUTFILE;\n\t\tdeactivate_output = true;\t/* Remember to turn off implicit output option since we got one */\n\t}\n\t/* 1b. Check if this is either gmtmath or grdmath which both use the special = outfile syntax and replace that by -=<outfile> */\n\telse if (!strncmp (module, \"gmtmath\", 7U) || !strncmp (module, \"grdmath\", 7U)) {\n\t\tstruct GMT_OPTION *delete = NULL;\n\t\tfor (opt = *head; opt && opt->next; opt = opt->next) {\t/* Here opt will end up being the last option */\n\t\t\tif (!strcmp (opt->arg, \"=\")) {\n\t\t\t\tif (opt->next) {\t/* Combine the previous = and <whatever> options into a single -=<whatever> option, then delete the former */\n\t\t\t\t\topt->next->option = '=';\n\t\t\t\t\tdelete = opt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGMT_Delete_Option (API, delete, head);\n\t}\n\t/* 1c. Check if this is the grdconvert module, which uses the syntax \"infile outfile\" without any option flags */\n\telse if (!strncmp (module, \"grdconvert\", 10U) && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, *head))) {\n\t\t/* Found a -<\"file\" option; this is indeed the input file but the 2nd \"input\" is actually output */\n\t\tif (opt->next && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, opt->next)))\t/* Found the next input file option */\n\t\t\topt->option = GMT_OPT_OUTFILE;\t/* Switch it to an output option */\n\t}\n\t/* 1d. Check if this is the greenspline module, where output type is grid for dimension == 2 else it is dataset */\n\telse if (!strncmp (module, \"greenspline\", 11U) && (opt = GMT_Find_Option (API, 'R', *head))) {\n\t\t/* Found the -R\"domain\" option; determine the dimensionality of the output */\n\t\tunsigned dim = api_determine_dimension (API, opt->arg);\n\t\ttype = (dim == 2) ? 'G' : 'D';\n\t}\n\t/* 1e. Check if this is the triangulate module, where primary dataset output should be turned off if -G given without -M,N,Q,S */\n\telse if (!strncmp (module, \"triangulate\", 11U) && (opt = GMT_Find_Option (API, 'G', *head))) {\n\t\t/* Found the -G<grid> option; determine if any of -M,N,Q,S are also set */\n\t\tif (!((opt = GMT_Find_Option (API, 'M', *head)) || (opt = GMT_Find_Option (API, 'N', *head))\n\t\t\t|| (opt = GMT_Find_Option (API, 'Q', *head)) || (opt = GMT_Find_Option (API, 'S', *head))))\n\t\t\t\tdeactivate_output = true;\t/* Turn off implicit output since none is in effect */\n\t}\n\t/* 1f. Check if this is the mgd77list module, which writes text or data depending on -F choices */\n\telse if (!strncmp (module, \"mgd77list\", 9U) && (opt = GMT_Find_Option (API, 'F', *head))) {\n\t\t/* Found the -F option, check if any strings are requested */\n\t\ttype = 'D';\t/* Default is dataset output unless any of the below were requested */\n\t\tif (strstr (opt->arg, \"all\") || strstr (opt->arg, \"mgd77\") || strstr (opt->arg, \"id\") || strstr (opt->arg, \"sln\")\n\t\t    || strstr (opt->arg, \"sspn\") || strstr (opt->arg, \"date\") || strstr (opt->arg, \"recno\"))\n\t\t\ttype = 'T';\n\t}\n\t/* 1g. Check if this is a *contour modules with -Gf|x given. For any other -G? flavor we kill the key with ! */\n\telse if ((!strncmp (module, \"grdcontour\", 10U) || !strncmp (module, \"pscontour\", 9U)) && (opt = GMT_Find_Option (API, 'G', *head))) {\n\t\t/* Found the -G option, check if any strings are requested */\n\t\t/* If not -Gf|x then we don't want this at all and set type = ! */\n\t\ttype = (opt->arg[0] == 'f') ? 'T' : ((opt->arg[0] == 'x') ? 'D' : '!');\n\t}\n\t/* 1h. Check if this is psxy or psxyz modules with quoted or decorated lines. For any other -S~|q? flavor we kill the key with ! */\n\telse if ((!strncmp (module, \"psxy\", 4U) || !strncmp (module, \"psxyz\", 5U)) && (opt = GMT_Find_Option (API, 'S', *head))) {\n\t\t/* Found the -S option, check if we requested quoted or decorated lines via fixed or crossing lines */\n\t\t/* If not f|x then we don't want this at all and set type = ! */\n\t\ttype = (!strchr (\"~q\", opt->arg[0]) || !strchr (\"fx\", opt->arg[1])) ? '!' : ((opt->arg[1] == 'x') ? 'D' : 'T');\n\t\tstrip_colon = (type && strchr (opt->arg, ':'));\n\t\tstrip_colon_opt = opt->option;\n\t\tif (strip_colon)\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Got quoted or decorate line and must strip argument %s from colon to end\\n\", opt->arg);\n\t}\n\t/* 1i. Check if this is the talwani3d module, where output type is grid except with -N it is dataset */\n\telse if (!strncmp (module, \"talwani3d\", 9U)) {\n\t\t/* If we find the -N option, we set type to D, else G */\n\t\ttype = (GMT_Find_Option (API, 'N', *head)) ? 'D' : 'G';\n\t}\n\n\tgmt_M_str_free (module);\n\n\t/* 2a. Get the option key array for this module */\n\tkey = api_process_keys (API, keys, type, *head, n_per_family, &n_keys);\t/* This is the array of keys for this module, e.g., \"<D{,GG},...\" */\n\n\tif (gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) {\n\t\tchar txt[4] = {\"\"};\n\t\tfor (k = 0; k < GMT_N_FAMILIES; k++) if (n_per_family[k] != GMT_NOTSET) {\n\t\t\t(n_per_family[k] == GMTAPI_UNLIMITED) ? sprintf (txt, \">1\") : sprintf (txt, \"%d\", n_per_family[k]);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: For %s we expect %s input objects\\n\", GMT_family[k], txt);\n\t\t}\n\t}\n\n\t/* 2b. Make some specific modifications to the keys given the options passed */\n\tif (deactivate_output && (k = api_get_key (API, GMT_OPT_OUTFILE, key, n_keys)) >= 0)\n\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Since an explicit output file already specified or not required */\n\n\t/* 3. Count command line output files */\n\tfor (opt = *head; opt; opt = opt->next)\n\t\tif (opt->option == GMT_OPT_OUTFILE) n_out++;\n\tif (n_out > 1) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Encode_Options: Can only specify one main output object via command line\\n\");\n\t\treturn_null (NULL, GMT_ONLY_ONE_ALLOWED);\t/* Too many output objects */\n\t}\n\tn_alloc = n_keys;\t/* Initial number of allocations */\n\tinfo = calloc (n_alloc, sizeof (struct GMT_RESOURCE));\n\n\t/* 4. Determine position of file args given as $ or via missing arg (proxy for input matrix) */\n\t/* Note: All explicit objects must be given after all implicit matrices have been listed */\n\tfor (opt = *head; opt; opt = opt->next) {\t/* Process options */\n\t\tstrip = (strip_colon_opt == opt->option) ? strip_colon : false;\t/* Just turn strip possibly true for the relevant option */\n\t\tk = api_get_key (API, opt->option, key, n_keys);\t/* If k >= 0 then this option is among those listed in the keys array */\n\t\tfamily = geometry = GMT_NOTSET;\t/* Not set yet */\n\t\tif (k >= 0) {\t/* Got a key, so split out family and geometry flags */\n\t\t\tsdir = api_key_to_family (API, key[k], &family, &geometry);\t/* Get dir, datatype, and geometry */\n\t\t\tif (sdir < 0) {\t/* Could not determine direction */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Encode_Options: Key not understood so direction is undefined? Notify developers\\n\");\n\t\t\t\tsdir = GMT_IN;\n\t\t\t}\n\t\t\tdirection = (unsigned int) sdir;\n\t\t}\n\t\tmod_pos = api_extract_argument (opt->arg, argument, key, k, strip, &n_pre_arg);\t/* Pull out the option argument, possibly modified by the key */\n\t\tif (api_found_marker (argument)) {\t/* Found an explicit questionmark within the option, e.g., -G?, -R? or -<? */\n\t\t\tif (opt->option == 'R' && !strcmp (opt->arg, \"?\")) {\t/* -R? means append a grid so set those parameters here */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -R? found: explicit grid will be substituted\\n\");\n\t\t\t\tfamily = GMT_IS_GRID;\n\t\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\t\tdirection = GMT_IN;\n\t\t\t}\n\t\t\telse if (k == GMT_NOTSET) {\t/* Found questionmark but no corresponding key found? */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Encode_Options: Error: Got a -<option>? argument but not listed in keys\\n\");\n\t\t\t\tdirection = GMT_IN;\t/* Have to assume it is an input file if not specified */\n\t\t\t}\n\t\t\tinfo[n_items].mode = (k >= 0 && api_is_required_IO (key[k][K_DIR])) ? K_PRIMARY : K_SECONDARY;\n\t\t\tif (k >= 0 && key[k][K_DIR] != '-')\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Make sure required { becomes ( and } becomes ) so we don't add them later */\n\t\t\t/* Add this item to our list */\n\t\t\tinfo[n_items].option    = opt;\n\t\t\tinfo[n_items].family    = family;\n\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\tinfo[n_items].direction = direction;\n\t\t\tinfo[n_items].pos = pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\t/* Explicitly given arguments are the first given on the r.h.s. */\n\t\t\tkind = GMT_FILE_EXPLICIT;\n\t\t\tn_items++;\n\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t}\n\t\telse if (k >= 0 && key[k][K_OPT] != GMT_OPT_INFILE && family != GMT_NOTSET && key[k][K_DIR] != '-') {\t/* Got some option like -G or -Lu with further args */\n\t\t\tbool implicit = true;\n\t\t\tif ((len = strlen (argument)) == (size_t)n_pre_arg)\t/* Got some option like -G or -Lu with no further args */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -%c needs implicit arg [offset = %d]\\n\", opt->option, n_pre_arg);\n\t\t\telse if (mod_pos && (argument[mod_pos] == '\\0' || argument[mod_pos] == '+'))\t/* Found an embedded +q<noarg> */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -%c needs implicit arg via argument-less +%c modifier\\n\", opt->option, key[k][K_MODIFIER]);\n\t\t\telse\n\t\t\t\timplicit = false;\n\t\t\tif (implicit) {\n\t\t\t\t/* This is an implicit reference and we must explicitly add the missing item by adding the questionmark */\n\t\t\t\tinfo[n_items].option    = opt;\n\t\t\t\tinfo[n_items].family    = family;\n\t\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\t\tinfo[n_items].direction = direction;\n\t\t\t\tinfo[n_items].mode = (api_is_required_IO (key[k][K_DIR])) ? K_PRIMARY : K_SECONDARY;\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\tinfo[n_items].pos = pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\n\t\t\t\t/* Explicitly add the missing marker (e.g., ?) to the option argument */\n\t\t\t\tif (mod_pos) {\t/* Must expand something like 300k+s+d+u into 300k+s$+d+u (assuming +s triggered this test) */\n\t\t\t\t\tstrncpy (txt, opt->arg, mod_pos);\n\t\t\t\t\tstrcat (txt, \"?\");\n\t\t\t\t\tif (opt->arg[mod_pos]) strcat (txt, &opt->arg[mod_pos]);\n\t\t\t\t}\n\t\t\t\telse if (strip)\t/* Special case for quoted and decorated lines with colon separating label info */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"%s?%s\", argument, &opt->arg[2]);\n\t\t\t\telse if (n_pre_arg)\t/* Something like -Lu becomes -Lu$ */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"%s?\", opt->arg);\n\t\t\t\telse\t/* Something like -C or -C+d200k becomes -C$ or -C$+d200k */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"?%s\", opt->arg);\n\t\t\t\tgmt_M_str_free (opt->arg);\n\t\t\t\topt->arg = strdup (txt);\n\t\t\t\tkind = GMT_FILE_EXPLICIT;\n\t\t\t\tn_items++;\n\t\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t\t}\n\t\t\telse {\t/* No implicit file argument involved, just check if this satisfies a required option */\n\t\t\t\tkind = GMT_FILE_NONE;\n\t\t\t\tif (k >= 0) {\t/* If this was a required input|output it has now been satisfied */\n\t\t\t\t\t/* Add check to make sure argument for input is an existing file! */\n\t\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\t\tsatisfy = special_text[direction];\n\t\t\t\t}\n\t\t\t\telse\t/* Nothing special about this option */\n\t\t\t\t\tsatisfy = special_text[2];\n\t\t\t}\n\t\t}\n\t\telse {\t/* No implicit file argument involved, just check if this satisfies a required option */\n\t\t\tkind = GMT_FILE_NONE;\n\t\t\tif (k >= 0) {\t/* If this was a required input|output it has now been satisfied */\n\t\t\t\t/* Add check to make sure argument for input is an existing file! */\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\tsatisfy = special_text[direction];\n\t\t\t}\n\t\t\telse\t/* Nothing special about this option */\n\t\t\t\tsatisfy = special_text[2];\n\t\t}\n\t\tif (kind == GMT_FILE_EXPLICIT)\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"%s: Option -%c%s includes a memory reference to %s argument # %d\\n\",\n\t\t\t            S[direction], opt->option, opt->arg, LR[direction], pos);\n\t\telse\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"---: Option -%c%s includes no memory reference%s\\n\",\n\t\t\t            opt->option, opt->arg, satisfy);\n\t\tif (n_items == n_alloc) {\n\t\t\tn_alloc <<= 1;\n\t\t\tinfo = realloc (info, n_alloc * sizeof (struct GMT_RESOURCE));\n\t\t}\n\t}\n\n\t/* Done processing references that were explicitly given in the options.  Now determine if module\n\t * has required input or output references that we must add (if not specified explicitly above) */\n\n\tfor (ku = 0; ku < n_keys; ku++) {\t/* Each set of keys specifies if the item is required via the 3rd key letter */\n\t\tif (api_is_required_IO (key[ku][K_DIR])) {\t/* Required input|output that was not specified explicitly above */\n\t\t\tchar str[2] = {'?',0};\n\t\t\tif ((sdir = api_key_to_family (API, key[ku], &family, &geometry)) == GMT_NOTSET) {\t/* Extract family and geometry */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Failure to extract family, geometry, and direction!!!!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdirection = (unsigned int) sdir;\n\t\t\t/* We need to know how many implicit items for a given family we might have to add.  For instance,\n\t\t\t * one can usually give any number of data or text tables but only one grid file.  However, this is\n\t\t\t * not a fixed thing, hence we counted up n_per_family from the keys earlier so we have some limits */\n\t\t\tif (direction == GMT_OUT || n_in == GMT_NOTSET)\t/* For output or lack of info we only add one item per key */\n\t\t\t\tn_to_add = 1;\n\t\t\telse\t/* More information to act on for inputs */\n\t\t\t\tn_to_add = (n_per_family[family] == GMTAPI_UNLIMITED) ? n_in - n_in_added : n_per_family[family];\n\t\t\tfor (e = 0; e < n_to_add; e++) {\n\t\t\t\tnew_ptr = GMT_Make_Option (API, key[ku][K_OPT], str);\t/* Create new option(s) with filename \"$\" */\n\t\t\t\t/* Append the new option to the list */\n\t\t\t\t*head = GMT_Append_Option (API, new_ptr, *head);\n\t\t\t\tinfo[n_items].option    = new_ptr;\n\t\t\t\tinfo[n_items].family    = family;\n\t\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\t\tinfo[n_items].direction = direction;\n\t\t\t\tinfo[n_items].pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\n\t\t\t\tinfo[n_items].mode = K_PRIMARY;\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"%s: Must add -%c? as implicit memory reference to %s argument # %d\\n\",\n\t\t\t\t\tS[direction], key[ku][K_OPT], LR[direction], info[n_items].pos);\n\t\t\t\tn_items++;\n\t\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t\t\tif (n_items == n_alloc) {\n\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\tinfo = realloc (info, n_alloc * sizeof (struct GMT_RESOURCE));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgmt_M_str_free (key[ku]);\t/* Free up this key */\n\t}\n\t/* Free up the temporary key array */\n\tgmt_M_str_free (key);\n\n\t/* Reallocate the information structure array or remove entirely if nothing given. */\n\tif (n_items && n_items < n_alloc) info = realloc (info, n_items * sizeof (struct GMT_RESOURCE));\n\telse if (n_items == 0) gmt_M_str_free (info);\t/* No containers used */\n\n\tgmt_M_memset (nn, 4, unsigned int);\n\tfor (ku = 0; ku < n_items; ku++)\t/* Count how many primary and secondary objects each for input and output */\n\t\tnn[info[ku].direction][info[ku].mode]++;\n\n\tfor (ku = 0; ku < n_items; ku++) {\t/* Reorder positions so that primary objects are listed before secondary objects */\n\t\tif (info[ku].mode == K_SECONDARY) info[ku].pos += nn[info[ku].direction][K_PRIMARY];\t/* Move secondary objects after all primary objects for this direction */\n\t\telse info[ku].pos -= nn[info[ku].direction][K_SECONDARY];\t/* Move any primary objects to start of list for this direction */\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Found %d inputs and %d outputs that need memory hook-up\\n\", input_pos, output_pos);\n\t/* Just checking that the options were properly processed */\n\tif (gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) {\n\t\tstatic char *omode[2] = {\"Primary\", \"Secondary\"};\n\t\ttext = GMT_Create_Cmd (API, *head);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Revised command before memory-substitution: %s\\n\", text);\n\t\tGMT_Destroy_Cmd (API, &text);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: List of items returned:\\n\");\n\t\tfor (ku = 0; ku < n_items; ku++) {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"External API item %2d: Family: %14s Direction: %6s Pos: %d Mode: %s\\n\",\n\t\t\t\tku, GMT_family[info[ku].family], GMT_direction[info[ku].direction], info[ku].pos, omode[info[ku].mode]);\n\t\t}\n\t}\n\n\t/* Pass back the info array and the number of items */\n\t*n = (n_items == 0) ? UINT_MAX : n_items;\t/* E.g., n_keys = 0 for gmtset, gmtdefaults, gmtlogo */\n\treturn (info);\n}\n\n#ifdef FORTRAN_API\nstruct GMT_RESOURCE *GMT_Encode_Options_ (const char *module, int *n_in, struct GMT_OPTION **head, unsigned int *n, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Encode_Options (GMT_FORTRAN, module, *n_in, head, n));\n}\n#endif\n\n/* Parsing API: to present, examine GMT Common Option current settings and GMT Default settings */\n\n/*! . */\nint GMT_Get_Common (void *V_API, unsigned int option, double par[]) {\n\t/* Inquires if specified GMT option has been set and obtains current values for some of them, if par is not NULL.\n\t * Returns GMT_NOTSET if the option has not been specified.  Otherwise, returns the number of parameters\n\t * it passed back via the par[] array.  Only some options passes back parameters; these are\n\t * -R, -I, -X, -Y, -b, -f, -i, -o, -r, -t, -:, while the others return 0.\n\t */\n\tint ret = GMT_NOTSET;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\n\tswitch (option) {\n\t\tcase 'B':\tif (GMT->common.B.active[0] || GMT->common.B.active[1]) ret = 0; break;\n\t\tcase 'I':\n\t\t\tif (GMT->common.R.active[ISET]) {\n\t\t\t\tret = 2;\n\t\t\t\tif (par) gmt_M_memcpy (par, GMT->common.R.inc, 2, double);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'J':\tif (GMT->common.J.active) ret = 0; break;\n\t\tcase 'K':\tif (GMT->common.K.active) ret = 0; break;\n\t\tcase 'O':\tif (GMT->common.O.active) ret = 0; break;\n\t\tcase 'P':\tif (GMT->common.P.active) ret = 0; break;\n\t\tcase 'R':\n\t\t\tif (GMT->common.R.active[RSET]) {\n\t\t\t\tret = 4;\n\t\t\t\tif (par) gmt_M_memcpy (par, GMT->common.R.wesn, 4, double);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\tif (GMT->common.U.active) ret = 0; break;\n\t\tcase 'V':\tif (GMT->common.V.active) ret = GMT->current.setting.verbose; break;\n\t\tcase 'X':\n\t\t\tif (GMT->common.X.active) {\n\t\t\t\tret = 1;\n\t\t\t\tif (par) par[0] = GMT->common.X.off;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\tif (GMT->common.Y.active) {\n\t\t\t\tret = 1;\n\t\t\t\tif (par) par[0] = GMT->common.Y.off;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\tif (GMT->common.a.active) ret = GMT->common.a.geometry; break;\n\t\tcase 'b':\tif (GMT->common.b.active[GMT_IN]) ret = GMT_IN; else if (GMT->common.b.active[GMT_OUT]) ret = GMT_OUT; break;\n\t\tcase 'c':\tif (GMT->common.c.active) ret = GMT->common.c.copies; break;\n\t\tcase 'f':\tif (GMT->common.f.active[GMT_IN]) ret = GMT_IN; else if (GMT->common.f.active[GMT_OUT]) ret = GMT_OUT; break;\n\t\tcase 'g':\tif (GMT->common.g.active) ret = 0; break;\n\t\tcase 'h':\tif (GMT->common.h.active) ret = GMT->common.h.mode; break;\n\t\tcase 'i':\tif (GMT->common.i.active) ret = (int)GMT->common.i.n_cols; break;\n\t\tcase 'n':\tif (GMT->common.n.active) ret = 0; break;\n\t\tcase 'o':\tif (GMT->common.o.active) ret = (int)GMT->common.o.n_cols; break;\n\t\tcase 'p':\tif (GMT->common.p.active) ret = 0; break;\n\t\tcase 'r':\tif (GMT->common.R.active[GSET]) ret = GMT->common.R.registration; break;\n\t\tcase 's':\tif (GMT->common.s.active) ret = 0; break;\n\t\tcase 't':\n\t\t\tif (GMT->common.t.active) {\n\t\t\t\tret = 1;\n\t\t\t\tif (par) par[0] = GMT->common.t.value;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\tif (GMT->common.colon.toggle[GMT_IN]) ret = GMT_IN; else if (GMT->common.colon.toggle[GMT_OUT]) ret = GMT_OUT; break;\n\t\tdefault:\n\t\t\tgmtapi_report_error (API, GMT_OPTION_NOT_FOUND);\n\t\t\tbreak;\n\t}\n\n\treturn (ret);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Common_ (unsigned int *option, double par[]) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Common (GMT_FORTRAN, *option, par));\n}\n#endif\n\n/*! . */\nint GMT_Get_Default (void *V_API, const char *keyword, char *value) {\n\t/* Given the text representation of a GMT parameter keyword, return its setting as text.\n\t * value must have enough space for the return information.\n\t */\n\tint error = GMT_NOERROR;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (keyword == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tif (value == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = api_get_api_ptr (V_API);\n\t/* First intercept any API Keywords */\n\tif (!strncmp (keyword, \"API_VERSION\", 11U))\t/* The API version */\n\t\tsprintf (value, \"%s\", GMT_PACKAGE_VERSION);\n\telse if (!strncmp (keyword, \"API_PAD\", 7U))\t/* Change the grid padding setting */\n\t\tsprintf (value, \"%d\", API->pad);\n\telse if (!strncmp (keyword, \"API_BINDIR\", 10U))\t/* Report binary directory */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_bindir);\n\telse if (!strncmp (keyword, \"API_SHAREDIR\", 12U))\t/* Report share directory */\n\t\tsprintf (value, \"%s\", API->GMT->session.SHAREDIR);\n\telse if (!strncmp (keyword, \"API_DATADIR\", 12U))\t/* Report data directory */\n\t\tsprintf (value, \"%s\", API->GMT->session.DATADIR);\n\telse if (!strncmp (keyword, \"API_PLUGINDIR\", 14U))\t/* Report plugin directory */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_plugindir);\n\telse if (!strncmp (keyword, \"API_LIBRARY\", 11U))\t/* Report core library */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_library);\n\telse if (!strncmp (keyword, \"API_CORES\", 9U))\t/* Report number of cores */\n\t\tsprintf (value, \"%d\", API->n_cores);\n#ifdef HAVE_GDAL\n\telse if (!strncmp (keyword, \"API_IMAGE_LAYOUT\", 16U))\t/* Report image/band layout */\n\t\tgmt_M_memcpy (value, API->GMT->current.gdal_read_in.O.mem_layout, 4, char);\n#endif\n\telse if (!strncmp (keyword, \"API_GRID_LAYOUT\", 15U)) {\t/* Report grid layout */\n\t\tif (API->shape == GMT_IS_COL_FORMAT)\n\t\t\tstrcpy (value, \"columns\");\n\t\telse if (API->shape == GMT_IS_ROW_FORMAT)\n\t\t\tstrcpy (value, \"rows\");\n\t}\n\telse {\t/* Must process as a GMT setting */\n\t\tstrcpy (value, gmtlib_putparameter (API->GMT, keyword));\n\t\terror = (value[0] == '\\0') ? GMT_OPTION_NOT_FOUND : GMT_NOERROR;\n\t}\n\treturn_error (V_API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Default_ (char *keyword, char *value, int len1, int len2) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Default (GMT_FORTRAN, keyword, value));\n}\n#endif\n\n/*! . */\nint GMT_Set_Default (void *V_API, const char *keyword, const char *txt_val) {\n\t/* Given the text representation of a GMT or API parameter keyword, assign its value.\n\t */\n\tunsigned int error = GMT_NOERROR;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *value = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (keyword == NULL) return_error (V_API, GMT_NOT_A_VALID_PARAMETER);\n\tif (txt_val == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = api_get_api_ptr (V_API);\n\tvalue = strdup (txt_val);\t/* Make local copy to be safe */\n\t/* First intercept any API Keywords */\n\tif (!strncmp (keyword, \"API_PAD\", 7U)) {\t/* Change the grid padding setting */\n\t\tint pad = atoi (value);\n\t\tif (pad >= 0) {\n\t\t\tgmt_set_pad (API->GMT, pad);\t/* Change the default pad; give GMT_NOTSET to leave as is */\n\t\t\tAPI->pad = pad;\n\t\t}\n\t}\n#ifdef HAVE_GDAL\n\telse if (!strncmp (keyword, \"API_IMAGE_LAYOUT\", 16U)) {\t/* Change image/band layout */\n\t\tif (strlen (value) != 4U) {\n\t\t\terror = 1;\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"API_IMAGE_LAYOUT requires a 4-character specification. %s is ignored\",  value);\n\t\t}\n\t\telse\n\t\t\tgmt_M_memcpy (API->GMT->current.gdal_read_in.O.mem_layout, value, 4, char);\n\t}\n#endif\n\telse if (!strncmp (keyword, \"API_GRID_LAYOUT\", 15U)) {\t/* Change grid layout */\n\t\tif (!strncmp (keyword, \"columns\", 7U))\n\t\t\tAPI->shape = GMT_IS_COL_FORMAT;\t/* Switch to column-major format */\n\t\telse if (!strncmp (keyword, \"rows\", 4U))\n\t\t\tAPI->shape = GMT_IS_ROW_FORMAT;\t/* Switch to row-major format */\n\t\telse\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"API_GRID_LAYOUT must be either \\\"columns\\\" or \\\"rows\\\"\",  value);\n\t\terror = 1;\n\t}\n\telse\t/* Must process as a GMT setting */\n\t\terror = gmtlib_setparameter (API->GMT, keyword, value, false);\n\tgmt_M_str_free (value);\n\treturn_error (V_API, (error) ? GMT_NOT_A_VALID_PARAMETER : GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Default_ (char *keyword, char *value, int len1, int len2) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Default (GMT_FORTRAN, keyword, value));\n}\n#endif\n\n/*! . */\nint GMT_Option (void *V_API, const char *options) {\n\t/* Take comma-separated GMT options and print the corresponding usage message(s). */\n\tunsigned int pos = 0, k = 0, n = 0;\n\tchar p[GMT_LEN64] = {\"\"}, arg[GMT_LEN64] = {\"\"};\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (options == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = api_get_api_ptr (V_API);\n\n\t/* The following does the translation between the rules for the option string and the convoluted items gmtlib_explain_options expects. */\n\twhile (gmt_strtok (options, \",\", &pos, p) && k < (GMT_LEN64-1)) {\n\t\tswitch (p[0]) {\n\t\t\tcase 'B':\t/* Let B be B and B- be b */\n\t\t\t\targ[k++] = (p[1] == '-') ? 'b' : 'B';\n\t\t\t\tbreak;\n\t\t\tcase 'J':\t/* Let J be -J and J- be j, JX is -Jx|X only, and -J[-]3 be adding -Z for 3-D scaling */\n\t\t\t\tn = 1;\n\t\t\t\tif (p[1] == '-') { arg[k++] = 'j'; n++; }\n\t\t\t\telse if (p[1] == 'X') { arg[k++] = 'x'; n++; }\n\t\t\t\telse arg[k++] = 'J';\n\t\t\t\tif (p[n] == 'Z' || p[n] == 'z') arg[k++] = 'Z';\n\t\t\t\tbreak;\n\t\t\tcase 'R':\t/* Want -R region usage */\n\t\t\t\tif (p[1]) {\t/* Gave modifiers */\n\t\t\t\t\tif (p[1] == 'x') arg[k++] = 'S';\t/* CarteSian region */\n\t\t\t\t\telse if (p[1] == 'g') arg[k++] = 'G';\t/* Geographic region */\n\t\t\t\t\telse arg[k++] = 'R';\t\t\t/* Generic region [Default] */\n\t\t\t\t\tif (p[1] == '3' || p[2] == '3') arg[k++] = 'z';\t/* 3-D region */\n\t\t\t\t}\n\t\t\t\telse arg[k++] = 'R';\t\t\t/* Generic region [Default] */\n\t\t\t\tbreak;\n\t\t\tcase 'b':\t/* Binary i/o -bi -bo */\n\t\t\t\targ[k++] = (p[1] == 'i') ? 'C' : 'D';\n\t\t\t\targ[k++] = (p[2]) ? p[2] : '0';\n\t\t\t\tbreak;\n\t\t\tcase 'd':\t/* Nodata flag -d, -di, -do */\n\t\t\t\tif (p[1] == 'i') arg[k++] = 'k';\n\t\t\t\telse if (p[1] == 'o') arg[k++] = 'l';\n\t\t\t\telse arg[k++] = 'd';\n\t\t\t\tbreak;\n\t\t\tcase 'r':\t/* Pixel registration */\n\t\t\t\targ[k++] = 'F';\n\t\t\t\tbreak;\n\t\t\tcase 'x':\t/* Number of threads (for multi-threaded progs) */\n\t\t\t\targ[k++] = 'y';\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* All others are pass-through */\n\t\t\t\targ[k++] = p[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgmtlib_explain_options (API->GMT, arg);\t/* Call the underlying explain_options machinery */\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Option_ (void *V_API, char *options, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Option (GMT_FORTRAN, options));\n}\n#endif\n\n/*! . */\nint GMT_Message (void *V_API, unsigned int mode, const char *format, ...) {\n\t/* Message independent of verbosity, optionally with timestamp.\n\t * mode = 0:\tNo time stamp\n\t * mode = 1:\tAbs time stamp formatted via GMT_TIME_STAMP\n\t * mode = 2:\tReport elapsed time since last reset.\n\t * mode = 4:\tReset elapsed time to 0, no time stamp.\n\t * mode = 6:\tReset elapsed time and report it as well.\n\t */\n\tsize_t source_info_len;\n\tchar message[4*GMT_BUFSIZ] = {\"\"}, *stamp = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tva_list args;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (format == NULL) return GMT_PTR_IS_NULL;\t/* Format cannot be NULL */\n\tAPI = api_get_api_ptr (V_API);\t/* Get the typecast structure pointer to API */\n\tif (mode) stamp = api_tictoc_string (API, mode);\t/* Pointer to a timestamp string */\n\tif (mode % 4) sprintf (message, \"%s | \", stamp);\t/* Lead with the time stamp */\n\tsource_info_len = strlen (message);\n\n\tva_start (args, format);\n\tvsnprintf (message + source_info_len, 4*GMT_BUFSIZ - source_info_len, format, args);\n\tva_end (args);\n\tassert (strlen (message) < 4*GMT_BUFSIZ);\n\tAPI->print_func (API->GMT->session.std[GMT_ERR], message);\t/* Do the printing */\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Message_ (void *V_API, unsigned int *mode, const char *message, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Message (GMT_FORTRAN, *mode, message));\n}\n#endif\n\n/*! . */\nint GMT_Report (void *V_API, unsigned int level, const char *format, ...) {\n\t/* Message whose output depends on verbosity setting */\n\tsize_t source_info_len = 0;\n\tunsigned int g_level;\n\tchar message[GMT_BUFSIZ] = {\"\"};\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\tva_list args;\n\t/* GMT_Report may be called before GMT is set so take precautions */\n\tif (V_API == NULL) return GMT_NOERROR;\t\t/* Not a fatal issue here but we cannot report anything */\n\tAPI = api_get_api_ptr (V_API);\t/* Get the typecast structure pointer to API */\n\tGMT = API->GMT;\t/* Short-hand for the GMT sub-structure */\n\tg_level = (GMT) ? GMT->current.setting.verbose : 0;\n\tif (level > MAX(API->verbose, g_level))\n\t\treturn 0;\n\tif (format == NULL) return GMT_PTR_IS_NULL;\t/* Format cannot be NULL */\n\tif (GMT && GMT->current.setting.timer_mode > GMT_NO_TIMER) {\n\t\tchar *stamp = api_tictoc_string (API, GMT->current.setting.timer_mode);\t/* NULL or pointer to a timestamp string */\n\t\tif (stamp) {\n\t\t\tsprintf (message, \"%s | \", stamp);\t/* Lead with the time stamp */\n\t\t\tsource_info_len = strlen (message);\t/* Update length of message from 0 */\n\t\t}\n\t}\n\tsnprintf (message + source_info_len, GMT_BUFSIZ-source_info_len, \"%s: \", (GMT && GMT->init.module_name) ? GMT->init.module_name : API->session_tag);\n\tsource_info_len = strlen (message);\n\tva_start (args, format);\n\t/* append format to the message: */\n\tvsnprintf (message + source_info_len, GMT_BUFSIZ - source_info_len, format, args);\n\tva_end (args);\n\tassert (strlen (message) < GMT_BUFSIZ);\n\tAPI->print_func (GMT ? GMT->session.std[GMT_ERR] : stderr, message);\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Report_ (void *V_API, unsigned int *level, const char *format, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Report (GMT_FORTRAN, *level, format));\n}\n#endif\n\n/*! . */\nint GMT_Get_Values (void *V_API, const char *arg, double par[], int maxpar) {\n\t/* Parse any number of comma, space, tab, semi-colon or slash-separated values.\n\t * The array par must have enough space to hold a maximum of maxpar items.\n\t * Function returns the number of items, or GMT_NOTSET if there was an error.\n\t * When there are more than maxpar items, only the first maxpar are stored, and\n\t * the value of maxpar is returned.\n\t * We can handle dimension units (c|i|p), distance units (d|m|s|e|f|k|M|n|u),\n\t * geographic coordinates, absolute dateTtime strings, and regular floats.\n\t *\n\t * Dimensions are returned in the current length unit [inch or cm].\n\t * Distances are returned in meters.\n\t * Arc distances are returned in degrees.\n\t * Geographic dd:mm:ss[W|E|S|N] coordinates are returned in decimal degrees.\n\t * DateTtime moments are returned in time in chosen units [sec] since chosen epoch [1970] */\n\n\tunsigned int pos = 0, mode, col_type_save[2][2];\n\tint npar = 0;\n\tsize_t len;\n\tchar p[GMT_BUFSIZ] = {\"\"}, unit;\n\tdouble value;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\tstatic const char separators[] = \" \\t,;/\";\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (arg == NULL || arg[0] == '\\0') return_value (V_API, GMT_NO_PARAMETERS, GMT_NOTSET);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\n\t/* Because gmt_init_distaz and possibly gmt_scanf_arg may decide to change the GMT col_type\n\t * we make a copy here and reset when done */\n\tgmt_M_memcpy (col_type_save[GMT_IN], GMT->current.io.col_type[GMT_IN],   2, unsigned int);\n\tgmt_M_memcpy (col_type_save[GMT_OUT], GMT->current.io.col_type[GMT_OUT], 2, unsigned int);\n\n\twhile (gmt_strtok (arg, separators, &pos, p)) {\t/* Loop over input aruments */\n\t\tif ((len = strlen (p)) == 0) continue;\n\t\tif (npar >= maxpar) {\t/* Bail out when already maxpar values are stored */\n\t\t\tgmtapi_report_error (API, GMT_DIM_TOO_LARGE);\n\t\t\tbreak;\n\t\t}\n\t\tlen--;\t/* Position of last char, possibly a unit */\n\t\tif (strchr (GMT_DIM_UNITS, p[len]))\t/* Dimension unit (c|i|p), return distance in GMT default length unit [inch or cm] */\n\t\t\tvalue = gmt_convert_units (GMT, p, GMT->current.setting.proj_length_unit, GMT->current.setting.proj_length_unit);\n\t\telse if (strchr (GMT_LEN_UNITS, p[len])) {\t/* Distance units, return as meters [or degrees if arc] */\n\t\t\tmode = gmt_get_distance (GMT, p, &value, &unit);\n\t\t\tgmt_init_distaz (GMT, unit, mode, GMT_MAP_DIST);\n\t\t\tvalue /= GMT->current.map.dist[GMT_MAP_DIST].scale;\t/* Convert to default unit */\n\t\t}\n\t\telse\t/* Perhaps coordinates or floats */\n\t\t\t(void) gmt_scanf_arg (GMT, p, GMT_IS_UNKNOWN, &value);\n\t\tpar[npar++] = value;\n\t}\n\t/* Reset col_types to what they were before the parsing */\n\tgmt_M_memcpy (GMT->current.io.col_type[GMT_IN],  col_type_save[GMT_IN],  2, unsigned int);\n\tgmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type_save[GMT_OUT], 2, unsigned int);\n\n\treturn (npar);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Values_ (char *arg, double par[], int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Values (GMT_FORTRAN, arg, par, len));\n}\n#endif\n\n/* Here lies the very basic F77 support for grid read and write only. It is assumed that no grid padding is required */\n\n#define F_STRNCPY(dst,src,ldst,lsrc) { int l = MIN(ldst-1, lsrc); strncpy (dst, src, l); dst[l] = '\\0'; }\n\nint gmt_f77_readgrdinfo_ (unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When returning, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * limit[4-5] holds zmin/zmax. limit must thus at least have a length of 6.\n\t */\n\tconst char *argv = \"GMT_F77_readgrdinfo\";\n\tchar *file = NULL;\n\tstruct GMT_GRID_HEADER header;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"No filename given to GMT_F77_readgrdinfo\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\t/* Read the grid header */\n\n\tgmt_M_memset (&header, 1, struct GMT_GRID_HEADER);\t/* To convince Coverity that header->index_function has been initialized */\n\tif (gmtlib_read_grd_info (API->GMT, file, &header)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error opening file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\t/* Assign variables from header structure items */\n\tdim[GMT_X] = header.n_columns;\tdim[GMT_Y] = header.n_rows;\n\tgmt_M_memcpy (limit, header.wesn, 4U, double);\n\tgmt_M_memcpy (inc, header.inc, 2U, double);\n\tlimit[ZLO] = header.z_min;\n\tlimit[ZHI] = header.z_max;\n\tdim[GMT_Z] = header.registration;\n\tif (title) F_STRNCPY (title, header.title, ltitle, GMT_GRID_TITLE_LEN80);\n\tif (remark) F_STRNCPY (remark, header.remark, lremark, GMT_GRID_REMARK_LEN160);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_RUNTIME_ERROR;\n\treturn GMT_NOERROR;\n}\n\nint gmt_f77_readgrd_ (float *array, unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When called, dim[2] is 1 we allocate the array, otherwise we assume it has enough space\n\t * Also, if dim[3] == 1 then we transpose the array before writing.\n\t * When returning, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * limit[4-5] holds zmin/zmax. limit must thus at least have a length of 6.\n\t */\n \tunsigned int no_pad[4] = {0, 0, 0, 0};\n\tdouble no_wesn[4] = {0.0, 0.0, 0.0, 0.0};\n\tconst char *argv = \"GMT_F77_readgrd\";\n\tchar *file = NULL;\n\tstruct GMT_GRID_HEADER header;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"No filename given to GMT_F77_readgrd\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\t/* Read the grid header */\n\tgmt_M_memset (&header, 1, struct GMT_GRID_HEADER);\t/* To convince Coverity that header->index_function has been initialized */\n\tgmt_grd_init (API->GMT, &header, NULL, false);\n\tif (gmtlib_read_grd_info (API->GMT, file, &header)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error opening file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\n\t/* Read the grid, possibly after first allocating array space */\n\tif (dim[GMT_Z] == 1) array = gmt_M_memory (API->GMT, NULL, header.size, float);\n\tif (gmtlib_read_grd (API->GMT, file, &header, array, no_wesn, no_pad, 0)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error reading file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\tif (dim[3] == 1) gmtlib_inplace_transpose (array, header.n_rows, header.n_columns);\n\n\t/* Assign variables from header structure items */\n\tdim[GMT_X] = header.n_columns;\tdim[GMT_Y] = header.n_rows;\n\tgmt_M_memcpy (limit, header.wesn, 4U, double);\n\tgmt_M_memcpy (inc, header.inc, 2U, double);\n\tlimit[ZLO] = header.z_min;\n\tlimit[ZHI] = header.z_max;\n\tdim[GMT_Z] = header.registration;\n\tif (title) F_STRNCPY (title, header.title, ltitle, GMT_GRID_TITLE_LEN80);\n\tif (remark) F_STRNCPY (remark, header.remark, lremark, GMT_GRID_REMARK_LEN160);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_RUNTIME_ERROR;\n\treturn GMT_NOERROR;\n}\n\nint gmt_f77_writegrd_ (float *array, unsigned int dim[], double limit[], double inc[], const char *title, const char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When called, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * Also, if dim[3] == 1 then we transpose the array before writing.  */\n \tunsigned int no_pad[4] = {0, 0, 0, 0};\n\tconst char *argv = \"GMT_F77_writegrd\";\n\tchar *file = NULL;\n\tdouble no_wesn[4] = {0.0, 0.0, 0.0, 0.0};\n\tstruct GMT_GRID_HEADER header;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\t/* Initialize with default values */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"No filename given to GMT_F77_writegrd\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\tgmt_M_memset (&header, 1, struct GMT_GRID_HEADER);\t/* To convince Coverity that header->index_function has been initialized */\n\tgmt_grd_init (API->GMT, &header, NULL, false);\n\tif (full_region (limit)) {\t/* Here that means limit was not properly given */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Grid domain not specified for %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif (inc[GMT_X] == 0.0 || inc[GMT_Y] == 0.0) {\t/* Here that means grid spacing was not properly given */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Grid spacing not specified for %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\n\t/* Set header parameters */\n\n\tgmt_M_memcpy (header.wesn, limit, 4U, double);\n\tgmt_M_memcpy (header.inc, inc, 2U, double);\n\theader.n_columns = dim[GMT_X];\theader.n_rows = dim[GMT_Y];\n\theader.registration = dim[GMT_Z];\n\tgmt_set_grddim (API->GMT, &header);\n\tif (title) F_STRNCPY (header.title, title, GMT_GRID_TITLE_LEN80, ltitle);\n\tif (remark) F_STRNCPY (header.remark, remark, GMT_GRID_REMARK_LEN160, lremark);\n\n\tif (dim[3] == 1) gmtlib_inplace_transpose (array, header.n_rows, header.n_columns);\n\n\t/* Write the file */\n\n\tif (gmtlib_write_grd (API->GMT, file, &header, array, no_wesn, no_pad, 0)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error writing file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_WRITE_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_MEMORY_ERROR;\n\treturn GMT_NOERROR;\n}\n\n/* wrappers for several Fortran compilers */\n#define F77_ARG1 unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname\n#define F77_ARG2 dim, limit, inc, title, remark, name, ltitle, lremark, lname\nint gmt_f77_readgrdinfo__(F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint gmt_f77_readgrdinfo  (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint GMT_F77_READGRDINFO_ (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint GMT_F77_READGRDINFO  (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\n#undef  F77_ARG1\n#undef  F77_ARG2\n\n#define F77_ARG1 float *array, unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname\n#define F77_ARG2 array, dim, limit, inc, title, remark, name, ltitle, lremark, lname\nint gmt_f77_readgrd__ (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint gmt_f77_readgrd   (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint GMT_F77_READGRD_  (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint GMT_F77_READGRD   (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\n#undef  F77_ARG1\n\n#define F77_ARG1 float *array, unsigned int dim[], double limit[], double inc[], const char *title, const char *remark, const char *name, int ltitle, int lremark, int lname\nint gmt_f77_writegrd__ (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint gmt_f77_writegrd   (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint GMT_F77_WRITEGRD_  (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint GMT_F77_WRITEGRD   (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\n#undef  F77_ARG1\n#undef  F77_ARG2\n\nchar *GMT_Duplicate_String (void *API, const char* string) {\n\t/* Duplicate a string. The interest of this function is to make the memory allocation\n\t   inside the GMT lib so that GMT_Destroy_Data we can free it without any concerns of\n\t   Windows DLL hell */\n\tgmt_M_unused(API);\n\treturn strdup (string);\n}\n\n/* Help functions specific to the Julia/GMT API */\n\nEXTERN_MSC int GMT_blind_change_struct(void *V_API, void *ptr, void *what, char *type, size_t off);\nint GMT_blind_change_struct(void *V_API, void *ptr, void *what, char *type, size_t off) {\n\t/* This is a magic backdoor to change static members of API structures that had to be declared as\n\t   immutables types in Julia and therefore impossible to change from within Julia.\n\t   *ptr  -> structure pointer whose member identified by the offset 'off' is to be changed.\n\t   *what -> pointer to the new value of the struct member that will be changed.\n\t   *type -> string with the type description, using the Julia types names. e.g. 'UInt32' or 'Float64'\n\t   The offset value 'off' is that obtained with the Julia's fieldoffsets() function, which is\n\t   equivalent to the 'offsetof()' C macro.\n\t*/\n\tif (!strcmp(type, \"Int32\"))\n\t\t*(int *)((char *)ptr + off) = *(int *)what;\n\telse if (!strcmp(type, \"UInt32\"))\n\t\t*(unsigned int *)((char *)ptr + off) = *(unsigned int *)what;\n\telse if (!strcmp(type, \"Int64\"))\n\t\t*(int64_t *)((char *)ptr + off) = *(int64_t *)what;\n\telse if (!strcmp(type, \"UInt64\"))\n\t\t*(uint64_t *)((char *)ptr + off) = *(uint64_t *)what;\n\telse if (!strcmp(type, \"Float32\"))\n\t\t*(float *)((char *)ptr + off) = *(float *)what;\n\telse if (!strcmp(type, \"Float64\"))\n\t\t*(double *)((char *)ptr + off) = *(double *)what;\n\telse if (!strcmp(type, \"Int16\"))\n\t\t*(signed short *)((char *)ptr + off) = *(signed short *)what;\n\telse if (!strcmp(type, \"UInt16\"))\n\t\t*(unsigned short *)((char *)ptr + off) = *(unsigned short *)what;\n\telse if (!strcmp(type, \"UInt8\"))\n\t\t*(unsigned char *)((char *)ptr + off) = *(unsigned char *)what;\n\telse if (!strcmp(type, \"Int8\"))\n\t\t*(char *)((char *)ptr + off) = *(char *)what;\n\telse {\n\t\tGMT_Report(V_API, GMT_MSG_NORMAL, \"GMT/Julia Backdoor: Type (%s) not accepted. Possibly a pointer to something.\\n\", type);\n\t\treturn_error (V_API, GMT_NOT_A_VALID_PARAMETER);\n\t}\n\treturn GMT_NOERROR;\n}\n\n/* Sub-functions to perform specific conversions */\n\n#define do_tbl_header(flag) (flag == 0 || flag == 2)\n#define do_seg_header(flag) (flag == 0 || flag == 1)\n\n/* GMT_DATASET to GMT_* : */\n\nGMT_LOCAL void *api_dataset2dataset (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_DATASET *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to another dataset using current formatting and column type information.\n\t * If Out is not NULL then we assume it has exact same dimension as the dataset, but no headers/records allocated.\n\t * header controls what we do with headers.\n\t * If mode == GMT_WRITE_TABLE_SEGMENT then we combine all segments into a SINGLE segment in ONE table\n\t * If mode == GMT_WRITE_TABLE then we collect all segments into ONE table.\n\t * If mode == GMT_WRITE_SEGMENT then we combine segments into ONE segment per table.\n\t */\n\tunsigned int hdr;\n\tuint64_t tbl, seg, row, col, n_rows, tbl_out = 0, row_out = 0, seg_out = 0;\n\tbool s_alloc, t_alloc, alloc, was;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *Din = NULL;\n\tstruct GMT_DATATABLE *Dout = NULL;\n\tstruct GMT_DATASEGMENT *Sin = NULL;\n\tstruct GMT_DATASEGMENT *Sout = NULL;\n\ts_alloc = t_alloc = alloc = (Out == NULL);\n\tif (alloc) {\t/* Must allocate output textset */\n\t\tOut = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASET);\n\t\tOut->n_tables = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : In->n_tables;\n\t\tOut->table = gmt_M_memory (GMT, NULL, Out->n_tables, struct GMT_DATATABLE *);\n\t}\n\twas = GMT->current.setting.io_header[GMT_OUT];\n\tGMT->current.setting.io_header[GMT_OUT] = do_tbl_header (header);\n\tOut->n_segments = (mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : ((mode == GMT_WRITE_SEGMENT) ? In->n_tables : In->n_segments);\n\tOut->n_records  = In->n_records;\n\tOut->n_columns  = In->n_columns;\n\tfor (tbl = 0; tbl < In->n_tables; tbl++) {\n\t\tif (mode == GMT_WRITE_SEGMENT) row_out = 0;\t/* Reset row output counter on a per table basis */\n\t\telse if (mode == 0) seg_out = 0;\t/* Reset segment output counter on a per table basis */\n\t\tif (alloc && (mode == 0 || mode == GMT_WRITE_SEGMENT)) s_alloc = true;\t/* Need to allocate at least one segment per table */\n\t\tDin = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tif (t_alloc) {\n\t\t\tOut->table[tbl_out] = Dout = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\t\tDout->n_segments = Dout->n_alloc = (mode == GMT_WRITE_TABLE_SEGMENT || mode == GMT_WRITE_SEGMENT) ? 1 : ((mode == GMT_WRITE_TABLE) ? In->n_segments : Din->n_segments);\t/* Number of segments in this table */\n\t\t\tDout->n_records  = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : Din->n_records;\t/* Number of data records int this table */\n\t\t\tDout->n_columns = In->n_columns;\n\t\t}\n\t\telse\n\t\t\tDout = Out->table[tbl_out];\n\t\tif (t_alloc) {\n\t\t\tif (Din->n_headers && do_tbl_header(header)) {\t/* Allocate and duplicate headers */\n\t\t\t\tDout->n_headers = Din->n_headers;\t/* Same number of header records as input table */\n\t\t\t\tif (alloc) Dout->header = gmt_M_memory (GMT, NULL, Dout->n_headers, char *);\n\t\t\t\tfor (hdr = 0; hdr < Dout->n_headers; hdr++) Dout->header[hdr] = strdup (Din->header[hdr]);\n\t\t\t}\n\t\t\tDout->segment = gmt_M_memory (GMT, NULL, Dout->n_segments, struct GMT_DATASEGMENT *);\n\t\t}\n\t\tfor (seg = 0; seg < Din->n_segments; seg++) {\t/* For each input table segment */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) row_out = 0;\t/* Reset row output counter on a per segment basis */\n\t\t\tSin = Din->segment[seg];\t/* Shorthand to current data segment */\n\t\t\tif (s_alloc) {\t/* Allocate another segment */\n\t\t\t\tn_rows = (mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : ((mode == GMT_WRITE_SEGMENT) ? Din->n_records : Sin->n_rows);\n\t\t\t\tDout->segment[seg_out] = GMT_Alloc_Segment (API, GMT_IS_DATASET, n_rows, In->n_columns, NULL, NULL);\n\t\t\t\tSout = Dout->segment[seg_out];\t/* Shorthand to current text segment */\n\t\t\t\tif (Sin->header && do_seg_header(header)) Sout->header = strdup (Sin->header);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSout = Dout->segment[seg_out];\n\t\t\tfor (row = 0; row < Sin->n_rows; row++, row_out++) {\t/* Copy each row to (new) segment */\n\t\t\t\tfor (col = 0; col < Sin->n_columns; col++)\n\t\t\t\t\tSout->data[col][row_out] = Sin->data[col][row];\n\t\t\t}\n\t\t\tif (mode == GMT_WRITE_SEGMENT || mode == GMT_WRITE_TABLE_SEGMENT) s_alloc = false;\t/* Only allocate this single segment, at least for this table */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) seg_out++;\t/* More than one segment on output */\n\t\t}\n\t\tif (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) t_alloc = false;\t/* Only allocate this single table */\n\t\tif (mode == 0 || mode == GMT_WRITE_SEGMENT) tbl_out++;\t/* More than one segment on output */\n\t}\n\tGMT->current.setting.io_header[GMT_OUT] = was;\n\treturn Out;\n}\n\nGMT_LOCAL void *api_dataset2textset (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_TEXTSET *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to a textset using current formatting and column type information.\n\t * If Out is not NULL then we assume it has exact same dimension as the dataset, but no headers/records allocated.\n\t * header controls what we do with headers.\n\t * If mode == GMT_WRITE_TABLE_SEGMENT then we combine all segments into a SINGLE segment in ONE table\n\t * If mode == GMT_WRITE_TABLE then we collect all segments into ONE table.\n\t * If mode == GMT_WRITE_SEGMENT then we combine segments into ONE segment per table.\n\t */\n\tunsigned int hdr, fmt;\n\tuint64_t tbl, seg, row, col, tbl_out = 0, row_out = 0, seg_out = 0;\n\tchar record[BUFSIZ] = {\"\"};\n\tbool s_alloc, t_alloc, alloc, was;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\ts_alloc = t_alloc = alloc = (Out == NULL);\n\tif (alloc) {\t/* Must allocate output textset */\n\t\tOut = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSET);\n\t\tOut->n_tables = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : In->n_tables;\n\t\tOut->table = gmt_M_memory (GMT, NULL, Out->n_tables, struct GMT_TEXTTABLE *);\n\t}\n\twas = GMT->current.setting.io_header[GMT_OUT];\n\tGMT->current.setting.io_header[GMT_OUT] = do_tbl_header (header);\n\tOut->n_segments = (mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : ((mode == GMT_WRITE_SEGMENT) ? In->n_tables : In->n_segments);\n\tOut->n_records  = In->n_records;\n\tfor (tbl = 0; tbl < In->n_tables; tbl++) {\n\t\tif (mode == GMT_WRITE_SEGMENT) row_out = 0;\t/* Reset row output counter on a per table basis */\n\t\telse if (mode == 0) seg_out = 0;\t/* Reset segment output counter on a per table basis */\n\t\tif (alloc && (mode == 0 || mode == GMT_WRITE_SEGMENT)) s_alloc = true;\t/* Need to allocate at least one segment per table */\n\t\tD = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tif (t_alloc) {\n\t\t\tOut->table[tbl_out] = T = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTTABLE);\n\t\t\tT->n_segments = T->n_alloc = (mode == GMT_WRITE_TABLE_SEGMENT || mode == GMT_WRITE_SEGMENT) ? 1 : ((mode == GMT_WRITE_TABLE) ? In->n_segments : D->n_segments);\t/* Number of segments in this table */\n\t\t\tT->n_records  = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : D->n_records;\t/* Number of data records int this table */\n\t\t}\n\t\telse T = Out->table[tbl_out];\n\t\tif (t_alloc) {\n\t\t\tif (D->n_headers && do_tbl_header(header)) {\t/* Allocate and duplicate headers */\n\t\t\t\tT->n_headers = D->n_headers;\t/* Same number of header records as input table */\n\t\t\t\tif (alloc) T->header = gmt_M_memory (GMT, NULL, T->n_headers, char *);\n\t\t\t\tfor (hdr = 0; hdr < T->n_headers; hdr++) T->header[hdr] = strdup (D->header[hdr]);\n\t\t\t}\n\t\t\tT->segment = gmt_M_memory (GMT, NULL, T->n_segments, struct GMT_TEXTSEGMENT *);\n\t\t}\n\t\tfor (seg = 0; seg < D->n_segments; seg++) {\t/* For each input table segment */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) row_out = 0;\t/* Reset row output counter on a per segment basis */\n\t\t\tSD = D->segment[seg];\t/* Shorthand to current data segment */\n\t\t\tif (s_alloc) {\t/* Allocate another segment */\n\t\t\t\tT->segment[seg_out] = gmt_M_memory (GMT, NULL, 1, struct GMT_TEXTSEGMENT);\n\t\t\t\tST = T->segment[seg_out];\t/* Shorthand to current text segment */\n\t\t\t\tST->n_rows = ST->n_alloc = (mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : ((mode == GMT_WRITE_SEGMENT) ? D->n_records : SD->n_rows);\n\t\t\t\tST->data = gmt_M_memory (GMT, NULL, ST->n_rows, char *);\n\t\t\t\tif (SD->header && do_seg_header(header)) ST->header = strdup (SD->header);\n\t\t\t}\n\t\t\telse\n\t\t\t\tST = T->segment[seg_out];\n\t\t\tfor (row = 0; row < SD->n_rows; row++, row_out++) {\t/* Encode each row into a text string */\n\t\t\t\tfmt = 10;\t/* Initialize record */\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++) {\n\t\t\t\t\tgmt_add_to_record (GMT, record, SD->data[col][row], col, GMT_IN, fmt);\n\t\t\t\t\tfmt = 1;\t/* Prepend field separator */\n\t\t\t\t}\n\t\t\t\tST->data[row_out] = strdup (record);\n\t\t\t}\n\t\t\tif (mode == GMT_WRITE_SEGMENT || mode == GMT_WRITE_TABLE_SEGMENT) s_alloc = false;\t/* Only allocate this single segment, at least for this table */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) seg_out++;\t/* More than one segment on output */\n\t\t}\n\t\tif (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) t_alloc = false;\t/* Only allocate this single table */\n\t\tif (mode == 0 || mode == GMT_WRITE_SEGMENT) tbl_out++;\t/* More than one segment on output */\n\t}\n\tGMT->current.setting.io_header[GMT_OUT] = was;\n\treturn Out;\n}\n\nGMT_LOCAL void *api_dataset2matrix (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_MATRIX *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to a matrix.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * Header controls if segment headers are written as NaN recs\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t */\n\tuint64_t tbl, seg, row, row_out, col, ij;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\n\tif (alloc) {\t/* Must allocate the output matrix */\n\t\tif ((Out = gmtlib_create_matrix (GMT, 1U, GMT_OUT)) == NULL) return (NULL);\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tOut->n_columns = Out->dim = In->n_columns;\n\t\tOut->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif (gmtlib_alloc_univector (GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tOut->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\tapi_put_val = api_select_put_function (API, Out->type);\n\tGMT_2D_to_index = api_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL);\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tD = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tfor (seg = 0; seg < D->n_segments; seg++) {\n\t\t\tSD = D->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < SD->n_rows; row++, row_out++) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, SD->data[col][row]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *api_dataset2vector (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_VECTOR *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to vectors.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t */\n\tuint64_t tbl, seg, row, row_out, col;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tif (alloc) {\n\t\tif ((Out = gmt_create_vector (GMT, In->n_columns, GMT_OUT)) == NULL) return NULL;\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tfor (col = 0; col < Out->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\tOut->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif ((API->error = api_alloc_vectors (GMT, Out, Out->n_rows)) != GMT_OK) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tapi_put_val = api_select_put_function (API, Out->type[0]);\t/* Since all columns are of same type we get the pointer here */\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tD = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tfor (seg = 0; seg < D->n_segments; seg++) {\n\t\t\tSD = D->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, GMT->session.d_NaN);\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < SD->n_rows; row++, row_out++) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, SD->data[col][row]);\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* GMT_TEXTSET to GMT_* : */\n\nGMT_LOCAL bool api_text2double_is_viable (struct GMT_CTRL *GMT, struct GMT_TEXTSET *In, bool strict) {\n\t/* Determine if we can convert text to data values.  Action depends on strict:\n\t * strict = true: Determines if all records in the textset can be converted to floating point data.\n\t * strict = false: Determines if two or more fields can be converted using first record only.\n\t */\n\tbool viable = true;\n\tuint64_t tbl, seg, row, k;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tstruct GMT_TEXTSEGMENT *S = NULL;\n\n\tif (!strict) {\n\t\tunsigned int n_columns = gmtlib_conv_text2datarec (GMT, In->table[0]->segment[0]->data[0], GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\treturn (n_columns > 1) ? true : false;\n\t}\n\t/* Do full strict check */\n\tfor (tbl = 0; viable && tbl < In->n_tables; tbl++) {\n\t\tT = In->table[tbl];\n\t\tfor (seg = 0; viable && seg < T->n_segments; seg++) {\n\t\t\tS = T->segment[seg];\t/* Shorthand */\n\t\t\tfor (row = 0; viable && row < S->n_rows; row++) {\n\t\t\t\tfor (k = 0; viable && k < strlen (S->data[row]); k++) {\n\t\t\t\t\tif (!strncmp (&S->data[row][k], \"NaN\", 3U))\n\t\t\t\t\t\tk += 2;\t/* Skip the NaN text */\n\t\t\t\t\telse if (!strchr (\"0123456789.,; -+eE\", S->data[row][k]))\n\t\t\t\t\t\tviable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn viable;\n}\n\nGMT_LOCAL void *api_textset2dataset (struct GMTAPI_CTRL *API, struct GMT_TEXTSET *In, struct GMT_DATASET *Out, unsigned int header, unsigned int dim, unsigned int mode) {\n\t/* Convert a textset to dataset.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * header controls what we do with headers.\n\t * If dim > 0 then it is assumed to hold the number of columns, else we estimate it from first data record.\n\t * If mode == GMT_WRITE_TABLE_SEGMENT then we combine all segments into a SINGLE segment in ONE table\n\t * If mode == GMT_WRITE_TABLE then we collect all segments into ONE table.\n\t * If mode == GMT_WRITE_SEGMENT then we combine segments into ONE segment per table.\n\t * If header & GMT_STRICT_CONVERSION then we only do the conversion if possible 1:1, else return NULL.\n\t * If header & GMT_LAX_CONVERSION then we do the conversion if at least the first two field convert, else return NULL.\n\t */\n\tunsigned int hdr;\n\tuint64_t tbl, seg, row, col, n_rows, tbl_out = 0, row_out = 0, seg_out = 0;\n\tbool s_alloc, t_alloc, alloc, was;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\n\tif (header & GMT_STRICT_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, true);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t\theader -= (header & GMT_STRICT_CONVERSION);\n\t}\n\telse if (header & GMT_LAX_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, false);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t\theader -= (header & GMT_LAX_CONVERSION);\n\t}\n\ts_alloc = t_alloc = alloc = (Out == NULL);\n\tif (alloc) {\n\t\tif ((Out = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASET)) == NULL) return_null (API, GMT_MEMORY_ERROR);\n\t\tOut->n_tables = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : In->n_tables;\n\t\tOut->table = gmt_M_memory (GMT, NULL, Out->n_tables, struct GMT_DATATABLE *);\n\t\tif (dim == 0) {\t/* Must guess number of columns from first text record */\n\t\t\tOut->n_columns = gmtlib_conv_text2datarec (GMT, In->table[0]->segment[0]->data[0], GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"api_textset2dataset: Determined that textset contains %d columns\\n\", Out->n_columns);\n\t\t}\n\t\telse\n\t\t\tOut->n_columns = dim;\n\t}\n\twas = GMT->current.setting.io_header[GMT_OUT];\n\tGMT->current.setting.io_header[GMT_OUT] = do_tbl_header (header);\n\tOut->n_segments = (mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : ((mode == GMT_WRITE_SEGMENT) ? In->n_tables : In->n_segments);\n\tOut->n_records  = In->n_records;\n\tfor (tbl = 0; tbl < In->n_tables; tbl++) {\n\t\tif (mode == GMT_WRITE_SEGMENT) row_out = 0;\t/* Reset row output counter on a per table basis */\n\t\telse if (mode == 0) seg_out = 0;\t/* Reset segment output counter on a per table basis */\n\t\tif (alloc && (mode == 0 || mode == GMT_WRITE_SEGMENT)) s_alloc = true;\t/* Need to allocate at least one segment per table */\n\t\tT = In->table[tbl];\n\t\tif (t_alloc) {\n\t\t\tOut->table[tbl_out] = D = gmt_M_memory (GMT, NULL, 1, struct GMT_DATATABLE);\n\t\t\tD->n_columns = Out->n_columns;\n\t\t}\n\t\telse D = Out->table[tbl_out];\n\t\tD->n_segments = D->n_alloc = (mode == GMT_WRITE_TABLE_SEGMENT || mode == GMT_WRITE_SEGMENT) ? 1 : ((mode == GMT_WRITE_TABLE) ? In->n_segments : T->n_segments);\t/* Number of segments in this table */\n\t\tD->n_records  = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : T->n_records;\t/* Number of data records int this table */\n\t\tif (t_alloc) {\n\t\t\tif (T->n_headers && do_tbl_header(header)) {\n\t\t\t\tD->n_headers = T->n_headers;\t/* Same number of header records as input table */\n\t\t\t\tif (alloc) D->header = gmt_M_memory (GMT, NULL, D->n_headers, char *);\n\t\t\t\tfor (hdr = 0; hdr < D->n_headers; hdr++) D->header[hdr] = strdup (T->header[hdr]);\n\t\t\t}\n\t\t\tD->segment = gmt_M_memory (GMT, NULL, D->n_segments, struct GMT_DATASEGMENT *);\n\t\t}\n\t\tfor (seg = 0; seg < T->n_segments; seg++) {\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) row_out = 0;\t/* Reset row output counter on a per segment basis */\n\t\t\tST = T->segment[seg];\t/* Shorthand */\n\t\t\tif (s_alloc) {\t/* Allocate this segment */\n\t\t\t\tn_rows = (mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : ((mode == GMT_WRITE_SEGMENT) ? T->n_records : ST->n_rows);\n\t\t\t\tD->segment[seg_out] = SD = GMT_Alloc_Segment (API, GMT_IS_DATASET, n_rows, Out->n_columns, NULL, NULL);\n\t\t\t\tif (ST->header && do_seg_header(header)) SD->header = strdup (ST->header);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSD = D->segment[seg_out];\n\t\t\tfor (row = 0; row < ST->n_rows; row++, row_out++) {\n\t\t\t\tcol = gmtlib_conv_text2datarec (GMT, ST->data[row], (unsigned int)Out->n_columns, GMT->current.io.curr_rec);\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++)\n\t\t\t\t\tSD->data[col][row_out] = GMT->current.io.curr_rec[col];\n\t\t\t}\n\t\t\tif (mode == GMT_WRITE_SEGMENT || mode == GMT_WRITE_TABLE_SEGMENT) s_alloc = false;\t/* Only allocate this single segment, at least for this table */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) seg_out++;\t/* More than one segment on output */\n\t\t}\n\t\tif (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) t_alloc = false;\t/* Only allocate this single table */\n\t\tif (mode == 0 || mode == GMT_WRITE_SEGMENT) tbl_out++;\t/* More than one segment on output */\n\t}\n\tGMT->current.setting.io_header[GMT_OUT] = was;\n\treturn Out;\n}\n\nGMT_LOCAL void *api_textset2matrix (struct GMTAPI_CTRL *API, struct GMT_TEXTSET *In, struct GMT_MATRIX *Out, unsigned int header, unsigned int dim, unsigned int mode) {\n\t/* Convert a textset to matrix.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * header controls what we do with headers.\n\t * If dim > 0 then it is assumed to hold the number of columns, else we estimate it from first data record.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t * If header & GMT_STRICT_CONVERSION then we only do the conversion if possible 1:1, else return NULL.\n\t * If header & GMT_LAX_CONVERSION then we do the conversion if at least the two first field convert, else return NULL.\n\t */\n\tuint64_t tbl, seg, row, row_out, col, ij;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\n\tif (header & GMT_STRICT_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, true);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t\tmode -= (mode & GMT_STRICT_CONVERSION);\n\t}\n\telse if (header & GMT_LAX_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, false);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t\tmode -= (mode & GMT_LAX_CONVERSION);\n\t}\n\n\tif (alloc) {\n\t\tif ((Out = gmtlib_create_matrix (GMT, 1U, GMT_OUT)) == NULL) return_null (API, GMT_MEMORY_ERROR);\n\t\tif (dim == 0) {\t/* Must guess number of columns from first text record */\n\t\t\tOut->n_columns = gmtlib_conv_text2datarec (GMT, In->table[0]->segment[0]->data[0], GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Determined that textset contains %d columns\\n\", Out->n_columns);\n\t\t}\n\t\telse\n\t\t\tOut->n_columns = dim;\n\t\tOut->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tif (gmtlib_alloc_univector (GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tOut->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\tapi_put_val = api_select_put_function (API, Out->type);\n\tGMT_2D_to_index = api_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL);\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tT = In->table[tbl];\n\t\tfor (seg = 0; seg < T->n_segments; seg++) {\n\t\t\tST = In->table[tbl]->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < Out->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < ST->n_rows; row++, row_out++) {\n\t\t\t\tcol = gmtlib_conv_text2datarec (GMT, ST->data[row], (unsigned int)Out->n_columns, GMT->current.io.curr_rec);\n\t\t\t\tfor (col = 0; col < Out->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, GMT->current.io.curr_rec[col]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *api_textset2vector (struct GMTAPI_CTRL *API, struct GMT_TEXTSET *In, struct GMT_VECTOR *Out, unsigned int header, unsigned int dim, unsigned int mode) {\n\t/* Convert a textset to vectors.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * header controls what we do with headers.\n\t * If dim > 0 then it is assumed to hold the number of columns, else we estimate it from first data record.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t * If header & GMT_STRICT_CONVERSION then we only do the conversion if possible 1:1, else return NULL.\n\t * If header & GMT_LAX_CONVERSION then we do the conversion if at least one field converts, else return NULL.\n\t */\n\tuint64_t tbl, seg, row, row_out, col;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_TEXTTABLE *T = NULL;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\n\tif (header & GMT_STRICT_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, true);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t}\n\telse if (header & GMT_LAX_CONVERSION) {\t/* Must ensure that all entries are numbers */\n\t\tbool viable = api_text2double_is_viable (GMT, In, false);\n\t\tif (!viable) return NULL;\t/* No can do */\n\t}\n\n\tif (alloc) {\n\t\tif (dim == 0) {\t/* Must guess number of columns from first text record */\n\t\t\tdim = gmtlib_conv_text2datarec (GMT, In->table[0]->segment[0]->data[0], GMT_BUFSIZ, GMT->current.io.curr_rec);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Determined that textset contains %d columns\\n\", dim);\n\t\t}\n\t\tif ((Out = gmt_create_vector (GMT, dim, GMT_OUT)) == NULL)\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tfor (col = 0; col < Out->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\tOut->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif ((API->error = api_alloc_vectors (GMT, Out, Out->n_rows)) != GMT_OK)\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t}\n\tapi_put_val = api_select_put_function (API, Out->type[0]);\t/* Since all columns are of same type we get the pointer here */\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tT = In->table[tbl];\n\t\tfor (seg = 0; seg < T->n_segments; seg++) {\n\t\t\tST = T->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < Out->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, GMT->session.d_NaN);\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < ST->n_rows; row++, row_out++) {\n\t\t\t\t(void)gmtlib_conv_text2datarec (GMT, ST->data[row], (unsigned int)Out->n_columns, GMT->current.io.curr_rec);\n\t\t\t\tfor (col = 0; col < Out->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, GMT->current.io.curr_rec[col]);\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* GMT_MATRIX to GMT_* : */\n\nGMT_LOCAL void *api_matrix2dataset (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_DATASET *Out, unsigned int header) {\n\t/* Convert a matrix to a dataset (one table with one segment).\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * header controls what we do with headers.\n\t */\n\tuint64_t row, col, ij;\n\tbool alloc = (Out == NULL);\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_matrix2dataset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_dataset (GMT, 1U, 1U, In->n_rows, In->n_columns, GMT_IS_POINT, true)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\tSD = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tapi_get_val = api_select_get_function (API, In->type);\n\tGMT_2D_to_index = api_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL);\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, In->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val (&(In->data), ij, &(SD->data[col][row]));\n\t\t}\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *api_matrix2textset (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_TEXTSET *Out, unsigned int header) {\n\t/* Convert a matrix to a textset (one table with one segment).\n\t * If Out is not NULL then we assume it has enough rows to hold the textset records.\n\t * header controls what we do with headers.\n\t */\n\tuint64_t row, col, ij;\n\tunsigned int fmt;\n\tchar record[BUFSIZ] = {\"\"};\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_matrix2textset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_textset (GMT, 1U, 1U, In->n_rows, false)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\n\tST = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tapi_get_val = api_select_get_function (API, In->type);\n\tGMT_2D_to_index = api_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL);\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfmt = 10;\t/* Initialize record */\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, In->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val (&(In->data), ij, &value);\n\t\t\tgmt_add_to_record (GMT, record, value, col, GMT_IN, fmt);\n\t\t\tfmt = 1;\t/* Prepend field separator */\n\t\t}\n\t\tST->data[row] = strdup (record);\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *api_matrix2vector (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_VECTOR *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a matrix to vectors.\n\t * If Out is not NULL then we assume it has enough rows to hold the vector rows.\n\t * header controls what we do with headers.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t */\n\tuint64_t row, col, ij;\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val_m = NULL;\n\tGMT_putfunction api_put_val_v = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_matrix2vector: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc) {\n\t\tif ((Out = gmt_create_vector (GMT, In->n_columns, GMT_OUT)) == NULL)\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\tOut->n_rows = In->n_rows;\n\t\tfor (col = 0; col < Out->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\tOut->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif ((API->error = api_alloc_vectors (GMT, Out, Out->n_rows)) != GMT_OK) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t}\n\t}\n\n\tapi_get_val_m = api_select_get_function (API, In->type);\n\tapi_put_val_v = api_select_put_function (API, GMT->current.setting.export_type);\t/* Since all columns are of same type we get the pointer here */\n\tGMT_2D_to_index = api_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL);\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, In->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val_m (&(In->data), ij, &value);\n\t\t\tapi_put_val_v (&(Out->data[col]), row, value);\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* GMT_VECTOR to GMT_* : */\n\nGMT_LOCAL void *api_vector2dataset (struct GMTAPI_CTRL *API, struct GMT_VECTOR *In, struct GMT_DATASET *Out, unsigned int header) {\n\t/* Convert a vector to a dataset (one table with one segment).\n\t * header controls what we do with headers.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t */\n\tuint64_t row, col;\n\tbool alloc = (Out == NULL);\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_getfunction api_get_val;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_vector2dataset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_dataset (GMT, 1U, 1U, In->n_rows, In->n_columns, GMT_IS_POINT, true)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\tSD = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tfor (col = 0; col < In->n_columns; col++) {\n\t\tapi_get_val = api_select_get_function (API, In->type[col]);\n\t\tfor (row = 0; row < In->n_rows; row++)\n\t\t\tapi_get_val (&(In->data[col]), row, &(SD->data[col][row]));\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *api_vector2textset (struct GMTAPI_CTRL *API, struct GMT_VECTOR *In, struct GMT_TEXTSET *Out, unsigned int header) {\n\t/* Convert a vector to a textset (one table with one segment).\n\t * header controls what we do with headers.\n\t * If Out is not NULL then we assume it has enough rows to hold the textset records.\n\t */\n\tuint64_t row, col;\n\tunsigned int fmt;\n\tchar record[BUFSIZ] = {\"\"};\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_TEXTSEGMENT *ST = NULL;\n\tGMT_getfunction *api_get_val = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_vector2textset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_textset (GMT, 1U, 1U, In->n_rows, false)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\n\tapi_get_val = gmt_M_memory (GMT, NULL, In->n_columns, GMT_getfunction);\n\tfor (col = 0; col < In->n_columns; col++)\n\t\tapi_get_val[col] = api_select_get_function (API, In->type[col]);\n\n\tST = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfmt = 10;\t/* Initialize record */\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tapi_get_val[col] (&(In->data[col]), row, &value);\n\t\t\tgmt_add_to_record (GMT, record, value, col, GMT_IN, fmt);\n\t\t\tfmt = 1;\t/* Prepend field separator */\n\t\t}\n\t\tST->data[row] = strdup (record);\n\t}\n\tgmt_M_free (GMT, api_get_val);\n\treturn Out;\n}\n\nGMT_LOCAL void *api_vector2matrix (struct GMTAPI_CTRL *API, struct GMT_VECTOR *In, struct GMT_MATRIX *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a vector to a textset (one table with one segment).\n\t * If Out is not NULL then we assume it has enough rows to hold the textset records.\n\t * header controls what we do with headers.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t */\n\tuint64_t row, col, ij;\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_NORMAL, \"api_vector2matrix: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc) {\n\t\tOut = gmtlib_create_matrix (GMT, 1U, GMT_OUT);\n\t\tOut->n_columns = In->n_columns;\n\t\tOut->n_rows = In->n_rows;\n\t\tOut->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif (gmtlib_alloc_univector (GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tOut->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\n\tGMT_2D_to_index = api_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL);\n\tapi_put_val = api_select_put_function (API, Out->type);\t/* Since all columns are of same type we get the pointer here */\n\tfor (col = 0; col < In->n_columns; col++) {\n\t\tapi_get_val = api_select_get_function (API, In->type[col]);\n\t\tfor (row = 0; row < In->n_rows; row++) {\n\t\t\tapi_get_val (&(In->data[col]), row, &value);\n\t\t\tij = GMT_2D_to_index (row, col, Out->dim);\n\t\t\tapi_put_val (&(Out->data), ij, value);\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* New function to convert between objects */\n\n#define GMT_HEADER_MODE\t0\n#define GMT_COLUMN_MODE\t1\n#define GMT_TYPE_MODE\t2\n#define GMT_FORMAT_MODE\t2\t/* Same as GMT_TYPE_MODE [not a typo] */\n\nvoid *GMT_Convert_Data (void *V_API, void *In, unsigned int family_in, void *Out, unsigned int family_out, unsigned int flag[]) {\n\t/* Convert between valid pairs of objects,  If Out == NULL then we allocate an output object,\n\t * otherwise we assume we are given adequate space already.  This is most likely restricted to a GMT_MATRIX.\n\t * flag is an array with three unsigned integers controlling various aspects of the conversion:\n\t * flag[0]: Controls how headers are handled on output:\n\t * \t 0 : All headers are passed on as is.  For Matrix/Vector all table headers are always ignored but\n\t * \t     segment headers will be encoded as NaN records\n\t * \t 1 : Headers are not copied, but segment headers are preserved\n\t * \t 2 : Headers are preserved, but segment headers are initialized to blank\n\t * \t 3 : All headers headers are eliminated\n\t *\t     The GMT Default settings in effect will control any output to files later.\n\t * \t Finally, if converting from TEXTSET to floating point representations, if the flag contains\n\t *   GMT_STRICT_CONVERSION then we only do the conversion if it is possible, else return NULL.\n\t *   If the flag contains GMT_LAX_CONVERSION then we do the conversion if at least one field converts, else return NULL.\n\t * [Note if that happens it is not considered an error, so API->error is GMT_NOERROR].\n\t * flag[1]: Controls how many columns to expect when converting TEXTSETS only.\n\t *\t0 : We determine number of columns by decoding the very first data record\n\t *  >0: We use this value as the number of columns to decode and report.\n\t * flag[2]: Controls the data type to use for MATRIX and VECTOR.\n\t * \t0: Use the GMT default data type [GMT_EXPORT_TYPE]\n\t * \t>0: Assumed to contain datatype + 1 (e.g., GMT_FLOAT+1, GMT_DOUBLE+1)\n\t * If TEXTSET or DATASET, this integer controls the restructuring of the set:\n\t * \tGMT_WRITE_TABLE_SEGMENT: Combine all segments into a SINGLE segment in ONE table\n\t * \tGMT_WRITE_TABLE: Collect all segments into ONE table.\n\t * \tGMT_WRITE_SEGMENT: Combine segments into ONE segment per table.\n\t * \t0: Retain initial layout.\n\t *\n\t * The following conversions are valid; the brackets indicate any side-effects or limitations]\n\t *\n\t * DATASET -> TEXTSET, MATRIX,  VECTOR\n\t * TEXTSET -> DATASET, MATRIX,  VECTOR [May result in NaNs; see GMT_STRICT_CONVERSION to limit conversion]\n\t * MATRIX  -> DATASET, TEXTSET, VECTOR\n\t * VECTOR  -> DATASET, TEXTSET, MATRIX\n\t */\n\tint object_ID, item;\n\tbool may_fail = false;\n\tvoid *X = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tswitch (family_in) {\n\t\tcase GMT_IS_DATASET:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = api_dataset2dataset (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_TEXTSET:\n\t\t\t\t\tX = api_dataset2textset (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_FORMAT_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = api_dataset2matrix(API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_VECTOR:\n\t\t\t\t\tX = api_dataset2vector (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\tmay_fail = (flag[GMT_HEADER_MODE] & (GMT_STRICT_CONVERSION | GMT_LAX_CONVERSION));\t/* Not an error if we \"fail\" to convert */\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = api_textset2dataset (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_COLUMN_MODE], flag[GMT_FORMAT_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = api_textset2matrix (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_COLUMN_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_VECTOR:\n\t\t\t\t\tX = api_textset2vector (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_COLUMN_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = api_matrix2dataset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_TEXTSET:\n\t\t\t\t\tX = api_matrix2textset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_VECTOR:\n\t\t\t\t\tX = api_matrix2vector (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = api_vector2dataset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_TEXTSET:\n\t\t\t\t\tX = api_vector2textset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = api_vector2matrix (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (may_fail && X == NULL)\n\t\treturn_null (API, GMT_NOERROR);\n\tif (API->error)\n\t\treturn_null (API, API->error);\n\tif ((object_ID = GMT_Register_IO (API, family_out, GMT_IS_REFERENCE, GMT_IS_POINT, GMT_IN, NULL, X)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failure to register */\n\tif ((item = gmtapi_validate_id (API, family_out, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->data = X;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n#ifdef DEBUG\n\tapi_list_objects (API, \"GMT_Convert_Data\");\n#endif\n\treturn (X);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Convert_Data_ (void *V_API, void *In, unsigned int *family_in, void *Out, unsigned int *family_out, unsigned int flag[]) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Convert_Data (GMT_FORTRAN, In, *family_in, Out, *family_out, flag));\n}\n#endif\n\nstruct GMT_DATASEGMENT *api_alloc_datasegment (void *V_API, uint64_t n_rows, uint64_t n_columns, char *header, struct GMT_DATASEGMENT *Sin) {\n\t/* Allocates space for a complete data segment and sets the segment header, if given.\n\t * In Sin == NULL then we allocate a new segment; else we reallocate items of the existing segment */\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tbool first = true;\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif ((S = Sin) != NULL)\t/* Existing segment given */\n\t\tfirst = false;\n\telse if ((S = gmt_M_memory (API->GMT, NULL, 1, struct GMT_DATASEGMENT)) == NULL) /* Something went wrong */\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\tif (gmt_alloc_datasegment (API->GMT, S, n_rows, n_columns, first))  {\t/* Something went wrong */\n\t\tif (first) gmt_M_free (API->GMT, S);\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\t}\n\tif (header && strlen (header)) {\t/* Gave a header string to (re)place in the segment */\n\t\tif (S->header) gmt_M_str_free (S->header);\n\t\tS->header = strdup (header);\n\t}\n\treturn S;\n}\n\nGMT_LOCAL struct GMT_TEXTSEGMENT *api_alloc_textsegment (void *V_API, uint64_t n_rows, char *header, struct GMT_TEXTSEGMENT *Sin) {\n\t/* Allocates space for a complete text segment and sets the segment header, if given.\n\t * In Sin == NULL then we allocate a new segment; else we reallocate items of the existing segment */\n\tstruct GMT_TEXTSEGMENT *S = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif ((S = Sin) == NULL && (S = gmt_M_memory (API->GMT, NULL, 1, struct GMT_TEXTSEGMENT)) == NULL) /* Something went wrong */\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\tif (gmt_alloc_textsegment (API->GMT, S, n_rows)) {\t/* Something went wrong */\n\t\tgmt_M_free (API->GMT, S);\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\t}\n\tif (header && strlen (header)) {\t/* Gave a header string to (re)place in the segment */\n\t\tif (S->header) gmt_M_str_free (S->header);\n\t\tS->header = strdup (header);\n\t}\n\treturn S;\n}\n\nvoid *GMT_Alloc_Segment (void *V_API, unsigned int family, uint64_t n_rows, uint64_t n_columns, char *header, void *S) {\n\t/* Deal with the two segment types or data and text.\n\t * The n_columns is only used for data segments.\n\t * header, if not NULL or blank, sets the segment header. */\n\tvoid *X = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tswitch (family) {\t/* Only two supported families */\n\t\tcase GMT_IS_DATASET:\n\t\t\tX = api_alloc_datasegment (V_API, n_rows, n_columns, header, S);\n\t\t\tbreak;\n\t\tcase GMT_IS_TEXTSET:\n\t\t\tX = api_alloc_textsegment (V_API, n_rows, header, S);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_null (V_API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\treturn (X);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Alloc_Segment_ (void *V_API, unsigned int *family, uint64_t *n_rows, uint64_t *n_columns, char *header, void *S, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Columns (GMT_FORTRAN, *family, *n_rows, *n_columns, header, S));\n}\n#endif\n\nint GMT_Set_Columns (void *V_API, unsigned int n_cols, unsigned int mode) {\n\t/* Specify how many output columns to use for record-by-record output */\n\tint error = 0;\n\tuint64_t n_in;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif ((n_in = gmt_get_cols (API->GMT, GMT_IN)) == 0) {\t/* Get number of input columns */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Set_Columns: Premature call - number of input columns not known yet\\n\");\n\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\t}\n\t/* If no columns specified we set output to the same as input columns */\n\tif (n_cols == 0 && (error = gmt_set_cols (API->GMT, GMT_OUT, n_in)) != 0)\n\t\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\n\t/* Get here when n_cols is not zero, so must consult mode */\n\n\tswitch (mode) {\n\t\tcase GMT_COL_FIX:\t/* Specific a fixed number of columns */\n\t\t\terror = gmt_set_cols (API->GMT, GMT_OUT, n_cols);\n\t\t\tbreak;\n\t\tcase GMT_COL_ADD:\t/* Add to the number of input columns */\n\t\t\terror = gmt_set_cols (API->GMT, GMT_OUT, n_in + n_cols);\n\t\t\tbreak;\n\t\tcase GMT_COL_SUB:\t/* Subtract from the number of input columns */\n\t\t\tif (n_cols >= n_in) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"GMT_Set_Columns: Cannot specify less than one output column!\\n\");\n\t\t\t\treturn_error (API, GMT_DIM_TOO_SMALL);\n\t\t\t}\n\t\t\terror = gmt_set_cols (API->GMT, GMT_OUT, n_in - n_cols);\n\t\t\tbreak;\n\t}\n\tif (error) return_error (API, GMT_N_COLS_NOT_SET);\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Columns_ (void *V_API, unsigned int *n_cols, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Columns (GMT_FORTRAN, *n_cols, *mode));\n}\n#endif\n\nGMT_LOCAL int api_change_gridlayout (struct GMTAPI_CTRL *API, char *code, unsigned int mode, struct GMT_GRID *G, float *out) {\n\tenum GMT_enum_family family;\n\tunsigned int row, col, pad[4], old_layout, new_layout;\n\tuint64_t in_node, out_node;\n\tfloat *tmp = NULL;\n\tgmt_M_unused(mode);\n\n\told_layout = api_decode_layout (API, G->header->mem_layout, &family);\n\tif (family != GMT_IS_GRID) return GMT_NOT_A_VALID_FAMILY;\n\tnew_layout = api_decode_layout(API, code, &family);\n\tif (old_layout == new_layout) return GMT_NOERROR;\t/* Nothing to do */\n\n\t/* Remove the high bits for complex data */\n\told_layout &= 3;\tnew_layout &= 3;\n\t/* Grids may be column vs row oriented and from top or from bottom */\n\tgmt_M_memcpy (pad, G->header->pad, 4, unsigned int);\t/* Remember the pad */\n\tif (((tmp = out) == NULL) && (tmp = gmt_M_memory_aligned (API->GMT, NULL, G->header->size, float)) == NULL)\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\n\tgmt_grd_pad_off (API->GMT, G);\t/* Simplify working with no pad */\n\tif (old_layout == 0 && new_layout == 2) { /* Change from TR to TC */\n\t\tfor (row = 0, in_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, in_node++)\n\t\t\t\ttmp[(uint64_t)col * (uint64_t)G->header->n_rows + row] = G->data[in_node];\n\t}\n\telse if (old_layout == 0 && new_layout == 3) {\t/* Change from TR to BC */\n\t\tfor (row = 0, in_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, in_node++)\n\t\t\t\ttmp[(uint64_t)col * (uint64_t)G->header->n_rows + (G->header->n_rows - row - 1)] = G->data[in_node];\n\t}\n\telse if (old_layout == 2 && new_layout == 0) {\t/* Change from TC to TR */\n\t\tfor (row = 0, out_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, out_node++)\n\t\t\t\ttmp[out_node] = G->data[(uint64_t)col * (uint64_t)G->header->n_rows + row];\n\t}\n\telse if (old_layout == 3 && new_layout == 0) {\t/* Change from BC to TR */\n\t\tfor (row = 0, out_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, out_node++)\n\t\t\t\ttmp[out_node] = G->data[(uint64_t)col * (uint64_t)G->header->n_rows + (G->header->n_rows - row - 1)];\n\t}\n\telse {\t\t/* Other cases to be added later ...*/\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_change_gridlayout: reordering function for case %s -> %s not yet written. Doing nothing\\n\",\n\t\t            G->header->mem_layout, code);\n\t\tfor (out_node = 0; out_node < G->header->size; out_node++)\n\t\t\ttmp[out_node] = G->data[out_node];\n\t}\n\n\tif (out == 0) {\t/* Means we must update the grid data */\n\t\tgmt_M_free_aligned (API->GMT, G->data);\t\t\t/* Free previous aligned grid memory */\n\t\tG->data = tmp;\n\t}\n\tgmt_grd_pad_on (API->GMT, G, pad);\t/* Restore pad on grid */\n\treturn (GMT_NOERROR);\n}\n\nGMT_LOCAL int api_change_imagelayout (struct GMTAPI_CTRL *API, char *code, unsigned int mode, struct GMT_IMAGE *I, unsigned char *out1, unsigned char *out2) {\n\t/* code: The new memory layout code\n\t   mode:\n\t   out1:  Array with the data converted to the new layout.\n\t   out2:  Array with the transparencies converted to the new layout.\n\t         If NULL on input the necessary memory is allocated in this function, otherwise\n\t         it is ASSUMED that it points a memory chunk big enough to hold the reshuffled data.\n\t*/\n\tunsigned char *tmp = NULL, *alpha = NULL;\n\tenum GMT_enum_family family;\n\tunsigned int old_layout, new_layout;\n\tuint64_t band, row, col, in_node, out_node;\n\tgmt_M_unused(mode);\n\n\told_layout = api_decode_layout (API, I->header->mem_layout, &family);\n\tif (family != GMT_IS_IMAGE) return GMT_NOT_A_VALID_FAMILY;\n\tnew_layout = api_decode_layout(API, code, &family);\n\tif (old_layout == new_layout) return GMT_NOERROR;\t/* Nothing to do */\n\n\t/* Images may be column vs row oriented, from top or from bottom and may be Band|Line|Pixel interleaved\n\t   That sums up to a lot of combinations. We will add them on a by-need basis. */\n\tif ((tmp = out1) == NULL && (tmp = gmt_M_memory_aligned (API->GMT, NULL, I->header->n_bands * I->header->size, unsigned char)) == NULL)\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\tif (I->alpha && (alpha = out2) == NULL && (alpha = gmt_M_memory_aligned (API->GMT, NULL, I->header->size, unsigned char)) == NULL) {\n\t\tif (out2 == NULL) gmt_M_free (API->GMT, alpha);\n\t\tgmt_M_free_aligned (API->GMT, tmp);\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\t}\n\n\tif (old_layout == 8 && new_layout == 2) {\t/* Change from TRP to TCB */\n\t\tout_node = 0;\n\t\tfor (row = 0; row < I->header->n_rows; row++)\n\t\t\tfor (col = 0; col < I->header->n_columns; col++)\n\t\t\t\tfor (band = 0; band < 3; band++) {\n\t\t\t\t\tin_node = row + col*I->header->n_rows + band*I->header->nm;\n\t\t\t\t\ttmp[in_node] = (uint8_t)I->data[out_node++];\n\t\t\t\t}\n\t}\n\t//else if (old_layout == 2 && new_layout == 0) {}\t/* Change from TCB to TRB */\n\telse {\t\t/* Other cases to be added later ...*/\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"api_change_imagelayout: reordering function for case %s -> %s not yet written. Doing nothing.\\n\",\n\t\t            I->header->mem_layout, code);\n\t\tfor (out_node = 0; out_node < I->header->size; out_node++)\n\t\t\ttmp[out_node] = I->data[out_node];\n\t}\n\n\tif (out1 == 0) {\t/* Means we must update the Image data */\n\t\tif (I->alloc_mode != GMT_ALLOC_EXTERNALLY)\n\t\t\tgmt_M_free_aligned (API->GMT, I->data);\t\t\t/* Free previous aligned image memory */\n\t\tI->data = tmp;\n\t}\n\tif (out2 == 0 && alpha) {\t/* Means we must update the alpha data */\n\t\tgmt_M_free_aligned (API->GMT, I->alpha);\t\t/* Free previous aligned image transparency */\n\t\tI->alpha = alpha;\n\t}\n\n\treturn (GMT_NOERROR);\n}\n\nint GMT_Change_Layout (void *V_API, unsigned int family, char *code, unsigned int mode, void *obj, void *out, void *alpha) {\n\t/* Reorder the memory layout of a grid or image given the new desired layout in code.\n\t * If out == NULL then we allocate space to hold the new grid|image and replace obj->data with this new array.\n\t *   For grids we preserve any padding in effect for the object but for out we have no padding.\n\t * Otherwise we assume out points to allcoated memory and we simply fill it out, assuming no pad.\n\t * mode is presently unused.\n\t * alpha is only considered for images and may be used to return a modified transparency array.\n\t */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tint error;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = api_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\terror = api_change_gridlayout (V_API, code, mode, obj, out);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\terror = api_change_imagelayout (V_API, code, mode, obj, out, alpha);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn_error (API, error);\n}\n\n/* Deal with assignments of custom vectors and matrices to GMT containers */\n\nint GMT_Put_Vector (void *API, struct GMT_VECTOR *V, unsigned int col, unsigned int type, void *vector) {\n\t/* Hooks a users custom vector onto V's column array and sets the type.\n\t * It is the user's respondibility to pass correct type for the given vector. */\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (col >= V->n_columns) return_error (API, GMT_DIM_TOO_LARGE);\n\tswitch (type) {\n\t\tcase GMT_DOUBLE:\tV->type[col] = GMT_DOUBLE;\tV->data[col].f8  = vector;\tbreak;\n\t\tcase GMT_FLOAT:\t\tV->type[col] = GMT_FLOAT;\tV->data[col].f4  = vector;\tbreak;\n\t\tcase GMT_ULONG:\t\tV->type[col] = GMT_ULONG;\tV->data[col].ui8 = vector;\tbreak;\n\t\tcase GMT_LONG:\t\tV->type[col] = GMT_LONG;\tV->data[col].si8 = vector;\tbreak;\n\t\tcase GMT_UINT:\t\tV->type[col] = GMT_UINT;\tV->data[col].ui4 = vector;\tbreak;\n\t\tcase GMT_INT:\t\tV->type[col] = GMT_INT;\t\tV->data[col].si4 = vector;\tbreak;\n\t\tcase GMT_USHORT:\tV->type[col] = GMT_USHORT;\tV->data[col].ui2 = vector;\tbreak;\n\t\tcase GMT_SHORT:\t\tV->type[col] = GMT_SHORT;\tV->data[col].si2 = vector;\tbreak;\n\t\tcase GMT_UCHAR:\t\tV->type[col] = GMT_UCHAR;\tV->data[col].uc1 = vector;\tbreak;\n\t\tcase GMT_CHAR:\t\tV->type[col] = GMT_CHAR;\tV->data[col].sc1 = vector;\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn GMT_NOERROR;\n}\n\nvoid *GMT_Get_Vector (void *API, struct GMT_VECTOR *V, unsigned int col) {\n\t/* Returns a pointer to the specified column array. Users can consult\n\t * V->type[col] to know what data type is pointed to.  */\n\tvoid *vector = NULL;\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tif (col >= V->n_columns) return_null (API, GMT_DIM_TOO_LARGE);\n\tswitch (V->type[col]) {\n\t\tcase GMT_DOUBLE:\tvector = V->data[col].f8;\tbreak;\n\t\tcase GMT_FLOAT:\t\tvector = V->data[col].f4;\tbreak;\n\t\tcase GMT_ULONG:\t\tvector = V->data[col].ui8;\tbreak;\n\t\tcase GMT_LONG:\t\tvector = V->data[col].si8;\tbreak;\n\t\tcase GMT_UINT:\t\tvector = V->data[col].ui4;\tbreak;\n\t\tcase GMT_INT:\t\tvector = V->data[col].si4;\tbreak;\n\t\tcase GMT_USHORT:\tvector = V->data[col].ui2;\tbreak;\n\t\tcase GMT_SHORT:\t\tvector = V->data[col].si2;\tbreak;\n\t\tcase GMT_UCHAR:\t\tvector = V->data[col].uc1;\tbreak;\n\t\tcase GMT_CHAR:\t\tvector = V->data[col].sc1;\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn vector;\n}\n\nint GMT_Put_Matrix (void *API, struct GMT_MATRIX *M, unsigned int type, void *matrix) {\n\t/* Hooks a user's custom matrix onto M's data array and sets the type.\n\t * It is the user's respondibility to pass correct type for the given matrix. */\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tswitch (type) {\n\t\tcase GMT_DOUBLE:\tM->type = GMT_DOUBLE;\tM->data.f8  = matrix;\tbreak;\n\t\tcase GMT_FLOAT:\t\tM->type = GMT_FLOAT;\tM->data.f4  = matrix;\tbreak;\n\t\tcase GMT_ULONG:\t\tM->type = GMT_ULONG;\tM->data.ui8 = matrix;\tbreak;\n\t\tcase GMT_LONG:\t\tM->type = GMT_LONG;\t\tM->data.si8 = matrix;\tbreak;\n\t\tcase GMT_UINT:\t\tM->type = GMT_UINT;\t\tM->data.ui4 = matrix;\tbreak;\n\t\tcase GMT_INT:\t\tM->type = GMT_INT;\t\tM->data.si4 = matrix;\tbreak;\n\t\tcase GMT_USHORT:\tM->type = GMT_USHORT;\tM->data.ui2 = matrix;\tbreak;\n\t\tcase GMT_SHORT:\t\tM->type = GMT_SHORT;\tM->data.si2 = matrix;\tbreak;\n\t\tcase GMT_UCHAR:\t\tM->type = GMT_UCHAR;\tM->data.uc1 = matrix;\tbreak;\n\t\tcase GMT_CHAR:\t\tM->type = GMT_CHAR;\t\tM->data.sc1 = matrix;\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn GMT_NOERROR;\n}\n\nvoid *GMT_Get_Matrix (void *API, struct GMT_MATRIX *M) {\n\t/* Returns a pointer to the matrix.  Users can consult\n\t * M->type to know what data type is pointed to.  */\n\tvoid *matrix = NULL;\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tswitch (M->type) {\n\t\tcase GMT_DOUBLE:\tmatrix = M->data.f8;\tbreak;\n\t\tcase GMT_FLOAT:\t\tmatrix = M->data.f4;\tbreak;\n\t\tcase GMT_ULONG:\t\tmatrix = M->data.ui8;\tbreak;\n\t\tcase GMT_LONG:\t\tmatrix = M->data.si8;\tbreak;\n\t\tcase GMT_UINT:\t\tmatrix = M->data.ui4;\tbreak;\n\t\tcase GMT_INT:\t\tmatrix = M->data.si4;\tbreak;\n\t\tcase GMT_USHORT:\tmatrix = M->data.ui2;\tbreak;\n\t\tcase GMT_SHORT:\t\tmatrix = M->data.si2;\tbreak;\n\t\tcase GMT_UCHAR:\t\tmatrix = M->data.uc1;\tbreak;\n\t\tcase GMT_CHAR:\t\tmatrix = M->data.sc1;\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn matrix;\n}\n\n/* Backwards compatibility for old API functions from 5.1-2 no longer in favor\n * as the Virtual File concept is much easier to understand and use. */\n\n/*! . */\nint GMT_Get_Value (void *V_API, const char *arg, double *par) {\n\n\treturn (GMT_Get_Values (V_API, arg, par, 999));\n}\n#ifdef FORTRAN_API\nint GMT_Get_Value_ (char *arg, double par[], int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Values (GMT_FORTRAN, arg, par, len));\n}\n#endif\n\n/*! . */\nvoid *GMT_Retrieve_Data (void *API, int object_ID) {\n\treturn api_retrieve_data (API, object_ID);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Retrieve_Data_ (int *object_ID) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (api_retrieve_data (GMT_FORTRAN, *object_ID));\n}\n#endif\n\nvoid *GMT_Get_Data (void *API, int object_ID, unsigned int mode, void *data) {\n\treturn api_get_data (API, object_ID, mode, data);\n}\n\n#ifdef FORTRAN_API\nvoid *GMT_Get_Data_ (int *ID, int *mode, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (api_get_data (GMT_FORTRAN, *ID, *mode, data));\n}\n#endif\n\nint GMT_Put_Data (void *API, int object_ID, unsigned int mode, void *data) {\n\treturn api_put_data (API, object_ID, mode, data);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Data_ (int *object_ID, unsigned int *mode, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (api_put_data (GMT_FORTRAN, *object_ID, *mode, data));\n}\n#endif\n\nint GMT_Encode_ID (void *API, char *filename, int object_ID) {\n\treturn (api_encode_id (API, filename, object_ID));\n}\n\n#ifdef FORTRAN_API\nint GMT_Encode_ID_ (char *filename, int *object_ID, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Encode_ID (GMT_FORTRAN, filename, *object_ID));\n}\n#endif\n\nint GMT_Get_ID (void *API, unsigned int family, unsigned int direction, void *resource) {\n\treturn (api_get_id (API, family, direction, resource));\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_ID_ (unsigned int *family, unsigned int *direction, void *resource) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_ID (GMT_FORTRAN, *family, *direction, resource));\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/src/gmt_sharedlibs.h": "/* $Id$\n *\n *\tCopyright (c) 2012-2018 by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe\n * by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis, and F. Wobbe\n * See LICENSE.TXT file for copying and redistribution conditions.\n */\n\n/*!\n * \\file gmt_sharedlibs.h\n * \\brief Structures needed by the various shared libraries. \n */\n\n#pragma once\n#ifndef _GMT_SHAREDLIBS_H\n#define _GMT_SHAREDLIBS_H\n\n#ifdef __cplusplus /* Basic C++ support */\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n#include <windows.h>\n/* Various functions declared in gmt_sharedlibs.c */\nEXTERN_MSC void *dlopen (const char *module_name, int mode);\nEXTERN_MSC int dlclose (void *handle);\nEXTERN_MSC void *dlsym (void *handle, const char *name);\nEXTERN_MSC char *dlerror (void);\n#else\n#include <dlfcn.h>\n#endif\n\nEXTERN_MSC void *dlopen_special (const char *name);\n\n/*! Info for each GMT shared library. This array is filled out when parsing GMT_CUSTOM_LIBS at end of GMT_Create_Session */\n\nstruct Gmt_libinfo {\n\tchar *name;\t/* Library tag name [without leading \"lib\" and extension], e.g. \"gmt\", \"gmtsuppl\" */\n\tchar *path;\t/* Full path to library as given in GMT_CUSTOM_LIBS */\n\tbool skip;\t/* true if we tried to open it and it was not available the first time */\n\tvoid *handle;\t/* Handle to the shared library, returned by dlopen or dlopen_special */\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !_GMT_SHAREDLIBS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/src/psconvert.c": "/*--------------------------------------------------------------------\n *\t$Id$\n *\n *\tCopyright (c) 1991-2018 by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe\n *\tSee LICENSE.TXT file for copying and redistribution conditions.\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU Lesser General Public License as published by\n *\tthe Free Software Foundation; version 3 or any later version.\n *\n *\tThis program is distributed in the hope that it will be useful,\n *\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n *\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\tGNU Lesser General Public License for more details.\n *\n *\tContact info: gmt.soest.hawaii.edu\n *--------------------------------------------------------------------*/\n/*\n *\n * Brief synopsis: psconvert converts one or several PostScript file(s) to other formats using GhostScript.\n * It works by modifying the page size in order that the image will have a size\n * which is specified by the BoundingBox.\n * As an option, a tight BoundingBox may be computed.\n * psconvert uses the ideas of the EPS2XXX.m from Primoz Cermelj published in MatLab Central\n * and of psbbox.sh of Remko Scharroo.\n *\n *\n *--------------------------------------------------------------------*/\n/*\n * Authors:\tJoaquim Luis and Remko Scharroo\n * Date:\t1-JAN-2010\n * Version:\t5 API\n */\n\n#include \"gmt_dev.h\"\n#define THIS_MODULE_NAME\t\"psconvert\"\n#define THIS_MODULE_LIB\t\t\"core\"\n#define THIS_MODULE_PURPOSE\t\"Convert [E]PS file(s) to other formats using GhostScript\"\n#define THIS_MODULE_KEYS\t\"<X{+,FI)\"\n#define THIS_MODULE_NEEDS\t\"\"\n#define THIS_MODULE_OPTIONS \"-V\"\n\n#ifdef _WIN32\n#\tdefine dup2 _dup2\n\t/* Various shared-library functions declared in gmt_sharedlibs.c */\n\tEXTERN_MSC void *dlopen (const char *module_name, int mode);\n\tEXTERN_MSC int dlclose (void *handle);\n\tEXTERN_MSC void *dlsym (void *handle, const char *name);\n\tEXTERN_MSC char *dlerror (void);\n#\tifndef RTLD_LAZY\n#\t\tdefine RTLD_LAZY 1\n#\tendif\n#else\t/* Standard Unix things */\n#\tinclude <dlfcn.h>\n#endif\n\nEXTERN_MSC void gmt_str_toupper (char *string);\nEXTERN_MSC void gmt_handle5_plussign (struct GMT_CTRL *GMT, char *in, char *mods, unsigned way);\n\n#ifdef WIN32\t/* Special for Windows */\n#\tinclude <windows.h>\n#\tinclude <process.h>\n#\tdefine getpid _getpid\n#\tdefine dup2 _dup2\n#\tdefine execv _execv\n#\tdefine pipe _pipe\n\tstatic char quote = '\\\"';\n\tstatic char *squote = \"\\\"\";\n#else\n\tstatic char quote = '\\'';\n\tstatic char *squote = \"\\'\";\n\tstruct popen2 {\n\t\tint fd[2];\t\t/* The input [0] and output [1] file descriptors */\n\t\tint n_closed;\t/* Number of times we have called gmt_pclose */\n\t    pid_t child_pid;\t/* Pid of child */\n\t};\n#endif\n\nenum GMT_GS_Devices {\n\tGS_DEV_EPS = 0,\n\tGS_DEV_PDF,\n\tGS_DEV_SVG,\n\tGS_DEV_JPG,\n\tGS_DEV_PNG,\n\tGS_DEV_PPM,\n\tGS_DEV_TIF,\n\tGS_DEV_BMP,\n\tGS_DEV_TPNG,      /* PNG with transparency */\n\tGS_DEV_JPGG,      /* These are grayscale versions */\n\tGS_DEV_PNGG,\n\tGS_DEV_TIFG,\n\tGS_DEV_BMPG,\n\tN_GS_DEVICES};\t/* Number of supported GS output devices */\n\nenum GMT_KML_Elevation {\n\tKML_GROUND_ABS = 0,\n\tKML_GROUND_REL,\n\tKML_ABS,\n\tKML_SEAFLOOR_REL,\n\tKML_SEAFLOOR_ABS,\n\tN_KML_ELEVATIONS};\n\n#define add_to_list(list,item) { if (list[0]) strcat (list, \" \"); strcat (list, item); }\n#define add_to_qlist(list,item) { if (list[0]) strcat (list, \" \"); strcat (list, squote);  strcat (list, item); strcat (list, squote); }\n\nstruct PS2RASTER_CTRL {\n\tstruct PS2R_In {\t/* Input file info */\n\t\tunsigned int n_files;\n\t} In;\n\tstruct PS2R_A {             /* -A[u][-] [Adjust boundingbox] */\n\t\tbool active;\n\t\tbool max;          /* Only scale if dim exceeds the given size */\n\t\tbool round;        /* Round HiRes BB instead of ceil */\n\t\tbool strip;        /* Remove the -U time-stamp */\n\t\tbool reset;        /* The -A- turns -A off, overriding any automode in effect */\n\t\tbool resize;       /* Resize to a user selected size */\n\t\tbool rescale;      /* Resize to a user selected scale factor */\n\t\tbool outline;      /* Draw frame around plot with selected pen [0.25p] */\n\t\tbool paint;        /* Paint box behind plot with selected fill */\n\t\tdouble scale;      /* Scale factor to go along with the 'rescale' option */\n\t\tdouble new_size[2];\n\t\tdouble margin[4];\n\t\tdouble new_dpi_x, new_dpi_y;\n\t\tstruct GMT_PEN pen;\n\t\tstruct GMT_FILL fill;\n\t} A;\n\tstruct PS2R_C {\t/* -C<option> */\n\t\tbool active;\n\t\tchar arg[GMT_LEN256];\n\t} C;\n\tstruct PS2R_D {\t/* -D<dir> */\n\t\tbool active;\n\t\tchar *dir;\n\t} D;\n\tstruct PS2R_E {\t/* -E<resolution> */\n\t\tbool active;\n\t\tunsigned int dpi;\n\t} E;\n\tstruct PS2R_F {\t/* -F<out_name> */\n\t\tbool active;\n\t\tchar *file;\n\t} F;\n\tstruct PS2R_G {\t/* -G<GSpath> */\n\t\tbool active;\n\t\tchar *file;\n\t} G;\n\tstruct PS2R_I {\t/* -I */\n\t\tbool active;\n\t} I;\n\tstruct PS2R_L {\t/* -L<listfile> */\n\t\tbool active;\n\t\tchar *file;\n\t} L;\n\tstruct PS2R_P {\t/* -P */\n\t\tbool active;\n\t} P;\n\tstruct PS2R_Q {\t/* -Q[g|t]<bits> */\n\t\tbool active;\n\t\tbool on[2];\t/* [0] for graphics, [1] for text antialiasing */\n\t\tunsigned int bits[2];\n\t} Q;\n\tstruct PS2R_S {\t/* -S */\n\t\tbool active;\n\t} S;\n\tstruct PS2R_T {\t/* -T */\n\t\tbool active;\n\t\tint eps;\t/* 1 if we want to make EPS, -1 with setpagedevice (possibly in addition to another format) */\n\t\tint ps;\t\t/* 1 if we want to save the final PS under \"modern\" setting */\n\t\tint device;\t/* May be negative */\n\t} T;\n\tstruct PS2R_W {\t/* -W -- for world file production */\n\t\tbool active;\n\t\tbool folder;\n\t\tbool warp;\n\t\tbool kml;\n\t\tunsigned int mode;\t/* 0 = clamp at ground, 1 is relative to ground, 2 is absolute 3 is relative to seafloor, 4 is clamp at seafloor */\n\t\tint min_lod, max_lod;\t/* minLodPixels and maxLodPixels settings */\n\t\tint min_fade, max_fade;\t/* minFadeExtent and maxFadeExtent settings */\n\t\tchar *doctitle;\t\t/* Name of KML document */\n\t\tchar *overlayname;\t/* Name of the image overlay */\n\t\tchar *URL;\t\t/* URL of remote site */\n\t\tchar *foldername;\t/* Name of KML folder */\n\t\tdouble altitude;\n\t} W;\n\tstruct PS2R_Z { /* -Z */\n\t\tbool active;\n\t} Z;\n};\n\n#ifdef WIN32\t/* Special for Windows */\n\tGMT_LOCAL int ghostbuster(struct GMTAPI_CTRL *API, struct PS2RASTER_CTRL *C);\n#else\n\t/* Abstraction to get popen to do bidirectional read/write */\nstruct popen2 * gmt_popen2 (const char *cmdline) {\n\tstruct popen2 *F = NULL;\n\t/* Must implement a bidirectional popen instead */\n    pid_t p;\n    int pipe_stdin[2] = {0, 0}, pipe_stdout[2] = {0, 0};\n\n    if (pipe(pipe_stdin))  return NULL;\n    if (pipe(pipe_stdout)) return NULL;\n\n    printf(\"pipe_stdin[0] = %d,  pipe_stdin[1]  = %d\\n\", pipe_stdin[0], pipe_stdin[1]);\n    printf(\"pipe_stdout[0] = %d, pipe_stdout[1] = %d\\n\", pipe_stdout[0], pipe_stdout[1]);\n\n    if ((p = fork()) < 0) return NULL; /* Fork failed */\n\n    if(p == 0) { /* child */\n        close (pipe_stdin[1]);\n        dup2 (pipe_stdin[0], 0);\n        close (pipe_stdout[0]);\n        dup2 (pipe_stdout[1], 1);\n        execl (\"/bin/sh\", \"sh\", \"-c\", cmdline, NULL);\n        perror (\"execl\"); exit (99);\n    }\n\t/* Return the file handles back via structure */\n\tF = calloc (1, sizeof (struct popen2));\n    F->child_pid = p;\n    F->fd[1] = pipe_stdin[1];\n    F->fd[0] = pipe_stdout[0];\n    return F; \n}\n\n#ifndef _WIN32\n#include <signal.h>\n#include <sys/wait.h>\n#endif\n\nvoid gmt_pclose2 (struct popen2 **Faddr, int dir) {\n\tstruct popen2 *F = *Faddr;\n\tF->n_closed++;\n\tclose (F->fd[dir]);\t/* Close this pipe */\n\tif (F->n_closed == 2) {\t/* Done so free object */\n\t\t/* Done, kill child */\n#ifndef _WIN32\n    \tprintf(\"kill(%d, 0) -> %d\\n\", F->child_pid, kill(F->child_pid, 0)); \n    \tprintf(\"waitpid() -> %d\\n\", waitpid(F->child_pid, NULL, 0));\n    \tprintf(\"kill(%d, 0) -> %d\\n\", F->child_pid, kill(F->child_pid, 0));\n#endif\n\t\tfree (F);\n\t\t*Faddr = NULL;\n\t}\n}\n#endif\n\nGMT_LOCAL int parse_A_settings (struct GMT_CTRL *GMT, char *arg, struct PS2RASTER_CTRL *Ctrl) {\n\t/* Syntax: -A[u][<margins>][-][+r][+s|S[m]<width>[u][/<height>[u]]] */\n\n\tbool error = false;\n\tunsigned int pos = 0;\n\tint j, k = 0, trim_j = -1;\n\tchar txt[GMT_LEN128] = {\"\"}, p[GMT_LEN128] = {\"\"};\n\tchar txt_a[GMT_LEN64] = {\"\"}, txt_b[GMT_LEN64] = {\"\"}, txt_c[GMT_LEN64] = {\"\"}, txt_d[GMT_LEN64] = {\"\"};\n\n\tCtrl->A.active = true;\n\n\tif (arg[k] == 'u') {Ctrl->A.strip = true; k++;}\n\t/* If there are +modifiers later we need to temporarily disable them: */\n\tfor (j = k; arg[j] && arg[j] != '+'; j++);\n\tif (arg[j] == '+') arg[j] = 0, trim_j = j;\n\tif (*arg != '\\0' && arg[strlen(arg)-1] == '-') {\n\t\tCtrl->A.reset = true;\n\t\treturn (error);\n\t}\n\tif (arg[k] && arg[k] != '+') {\t/* Also specified margin(s) */\n\t\tj = sscanf (&arg[k], \"%[^/]/%[^/]/%[^/]/%s\", txt_a, txt_b, txt_c, txt_d);\n\t\tswitch (j) {\n\t\t\tcase 1:\t/* Got uniform margin */\n\t\t\t\tCtrl->A.margin[XLO] = Ctrl->A.margin[XHI] = Ctrl->A.margin[YLO] = Ctrl->A.margin[YHI] = gmt_M_to_points (GMT, txt_a);\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* Got seprate x/y margins */\n\t\t\t\tCtrl->A.margin[XLO] = Ctrl->A.margin[XHI] = gmt_M_to_points (GMT, txt_a);\n\t\t\t\tCtrl->A.margin[YLO] = Ctrl->A.margin[YHI] = gmt_M_to_points (GMT, txt_b);\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* Got uniform margin */\n\t\t\t\tCtrl->A.margin[XLO] = gmt_M_to_points (GMT, txt_a);\n\t\t\t\tCtrl->A.margin[XHI] = gmt_M_to_points (GMT, txt_b);\n\t\t\t\tCtrl->A.margin[YLO] = gmt_M_to_points (GMT, txt_c);\n\t\t\t\tCtrl->A.margin[YHI] = gmt_M_to_points (GMT, txt_d);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror++;\n\t\t\t\tGMT_Report (Ctrl, GMT_MSG_NORMAL, \"-A: Give 1, 2, or 4 margins\\n\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (trim_j >= 0) arg[trim_j] = '+';\t/* Restore the chopped off section */\n\tstrncpy (txt, arg, GMT_LEN128-1);\n\twhile (!error && (gmt_strtok (txt, \"+\", &pos, p))) {\n\t\tswitch (p[0]) {\n\t\t\tcase 'p':\t/* Draw outline */\n\t\t\t\tCtrl->A.outline = true;\n\t\t\t\tif (!p[1])\n\t\t\t\t\tCtrl->A.pen = GMT->current.setting.map_default_pen;\n\t\t\t\telse if (gmt_getpen (GMT, &p[1], &Ctrl->A.pen)) {\n\t\t\t\t\tgmt_pen_syntax (GMT, 'A', \"sets background outline pen attributes\", 0);\n\t\t\t\t\terror++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'g':\t/* Fill background */\n\t\t\t\tCtrl->A.paint = true;\n\t\t\t\tif (!p[1]) {\n\t\t\t\t\tGMT_Report (Ctrl, GMT_MSG_NORMAL, \"-A+g: Append the background fill\\n\");\n\t\t\t\t\terror++;\n\t\t\t\t}\n\t\t\t\telse if (gmt_getfill (GMT, &p[1], &Ctrl->A.fill)) {\n\t\t\t\t\tgmt_pen_syntax (GMT, 'A', \"sets background fill attributes\", 0);\n\t\t\t\t\terror++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r':\t/* Round */\n\t\t\t\tCtrl->A.round = true;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\t/* New size via a scale factor */\n\t\t\t\tCtrl->A.rescale = true;\n\t\t\t\tCtrl->A.scale = atof(&p[1]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\t/* New size +s[m]<width>[u][/<height>[u]] */\n\t\t\t\tCtrl->A.resize = true;\n\t\t\t\tif (p[1] == 'm') { Ctrl->A.max = true, k = 2;} else k = 1;\n\t\t\t\tj = sscanf (&p[k], \"%[^/]/%s\", txt_a, txt_b);\n\t\t\t\tswitch (j) {\n\t\t\t\t\tcase 1:\t/* Got width only. Height will be computed later */\n\t\t\t\t\t\tCtrl->A.new_size[0] = gmt_M_to_points (GMT, txt_a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\t/* Got separate width/height */\n\t\t\t\t\t\tCtrl->A.new_size[0] = gmt_M_to_points (GMT, txt_a);\n\t\t\t\t\t\tCtrl->A.new_size[1] = gmt_M_to_points (GMT, txt_b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGMT_Report (Ctrl, GMT_MSG_NORMAL, \"Syntax error -A+s[m]<width[/height]>: Wrong size parameters\\n\");\n\t\t\t\t\t\terror++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (Ctrl->A.rescale && Ctrl->A.resize) {\n\t\tGMT_Report (Ctrl, GMT_MSG_NORMAL, \"Syntax error -A+s|S: Cannot set both -A+s and -A+S\\n\");\n\t\terror++;\n\t}\n\telse if (Ctrl->A.rescale)    /* But we can. This makes the coding simpler later on */\n\t\tCtrl->A.resize = true;\n\n\treturn (error);\n}\n\nGMT_LOCAL int parse_GE_settings (struct GMT_CTRL *GMT, char *arg, struct PS2RASTER_CTRL *C) {\n\t/* Syntax: -W[+g][+k][+t<doctitle>][+n<layername>][+a<altmode>][+l<lodmin>/<lodmax>] */\n\n\tunsigned int pos = 0, error = 0;\n\tchar p[GMT_LEN256] = {\"\"};\n\tgmt_M_unused(GMT);\n\n\tC->W.active = true;\n\twhile (gmt_getmodopt (GMT, 'W', arg, \"afgklnotu\", &pos, p, &error) && error == 0) {\t/* Looking for +a, etc */\n\t\tswitch (p[0]) {\n\t\t\tcase 'a':\t/* Altitude setting */\n\t\t\t\tswitch (p[1]) {\t/* Check which altitude mode we selected */\n\t\t\t\t\tcase 'G':\n\t\t\t\t\t\tC->W.mode = KML_GROUND_ABS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tC->W.mode = KML_GROUND_REL;\n\t\t\t\t\t\tC->W.altitude = atof (&p[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tC->W.mode = KML_ABS;\n\t\t\t\t\t\tC->W.altitude = atof (&p[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tC->W.mode = KML_SEAFLOOR_REL;\n\t\t\t\t\t\tC->W.altitude = atof (&p[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tC->W.mode = KML_SEAFLOOR_ABS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGMT_Report (C, GMT_MSG_NORMAL, \"Syntax error -W+a<mode>[par]: Unrecognized altitude mode %c\\n\", p[1]);\n\t\t\t\t\t\terror++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'f':\t/* Set fading options in KML */\n\t\t\t\tsscanf (&p[1], \"%d/%d\", &C->W.min_fade, &C->W.max_fade);\n\t\t\t\tbreak;\n\t\t\tcase 'g':\t/* Use gdal to make geotiff */\n\t\t\t\tC->W.warp = true;\n\t\t\t\tbreak;\n\t\t\tcase 'k':\t/* Produce a KML file */\n\t\t\t\tC->W.kml = true;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\t/* Set KML level of detail for image */\n\t\t\t\tsscanf (&p[1], \"%d/%d\", &C->W.min_lod, &C->W.max_lod);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\t/* Set KML document layer name */\n\t\t\t\tgmt_M_str_free (C->W.overlayname);\t/* Already set, free then reset */\n\t\t\t\tC->W.overlayname = gmt_assign_text (GMT, p);\n\t\t\t\tbreak;\n\t\t\tcase 'o':\t/* Produce a KML overlay as a folder subset */\n\t\t\t\tC->W.folder = true;\n\t\t\t\tgmt_M_str_free (C->W.foldername);\t/* Already set, free then reset */\n\t\t\t\tC->W.foldername = gmt_assign_text (GMT, p);\n\t\t\t\tbreak;\n\t\t\tcase 't':\t/* Set KML document title */\n\t\t\t\tgmt_M_str_free (C->W.doctitle);\t/* Already set, free then reset */\n\t\t\t\tC->W.doctitle = gmt_assign_text (GMT, p);\n\t\t\t\tbreak;\n\t\t\tcase 'u':\t/* Specify a remote address for image */\n\t\t\t\tgmt_M_str_free (C->W.URL);\t/* Already set, free then reset */\n\t\t\t\tC->W.URL = gmt_assign_text (GMT, p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGMT_Report (C, GMT_MSG_NORMAL, \"Syntax error -W+<opt>: Unrecognized option selection %c\\n\", p[1]);\n\t\t\t\terror++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn (error);\n}\n\nGMT_LOCAL void *New_Ctrl (struct GMT_CTRL *GMT) {\t/* Allocate and initialize a new control structure */\n\tstruct PS2RASTER_CTRL *C;\n\n\tC = gmt_M_memory (GMT, NULL, 1, struct PS2RASTER_CTRL);\n\n\t/* Initialize values whose defaults are not 0/false/NULL */\n#ifdef WIN32\n\tif (ghostbuster(GMT->parent, C) != GMT_NOERROR)  /* Try first to find the gspath from registry */\n\t\tC->G.file = strdup (\"gswin64c\");     /* Fall back to this default and expect a miracle */\n#else\n\tC->G.file = strdup (\"gs\");\n#endif\n\tC->D.dir = strdup (\".\");\n\n\tC->W.doctitle = strdup (\"GMT KML Document\");\n\tC->W.overlayname = strdup (\"GMT Image Overlay\");\n\tC->W.foldername = strdup (\"GMT Image Folder\");\n\n\treturn (C);\n}\n\nGMT_LOCAL void Free_Ctrl (struct GMT_CTRL *GMT, struct PS2RASTER_CTRL *C) {\t/* Deallocate control structure */\n\tif (!C) return;\n\tgmt_M_str_free (C->D.dir);\n\tgmt_M_str_free (C->F.file);\n\tgmt_M_str_free (C->G.file);\n\tgmt_M_str_free (C->L.file);\n\tgmt_M_str_free (C->W.doctitle);\n\tgmt_M_str_free (C->W.overlayname);\n\tgmt_M_str_free (C->W.foldername);\n\tgmt_M_str_free (C->W.URL);\n\tgmt_M_free (GMT, C);\n}\n\nGMT_LOCAL int usage (struct GMTAPI_CTRL *API, int level) {\n\tgmt_show_name_and_purpose (API, THIS_MODULE_LIB, THIS_MODULE_NAME, THIS_MODULE_PURPOSE);\n\tif (level == GMT_MODULE_PURPOSE) return (GMT_NOERROR);\n\tGMT_Message (API, GMT_TIME_NONE, \"usage: psconvert <psfile1> <psfile2> <...> -A[u][<margins>][-][+p[<pen>]][+g<fill>][+r][+s[m]|S<width[u]>[/<height>[u]]]\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t[-C<gs_command>] [-D<dir>] [-E<resolution>] [-F<out_name>] [-G<gs_path>] [-L<listfile>]\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t[-P] [-Q[g|t]1|2|4] [-S] [-Tb|e|E|f|F|g|G|j|m|s|t] [%s]\\n\", GMT_V_OPT);\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t[-W[+a<mode>[<alt]][+f<minfade>/<maxfade>][+g][+k][+l<lodmin>/<lodmax>][+n<name>][+o<folder>][+t<title>][+u<URL>]]\\n\");\n\tif (API->GMT->current.setting.run_mode == GMT_CLASSIC)\n\t\tGMT_Message (API, GMT_TIME_NONE, \"\\t[-Z]\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\n\");\n\n\tif (level == GMT_SYNOPSIS) return (GMT_MODULE_SYNOPSIS);\n\n\tGMT_Message (API, GMT_TIME_NONE, \"\\tWorks by modifying the page size in order that the resulting\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\timage will have the size specified by the BoundingBox.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\tAs an option, a tight BoundingBox may be computed.\\n\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t<psfile(s)> PostScript file(s) to be converted.\\n\");\n\tif (API->external)\n\t\tGMT_Message (API, GMT_TIME_NONE, \"\\tTo access the current internal GMT plot, specify <psfile> as \\\"=\\\".\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\n\\tOPTIONS:\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-A Adjust the BoundingBox to the minimum required by the image contents.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Append u to strip out time-stamps (produced by GMT -U options).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Append - to make sure -A is NOT activated by -W.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Optionally, append margin(s) to adjusted BoundingBox.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     -A<off>[u] sets uniform margin for all 4 sides.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     -A<xoff>[u]/<yoff>[u] set separate x- and y-margins.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     -A<woff>[u]/<eoff>[u]/<soff>[u]/<noff>[u] set separate w-,e-,s-,n-margins.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use the -A+s[m]<width[u]>[/<height>[u]] option the select a new image size\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   but maintaining the DPI set by -E (ghostscript does the re-interpolation work).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Add +g<paint> to paint the BoundingBox [no paint].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Add +p[<pen>] to outline the BoundingBox [%s].\\n\",\n\t             gmt_putpen (API->GMT, &API->GMT->current.setting.map_default_pen));\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use +sm to only change size if figure size exceeds the new maximum size(s).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Append unit u (%s) [%c].\\n\",\n\t             GMT_DIM_UNITS_DISPLAY, &API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit][0]);\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Alternatively use -A+S<scale> to scale the image by the <scale> factor.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use -A+r to force rounding of HighRes BoundingBox instead of ceil.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-C Specify a single, custom option that will be passed on to GhostScript\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   as is. Repeat to add several options [none].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-D Set an alternative output directory (which must exist)\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   [Default is same directory as PS files].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use -D. to place the output in the current directory.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-E Set raster resolution in dpi [default = 720 for PDF, 300 for others].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-F Force the output file name. By default output names are constructed\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   using the input names as base, which are appended with an appropriate\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   extension. Use this option to provide a different name, but WITHOUT\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   extension. Extension is still determined automatically.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-G Full path to your ghostscript executable.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   NOTE: Under Unix systems this is generally not necessary.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Under Windows, ghostscript path is fished from the registry.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   If this fails you can still add the GS path to system's path\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   or give the full path here.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   (e.g., -Gc:\\\\programs\\\\gs\\\\gs9.02\\\\bin\\\\gswin64c).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-I Ghostscript versions >= 9.00 change gray-shades by using ICC profiles.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   GS 9.05 and above provide the '-dUseFastColor=true' option to prevent that\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   and that is what psconvert does by default, unless option -I is set.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Note that for GS >= 9.00 and < 9.05 the gray-shade shifting is applied\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   to all but PDF format. We have no solution to offer other than ... upgrade GS\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-L The <listfile> is an ASCII file with names of files to be converted.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-P Force Portrait mode. All Landscape mode plots will be rotated back\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   so that they show unrotated in Portrait mode.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   This is practical when converting to image formats or preparing\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   EPS or PDF plots for inclusion in documents.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-Q Anti-aliasing setting for (g)raphics or (t)ext; append size (1,2,4)\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   of sub-sampling box.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Default is no anti-aliasing, which is the same as specifying size 1.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-S Apart from executing it, also writes the ghostscript command to\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   standard error and keeps all intermediate files.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-T Set output format [default is jpeg]:\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   b means BMP.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   e means EPS.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   E means EPS with setpagedevice command.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   f means PDF.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   F means multi-page PDF (requires -F).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   g means PNG.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   G means PNG (transparent where nothing is plotted).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   j means JPEG.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   m means PPM.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   s means SVG [if supported by your ghostscript version].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   t means TIF.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   For b, g, j, t, append - to get a grayscale image [24-bit color].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   The EPS format can be combined with any of the other formats.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   For example, -Tef creates both an EPS and PDF file.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-V Provide progress report [default is silent] and shows the\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   gdal_translate command, in case you want to use this program\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   to create a geoTIFF file.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t-W Write a ESRI type world file suitable to make (e.g.,) .tif files be\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   recognized as geotiff by software that know how to do it. Be aware,\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   however, that different results are obtained depending on the image\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   contents and if the -B option has been used or not. The trouble with\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   -B is that it creates a frame and very likely its annotations and\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   that introduces pixels outside the map data extent. As a consequence,\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   the map extents estimation will be wrong. To avoid this problem, use\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   the --MAP_FRAME_TYPE=inside option which plots all annotations related\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   stuff inside the image and does not compromise the coordinate.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   computations. The world file naming follows the convention of jamming\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   a 'w' in the file extension. So, if the output is tif (-Tt) the world\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   file is a .tfw, for jpeg a .jgw, and so on.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use -W+g to do a system call to gdal_translate and produce a true\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   geoTIFF image right away. The output file will have the extension\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   .tiff. See the man page for other 'gotchas'. Automatically sets -A -P.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Use -W+k to create a minimalist KML file that allows loading the\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   image in Google Earth. Note that for this option the image must be\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   in geographical coordinates. If not, a warning is issued but the\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   KML file is created anyway.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Several modifiers allow you to specify the content in the KML file:\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +a<altmode>[<altitude>] sets the altitude mode of this layer, where\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      <altmode> is one of 5 recognized by Google Earth:\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      G clamped to the ground [Default].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      g Append altitude (in m) relative to ground.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      A Append absolute altitude (in m).\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      s Append altitude (in m) relative to seafloor.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t      S clamped to the seafloor.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +f<minfade>/<maxfade>] sets distances over which we fade from opaque\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     to transparent [no fading].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +l<minLOD>/<maxLOD>] sets Level Of Detail when layer should be\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     active [always active]. Image goes inactive when there are fewer\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     than minLOD pixels or more than maxLOD pixels visible.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     -1 means never invisible.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +n<layername> sets the name of this particular layer\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     [\\\"GMT Image Overlay\\\"].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +o<foldername> sets the name of this particular folder\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     [\\\"GMT Image Folder\\\"].  This yields a KML snipped without header/trailer.\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +t<doctitle> sets the document name [\\\"GMT KML Document\\\"].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   +u<URL> prepands this URL to the name of the image referenced in the\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t     KML [local file].\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t   Escape any +? modifier inside strings with \\\\.\\n\");\n\tif (API->GMT->current.setting.run_mode == GMT_CLASSIC)\n\t\tGMT_Message (API, GMT_TIME_NONE, \"\\t-Z Remove input PostScript file(s) after successful conversion.\\n\");\n\n\treturn (GMT_MODULE_USAGE);\n}\n\nGMT_LOCAL int parse (struct GMT_CTRL *GMT, struct PS2RASTER_CTRL *Ctrl, struct GMT_OPTION *options) {\n\t/* This parses the options provided to psconvert and sets parameters in CTRL.\n\t * Any GMT common options will override values set previously by other commands.\n\t * It also replaces any file names specified as input or output with the data ID\n\t * returned when registering these sources/destinations with the API.\n\t */\n\n\tunsigned int n_errors = 0, mode;\n\tint j;\n\tbool grayscale;\n\tstruct GMT_OPTION *opt = NULL;\n\n\tfor (opt = options; opt; opt = opt->next) {\n\t\tswitch (opt->option) {\n\n\t\t\tcase '<':\t/* Input files [Allow for file \"=\" under API calls] */\n\t\t\t\tif (!(GMT->parent->external && !strncmp (opt->arg, \"=\", 1))) {\t/* Can check if file is sane */\n\t\t\t\t\tif (!gmt_check_filearg (GMT, '<', opt->arg, GMT_IN, GMT_IS_TEXTSET)) n_errors++;\n\t\t\t\t}\n\t\t\t\tCtrl->In.n_files++;\n\t\t\t\tbreak;\n\n\t\t\t/* Processes program-specific parameters */\n\n\t\t\tcase 'A':\t/* Adjust BoundingBox: -A[u][<margins>][-][+r][+s<width>[u][/<height>[u]]] or -A- */\n\t\t\t\tn_errors += parse_A_settings (GMT, opt->arg, Ctrl);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\t/* Append extra custom GS options */\n\t\t\t\tstrcat (Ctrl->C.arg, \" \");\n\t\t\t\tstrncat (Ctrl->C.arg, opt->arg, GMT_LEN256-1);\t/* Append to list of extra GS options */\n\t\t\t\tbreak;\n\t\t\tcase 'D':\t/* Change output directory */\n\t\t\t\tif ((Ctrl->D.active = gmt_check_filearg (GMT, 'D', opt->arg, GMT_OUT, GMT_IS_TEXTSET)) != 0) {\n\t\t\t\t\tgmt_M_str_free (Ctrl->D.dir);\n\t\t\t\t\tCtrl->D.dir = strdup (opt->arg);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tn_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\t/* Set output dpi */\n\t\t\t\tCtrl->E.active = true;\n\t\t\t\tCtrl->E.dpi = atoi (opt->arg);\n\t\t\t\tbreak;\n\t\t\tcase 'F':\t/* Set explicitly the output file name */\n\t\t\t\tif ((Ctrl->F.active = gmt_check_filearg (GMT, 'F', opt->arg, GMT_OUT, GMT_IS_TEXTSET)) != 0) {\n\t\t\t\t\tCtrl->F.file = strdup (opt->arg);\n\t\t\t\t\tif (!gmt_M_file_is_memory (Ctrl->F.file)) gmt_chop_ext (Ctrl->F.file);\t/* Make sure file name has no extension */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tn_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\t/* Set GS path */\n\t\t\t\tif ((Ctrl->G.active = gmt_check_filearg (GMT, 'G', opt->arg, GMT_IN, GMT_IS_TEXTSET)) != 0) {\n\t\t\t\t\tgmt_M_str_free (Ctrl->G.file);\n\t\t\t\t\tCtrl->G.file = malloc (strlen (opt->arg)+3);\t/* Add space for quotes */\n\t\t\t\t\tsprintf (Ctrl->G.file, \"%c%s%c\", quote, opt->arg, quote);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tn_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\t/* Do not use the ICC profile when converting gray shades */\n\t\t\t\tCtrl->I.active = true;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\t/* Give list of files to convert */\n\t\t\t\tif ((Ctrl->L.active = gmt_check_filearg (GMT, 'L', opt->arg, GMT_IN, GMT_IS_TEXTSET)) != 0)\n\t\t\t\t\tCtrl->L.file = strdup (opt->arg);\n\t\t\t\telse\n\t\t\t\t\tn_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\t/* Force Portrait mode */\n\t\t\t\tCtrl->P.active = true;\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\t/* Anti-aliasing settings */\n\t\t\t\tCtrl->Q.active = true;\n\t\t\t\tif (opt->arg[0] == 'g')\n\t\t\t\t\tmode = 0;\n\t\t\t\telse if (opt->arg[0] == 't')\n\t\t\t\t\tmode = 1;\n\t\t\t\telse {\n\t\t\t\t\tgmt_default_error (GMT, opt->option);\n\t\t\t\t\tn_errors++;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\t\t\t\tCtrl->Q.on[mode] = true;\n\t\t\t\tCtrl->Q.bits[mode] = (opt->arg[1]) ? atoi (&opt->arg[1]) : 4;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\t/* Write the GS command to STDERR */\n\t\t\t\tCtrl->S.active = true;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\t/* Select output format (optionally also request EPS) */\n\t\t\t\tCtrl->T.active = true;\n\t\t\t\tgrayscale = ((j = (int)strlen(opt->arg)) > 1 && opt->arg[j-1] == '-');\n\t\t\t\tfor (j = 0; opt->arg[j]; j++) {\n\t\t\t\t\tswitch (opt->arg[j]) {\n\t\t\t\t\t\tcase 'e':\t/* EPS */\n\t\t\t\t\t\t\tCtrl->T.eps = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'E':\t/* EPS with setpagedevice */\n\t\t\t\t\t\t\tCtrl->T.eps = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'f':\t/* PDF */\n\t\t\t\t\t\t\tCtrl->T.device = GS_DEV_PDF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'F':\t/* PDF (multipages) */\n\t\t\t\t\t\t\tCtrl->T.device = -GS_DEV_PDF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'b':\t/* BMP */\n\t\t\t\t\t\t\tCtrl->T.device = (grayscale) ? GS_DEV_BMPG : GS_DEV_BMP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'j':\t/* JPEG */\n\t\t\t\t\t\t\tCtrl->T.device = (grayscale) ? GS_DEV_JPGG : GS_DEV_JPG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'g':\t/* PNG */\n\t\t\t\t\t\t\tCtrl->T.device = (grayscale) ? GS_DEV_PNGG : GS_DEV_PNG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'G':\t/* PNG (transparent) */\n\t\t\t\t\t\t\tCtrl->T.device = GS_DEV_TPNG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'm':\t/* PPM */\n\t\t\t\t\t\t\tCtrl->T.device = GS_DEV_PPM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'p':\t/* PS */\n\t\t\t\t\t\t\tCtrl->T.ps = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 's':\t/* SVG */\n\t\t\t\t\t\t\tCtrl->T.device = GS_DEV_SVG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 't':\t/* TIFF */\n\t\t\t\t\t\t\tCtrl->T.device = (grayscale) ? GS_DEV_TIFG : GS_DEV_TIF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\t/* Just skip the trailing - for grayscale since it is handled separately */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tgmt_default_error (GMT, opt->option);\n\t\t\t\t\t\t\tn_errors++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'W':\t/* Save world file */\n\t\t\t\tn_errors += parse_GE_settings (GMT, opt->arg, Ctrl);\n\t\t\t\tbreak;\n\n\t\t\tcase 'Z':\n\t\t\t\tif (GMT->current.setting.run_mode == GMT_CLASSIC)\n\t\t\t\t\tCtrl->Z.active = true;\n\t\t\t\telse {\n\t\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Error: The -Z option is not available in MODERN mode!\\n\");\n\t\t\t\t\tn_errors++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\t/* Report bad options */\n\t\t\t\tn_errors += gmt_default_error (GMT, opt->option);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!Ctrl->T.active) Ctrl->T.device = GS_DEV_JPG;\t/* Default output device if none is specified */\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->Q.on[0] && (Ctrl->Q.bits[0] < 1 || Ctrl->Q.bits[0] > 4),\n\t                                   \"Syntax error: Anti-aliasing for graphics requires sub-sampling box of 1,2, or 4\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->Q.on[1] && (Ctrl->Q.bits[1] < 1 || Ctrl->Q.bits[1] > 4),\n\t                                   \"Syntax error: Anti-aliasing for text requires sub-sampling box of 1,2, or 4\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->In.n_files > 1 && Ctrl->L.active,\n\t                                   \"Syntax error: Cannot handle both a file list and multiple ps files in input\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->L.active && access (Ctrl->L.file, R_OK),\n\t                                   \"Error: Cannot read list file %s\\n\", Ctrl->L.file);\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->T.device == -GS_DEV_PDF && !Ctrl->F.active,\n\t                                   \"Syntax error: Creation of Multipage PDF requires setting -F option\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->L.active && (GMT->current.setting.run_mode == GMT_MODERN),\n\t                                   \"Error: Cannot use -L for list file under modern GMT mode\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, Ctrl->In.n_files > 1 && (GMT->current.setting.run_mode == GMT_MODERN),\n\t                                   \"Syntax error: No listed input files allowed under modern GMT mode\\n\");\n\n\tn_errors += gmt_M_check_condition (GMT, !Ctrl->F.active && (GMT->current.setting.run_mode == GMT_MODERN),\n\t                                   \"Syntax error: Modern GMT mode requires the -F option\\n\");\n\n\treturn (n_errors ? GMT_PARSE_ERROR : GMT_NOERROR);\n}\n\nGMT_LOCAL int64_t file_line_reader (struct GMT_CTRL *GMT, char **L, size_t *size, FILE *fp, char *notused1, uint64_t *notused2) {\n\t/* file_line_reader gets the next logical record from filepointer fp and passes it back via L.\n\t * We use this function since PS files may be shitty and contain a mixture of \\r or \\n\n\t * to indicate end of a logical record.\n\t * all_PS and pos are not used.\n\t * Empty lines are suppressed.\n\t * If the last end-of-line is missing, the last line is still produced with an end-of-line.\n\t */\n\tint c;\n\tint64_t out = 0;\n\tchar *line = *L;\n\tif (notused1 == NULL){};\t\t\t/* Just to shut up a compiler warning of \"unreferenced formal parameter\" */\n\tif (notused2 == NULL){};\t\t\t/* \t\t\"\"\t\t*/\n\twhile ((c = fgetc (fp)) > 0) {\t/* Keep reading until End-Of-File */\n\t\tif (c == '\\r' || c == '\\n') {\t/* Got logical end of record */\n\t\t\tif (!out) continue; /* Nothing in buffer ... skip */\n\t\t\tline[out] = '\\0';\t/* Terminate output string */\n\t\t\treturn out;\t/* Return number of characters in L */\n\t\t}\n\t\t/* Got a valid character in current record */\n\t\tif ((size_t)out == (*size-1)) {\t/* Need to extend our buffer; the -1 makes room for an \\0 as needed to end a string */\n\t\t\t(*size) <<= 1;\t/* Double the current buffer space */\n\t\t\tline = *L = gmt_M_memory (GMT, *L, *size, char);\n\t\t}\n\t\tline[out++] = (char)c;\t/* Add this char to our buffer */\n\t}\n\tif (!out) return EOF;\t/* Nothing in buffer ... exit with EOF */\n\tline[out] = '\\0';\t/* Terminate output string */\n\treturn out;\t\t\t/* Return number of characters in L. The next call to the routine will return EOF. */\n}\n\nvoid file_rewind (FILE *fp, uint64_t *notused) {\t/* Rewinds to start of file */\n\tif (notused == NULL){};\t\t\t/* Just to shut up a compiler warning of \"unreferenced formal parameter\" */\n\trewind (fp);\n}\n\n#define bailout(code) {gmt_M_free_options (mode); return (code);}\n#define Return(code) {Free_Ctrl (GMT, Ctrl); gmt_end_module (GMT, GMT_cpy); bailout (code);}\n\nGMT_LOCAL inline char *alpha_bits (struct PS2RASTER_CTRL *Ctrl) {\n\t/* return alpha bits which are valid for the selected driver */\n\tstatic char alpha[48];\n\tchar *c = alpha;\n\tunsigned int bits;\n\t*alpha = '\\0'; /* reset string */\n\tif (Ctrl->Q.on[0]) {\n\t\tif (Ctrl->T.device == GS_DEV_PDF || Ctrl->T.device == -GS_DEV_PDF)\n\t\t\t/* Note: cannot set GraphicsAlphaBits > 1 with a vector device */\n\t\t\tbits = 1;\n\t\telse\n\t\t\tbits = Ctrl->Q.bits[0];\n\t\tsprintf (c, \" -dGraphicsAlphaBits=%d\", bits);\n\t\tc = strrchr(c, '\\0'); /* advance to end of string */\n\t}\n\tif (Ctrl->Q.on[1]) {\n\t\tif (Ctrl->T.device == GS_DEV_PDF || Ctrl->T.device == -GS_DEV_PDF)\n\t\t\t/* Note: cannot set GraphicsAlphaBits > 1 with a vector device */\n\t\t\tbits = 1;\n\t\telse\n\t\t\tbits = Ctrl->Q.bits[1];\n\t\tsprintf (c, \" -dTextAlphaBits=%d\", bits);\n\t}\n\treturn alpha;\n}\n\nGMT_LOCAL void possibly_fill_or_outline_BoundingBox (struct GMT_CTRL *GMT, struct PS2R_A *A, FILE *fp) {\n\t/* Check if user wanted to paint or outline the BoundingBox - otherwise do nothing */\n\tchar *ptr = NULL;\n\tGMT->PSL->internal.dpp = PSL_DOTS_PER_INCH / 72.0;\t/* Dots pr. point resolution of output device, set here since no PSL initialization */\n\tif (A->paint) {\t/* Paint the background of the page */\n\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Paint background BoundingBox using paint %s\\n\", gmt_putrgb (GMT, A->fill.rgb));\n\t\tif (GMT->PSL->internal.comments) fprintf (fp, \"%% Paint background BoundingBox using paint %s\\n\", gmt_putrgb (GMT, A->fill.rgb));\n\t\tptr = PSL_makecolor (GMT->PSL, A->fill.rgb);\n\t\tfprintf (fp, \"gsave clippath %s F N U\\n\", ptr);\n\t}\n\tif (A->outline) {\t/* Draw the outline of the page */\n\t\tGMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, \"Outline background BoundingBox using pen %s\\n\", gmt_putpen (GMT, &A->pen));\n\t\tif (GMT->PSL->internal.comments) fprintf (fp, \"%% Outline background BoundingBox using pen %s\\n\", gmt_putpen (GMT, &A->pen));\n\t\t/* Double pen thickness since half will be clipped by BoundingBox */\n\t\tptr = PSL_makepen (GMT->PSL, 2.0*A->pen.width, A->pen.rgb, A->pen.style, A->pen.offset);\n\t\tfprintf (fp, \"gsave %s clippath S U\\n\", ptr);\n\t}\n}\n\n/* ---------------------------------------------------------------------------------------------- */\nGMT_LOCAL int pipe_HR_BB(struct GMTAPI_CTRL *API, struct PS2RASTER_CTRL *Ctrl, char *gs_BB, double margin, double *w, double *h) {\n\t/* Do what we do in the main code for the -A option but on a in-memory PS 'file' */\n\tchar      cmd[GMT_LEN256] = {\"\"}, buf[GMT_LEN128] = {\"\"}, t[32] = {\"\"}, *pch, c;\n\tint       fh, r, c_begin = 0;\n\tsize_t    n;\n\tbool      landscape = false;\n\tdouble    x0, y0, x1, y1, xt, yt;\n\tstruct GMT_POSTSCRIPT *PS = NULL;\n#ifdef _WIN32\n\tint       fd[2] = { 0, 0 };\n\tFILE     *fp = NULL;\n#else\n\tstruct popen2 *H = NULL;\n#endif\n\n\tsprintf (cmd, \"%s %s %s -\", Ctrl->G.file, gs_BB, Ctrl->C.arg);\t/* Set up gs command */\n\n#ifdef _WIN32\n\tif (_pipe(fd, 512, O_BINARY) == -1) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: failed to open the pipe.\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n\tif (dup2 (fd[1], fileno (stderr)) < 0) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Failed to duplicate pipe.\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n\tif (close (fd[1]) == -1) { \t\t/* Close original write end of pipe */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: failed to close write end of pipe.\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n\tif ((fp = popen (cmd, \"w\")) == NULL) {\t/* Failed popen-job, exit */\n\t\tGMT_Report(API, GMT_MSG_NORMAL, \"Cannot execute GhostScript command.\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n#else\n\tif ((H = gmt_popen2 (cmd)) == NULL) {\t/* Failed popen-job, exit */\n\t\tGMT_Report(API, GMT_MSG_NORMAL, \"Cannot execute GhostScript command.\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n#endif\n\n\t/* Allocate GMT_POSTSCRIPT struct to hold the string that lives inside GMT->PSL */\n\tPS = gmt_M_memory (API->GMT, NULL, 1, struct GMT_POSTSCRIPT);\n\tPS->data = PSL_getplot (API->GMT->PSL);\t\t/* Get pointer to the internal plot buffer */\n\tPS->n_bytes = API->GMT->PSL->internal.n;\t/* Length of plot buffer; note P->n_alloc = 0 since nothing was allocated here */\n\n\t/* Send the PS down ghostscripts throat */\n#ifdef _WIN32\n\tfwrite (PS->data, sizeof(char), PS->n_bytes, fp);\n\tfflush (fp);\n\tif (pclose (fp) == -1)\n\t\tGMT_Report(API, GMT_MSG_NORMAL, \"Error closing pipe used for GhostScript command.\\n\");\n\tfh = fd[0];\t/* File handle for reading */\n#else\n \twrite (H->fd[1], PS->data, PS->n_bytes);\n\t/* Now closed for writing */\n    gmt_pclose2 (&H, 1);\n\tfh = H->fd[0];\t/* File handle for reading */\n#endif\n\n\t/* Now read the image from input pipe fd[0] */\n\twhile (read(fh, t, 1U) && t[0] != '\\n'); \t/* Consume first line that has the BoundingBox */\n\tn = 0;\n\twhile (read(fh, t, 1U) && t[0] != '\\n')\t\t/* Read second line which has the HiResBoundingBox */\n\t\tbuf[n++] = t[0];\n#ifdef _WIN32\n\tif (close (fd[0]) == -1) { \t\t/* Close read end of pipe */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: failed to close read end of pipe.\\n\");\n\t\tgmt_M_free (API->GMT, PS);\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n#else\n\t/* Now closed for reading */\n \tgmt_pclose2 (&H, 0);\n#endif\n\n\tsscanf (buf, \"%s %lf %lf %lf %lf\", t, &x0, &y0, &x1, &y1);\n\tc = PS->data[500];\n\tPS->data[500] = '\\0';\t\t\t/* Temporary cut the string to not search the whole file */\n\tpch = strstr(PS->data, \"Landscape\");\n\tif (pch != NULL) landscape = true;\n\tPS->data[500] = c;\t\t\t\t/* Restore the deleted character */\n\n\tif (landscape)\t\t\t\t\t/* We will need these in pipe_ghost() */\n\t\txt = -x1, yt = -y0, *w = y1-y0, *h = x1-x0, r = -90;\n\telse\n\t\txt = -x0, yt = -y0, *w = x1-x0, *h = y1-y0, r = 0;\n\n\t/* Add a margin if user requested it (otherwise margin = 0) */\n\t*w += 2 * margin;       *h += 2 * margin;\n\txt += margin;           yt += margin;\n\n\tsprintf (buf, \"BoundingBox: 0 0 %.0f %.0f\", ceil(*w), ceil(*h));\n\tif ((pch = strstr (PS->data, \"BoundingBox\")) != NULL) {\t\t/* Find where is the BB */\n\t\tfor (n = 0; n < strlen(buf); n++)                       /* and update it */\n\t\t\tpch[n] = buf[n];\n\t\twhile (pch[n] != '\\n') pch[n++] = ' ';                  /* Make sure that there are only spaces till EOL */\n\t}\n\telse\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: Something very odd the GMT PS does not have a %%BoundingBox\\n\");\n\n\tsprintf (buf, \"HiResBoundingBox: 0 0 %.4f %.4f\", *w, *h);\n\tif ((pch = strstr(PS->data, \"HiResBoundingBox\")) != NULL) {\t/* Find where is the HiResBB */\n\t\tfor (n = 0; n < strlen(buf); n++)                       /* and update it */\n\t\t\tpch[n] = buf[n];\n\t}\n\telse\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: Something very odd the GMT PS does not have a %%HiResBoundingBox\\n\");\n\n\t/* Find where is the setpagedevice line */\n\tif ((pch = strstr(PS->data, \"setpagedevice\")) != NULL) {\n\t\twhile (pch[c_begin] != '\\n') c_begin--;\t\tc_begin++;\t/* It receded one too much */\n\t\t/* So now we know where the line starts. Put a 'translate' command in its place. */\n\t\t(r == 0) ? sprintf(buf, \"%.3f %.3f translate\", xt, yt) : sprintf(buf, \"%d rotate\\n%.3f %.3f translate\", r, xt, yt);\n\t\tfor (n = 0; n < strlen(buf); n++, c_begin++) pch[c_begin] = buf[n];\n\t\twhile (pch[c_begin] != '\\n')  pch[c_begin++] = ' ';     /* Make sure that there are only spaces till EOL */\n\t}\n\telse {\n\t\tif ((pch = strstr(PS->data, \" translate\")) != NULL) {\t\t/* If user runs through this function twice 'setpagedevice' was changed to 'translate' */\n\t\t\tdouble old_xt, old_yt;\n\t\t\twhile (pch[c_begin] != '\\n') c_begin--;\t\tc_begin++;\t/* Goto line start but it receded one too much */\n\t\t\tsscanf (&pch[c_begin], \"%lf %lf\", &old_xt, &old_yt);\n\t\t\t(r == 0) ? sprintf(buf, \"%.3f %.3f translate\", xt + old_xt, yt + old_xt) : sprintf(buf, \"%d rotate\\n%.3f %.3f translate\", r, xt + old_xt, yt + old_xt);\n\t\t\tfor (n = 0; n < strlen(buf); n++, c_begin++) pch[c_begin] = buf[n];\n\t\t\twhile (pch[c_begin] != '\\n') pch[c_begin++] = ' ';\n\t\t}\n\t\telse\n\t\t\tGMT_Report(API, GMT_MSG_NORMAL, \"Warning: Something very odd the GMT PS does not have the setpagedevice line\\n\");\n\t}\n\n\tgmt_M_free (API->GMT, PS);\n\n\treturn GMT_NOERROR;\n}\n/* ---------------------------------------------------------------------------------------------- */\n\nGMT_LOCAL int pipe_ghost (struct GMTAPI_CTRL *API, struct PS2RASTER_CTRL *Ctrl, char *gs_params, double w, double h, char *out_file) {\n\t/* Run the command that converts the PostScript into a raster format, but using a in-memory PS as source.\n\t   For that we use the popen function to run the GS command. The biggest problem, however, is that popen only\n\t   access one pipe and we need two. One for the PS input and the other for the raster output. There are popen\n\t   versions (popen2) that have that capacity, but not the one on Windows so we resort to a trick using both\n\t   popen() and pipe().\n\n\t   w,h are the raster Width and Height calculated by a previous call to pipe_HR_BB().\n\t   out_file is a string with two different meanings:\n\t      1. If it's empty than we save the raster in a GMT_IMAGE structure\n\t      2. If it holds a file name plus the settings for that driver, than we save the result in a file.\n\t*/\n\tchar      cmd[1024] = {\"\"}, buf[GMT_LEN128], t[16] = {\"\"};\n\tint       fd[2] = {0, 0}, fh, n, k, pix_w, pix_h;\n\tuint64_t  dim[3], nXY, row, col, band, nCols, nRows, nBands;\n\tunsigned char *tmp;\n\tunsigned int nopad[4] = {0, 0, 0, 0};\n\tstruct GMT_IMAGE *I = NULL;\n\tstruct GMT_POSTSCRIPT *PS = NULL;\n#ifdef _WIN32\n\tuint64_t  n_bytes;\n#else\n\tstruct popen2 *H = NULL;\n#endif\n\tFILE     *fp = NULL;\n\n\t/* sprintf(cmd, \"gswin64c -q -r300x300 -sDEVICE=ppmraw -sOutputFile=- -\"); */\n\tpix_w = urint (ceil (w * Ctrl->E.dpi / 72.0));\n\tpix_h = urint (ceil (h * Ctrl->E.dpi / 72.0));\n\tsprintf (cmd, \"%s -r%d -g%dx%d \", Ctrl->G.file, Ctrl->E.dpi, pix_w, pix_h);\n\tif (strlen(gs_params) < 450) strcat (cmd, gs_params);\t/* We know it is but Coverity doesn't, and complains */\n\n\tif (out_file[0] == '\\0') {\t\t/* Need to open a pipe to capture the popen output, which will contain the raster */\n\t\tstrcat (cmd, \" -sDEVICE=ppmraw -sOutputFile=- -\");\n#ifdef _WIN32\n\t\tif (_pipe(fd, 145227600, O_BINARY) == -1) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: failed to open the pipe.\\n\");\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n\t\tif (dup2 (fd[1], fileno (stdout)) < 0) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Failed to duplicate pipe.\\n\");\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n\t\tif (close (fd[1]) == -1) { \t\t/* Close original write end of pipe */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: failed to close write end of pipe.\\n\");\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n\t\tif ((fp = popen (cmd, \"w\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Cannot execute GhostScript command.\\n\");\n\t\t\tgmt_M_free (API->GMT, PS);\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n#else\n\t\tif ((H = gmt_popen2 (cmd)) == NULL) {\t/* Failed popen-job, exit */\n\t\t\tGMT_Report(API, GMT_MSG_NORMAL, \"Cannot execute GhostScript command.\\n\");\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n#endif\n\t}\n\telse {\t/* Only need a unidirectional pipe as supported by all since gs output is written to a file */\n\t\tstrncat (cmd, out_file, 1023);\n\t\tif ((fp = popen (cmd, \"w\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Cannot execute GhostScript command.\\n\");\n\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t}\n\t}\n\t\n\tPS = gmt_M_memory (API->GMT, NULL, 1, struct GMT_POSTSCRIPT);\n\tPS->data = PSL_getplot (API->GMT->PSL);\t\t/* Get pointer to the plot buffer */\n\tPS->n_bytes = API->GMT->PSL->internal.n;\t/* Length of plot buffer; note P->n_alloc = 0 since nothing was allocated here */\n\n\t/* Send the PS down ghostscript's throat */\n#ifdef _WIN32\n\tif ((n_bytes = fwrite (PS->data, sizeof(char), PS->n_bytes, fp)) != PS->n_bytes)\n\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t            \"Error writing PostScript buffer to GhostScript process. Bytes written = %ld, should have been %ld\\n\", n_bytes, PS->n_bytes);\n\tif (fflush (fp) == EOF)\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error flushing GhostScript process.\\n\");\n\tif (pclose (fp) == -1)\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error closing GhostScript process.\\n\");\n\tfh = fd[0];\t/* File handle for reading */\n#else\n\tif (fp) {\t/* Did popen after all since we have an output filename */\n\t\tif (fwrite (PS->data, sizeof(char), PS->n_bytes, fp) != PS->n_bytes)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error writing PostScript buffer to GhostScript process.\\n\");\n\t\tif (fflush (fp) == EOF)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error flushing GhostScript process.\\n\");\n\t\tif (pclose (fp) == -1)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error closing GhostScript process.\\n\");\n\t}\n\telse {\t/* On non-Windows and want a raster back */\n \t\twrite (H->fd[1], PS->data, PS->n_bytes);\n\t\t/* Now closed for writing */\n    \tgmt_pclose2 (&H, 1);\n\t\tfh = H->fd[0];\t/* File handle for reading */\n\t}\n#endif\n\n\t/* And now restore the original BB & HiResBB so that the PS data can be reused if wanted */\n\tgmt_M_free (API->GMT, PS);\n\n\t/* ----------- IF WE WROTE A FILE THEN WE ARE DONE AND WILL RETURN RIGHT NOW -------------- */\n\tif (out_file[0] != '\\0')\n\t\treturn GMT_NOERROR;\n\t/* ---------------------------------------------------------------------------------------- */\n\n\tif ((n = read (fh, buf, 3U)) != 3)\t\t\t\t/* Consume first header line */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"pipe_ghost: failed read first line in popen store. Expect failures.\\n\");\n\twhile (read (fh, buf, 1U) && buf[0] != '\\n'); \t/* OK, by the end of this we are at the end of second header line */\n\tn = 0;\n\twhile (read(fh, buf, 1U) && buf[0] != ' ') \t\t/* Get string with number of columns from 3rd header line */\n\t\tt[n++] = buf[0];\n\tdim[GMT_X] = atoi (t);\n\tn = 0;\n\twhile (read(fh, buf, 1U) && buf[0] != '\\n') \t\t/* Get string with number of rows from 3rd header line */\n\t\tt[n++] = buf[0];\n\tt[n] = '\\0';\t\t\t\t\t\t/* Make sure no character is left from previous usage */\n\n\twhile (read(fh, buf, 1U) && buf[0] != '\\n');\t\t/* Consume fourth header line */\n\n\tdim[GMT_Y] = atoi (t);\n\tdim[GMT_Z] = 3;\t/* This might change if we do monochrome at some point */\n\tGMT_Report (API, GMT_MSG_VERBOSE, \"Image dimensions %d\\t%d\\n\", dim[GMT_X], dim[GMT_Y]);\n\n\tif ((I = GMT_Create_Data (API, GMT_IS_IMAGE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, dim, NULL, NULL, 1, 0, NULL)) == NULL) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Could not create Image structure\\n\");\n\t\treturn GMT_RUNTIME_ERROR;\n\t}\n\n\tnCols = dim[GMT_X];\t\tnRows = dim[GMT_Y];\t\tnBands = dim[2];\tnXY = nRows * nCols;\n\ttmp   = gmt_M_memory(API->GMT, NULL, nCols * nBands, char);\n\tif (!strncmp(I->header->mem_layout, \"TCP\", 3)) {\t\t/* Images.jl in Julia wants this */\n\t\tfor (row = 0; row < nRows; row++) {\n\t\t\tif ((k = read (fd[0], tmp, (unsigned int)(nCols * nBands))) == 0) {\t/* Read a row of nCols by nBands bytes of data */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Could not read row from pipe into Image structure\\n\");\n\t\t\t\tgmt_M_free (API->GMT, tmp);\n\t\t\t\treturn GMT_RUNTIME_ERROR;\n\t\t\t}\n\t\t\tfor (col = n = 0; col < nCols; col++)\n\t\t\t\tfor (band = 0; band < nBands; band++)\n\t\t\t\t\tI->data[row*nBands + col*nBands*nRows + band] = tmp[n++];\n\t\t}\n\t}\n\telse if (!strncmp(I->header->mem_layout, \"TRP\", 3)) {\t/* Very cheap this one since is gs native order. */\n\t\tread (fd[0], I->data, (unsigned int)(nCols * nRows * nBands));\t\t/* ... but may overflow */\n\t}\n\telse {\n\t\tfor (row = 0; row < nRows; row++) {\n\t\t\tread (fd[0], tmp, (unsigned int)(nCols * nBands));\t/* Read a row of nCols by nBands bytes of data */\n\t\t\tfor (col = n = 0; col < nCols; col++)\n\t\t\t\tfor (band = 0; band < nBands; band++)\n\t\t\t\t\tI->data[row + col*nRows + band*nXY] = tmp[n++];\t/* Band interleaved, the best for MEX. */\n\t\t}\n\t}\n\tgmt_M_free (API->GMT, tmp);\n\n#ifdef _WIN32\n\tif (close (fh) == -1) \t\t/* Close read end of pipe */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Failed to close read end of pipe.\\n\");\n#else\n\t/* Now closed for reading */\n \tgmt_pclose2 (&H, 0);\n#endif\n\n\tI->type = GMT_CHAR;\n\tI->header->n_columns = (uint32_t)dim[GMT_X];\tI->header->n_rows = (uint32_t)dim[GMT_Y];\tI->header->n_bands = (uint32_t)dim[GMT_Z];\n\tI->header->registration = GMT_GRID_PIXEL_REG;\n\tgmt_M_grd_setpad (API->GMT, I->header, nopad);          /* Copy the no pad to the header */\n\tif (GMT_Write_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, Ctrl->F.file, I) != GMT_NOERROR)\n\t\treturn GMT_RUNTIME_ERROR;\n\n\treturn GMT_NOERROR;\t/* Done here */\n}\n\n/* ---------------------------------------------------------------------------------------------- */\nGMT_LOCAL int in_mem_PS_convert(struct GMTAPI_CTRL *API, struct PS2RASTER_CTRL *Ctrl, char **ps_names, char *gs_BB, char *gs_params, char *device[], char *device_options[], char *ext[]) {\n\tchar out_file[GMT_LEN256] = {\"\"};\n\tint    error = 0;\n\tdouble margin = 0, w = 0, h = 0;\t/* Width and height in pixels of the final raster cropped of the outer white spaces */\n\n\tif (ps_names[0][1])\t\t/* See if we have a margin request */\n\t\tmargin = gmt_M_to_points (API->GMT, &ps_names[0][1]);\n\n\tif (API->GMT->PSL->internal.pmode != 3) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Internal PSL PostScript is only half-baked [mode = %d]\\n\",\n\t\t            API->GMT->PSL->internal.pmode);\n\t\terror++;\n\t}\n\tif (error) \t\t\t/* Return in error state */\n\t\treturn error;\n\n\tif (pipe_HR_BB (API, Ctrl, gs_BB, margin, &w, &h))\t\t/* Apply the -A stuff to the in-memory PS */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Failed to fish the HiResBoundingBox from PS-in-memory .\\n\");\n\n\tif (Ctrl->T.active) {\t\t/* Then write the converted file into a file instead of storing it into a Image struct */\n\t\tchar t[GMT_LEN256] = {\"\"};\n\t\tsprintf (t, \" -sDEVICE=%s %s -sOutputFile=\", device[Ctrl->T.device], device_options[Ctrl->T.device]);\n\t\tstrcat (out_file, t);\n\t\tif (API->external && Ctrl->F.active && !gmt_M_file_is_memory (Ctrl->F.file)) {\n\t\t\tstrncpy (t, Ctrl->F.file, GMT_LEN256-1);\n\t\t}\n\t\telse {\n\t\t\tif (API->tmp_dir)\t/* Use the established temp directory */\n\t\t\t\tsprintf (t, \"%s/psconvert_tmp\", API->tmp_dir);\n\t\t\telse\t/* Must dump it in current directory */\n\t\t\t\tsprintf (t, \"psconvert_tmp\");\n\t\t}\n\t\tstrncat (t, ext[Ctrl->T.device], 5);\n\t\tif (API->external) {\t\t/* Apparently we cannot have the output file name inside quotes */\n\t\t\tstrcat (out_file, t);\t\tstrcat (out_file, \" -\");\n\t\t}\n\t\telse {\n\t\t\tstrncat (out_file, squote, 1);\tstrcat (out_file, t);\tstrncat (out_file, squote, 1);\n\t\t\tstrcat (out_file, \" -\");\n\t\t}\n\t}\n\tif (pipe_ghost(API, Ctrl, gs_params, w, h, out_file)) {\t/* Run ghostscript to convert the PS to the desired output format */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Failed to wrap ghostscript in pipes.\\n\");\n\t\terror++;\n\t}\n\treturn error;\n}\n\nEXTERN_MSC int gmt_copy (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, char *ifile, char *ofile);\n\nint GMT_psconvert (void *V_API, int mode, void *args) {\n\tunsigned int i, j, k, pix_w = 0, pix_h = 0, got_BBatend;\n\tint sys_retval = 0, r, pos_file, pos_ext, error = 0;\n\tsize_t len, line_size = 0U;\n\tuint64_t pos = 0;\n\tbool got_BB, got_HRBB, file_has_HRBB, got_end, landscape, landscape_orig, set_background = false;\n\tbool excessK, setup, found_proj = false, isGMT_PS = false, return_image = false, delete = false, file_processing = true;\n\tbool transparency = false, look_for_transparency, BeginPageSetup_here = false, add_grestore = false;\n\n\tdouble xt, yt, xt_bak, yt_bak, w, h, x0 = 0.0, x1 = 612.0, y0 = 0.0, y1 = 828.0;\n\tdouble west = 0.0, east = 0.0, south = 0.0, north = 0.0;\n\tdouble old_scale_x = 1, old_scale_y = 1;\n\n\tsize_t n_alloc = GMT_SMALL_CHUNK;\n\n\tchar **ps_names = NULL;\n\tchar ps_file[PATH_MAX] = \"\", no_U_file[PATH_MAX] = \"\", clean_PS_file[PATH_MAX] = \"\", tmp_file[PATH_MAX] = \"\",\n\t     out_file[PATH_MAX] = \"\", BB_file[PATH_MAX] = \"\";\n\tchar *line = NULL, c1[20] = {\"\"}, c2[20] = {\"\"}, c3[20] = {\"\"}, c4[20] = {\"\"},\n\t     cmd[GMT_BUFSIZ] = {\"\"}, proj4_name[20] = {\"\"}, *quiet = NULL;\n\tchar *gs_params = NULL, *gs_BB = NULL, *proj4_cmd = NULL;\n\tchar *device[N_GS_DEVICES] = {\"\", \"pdfwrite\", \"svg\", \"jpeg\", \"png16m\", \"ppmraw\", \"tiff24nc\", \"bmp16m\", \"pngalpha\",\n\t                              \"jpeggray\", \"pnggray\", \"tiffgray\", \"bmpgray\"};\n\tchar *device_options[N_GS_DEVICES] = {\n\t\t/* extra options to pass to individual drivers */\n\t\t\"\",\n\t\t\"\", /* pdfwrite */\n\t\t\"\", /* svg */\n\t\t\"-dJPEGQ=90\", /* jpeg */\n\t\t\"\", /* png16m */\n\t\t\"\", /* ppmraw */\n\t\t\"-sCompression=lzw\", /* tiff24nc */\n\t\t\"\", /* bmp16m */\n\t\t\"\", /* pngalpha */\n\t\t\"-dJPEGQ=90\", /* jpeggray */\n\t\t\"\", /* pnggray */\n\t\t\"-sCompression=lzw\", /* tiffgray */\n\t\t\"\"}; /* bmpgray */\n\tchar *ext[N_GS_DEVICES] = {\".eps\", \".pdf\", \".svg\", \".jpg\", \".png\", \".ppm\", \".tif\", \".bmp\", \".png\", \".jpg\", \".png\", \".tif\", \".bmp\"};\n\tchar *RefLevel[N_KML_ELEVATIONS] = {\"clampToGround\", \"relativeToGround\", \"absolute\", \"relativeToSeaFloor\", \"clampToSeaFloor\"};\n#ifdef WIN32\n\tchar at_sign[2] = \"@\";\n#else\n\tchar at_sign[2] = \"\";\n#endif\n\n#ifdef HAVE_GDAL\n\tstruct GMT_GDALREAD_IN_CTRL  *to_gdalread = NULL;\n\tstruct GMT_GDALREAD_OUT_CTRL *from_gdalread = NULL;\n#endif\n\n\tFILE *fp = NULL, *fpo = NULL, *fpb = NULL, *fp2 = NULL, *fpw = NULL;\n\n\tstruct GMT_OPTION *opt = NULL;\n\tstruct PS2RASTER_CTRL *Ctrl = NULL;\n\tstruct GMT_CTRL *GMT = NULL, *GMT_cpy = NULL;\n\tstruct GMT_OPTION *options = NULL;\n\tstruct GMTAPI_CTRL *API = gmt_get_api_ptr (V_API);\t/* Cast from void to GMTAPI_CTRL pointer */\n\tstruct { int major, minor; } gsVersion = {0, 0};\n\tstruct GMT_POSTSCRIPT *PS = NULL;\n\n\t/*----------------------- Standard module initialization and parsing ----------------------*/\n\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\n\tif (mode == GMT_MODULE_PURPOSE) return (usage (API, GMT_MODULE_PURPOSE));\t/* Return the purpose of program */\n\toptions = GMT_Create_Options (API, mode, args);\tif (API->error) return (API->error);\t/* Set or get option list */\n\n\tif (!options || options->option == GMT_OPT_USAGE) bailout (usage (API, GMT_USAGE));/* Return the usage message */\n\tif (options->option == GMT_OPT_SYNOPSIS) bailout (usage (API, GMT_SYNOPSIS));\t/* Return the synopsis */\n\n\t/* Parse the command-line arguments */\n\n\tif ((GMT = gmt_init_module (API, THIS_MODULE_LIB, THIS_MODULE_NAME, THIS_MODULE_KEYS, THIS_MODULE_NEEDS, &options, &GMT_cpy)) == NULL) bailout (API->error); /* Save current state */\n\tif (GMT_Parse_Common (API, THIS_MODULE_OPTIONS, options)) Return (API->error);\n\tCtrl = New_Ctrl (GMT);\t/* Allocate and initialize a new control structure */\n\tif ((error = parse (GMT, Ctrl, options)) != 0) Return (error);\n\n\t/*---------------------------- This is the psconvert main code ----------------------------*/\n\n\tif (!Ctrl->L.active && (GMT->current.setting.run_mode == GMT_CLASSIC) && (Ctrl->In.n_files == 0)) {\t/* No files given, bail */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"No PostScript files specified - exiting.\\n\");\n\t\tReturn (GMT_NOERROR);\n\t}\n\n\t/* Test if GhostScript can be executed (version query) */\n\tsprintf(cmd, \"%s --version\", Ctrl->G.file);\n\tif ((fp = popen(cmd, \"r\")) != NULL) {\n\t\tint n;\n\t\tn = fscanf(fp, \"%d.%d\", &gsVersion.major, &gsVersion.minor);\n\t\tif (pclose(fp) == -1)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error closing GhostScript version query.\\n\");\n\t\tif (n != 2) {\n\t\t\t/* command execution failed or cannot parse response */\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Failed to parse response to GhostScript version query [n = %d %d %d].\\n\",\n\t\t\t            n, gsVersion.major, gsVersion.minor);\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\t}\n\telse { /* failed to open pipe */\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Cannot execute GhostScript (%s).\\n\", Ctrl->G.file);\n\t\tReturn (GMT_RUNTIME_ERROR);\n\t}\n\n\tif (Ctrl->T.device == GS_DEV_SVG && (gsVersion.major > 9 || (gsVersion.major == 9 && gsVersion.minor >= 16))) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Your ghostscript version (%d.%d) no longer supports the SVG device.\\n\",\n\t\t            gsVersion.major, gsVersion.minor);\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"We recommend converting to PDF and then installing the pdf2svg package.\\n\");\n\t\tReturn (GMT_RUNTIME_ERROR);\n\t}\n\tif (Ctrl->F.active && (Ctrl->L.active || Ctrl->D.active)) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: Option -F and options -L OR -D are mutually exclusive. Ignoring option -F.\\n\");\n\t\tCtrl->F.active = false;\n\t}\n\n\tif (Ctrl->F.active && Ctrl->In.n_files > 1 && Ctrl->T.device != -GS_DEV_PDF) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: Option -F is incompatible with multiple inputs. Ignoring option -F.\\n\");\n\t\tCtrl->F.active = false;\n\t}\n\n\tif (Ctrl->F.active && gmt_M_file_is_memory (Ctrl->F.file)) {\n\t\tif (Ctrl->T.device <= GS_DEV_SVG || Ctrl->In.n_files > 1) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Can only return one (PS or PDF) raster image to calling program via memory array.\\n\");\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\t\treturn_image = true;\n#ifndef HAVE_GDAL\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Selecting ppmraw device since GDAL not available.\\n\");\n\t\tCtrl->T.device = GS_DEV_PPM;\n#endif\n\t}\n\n\tif (GMT->current.setting.run_mode == GMT_MODERN) {\t/* Finalize hidden PS file first */\n\t\tif ((k = gmt_set_psfilename (GMT)) == 0) {\t/* Get hidden file name for PS */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"No hidden PS file %s found\\n\", GMT->current.ps.filename);\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\t\tif ((fp = PSL_fopen (GMT->PSL, GMT->current.ps.filename, \"a\")) == NULL) {\t/* Must open inside PSL DLL */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Cannot append to file %s\\n\", GMT->current.ps.filename);\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\t\tPSL_endplot (GMT->PSL, 1);\t/* Finalize the PS plot */\n\t\tif (PSL_fclose (GMT->PSL)) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_NORMAL, \"Error: Unable to close hidden PS file %s!\\n\", GMT->current.ps.filename);\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\t}\n\t\n\t/* Parameters for all the formats available */\n\n\tif (gsVersion.major >= 9 && gsVersion.minor >= 21)\n\t\t/* Artifex says that the -dSCANCONVERTERTYPE=2 new scan converter is faster (confirmed) and\n\t\t   will be the default in a future release. Since it was introduced in 9.21 we start using it\n\t\t   right now and remove this conditional once it becomes the default */\n\t\tgs_params = \"-q -dSAFER -dNOPAUSE -dBATCH -dPDFSETTINGS=/prepress -dDownsampleColorImages=false -dDownsampleGrayImages=false -dDownsampleMonoImages=false -dUseFlateCompression=true -dEmbedAllFonts=true -dSubsetFonts=true -dMonoImageFilter=/FlateEncode -dAutoFilterGrayImages=false -dGrayImageFilter=/FlateEncode -dAutoFilterColorImages=false -dColorImageFilter=/FlateEncode -dSCANCONVERTERTYPE=2\";\n\telse\n\t\tgs_params = \"-q -dSAFER -dNOPAUSE -dBATCH -dPDFSETTINGS=/prepress -dDownsampleColorImages=false -dDownsampleGrayImages=false -dDownsampleMonoImages=false -dUseFlateCompression=true -dEmbedAllFonts=true -dSubsetFonts=true -dMonoImageFilter=/FlateEncode -dAutoFilterGrayImages=false -dGrayImageFilter=/FlateEncode -dAutoFilterColorImages=false -dColorImageFilter=/FlateEncode\";\n\n\tgs_BB = \"-q -dSAFER -dNOPAUSE -dBATCH -sDEVICE=bbox\"; /* -r defaults to 4000, see http://pages.cs.wisc.edu/~ghost/doc/cvs/Devices.htm#Test */\n\n\tadd_to_list (Ctrl->C.arg, \"-dMaxBitmap=2147483647\");\t/* Add this as GS option to fix bug in GS */\n\n\tif (Ctrl->W.kml && !(Ctrl->T.device == GS_DEV_JPG ||\n\t    Ctrl->T.device == GS_DEV_JPGG || Ctrl->T.device == GS_DEV_TIF ||\n\t    Ctrl->T.device == GS_DEV_TIFG || Ctrl->T.device == GS_DEV_PNG ||\n\t    Ctrl->T.device == GS_DEV_TPNG || Ctrl->T.device == GS_DEV_PNGG) ) {\n\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: As far as we know selected raster type is unsupported by GE.\\n\");\n\t}\n\n\tif (Ctrl->W.active) {\t/* Implies -P and -A (unless -A- is set ) */\n\t\tCtrl->P.active = Ctrl->A.active = true;\n\t\tif (Ctrl->A.reset) Ctrl->A.active = false;\n\t}\n\n\t/* Use default DPI if not already set */\n\tif (Ctrl->E.dpi <= 0) Ctrl->E.dpi = (Ctrl->T.device == GS_DEV_PDF) ? 720 : 300;\n\n\tline_size = GMT_LEN128;\n\tline = gmt_M_memory (GMT, NULL, line_size, char);\t/* Initial buffer size */\n\n\t/* Multiple files in a file with their names */\n\tif (Ctrl->L.active) {\n\t\tstruct GMT_TEXTSET *T = NULL;\n\t\tif ((T = GMT_Read_Data (API, GMT_IS_TEXTSET, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, Ctrl->L.file, NULL)) == NULL) {\n\t\t\tgmt_M_free (GMT, line);\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\n\t\tCtrl->In.n_files = (unsigned int)T->n_records;\n\t\tps_names = gmt_M_memory (GMT, NULL, T->n_records, char *);\n\t\tfor (k = 0; k < T->table[0]->segment[0]->n_rows; k++)\t/* Set pointers */\n\t\t\tps_names[k] = T->table[0]->segment[0]->data[k];\n\t}\n\telse if (Ctrl->In.n_files) {\t/* One or more files given on command line */\n\t\tps_names = gmt_M_memory (GMT, NULL, Ctrl->In.n_files, char *);\n\t\tj = 0;\n\t\tfor (opt = options; opt; opt = opt->next) {\n\t\t\tif (opt->option != '<') continue;\n\t\t\tps_names[j++] = strdup (opt->arg);\n\t\t}\n\t}\n\telse if (GMT->current.setting.run_mode == GMT_MODERN) {\t/* Just that one hidden PS file */\n\t\tps_names = gmt_M_memory (GMT, NULL, 1, char *);\n\t\tps_names[0] = strdup (GMT->current.ps.filename);\n\t\tCtrl->In.n_files = 1;\n\t}\n\n\t/* -------------------- Special case of in-memory PS. Process it and return ------------------- */\n\tif (API->external && Ctrl->In.n_files == 1 && ps_names[0][0] == '=') {\n\t\tif (!return_image && !Ctrl->T.active) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Internal PSL PostScript rip requires output file via -F\\n\");\n\t\t\terror++;\n\t\t}\n\t\telse\n\t\t\terror = in_mem_PS_convert(API, Ctrl, ps_names, gs_BB, gs_params, device, device_options, ext);\n\n\t\tif (!Ctrl->L.active) gmt_M_str_free (ps_names[0]);\t\t/* Otherwise ps_names contents are the Garbageman territory */\n\t\tgmt_M_free (GMT, ps_names);\n\t\tgmt_M_free (GMT, line);\n\t\tReturn (error ? GMT_RUNTIME_ERROR : GMT_NOERROR);\t\t/* Done here */\n\t}\n\t/* --------------------------------------------------------------------------------------------- */\n\n\t/* Let gray 50 be rasterized as 50/50/50. See http://gmtrac.soest.hawaii.edu/issues/50 */\n\tif (!Ctrl->I.active && ((gsVersion.major == 9 && gsVersion.minor >= 5) || gsVersion.major > 9))\n\t\tadd_to_list (Ctrl->C.arg, \"-dUseFastColor=true\");\n\n\t/* --------------------------------------------------------------------------------------------- */\n\t/* ------    If a multi-page PDF file creation is requested, do it and exit.   ------------------*/\n\t/* --------------------------------------------------------------------------------------------- */\n\tif (Ctrl->T.active && Ctrl->T.device == -GS_DEV_PDF) {\n\t\tchar *all_names_in = NULL, *cmd2 = NULL;\n\t\tint   error = 0;\n\n\t\tn_alloc = 0;\n\t\tfor (k = 0; k < Ctrl->In.n_files; k++)\n\t\t\tn_alloc += (strlen (ps_names[k]) + 3);\t/* 3 = 2 quotes plus space */\n\t\tall_names_in = gmt_M_memory (GMT, NULL, n_alloc, char);\n\t\tfor (k = 0; k < Ctrl->In.n_files; k++) {\n\t\t\tadd_to_qlist (all_names_in, ps_names[k]);\n\t\t\tif (!Ctrl->L.active) gmt_M_str_free (ps_names[k]);\t\t/* Otherwise ps_names contents are the Garbageman territory */\n\t\t}\n\t\tcmd2 = gmt_M_memory (GMT, NULL, n_alloc + PATH_MAX, char);\n\t\tsprintf (cmd2, \"%s%s -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite %s%s -r%d -sOutputFile=%c%s.pdf%c %s\",\n\t\t\tat_sign, Ctrl->G.file, Ctrl->C.arg, alpha_bits(Ctrl), Ctrl->E.dpi, quote, Ctrl->F.file, quote, all_names_in);\n\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd2);\n\t\tsys_retval = system (cmd2);\t\t/* Execute the GhostScript command */\n\t\tif (sys_retval) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd2, sys_retval);\n\t\t\terror++;\n\t\t}\n\t\tif (!error && Ctrl->S.active)\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s\\n\", cmd2);\n\n\t\tgmt_M_free (GMT, all_names_in);\n\t\tgmt_M_free (GMT, cmd2);\n\t\tgmt_M_free (GMT, ps_names);\n\t\tgmt_M_free (GMT, line);\n\t\tReturn (error ? GMT_RUNTIME_ERROR : GMT_NOERROR);\t\t/* Done here */\n\t}\n\t/* ----------------------------------------------------------------------------------------------- */\n\n\tPS = gmt_M_memory (GMT, NULL, 1, struct GMT_POSTSCRIPT);\t/* Only used if API passes = */\n\n\t/* Loop over all input files */\n\n\tfor (k = 0; k < Ctrl->In.n_files; k++) {\n\t\texcessK = delete = false;\n\t\t*out_file = '\\0'; /* truncate string */\n\t\tif (gmt_M_file_is_memory (ps_names[k])) {\t/* For now we create temp file from PS given via memory so code below will work */\n\t\t\tsprintf (ps_file, \"%s/psconvert_stream_%d.ps\", API->tmp_dir, (int)getpid());\n\t\t\tif (gmt_copy (API, GMT_IS_POSTSCRIPT, GMT_OUT, ps_names[k], ps_file)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to make temp file %s from %s. Skipping.\\n\", ps_file, ps_names[k]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdelete = true;\t/* Must delete this temporary file when done */\n\t\t}\n\t\telse\n\t\t\tstrncpy (ps_file, ps_names[k], PATH_MAX-1);\n\n\t\tif (file_processing && (fp = fopen (ps_file, \"r\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Cannot open file %s\\n\", ps_file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"Processing %s...\\n\", ps_file);\n\n\t\tif (Ctrl->A.strip) {\t/* Must strip off the GMT timestamp stuff, but pass any font encodings */\n\t\t\tint dump = true;\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Strip GMT time-stamp...\\n\");\n\t\t\tsprintf (no_U_file, \"%s/psconvert_%db.eps\", Ctrl->D.dir, (int)getpid());\n\t\t\tif ((fp2 = fopen (no_U_file, \"w+\")) == NULL) {\n\t\t\t\tunsigned int kk;\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to create a temporary file\\n\");\n\t\t\t\tif (file_processing) {fclose (fp);\tfp = NULL;}\t/* Close original PS file */\n\t\t\t\tif (delete && gmt_remove_file (GMT, ps_file))\t/* Since we created a temporary file from the memdata */\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\tif (!Ctrl->L.active)\t\t\t/* Otherwise ps_names contents are the Garbageman territory */\n\t\t\t\t\tfor (kk = 0; kk < Ctrl->In.n_files; kk++) gmt_M_str_free (ps_names[kk]);\n\t\t\t\tgmt_M_free (GMT, ps_names);\n\t\t\t\tgmt_M_free (GMT, PS);\n\t\t\t\tgmt_M_free (GMT, line);\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t\twhile (file_line_reader (GMT, &line, &line_size, fp, PS->data, &pos) != EOF) {\n\t\t\t\tif (dump && !strncmp (line, \"% Begin GMT time-stamp\", 22))\n\t\t\t\t\tdump = false;\n\t\t\t\tif (dump)\n\t\t\t\t\tfprintf (fp2, \"%s\\n\", line);\n\t\t\t\telse if (!strncmp (line, \"PSL_font_encode\", 15))\t/* Must always pass any font reencodings */\n\t\t\t\t\tfprintf (fp2, \"%s\\n\", line);\n\t\t\t\tif (!dump && !strncmp (line, \"% End GMT time-stamp\", 20))\n\t\t\t\t\tdump = true;\n\t\t\t}\n\t\t\tif (file_processing) fclose (fp);\t/* Close original PS file */\n\t\t\trewind (fp2);\t/* Rewind new file without timestamp */\n\t\t\tfp = fp2;\t/* Set original file pointer to this file instead */\n\t\t\tfile_processing = true;\t\t\t/* Since we now are reading a temporary file */\n\t\t}\n\n\t\tgot_BB = got_HRBB = file_has_HRBB = got_end = landscape = landscape_orig = setup = false;\n\t\tgot_BBatend = 0;\n\n\t\tlen = strlen (ps_file);\n\t\tj = (unsigned int)len - 1;\n\t\tpos_file = -1;\n\t\tpos_ext = -1;\t/* In case file has no extension */\n\t\tfor (i = 0; i < len; i++, j--) {\n\t\t\tif (pos_ext < 0 && ps_file[j] == '.') pos_ext = j;\t/* Beginning of file extension */\n\t\t\tif (pos_file < 0 && (ps_file[j] == '/' || ps_file[j] == '\\\\')) pos_file = j + 1;\t/* Beginning of file name */\n\t\t}\n\t\tif (pos_ext == -1) pos_ext = (unsigned int)len - 1;\t/* File has no extension */\n\t\tif (!Ctrl->D.active || pos_file == -1) pos_file = 0;\t/* File either has no leading directory or we want to use it */\n\n\t\t/* Adjust to a tight BoundingBox if user requested so */\n\n\t\tif (Ctrl->A.active) {\n\t\t\tchar *psfile_to_use = NULL;\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Find HiResBoundingBox ...\\n\");\n\t\t\tsprintf (BB_file, \"%s/psconvert_%dc.bb\", Ctrl->D.dir, (int)getpid());\n\t\t\tpsfile_to_use = Ctrl->A.strip ? no_U_file : ((strlen (clean_PS_file) > 0) ? clean_PS_file : ps_file);\n\t\t\tsprintf (cmd, \"%s%s %s %s %c%s%c 2> %c%s%c\",\n\t\t\t         at_sign, Ctrl->G.file, gs_BB, Ctrl->C.arg, quote, psfile_to_use, quote, quote, BB_file, quote);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd);\n\t\t\tsys_retval = system (cmd);\t\t/* Execute the command that computes the tight BB */\n\t\t\tif (sys_retval) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd, sys_retval);\n\t\t\t\tif (gmt_remove_file (GMT, BB_file))\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\tif (delete && gmt_remove_file (GMT, ps_file))\t/* Since we created a temporary file from the memdata */\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\tgmt_M_free (GMT, PS);\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t\tif ((fpb = fopen (BB_file, \"r\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s\\n\", BB_file);\n\t\t\t\tif (delete && gmt_remove_file (GMT, ps_file))\t/* Since we created a temporary file from the memdata */\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\tgmt_M_free (GMT, PS);\n\t\t\t\tReturn (GMT_ERROR_ON_FOPEN);\n\t\t\t}\n\t\t\twhile ((file_line_reader (GMT, &line, &line_size, fpb, NULL, NULL) != EOF) && !got_BB) {\n\t\t\t\t/* We only use the High resolution BB */\n\t\t\t\tif ((strstr (line,\"%%HiResBoundingBox:\"))) {\n\t\t\t\t\tsscanf (&line[19], \"%s %s %s %s\", c1, c2, c3, c4);\n\t\t\t\t\tx0 = atof (c1);\t\ty0 = atof (c2);\n\t\t\t\t\tx1 = atof (c3);\t\ty1 = atof (c4);\n\t\t\t\t\tx0 -= Ctrl->A.margin[XLO];\tx1 += Ctrl->A.margin[XHI];\t/* If not given, margin = 0/0/0/0 */\n\t\t\t\t\ty0 -= Ctrl->A.margin[YLO];\ty1 += Ctrl->A.margin[YHI];\n\t\t\t\t\tif (x1 <= x0 || y1 <= y0) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to decode BoundingBox file %s\\n\", BB_file);\n\t\t\t\t\t\tfclose (fpb);\tfpb = NULL;            /* so we don't accidentally close twice */\n\t\t\t\t\t\tif (!Ctrl->S.active && gmt_remove_file (GMT, BB_file))\t/* Remove the file */\n\t\t\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t\t\tif (Ctrl->D.active)\n\t\t\t\t\t\t\tsprintf (tmp_file, \"%s/\", Ctrl->D.dir);\n\t\t\t\t\t\tstrncat (tmp_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\t\t\t\t\t\tstrcat (tmp_file, ext[Ctrl->T.device]);\n\t\t\t\t\t\tsprintf (cmd, \"%s%s %s %s%s -sDEVICE=%s %s -g1x1 -r%d -sOutputFile=%c%s%c -f%c%s%c\",\n\t\t\t\t\t\t\tat_sign, Ctrl->G.file, gs_params, Ctrl->C.arg, alpha_bits(Ctrl), device[Ctrl->T.device],\n\t\t\t\t\t\t\tdevice_options[Ctrl->T.device],\n\t\t\t\t\t\t\tCtrl->E.dpi, quote, tmp_file, quote, quote, ps_file, quote);\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd);\n\t\t\t\t\t\tsys_retval = system (cmd);\t\t/* Execute the GhostScript command */\n\t\t\t\t\t\tif (Ctrl->S.active)\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s\\n\", cmd);\n\t\t\t\t\t\tif (sys_retval) {\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd, sys_retval);\n\t\t\t\t\t\t\tif (gmt_remove_file (GMT, tmp_file))\t/* Remove the file */\n\t\t\t\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t\t\t\tif (delete && gmt_remove_file (GMT, ps_file))\t/* Since we created a temporary file from the memdata */\n\t\t\t\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t\t\t\tgmt_M_free (GMT, PS);\n\t\t\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* must leave loop because fpb has been closed and file_line_reader would\n\t\t\t\t\t\t * read from closed file: */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgot_BB = got_HRBB = true;\n\t\t\t\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"Figure dimensions: Width: %g points [%g %s]  Height: %g points [%g %s]\\n\",\n\t\t\t\t\t            x1-x0, (x1-x0)*GMT->session.u2u[GMT_PT][GMT->current.setting.proj_length_unit],\n\t\t\t\t\t            API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit],\n\t\t\t\t\t            y1-y0, (y1-y0)*GMT->session.u2u[GMT_PT][GMT->current.setting.proj_length_unit],\n\t\t\t\t\t            API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fpb != NULL) { /* don't close twice */\n\t\t\t\tfclose (fpb);\tfpb = NULL;\n\t\t\t}\n\t\t\tif (!Ctrl->S.active && gmt_remove_file (GMT, BB_file))\t/* Remove the file with BB info */\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\tif (got_BB) GMT_Report (API, GMT_MSG_LONG_VERBOSE, \"[%g %g %g %g]...\\n\", x0, y0, x1, y1);\n\t\t}\n\n\t\t/* Open temporary file to be processed by ghostscript. When -Te or -TE is used, tmp_file is for keeps */\n\n\t\tif (Ctrl->T.eps) {\n\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Format EPS file...\\n\");\n\t\t\tif (Ctrl->D.active) sprintf (tmp_file, \"%s/\", Ctrl->D.dir);\t/* Use specified output directory */\n\t\t\tif (!Ctrl->F.active || return_image)\n\t\t\t\tstrncat (tmp_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\t\t\telse\n\t\t\t\tstrcat (tmp_file, Ctrl->F.file);\n\t\t\tif (strlen(tmp_file) < PATH_MAX-4)\t\t/* To please Coverity */\n\t\t\t\tstrcat (tmp_file, ext[GS_DEV_EPS]);\n\t\t\tif ((fpo = fopen (tmp_file, \"w\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s for writing\\n\", tmp_file);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsprintf (tmp_file, \"%s/psconvert_%dd.eps\", Ctrl->D.dir, (int)getpid());\n\t\t\tif ((fpo = fopen (tmp_file, \"w+\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to create a temporary file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Scan first 20 lines of input file for [HiRes]BoundingBox and Orientation statements.\n\t\t * Since we prefer the HiResBB over BB we must continue to read until both are found or 20 lines have past */\n\n\t\ti = 0;\n\t\twhile ((file_line_reader (GMT, &line, &line_size, fp, PS->data, &pos) != EOF) && i < 20 && !(got_BB && got_HRBB && got_end)) {\n\t\t\ti++;\n\t\t\tif (!line[0] || line[0] != '%')\n\t\t\t\t{ /* Skip empty and non-comment lines */ }\n\t\t\telse if (!got_BB && strstr (line, \"%%BoundingBox:\")) {\n\t\t\t\tsscanf (&line[14], \"%s %s %s %s\",c1,c2,c3,c4);\n\t\t\t\tif (strncmp (c1, \"(atend)\", 7)) {\t/* Got actual numbers */\n\t\t\t\t\tif (!got_HRBB) {\t/* Only assign values if we haven't seen the high-res version yet */\n\t\t\t\t\t\tx0 = atoi (c1);\t\ty0 = atoi (c2);\n\t\t\t\t\t\tx1 = atoi (c3);\t\ty1 = atoi (c4);\n\t\t\t\t\t}\n\t\t\t\t\tgot_BB = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tgot_BBatend++;\n\t\t\t}\n\t\t\telse if ((strstr (line, \"%%HiResBoundingBox:\"))) {\n\t\t\t\tfile_has_HRBB = true;\n\t\t\t\tif (!got_HRBB) {\n\t\t\t\t\tsscanf (&line[19], \"%s %s %s %s\",c1,c2,c3,c4);\n\t\t\t\t\tif (strncmp (c1, \"(atend)\", 7)) {\t/* Got actual numbers */\n\t\t\t\t\t\tx0 = atof (c1);\t\ty0 = atof (c2);\n\t\t\t\t\t\tx1 = atof (c3);\t\ty1 = atof (c4);\n\t\t\t\t\t\tgot_HRBB = got_BB = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((strstr (line, \"%%Creator:\"))) {\n\t\t\t\tif (!strncmp (&line[11], \"GMT\", 3))\n\t\t\t\t\tisGMT_PS = true;\n\t\t\t}\n\t\t\telse if ((strstr (line, \"%%Orientation:\"))) {\n\t\t\t\tif (!strncmp (&line[15], \"Landscape\", 9))\n\t\t\t\t\tlandscape = landscape_orig = true;\n\t\t\t}\n\t\t\telse if ((strstr (line, \"%%EndComments\")))\n\t\t\t\tgot_end = true;\n\t\t\tif (got_BBatend == 1 && (got_end || i == 19)) {\t/* Now is the time to look at the end of the file */\n\t\t\t\tgot_BBatend++;\t\t\t/* Avoid jumping more than once to the end */\n\t\t\t\tif (file_processing) {\n\t\t\t\t\tif (fseek (fp, (off_t)-256, SEEK_END))\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Seeking to start of last 256 bytes failed\\n\");\n\t\t\t\t}\n\t\t\t\telse {\t/* Get towards end of string */\n\t\t\t\t\tpos = (PS->n_bytes > 256) ? PS->n_bytes - 256 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Cannot proceed without knowing the BoundingBox */\n\n\t\tif (!got_BB) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t            \"Error: The file %s has no BoundingBox in the first 20 lines or last 256 bytes. Use -A option.\\n\", ps_file);\n\t\t\tif (!Ctrl->T.eps && gmt_remove_file (GMT, tmp_file))\t/* Remove the temporary EPS file */\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do the math on the BoundingBox and translation coordinates */\n\n\t\tif (Ctrl->P.active && landscape)\n\t\t\txt = -x1, yt = -y0, w = y1-y0, h = x1-x0, r = -90;\n\t\telse\n\t\t\txt = -x0, yt = -y0, w = x1-x0, h = y1-y0, r = 0;\n\n\t\txt_bak = xt;\tyt_bak = yt;\t\t/* Needed when Ctrl->A.resize */\n\n\t\t/* Set new height when width was set and no height given */\n\t\tif (Ctrl->A.new_size[0] > 0.0 && Ctrl->A.new_size[1] == 0.0) Ctrl->A.new_size[1] = Ctrl->A.new_size[0] * h / w;\n\n\t\t/* ****************************************************************** */\n\t\t/*         Rewind the input file and start copying and replacing      */\n\t\t/* ****************************************************************** */\n\n\t\tfile_rewind (fp, &pos);\n\n\t\t/* To produce non-PDF output from PS with transparency we must determine if transparency is requested in the PS */\n\t\tlook_for_transparency = Ctrl->T.device != GS_DEV_PDF && Ctrl->T.device != -GS_DEV_PDF;\n\t\ttransparency = add_grestore = false;\n\t\tset_background = (Ctrl->A.paint || Ctrl->A.outline);\n\n\t\twhile (file_line_reader (GMT, &line, &line_size, fp, PS->data, &pos) != EOF) {\n\t\t\tif (line[0] != '%') {\t/* Copy any non-comment line, except one containing setpagedevice in the Setup block */\n\t\t\t\tif (look_for_transparency && strstr (line, \" PSL_transp\")) {\n\t\t\t\t\ttransparency = true;\t\t/* Yes, found transparency */\n\t\t\t\t\tlook_for_transparency = false;\t/* No need to check anymore */\n\t\t\t\t}\n\t\t\t\tif (setup && strstr(line,\"setpagedevice\") != NULL)\t/* This is a \"setpagedevice\" command that should be avoided */\n\t\t\t\t\tcontinue;\n\t\t\t\tfprintf (fpo, \"%s\\n\", line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (Ctrl->W.active && !found_proj) {\t/* Here, line[0] == '%' */\n\t\t\t\tif (!strncmp (&line[2], \"PROJ\", 4)) { /* Search for the PROJ tag in the ps file */\n\t\t\t\t\tchar *ptmp = NULL, xx1[20], xx2[20], yy1[20], yy2[20];\n\t\t\t\t\tsscanf (&line[8], \"%s %s %s %s %s %s %s %s %s\",proj4_name,xx1,xx2,yy1,yy2,c1,c2,c3,c4);\n\t\t\t\t\twest = atof (c1);\t\teast = atof (c2);\n\t\t\t\t\tsouth = atof (c3);\t\tnorth = atof (c4);\n\t\t\t\t\tGMT->common.R.wesn[XLO] = atof (xx1);\t\tGMT->common.R.wesn[XHI] = atof (xx2);\n\t\t\t\t\tif (GMT->common.R.wesn[XLO] > 180.0 && GMT->common.R.wesn[XHI] > 180.0) {\n\t\t\t\t\t\tGMT->common.R.wesn[XLO] -= 360.0;\n\t\t\t\t\t\tGMT->common.R.wesn[XHI] -= 360.0;\n\t\t\t\t\t}\n\t\t\t\t\tGMT->common.R.wesn[YLO] = atof (yy1);\tGMT->common.R.wesn[YHI] = atof (yy2);\n\t\t\t\t\tfound_proj = true;\n\t\t\t\t\tif ((ptmp = strstr (&line[2], \"+proj\")) != NULL) {  /* Search for the +proj in the comment line */\n\t\t\t\t\t\tproj4_cmd = strdup (&line[(int)(ptmp - &line[0])]);\n\t\t\t\t\t\tgmt_chop (proj4_cmd);\t\t/* Remove the new line char */\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (proj4_name,\"latlong\") || !strcmp (proj4_name,\"xy\")) {\t\t/* Linear case, use original coords */\n\t\t\t\t\t\twest  = atof(xx1);\t\teast  = atof(xx2);\n\t\t\t\t\t\tsouth = atof(yy1);\t\tnorth = atof(yy2);\n\t\t\t\t\t\t/* One further test. +xy was found, but have we geog coords? Check that */\n\t\t\t\t\t\tif (!strcmp (proj4_name,\"xy\") &&\n\t\t\t\t\t\t\t\t(west >= -180) && ((east <= 360) && ((east - west) <= 360)) &&\n\t\t\t\t\t\t\t\t(south >= -90) && (north <= 90) ) {\n\t\t\t\t\t\t\tproj4_cmd = strdup (\"latlon\");\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Warning: An unknown psconvert setting was found but since \"\n\t\t\t\t\t\t\t\t\t\"image coordinates seem to be geographical, a linear transformation \"\n\t\t\t\t\t\t\t\t\t\"will be used.\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp (proj4_name,\"xy\") && Ctrl->W.warp) {\t/* Do not operate on a twice unknown setting */\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: requested an automatic geotiff generation, but \"\n\t\t\t\t\t\t\t\t\t\"no recognized psconvert option was used for the PS creation.\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (Ctrl->W.kml) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: To GE images must be in geographical coordinates. Very likely \"\n\t\t\t\t\t\t\t\t\t\"this won't work as you wish inside GE.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strncmp (line, \"%%BoundingBox:\", 14)) {\n\t\t\t\tdouble w_t, h_t;\n\t\t\t\tw_t = w;\th_t = h;\n\t\t\t\tif (Ctrl->A.resize) {\t\t/* Here the BB is the new size itself */\n\t\t\t\t\tw_t = Ctrl->A.new_size[0];\t\th_t = Ctrl->A.new_size[1];\n\t\t\t\t}\n\t\t\t\tif (got_BB && !Ctrl->A.round)\n\t\t\t\t\tfprintf (fpo, \"%%%%BoundingBox: 0 0 %ld %ld\\n\", lrint (ceil(w_t)), lrint (ceil(h_t)));\n\t\t\t\telse if (got_BB && Ctrl->A.round)\t\t/* Go against Adobe Law and round HRBB instead of ceil */\n\t\t\t\t\tfprintf (fpo, \"%%%%BoundingBox: 0 0 %ld %ld\\n\", lrint (w_t), lrint (h_t));\n\n\t\t\t\tgot_BB = false;\n\t\t\t\tif (file_has_HRBB)\n\t\t\t\t\tcontinue;\t/* High-res BB will be put elsewhere */\n\t\t\t\tif (got_HRBB)\n\t\t\t\t\tfprintf (fpo, \"%%%%HiResBoundingBox: 0 0 %g %g\\n\", w_t, h_t);\n\t\t\t\tgot_HRBB = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (!strncmp (line, \"%%HiResBoundingBox:\", 19)) {\n\t\t\t\tdouble w_t, h_t;\n\t\t\t\tw_t = w;\th_t = h;\n\t\t\t\tif (Ctrl->A.resize) {\t\t/* Here the BB is the new size itself */\n\t\t\t\t\tw_t = Ctrl->A.new_size[0];\t\th_t = Ctrl->A.new_size[1];\n\t\t\t\t}\n\t\t\t\tif (got_HRBB)\n\t\t\t\t\tfprintf (fpo, \"%%%%HiResBoundingBox: 0 0 %g %g\\n\", w_t, h_t);\n\t\t\t\tgot_HRBB = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (Ctrl->P.active && landscape && !strncmp (line, \"%%Orientation:\", 14)) {\n\t\t\t\tfprintf (fpo, \"%%%%Orientation: Portrait\\n\");\n\t\t\t\tlandscape = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (!strncmp (line, \"%%BeginSetup\", 12))\n\t\t\t\tsetup = true;\n\t\t\telse if (!strncmp (line, \"%%EndSetup\", 10)) {\n\t\t\t\tsetup = false;\n\t\t\t\tif (Ctrl->T.eps == -1)\t/* Write out setpagedevice command */\n\t\t\t\t\tfprintf (fpo, \"<< /PageSize [%g %g] >> setpagedevice\\n\", w, h);\n\t\t\t\tif (r != 0)\n\t\t\t\t\tfprintf (fpo, \"%d rotate\\n\", r);\n\t\t\t\tif (!gmt_M_is_zero (xt) || !gmt_M_is_zero (yt))\n\t\t\t\t\tfprintf (fpo, \"%g %g translate\\n\", xt, yt);\n\t\t\t\txt = yt = 0.0;\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (Ctrl->A.resize) {\n\t\t\t\t/* We are going to trick ghostscript to do what -dEPSFitPage was supposed to do but doesn't\n\t\t\t\t   because it's bugged. For that we recompute a new scale, offsets and DPIs such that at the\n\t\t\t\t   end we will end up with an image with the imposed size and the current -E dpi setting.\n\t\t\t\t*/\n\t\t\t\tdouble new_scale_x, new_scale_y, new_off_x, new_off_y, r_x, r_y;\n\t\t\t\tchar t1[8], t2[8];\t/* To hold the translate part when landscape */\n\t\t\t\tchar t3[128];\t\t/* To hold a copy of the last commented (%%) line */\n\t\t\t\tif (!strncmp (line, \"%%BeginPageSetup\", 16)) {\n\t\t\t\t\tint n_scan = 0;\n\t\t\t\t\tsize_t Lsize = 128U;\n\t\t\t\t\tchar *line_ = gmt_M_memory (GMT, NULL, Lsize, char);\n\t\t\t\t\tBeginPageSetup_here = true;\t/* Signal that on next line the job must be done */\n\t\t\t\t\tfile_line_reader (GMT, &line_, &Lsize, fp, PS->data, &pos);   /* Read also next line which is to be overwritten (unless a comment) */\n\t\t\t\t\twhile (line_[0] == '%') {\t/* Skip all comments until we get the first actionable line */\n\t\t\t\t\t\tstrncpy(t3, line_, 127);\n\t\t\t\t\t\tfile_line_reader (GMT, &line_, &Lsize, fp, PS->data, &pos);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* The trouble is that we can have things like \"V 612 0 T 90 R 0.06 0.06 scale\" or \"V 0.06 0.06 scale\" */\n\t\t\t\t\tif (landscape_orig)\n\t\t\t\t\t\tn_scan = sscanf (line_, \"%s %s %s %*s %*s %*s %s %s\", c1, t1, t2, c2, c3);\n\t\t\t\t\telse\n\t\t\t\t\t\tn_scan = sscanf (line_, \"%s %s %s\", c1, c2, c3);\n\t\t\t\t\tif ((strcmp (c1, \"V\") && strcmp (c1, \"gsave\")) || !(n_scan == 3 || n_scan == 5)) {\n\t\t\t\t\t\tint c;\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Parsing of scale after %%%%BeginPageSetup failed\\n\"\n\t\t\t\t\t\t                                 \"\\tMaking some assumptions to try to save the situation.\\n\");\n\t\t\t\t\t\told_scale_x = 1;\t\told_scale_y = 1;\t/* Assume this */\n\t\t\t\t\t\t/* Receed two lines to position us again in a comment line (hopefully %%EndPageSetup) */\n\t\t\t\t\t\tfseek (fp, -(off_t)(strlen(line_)+strlen(t3)+2U), SEEK_CUR);\n\t\t\t\t\t\t/* But because the line termination issue we must test if we seeked back long enough */\n\t\t\t\t\t\tc = fgetc (fp);\n\t\t\t\t\t\tif (c == '%')\n\t\t\t\t\t\t\tfseek (fp, -(off_t)(1U), SEEK_CUR);\t\t/* Just receed the read character (file is unix terminate) */\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfseek (fp, -(off_t)(3U), SEEK_CUR);\t\t/* Receed the character and 2 more because file is Win terminated */\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\told_scale_x = atof (c2);\t\told_scale_y = atof (c3);\n\t\t\t\t\t}\n\t\t\t\t\tgmt_M_free (GMT, line_);\n\t\t\t\t}\n\t\t\t\telse if (BeginPageSetup_here) {\n\t\t\t\t\tBeginPageSetup_here = false;\n\t\t\t\t\tCtrl->A.resize = false;       /* Need to reset so it doesn't keep checking inside this branch */\n\t\t\t\t\t/* Now we must calculate the new scale */\n\t\t\t\t\tif (Ctrl->A.rescale)          /* except if it was set as an option */\n\t\t\t\t\t\tr_x = Ctrl->A.scale;\n\t\t\t\t\telse if (Ctrl->A.max) {\t/* Check if plot size exceeds specified limits */\n\t\t\t\t\t\tr_x = (w > Ctrl->A.new_size[0]) ? Ctrl->A.new_size[0] / w : 1.0;\n\t\t\t\t\t\tif (Ctrl->A.new_size[1] / h < r_x) r_x = Ctrl->A.new_size[1] / h;\t/* Pick the smallest scale */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tr_x = Ctrl->A.new_size[0] / w;\n\n\t\t\t\t\tnew_scale_x = new_scale_y = old_scale_x * r_x;\n\t\t\t\t\tnew_off_x = -xt_bak + xt_bak * r_x;     /* Need to recompute the new offsets as well */\n\t\t\t\t\tnew_off_y = -yt_bak + yt_bak * r_x;\n\t\t\t\t\tCtrl->A.new_dpi_x = Ctrl->A.new_dpi_y = Ctrl->E.dpi * r_x;\n\t\t\t\t\tif (!Ctrl->A.max && Ctrl->A.new_size[1]) {\n\t\t\t\t\t\tr_y = Ctrl->A.new_size[1] / h;\n\t\t\t\t\t\tnew_scale_y = old_scale_y * r_y;\n\t\t\t\t\t\tnew_off_y = -yt_bak + yt_bak * r_y;\n\t\t\t\t\t\tCtrl->A.new_dpi_y = Ctrl->E.dpi * r_y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tr_y = r_x;\t/* Not sure of this. Added later to shut up a compiler warning of r_y potentially used uninitialized */\n\n\t\t\t\t\tfprintf (fpo, \"%% Recalculate translation and scale to obtain a resized image\\n\");\n\t\t\t\t\tfprintf (fpo, \"%g %g translate\\n\", new_off_x, new_off_y);\n\t\t\t\t\tif (landscape_orig) {\n\t\t\t\t\t\tfprintf (fpo, \"gsave %g %g translate 90 rotate %g %g scale\\n\", atof(t1)*r_x, atof(t2)*r_y, new_scale_x, new_scale_y);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf (fpo, \"gsave %g %g scale\\n\", new_scale_x, new_scale_y);\n\t\t\t\t\tset_background = false;\n\t\t\t\t\tadd_grestore = true;\n\t\t\t\t\tpossibly_fill_or_outline_BoundingBox (GMT, &(Ctrl->A), fpo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (set_background) {\n\t\t\t\t/* Paint or outline the background rectangle. */\n\t\t\t\tif (!strncmp (line, \"%%EndPageSetup\", 14)) {\n\t\t\t\t\tset_background = false;\n\t\t\t\t\tpossibly_fill_or_outline_BoundingBox (GMT, &(Ctrl->A), fpo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strncmp (line, \"%%Page:\", 7)) {\n\t\t\t\tif (r != 0)\n\t\t\t\t\tfprintf (fpo, \"%d rotate\\n\", r);\n\t\t\t\tif (!gmt_M_is_zero (xt) || !gmt_M_is_zero (yt))\n\t\t\t\t\tfprintf (fpo, \"%g %g translate\\n\", xt, yt);\n\t\t\t\txt = yt = 0.0;\n\t\t\t\tr = 0;\n\t\t\t}\n#ifdef HAVE_GDAL\n\t\t\telse if (found_proj && !strncmp (line, \"%%PageTrailer\", 13)) {\n\t\t\t\tfile_line_reader (GMT, &line, &line_size, fp, PS->data, &pos);\n\t\t\t\tfprintf (fpo, \"%%%%PageTrailer\\n\");\n\t\t\t\tfprintf (fpo, \"%s\\n\", line);\n\n\t\t\t\t/* Write a GeoPDF registration info */\n\n\t\t\t\t/* Allocate new control structures */\n\t\t\t\tto_gdalread = gmt_M_memory (GMT, NULL, 1, struct GMT_GDALREAD_IN_CTRL);\n\t\t\t\tfrom_gdalread = gmt_M_memory (GMT, NULL, 1, struct GMT_GDALREAD_OUT_CTRL);\n\t\t\t\tto_gdalread->W.active = true;\n\t\t\t\tfrom_gdalread->ProjRefPROJ4 = proj4_cmd;\n\t\t\t\tgmt_gdalread (GMT, NULL, to_gdalread, from_gdalread);\n\t\t\t\tif (from_gdalread->ProjRefWKT != NULL) {\n\t\t\t\t\tdouble x0, y0, x1;\t/* Projected coordinates */\n\t\t\t\t\tdouble h0, v0, h1;\t/* Correspnding point coordinates */\n\t\t\t\t\tdouble a, H, V;\t\t/* a -> coeff of affine matrix; H,V -> origin shift in projected coords */\n\t\t\t\t\tdouble pX[4], pY[4], lptsX[4], lptsY[4];\n\n\t\t\t\t\tx0 = west;\t\ty0 = south;\t\tx1 = east;\ty1 = north;\n\t\t\t\t\th0 = v0 = 0;\t/* because we used -A option so origin in points is at (0,0) */\n\t\t\t\t\th1 = h0 + w;\n\t\t\t\t\t/* takes the projected coordinate system into the page coordinate system */\n\t\t\t\t\ta = (h1 - h0)/(x1 - x0);\n\t\t\t\t\tH = h0 - a*x0;\n\t\t\t\t\tV = v0 - a*y0;\n\n\t\t\t\t\t/* Use the above matrix to discover where the corners of the map will fall */\n\t\t\t\t\tpX[0] = a*x0 + H;\tpX[1] = a*x0 + H;\tpX[2] = a*x1 + H;\tpX[3] = a*x1 + H;\n\t\t\t\t\tpY[0] = a*y0 + V;\tpY[1] = a*y1 + V;\tpY[2] = a*y1 + V;\tpY[3] = a*y0 + V;\n\n\t\t\t\t\t/* Now compute the LPTS array */\n\t\t\t\t\tlptsX[0] = pX[0] / w;\tlptsX[1] = pX[1] / w;\tlptsX[2] = pX[2] / w;\tlptsX[3] = pX[3] / w;\n\t\t\t\t\tlptsY[0] = pY[0] / h;\tlptsY[1] = pY[1] / h;\tlptsY[2] = pY[2] / h;\tlptsY[3] = pY[3] / h;\n\n\t\t\t\t\tfprintf (fpo, \"\\n%% embed georegistation info\\n\");\n\t\t\t\t\tfprintf (fpo, \"[ {ThisPage} <<\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t/VP [ <<\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t/Type /Viewport\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t/BBox[0 0 %.1f %.1f]\\n\", w, h);\n\t\t\t\t\tfprintf (fpo, \"\\t\\t/Measure <<\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/Type /Measure\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/Subtype /GEO\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/Bounds[0 0 0 1 1 1 1 0]\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/GPTS[%f %f %f %f %f %f %f %f]\\n\",\n\t\t\t\t\t         south, west, north, west, north, east, south, east);\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/LPTS[%f %f %f %f %f %f %f %f]\\n\",\n\t\t\t\t\t         lptsX[0],lptsY[0], lptsX[1],lptsY[1], lptsX[2],lptsY[2], lptsX[3],lptsY[3]);\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t/GCS <<\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t\\t/Type /PROJCS\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t\\t/WKT\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t\\t(%s)\\n\", from_gdalread->ProjRefWKT);\n\t\t\t\t\tfprintf (fpo, \"\\t\\t\\t>>\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t\\t>>\\n\");\n\t\t\t\t\tfprintf (fpo, \"\\t>>]\\n\");\n\t\t\t\t\tfprintf (fpo, \">> /PUT pdfmark\\n\\n\");\n\t\t\t\t}\n\t\t\t\tgmt_M_free (GMT, to_gdalread);\n\t\t\t\tgmt_M_free (GMT, from_gdalread);\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tfprintf (fpo, \"%s\\n\", line);\n\t\t}\n\t\tif (add_grestore)\n\t\t\tfprintf (fpo, \"grestore\\n\");\t/* Since we started with gsave to change size */\n\t\t/* Recede a bit to test the contents of last line. -7 for when PS has CRLF endings */\n\t\tif (fseek (fp, (off_t)-7, SEEK_END))\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Error: Seeking to spot 7 bytes earlier failed\\n\");\n\t\t/* Read until last line is encountered */\n\t\twhile (file_line_reader (GMT, &line, &line_size, fp, PS->data, &pos) != EOF);\n\t\tif (strncmp (line, \"%%EOF\", 5U))\n\t\t\t/* Possibly a non-closed GMT PS file. To be confirmed later */\n\t\t\texcessK = true;\n\n\t\tfclose (fpo);\tfpo = NULL;\n\t\tfclose (fp);\tfp  = NULL;\n\t\tif (delete && gmt_remove_file (GMT, ps_file))\t/* Since we created a temporary file from the memdata */\n\t\t\tReturn (GMT_RUNTIME_ERROR);\n\n\t\t/* Build the converting ghostscript command and execute it */\n\n\t\tif (Ctrl->T.device != GS_DEV_EPS) {\n\t\t\tchar tag[16] = {\"\"};\n\t\t\tint dest_device = Ctrl->T.device;\t/* Keep copy in case of temp change below */\n\n\t\t\tstrncpy (tag, &ext[Ctrl->T.device][1], 15U);\n\t\t\tgmt_str_toupper (tag);\n\n\t\t\tif (transparency) {\t/* Get here when PDF is _NOT_ the final output format but an intermediate format */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"PS file with transparency must be converted to PDF before creating %s\\n\", tag);\n\t\t\t\t/* Temporarily change output device to PDF to get the PDF tmp file */\n\t\t\t\tCtrl->T.device = GS_DEV_PDF;\n\t\t\t\t/* After conversion, we convert the tmp PDF file to desired format via a 2nd gs call */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Convert to intermediate PDF...\\n\");\n\t\t\t\tstrncat (out_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\t\t\t\tstrcat (out_file, \"_intermediate\");\n\t\t\t}\n\t\t\telse {\t/* Output is the final result */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Convert to %s...\\n\", tag);\n\n\t\t\t\tif (!Ctrl->F.active || return_image) {\n\t\t\t\t\tif (Ctrl->D.active) sprintf (out_file, \"%s/\", Ctrl->D.dir);\t/* Use specified output directory */\n\t\t\t\t\tstrncat (out_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrncpy (out_file, Ctrl->F.file, PATH_MAX-1);\n\t\t\t}\n\t\t\tstrcat (out_file, ext[Ctrl->T.device]);\n\n\t\t\tif (Ctrl->A.new_dpi_x) {\t/* We have a resize request (was Ctrl->A.resize = true;) */\n\t\t\t\tpix_w = urint (ceil (w * Ctrl->A.new_dpi_x / 72.0));\n\t\t\t\tpix_h = urint (ceil (h * Ctrl->A.new_dpi_y / 72.0));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpix_w = urint (ceil (w * Ctrl->E.dpi / 72.0));\n\t\t\t\tpix_h = urint (ceil (h * Ctrl->E.dpi / 72.0));\n\t\t\t}\n\n\t\t\tsprintf (cmd, \"%s%s %s %s%s -sDEVICE=%s %s -g%dx%d -r%d -sOutputFile=%c%s%c -f%c%s%c\",\n\t\t\t\tat_sign, Ctrl->G.file, gs_params, Ctrl->C.arg, alpha_bits(Ctrl), device[Ctrl->T.device],\n\t\t\t\tdevice_options[Ctrl->T.device], pix_w, pix_h, Ctrl->E.dpi, quote, out_file, quote, quote, tmp_file, quote);\n\n\t\t\tif (Ctrl->S.active)\t/* Print GhostScript command */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s\\n\", cmd);\n\n\t\t\t/* Execute the GhostScript command */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd);\n\t\t\tsys_retval = system (cmd);\n\t\t\tif (sys_retval) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd, sys_retval);\n\t\t\t\tgmt_remove_file (GMT, tmp_file);\t/* Since we created a temporary file from the memdata */\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\n\t\t\t/* Check output file */\n\t\t\tif (access (out_file, R_OK)) {\t\t/* output file not created */\n\t\t\t\tif (isGMT_PS && excessK)\n\t\t\t\t\t/* non-closed GMT input PS file */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t\t\t            \"%s: GMT PS format detected but file is not finalized. Maybe a -K in excess? No output created.\\n\", ps_file);\n\t\t\t\telse\n\t\t\t\t\t/* Either a bad closed GMT PS file or one of unknown origin */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t\t\t            \"Could not create %s. Maybe input file does not fulfill PS specifications.\\n\", out_file);\n\t\t\t}\n\t\t\telse {\t\t\t\t\t\t\t\t/* output file exists */\n\t\t\t\tif (isGMT_PS && excessK)\n\t\t\t\t\t/* non-closed GMT input PS file */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL,\n\t\t\t\t\t            \"%s: GMT PS format detected but file is not finalized. Maybe a -K in excess? %s could be messed up.\\n\",\n\t\t\t\t\t            ps_file, out_file);\n\t\t\t\t/* else: Either a good closed GMT PS file or one of unknown origin */\n\t\t\t}\n\t\t\tif (transparency) {\t/* Now convert temporary PDF to desired format */\n\t\t\t\tchar pdf_file[PATH_MAX] = {\"\"};\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Convert PDF with transparency to %s...\\n\", tag);\n\t\t\t\tCtrl->T.device = dest_device;\t/* Reset output device type */\n\t\t\t\tstrcpy (pdf_file, out_file);\t/* Now the PDF is the infile */\n\t\t\t\t*out_file = '\\0'; /* truncate string to build new output file */\n\t\t\t\tif (!Ctrl->F.active || return_image) {\n\t\t\t\t\tif (Ctrl->D.active) sprintf (out_file, \"%s/\", Ctrl->D.dir);\t/* Use specified output directory */\n\t\t\t\t\tstrncat (out_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrncpy (out_file, Ctrl->F.file, PATH_MAX-1);\n\t\t\t\tstrcat (out_file, ext[Ctrl->T.device]);\n\t\t\t\t/* After conversion, convert the tmp PDF file to desired format via a 2nd gs call */\n\t\t\t\tsprintf (cmd, \"%s%s %s %s%s -sDEVICE=%s %s -r%d -sOutputFile=%c%s%c %c%s%c\",\n\t\t\t\t\tat_sign, Ctrl->G.file, gs_params, Ctrl->C.arg, alpha_bits(Ctrl), device[Ctrl->T.device],\n\t\t\t\t\tdevice_options[Ctrl->T.device],\n\t\t\t\t\tCtrl->E.dpi, quote, out_file, quote, quote, pdf_file, quote);\n\t\t\t\tif (Ctrl->S.active)\t/* Print 2nd GhostScript command */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"%s\\n\", cmd);\n\t\t\t\t/* Execute the 2nd GhostScript command */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd);\n\t\t\t\tsys_retval = system (cmd);\n\t\t\t\tif (sys_retval) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd, sys_retval);\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t\tif (!Ctrl->S.active && gmt_remove_file (GMT, pdf_file))\t/* The temporary PDF file is no longer needed */\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t}\n\n\t\tif (GMT->current.setting.run_mode == GMT_MODERN) {\n\t\t\tif (Ctrl->T.ps) {\t/* Under modern mode we can also save the PS file by renaming it */\n\t\t\t\tstrncpy (out_file, Ctrl->F.file, PATH_MAX-1);\n\t\t\t\tstrcat (out_file, \".ps\");\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Rename %s -> %s\\n\", GMT->current.ps.filename, out_file);\n\t\t\t\tif (gmt_rename_file (GMT, GMT->current.ps.filename, out_file))\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t\telse {\t/* Delete it, no -Z needed */\n\t\t\t\tif (gmt_remove_file (GMT, GMT->current.ps.filename))\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t}\n\t\telse if (Ctrl->Z.active && !delete) {\t\t/* Remove input file, if requested */\n\t\t\tif (gmt_remove_file (GMT, ps_file))\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\n\t\tif (return_image) {\t/* Must read in the saved raster image and return via Ctrl->F.file pointer */\n\t\t\tstruct GMT_IMAGE *I = NULL;\n#ifdef HAVE_GDAL\t/* Since GMT_Read_Data with GMT_IS_IMAGE, GMT_IS_FILE means a call to GDAL */\n\t\t\tgmt_set_pad (GMT, 0U);\t/* Temporary turn off padding (and thus BC setting) since we will use image exactly as is */\n\t\t\t/* State how we wish to receive images from GDAL */\n\t\t\tif (GMT->current.gdal_read_in.O.mem_layout[0])\t\t/* At one point this should never be allowed to be empty */\n\t\t\t\tGMT_Set_Default (API, \"API_IMAGE_LAYOUT\", GMT->current.gdal_read_in.O.mem_layout);\n\t\t\telse\n\t\t\t\tGMT_Set_Default (API, \"API_IMAGE_LAYOUT\", \"TCBa\");\n\t\n\t\t\tif ((I = GMT_Read_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, out_file, NULL)) == NULL) {\n\t\t\t\tReturn (API->error);\n\t\t\t}\n#else\t\t\t/* Here we have already set device to PPM which we can read ourselves. */\n\t\t\tuint64_t dim[GMT_DIM_SIZE] = {0U, 0U, 3U, 0U}; \t/* 3 bands. This might change if we do monochrome at some point */\n\t\t\tuint64_t row, col, band, nCols, nRows, nBands, nXY;\n\t\t\tFILE *fp_raw = NULL;\n\t\t\tunsigned char *tmp;\n\t\t\tint ios;\n\t\t\tif ((fp_raw = fopen (out_file, \"rb\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open image file %s\\n\", out_file);\n\t\t\t\tReturn (GMT_ERROR_ON_FOPEN);\n\t\t\t}\n\t\t\tgmt_fgets (GMT, line, GMT_LEN128, fp_raw);\t/* Skip 1st line */\n\t\t\tgmt_fgets (GMT, line, GMT_LEN128, fp_raw);\t/* Skip 2nd line */\n\t\t\tgmt_fgets (GMT, line, GMT_LEN128, fp_raw);\t/* Get 3rd line */\n\t\t\tif (sscanf (line, \"%\" PRIu64 \" %\" PRIu64, &dim[GMT_X], &dim[GMT_Y]) != 2) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to decipher size of image in file %s\\n\", out_file);\n\t\t\t\tfclose (fp_raw);\n\t\t\t\tReturn (GMT_PARSE_ERROR);\n\t\t\t}\n\t\t\tgmt_fgets (GMT, line, GMT_LEN128, fp_raw);\t/* Skip 4th line */\n\t\t\tgmt_set_pad (GMT, 0U);\t/* Temporary turn off padding (and thus BC setting) since we will use image exactly as is */\n\t\t\tif ((I = GMT_Create_Data (API, GMT_IS_IMAGE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, dim, NULL, NULL, 0, 0, NULL)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to create image structure\\n\");\n\t\t\t\tfclose (fp_raw);\n\t\t\t\tReturn (API->error);\n\t\t\t}\n\n\t\t\tnCols = dim[GMT_X];\t\tnRows = dim[GMT_Y];\t\tnBands = dim[2];\tnXY = nRows * nCols;\n\t\t\ttmp   = gmt_M_memory(GMT, NULL, nCols * nBands, char);\n\t\t\tfor (row = 0; row < nRows; row++) {\n\t\t\t\tios = fread(tmp, sizeof (unsigned char), nCols * nBands, fp_raw);\t\t/* Read a row of nCols by nBands bytes of data */\n\t\t\t\tfor (col = 0; col < nCols; col++) {\n\t\t\t\t\tfor (band = 0; band < nBands; band++) {\n\t\t\t\t\t\tI->data[row + col*nRows + band*nXY] = tmp[band + col*nBands];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_M_free (GMT, tmp);\n\t\t\tfclose (fp_raw);\tfp_raw = NULL;\n#endif\n\t\t\tif (GMT_Write_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, Ctrl->F.file, I) != GMT_NOERROR)\n\t\t\t\tReturn (API->error);\n\t\t\tgmt_set_pad (GMT, API->pad);\t/* Reset padding to GMT default */\n\t\t\tif (Ctrl->Z.active) {\t/* Remove the image since it is returned to a calling program and -Z was given */\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Removing %s...\\n\", out_file);\n\t\t\t\tif (gmt_remove_file (GMT, out_file))\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t}\n\t\t}\n\n\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"Done.\\n\");\n\n\t\tif (!Ctrl->S.active) {\n\t\t\tif (!Ctrl->T.eps && gmt_remove_file (GMT, tmp_file))\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\tif (strlen (no_U_file) > 0 && gmt_remove_file (GMT, no_U_file)) /* empty string == file was not created */\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\tif (strlen (clean_PS_file) > 0 && gmt_remove_file (GMT, clean_PS_file)) /* empty string == file was not created */\n\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t}\n\n\t\tif (Ctrl->W.active && found_proj && !Ctrl->W.kml) {\t/* Write a world file */\n\t\t\tdouble x_inc, y_inc;\n\t\t\tchar world_file[PATH_MAX] = \"\", *wext = NULL, *s = NULL;\n\n\t\t\tx_inc = (east  - west)  / pix_w;\n\t\t\ty_inc = (north - south) / pix_h;\n\t\t\tGMT_Report (API, GMT_MSG_VERBOSE, \"width = %d\\theight = %d\\tX res = %f\\tY res = %f\\n\", pix_w, pix_h, x_inc, y_inc);\n\n\t\t\t/* West and North of the world file contain the coordinates of the\n\t\t\t * center of the pixel\n\t\t\t\t but our current values are of the NW corner of the pixel (pixel\n\t\t\t\t registration). So we'll move halph pixel inward. */ west  += x_inc /\n\t\t\t2.0; north -= y_inc / 2.0;\n\n\t\t\tif (Ctrl->D.active) sprintf (world_file, \"%s/\", Ctrl->D.dir);\t/* Use specified output directory */\n\t\t\tif (Ctrl->F.active) {\t\t/* Must rip the raster file extension before adding the world one */\n\t\t\t\tfor (i = (int)strlen(out_file) - 1; i > 0; i--) {\n\t\t\t\t\tif (out_file[i] == '.') { \t/* Beginning of file extension */\n\t\t\t\t\t\tpos_ext = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout_file[pos_ext] = '\\0';\n\t\t\t\tstrcat(world_file, out_file);\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrncat (world_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\n\t\t\ts = ext[Ctrl->T.device];\n\t\t\twext = strdup(ext[Ctrl->T.device]);\n\t\t\twext[1] = s[1];\t\twext[2] = s[3];\t\twext[3] = 'w';\n\t\t\tstrcat (world_file, wext);\n\n\t\t\tif ((fpw = fopen (world_file, \"w\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s for writing\\n\", world_file);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf (fpw, \"%.12f\\n0.0\\n0.0\\n%.12f\\n%.12f\\n%.12f\", x_inc, -y_inc, west, north);\n\t\t\t\tfclose (fpw);\tfpw = NULL;\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Wrote world file %s\\n\", world_file);\n\t\t\t\tif (proj4_cmd)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Proj4 definition: %s\\n\", proj4_cmd);\n\t\t\t}\n\n\t\t\tgmt_M_str_free (wext);\n\n\t\t\tif (Ctrl->W.warp && proj4_cmd && proj4_cmd[1] == 'p') {\t/* We got a usable Proj4 string. Run it (if gdal is around) */\n\t\t\t\t/* The true geotiff file will have the same base name plus a .tiff extension.\n\t\t\t\t   We will reuse the world_file variable because all it is need is to replace the extension */\n\t\t\t\tfor (i = (int)strlen(world_file) - 1; i > 0; i--) {\n\t\t\t\t\tif (world_file[i] == '.') { \t/* Beginning of file extension */\n\t\t\t\t\t\tpos_ext = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworld_file[pos_ext] = '\\0';\n\t\t\t\tstrcat (world_file, \".tiff\");\n\n\t\t\t\tif (GMT->current.setting.verbose < GMT_MSG_VERBOSE)\t/* Shut up the gdal_translate (low level) verbosity */\n\t\t\t\t\tquiet = \" -quiet\";\n\t\t\t\telse\n\t\t\t\t\tquiet = \"\";\n\n\t\t\t\tsprintf (cmd, \"gdal_translate -mo TIFFTAG_XRESOLUTION=%d -mo TIFFTAG_YRESOLUTION=%d -a_srs %c%s%c \"\n\t\t\t\t              \"-co COMPRESS=LZW -co TILED=YES %s %c%s%c %c%s%c\",\n\t\t\t\t\tCtrl->E.dpi, Ctrl->E.dpi, quote, proj4_cmd, quote, quiet, quote, out_file, quote, quote, world_file, quote);\n\t\t\t\tgmt_M_str_free (proj4_cmd);\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Running: %s\\n\", cmd);\n\t\t\t\tsys_retval = system (cmd);\t\t/* Execute the gdal_translate command */\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"The gdal_translate command: \\n%s\\n\", cmd);\n\t\t\t\tif (sys_retval) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"System call [%s] returned error %d.\\n\", cmd, sys_retval);\n\t\t\t\t\tReturn (GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Ctrl->W.warp && !proj4_cmd)\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Could not find the Proj4 command in the PS file. No conversion performed.\\n\");\n\t\t}\n\n\t\telse if (Ctrl->W.kml) {\t/* Write a basic kml file */\n\t\t\tchar kml_file[PATH_MAX] = \"\";\n\t\t\tif (Ctrl->D.active)\n\t\t\t\tsprintf (kml_file, \"%s/\", Ctrl->D.dir);\t/* Use specified output directory */\n\t\t\tif (Ctrl->F.active) {\t\t/* Must rip the raster file extension before adding the kml one */\n\t\t\t\tfor (i = (int)strlen(out_file) - 1; i > 0; i--) {\n\t\t\t\t\tif (out_file[i] == '.') { \t/* Beginning of file extension */\n\t\t\t\t\t\tpos_ext = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout_file[pos_ext] = '\\0';\n\t\t\t\tstrcat (kml_file, out_file);\n\t\t\t\tout_file[pos_ext] = '.';\t/* Reset the extension */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrncat (kml_file, &ps_file[pos_file], (size_t)(pos_ext - pos_file));\n\n\t\t\tstrcat (kml_file, \".kml\");\n\n\t\t\tif ((fpw = fopen (kml_file, \"w\")) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Unable to open file %s for writing\\n\", kml_file);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Ctrl->W.folder) {\t/* Control KML overlay vs full file */\n\t\t\t\t\tfprintf (fpw, \"<Folder>\\n\\t<name>%s</name>\\n\", Ctrl->W.foldername);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfprintf (fpw, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\t\t\t\tfprintf (fpw, \"<kml xmlns=\\\"http://earth.google.com/kml/2.1\\\">\\n\");\n\t\t\t\t}\n\t\t\t\tfprintf (fpw, \"<Document>\\n\\t<name>%s</name>\\n\", Ctrl->W.doctitle);\n\t\t\t\tfprintf (fpw, \"\\t<GroundOverlay>\\n\\t\\t<name>%s</name>\\n\", Ctrl->W.overlayname);\n\t\t\t\tfprintf (fpw, \"\\t\\t<Icon>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<href>\");\n\t\t\t\tif (Ctrl->W.URL) fprintf (fpw, \"%s/\", Ctrl->W.URL);\n\t\t\t\tif (Ctrl->D.active) {\t\t/* Do not write the directory name */\n\t\t\t\t\tchar *p;\n\t\t\t\t\tp = strrchr (out_file, '/');\n\t\t\t\t\t(p == NULL) ? fprintf (fpw, \"%s</href>\\n\", out_file) : fprintf (fpw, \"%s</href>\\n\", ++p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf (fpw, \"%s</href>\\n\", out_file);\n\t\t\t\tfprintf (fpw, \"\\t\\t</Icon>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t<altitudeMode>%s</altitudeMode>\\n\", RefLevel[Ctrl->W.mode]);\n\t\t\t\tif (Ctrl->W.mode > KML_GROUND_ABS && Ctrl->W.mode < KML_SEAFLOOR_ABS)\n\t\t\t\t\tfprintf (fpw, \"\\t\\t<altitude>%g</altitude>\\n\", Ctrl->W.altitude);\n\t\t\t\tfprintf (fpw, \"\\t\\t<LatLonBox>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<north>%f</north>\\n\", GMT->common.R.wesn[YHI]);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<south>%f</south>\\n\", GMT->common.R.wesn[YLO]);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<east>%f</east>\\n\", GMT->common.R.wesn[XHI]);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<west>%f</west>\\n\", GMT->common.R.wesn[XLO]);\n\t\t\t\tfprintf (fpw, \"\\t\\t</LatLonBox>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t<Region>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t<LatLonAltBox>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<north>%f</north>\\n\", north);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<south>%f</south>\\n\", south);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<east>%f</east>\\n\", east);\n\t\t\t\tfprintf (fpw, \"\\t\\t\\t<west>%f</west>\\n\", west);\n\t\t\t\tfprintf (fpw, \"\\t\\t</LatLonAltBox>\\n\");\n\t\t\t\tif (Ctrl->W.min_lod != Ctrl->W.max_lod) {\t/* Control layer visibility */\n \t\t\t\t\tfprintf (fpw, \"\\t\\t<Lod>\\n\");\n \t\t\t\t\tfprintf (fpw, \"\\t\\t\\t<minLodPixels>%d</minLodPixels>\\n\", Ctrl->W.min_lod);\n \t\t\t\t\tfprintf (fpw, \"\\t\\t\\t<maxLodPixels>%d</maxLodPixels>\\n\", Ctrl->W.max_lod);\n\t\t\t\t\tif (Ctrl->W.min_fade) fprintf (fpw, \"\\t\\t\\t<minFadeExtent>%d</minFadeExtent>\\n\", Ctrl->W.min_fade);\n\t \t\t\t\tif (Ctrl->W.max_fade) fprintf (fpw, \"\\t\\t\\t<maxFadeExtent>%d</maxFadeExtent>\\n\", Ctrl->W.max_fade);\n \t\t\t\t\tfprintf (fpw, \"\\t\\t</Lod>\\n\");\n\t\t\t\t}\n\t\t\t\tfprintf (fpw, \"\\t\\t</Region>\\n\");\n\t\t\t\tfprintf (fpw, \"\\t</GroundOverlay>\\n\");\n\t\t\t\tif (Ctrl->W.folder)\t/* Control KML overlay vs full file */\n\t\t\t\t\tfprintf (fpw, \"</Folder>\\n\");\n\t\t\t\telse\n\t\t\t\t\tfprintf (fpw, \"</Document>\\n</kml>\\n\");\n\t\t\t\tfclose (fpw);\tfpw = NULL;\n\t\t\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Wrote KML file %s\\n\", kml_file);\n\t\t\t}\n\t\t}\n\n\t\telse if (Ctrl->W.active && !found_proj) {\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"Could not find the 'PROJ' tag in the PS file. No world file created.\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"This situation occurs when one of the two next cases is true:\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"1) the PS file was created with a pre-GMT v4.5.0 version\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_NORMAL, \"2) the PS file was not created by GMT\\n\");\n\t\t}\n\t}\n\n\tif (!Ctrl->L.active)\t\t/* Otherwise ps_names contents are the Garbageman territory */\n\t\tfor (k = 0; k < Ctrl->In.n_files; k++) gmt_M_str_free (ps_names[k]);\n\tgmt_M_free (GMT, ps_names);\n\tgmt_M_free (GMT, line);\n\tgmt_M_free (GMT, PS);\n\t/* According to Coverity there are still paths that may reach here with the files not closed */\n\tif (fp != NULL) fclose (fp);\n\tif (fpo != NULL) fclose (fpo);\tif (fpb != NULL) fclose (fpb);\n\tif (fp2 != NULL) fclose (fp2);\tif (fpw != NULL) fclose (fpw);\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Final input buffer length was % \"PRIuS \"\\n\", line_size);\n\n\tReturn (GMT_NOERROR);\n}\n\n#ifdef WIN32\nGMT_LOCAL int ghostbuster(struct GMTAPI_CTRL *API, struct PS2RASTER_CTRL *C) {\n\t/* Search the Windows registry for the directory containing the gswinXXc.exe\n\t   We do this by finding the GS_DLL that is a value of the HKLM\\SOFTWARE\\GPL Ghostscript\\X.XX\\ key\n\t   Things are further complicated because Win64 has TWO registries: one 32 and the other 64 bits.\n\t   Add to this that the installed GS version may be 32 or 64 bits, so we have to check for the\n\t   four GS_32|64 + GMT_32|64 combinations.\n\n\t\t Adapted from snipets at http://www.daniweb.com/software-development/c/code/217174\n\t   and http://juknull.wordpress.com/tag/regenumkeyex-example */\n\n\tHKEY hkey;              /* Handle to registry key */\n\tchar data[GMT_LEN256] = {\"\"}, ver[8] = {\"\"}, *ptr;\n\tchar key[32] = \"SOFTWARE\\\\GPL Ghostscript\\\\\";\n\tunsigned long datalen = GMT_LEN256;\n\tunsigned long datatype;\n\tlong RegO, rc = 0;\n\tint n = 0;\n\tbool bits64 = true;\n\tfloat maxVersion = 0;\t\t/* In case more than one GS, hold the number of the highest version */\n\n#ifdef _WIN64\n\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\GPL Ghostscript\", 0, KEY_READ, &hkey);\t/* Read 64 bits Reg */\n\tif (RegO != ERROR_SUCCESS) {\t\t/* Try the 32 bits registry */\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\GPL Ghostscript\", 0, KEY_READ|KEY_WOW64_32KEY, &hkey);\n\t\tbits64 = false;\n\t}\n#else\n\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\GPL Ghostscript\", 0, KEY_READ, &hkey);\t/* Read 32 bits Reg */\n\tif (RegO != ERROR_SUCCESS)\t\t\t/* Failed. Try the 64 bits registry */\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\GPL Ghostscript\", 0, KEY_READ|KEY_WOW64_64KEY, &hkey);\n\telse {\n\t\tbits64 = false;\n\t}\n#endif\n\n\tif (RegO != ERROR_SUCCESS) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Error opening HKLM key\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\twhile (rc != ERROR_NO_MORE_ITEMS) {\n\t\trc  = RegEnumKeyEx (hkey, n++, data, &datalen, 0, NULL, NULL, NULL);\n\t\tdatalen = GMT_LEN256; /* reset to buffer length (including terminating \\0) */\n\t\tif (rc == ERROR_SUCCESS)\n\t\t\tmaxVersion = MAX(maxVersion, strtof(data, NULL));\t/* If more than one GS, keep highest version number */\n\t}\n\n\tRegCloseKey(hkey);\n\n\tif (maxVersion == 0) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Unknown version reported in registry\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\tsprintf(ver, \"%.2f\", maxVersion);\n\tstrcat(key, ver);\n\n\t/* Open the HKLM key, key, from which we wish to get data.\n\t   But now we already know the registry bitage */\n#ifdef _WIN64\n\tif (bits64)\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, 0, KEY_QUERY_VALUE, &hkey);\n\telse\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, 0, KEY_QUERY_VALUE|KEY_WOW64_32KEY, &hkey);\n#else\n\tif (bits64)\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, 0, KEY_QUERY_VALUE|KEY_WOW64_64KEY, &hkey);\n\telse\n\t\tRegO = RegOpenKeyEx(HKEY_LOCAL_MACHINE, key, 0, KEY_QUERY_VALUE, &hkey);\n#endif\n\tif (RegO != ERROR_SUCCESS) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Error opening HKLM key\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\t/* Read the value for \"GS_DLL\" via the handle 'hkey' */\n\tRegO = RegQueryValueEx(hkey, \"GS_DLL\", NULL, &datatype, (LPBYTE)data, &datalen);\n\n\tRegCloseKey(hkey);\n\n\tif (RegO != ERROR_SUCCESS) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"Error reading the GS_DLL value contents\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\tif ((ptr = strstr(data,\"\\\\gsdll\")) == NULL ) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"GS_DLL value is screwed.\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\t/* Truncate string and add affix gswinXXc.exe */\n\t*ptr = '\\0';\n\tstrcat(data, bits64 ? \"\\\\gswin64c.exe\" : \"\\\\gswin32c.exe\");\n\n\t/* Now finally check that the gswinXXc.exe exists */\n\tif (access (data, R_OK)) {\n\t\tGMT_Report (API, GMT_MSG_LONG_VERBOSE, \"gswinXXc.exe does not exist.\\n\");\n\t\treturn (GMT_RUNTIME_ERROR);\n\t}\n\n\t/* Wrap the path in double quotes to prevent troubles raised by dumb things like \"Program Files\" */\n\tC->G.file = malloc (strlen (data) + 3);\t/* strlen + 2 * \" + \\0 */\n\tsprintf (C->G.file, \"\\\"%s\\\"\", data);\n\n\treturn (GMT_NOERROR);\n}\n\n#endif\t\t/* WIN32 */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/src/gmt_sharedlibs.c": "/* $Id$\n *\n *\tCopyright (c) 2012-2018 by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe\n * See LICENSE.TXT file for copying and redistribution conditions.\n */\n\n/* Here are Windows implementations of standard POSIX shared\n * library function.  Borrowed from this website:\n * http://www.refcode.net/2013/02/posix-dynamic-library-loading-calls-for.html\n * which says it is open source.\n */\n\n#include \"gmt_dev.h\"\n#include \"gmt_sharedlibs.h\" \t/* Common shared libs structures */\n\n#if defined(_WIN32)\nvoid *dlopen (const char *module_name, int mode) {\t/* Opens a dll file*/\n\tUINT err_code;\n\tHINSTANCE dll_handle;\n\tgmt_M_unused (mode);\n  \n\terr_code = SetErrorMode (SEM_FAILCRITICALERRORS);\n\tdll_handle = LoadLibrary (module_name);\n\tif (!dll_handle) {\n\t\tdll_handle = LoadLibraryEx (module_name, NULL, 0);\n\t\tif (!dll_handle)\n\t\t\treturn (void *)dll_handle;\n \t}\n\n\t/* Clear the last error*/\n\tSetLastError (0); \n\treturn (void *)dll_handle;\n}\n\nint dlclose (void *handle) {\n\t/* Closes handle */\n\t/* POSIX call returns zero for success, non-zero for failure */\n\treturn (!FreeLibrary (handle)); \n}\n\nvoid *dlsym (void *handle, const char *name) {\n\t/* Get a symbol from dll */\n\treturn GetProcAddress (handle, name);\n}\n\nchar *dlerror (void) {\n\t/* Reports last error occurred */\n\tint len, error_code;\n\tstatic char errstr[GMT_LEN128];\n        \n\tif ((error_code = GetLastError ()) == 0)\n\t\treturn NULL;\n\n\t/* POSIX dlerror call needs to report no error (null) \n\t   when it is called 2nd time consequently, so clear error */\n\tSetLastError (0); \n\n\t/* Format the error string */\n\tlen = snprintf (errstr, GMT_LEN128, \"Error <%d>: \", error_code);\n\tlen += FormatMessage ( \n\t\tFORMAT_MESSAGE_FROM_SYSTEM,\n\t\tNULL,\n\t\terror_code,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\n\t\t(LPTSTR) errstr + len,\n\t\tsizeof(errstr) - len,\n\t\tNULL \n\t\t);\n    \n\t/* Replace \\r\\n */\n\tif (len > 1 && errstr[len-2] == '\\r' && errstr[len-1] == '\\n') {\n\t\tif (len > 2 && errstr[len-3] == '.')\n\t\t\tlen--;\n\t}\n\n\treturn errstr;\n}\n\n/* Extra convenience function for opening DLL of current process */\nHINSTANCE GetMyModuleHandle() {\n\t/* http://stackoverflow.com/questions/846044/how-to-get-the-filename-of-a-dll */\n\tMEMORY_BASIC_INFORMATION mbi;\n\tVirtualQuery(GetMyModuleHandle, &mbi, sizeof(mbi));\n\treturn (HINSTANCE) (mbi.AllocationBase);\n}\nvoid *dlopen_special(const char *name) {\n\t/* Opens the dll file of the current process.  This is how it is done\n\t * under Windows, per http://en.wikipedia.org/wiki/Dynamic_loading */\n\t/*HMODULE this_process, this_process_again;\n\tGetModuleHandleEx (0, 0, &this_process);\n\tthis_process_again = GetModuleHandle (NULL);\n\treturn (this_process_again);*/\n\tgmt_M_unused (name);\n\tHINSTANCE this_dll_process;\n\tthis_dll_process = GetMyModuleHandle();\n\treturn (this_dll_process);\n}\n#elif defined(__CYGWIN__)\n\t/* Cygwin behaves differently than most Unix and we must use regular dlopen with library name */\nvoid *dlopen_special(const char *name) {\n\t/* Opens the shared library file of the current process under *nix.\n\t * Just call dlopen with NULL and RTLD_LAZY */\n\treturn (dlopen (name, RTLD_LAZY));\n}\n#else\n\n/* Extra convenience function for opening shared library of current process */\n\nvoid *dlopen_special(const char *name) {\n\t/* Opens the shared library file of the current process under *nix.\n\t * Just call dlopen with NULL and RTLD_LAZY */\n\tgmt_M_unused(name);\n\treturn (dlopen (NULL, RTLD_LAZY));\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/cmake/modules/ConfigureChecks.cmake": "#\n# $Id$\n#\n\nif(NOT DEFINED _INCLUDED_CHECK_MACROS_)\n\tset(_INCLUDED_CHECK_MACROS_ \"DEFINED\")\n\n\tinclude (CheckCCompilerFlag)\n\tinclude (CheckCSourceCompiles)\n\tinclude (CheckCSourceRuns)\n\tinclude (CheckFunctionExists)\n\tinclude (CheckIncludeFile)\n\tinclude (CheckIncludeFiles)\n\tinclude (CheckLibraryExists)\n\tinclude (CheckPrototypeExists)\n\tinclude (CheckSymbolExists)\n\tinclude (CheckTypeExists)\n\tinclude (CheckTypeSize)\n\tinclude (CMakePushCheckState)\n\tinclude (TestBigEndian)\n\nendif(NOT DEFINED _INCLUDED_CHECK_MACROS_)\n\n#\n# Check if compiler supports -traditional-cpp\n#\n\nif (NOT HAVE_TRADITIONAL_CPP)\n\tif (MSVC)\n\t\t# Visual C++\n\t\tset (_cpp_cmdline /EP)\n\telseif (CMAKE_C_COMPILER_ID MATCHES \"(GNU|Clang|Intel)\")\n\t\t# GCC, Clang, or ICC\n\t\tset (_cpp_cmdline -E -w -P -nostdinc -traditional-cpp)\n\tendif (MSVC)\n\tmessage (STATUS \"Performing Test HAVE_TRADITIONAL_CPP\")\n\texecute_process (COMMAND ${CMAKE_C_COMPILER} ${_cpp_cmdline}\n\t\t${GMT_SOURCE_DIR}/config.h.in # can be any header file\n\t\tRESULT_VARIABLE _cpp_traditional_result\n\t\tOUTPUT_QUIET ERROR_QUIET)\n\tif (_cpp_traditional_result EQUAL 0)\n\t\tset (HAVE_TRADITIONAL_CPP TRUE CACHE INTERNAL \"Test HAVE_TRADITIONAL_CPP\")\n\t\tmessage (STATUS \"Performing Test HAVE_TRADITIONAL_CPP - Success\")\n\telse (_cpp_traditional_result EQUAL 0)\n\t\tset (HAVE_TRADITIONAL_CPP \"\" CACHE INTERNAL \"Test HAVE_TRADITIONAL_CPP\")\n\t\tmessage (STATUS \"Performing Test HAVE_TRADITIONAL_CPP - Failed\")\n\tendif (_cpp_traditional_result EQUAL 0)\nendif (NOT HAVE_TRADITIONAL_CPP)\n\n#\n# Check if compiler supports __func__ or __FUNCTION__ identifier\n#\n\ncheck_c_source_compiles (\n\t\"\n\tint main (){char *function_name = __func__; return 0;}\n\t\"\n\tHAVE___FUNC__)\ncheck_c_source_compiles (\n\t\"\n\tint main (){char *function_name = __FUNCTION__; return 0;}\n\t\"\n\tHAVE___FUNCTION__)\n\n\n#\n# Check if compiler supports inline functions\n# This test is adapted from Jack Kelly on the CMake mailing list\n#\n\ncmake_push_check_state() # save state of CMAKE_REQUIRED_*\nforeach (KEYWORD \"inline\" \"__inline\" \"__inline__\")\n\tif (NOT DEFINED HAVE_C_INLINE)\n\t\tset (CMAKE_REQUIRED_DEFINITIONS -Dinline=${KEYWORD})\n\t\tcheck_c_source_compiles(\n\t\t\t\"\n\t\t\ttypedef int foo_t;\n\t\t\tstatic inline foo_t static_foo () {return 0;}\n\t\t\tfoo_t foo () {return 0;}\n\t\t\tint main (int argc, char *argv[]) {return 0;}\n\t\t\t\"\n\t\t\tHAVE_C_${KEYWORD})\n\t\tif (HAVE_C_${KEYWORD})\n\t\t\tset (HAVE_C_INLINE TRUE)\n\t\tendif (HAVE_C_${KEYWORD})\n\tendif (NOT DEFINED HAVE_C_INLINE)\nendforeach (KEYWORD)\ncmake_pop_check_state() # restore state of CMAKE_REQUIRED_*\n\n#\n# Check for windows header\n#\n\ncheck_include_file (io.h                HAVE_IO_H_)\ncheck_include_file (direct.h            HAVE_DIRECT_H_)\ncheck_include_file (process.h           HAVE_PROCESS_H_)\n\n#\n# Check for C99 and libc extensions\n#\n\n# strdup, sincos, ... are GNU/BSD/Sun extensions:\ncmake_push_check_state()\nset (CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}\n\t-D_GNU_SOURCE\n\t-D__EXTENSIONS__\n\t-D_LARGEFILE_SOURCE\n\t-D_LARGEFILE64_SOURCE)\n\ncheck_include_file (assert.h            HAVE_ASSERT_H_)\ncheck_include_file (dirent.h            HAVE_DIRENT_H_)\ncheck_include_file (errno.h             HAVE_ERRNO_H_)\ncheck_include_file (execinfo.h          HAVE_EXECINFO_H_)\ncheck_include_file (fcntl.h             HAVE_FCNTL_H_)\ncheck_include_file (signal.h            HAVE_SIGNAL_H_)\ncheck_include_file (stdbool.h           HAVE_STDBOOL_H_)\ncheck_include_file (sys/dir.h           HAVE_SYS_DIR_H_)\ncheck_include_file (sys/resource.h      HAVE_SYS_RESOURCE_H_)\ncheck_include_file (sys/stat.h          HAVE_SYS_STAT_H_)\ncheck_include_file (sys/time.h          HAVE_SYS_TIME_H_)\ncheck_include_file (sys/ucontext.h      HAVE_SYS_UCONTEXT_H_)\ncheck_include_file (unistd.h            HAVE_UNISTD_H_)\n\ncheck_function_exists (fcntl            HAVE_FCNTL)\ncheck_function_exists (fopen64          HAVE_FOPEN64)\ncheck_function_exists (fseeko           HAVE_FSEEKO)\ncheck_function_exists (ftello           HAVE_FTELLO)\ncheck_function_exists (getopt           HAVE_GETOPT)\ncheck_function_exists (getpwuid         HAVE_GETPWUID)\ncheck_function_exists (abs              HAVE_ABS)\ncheck_function_exists (llabs            HAVE_LLABS)\ncheck_function_exists (pclose           HAVE_PCLOSE)\ncheck_function_exists (popen            HAVE_POPEN)\ncheck_function_exists (qsort_r          HAVE_QSORT_R)\nif (HAVE_QSORT_R)\n\t# check qsort_r compatibility\n\tcheck_c_source_runs (\n\t\t\"\n\t\t#include <stdlib.h>\n\t\t#include <assert.h>\n\t\tint cmp(const void *a, const void*b, void *c) {\n\t\tassert(c == NULL);\n\t\treturn *(int*)a - *(int*)b;\n\t\t}\n\t\tint main() {\n\t\tint array[5] = {7,3,5,2,8};\n\t\tint i;\n\t\tqsort_r(array,5,sizeof(int),cmp,NULL);\n\t\tfor (i=0;i<4;++i) {\n\t\tassert(array[i] < array[i+1]);\n\t\t}\n\t\treturn 0;\n\t\t}\n\t\t\"\n\t\tHAVE_QSORT_R_GLIBC)\nendif (HAVE_QSORT_R)\ncheck_function_exists (strcasecmp       HAVE_STRCASECMP)\ncheck_function_exists (strncasecmp      HAVE_STRNCASECMP)\ncheck_function_exists (stricmp          HAVE_STRICMP)\ncheck_function_exists (strnicmp         HAVE_STRNICMP)\ncheck_function_exists (strdup           HAVE_STRDUP)\ncheck_function_exists (strndup          HAVE_STRNDUP)\ncheck_function_exists (strsep           HAVE_STRSEP)\ncheck_function_exists (strtod           HAVE_STRTOD)\n# Note: trailing underscore = GDAL workaround\ncheck_function_exists (strtof           HAVE_STRTOF_)\ncheck_function_exists (strtok_r         HAVE_STRTOK_R)\n\nif (WIN32)\n\tcheck_function_exists (_fseeki64      HAVE__FSEEKI64)\n\tcheck_function_exists (_ftelli64      HAVE__FTELLI64)\n\tcheck_function_exists (_pclose        HAVE__PCLOSE)\n\tcheck_function_exists (_popen         HAVE__POPEN)\n\tcheck_function_exists (_stat          HAVE__STAT)\n\tcheck_function_exists (_stati64       HAVE__STATI64)\n\tcheck_function_exists (_fstat         HAVE__FSTAT)\n\tcheck_function_exists (_fstati64      HAVE__FSTATI64)\n\tcheck_function_exists (strtok_s       HAVE_STRTOK_S)\nendif (WIN32)\n\n# Check if these functions are declared (might not be the case although they\n# are build-in)\ncheck_symbol_exists (strdup    string.h DECLARED_STRDUP)\ncheck_symbol_exists (strsep    string.h DECLARED_STRSEP)\n\ncheck_symbol_exists (basename  libgen.h HAVE_BASENAME)\ncheck_symbol_exists (fileno    stdio.h  HAVE_FILENO)\ncheck_symbol_exists (setlocale locale.h HAVE_SETLOCALE)\n# Note: trailing underscore = GDAL workaround\ncheck_symbol_exists (snprintf  stdio.h  HAVE_SNPRINTF_)\ncheck_symbol_exists (vsnprintf stdio.h  HAVE_VSNPRINTF_)\n\nif (HAVE_UNISTD_H_)\n\tcheck_symbol_exists (access  unistd.h HAVE_ACCESS)\n\tcheck_symbol_exists (getpid  unistd.h HAVE_GETPID)\nelse (HAVE_UNISTD_H_)\n\t# in MinGW:\n\tcheck_symbol_exists (access  io.h     HAVE_ACCESS)\n\tcheck_symbol_exists (_getpid process.h HAVE__GETPID)\nendif (HAVE_UNISTD_H_)\n\nif (WIN32)\n\tcheck_symbol_exists (_access   io.h     HAVE__ACCESS)\n\tcheck_symbol_exists (_fileno   stdio.h  HAVE__FILENO)\n\tcheck_symbol_exists (_getcwd   direct.h HAVE__GETCWD)\n\tcheck_symbol_exists (_mkdir    direct.h HAVE__MKDIR)\n\tcheck_symbol_exists (_setmode  io.h     HAVE__SETMODE)\n\tcheck_symbol_exists (_snprintf stdio.h  HAVE__SNPRINTF_)\n\tcheck_symbol_exists (_vsnprintf stdio.h HAVE__VSNPRINTF_)\nendif (WIN32)\n\nif (UNIX)\n\t# Check if -ldl is needed for dladdr\n\tcheck_function_exists (dlopen HAVE_BUILTIN_DYNAMIC_LINKING_LOADER)\n\tif (NOT HAVE_BUILTIN_DYNAMIC_LINKING_LOADER)\n\t\tcheck_library_exists (dl dlopen \"\" HAVE_LIBDL)\n\tendif (NOT HAVE_BUILTIN_DYNAMIC_LINKING_LOADER)\n\tcmake_push_check_state() # save state of CMAKE_REQUIRED_*\n\tif (HAVE_LIBDL)\n\t\tset (CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} \"-ldl\")\n\tendif (HAVE_LIBDL)\n\tcheck_symbol_exists (dladdr dlfcn.h HAVE_DLADDR)\n\tcmake_pop_check_state() # restore state of CMAKE_REQUIRED_*\n\n\tcheck_function_exists (memalign       HAVE_MEMALIGN)\n\tcheck_function_exists (posix_memalign HAVE_POSIX_MEMALIGN)\n\n\tif (HAVE_UNISTD_H_)\n\t\t# Check if sysconf(_SC_NPROCESSORS_ONLN) can be used for CPU count\n\t\tcheck_c_source_compiles (\n\t\t\t\"\n\t\t\t#include <unistd.h>\n\t\t\tint main() {\n\t\t\t  sysconf(_SC_NPROCESSORS_ONLN);\n\t\t\t}\n\t\t\t\"\n\t\t\tHAVE_SC_NPROCESSORS_ONLN)\n\t\t# Check if sysconf(_SC_NPROC_ONLN) can be used for CPU count\n\t\tcheck_c_source_compiles (\n\t\t\t\"\n\t\t\t#include <unistd.h>\n\t\t\tint main() {\n\t\t\t  sysconf(_SC_NPROC_ONLN);\n\t\t\t}\n\t\t\t\"\n\t\t\tHAVE_SC_NPROC_ONLN)\n\tendif (HAVE_UNISTD_H_)\n\n\t# Check if sysctl can be used for CPU count\n\tcheck_c_source_compiles (\n\t\t\"\n\t\t#include <stddef.h>\n\t\t#include <sys/sysctl.h>\n\t\tint main () {\n\t\t  int count;\n\t\t  size_t size = sizeof(count);\n\t\t  int mib[] = { CTL_HW, HW_NCPU };\n\t\t  sysctl(mib, 2, &count, &size, NULL, 0);\n\t\t}\n\t\t\"\n\t\tHAVE_SYSCTL_HW_NCPU)\nendif (UNIX)\n\n#\n# Check c types\n#\n\ncheck_include_file (ctype.h             HAVE_CTYPE_H_)\ncheck_include_file (inttypes.h          HAVE_INTTYPES_H_)\n#check_include_file (stddef.h            HAVE_STDDEF_H_)\n#check_include_file (stdint.h            HAVE_STDINT_H_)\n#check_include_file (sys/types.h         HAVE_SYS_TYPES_H_)\n\n# set HAVE_SYS_TYPES_H, HAVE_STDINT_H, and HAVE_STDDEF_H\n# and check in <sys/types.h>, <stdint.h>, and <stddef.h>:\ncheck_type_size (_Bool                  SIZEOF__BOOL)\ncheck_type_size (bool                   SIZEOF_BOOL)\ncheck_type_size (int                    SIZEOF_INT)\nset (CMAKE_EXTRA_INCLUDE_FILES sys/ucontext.h)\ncheck_type_size (greg_t                 SIZEOF_GREG_T)\nset (CMAKE_EXTRA_INCLUDE_FILES)\ncheck_type_size (long                   SIZEOF_LONG)\ncheck_type_size (\"long long\"            SIZEOF_LONG_LONG)\ncheck_type_size (\"long double\"          SIZEOF_LONG_DOUBLE)\ncheck_type_size (mode_t                 SIZEOF_MODE_T)\ncheck_type_size (off_t                  SIZEOF_OFF_T)\ncheck_type_size (size_t                 SIZEOF_SIZE_T)\ncheck_type_size (wchar_t                SIZEOF_WCHAR_T)\ncheck_type_size (\"void*\"                SIZEOF_VOID_P)\n\n# add suffix to prevent name clash with GDAL\nset (HAVE_STDDEF_H_ \"${HAVE_STDDEF_H}\"\n\tCACHE INTERNAL \"Have include stddef.h\")\nset (HAVE_STDINT_H_ \"${HAVE_STDINT_H}\"\n\tCACHE INTERNAL \"Have include stdinf.h\")\nset (HAVE_SYS_TYPES_H_ \"${HAVE_SYS_TYPES_H}\"\n\tCACHE INTERNAL \"Have include sys/types.h\")\n\ntest_big_endian (WORDS_BIGENDIAN)\n\n# Byte swapping functions\ncheck_c_source_runs (\n\t\"\n\tint main(void) {\n\t\treturn !__builtin_bswap16(0xabcd) == 0xcdab;\n\t}\n\t\"\n\tHAVE___BUILTIN_BSWAP16)\ncheck_c_source_runs (\n\t\"\n\tint main(void) {\n\t\treturn !__builtin_bswap32(0xdeadbeef) == 0xefbeadde;\n\t}\n\t\"\n\tHAVE___BUILTIN_BSWAP32)\ncheck_c_source_runs (\n\t\"\n\tint main(void) {\n\t\treturn !__builtin_bswap64(0x1234567890abcdef) == 0xefcdab9078563412;\n\t}\n\t\"\n\tHAVE___BUILTIN_BSWAP64)\nif (WIN32)\n\tcheck_function_exists (_byteswap_ushort HAVE__BYTESWAP_USHORT) # for uint16_t\n\tcheck_function_exists (_byteswap_ulong  HAVE__BYTESWAP_ULONG)  # for uint32_t\n\tcheck_function_exists (_byteswap_uint64 HAVE__BYTESWAP_UINT64) # for uint64_t\nendif (WIN32)\n\n#\n# Check math related stuff\n#\n\n# extra math headers\n\ncheck_include_file (floatingpoint.h     HAVE_FLOATINGPOINT_H_)\ncheck_include_file (ieeefp.h            HAVE_IEEEFP_H_)\n\nset (_math_h math.h float.h)\nif (HAVE_FLOATINGPOINT_H_)\n\tlist (APPEND _math_h floatingpoint.h)\nendif (HAVE_FLOATINGPOINT_H_)\nif (HAVE_IEEEFP_H_)\n\tlist (APPEND _math_h ieeefp.h)\nendif (HAVE_IEEEFP_H_)\n\n# Check if -lm is needed\ncheck_function_exists (cos HAVE_M_FUNCTIONS)\nif (NOT HAVE_M_FUNCTIONS)\n\tcheck_library_exists (m cos \"\" HAVE_M_LIBRARY)\nendif (NOT HAVE_M_FUNCTIONS)\n\n# If necessary compile with -lm\nif (HAVE_M_LIBRARY)\n\tset (CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} \"-lm\")\nendif (HAVE_M_LIBRARY)\n\n# check symbols (double)\ncheck_symbol_exists (acosh       \"${_math_h}\" HAVE_ACOSH)\ncheck_symbol_exists (asinh       \"${_math_h}\" HAVE_ASINH)\ncheck_symbol_exists (atanh       \"${_math_h}\" HAVE_ATANH)\ncheck_symbol_exists (copysign    \"${_math_h}\" HAVE_COPYSIGN)\ncheck_symbol_exists (erf         \"${_math_h}\" HAVE_ERF)\ncheck_symbol_exists (erfc        \"${_math_h}\" HAVE_ERFC)\ncheck_symbol_exists (hypot       \"${_math_h}\" HAVE_HYPOT)\ncheck_symbol_exists (isfinite    \"${_math_h}\" HAVE_ISFINITE)\ncheck_symbol_exists (isinf       \"${_math_h}\" HAVE_ISINF)\ncheck_symbol_exists (isnan       \"${_math_h}\" HAVE_ISNAN)\ncheck_symbol_exists (isnand      \"${_math_h}\" HAVE_ISNAND)\ncheck_symbol_exists (isnanf      \"${_math_h}\" HAVE_ISNANF)\ncheck_symbol_exists (isnormal    \"${_math_h}\" HAVE_ISNORMAL)\ncheck_symbol_exists (j0          \"${_math_h}\" HAVE_J0)\ncheck_symbol_exists (j1          \"${_math_h}\" HAVE_J1)\ncheck_symbol_exists (jn          \"${_math_h}\" HAVE_JN)\ncheck_symbol_exists (lrint       \"${_math_h}\" HAVE_LRINT)\ncheck_symbol_exists (llrint      \"${_math_h}\" HAVE_LLRINT)\ncheck_symbol_exists (log1p       \"${_math_h}\" HAVE_LOG1P)\ncheck_symbol_exists (log2        \"${_math_h}\" HAVE_LOG2)\ncheck_symbol_exists (rint        \"${_math_h}\" HAVE_RINT)\ncheck_symbol_exists (sincos      \"${_math_h}\" HAVE_SINCOS)\ncheck_symbol_exists (y0          \"${_math_h}\" HAVE_Y0)\ncheck_symbol_exists (y1          \"${_math_h}\" HAVE_Y1)\ncheck_symbol_exists (yn          \"${_math_h}\" HAVE_YN)\n# check symbols (float)\ncheck_symbol_exists (acosf       \"${_math_h}\" HAVE_ACOSF)\ncheck_symbol_exists (acoshf      \"${_math_h}\" HAVE_ACOSHF)\ncheck_symbol_exists (asinf       \"${_math_h}\" HAVE_ASINF)\ncheck_symbol_exists (asinhf      \"${_math_h}\" HAVE_ASINHF)\ncheck_symbol_exists (atanf       \"${_math_h}\" HAVE_ATANF)\ncheck_symbol_exists (atanhf      \"${_math_h}\" HAVE_ATANHF)\ncheck_symbol_exists (atan2f      \"${_math_h}\" HAVE_ATAN2F)\ncheck_symbol_exists (erff        \"${_math_h}\" HAVE_ERFF)\ncheck_symbol_exists (ceilf       \"${_math_h}\" HAVE_CEILF)\ncheck_symbol_exists (cosf        \"${_math_h}\" HAVE_COSF)\ncheck_symbol_exists (coshf       \"${_math_h}\" HAVE_COSHF)\ncheck_symbol_exists (erfcf       \"${_math_h}\" HAVE_ERFCF)\ncheck_symbol_exists (expf        \"${_math_h}\" HAVE_EXPF)\ncheck_symbol_exists (fabsf       \"${_math_h}\" HAVE_FABSF)\ncheck_symbol_exists (floorf      \"${_math_h}\" HAVE_FLOORF)\ncheck_symbol_exists (fmodf       \"${_math_h}\" HAVE_FMODF)\ncheck_symbol_exists (hypotf      \"${_math_h}\" HAVE_HYPOTF)\ncheck_symbol_exists (logf        \"${_math_h}\" HAVE_LOGF)\ncheck_symbol_exists (log2f       \"${_math_h}\" HAVE_LOG2F)\ncheck_symbol_exists (log10f      \"${_math_h}\" HAVE_LOG10F)\ncheck_symbol_exists (log1pf      \"${_math_h}\" HAVE_LOG1PF)\ncheck_symbol_exists (lrintf      \"${_math_h}\" HAVE_LRINTF)\ncheck_symbol_exists (llrintf     \"${_math_h}\" HAVE_LLRINTF)\ncheck_symbol_exists (powf        \"${_math_h}\" HAVE_POWF)\ncheck_symbol_exists (rintf       \"${_math_h}\" HAVE_RINTF)\ncheck_symbol_exists (sinf        \"${_math_h}\" HAVE_SINF)\ncheck_symbol_exists (sinhf       \"${_math_h}\" HAVE_SINHF)\ncheck_symbol_exists (sqrtf       \"${_math_h}\" HAVE_SQRTF)\ncheck_symbol_exists (tanf        \"${_math_h}\" HAVE_TANF)\ncheck_symbol_exists (tanhf       \"${_math_h}\" HAVE_TANHF)\n\nif (WIN32)\n\tcheck_symbol_exists (_copysign \"${_math_h}\" HAVE__COPYSIGN)\n\tcheck_symbol_exists (_finite   \"${_math_h}\" HAVE__FINITE)\n\tcheck_symbol_exists (_fpclass  \"${_math_h}\" HAVE__FPCLASS)\n\tcheck_symbol_exists (_isnan    \"${_math_h}\" HAVE__ISNAN)\nendif (WIN32)\n\n# restore state of CMAKE_REQUIRED_*\ncmake_pop_check_state()\n\n#check_symbol_exists (intptr_t \"stdint.h\" HAVE_STDINT_H_WITH_INTPTR)\n#check_symbol_exists (intptr_t \"unistdint.h\" HAVE_UNISTD_H_WITH_INTPTR)\n\n#check_function_exists (__argz_count HAVE___ARGZ_COUNT)\n#check_function_exists (__argz_next HAVE___ARGZ_NEXT)\n#check_function_exists (__argz_stringify HAVE___ARGZ_STRINGIFY)\n#check_function_exists (__fsetlocking HAVE___FSETLOCKING)\n#check_function_exists (_close HAVE__CLOSE)\n#check_function_exists (_dyld_func_lookup HAVE_DYLD)\n#check_function_exists (_open HAVE__OPEN)\n#check_function_exists (_pclose HAVE__PCLOSE)\n#check_function_exists (_popen HAVE__POPEN)\n#check_function_exists (argz_append HAVE_ARGZ_APPEND)\n#check_function_exists (argz_create_sep HAVE_ARGZ_CREATE_SEP )\n#check_function_exists (argz_insert HAVE_ARGZ_INSERT )\n#check_function_exists (argz_next HAVE_ARGZ_NEXT)\n#check_function_exists (argz_stringify HAVE_ARGZ_STRINGIFY )\n#check_function_exists (chmod HAVE_CHMOD)\n#check_function_exists (clock_gettime HAVE_CLOCK_GETTIME)\n#check_function_exists (close HAVE_CLOSE)\n#check_function_exists (dcgettext HAVE_DCGETTEXT)\n#check_function_exists (dladdr HAVE_DLADDR)\n#check_function_exists (dlerror HAVE_DLERROR)\n#check_function_exists (getcwd HAVE_GETCWD)\n#check_function_exists (getegid HAVE_GETEGID)\n#check_function_exists (getgid HAVE_GETGID)\n#check_function_exists (gethrtime HAVE_GETHRTIME)\n#check_function_exists (getpagesize HAVE_GETPAGESIZE)\n#check_function_exists (gettext HAVE_GETTEXT)\n#check_function_exists (getuid HAVE_GETUID)\n#check_function_exists (getwd HAVE_GETWD)\n#check_function_exists (index HAVE_INDEX)\n#check_function_exists (mach_absolute_time HAVE_MACH_ABSOLUTE_TIME)\n#check_function_exists (mempcpy HAVE_MEMPCPY)\n#check_function_exists (mkfifo HAVE_MKFIFO)\n#check_function_exists (mkstemp HAVE_MKSTEMP)\n#check_function_exists (mktemp HAVE_MKTEMP)\n#check_function_exists (mktime HAVE_MKTIME)\n#check_function_exists (mmap HAVE_MMAP)\n#check_function_exists (open HAVE_OPEN)\n#check_function_exists (opendir HAVE_OPENDIR)\n#check_function_exists (pclose HAVE_PCLOSE)\n#check_function_exists (popen HAVE_POPEN)\n#check_function_exists (putenv HAVE_PUTENV)\n#check_function_exists (read_real_time HAVE_READ_REAL_TIME)\n#check_function_exists (readdir HAVE_READDIR)\n#check_function_exists (setlocale HAVE_SETLOCALE)\n#check_function_exists (shl_load HAVE_SHL_LOAD)\n#check_function_exists (stpcpy HAVE_STPCPY)\n#check_function_exists (strcasecmp HAVE_STRCASECMP)\n#check_function_exists (strcoll HAVE_STRCOLL)\n#check_function_exists (strcspn HAVE_STRCSPN)\n#check_function_exists (strcspn HAVE_STRERROR)\n#check_function_exists (strdup HAVE_STRDUP)\n#check_function_exists (strerror HAVE_STRERROR)\n#check_function_exists (strftime HAVE_STRFTIME)\n#check_function_exists (strlcat HAVE_STRLCAT)\n#check_function_exists (strlcpy HAVE_STRLCPY)\n#check_function_exists (strspn HAVE_STRSPN)\n#check_function_exists (strstr HAVE_STRSTR)\n#check_function_exists (strtod HAVE_STRTOD)\n#check_function_exists (strtol HAVE_STRTOL)\n#check_function_exists (strtoul HAVE_STRTOUL)\n#check_function_exists (time_base_to_time HAVE_TIME_BASE_TO_TIME)\n#check_function_exists (tsearch HAVE_TSEARCH)\n#check_function_exists (vprintf HAVE_VPRINTF )\n#check_function_exists (wcslen HAVE_WCSLEN)\n#check_include_file (argz.h HAVE_ARGZ_H)\n#check_include_file (c_asm.h HAVE_C_ASM_H)\n#check_include_file (dl.h HAVE_DL_H)\n#check_include_file (dlfcn.h HAVE_DLADDR  )\n#check_include_file (dlfcn.h HAVE_DLFCN_H)\n#check_include_file (ffi.h HAVE_FFI_H)\n#check_include_file (intrinsics.h HAVE_INTRINSICS_H)\n#check_include_file (sys/time.h have_hrtime_t)\n#check_include_file (mach-o/dyld.h HAVE_MACH_O_DYLD_H  )\n#check_include_file (mach/mach_time.h  HAVE_MACH_MACH_TIME_H)\n#check_include_file (machine/endian.h    HAVE_MACHINE_ENDIAN_H_)\n#check_include_file (argz.h HAVE_ARGZ_H)\n#check_include_file (io.h HAVE_IO_H)\n#check_include_file (limits.h HAVE_LIMITS_H)\n#check_include_file (locale.h HAVE_LOCALE_H)\n#check_include_file (memory.h HAVE_MEMORY_H)\n#check_include_file (ndir.h HAVE_NDIR_H)\n#check_include_file (pthread.h HAVE_PTHREAD_H)\n#check_include_file (stdlib.h HAVE_STDLIB_H)\n#check_include_file (string.h HAVE_STRING_H)\n#check_include_file (strings.h HAVE_STRINGS_H)\n#check_include_file (sys/dl.h HAVE_SYS_DL_H )\n#check_include_file (sys/socket.h HAVE_SYS_SOCKET_H)\n#check_include_file (sys/stat.h HAVE_SYS_STAT_H )\n#check_include_file (sys/stat.h HAVE_SYS_STAT_H)\n#check_include_file (sys/time.h HAVE_SYS_TIME_H )\n#check_include_file (sys/time.h HAVE_SYS_TIME_H)\n#check_include_file (sys/types.h HAVE_SYS_TYPES_H )\n#check_include_file (sys/types.h HAVE_SYS_TYPES_H)\n#check_include_file (sys/utime.h HAVE_SYS_UTIME_H)\n#check_include_file (utime.h HAVE_UTIME_H)\n#check_library_exists (dl dl \"/lib;/usr/lib;/usr/local/lib;/usr/pkg/lib\" HAVE_LIBDL)\n#check_symbol_exists (LC_MESSAGES \"locale.h\" HAVE_LC_MESSAGES)\n#check_symbol_exists (asprintf \"stdio.h\" HAVE_ASPRINTF)\n#check_symbol_exists (intmax_t \"inttypes.h\" HAVE_INTTYPES_H_WITH_UINTMAX)\n#check_symbol_exists (pid_t \"sys/types.h\" HAVE_PID_T)\n#check_symbol_exists (printf \"stdio.h\" HAVE_POSIX_PRINTF)\n#check_symbol_exists (uintmax_t \"stdint.h\" HAVE_STDINT_H_WITH_UINTMAX)\n#check_symbol_exists (wprintf \"stdio.h\" HAVE_WPRINTF)\n#check_type_size (\"long double\"         SIZEOF_LONG_DOUBLE)\n#check_type_size (\"long long\" SIZEOF_LONG_LONG)\n#check_type_size (char           SIZEOF_CHAR)\n#check_type_size (double         SIZEOF_DOUBLE)\n#check_type_size (float         SIZEOF_FLOAT)\n#check_type_size (int            SIZEOF_INT)\n#check_type_size (long           SIZEOF_LONG) \n#check_type_size (short          SIZEOF_SHORT)\n\nif (NOT DEFINED STDC_HEADERS)\n\tmessage (STATUS \"Checking whether system has ANSI C header files\")\n\tcheck_include_files (\"stdlib.h;stdarg.h;string.h;float.h\" StandardHeadersExist)\n\tif (StandardHeadersExist)\n\t\tcheck_prototype_exists (memchr string.h memchrExists)\n\t\tif (memchrExists)\n\t\t\tcheck_prototype_exists (free stdlib.h freeExists)\n\t\t\tif (freeExists)\n\t\t\t\t#include (TestForHighBitCharacters)\n\t\t\t\t#if (CMAKE_HIGH_BIT_CHARACTERS)\n\t\t\t\tmessage (STATUS \"ANSI C header files - found\")\n\t\t\t\tset (STDC_HEADERS 1 CACHE INTERNAL \"System has ANSI C header files\")\n\t\t\t\t#endif (CMAKE_HIGH_BIT_CHARACTERS)\n\t\t\tendif (freeExists)\n\t\tendif (memchrExists)\n\tendif (StandardHeadersExist)\n\tif (NOT STDC_HEADERS)\n\t\tmessage (STATUS \"ANSI C header files - not found\")\n\t\tset (STDC_HEADERS 0 CACHE INTERNAL \"System has ANSI C header files\")\n\tendif (NOT STDC_HEADERS)\nendif (NOT DEFINED STDC_HEADERS)\n\n# Define to 1 if you can safely include both <sys/time.h> and <time.h>\n#if (HAVE_SYS_TIME_H)\n#   check_include_files (\"sys/time.h;time.h\" TIME_WITH_SYS_TIME)\n#else (HAVE_SYS_TIME_H)\n#   set (TIME_WITH_SYS_TIME 0)\n#endif (HAVE_SYS_TIME_H)\n\n# Define to 1 if your <sys/time.h> declares `struct tm'. */\n#check_type_exists (\"struct tm\" sys/time.h TM_IN_SYS_TIME)\n\n#check_cxx_source_compiles (\n#   \"\n#   #include <algorithm>\n#   using std::count;\n#   int countChar(char * b, char * e, char const c)\n#   {\n#       return count (b, e, c);\n#   }\n#   int main (){return 0;}\n#   \"\n#HAVE_STD_COUNT)\n\n#check_cxx_source_compiles (\n#   \"\n#   #include <cctype>\n#   using std::tolower;\n#   int main (){return 0;}\n#   \"\n#CXX_GLOBAL_CSTD)\n\n#   check_c_source_compiles (\n#     \"\n#     #include <iconv.h>\n#     // this declaration will fail when there already exists a non const char** version which returns size_t\n#     double iconv(iconv_t cd,  char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);\n#     int main () { return 0; }\n#     \"\n#   HAVE_ICONV_CONST)\n#\n#   check_c_source_compiles (\n#     \"\n#     #include <stdlib.h>\n#     int i[ ( sizeof(wchar_t)==2 ? 1 : -1 ) ];\n#     int main (){return 0;}\n#     \"\n#   SIZEOF_WCHAR_T_IS_2)\n#\n#   check_c_source_compiles (\n#     \"\n#     #include <stdlib.h>\n#     int i[ ( sizeof(wchar_t)==4 ? 1 : -1 ) ];\n#     int main (){return 0;}\n#     \"\n#   SIZEOF_WCHAR_T_IS_4)\n\n# vim: textwidth=78 noexpandtab tabstop=2 softtabstop=2 shiftwidth=2\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/src/segy/wa1_mig13.segy",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_it.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_gr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_jp.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_fi.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_pl.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_is.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_cn1.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_ru.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_cn2.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_se.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_es.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_hu.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_tr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_de.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_dk.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_fr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/br.d",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/localization/gmt_il.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/spotter/Global_EarthByte_Plate_ID_Table.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/spotter/Global_EarthByte_Plate_ID_Table_AREPS.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/psldemo/vader.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/psldemo/circuit.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_62.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_50.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_34.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_37.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_18.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_33.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_80.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_31.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_08.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_67.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_81.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_30.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_75.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_16.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_88.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_29.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_87.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_23.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_79.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_36.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_89.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_01.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_03.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_78.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_90.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_65.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_54.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_46.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_84.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_42.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_57.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_77.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_51.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_55.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_60.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_59.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_20.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_56.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_13.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_82.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_35.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_47.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_26.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_22.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_58.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_11.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_25.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_38.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_39.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_76.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_21.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_02.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_53.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_85.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_12.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_72.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_17.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_70.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_24.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_32.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_04.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_49.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_52.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_73.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_71.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_40.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_83.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_48.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_64.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_15.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_05.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_10.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_41.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_19.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_07.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_43.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_28.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_74.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_68.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_44.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_14.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_45.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_06.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_69.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_09.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_61.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_27.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_63.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_86.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/share/postscriptlight/PSL_pattern_66.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/grdread.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/afr.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/subset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/autointense.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/grdclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/grdcyclic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/grdwrap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/rendering.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/hovmuller.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/lonshift.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/globalgrid.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/gdal/needle.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/gdal/vader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdimage/gdal/needle.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscontour/thickness.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/x2sys_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/ss_faa.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/x2sys_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/x2sys_06.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/x2sys_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/x2sys/x2sys_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfft/white_noise.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfft/surf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfft/gfilter.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/nuvel1.vx.1.5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/shrink.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/wrapped.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/nuvel1.vy.1.5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/cartpol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdvector/sample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pshistogram/bdata.b",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sample1d/sample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/mapproject/waypoints.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/mapproject/oblmerc_down.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/mapproject/oblmerc_up.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/img/imgmap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pswiggle/wiggles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/datagrep.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/mixed_axes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/ErrorEllipseGeo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/vector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/tiling1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/endarrows.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/hexagone.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/tiling2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/plane_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/rectclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/urlquakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/ErrorEllipseCart.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/connections.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/rotrectangle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/gtec_tx_daily.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/linetrim.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/wrapping.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/windbarb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/linearrow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/repeat1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/txtsymb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/repeat2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/poleline.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping7.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/lon_vs_time.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/japquakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/gaps.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/lineclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/badpols.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/custom_symbol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/macros.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/nojump.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/geosegmentize.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/longjump.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/clipping2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/geovector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxy/geovector2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gshhg/comb_ants.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gshhg/two_ants.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdmask/geoholes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdmask/sphinout.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdmask/ogrtest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdmask/polarhole.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdmask/holes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/byteswap/binary.be",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/byteswap/binary.le",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/surface/periodic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/surface/periodic_pix.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psimage/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psimage/warning.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/snyder_map.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/etopo2-chesapeake.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/gridlines2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/hyperbolic_map.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/polar2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/etopo2-hawaii.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/pacific_map_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/gridlines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/Snyder_Section_23.doc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/gmt_genper_calling_command.doc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/General_Perspective_Projection_Notes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/genper/east_map_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/project/circles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pslegend/legend3D.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pslegend/legend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pslegend/SOEST_block4.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pslegend/lines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/segy/wa1_mig13.segy",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfilter/openmp.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfilter/highpass.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfilter/AFR.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdfilter/filtertest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pstext/cliptxtbox.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pstext/test.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/ogr/select.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/ogr/quakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/ogr/lookup.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/splitxyz/split.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdsample/straddle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtvector/meanvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/map_JE.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/inside.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/mapscales.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/annotations4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/rose_dir.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/annotations1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/rose_mag2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/oblique.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/test-JXd.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/annotations2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/mapbarlat.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psbasemap/rose_mag1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdtrend/data_w_nans.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdtrend/trend_robust.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sph2grd/one.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sph2grd/EGM96.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/pac_int.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/pac_age.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/pac_residual_topo.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/spotter/spotter_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtspatial/crossings.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtspatial/nn.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtspatial/intersect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtconnect/connect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/greenspline/gspline_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_13.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_11.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/meca/meca_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/mgd77/track.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxyz/vector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxyz/rotrectangle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxyz/geovector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psxyz/geovector2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sph/sph_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sph/sph_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/sph/sph_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/pssac_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/seis.sac",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/sdkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/onkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/ntkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pssac/nykl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grd2rgb/hill.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grd2rgb/Uluru.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/psmask/holes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtsimplify/reduce.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdlandmask/greenwich.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdlandmask/mask.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/geoid_1m.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/fc_okb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/bathy_1m.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/grdokb_grav.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/cseamounts.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/faa_noise.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/gpsgridder1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/case_largeR_noW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/case_smallR_noW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/potential/gseamounts.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grd2xyz/extract.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtselect/near_a_line.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/domo-filtrado.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/icelandbox.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/cuerpo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/categorical.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/autointense.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/denver.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/D3-25TV24-resid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdview/super2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdtrack/layout.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdtrack/profiles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/api/apivec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/api/apimat.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/kml/kml2gmt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/BigIsland.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/closed.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/contours.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/bigisland.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/test.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/grdtime.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/polcontr.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/tsu_chile60.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/xz-temp.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/grdtxtclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcontour/test.dat.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/gmtconvert/mix_binary_data.b",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/postscriptlight/psldemo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/grdcut/origin.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_JE3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_180.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_Madagascar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_JS.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_JW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_JM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/pscoast_mess.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/test/pscoast/dumpvsplot.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/cmake/dist/GMT.icns",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/formatting.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/formatpicture.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT5_external.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT5_mode.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT4_mode.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT_Environment.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT5_Summit_2016.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/noantialias.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/rendering.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/hsv-cone.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/GMT_Environment.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/highres.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/gimp-sliders+panel.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/fig/withantialias.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/tutorial/bermuda.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/tutorial/otemp.anal1deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/tutorial/us.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/atlantwhitesided.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commonporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/humpbacktail_two_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bottlenose_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-cleavage_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/beluga_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-lineation-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/killerwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/jumpback_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bowhead_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commondolphin_midlow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_inv.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhaletail.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/stripeddolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/srightwhaledolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/longfinnedpilotwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/beluga.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/graywhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifieddolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/southernrightwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spectacledporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bottlenose.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/graywhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/jumpback.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/pigmyspermwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/northernrightwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/seiwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-foliation-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/shortfinnedpilotwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bowhead_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commondolphin_midhigh.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/humpbacktail_one_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-foliation_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commondolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/stripeddolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/minkewhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/atlantwhitesided_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commonporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifieddolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/cuviersbeaked_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/pigmyspermwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/stripeddolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/rissosdolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bottlenose_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/humpbacktail_one.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-lineation-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhaletail_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_rake.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedbeakedwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commondolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/shortfinnedpilotwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/minkewhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/southernrightwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-joint.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/graywhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/seiwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/cuviersbeaked.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/finwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/finwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-foliation-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-foliation_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/pirata.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/finwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/shortfinnedpilotwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/burmeistersporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/srightwhaledolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-cleavage.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commonporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-lineation_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/seiwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/jumpback_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/killerwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifieddolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_medium.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/killerwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/atlantwhitesided_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/longfinnedpilotwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-lineation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/pigmyspermwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_gentle.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/northernrightwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/beluga_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/northernrightwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/minkewhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/bowhead.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/southernrightwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-joint_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/cuviersbeaked_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-lineation_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spectacledporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/burmeistersporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spectacledporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-cleavage_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/commondolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-joint_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/rissosdolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-foliation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_und.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/humpbacktail_two.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/rissosdolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/burmeistersporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedbeakedwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/geo-plane_steep.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/spermwhaletail_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/srightwhaledolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/longfinnedpilotwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_symbols/images/unidentifiedbeakedwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/gallery/users_contrib_script/images/vertical_slice.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/source/locale/en/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/themes/rtd/static/bg-header2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/rst/themes/rtd/static/bg-header1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex33/spac.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex33/example_33.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex19/circuit.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex27/tasman_grav.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex27/example_27.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex44/example_44.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex24/example_24.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex08/guinea_bay.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex08/example_08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex10/example_10.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/anim04/USEast_Coast.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/anim03/anim_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/anim03/Iceland.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex42/example_42.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex42/BEDMAP_elevation.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex07/example_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex15/example_15.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex48/etopo10m.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex20/example_20.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex16/circuit.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex49/depth_pixel.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex49/age_gridline.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex49/example_49.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex26/example_26.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex22/USGS.ras",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex22/example_22.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex02/example_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex02/HI_geoid2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex02/HI_topo2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex28/example_28.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex28/Kilauea.utm.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex36/example_36.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/europe-capitals-ru.csv",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/example_31.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinLibertine_Bd-4.1.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinBiolinum_Kb-0.5.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinLibertine_It-4.2.6.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinLibertine_Re-4.7.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinLibertine_C-4.0.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinBiolinum_Re-0.6.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinBiolinum_It-0.5.1.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinBiolinum_Bd-0.5.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinBiolinum_Sl-0.4.9.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex31/fonts/LinLibertine_BI-4.1.0.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex38/topo.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex38/example_38.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex09/example_09.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex46/example_46.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex18/AK_gulf_grav.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex18/example_18.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex37/grav.V18.par.surf.1km.sq.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex37/mb.par.surf.1km.sq.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex34/example_34.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex34/FR+IT.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex32/topo.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex32/euflag.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex32/euflag.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex29/example_29.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex17/india_topo.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex17/example_17.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex17/india_geoid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex04/example_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex04/HI_topo4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex04/HI_geoid4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex04/example_04c.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/anim02/anim_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/anim02/us.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex25/example_25.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex40/example_40.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/examples/ex01/osu91a1f_16.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_colorbar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_general_cyl.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_TM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_15.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_linear_d.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_11.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_albers.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_-B_geo_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_13.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/topo5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_Defaults_1a.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_K_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_K_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_9.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/nsf1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_stereographic_polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_polyconic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_9.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_equi_cyl.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_-B_geo_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_K_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_obl_merc.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_17.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_mag_rose.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_K_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_P_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_lambert_az_rect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_18.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_P_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_linearrow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_7.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_dir_rose.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_stereographic_rect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_miller.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_16.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_perspective.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_12.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_utm_zones.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_mapscale.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_-R.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_K_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_insert.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_Defaults_1b.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/geoid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_transverse_merc.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_equidistant_conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_lineoffset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_gnomonic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_lambert_conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/ttt_atl.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_obl_nz.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_19.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_gall_stereo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_cyclic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_stereographic_general.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_App_O_8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_cassini.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_tut_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-5.4.4-t36spjzrkanyr23wk7sr3gx2fo2oyril/spack-src/doc/scripts/GMT_mercator.ps"
    ],
    "total_files": 3234
}