{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/src/WriterPlugin.cc": "// -*- C++ -*-\n//\n// This file is part of HepMC\n// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)\n//\n///\n/// @file WriterPlugin.cc\n/// @brief Implementation of \\b class WriterPlugin\n///\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#define NOWINBASEINTERLOCK\n#define NOMINMAX\n#undef UNICODE\n#include <intrin.h>\n#include <windows.h>\n#endif\n#if defined(__linux__) || defined(__darwin__)\n#include <dlfcn.h>\n#endif\n#include <cstring>\n#include <sstream>\n#include \"HepMC3/WriterPlugin.h\"\n#include \"HepMC3/GenEvent.h\"\n\n\nnamespace HepMC3 {\n\nWriterPlugin::WriterPlugin(std::ostream & stream,const std::string &libname, const std::string &newwriter,std::shared_ptr<GenRunInfo> run) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    typedef Writer* (__stdcall *f_funci)(std::ostream & stream,shared_ptr<GenRunInfo>);\n    f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newwriter.c_str(),libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    m_writer=(Writer*)(newWriter(stream,run));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_writer=nullptr; return;  }\n    Writer* (*newWriter)(std::ostream & stream,std::shared_ptr<GenRunInfo>);\n    newWriter=(Writer* (*)(std::ostream & stream,std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newwriter.c_str(),libname.c_str(),dlerror()); m_writer=nullptr; return;   }\n    m_writer=(Writer*)(newWriter(stream,run));\n#endif\n\n\n}\nWriterPlugin::WriterPlugin(const std::string& filename,const std::string &libname, const std::string &newwriter,std::shared_ptr<GenRunInfo> run) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    typedef Writer* (__stdcall *f_funci)(const std::string&,shared_ptr<GenRunInfo>);\n    f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newwriter.c_str(),libname.c_str(),GetLastError()); m_writer=nullptr; return;  }\n    m_writer=(Writer*)(newWriter(filename,run));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_writer=nullptr; return;  }\n    Writer* (*newWriter)(const std::string&,std::shared_ptr<GenRunInfo>);\n    newWriter=(Writer* (*)(const std::string&,std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());\n    if (!newWriter) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newwriter.c_str(),libname.c_str(),dlerror()); m_writer=nullptr; return;   }\n    m_writer=(Writer*)(newWriter(filename,run));\n#endif\n}\n\nWriterPlugin::~WriterPlugin() {\n    if (m_writer) m_writer->close();\n    if (m_writer) delete m_writer;\n#ifdef WIN32\n    if(dll_handle) {\n        FreeLibrary((HINSTANCE)dll_handle);\n    }\n#endif\n#if defined(__linux__) || defined(__darwin__)\n    if(dll_handle) {\n        dlclose(dll_handle);\n        dll_handle = nullptr;\n    }\n#endif\n}\n} // namespace HepMC3\n",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/src/ReaderPlugin.cc": "// -*- C++ -*-\n//\n// This file is part of HepMC\n// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)\n//\n///\n/// @file ReaderPlugin.cc\n/// @brief Implementation of \\b class ReaderPlugin\n///\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#define NOWINBASEINTERLOCK\n#define NOMINMAX\n#undef UNICODE\n#include <intrin.h>\n#include <windows.h>\n#endif\n#if defined(__linux__) || defined(__darwin__)\n#include <dlfcn.h>\n#endif\n#include <cstring>\n#include <sstream>\n#include \"HepMC3/ReaderPlugin.h\"\n#include \"HepMC3/GenEvent.h\"\n\nnamespace HepMC3 {\n\nReaderPlugin::ReaderPlugin(std::istream & stream,const std::string &libname, const std::string &newreader) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    typedef Reader* (__stdcall *f_funci)(std::istream & stream);\n    f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newreader.c_str(),libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    m_reader=(Reader*)(newReader(stream));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_reader=nullptr; return;  }\n    Reader* (*newReader)(std::istream & stream);\n    newReader=(Reader* (*)(std::istream & stream))dlsym(dll_handle, newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newreader.c_str(),libname.c_str(),dlerror()); m_reader=nullptr; return;   }\n    m_reader=(Reader*)(newReader(stream));\n#endif\n\n}\n/** @brief Constructor */\nReaderPlugin::ReaderPlugin(const std::string& filename,const std::string &libname, const std::string &newreader) {\n\n#ifdef WIN32\n    dll_handle=nullptr;\n    dll_handle = LoadLibrary(libname.c_str());\n    if (!dll_handle) { printf(\"Error  while loading library %s. Error code %i\\n\",libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    typedef Reader* (__stdcall *f_funci)(const std::string&);\n    f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s. Error code %i\\n\",newreader.c_str(),libname.c_str(),GetLastError()); m_reader=nullptr; return;  }\n    m_reader=(Reader*)(newReader(filename));\n#endif\n\n#if defined(__linux__) || defined(__darwin__)\n    dll_handle=nullptr;\n    dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (!dll_handle) { printf(\"Error  while loading library %s: %s\\n\",libname.c_str(),dlerror()); m_reader=nullptr; return;  }\n    Reader* (*newReader)(const std::string&);\n    newReader=(Reader* (*)(const std::string&))dlsym(dll_handle, newreader.c_str());\n    if (!newReader) { printf(\"Error  while loading function %s from  library %s: %s\\n\",newreader.c_str(),libname.c_str(),dlerror()); m_reader=nullptr; return;   }\n    m_reader=(Reader*)(newReader(filename));\n#endif\n}\nReaderPlugin::~ReaderPlugin() {\n    if (m_reader) m_reader->close();\n    if (m_reader) delete m_reader;\n#ifdef WIN32\n    if(dll_handle) {\n        FreeLibrary((HINSTANCE)(dll_handle));\n    }\n#endif\n#if defined(__linux__) || defined(__darwin__)\n    if(dll_handle) {\n        dlclose(dll_handle);\n        dll_handle = nullptr;\n    }\n#endif\n}\n} // namespace HepMC3\n",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/python/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (tstate))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 3\n\n#if defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)       { e.restore();   return;\n                } catch (const builtin_exception &e) { e.set_error(); return;\n                }\n            }\n        );\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)           { e.restore();                                    return;\n                } catch (const builtin_exception &e)     { e.set_error();                                  return;\n                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n                } catch (...) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n                    return;\n                }\n            }\n        );\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/python/test/inputIO4.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/test/inputIO4.root",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/doc/doxygen/class_diagram_3.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-hepmc3-3.2.1-hydegkqkebw6344o2hsztqdn352d7aqa/spack-src/doc/doxygen/class_diagram.png"
    ],
    "total_files": 336
}