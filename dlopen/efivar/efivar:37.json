{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-efivar-37-6qad6nxbdhe5e4rjg67dfh4rjarf2ts6/spack-src/src/guid.c": "/*\n * libefivar - library for the manipulation of EFI variables\n * Copyright 2012-2014 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of the\n * License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see\n * <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"fix_coverity.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdio.h>\n\n#include \"efivar.h\"\n\n#define GUID_LENGTH_WITH_NUL 37\n\nextern const efi_guid_t efi_guid_zero;\n\nint NONNULL(1, 2) PUBLIC\nefi_guid_cmp(const efi_guid_t *a, const efi_guid_t *b)\n{\n\treturn memcmp(a, b, sizeof (efi_guid_t));\n}\n\nint NONNULL(1) PUBLIC\nefi_guid_is_zero(const efi_guid_t *guid)\n{\n\treturn !efi_guid_cmp(guid,&efi_guid_zero);\n}\n\nint\nefi_guid_is_empty(const efi_guid_t *guid)\n        NONNULL(1) PUBLIC ALIAS(efi_guid_is_zero);\n\nint NONNULL(1, 2) PUBLIC\nefi_str_to_guid(const char *s, efi_guid_t *guid)\n{\n\tint rc;\n\trc = text_to_guid(s, guid);\n\tif (rc < 0)\n\t\tefi_error(\"text_to_guid(\\\"%s\\\",...)\", s);\n\treturn rc;\n}\n\nint NONNULL(1) PUBLIC\nefi_guid_to_str(const efi_guid_t *guid, char **sp)\n{\n\tchar *ret = NULL;\n\tint rc = -1;\n\n\tif (!sp) {\n\t\trc = snprintf(NULL, 0, GUID_FORMAT,\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\t\tguid->e[4], guid->e[5]);\n\t} else if (sp && *sp) {\n\t\trc = snprintf(*sp, GUID_LENGTH_WITH_NUL, GUID_FORMAT,\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\t\tguid->e[4], guid->e[5]);\n\t} else {\n\t\trc = asprintf(&ret, GUID_FORMAT,\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\t\tguid->e[4], guid->e[5]);\n\t\tif (rc >= 0)\n\t\t\t*sp = ret;\n\t}\n\tif (rc < 0)\n\t\tefi_error(\"Could not format guid\");\n\treturn rc;\n}\n\nextern struct guidname efi_well_known_guids PUBLIC;\nextern struct guidname efi_well_known_names PUBLIC;\nextern struct guidname efi_well_known_guids_end PUBLIC;\nextern struct guidname efi_well_known_names_end PUBLIC;\n\nstatic int NONNULL(1, 2)\ncmpguidp(const void *p1, const void *p2)\n{\n\tstruct guidname *gn1 = (struct guidname *)p1;\n\tstruct guidname *gn2 = (struct guidname *)p2;\n\n\treturn memcmp(&gn1->guid, &gn2->guid, sizeof (gn1->guid));\n}\n\nstatic int NONNULL(1, 2)\ncmpnamep(const void *p1, const void *p2)\n{\n\tstruct guidname *gn1 = (struct guidname *)p1;\n\tstruct guidname *gn2 = (struct guidname *)p2;\n\n\treturn memcmp(gn1->name, gn2->name, sizeof (gn1->name));\n}\n\nstatic int NONNULL(1, 2)\n_get_common_guidname(const efi_guid_t *guid, struct guidname **result)\n{\n\tintptr_t end = (intptr_t)&efi_well_known_guids_end;\n\tintptr_t start = (intptr_t)&efi_well_known_guids;\n\tsize_t nmemb = (end - start) / sizeof (efi_well_known_guids);\n\n\tstruct guidname key;\n\tmemset(&key, '\\0', sizeof (key));\n\tmemcpy(&key.guid, guid, sizeof (*guid));\n\n\tstruct guidname *tmp;\n\ttmp = bsearch(&key, &efi_well_known_guids, nmemb,\n\t\t\tsizeof (efi_well_known_guids), cmpguidp);\n\tif (!tmp) {\n\t\t*result = NULL;\n\t\terrno = ENOENT;\n\t\tefi_error(\"GUID is not in common GUID list\");\n\t\treturn -1;\n\t}\n\n\t*result = tmp;\n\treturn 0;\n}\n\nint NONNULL(1, 2) PUBLIC\nefi_guid_to_name(efi_guid_t *guid, char **name)\n{\n\tstruct guidname *result;\n\tint rc = _get_common_guidname(guid, &result);\n\tif (rc >= 0) {\n\t\t*name = strndup(result->name, sizeof (result->name) -1);\n\t\treturn *name ? (int)strlen(*name) : -1;\n\t}\n\trc = efi_guid_to_str(guid, name);\n\tif (rc >= 0)\n\t\tefi_error_clear();\n\treturn rc;\n}\n\nint NONNULL(1, 2) PUBLIC\nefi_guid_to_symbol(efi_guid_t *guid, char **symbol)\n{\n\tstruct guidname *result;\n\tint rc = _get_common_guidname(guid, &result);\n\tif (rc >= 0) {\n\t\t*symbol = strndup(result->symbol, sizeof (result->symbol) -1);\n\t\treturn *symbol ? (int)strlen(*symbol) : -1;\n\t}\n\tefi_error_clear();\n\terrno = EINVAL;\n\treturn -1;\n}\n\nint NONNULL(1) PUBLIC\nefi_guid_to_id_guid(const efi_guid_t *guid, char **sp)\n{\n\tstruct guidname *result = NULL;\n\tchar *ret = NULL;\n\tint rc;\n\n\trc = _get_common_guidname(guid, &result);\n\tif (rc >= 0) {\n\t\tif (!sp) {\n\t\t\treturn snprintf(NULL, 0, \"{%s}\",\n\t\t\t\t\tresult->symbol + strlen(\"efi_guid_\"));\n\t\t} else if (sp && *sp) {\n\t\t\treturn snprintf(*sp, GUID_LENGTH_WITH_NUL + 2, \"{%s}\",\n\t\t\t\t\tresult->symbol + strlen(\"efi_guid_\"));\n\t\t}\n\n\t\trc = asprintf(&ret, \"{%s}\",\n\t\t\t\tresult->symbol + strlen(\"efi_guid_\"));\n\t\tif (rc >= 0)\n\t\t\t*sp = ret;\n\t\treturn rc;\n\t}\n\tif (!sp) {\n\t\treturn snprintf(NULL, 0, \"{\"GUID_FORMAT\"}\",\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\t\tguid->e[4], guid->e[5]);\n\t} else if (sp && *sp) {\n\t\treturn snprintf(*sp, GUID_LENGTH_WITH_NUL+2, \"{\"GUID_FORMAT\"}\",\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\t\tguid->e[4], guid->e[5]);\n\t}\n\trc = asprintf(&ret, \"{\"GUID_FORMAT\"}\",\n\t\t\t\tle32_to_cpu(guid->a),\n\t\t\t\tle16_to_cpu(guid->b),\n\t\t\t\tle16_to_cpu(guid->c),\n\t\t\t\tbe16_to_cpu(guid->d),\n\t\t\tguid->e[0], guid->e[1], guid->e[2], guid->e[3],\n\t\t\tguid->e[4], guid->e[5]);\n\tif (rc >= 0)\n\t\t*sp = ret;\n\treturn rc;\n}\n\nint NONNULL(1, 2) PUBLIC\nefi_symbol_to_guid(const char *symbol, efi_guid_t *guid)\n{\n\tvoid *dlh = dlopen(NULL, RTLD_LAZY);\n\tif (!dlh)\n\t\treturn -1;\n\n\tvoid *sym = dlsym(dlh, symbol);\n\tdlclose(dlh);\n\tif (!sym)\n\t\treturn -1;\n\n\tmemcpy(guid, sym, sizeof(*guid));\n\treturn 0;\n}\n\nint NONNULL(1, 2) PUBLIC\nefi_name_to_guid(const char *name, efi_guid_t *guid)\n{\n\tintptr_t end = (intptr_t)&efi_well_known_names_end;\n\tintptr_t start = (intptr_t)&efi_well_known_names;\n\tsize_t nmemb = (end - start) / sizeof (efi_well_known_names);\n\tsize_t namelen;\n\n\tnamelen = strnlen(name, 39);\n\tstruct guidname key;\n\tmemset(&key, '\\0', sizeof (key));\n\tmemcpy(key.name, name, namelen);\n\n\tif (namelen > 2 && name[0] == '{' && name[namelen - 1] == '}') {\n\t\tnamelen -= 2;\n\t\tmemcpy(key.name, name + 1, namelen);\n\t\tkey.name[namelen] = 0;\n\t}\n\n\tkey.name[sizeof(key.name) - 1] = '\\0';\n\n\tstruct guidname *result;\n\tresult = bsearch(&key, &efi_well_known_names, nmemb,\n\t\t\tsizeof (efi_well_known_names), cmpnamep);\n\tif (result != NULL) {\n\t\tmemcpy(guid, &result->guid, sizeof (*guid));\n\t\treturn 0;\n\t}\n\n\tint rc = efi_str_to_guid(key.name, guid);\n\tif (rc >= 0)\n\t\treturn 0;\n\n\tchar tmpname[sizeof(key.name) + 9];\n\tstrcpy(tmpname, \"efi_guid_\");\n\tmemmove(tmpname+9, key.name, sizeof (key.name) - 9);\n\n\trc = efi_symbol_to_guid(tmpname, guid);\n\tif (rc >= 0)\n\t\treturn rc;\n\n\terrno = ENOENT;\n\treturn -1;\n}\n\nint\nefi_id_guid_to_guid(const char *name, efi_guid_t *guid)\n        NONNULL(1, 2) PUBLIC ALIAS(efi_name_to_guid);\n"
    },
    "skipped": [],
    "total_files": 112
}