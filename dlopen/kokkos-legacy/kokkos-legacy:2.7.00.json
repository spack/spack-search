{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.7.00-zvbh54zuiltpbcso2lxpp3s2zan5kwge/spack-src/core/src/impl/Kokkos_Profiling_Interface.cpp": "/*\n //@HEADER\n // ************************************************************************\n //\n //                        Kokkos v. 2.0\n //              Copyright (2014) Sandia Corporation\n //\n // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n // the U.S. Government retains certain rights in this software.\n //\n // Redistribution and use in source and binary forms, with or without\n // modification, are permitted provided that the following conditions are\n // met:\n //\n // 1. Redistributions of source code must retain the above copyright\n // notice, this list of conditions and the following disclaimer.\n //\n // 2. Redistributions in binary form must reproduce the above copyright\n // notice, this list of conditions and the following disclaimer in the\n // documentation and/or other materials provided with the distribution.\n //\n // 3. Neither the name of the Corporation nor the names of the\n // contributors may be used to endorse or promote products derived from\n // this software without specific prior written permission.\n //\n // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n //\n // Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n //\n // ************************************************************************\n //@HEADER\n */\n\n#include <Kokkos_Macros.hpp>\n\n#if defined(KOKKOS_ENABLE_PROFILING)\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n#include <cstring>\n\nnamespace Kokkos {\nnamespace Profiling {\n\nstatic initFunction initProfileLibrary = nullptr;\nstatic finalizeFunction finalizeProfileLibrary = nullptr;\n\nstatic beginFunction beginForCallee = nullptr;\nstatic beginFunction beginScanCallee = nullptr;\nstatic beginFunction beginReduceCallee = nullptr;\nstatic endFunction endForCallee = nullptr;\nstatic endFunction endScanCallee = nullptr;\nstatic endFunction endReduceCallee = nullptr;\n\nstatic pushFunction pushRegionCallee = nullptr;\nstatic popFunction popRegionCallee = nullptr;\n\nstatic allocateDataFunction allocateDataCallee = nullptr;\nstatic deallocateDataFunction deallocateDataCallee = nullptr;\n\nstatic beginDeepCopyFunction beginDeepCopyCallee = nullptr;\nstatic endDeepCopyFunction endDeepCopyCallee = nullptr;\n\nstatic createProfileSectionFunction createSectionCallee = nullptr;\nstatic startProfileSectionFunction startSectionCallee = nullptr;\nstatic stopProfileSectionFunction stopSectionCallee = nullptr;\nstatic destroyProfileSectionFunction destroySectionCallee = nullptr;\n\nstatic profileEventFunction profileEventCallee = nullptr;\n\nSpaceHandle::SpaceHandle(const char* space_name) {\n  strncpy(name,space_name,64);\n}\n\nbool profileLibraryLoaded() {\n  return (nullptr != initProfileLibrary);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(nullptr != beginForCallee) {\n    Kokkos::fence();\n    (*beginForCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if(nullptr != endForCallee) {\n    Kokkos::fence();\n    (*endForCallee)(kernelID);\n  }\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(nullptr != beginScanCallee) {\n    Kokkos::fence();\n    (*beginScanCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if(nullptr != endScanCallee) {\n    Kokkos::fence();\n    (*endScanCallee)(kernelID);\n  }\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(nullptr != beginReduceCallee) {\n    Kokkos::fence();\n    (*beginReduceCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if(nullptr != endReduceCallee) {\n    Kokkos::fence();\n    (*endReduceCallee)(kernelID);\n  }\n}\n\n\nvoid pushRegion(const std::string& kName) {\n  if( nullptr != pushRegionCallee ) {\n    Kokkos::fence();\n    (*pushRegionCallee)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if( nullptr != popRegionCallee ) {\n    Kokkos::fence();\n    (*popRegionCallee)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n  if(nullptr != allocateDataCallee) {\n    (*allocateDataCallee)(space,label.c_str(),ptr,size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n  if(nullptr != deallocateDataCallee) {\n    (*deallocateDataCallee)(space,label.c_str(),ptr,size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label, const void* dst_ptr,\n    const SpaceHandle src_space, const std::string src_label, const void* src_ptr,\n    const uint64_t size) {\n  if(nullptr != beginDeepCopyCallee) {\n    (*beginDeepCopyCallee)(dst_space, dst_label.c_str(), dst_ptr,\n                      src_space, src_label.c_str(), src_ptr,\n                      size);\n  }\n}\n\nvoid endDeepCopy() {\n  if(nullptr != endDeepCopyCallee) {\n    (*endDeepCopyCallee)();\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n\n\tif(nullptr != createSectionCallee) {\n\t\t(*createSectionCallee)(sectionName.c_str(), secID);\n\t}\n}\n\nvoid startSection(const uint32_t secID) {\n\tif(nullptr != startSectionCallee) {\n\t\t(*startSectionCallee)(secID);\n\t}\n}\n\nvoid stopSection(const uint32_t secID) {\n\tif(nullptr != stopSectionCallee) {\n\t\t(*stopSectionCallee)(secID);\n\t}\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n\tif(nullptr != destroySectionCallee) {\n\t\t(*destroySectionCallee)(secID);\n\t}\n}\n\nvoid markEvent(const std::string& eventName) {\n\tif(nullptr != profileEventCallee) {\n\t\t(*profileEventCallee)(eventName.c_str());\n\t}\n}\n\nvoid initialize() {\n\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if(is_initialized) return;\n  is_initialized = 1;\n\n  void* firstProfileLibrary;\n\n  char* envProfileLibrary  = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if( nullptr == envProfileLibrary ) {\n    return ;\n  }\n\n  char* envProfileCopy = (char*) malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if( (nullptr != profileLibraryName) && (strcmp(profileLibraryName, \"\") != 0) ) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if(nullptr == firstProfileLibrary) {\n      std::cerr << \"Error: Unable to load KokkosP library: \" <<\n        profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName << \", RTLD_NOW | RTLD_GLOBAL) failed with \"\n        << dlerror() << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName << std::endl;\n#endif\n\n      // dlsym returns a pointer to an object, while we want to assign to pointer to function\n      // A direct cast will give warnings hence, we have to workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      beginForCallee = *((beginFunction*) &p1);\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      beginScanCallee = *((beginFunction*) &p2);\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      beginReduceCallee = *((beginFunction*) &p3);\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      endScanCallee = *((endFunction*) &p4);\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      endForCallee = *((endFunction*) &p5);\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      endReduceCallee = *((endFunction*) &p6);\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      initProfileLibrary = *((initFunction*) &p7);\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      finalizeProfileLibrary = *((finalizeFunction*) &p8);\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      pushRegionCallee = *((pushFunction*) &p9);\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      popRegionCallee = *((popFunction*) &p10);\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      allocateDataCallee = *((allocateDataFunction*) &p11);\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      deallocateDataCallee = *((deallocateDataFunction*) &p12);\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      beginDeepCopyCallee = *((beginDeepCopyFunction*) &p13);\n      auto p14 = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      endDeepCopyCallee = *((endDeepCopyFunction*) &p14);\n      \n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      createSectionCallee = *((createProfileSectionFunction*) &p15);\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      startSectionCallee = *((startProfileSectionFunction*) &p16);\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      stopSectionCallee = *((stopProfileSectionFunction*) &p17);      \n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      destroySectionCallee = *((destroyProfileSectionFunction*) &p18);\n      \n      auto p19 = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      profileEventCallee = *((profileEventFunction*) &p19);\n    }\n  }\n\n  if(nullptr != initProfileLibrary) {\n    (*initProfileLibrary)(0,\n        (uint64_t) KOKKOSP_INTERFACE_VERSION,\n        (uint32_t) 0,\n        nullptr);\n  }\n\n  free(envProfileCopy);\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if(is_finalized) return;\n  is_finalized = 1;\n\n  if(nullptr != finalizeProfileLibrary) {\n    (*finalizeProfileLibrary)();\n\n    // Set all profile hooks to nullptr to prevent\n    // any additional calls. Once we are told to\n    // finalize, we mean it\n    initProfileLibrary = nullptr;\n    finalizeProfileLibrary = nullptr;\n\n    beginForCallee = nullptr;\n    beginScanCallee = nullptr;\n    beginReduceCallee = nullptr;\n    endScanCallee = nullptr;\n    endForCallee = nullptr;\n    endReduceCallee = nullptr;\n\n    pushRegionCallee = nullptr;\n    popRegionCallee = nullptr;\n\n    allocateDataCallee = nullptr;\n    deallocateDataCallee = nullptr;\n\n    beginDeepCopyCallee = nullptr;\n    endDeepCopyCallee = nullptr;\n    \n    createSectionCallee = nullptr;\n\tstartSectionCallee = nullptr;\n\tstopSectionCallee = nullptr;\n\tdestroySectionCallee = nullptr;\n\n\tprofileEventCallee = nullptr;\n  }\n}\n}\n}\n\n#else\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n#include <cstring>\n\nnamespace Kokkos {\nnamespace Profiling {\n\nbool profileLibraryLoaded() { return false; }\n\n\nvoid beginParallelFor(const std::string& , const uint32_t , uint64_t* ) {}\nvoid endParallelFor(const uint64_t ) {}\nvoid beginParallelScan(const std::string& , const uint32_t , uint64_t* ) {}\nvoid endParallelScan(const uint64_t ) {}\nvoid beginParallelReduce(const std::string& , const uint32_t , uint64_t* ) {}\nvoid endParallelReduce(const uint64_t ) {}\n\nvoid pushRegion(const std::string& ) {}\nvoid popRegion() {}\nvoid createProfileSection(const std::string& , uint32_t* ) {}\nvoid startSection(const uint32_t ) {}\nvoid stopSection(const uint32_t ) {}\nvoid destroyProfileSection(const uint32_t ) {}\n\nvoid markEvent(const std::string& ) {}\n\nvoid allocateData(const SpaceHandle , const std::string , const void* , const uint64_t ) {}\nvoid deallocateData(const SpaceHandle , const std::string , const void* , const uint64_t ) {}\n\nvoid beginDeepCopy(const SpaceHandle , const std::string , const void* , \n    const SpaceHandle , const std::string , const void* ,\n    const uint64_t ) {}\nvoid endDeepCopy() {}\n\nvoid initialize() {}\nvoid finalize() {}\n\n}} // end namespace Kokkos::Profiling\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.7.00-zvbh54zuiltpbcso2lxpp3s2zan5kwge/spack-src/doc/SAND2017-10464-Kokkos-Task-DAG.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.7.00-zvbh54zuiltpbcso2lxpp3s2zan5kwge/spack-src/doc/Kokkos_PG.pdf"
    ],
    "total_files": 1956
}