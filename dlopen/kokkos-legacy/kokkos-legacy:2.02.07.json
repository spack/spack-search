{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.02.07-wbzpeyi75miqqv6gq5mzwrbvyf67tjmd/spack-src/core/src/impl/Kokkos_Profiling_Interface.cpp": "/*\n //@HEADER\n // ************************************************************************\n //\n //                        Kokkos v. 2.0\n //              Copyright (2014) Sandia Corporation\n //\n // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n // the U.S. Government retains certain rights in this software.\n //\n // Redistribution and use in source and binary forms, with or without\n // modification, are permitted provided that the following conditions are\n // met:\n //\n // 1. Redistributions of source code must retain the above copyright\n // notice, this list of conditions and the following disclaimer.\n //\n // 2. Redistributions in binary form must reproduce the above copyright\n // notice, this list of conditions and the following disclaimer in the\n // documentation and/or other materials provided with the distribution.\n //\n // 3. Neither the name of the Corporation nor the names of the\n // contributors may be used to endorse or promote products derived from\n // this software without specific prior written permission.\n //\n // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n //\n // Questions? Contact  H. Carter Edwards (hcedwar@sandia.gov)\n //\n // ************************************************************************\n //@HEADER\n */\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n\n#if (KOKKOS_ENABLE_PROFILING)\n#include <string.h>\n\nnamespace Kokkos {\n  namespace Profiling {\n\n    SpaceHandle::SpaceHandle(const char* space_name) {\n      strncpy(name,space_name,64);\n    }\n\n    bool profileLibraryLoaded() {\n       \treturn (NULL != initProfileLibrary);\n    }\n\n    void beginParallelFor(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n        if(NULL != beginForCallee) {\n            Kokkos::fence();\n            (*beginForCallee)(kernelPrefix.c_str(), devID, kernelID);\n        }\n    }\n\n    void endParallelFor(const uint64_t kernelID) {\n        if(NULL != endForCallee) {\n            Kokkos::fence();\n            (*endForCallee)(kernelID);\n        }\n    }\n\n    void beginParallelScan(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n        if(NULL != beginScanCallee) {\n            Kokkos::fence();\n            (*beginScanCallee)(kernelPrefix.c_str(), devID, kernelID);\n        }\n    }\n\n    void endParallelScan(const uint64_t kernelID) {\n        if(NULL != endScanCallee) {\n            Kokkos::fence();\n            (*endScanCallee)(kernelID);\n        }\n    }\n    \n    void beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n        if(NULL != beginReduceCallee) {\n            Kokkos::fence();\n            (*beginReduceCallee)(kernelPrefix.c_str(), devID, kernelID);\n        }\n    }\n    \n    void endParallelReduce(const uint64_t kernelID) {\n        if(NULL != endReduceCallee) {\n            Kokkos::fence();\n            (*endReduceCallee)(kernelID);\n        }\n    }\n    \n\n    void pushRegion(const std::string& kName) {\n      if( NULL != pushRegionCallee ) {\n        Kokkos::fence();\n        (*pushRegionCallee)(kName.c_str());\n      }\n    }\n\n    void popRegion() {\n      if( NULL != popRegionCallee ) {\n        Kokkos::fence();\n        (*popRegionCallee)();\n      }\n    }\n\n    void allocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n        if(NULL != allocateDataCallee) {\n            (*allocateDataCallee)(space,label.c_str(),ptr,size);\n        }\n    }\n\n    void deallocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n        if(NULL != allocateDataCallee) {\n            (*deallocateDataCallee)(space,label.c_str(),ptr,size);\n        }\n    }\n\n    void initialize() {\n\n        // Make sure initialize calls happens only once\n        static int is_initialized = 0;\n        if(is_initialized) return;\n        is_initialized = 1;\n\n        void* firstProfileLibrary;\n\n        char* envProfileLibrary  = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n\t// If we do not find a profiling library in the environment then exit\n\t// early.\n\tif( NULL == envProfileLibrary ) {\n\t\treturn ;\n\t}\n\n\t\tchar* envProfileCopy = (char*) malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n\t\tsprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n\t\tchar* profileLibraryName = strtok(envProfileCopy, \";\");\n\n        if( (NULL != profileLibraryName) && (strcmp(profileLibraryName, \"\") != 0) ) {\n            firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n            if(NULL == firstProfileLibrary) {\n                std::cerr << \"Error: Unable to load KokkosP library: \" <<\n                profileLibraryName << std::endl;\n            } else {\n                std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName << std::endl;\n\n                // dlsym returns a pointer to an object, while we want to assign to pointer to function\n                // A direct cast will give warnings hence, we have to workaround the issue by casting pointer to pointers.\n                auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n                beginForCallee = *((beginFunction*) &p1);\n                auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n                beginScanCallee = *((beginFunction*) &p2);\n                auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n                beginReduceCallee = *((beginFunction*) &p3);\n\n                auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n                endScanCallee = *((endFunction*) &p4);\n                auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n                endForCallee = *((endFunction*) &p5);\n                auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n                endReduceCallee = *((endFunction*) &p6);\n\n                auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n                initProfileLibrary = *((initFunction*) &p7);\n                auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n                finalizeProfileLibrary = *((finalizeFunction*) &p8);\n\n                auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n                pushRegionCallee = *((pushFunction*) &p9);\n                auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n                popRegionCallee = *((popFunction*) &p10);\n\n                auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n                allocateDataCallee = *((allocateDataFunction*) &p11);\n                auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n                deallocateDataCallee = *((deallocateDataFunction*) &p12);\n\n            }\n        }\n\n        if(NULL != initProfileLibrary) {\n            (*initProfileLibrary)(0,\n\t\t\t(uint64_t) KOKKOSP_INTERFACE_VERSION,\n\t\t\t(uint32_t) 0,\n\t\t\tNULL);\n        }\n\n\t\tfree(envProfileCopy);\n    }\n\n    void finalize() {\n      // Make sure finalize calls happens only once\n      static int is_finalized = 0;\n      if(is_finalized) return;\n      is_finalized = 1;\n\n      if(NULL != finalizeProfileLibrary) {\n        (*finalizeProfileLibrary)();\n\n        // Set all profile hooks to NULL to prevent\n        // any additional calls. Once we are told to\n        // finalize, we mean it\n        initProfileLibrary = NULL;\n        finalizeProfileLibrary = NULL;\n\n        beginForCallee = NULL;\n        beginScanCallee = NULL;\n        beginReduceCallee = NULL;\n        endScanCallee = NULL;\n        endForCallee = NULL;\n        endReduceCallee = NULL;\n\n        pushRegionCallee = NULL;\n        popRegionCallee = NULL;\n\n        allocateDataCallee = NULL;\n        deallocateDataCallee = NULL;\n\n      }\n    }\n  }\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.02.07-wbzpeyi75miqqv6gq5mzwrbvyf67tjmd/spack-src/doc/Kokkos_PG.pdf"
    ],
    "total_files": 491
}