{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/src/PartonDistributions.cc": "// PartonDistributions.cc is a part of the PYTHIA event generator.\n// Copyright (C) 2015 Torbjorn Sjostrand.\n// PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.\n// Please respect the MCnet Guidelines, see GUIDELINES for details.\n\n// Function definitions (not found in the header) for the PDF, LHAPDF,\n// GRV94L, CTEQ5L,  MSTWpdf, CTEQ6pdf, GRVpiL, PomFix, PomH1FitAB,\n// PomH1Jets, Lepton and NNPDF classes.\n\n#include \"Pythia8/PartonDistributions.h\"\n\nnamespace Pythia8 {\n\n//==========================================================================\n\n// Base class for parton distribution functions.\n\n//--------------------------------------------------------------------------\n\n// Resolve valence content for assumed meson. Possibly modified later.\n\nvoid PDF::setValenceContent() {\n\n  // Subdivide meson by flavour content.\n  if (idBeamAbs < 100 || idBeamAbs > 1000) return;\n  int idTmp1 = idBeamAbs/100;\n  int idTmp2 = (idBeamAbs/10)%10;\n\n  // Find which is quark and which antiquark.\n  if (idTmp1%2 == 0) {\n    idVal1 =  idTmp1;\n    idVal2 = -idTmp2;\n  } else {\n    idVal1 =  idTmp2;\n    idVal2 = -idTmp1;\n  }\n  if (idBeam < 0) {\n    idVal1 = -idVal1;\n    idVal2 = -idVal2;\n  }\n\n  // Special case for Pomeron, to start off.\n  if (idBeamAbs == 990) {\n    idVal1 =  1;\n    idVal2 = -1;\n  }\n}\n\n//--------------------------------------------------------------------------\n\n// Standard parton densities.\n\ndouble PDF::xf(int id, double x, double Q2) {\n\n  // Need to update if flavour, x or Q2 changed.\n  // Use idSav = 9 to indicate that ALL flavours are up-to-date.\n  // Assume that flavour and antiflavour always updated simultaneously.\n  if ( (abs(idSav) != abs(id) && idSav != 9) || x != xSav || Q2 != Q2Sav)\n    {idSav = id; xfUpdate(id, x, Q2); xSav = x; Q2Sav = Q2;}\n\n  // Baryon and nondiagonal meson beams: only p, pbar, pi+, pi- for now.\n  if (idBeamAbs == 2212 || idBeamAbs == 211) {\n    int idNow = (idBeam > 0) ? id : -id;\n    int idAbs = abs(id);\n    if (idNow ==  0 || idAbs == 21) return max(0., xg);\n    if (idNow ==  1) return max(0., xd);\n    if (idNow == -1) return max(0., xdbar);\n    if (idNow ==  2) return max(0., xu);\n    if (idNow == -2) return max(0., xubar);\n    if (idNow ==  3) return max(0., xs);\n    if (idNow == -3) return max(0., xsbar);\n    if (idAbs ==  4) return max(0., xc);\n    if (idAbs ==  5) return max(0., xb);\n    if (idAbs == 22) return max(0., xgamma);\n    return 0.;\n\n  // Baryon beams: n and nbar by isospin conjugation of p and pbar.\n  } else if (idBeamAbs == 2112) {\n    int idNow = (idBeam > 0) ? id : -id;\n    int idAbs = abs(id);\n    if (idNow ==  0 || idAbs == 21) return max(0., xg);\n    if (idNow ==  1) return max(0., xu);\n    if (idNow == -1) return max(0., xubar);\n    if (idNow ==  2) return max(0., xd);\n    if (idNow == -2) return max(0., xdbar);\n    if (idNow ==  3) return max(0., xs);\n    if (idNow == -3) return max(0., xsbar);\n    if (idAbs ==  4) return max(0., xc);\n    if (idAbs ==  5) return max(0., xb);\n    if (idAbs == 22) return max(0., xgamma);\n    return 0.;\n\n  // Diagonal meson beams: only pi0, Pomeron for now.\n  } else if (idBeam == 111 || idBeam == 990) {\n    int idAbs = abs(id);\n    if (id ==  0 || idAbs == 21) return max(0., xg);\n    if (id == idVal1 || id == idVal2) return max(0., xu);\n    if (idAbs <=  2) return max(0., xubar);\n    if (idAbs ==  3) return max(0., xs);\n    if (idAbs ==  4) return max(0., xc);\n    if (idAbs ==  5) return max(0., xb);\n    if (idAbs == 22) return max(0., xgamma);\n    return 0.;\n\n\n  // Lepton beam.\n  } else {\n    if (id == idBeam ) return max(0., xlepton);\n    if (abs(id) == 22) return max(0., xgamma);\n    return 0.;\n  }\n\n}\n\n//--------------------------------------------------------------------------\n\n// Only valence part of parton densities.\n\ndouble PDF::xfVal(int id, double x, double Q2) {\n\n  // Need to update if flavour, x or Q2 changed.\n  // Use idSav = 9 to indicate that ALL flavours are up-to-date.\n  // Assume that flavour and antiflavour always updated simultaneously.\n  if ( (abs(idSav) != abs(id) && idSav != 9) || x != xSav || Q2 != Q2Sav)\n    {idSav = id; xfUpdate(id, x, Q2); xSav = x; Q2Sav = Q2;}\n\n  // Baryon and nondiagonal meson beams: only p, pbar, n, nbar, pi+, pi-.\n  if (idBeamAbs == 2212) {\n    int idNow = (idBeam > 0) ? id : -id;\n    if (idNow == 1) return max(0., xdVal);\n    if (idNow == 2) return max(0., xuVal);\n    return 0.;\n  } else if (idBeamAbs == 2112) {\n    int idNow = (idBeam > 0) ? id : -id;\n    if (idNow == 1) return max(0., xuVal);\n    if (idNow == 2) return max(0., xdVal);\n    return 0.;\n  } else if (idBeamAbs == 211) {\n    int idNow = (idBeam > 0) ? id : -id;\n    if (idNow == 2 || idNow == -1) return max(0., xuVal);\n    return 0.;\n\n  // Diagonal meson beams: only pi0, Pomeron for now.\n  } else if (idBeam == 111 || idBeam == 990) {\n    if (id == idVal1 || id == idVal2) return max(0., xuVal);\n    return 0.;\n\n  // Lepton beam.\n  } else {\n    if (id == idBeam) return max(0., xlepton);\n    return 0.;\n  }\n\n}\n\n//--------------------------------------------------------------------------\n\n// Only sea part of parton densities.\n\ndouble PDF::xfSea(int id, double x, double Q2) {\n\n  // Need to update if flavour, x or Q2 changed.\n  // Use idSav = 9 to indicate that ALL flavours are up-to-date.\n  // Assume that flavour and antiflavour always updated simultaneously.\n  if ( (abs(idSav) != abs(id) && idSav != 9) || x != xSav || Q2 != Q2Sav)\n    {idSav = id; xfUpdate(id, x, Q2); xSav = x; Q2Sav = Q2;}\n\n  // Hadron beams.\n  if (idBeamAbs > 100) {\n    int idNow = (idBeam > 0) ? id : -id;\n    int idAbs = abs(id);\n    if (idNow == 0 || idAbs == 21) return max(0., xg);\n    if (idBeamAbs == 2212) {\n      if (idNow ==  1) return max(0., xdSea);\n      if (idNow == -1) return max(0., xdbar);\n      if (idNow ==  2) return max(0., xuSea);\n      if (idNow == -2) return max(0., xubar);\n    } else if (idBeamAbs == 2112) {\n      if (idNow ==  1) return max(0., xuSea);\n      if (idNow == -1) return max(0., xubar);\n      if (idNow ==  2) return max(0., xdSea);\n      if (idNow == -2) return max(0., xdbar);\n    } else {\n      if (idAbs <=  2) return max(0., xuSea);\n    }\n    if (idNow ==  3) return max(0., xs);\n    if (idNow == -3) return max(0., xsbar);\n    if (idAbs ==  4) return max(0., xc);\n    if (idAbs ==  5) return max(0., xb);\n    if (idAbs == 22) return max(0., xgamma);\n    return 0.;\n\n  // Lepton beam.\n  } else {\n    if (abs(id) == 22) return max(0., xgamma);\n    return 0.;\n  }\n\n}\n\n//==========================================================================\n\n// Gives the GRV 94 L (leading order) parton distribution function set\n// in parametrized form. Authors: M. Glueck, E. Reya and A. Vogt.\n// Ref: M. Glueck, E. Reya and A. Vogt, Z.Phys. C67 (1995) 433.\n\nvoid GRV94L::xfUpdate(int , double x, double Q2) {\n\n  // Common expressions. Constrain Q2 for which parametrization is valid.\n  double mu2  = 0.23;\n  double lam2 = 0.2322 * 0.2322;\n  double s    = (Q2 > mu2) ? log( log(Q2/lam2) / log(mu2/lam2) ) : 0.;\n  double ds   = sqrt(s);\n  double s2   = s * s;\n  double s3   = s2 * s;\n\n  // uv :\n  double nu  =  2.284 + 0.802 * s + 0.055 * s2;\n  double aku =  0.590 - 0.024 * s;\n  double bku =  0.131 + 0.063 * s;\n  double au  = -0.449 - 0.138 * s - 0.076 * s2;\n  double bu  =  0.213 + 2.669 * s - 0.728 * s2;\n  double cu  =  8.854 - 9.135 * s + 1.979 * s2;\n  double du  =  2.997 + 0.753 * s - 0.076 * s2;\n  double uv  = grvv (x, nu, aku, bku, au, bu, cu, du);\n\n  // dv :\n  double nd  =  0.371 + 0.083 * s + 0.039 * s2;\n  double akd =  0.376;\n  double bkd =  0.486 + 0.062 * s;\n  double ad  = -0.509 + 3.310 * s - 1.248 * s2;\n  double bd  =  12.41 - 10.52 * s + 2.267 * s2;\n  double cd  =  6.373 - 6.208 * s + 1.418 * s2;\n  double dd  =  3.691 + 0.799 * s - 0.071 * s2;\n  double dv  = grvv (x, nd, akd, bkd, ad, bd, cd, dd);\n\n  // udb :\n  double alx =  1.451;\n  double bex =  0.271;\n  double akx =  0.410 - 0.232 * s;\n  double bkx =  0.534 - 0.457 * s;\n  double agx =  0.890 - 0.140 * s;\n  double bgx = -0.981;\n  double cx  =  0.320 + 0.683 * s;\n  double dx  =  4.752 + 1.164 * s + 0.286 * s2;\n  double ex  =  4.119 + 1.713 * s;\n  double esx =  0.682 + 2.978 * s;\n  double udb = grvw (x, s, alx, bex, akx, bkx, agx, bgx, cx,\n    dx, ex, esx);\n\n  // del :\n  double ne  =  0.082 + 0.014 * s + 0.008 * s2;\n  double ake =  0.409 - 0.005 * s;\n  double bke =  0.799 + 0.071 * s;\n  double ae  = -38.07 + 36.13 * s - 0.656 * s2;\n  double be  =  90.31 - 74.15 * s + 7.645 * s2;\n  double ce  =  0.;\n  double de  =  7.486 + 1.217 * s - 0.159 * s2;\n  double del = grvv (x, ne, ake, bke, ae, be, ce, de);\n\n  // sb :\n  double sts =  0.;\n  double als =  0.914;\n  double bes =  0.577;\n  double aks =  1.798 - 0.596 * s;\n  double as  = -5.548 + 3.669 * ds - 0.616 * s;\n  double bs  =  18.92 - 16.73 * ds + 5.168 * s;\n  double dst =  6.379 - 0.350 * s  + 0.142 * s2;\n  double est =  3.981 + 1.638 * s;\n  double ess =  6.402;\n  double sb  = grvs (x, s, sts, als, bes, aks, as, bs, dst, est, ess);\n\n  // cb :\n  double stc =  0.888;\n  double alc =  1.01;\n  double bec =  0.37;\n  double akc =  0.;\n  double ac  =  0.;\n  double bc  =  4.24  - 0.804 * s;\n  double dct =  3.46  - 1.076 * s;\n  double ect =  4.61  + 1.49  * s;\n  double esc =  2.555 + 1.961 * s;\n  double chm = grvs (x, s, stc, alc, bec, akc, ac, bc, dct, ect, esc);\n\n  // bb :\n  double stb =  1.351;\n  double alb =  1.00;\n  double beb =  0.51;\n  double akb =  0.;\n  double ab  =  0.;\n  double bb  =  1.848;\n  double dbt =  2.929 + 1.396 * s;\n  double ebt =  4.71  + 1.514 * s;\n  double esb =  4.02  + 1.239 * s;\n  double bot = grvs (x, s, stb, alb, beb, akb, ab, bb, dbt, ebt, esb);\n\n  // gl :\n  double alg =  0.524;\n  double beg =  1.088;\n  double akg =  1.742 - 0.930 * s;\n  double bkg =                     - 0.399 * s2;\n  double ag  =  7.486 - 2.185 * s;\n  double bg  =  16.69 - 22.74 * s  + 5.779 * s2;\n  double cg  = -25.59 + 29.71 * s  - 7.296 * s2;\n  double dg  =  2.792 + 2.215 * s  + 0.422 * s2 - 0.104 * s3;\n  double eg  =  0.807 + 2.005 * s;\n  double esg =  3.841 + 0.316 * s;\n  double gl  = grvw (x, s, alg, beg, akg, bkg, ag, bg, cg,\n    dg, eg, esg);\n\n  // Update values\n  xg    = gl;\n  xu    = uv + 0.5*(udb - del);\n  xd    = dv + 0.5*(udb + del);\n  xubar = 0.5*(udb - del);\n  xdbar = 0.5*(udb + del);\n  xs    = sb;\n  xsbar = sb;\n  xc    = chm;\n  xb    = bot;\n\n  // Subdivision of valence and sea.\n  xuVal = uv;\n  xuSea = xubar;\n  xdVal = dv;\n  xdSea = xdbar;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//--------------------------------------------------------------------------\n\ndouble GRV94L::grvv (double x, double n, double ak, double bk, double a,\n   double b, double c, double d) {\n\n  double dx = sqrt(x);\n  return n * pow(x, ak) * (1. + a * pow(x, bk) + x * (b + c * dx)) *\n    pow(1. - x, d);\n\n}\n\n//--------------------------------------------------------------------------\n\ndouble GRV94L::grvw (double x, double s, double al, double be, double ak,\n  double bk, double a, double b, double c, double d, double e, double es) {\n\n  double lx = log(1./x);\n  return (pow(x, ak) * (a + x * (b + x * c)) * pow(lx, bk) + pow(s, al)\n    * exp(-e + sqrt(es * pow(s, be) * lx))) * pow(1. - x, d);\n\n}\n\n//--------------------------------------------------------------------------\n\ndouble GRV94L::grvs (double x, double s, double sth, double al, double be,\n  double ak, double ag, double b, double d, double e, double es) {\n\n  if(s <= sth) {\n    return 0.;\n  } else {\n    double dx = sqrt(x);\n    double lx = log(1./x);\n    return pow(s - sth, al) / pow(lx, ak) * (1. + ag * dx + b * x) *\n      pow(1. - x, d) * exp(-e + sqrt(es * pow(s, be) * lx));\n  }\n\n}\n\n//==========================================================================\n\n// Gives the CTEQ 5 L (leading order) parton distribution function set\n// in parametrized form. Parametrization by J. Pumplin.\n// Ref: CTEQ Collaboration, H.L. Lai et al., Eur.Phys.J. C12 (2000) 375.\n\n// The range of (x, Q) covered by this parametrization of the QCD\n// evolved parton distributions is 1E-6 < x < 1, 1.1 GeV < Q < 10 TeV.\n// In the current implementation, densities are frozen at borders.\n\nvoid CTEQ5L::xfUpdate(int , double x, double Q2) {\n\n  // Constrain x and Q2 to range for which parametrization is valid.\n  double Q = sqrt( max( 1., min( 1e8, Q2) ) );\n  x = max( 1e-6, min( 1.-1e-10, x) );\n\n  // Derived kinematical quantities.\n  double y = - log(x);\n  double u = log( x / 0.00001);\n  double x1 = 1. - x;\n  double x1L = log(1. - x);\n  double sumUbarDbar = 0.;\n\n  // Parameters of parametrizations.\n  const double Qmin[8] = { 0., 0., 0., 0., 0., 0., 1.3, 4.5};\n  const double alpha[8] = { 0.2987216, 0.3407552, 0.4491863, 0.2457668,\n    0.5293999, 0.3713141, 0.03712017, 0.004952010 };\n  const double ut1[8] = { 4.971265, 2.612618, -0.4656819, 3.862583,\n    0.1895615, 3.753257, 4.400772, 5.562568 };\n  const double ut2[8] = { -1.105128, -1.258304e5, -274.2390, -1.265969,\n    -3.069097, -1.113085, -1.356116, -1.801317 };\n  const double am[8][9][3] = {\n    // d.\n    { {  0.5292616E+01, -0.2751910E+01, -0.2488990E+01 },\n      {  0.9714424E+00,  0.1011827E-01, -0.1023660E-01 },\n      { -0.1651006E+02,  0.7959721E+01,  0.8810563E+01 },\n      { -0.1643394E+02,  0.5892854E+01,  0.9348874E+01 },\n      {  0.3067422E+02,  0.4235796E+01, -0.5112136E+00 },\n      {  0.2352526E+02, -0.5305168E+01, -0.1169174E+02 },\n      { -0.1095451E+02,  0.3006577E+01,  0.5638136E+01 },\n      { -0.1172251E+02, -0.2183624E+01,  0.4955794E+01 },\n      {  0.1662533E-01,  0.7622870E-02, -0.4895887E-03 } },\n    // u.\n    { {  0.9905300E+00, -0.4502235E+00,  0.1624441E+00 },\n      {  0.8867534E+00,  0.1630829E-01, -0.4049085E-01 },\n      {  0.8547974E+00,  0.3336301E+00,  0.1371388E+00 },\n      {  0.2941113E+00, -0.1527905E+01,  0.2331879E+00 },\n      {  0.3384235E+02,  0.3715315E+01,  0.8276930E+00 },\n      {  0.6230115E+01,  0.3134639E+01, -0.1729099E+01 },\n      { -0.1186928E+01, -0.3282460E+00,  0.1052020E+00 },\n      { -0.8545702E+01, -0.6247947E+01,  0.3692561E+01 },\n      {  0.1724598E-01,  0.7120465E-02,  0.4003646E-04 } },\n    // g.\n    { {  0.1193572E+03, -0.3886845E+01, -0.1133965E+01 },\n      { -0.9421449E+02,  0.3995885E+01,  0.1607363E+01 },\n      {  0.4206383E+01,  0.2485954E+00,  0.2497468E+00 },\n      {  0.1210557E+03, -0.3015765E+01, -0.1423651E+01 },\n      { -0.1013897E+03, -0.7113478E+00,  0.2621865E+00 },\n      { -0.1312404E+01, -0.9297691E+00, -0.1562531E+00 },\n      {  0.1627137E+01,  0.4954111E+00, -0.6387009E+00 },\n      {  0.1537698E+00, -0.2487878E+00,  0.8305947E+00 },\n      {  0.2496448E-01,  0.2457823E-02,  0.8234276E-03 } },\n    // ubar + dbar.\n    { {  0.2647441E+02,  0.1059277E+02, -0.9176654E+00 },\n      {  0.1990636E+01,  0.8558918E-01,  0.4248667E-01 },\n      { -0.1476095E+02, -0.3276255E+02,  0.1558110E+01 },\n      { -0.2966889E+01, -0.3649037E+02,  0.1195914E+01 },\n      { -0.1000519E+03, -0.2464635E+01,  0.1964849E+00 },\n      {  0.3718331E+02,  0.4700389E+02, -0.2772142E+01 },\n      { -0.1872722E+02, -0.2291189E+02,  0.1089052E+01 },\n      { -0.1628146E+02, -0.1823993E+02,  0.2537369E+01 },\n      { -0.1156300E+01, -0.1280495E+00,  0.5153245E-01 } },\n    // dbar/ubar.\n    { { -0.6556775E+00,  0.2490190E+00,  0.3966485E-01 },\n      {  0.1305102E+01, -0.1188925E+00, -0.4600870E-02 },\n      { -0.2371436E+01,  0.3566814E+00, -0.2834683E+00 },\n      { -0.6152826E+01,  0.8339877E+00, -0.7233230E+00 },\n      { -0.8346558E+01,  0.2892168E+01,  0.2137099E+00 },\n      {  0.1279530E+02,  0.1021114E+00,  0.5787439E+00 },\n      {  0.5858816E+00, -0.1940375E+01, -0.4029269E+00 },\n      { -0.2795725E+02, -0.5263392E+00,  0.1290229E+01 },\n      {  0.0000000E+00,  0.0000000E+00,  0.0000000E+00 } },\n    // sbar.\n    { {  0.1580931E+01, -0.2273826E+01, -0.1822245E+01 },\n      {  0.2702644E+01,  0.6763243E+00,  0.7231586E-02 },\n      { -0.1857924E+02,  0.3907500E+01,  0.5850109E+01 },\n      { -0.3044793E+02,  0.2639332E+01,  0.5566644E+01 },\n      { -0.4258011E+01, -0.5429244E+01,  0.4418946E+00 },\n      {  0.3465259E+02, -0.5532604E+01, -0.4904153E+01 },\n      { -0.1658858E+02,  0.2923275E+01,  0.2266286E+01 },\n      { -0.1149263E+02,  0.2877475E+01, -0.7999105E+00 },\n      {  0.0000000E+00,  0.0000000E+00,  0.0000000E+00 } },\n    // cbar.\n    { { -0.8293661E+00, -0.3982375E+01, -0.6494283E-01 },\n      {  0.2754618E+01,  0.8338636E+00, -0.6885160E-01 },\n      { -0.1657987E+02,  0.1439143E+02, -0.6887240E+00 },\n      { -0.2800703E+02,  0.1535966E+02, -0.7377693E+00 },\n      { -0.6460216E+01, -0.4783019E+01,  0.4913297E+00 },\n      {  0.3141830E+02, -0.3178031E+02,  0.7136013E+01 },\n      { -0.1802509E+02,  0.1862163E+02, -0.4632843E+01 },\n      { -0.1240412E+02,  0.2565386E+02, -0.1066570E+02 },\n      {  0.0000000E+00,  0.0000000E+00,  0.0000000E+00 } },\n    // bbar.\n    { { -0.6031237E+01,  0.1992727E+01, -0.1076331E+01 },\n      {  0.2933912E+01,  0.5839674E+00,  0.7509435E-01 },\n      { -0.8284919E+01,  0.1488593E+01, -0.8251678E+00 },\n      { -0.1925986E+02,  0.2805753E+01, -0.3015446E+01 },\n      { -0.9480483E+01, -0.9767837E+00, -0.1165544E+01 },\n      {  0.2193195E+02, -0.1788518E+02,  0.9460908E+01 },\n      { -0.1327377E+02,  0.1201754E+02, -0.6277844E+01 },\n      {  0.0000000E+00,  0.0000000E+00,  0.0000000E+00 },\n      {  0.0000000E+00,  0.0000000E+00,  0.0000000E+00 } } };\n\n  // Loop over 8 different parametrizations. Check if inside allowed region.\n  for (int i = 0; i < 8; ++i) {\n    double answer = 0.;\n    if (Q > max(Qmin[i], alpha[i])) {\n\n      // Evaluate answer.\n      double tmp = log(Q / alpha[i]);\n      double sb = log(tmp);\n      double sb1 = sb - 1.2;\n      double sb2 = sb1*sb1;\n      double af[9];\n      for (int j = 0; j < 9; ++j)\n        af[j] = am[i][j][0] + sb1 * am[i][j][1] + sb2 * am[i][j][2];\n      double part1 = af[1] * pow( y, 1. + 0.01 * af[4]) * (1. + af[8] * u);\n      double part2 = af[0] * x1 + af[3] * x;\n      double part3 = x * x1 * (af[5] + af[6] * x1 + af[7] * x * x1);\n      double part4 = (ut2[i] < -100.) ? ut1[i] * x1L + af[2] * x1L\n                   : ut1[i] * x1L + af[2] * log(x1 + exp(ut2[i]));\n      answer       = x * exp( part1 + part2 + part3 + part4);\n      answer      *= 1. - Qmin[i] / Q;\n    }\n\n    // Store results.\n    if (i == 0) xd = x * answer;\n    else if (i == 1) xu = x * answer;\n    else if (i == 2) xg = x * answer;\n    else if (i == 3) sumUbarDbar = x * answer;\n    else if (i == 4) { xubar = sumUbarDbar / (1. + answer);\n      xdbar = sumUbarDbar * answer / (1. + answer); }\n    else if (i == 5) {xs = x * answer; xsbar = xs;}\n    else if (i == 6) xc = x * answer;\n    else if (i == 7) xb = x * answer;\n  }\n\n  // Subdivision of valence and sea.\n  xuVal = xu - xubar;\n  xuSea = xubar;\n  xdVal = xd - xdbar;\n  xdSea = xdbar;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// The MSTWpdf class.\n// MSTW 2008 PDF's, specifically the LO one.\n// Original C++ version by Jeppe Andersen.\n// Modified by Graeme Watt <watt(at)hep.ucl.ac.uk>.\n\n//--------------------------------------------------------------------------\n\n// Constants: could be changed here if desired, but normally should not.\n// These are of technical nature, as described for each.\n\n// Number of parton flavours, x and Q2 grid points,\n// bins below c and b thresholds.\nconst int    MSTWpdf::np     = 12;\nconst int    MSTWpdf::nx     = 64;\nconst int    MSTWpdf::nq     = 48;\nconst int    MSTWpdf::nqc0   = 4;\nconst int    MSTWpdf::nqb0   = 14;\n\n// Range of (x, Q2) grid.\nconst double MSTWpdf::xmin   = 1e-6;\nconst double MSTWpdf::xmax   = 1.0;\nconst double MSTWpdf::qsqmin = 1.0;\nconst double MSTWpdf::qsqmax = 1e9;\n\n// Array of x values.\nconst double MSTWpdf::xxInit[65] = {0., 1e-6, 2e-6, 4e-6, 6e-6, 8e-6,\n  1e-5, 2e-5, 4e-5, 6e-5, 8e-5, 1e-4, 2e-4, 4e-4, 6e-4, 8e-4,\n  1e-3, 2e-3, 4e-3, 6e-3, 8e-3, 1e-2, 1.4e-2, 2e-2, 3e-2, 4e-2, 6e-2,\n  8e-2, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30,\n  0.325, 0.35, 0.375, 0.40, 0.425, 0.45, 0.475, 0.50, 0.525, 0.55,\n  0.575, 0.60, 0.625, 0.65, 0.675, 0.70, 0.725, 0.75, 0.775, 0.80,\n  0.825, 0.85, 0.875, 0.90, 0.925, 0.95, 0.975, 1.0 };\n\n// Array of Q values.\nconst double MSTWpdf::qqInit[49] = {0., 1.0, 1.25, 1.5, 0., 0., 2.5, 3.2,\n  4.0, 5.0, 6.4, 8.0, 10., 12., 0., 0., 26.0, 40.0, 64.0, 1e2, 1.6e2,\n  2.4e2, 4e2, 6.4e2, 1e3, 1.8e3, 3.2e3, 5.6e3, 1e4, 1.8e4, 3.2e4, 5.6e4,\n  1e5, 1.8e5, 3.2e5, 5.6e5, 1e6, 1.8e6, 3.2e6, 5.6e6, 1e7, 1.8e7, 3.2e7,\n  5.6e7, 1e8, 1.8e8, 3.2e8, 5.6e8, 1e9 };\n\n//--------------------------------------------------------------------------\n\n// Initialize PDF: read in data grid from file and set up interpolation.\n\nvoid MSTWpdf::init(int iFitIn, string xmlPath, Info* infoPtr) {\n\n  // Choice of fit among possibilities. Counters and temporary variables.\n  iFit = iFitIn;\n  int i,n,m,k,l,j;\n  double dtemp;\n\n  // Variables used for initialising c_ij array:\n  double f[np+1][nx+1][nq+1];\n  double f1[np+1][nx+1][nq+1]; // derivative w.r.t. x\n  double f2[np+1][nx+1][nq+1]; // derivative w.r.t. q\n  double f12[np+1][nx+1][nq+1];// cross derivative\n  double f21[np+1][nx+1][nq+1];// cross derivative\n  int wt[16][16]={{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n                  {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},\n                  {-3,0,0,3,0,0,0,0,-2,0,0,-1,0,0,0,0},\n                  {2,0,0,-2,0,0,0,0,1,0,0,1,0,0,0,0},\n                  {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},\n                  {0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},\n                  {0,0,0,0,-3,0,0,3,0,0,0,0,-2,0,0,-1},\n                  {0,0,0,0,2,0,0,-2,0,0,0,0,1,0,0,1},\n                  {-3,3,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0},\n                  {0,0,0,0,0,0,0,0,-3,3,0,0,-2,-1,0,0},\n                  {9,-9,9,-9,6,3,-3,-6,6,-6,-3,3,4,2,1,2},\n                  {-6,6,-6,6,-4,-2,2,4,-3,3,3,-3,-2,-1,-1,-2},\n                  {2,-2,0,0,1,1,0,0,0,0,0,0,0,0,0,0},\n                  {0,0,0,0,0,0,0,0,2,-2,0,0,1,1,0,0},\n                  {-6,6,-6,6,-3,-3,3,3,-4,4,2,-2,-2,-2,-1,-1},\n                  {4,-4,4,-4,2,2,-2,-2,2,-2,-2,2,1,1,1,1}};\n  double xxd,d1d2,cl[16],x[16],d1,d2,y[5],y1[5],y2[5],y12[5];\n  double mc2,mb2,eps=1e-6; // q^2 grid points at mc2+eps, mb2+eps\n\n    // Select which data file to read for current fit.\n  if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += \"/\";\n  string fileName = \"  \";\n  if (iFit == 1) fileName = \"mrstlostar.00.dat\";\n  if (iFit == 2) fileName = \"mrstlostarstar.00.dat\";\n  if (iFit == 3) fileName = \"mstw2008lo.00.dat\";\n  if (iFit == 4) fileName = \"mstw2008nlo.00.dat\";\n\n  // Open data file.\n  ifstream data_file( (xmlPath + fileName).c_str() );\n  if (!data_file.good()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n      \"did not find parametrization file \", fileName);\n    else cout << \" Error from MSTWpdf::init: \"\n      << \"did not find parametrization file \" << fileName << endl;\n    isSet = false;\n    return;\n  }\n\n  // Read distance, tolerance, heavy quark masses\n  // and alphaS values from file.\n  char comma;\n  int nExtraFlavours;\n  data_file.ignore(256,'\\n');\n  data_file.ignore(256,'\\n');\n  data_file.ignore(256,'='); data_file >> distance >> tolerance;\n  data_file.ignore(256,'='); data_file >> mCharm;\n  data_file.ignore(256,'='); data_file >> mBottom;\n  data_file.ignore(256,'='); data_file >> alphaSQ0;\n  data_file.ignore(256,'='); data_file >> alphaSMZ;\n  data_file.ignore(256,'='); data_file >> alphaSorder >> comma >> alphaSnfmax;\n  data_file.ignore(256,'='); data_file >> nExtraFlavours;\n  data_file.ignore(256,'\\n');\n  data_file.ignore(256,'\\n');\n  data_file.ignore(256,'\\n');\n\n  // Use c and b quark masses for outlay of qq array.\n  for (int iqq = 0; iqq < 49; ++iqq) qq[iqq] = qqInit[iqq];\n  mc2=mCharm*mCharm;\n  mb2=mBottom*mBottom;\n  qq[4]=mc2;\n  qq[5]=mc2+eps;\n  qq[14]=mb2;\n  qq[15]=mb2+eps;\n\n  // Check that the heavy quark masses are sensible.\n  if (mc2 < qq[3] || mc2 > qq[6]) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n      \"invalid mCharm\");\n    else cout << \" Error from MSTWpdf::init: invalid mCharm\" << endl;\n    isSet = false;\n    return;\n  }\n  if (mb2 < qq[13] || mb2 > qq[16]) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n      \"invalid mBottom\");\n    else cout << \" Error from MSTWpdf::init: invalid mBottom\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // The nExtraFlavours variable is provided to aid compatibility\n  // with future grids where, for example, a photon distribution\n  // might be provided (cf. the MRST2004QED PDFs).\n  if (nExtraFlavours < 0 || nExtraFlavours > 1) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n      \"invalid nExtraFlavours\");\n    else cout << \" Error from MSTWpdf::init: invalid nExtraFlavours\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // Now read in the grids from the grid file.\n  for (n=1;n<=nx-1;n++)\n    for (m=1;m<=nq;m++) {\n      for (i=1;i<=9;i++)\n        data_file >> f[i][n][m];\n      if (alphaSorder==2) { // only at NNLO\n        data_file >> f[10][n][m]; // = chm-cbar\n        data_file >> f[11][n][m]; // = bot-bbar\n      }\n      else {\n        f[10][n][m] = 0.; // = chm-cbar\n        f[11][n][m] = 0.; // = bot-bbar\n      }\n      if (nExtraFlavours>0)\n        data_file >> f[12][n][m];   // = photon\n      else\n        f[12][n][m] = 0.; // photon\n      if (data_file.eof()) {\n        if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n          \"failed to read in data file\");\n        else cout << \" Error from MSTWpdf::init: failed to read in data file\"\n          << endl;\n        isSet = false;\n        return;\n      }\n    }\n\n  // Check that ALL the file contents have been read in.\n  data_file >> dtemp;\n  if (!data_file.eof()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from MSTWpdf::init: \"\n      \"failed to read in data file\");\n    else cout << \" Error from MSTWpdf::init: failed to read in data file\"\n      << endl;\n    isSet = false;\n    return;\n  }\n\n  // Close the datafile.\n  data_file.close();\n\n  // PDFs are identically zero at x = 1.\n  for (i=1;i<=np;i++)\n    for (m=1;m<=nq;m++)\n      f[i][nx][m]=0.0;\n\n  // Set up the new array in log10(x) and log10(qsq).\n  for (i=1;i<=nx;i++)\n    xx[i]=log10(xxInit[i]);\n  for (m=1;m<=nq;m++)\n    qq[m]=log10(qq[m]);\n\n  // Now calculate the derivatives used for bicubic interpolation.\n  for (i=1;i<=np;i++) {\n\n    // Start by calculating the first x derivatives\n    // along the first x value:\n    for (m=1;m<=nq;m++) {\n      f1[i][1][m]=polderivative1(xx[1],xx[2],xx[3],f[i][1][m],f[i][2][m],\n        f[i][3][m]);\n      // Then along the rest (up to the last):\n      for (k=2;k<nx;k++)\n        f1[i][k][m]=polderivative2(xx[k-1],xx[k],xx[k+1],f[i][k-1][m],\n          f[i][k][m],f[i][k+1][m]);\n      // Then for the last column:\n      f1[i][nx][m]=polderivative3(xx[nx-2],xx[nx-1],xx[nx],f[i][nx-2][m],\n        f[i][nx-1][m],f[i][nx][m]);\n    }\n\n    // Then calculate the qq derivatives.  At NNLO there are\n    // discontinuities in the PDFs at mc2 and mb2, so calculate\n    // the derivatives at q^2 = mc2, mc2+eps, mb2, mb2+eps in\n    // the same way as at the endpoints qsqmin and qsqmax.\n    for (m=1;m<=nq;m++) {\n      if (m==1 || m==nqc0+1 || m==nqb0+1) {\n        for (k=1;k<=nx;k++)\n          f2[i][k][m]=polderivative1(qq[m],qq[m+1],qq[m+2],\n                                     f[i][k][m],f[i][k][m+1],f[i][k][m+2]);\n      }\n      else if (m==nq || m==nqc0 || m==nqb0) {\n        for (k=1;k<=nx;k++)\n          f2[i][k][m]=polderivative3(qq[m-2],qq[m-1],qq[m],\n                                     f[i][k][m-2],f[i][k][m-1],f[i][k][m]);\n      }\n      else {\n        // The rest:\n        for (k=1;k<=nx;k++)\n          f2[i][k][m]=polderivative2(qq[m-1],qq[m],qq[m+1],\n                                    f[i][k][m-1],f[i][k][m],f[i][k][m+1]);\n      }\n    }\n\n    // Now, calculate the cross derivatives.\n    // Calculate these as the average between (d/dx)(d/dy) and (d/dy)(d/dx).\n\n    // First calculate (d/dx)(d/dy).\n    // Start by calculating the first x derivatives\n    // along the first x value:\n    for (m=1;m<=nq;m++)\n      f12[i][1][m]=polderivative1(xx[1],xx[2],xx[3],f2[i][1][m],\n        f2[i][2][m],f2[i][3][m]);\n    // Then along the rest (up to the last):\n    for (k=2;k<nx;k++) {\n      for (m=1;m<=nq;m++)\n        f12[i][k][m]=polderivative2(xx[k-1],xx[k],xx[k+1],f2[i][k-1][m],\n          f2[i][k][m],f2[i][k+1][m]);\n    }\n    // Then for the last column:\n    for (m=1;m<=nq;m++)\n      f12[i][nx][m]=polderivative3(xx[nx-2],xx[nx-1],xx[nx],\n        f2[i][nx-2][m],f2[i][nx-1][m],f2[i][nx][m]);\n\n    // Now calculate (d/dy)(d/dx).\n    for (m=1;m<=nq;m++) {\n      if (m==1 || m==nqc0+1 || m==nqb0+1) {\n        for (k=1;k<=nx;k++)\n          f21[i][k][m]=polderivative1(qq[m],qq[m+1],qq[m+2],\n                                      f1[i][k][m],f1[i][k][m+1],f1[i][k][m+2]);\n      }\n      else if (m==nq || m==nqc0 || m==nqb0) {\n        for (k=1;k<=nx;k++)\n          f21[i][k][m]=polderivative3(qq[m-2],qq[m-1],qq[m],\n                                      f1[i][k][m-2],f1[i][k][m-1],f1[i][k][m]);\n      }\n      else {\n        // The rest:\n        for (k=1;k<=nx;k++)\n          f21[i][k][m]=polderivative2(qq[m-1],qq[m],qq[m+1],\n                                     f1[i][k][m-1],f1[i][k][m],f1[i][k][m+1]);\n      }\n    }\n\n    // Now take the average of (d/dx)(d/dy) and (d/dy)(d/dx).\n    for (k=1;k<=nx;k++) {\n      for (m=1;m<=nq;m++) {\n        f12[i][k][m] = 0.5*(f12[i][k][m]+f21[i][k][m]);\n      }\n    }\n\n    // Now calculate the coefficients c_ij.\n    for (n=1;n<=nx-1;n++) {\n      for (m=1;m<=nq-1;m++) {\n        d1=xx[n+1]-xx[n];\n        d2=qq[m+1]-qq[m];\n        d1d2=d1*d2;\n\n        y[1]=f[i][n][m];\n        y[2]=f[i][n+1][m];\n        y[3]=f[i][n+1][m+1];\n        y[4]=f[i][n][m+1];\n\n        y1[1]=f1[i][n][m];\n        y1[2]=f1[i][n+1][m];\n        y1[3]=f1[i][n+1][m+1];\n        y1[4]=f1[i][n][m+1];\n\n        y2[1]=f2[i][n][m];\n        y2[2]=f2[i][n+1][m];\n        y2[3]=f2[i][n+1][m+1];\n        y2[4]=f2[i][n][m+1];\n\n        y12[1]=f12[i][n][m];\n        y12[2]=f12[i][n+1][m];\n        y12[3]=f12[i][n+1][m+1];\n        y12[4]=f12[i][n][m+1];\n\n        for (k=1;k<=4;k++) {\n          x[k-1]=y[k];\n          x[k+3]=y1[k]*d1;\n          x[k+7]=y2[k]*d2;\n          x[k+11]=y12[k]*d1d2;\n        }\n\n        for (l=0;l<=15;l++) {\n          xxd=0.0;\n          for (k=0;k<=15;k++) xxd+= wt[l][k]*x[k];\n          cl[l]=xxd;\n        }\n\n        l=0;\n        for (k=1;k<=4;k++)\n          for (j=1;j<=4;j++) c[i][n][m][k][j]=cl[l++];\n      } //m\n    } //n\n  } // i\n\n}\n\n//--------------------------------------------------------------------------\n\n// Update PDF values.\n\nvoid MSTWpdf::xfUpdate(int , double x, double Q2) {\n\n  // Update using MSTW routine.\n  double q    = sqrtpos(Q2);\n  // Quarks:\n  double dn   = parton(1,x,q);\n  double up   = parton(2,x,q);\n  double str  = parton(3,x,q);\n  double chm  = parton(4,x,q);\n  double bot  = parton(5,x,q);\n  // Valence quarks:\n  double dnv  = parton(7,x,q);\n  double upv  = parton(8,x,q);\n  double sv   = parton(9,x,q);\n  double cv   = parton(10,x,q);\n  double bv   = parton(11,x,q);\n  // Antiquarks = quarks - valence quarks:\n  double dsea = dn - dnv;\n  double usea = up - upv;\n  double sbar = str - sv;\n  double cbar = chm - cv;\n  double bbar = bot - bv;\n  // Gluon:\n  double glu  = parton(0,x,q);\n  // Photon (= zero unless considering QED contributions):\n  double phot = parton(13,x,q);\n\n  // Transfer to Pythia notation.\n  xg     = glu;\n  xu     = up;\n  xd     = dn;\n  xubar  = usea;\n  xdbar  = dsea;\n  xs     = str;\n  xsbar  = sbar;\n  xc     = 0.5 * (chm + cbar);\n  xb     = 0.5 * (bot + bbar);\n  xgamma = phot;\n\n  // Subdivision of valence and sea.\n  xuVal  = upv;\n  xuSea  = xubar;\n  xdVal  = dnv;\n  xdSea  = xdbar;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav  = 9;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Returns the PDF value for parton of flavour 'f' at x,q.\n\ndouble MSTWpdf::parton(int f,double x,double q) {\n\n  double qsq;\n  int ip;\n  int interpolate(1);\n  double parton_pdf=0,parton_pdf1=0,anom;\n  double xxx,qqq;\n\n  qsq=q*q;\n\n  // If mc2 < qsq < mc2+eps, then qsq = mc2+eps.\n  if (qsq>pow(10.,qq[nqc0]) && qsq<pow(10.,qq[nqc0+1])) {\n    qsq = pow(10.,qq[nqc0+1]);\n  }\n\n  // If mb2 < qsq < mb2+eps, then qsq = mb2+eps.\n  if (qsq>pow(10.,qq[nqb0]) && qsq<pow(10.,qq[nqb0+1])) {\n    qsq = pow(10.,qq[nqb0+1]);\n  }\n\n  if (x<xmin) {\n    interpolate=0;\n    if (x<=0.) return 0.;\n  }\n  else if (x>xmax) return 0.;\n\n  if (qsq<qsqmin) {\n    interpolate=-1;\n    if (q<=0.) return 0.;\n  }\n  else if (qsq>qsqmax) {\n    interpolate=0;\n  }\n\n  if (f==0) ip=1;\n  else if (f>=1 && f<=5) ip=f+1;\n  else if (f<=-1 && f>=-5) ip=-f+1;\n  else if (f>=7 && f<=11) ip=f;\n  else if (f==13) ip=12;\n  else if (abs(f)==6 || f==12) return 0.;\n  else return 0.;\n\n  // Interpolation in log10(x), log10(qsq):\n  xxx=log10(x);\n  qqq=log10(qsq);\n\n  if (interpolate==1) { // do usual interpolation\n    parton_pdf=parton_interpolate(ip,xxx,qqq);\n    if (f<=-1 && f>=-5) // antiquark = quark - valence\n      parton_pdf -= parton_interpolate(ip+5,xxx,qqq);\n  }\n  else if (interpolate==-1) { // extrapolate to low Q^2\n\n    if (x<xmin) { // extrapolate to low x\n      parton_pdf = parton_extrapolate(ip,xxx,log10(qsqmin));\n      parton_pdf1 = parton_extrapolate(ip,xxx,log10(1.01*qsqmin));\n      if (f<=-1 && f>=-5) { // antiquark = quark - valence\n        parton_pdf -= parton_extrapolate(ip+5,xxx,log10(qsqmin));\n        parton_pdf1 -= parton_extrapolate(ip+5,xxx,log10(1.01*qsqmin));\n      }\n    }\n    else { // do usual interpolation\n      parton_pdf = parton_interpolate(ip,xxx,log10(qsqmin));\n      parton_pdf1 = parton_interpolate(ip,xxx,log10(1.01*qsqmin));\n      if (f<=-1 && f>=-5) { // antiquark = quark - valence\n        parton_pdf -= parton_interpolate(ip+5,xxx,log10(qsqmin));\n        parton_pdf1 -= parton_interpolate(ip+5,xxx,log10(1.01*qsqmin));\n      }\n    }\n    // Calculate the anomalous dimension, dlog(xf)/dlog(qsq),\n    // evaluated at qsqmin.  Then extrapolate the PDFs to low\n    // qsq < qsqmin by interpolating the anomalous dimenion between\n    // the value at qsqmin and a value of 1 for qsq << qsqmin.\n    // If value of PDF at qsqmin is very small, just set\n    // anomalous dimension to 1 to prevent rounding errors.\n    if (fabs(parton_pdf) >= 1.e-5)\n      anom = max(-2.5, (parton_pdf1-parton_pdf)/parton_pdf/0.01);\n    else anom = 1.;\n    parton_pdf = parton_pdf*pow(qsq/qsqmin,anom*qsq/qsqmin+1.-qsq/qsqmin);\n\n  }\n  else { // extrapolate outside PDF grid to low x or high Q^2\n    parton_pdf = parton_extrapolate(ip,xxx,qqq);\n    if (f<=-1 && f>=-5) // antiquark = quark - valence\n      parton_pdf -= parton_extrapolate(ip+5,xxx,qqq);\n  }\n\n  return parton_pdf;\n}\n\n//--------------------------------------------------------------------------\n\n// Interpolate PDF value inside data grid.\n\ndouble MSTWpdf::parton_interpolate(int ip, double xxx, double qqq) {\n\n  double g, t, u;\n  int    n, m, l;\n\n  n=locate(xx,nx,xxx); // 0: below xmin, nx: above xmax\n  m=locate(qq,nq,qqq); // 0: below qsqmin, nq: above qsqmax\n\n  t=(xxx-xx[n])/(xx[n+1]-xx[n]);\n  u=(qqq-qq[m])/(qq[m+1]-qq[m]);\n\n  // Assume PDF proportional to (1-x)^p as x -> 1.\n  if (n==nx-1) {\n    double g0=((c[ip][n][m][1][4]*u+c[ip][n][m][1][3])*u\n    +c[ip][n][m][1][2])*u+c[ip][n][m][1][1]; // value at xx[n]\n    double g1=((c[ip][n-1][m][1][4]*u+c[ip][n-1][m][1][3])*u\n           +c[ip][n-1][m][1][2])*u+c[ip][n-1][m][1][1]; // value at xx[n-1]\n    double p = 1.0;\n    if (g0>0.0&&g1>0.0) p = log(g1/g0)/log((xx[n+1]-xx[n-1])/(xx[n+1]-xx[n]));\n    if (p<=1.0) p=1.0;\n    g=g0*pow((xx[n+1]-xxx)/(xx[n+1]-xx[n]),p);\n  }\n\n  // Usual interpolation.\n  else {\n    g=0.0;\n    for (l=4;l>=1;l--) {\n      g=t*g+((c[ip][n][m][l][4]*u+c[ip][n][m][l][3])*u\n         +c[ip][n][m][l][2])*u+c[ip][n][m][l][1];\n    }\n  }\n\n  return g;\n}\n\n//--------------------------------------------------------------------------\n\n// Extrapolate PDF value outside data grid.\n\n\ndouble MSTWpdf::parton_extrapolate(int ip, double xxx, double qqq) {\n\n  double parton_pdf=0.;\n  int n,m;\n\n  n=locate(xx,nx,xxx); // 0: below xmin, nx: above xmax\n  m=locate(qq,nq,qqq); // 0: below qsqmin, nq: above qsqmax\n\n  if (n==0&&(m>0&&m<nq)) { // if extrapolation in small x only\n\n    double f0,f1;\n    f0=parton_interpolate(ip,xx[1],qqq);\n    f1=parton_interpolate(ip,xx[2],qqq);\n    if ( f0>1e-3 && f1>1e-3 ) { // if values are positive, keep them so\n      f0=log(f0);\n      f1=log(f1);\n      parton_pdf=exp(f0+(f1-f0)/(xx[2]-xx[1])*(xxx-xx[1]));\n    } else // otherwise just extrapolate in the value\n      parton_pdf=f0+(f1-f0)/(xx[2]-xx[1])*(xxx-xx[1]);\n\n  } if (n>0&&m==nq) { // if extrapolation into large q only\n\n    double f0,f1;\n    f0=parton_interpolate(ip,xxx,qq[nq]);\n    f1=parton_interpolate(ip,xxx,qq[nq-1]);\n    if ( f0>1e-3 && f1>1e-3 ) { // if values are positive, keep them so\n      f0=log(f0);\n      f1=log(f1);\n      parton_pdf=exp(f0+(f0-f1)/(qq[nq]-qq[nq-1])*(qqq-qq[nq]));\n    } else // otherwise just extrapolate in the value\n      parton_pdf=f0+(f0-f1)/(qq[nq]-qq[nq-1])*(qqq-qq[nq]);\n\n  } if (n==0&&m==nq) { // if extrapolation into large q AND small x\n\n    double f0,f1;\n    f0=parton_extrapolate(ip,xx[1],qqq);\n    f1=parton_extrapolate(ip,xx[2],qqq);\n    if ( f0>1e-3 && f1>1e-3 ) { // if values are positive, keep them so\n      f0=log(f0);\n      f1=log(f1);\n      parton_pdf=exp(f0+(f1-f0)/(xx[2]-xx[1])*(xxx-xx[1]));\n    } else // otherwise just extrapolate in the value\n      parton_pdf=f0+(f1-f0)/(xx[2]-xx[1])*(xxx-xx[1]);\n\n  }\n\n  return parton_pdf;\n}\n\n//--------------------------------------------------------------------------\n\n// Returns an integer j such that x lies inbetween xloc[j] and xloc[j+1].\n// unit offset of increasing ordered array xloc assumed.\n// n is the length of the array (xloc[n] highest element).\n\nint MSTWpdf::locate(double xloc[],int n,double x) {\n  int ju,jm,jl(0),j;\n  ju=n+1;\n\n  while (ju-jl>1) {\n    jm=(ju+jl)/2; // compute a mid point.\n    if ( x>= xloc[jm])\n      jl=jm;\n    else ju=jm;\n  }\n  if (x==xloc[1]) j=1;\n  else if (x==xloc[n]) j=n-1;\n  else j=jl;\n\n  return j;\n}\n\n//--------------------------------------------------------------------------\n\n// Returns the estimate of the derivative at x1 obtained by a polynomial\n// interpolation using the three points (x_i,y_i).\n\ndouble MSTWpdf::polderivative1(double x1, double x2, double x3, double y1,\n  double y2, double y3) {\n\n  return (x3*x3*(y1-y2)+2.0*x1*(x3*(-y1+y2)+x2*(y1-y3))+x2*x2*(-y1+y3)\n          +x1*x1*(-y2+y3))/((x1-x2)*(x1-x3)*(x2-x3));\n\n}\n\n//--------------------------------------------------------------------------\n\n// Returns the estimate of the derivative at x2 obtained by a polynomial\n// interpolation using the three points (x_i,y_i).\n\ndouble MSTWpdf::polderivative2(double x1, double x2, double x3, double y1,\n  double y2, double y3) {\n\n  return (x3*x3*(y1-y2)-2.0*x2*(x3*(y1-y2)+x1*(y2-y3))+x2*x2*(y1-y3)\n          +x1*x1*(y2-y3))/((x1-x2)*(x1-x3)*(x2-x3));\n\n}\n\n//--------------------------------------------------------------------------\n\n// Returns the estimate of the derivative at x3 obtained by a polynomial\n// interpolation using the three points (x_i,y_i).\n\ndouble MSTWpdf::polderivative3(double x1, double x2, double x3, double y1,\n  double y2, double y3) {\n\n  return (x3*x3*(-y1+y2)+2.0*x2*x3*(y1-y3)+x1*x1*(y2-y3)+x2*x2*(-y1+y3)\n          +2.0*x1*x3*(-y2+y3))/((x1-x2)*(x1-x3)*(x2-x3));\n\n}\n\n//==========================================================================\n\n// The CTEQ6pdf class.\n// Code for handling CTEQ6L, CTEQ6L1, CTEQ66.00, CT09MC1, CT09MC2, (CT09MCS?).\n\n// Constants: could be changed here if desired, but normally should not.\n// These are of technical nature, as described for each.\n\n// Stay away from xMin, xMax, Qmin, Qmax limits.\nconst double CTEQ6pdf::EPSILON = 1e-6;\n\n// Assumed approximate power of small-x behaviour for interpolation.\nconst double CTEQ6pdf::XPOWER = 0.3;\n\n//--------------------------------------------------------------------------\n\n// Initialize PDF: read in data grid from file.\n\nvoid CTEQ6pdf::init(int iFitIn, string xmlPath, Info* infoPtr) {\n\n  // Choice of fit among possibilities.\n  iFit = iFitIn;\n\n  // Select which data file to read for current fit.\n  if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += \"/\";\n  string fileName = \"  \";\n  if (iFit == 1) fileName = \"cteq6l.tbl\";\n  if (iFit == 2) fileName = \"cteq6l1.tbl\";\n  if (iFit == 3) fileName = \"ctq66.00.pds\";\n  if (iFit == 4) fileName = \"ct09mc1.pds\";\n  if (iFit == 5) fileName = \"ct09mc2.pds\";\n  if (iFit == 6) fileName = \"ct09mcs.pds\";\n  bool isPdsGrid = (iFit > 2);\n\n  // Open data file.\n  ifstream pdfgrid( (xmlPath + fileName).c_str() );\n  if (!pdfgrid.good()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from CTEQ6pdf::init: \"\n      \"did not find parametrization file \", fileName);\n    else cout << \" Error from CTEQ6pdf::init: \"\n      << \"did not find parametrization file \" << fileName << endl;\n    isSet = false;\n    return;\n  }\n\n  // Read in common information.\n  int    iDum;\n  double orderTmp, nQTmp, qTmp, rDum;\n  string line;\n  getline( pdfgrid, line);\n  getline( pdfgrid, line);\n  getline( pdfgrid, line);\n  istringstream is1(line);\n  is1 >> orderTmp >> nQTmp >> lambda >> mQ[1] >> mQ[2] >> mQ[3]\n     >> mQ[4] >> mQ[5] >> mQ[6];\n  order  = int(orderTmp + 0.5);\n  nQuark = int(nQTmp + 0.5);\n  getline( pdfgrid, line);\n\n  // Read in information for the .pds grid format.\n  if (isPdsGrid) {\n    getline( pdfgrid, line);\n    istringstream is2(line);\n    is2 >> iDum >> iDum >> iDum >> nfMx >> mxVal >> iDum;\n    if (mxVal > 4) mxVal = 3;\n    getline( pdfgrid, line);\n    getline( pdfgrid, line);\n    istringstream is3(line);\n    is3 >> nX >> nT >> iDum >> nG >> iDum;\n    for (int i = 0; i < nG + 2; ++i) getline( pdfgrid, line);\n    getline( pdfgrid, line);\n    istringstream is4(line);\n    is4 >> qIni >> qMax;\n    for (int iT = 0; iT <= nT; ++iT) {\n      getline( pdfgrid, line);\n      istringstream is5(line);\n      is5 >> qTmp;\n      tv[iT] = log( log( qTmp/lambda));\n    }\n    getline( pdfgrid, line);\n    getline( pdfgrid, line);\n    istringstream is6(line);\n    is6 >> xMin >> rDum;\n    int nPackX = 6;\n    xv[0] = 0.;\n    for (int iXrng = 0; iXrng < int( (nX + nPackX - 1) / nPackX); ++iXrng) {\n      getline( pdfgrid, line);\n      istringstream is7(line);\n      for (int iX = nPackX * iXrng + 1; iX <= nPackX * (iXrng + 1); ++iX)\n      if (iX <= nX) is7 >> xv[iX];\n    }\n  }\n\n  // Read in information for the .tbl grid format.\n  else {\n    mxVal = 2;\n    getline( pdfgrid, line);\n    istringstream is2(line);\n    is2 >> nX >> nT >> nfMx;\n    getline( pdfgrid, line);\n    getline( pdfgrid, line);\n    istringstream is3(line);\n    is3 >> qIni >> qMax;\n    int    nPackT = 6;\n    for (int iTrng = 0; iTrng < int( (nT + nPackT) / nPackT); ++iTrng) {\n      getline( pdfgrid, line);\n      istringstream is4(line);\n      for (int iT = nPackT * iTrng; iT < nPackT * (iTrng + 1); ++iT)\n      if (iT <= nT) {\n        is4 >> qTmp;\n        tv[iT] = log( log( qTmp / lambda) );\n      }\n    }\n    getline( pdfgrid, line);\n    getline( pdfgrid, line);\n    istringstream is5(line);\n    is5 >> xMin;\n    int nPackX = 6;\n    for (int iXrng = 0; iXrng < int( (nX + nPackX) / nPackX); ++iXrng) {\n      getline( pdfgrid, line);\n      istringstream is6(line);\n      for (int iX = nPackX * iXrng; iX < nPackX * (iXrng + 1); ++iX)\n      if (iX <= nX) is6 >> xv[iX];\n    }\n  }\n\n  // Read in the grid proper.\n  getline( pdfgrid, line);\n  int nBlk  = (nX + 1) * (nT + 1);\n  int nPts  = nBlk * (nfMx + 1 + mxVal);\n  int nPack = (isPdsGrid) ? 6 : 5;\n  for (int iRng = 0; iRng < int( (nPts + nPack - 1) / nPack); ++iRng) {\n    getline( pdfgrid, line);\n    istringstream is8(line);\n    for (int i = nPack * iRng + 1; i <= nPack * (iRng + 1); ++i)\n      if (i <= nPts) is8 >> upd[i];\n  }\n\n  // Initialize x grid mapped to x^0.3.\n  xvpow[0] = 0.;\n  for (int iX = 1; iX <= nX; ++iX)  xvpow[iX] = pow(xv[iX], XPOWER);\n\n  // Set x and Q borders with some margin.\n  xMinEps = xMin * (1. + EPSILON);\n  xMaxEps = 1. - EPSILON;\n  qMinEps = qIni * (1. + EPSILON);\n  qMaxEps = qMax * (1. - EPSILON);\n\n  // Initialize (x, Q) values of previous call.\n  xLast = 0.;\n  qLast = 0.;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Update PDF values.\n\nvoid CTEQ6pdf::xfUpdate(int , double x, double Q2) {\n\n  // Update using CTEQ6 routine, within allowed (x, q) range.\n  double xEps = max( xMinEps, x);\n  double qEps = max( qMinEps, min( qMaxEps, sqrtpos(Q2) ) );\n\n  // Gluon:\n  double glu  = xEps * parton6( 0, xEps, qEps);\n  // Sea quarks (note wrong order u, d):\n  double bot  = xEps * parton6( 5, xEps, qEps);\n  double chm  = xEps * parton6( 4, xEps, qEps);\n  double str  = xEps * parton6( 3, xEps, qEps);\n  double usea = xEps * parton6(-1, xEps, qEps);\n  double dsea = xEps * parton6(-2, xEps, qEps);\n  // Valence quarks:\n  double upv  = xEps * parton6( 1, xEps, qEps) - usea;\n  double dnv  = xEps * parton6( 2, xEps, qEps) - dsea;\n\n  // Transfer to Pythia notation.\n  xg     = glu;\n  xu     = upv + usea;\n  xd     = dnv + dsea;\n  xubar  = usea;\n  xdbar  = dsea;\n  xs     = str;\n  xsbar  = str;\n  xc     = chm;\n  xb     = bot;\n  xgamma = 0.;\n\n  // Subdivision of valence and sea.\n  xuVal  = upv;\n  xuSea  = usea;\n  xdVal  = dnv;\n  xdSea  = dsea;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav  = 9;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Returns the PDF value for parton of flavour iParton at x, q.\n\ndouble CTEQ6pdf::parton6(int iParton, double x, double q) {\n\n  // Put zero for large x. Parton table and interpolation variables.\n  if (x > xMaxEps) return 0.;\n  int    iP = (iParton > mxVal) ? -iParton : iParton;\n  double ss = pow( x, XPOWER);\n  double tt = log( log(q / lambda) );\n\n  // Find location in grid.Skip if same as in latest call.\n  if (x != xLast || q != qLast) {\n\n    // Binary search in x grid.\n    iGridX  = 0;\n    iGridLX = -1;\n    int ju  = nX + 1;\n    int jm  = 0;\n    while (ju - iGridLX > 1 && jm >= 0) {\n      jm = (ju + iGridLX) / 2;\n      if (x >= xv[jm]) iGridLX = jm;\n      else ju = jm;\n    }\n\n    // Separate acceptable from unacceptable grid points.\n    if      (iGridLX <= -1)     return 0.;\n    else if (iGridLX == 0)      iGridX = 0;\n    else if (iGridLX <= nX - 2) iGridX = iGridLX - 1;\n    else if (iGridLX == nX - 1) iGridX = iGridLX - 2;\n    else                        return 0.;\n\n    // Expressions for interpolation in x Grid.\n    if (iGridLX > 1 && iGridLX < nX - 1) {\n      double svec1 = xvpow[iGridX];\n      double svec2 = xvpow[iGridX+1];\n      double svec3 = xvpow[iGridX+2];\n      double svec4 = xvpow[iGridX+3];\n      double s12   = svec1 - svec2;\n      double s13   = svec1 - svec3;\n      xConst[8]    = svec2 - svec3;\n      double s24   = svec2 - svec4;\n      double s34   = svec3 - svec4;\n      xConst[6]    = ss - svec2;\n      xConst[7]    = ss - svec3;\n      xConst[0]    = s13 / xConst[8];\n      xConst[1]    = s12 / xConst[8];\n      xConst[2]    = s34 / xConst[8];\n      xConst[3]    = s24 / xConst[8];\n      double s1213 = s12 + s13;\n      double s2434 = s24 + s34;\n      double sdet  = s12 * s34 - s1213 * s2434;\n      double tmp   = xConst[6] * xConst[7] / sdet;\n      xConst[4]    = (s34 * xConst[6] - s2434 * xConst[7]) * tmp / s12;\n      xConst[5]    = (s1213 * xConst[6] - s12 * xConst[7]) * tmp / s34;\n    }\n\n    // Binary search in Q grid.\n    iGridQ  = 0;\n    iGridLQ = -1;\n    ju      = nT + 1;\n    jm      = 0;\n    while (ju - iGridLQ > 1 && jm >= 0) {\n      jm = (ju + iGridLQ) / 2;\n      if (tt >= tv[jm]) iGridLQ = jm;\n      else ju = jm;\n    }\n    if      (iGridLQ == 0)      iGridQ = 0;\n    else if (iGridLQ <= nT - 2) iGridQ = iGridLQ - 1;\n    else                        iGridQ = nT - 3;\n\n    // Expressions for interpolation in Q Grid.\n    if (iGridLQ > 0 && iGridLQ < nT - 1) {\n      double tvec1 = tv[iGridQ];\n      double tvec2 = tv[iGridQ+1];\n      double tvec3 = tv[iGridQ+2];\n      double tvec4 = tv[iGridQ+3];\n      double t12   = tvec1 - tvec2;\n      double t13   = tvec1 - tvec3;\n      tConst[8]    =   tvec2 - tvec3;\n      double t24   = tvec2 - tvec4;\n      double t34   = tvec3 - tvec4;\n      tConst[6]    = tt - tvec2;\n      tConst[7]    = tt - tvec3;\n      double tmp1  = t12 + t13;\n      double tmp2  = t24 + t34;\n      double tdet  = t12 * t34 - tmp1 * tmp2;\n      tConst[0]    = t13 / tConst[8];\n      tConst[1]    = t12 / tConst[8];\n      tConst[2]    = t34 / tConst[8];\n      tConst[3]    = t24 / tConst[8];\n      tConst[4]    = (t34 * tConst[6] - tmp2 * tConst[7]) / t12\n                     * tConst[6] * tConst[7] / tdet;\n      tConst[5]    = (tmp1 * tConst[6] - t12 * tConst[7]) / t34\n                     * tConst[6] * tConst[7] / tdet;\n    }\n\n    // Save x and q values so do not have to redo same again.\n    xLast = x;\n    qLast = q;\n  }\n\n  // Jump to here if x and q are the same as for the last call.\n  int jtmp = ( (iP + nfMx) * (nT + 1) + (iGridQ - 1) ) * (nX + 1) + iGridX + 1;\n\n  // Interpolate in x space for four different q values.\n  for(int it = 1; it <= 4; ++it) {\n    int j1 = jtmp + it * (nX + 1);\n    if (iGridX == 0) {\n      double fij[5];\n      fij[1] = 0.;\n      fij[2] = upd[j1+1] * pow2(xv[1]);\n      fij[3] = upd[j1+2] * pow2(xv[2]);\n      fij[4] = upd[j1+3] * pow2(xv[3]);\n      double fX = polint4F( &xvpow[0], &fij[1], ss);\n      fVec[it] = (x > 0.) ? fX / pow2(x) : 0.;\n    } else if (iGridLX==nX-1) {\n      fVec[it] = polint4F( &xvpow[nX-3], &upd[j1], ss);\n    } else {\n      double sf2 = upd[j1+1];\n      double sf3 = upd[j1+2];\n      double g1  =  sf2 * xConst[0] - sf3 * xConst[1];\n      double g4  = -sf2 * xConst[2] + sf3 * xConst[3];\n      fVec[it]   = (xConst[4] * (upd[j1] - g1) + xConst[5] * (upd[j1+3] - g4)\n                 + sf2 * xConst[7] - sf3 * xConst[6]) / xConst[8];\n    }\n  }\n\n  // Interpolate in q space for x-interpolated values found above.\n  double ff;\n  if( iGridLQ <= 0 ) {\n    ff = polint4F( &tv[0], &fVec[1], tt);\n  } else if (iGridLQ >= nT - 1) {\n    ff=polint4F( &tv[nT-3], &fVec[1], tt);\n  } else {\n    double tf2 = fVec[2];\n    double tf3 = fVec[3];\n    double g1  =  tf2 * tConst[0] - tf3 * tConst[1];\n    double g4  = -tf2 * tConst[2] + tf3 * tConst[3];\n    ff         = (tConst[4] * (fVec[1] - g1) + tConst[5] * (fVec[4] - g4)\n               + tf2 * tConst[7] - tf3 * tConst[6]) / tConst[8];\n  }\n\n  // Done.\n  return ff;\n}\n\n//--------------------------------------------------------------------------\n\n// The POLINT4 routine is based on the POLINT routine from \"Numerical Recipes\",\n// but assuming N=4, and ignoring the error estimation.\n// Suggested by Z. Sullivan.\n\ndouble CTEQ6pdf::polint4F(double xa[],double ya[],double x) {\n\n  double y, h1, h2, h3, h4, w, den, d1, c1, d2, c2, d3, c3, cd1, cc1,\n         cd2, cc2, dd1, dc1;\n\n  h1  = xa[0] - x;\n  h2  = xa[1] - x;\n  h3  = xa[2] - x;\n  h4  = xa[3] - x;\n\n  w   = ya[1] - ya[0];\n  den = w / (h1 - h2);\n  d1  = h2 * den;\n  c1  = h1 * den;\n\n  w   = ya[2] - ya[1];\n  den = w / (h2 - h3);\n  d2  = h3 * den;\n  c2  = h2 * den;\n\n  w   = ya[3] - ya[2];\n  den = w / (h3 - h4);\n  d3  = h4 * den;\n  c3  = h3 * den;\n\n  w   = c2 - d1;\n  den = w / (h1 - h3);\n  cd1 = h3 * den;\n  cc1 = h1 * den;\n\n  w   = c3 - d2;\n  den = w / (h2 - h4);\n  cd2 = h4 * den;\n  cc2 = h2 * den;\n\n  w   = cc2 - cd1;\n  den = w / (h1 - h4);\n  dd1 = h4 * den;\n  dc1 = h1 * den;\n\n  if      (h3 + h4 < 0.) y = ya[3] + d3 + cd2 + dd1;\n  else if (h2 + h3 < 0.) y = ya[2] + d2 + cd1 + dc1;\n  else if (h1 + h2 < 0.) y = ya[1] + c2 + cd1 + dc1;\n  else                   y = ya[0] + c1 + cc1 + dc1;\n\n  return y;\n\n}\n\n//==========================================================================\n\n// SA Unresolved proton: equivalent photon spectrum from\n// V.M. Budnev, I.F. Ginzburg, G.V. Meledin and V.G. Serbo,\n// Phys. Rept. 15 (1974/1975) 181.\n\n// Constants:\nconst double ProtonPoint::ALPHAEM = 0.00729735;\nconst double ProtonPoint::Q2MAX   = 2.0;\nconst double ProtonPoint::Q20     = 0.71;\nconst double ProtonPoint::A       = 7.16;\nconst double ProtonPoint::B       = -3.96;\nconst double ProtonPoint::C       = 0.028;\n\n//--------------------------------------------------------------------------\n\n// Gives a generic Q2-independent equivalent photon spectrum.\n\nvoid ProtonPoint::xfUpdate(int , double x, double /*Q2*/ ) {\n\n  // Photon spectrum\n  double tmpQ2Min = 0.88 * pow2(x);\n  double phiMax = phiFunc(x, Q2MAX / Q20);\n  double phiMin = phiFunc(x, tmpQ2Min / Q20);\n\n  double fgm = 0;\n  if (phiMax < phiMin && m_infoPtr != 0) {\n    m_infoPtr->errorMsg(\"Error from ProtonPoint::xfUpdate: \"\n      \"phiMax - phiMin < 0!\");\n  } else {\n    // Corresponds to: x*f(x)\n    fgm = (ALPHAEM / M_PI) * (1 - x) * (phiMax - phiMin);\n  }\n\n  // Update values\n  xg     = 0.;\n  xu     = 0.;\n  xd     = 0.;\n  xubar  = 0.;\n  xdbar  = 0.;\n  xs     = 0.;\n  xsbar  = 0.;\n  xc     = 0.;\n  xb     = 0.;\n  xgamma = fgm;\n\n  // Subdivision of valence and sea.\n  xuVal = 0.;\n  xuSea = 0;\n  xdVal = 0.;\n  xdSea = 0;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Function related to Q2 integration.\n\ndouble ProtonPoint::phiFunc(double x, double Q) {\n\n  double tmpV = 1. + Q;\n  double tmpSum1 = 0;\n  double tmpSum2 = 0;\n  for (int k=1; k<4; ++k) {\n    tmpSum1 += 1. / (k * pow(tmpV, k));\n    tmpSum2 += pow(B, k) / (k * pow(tmpV, k));\n  }\n\n  double tmpY = pow2(x) / (1 - x);\n  double funVal = (1 + A * tmpY) * (-1.*log(tmpV / Q) + tmpSum1)\n                + (1 - B) * tmpY / (4 * Q * pow(tmpV, 3))\n                + C * (1 + tmpY/4.)* (log((tmpV - B)/tmpV) + tmpSum2);\n\n  return funVal;\n\n}\n\n//==========================================================================\n\n// Gives the GRV 1992 pi+ (leading order) parton distribution function set\n// in parametrized form. Authors: Glueck, Reya and Vogt.\n// Ref: M. Glueck, E. Reya and A. Vogt, Z. Phys. C53 (1992) 651.\n// Allowed variable range: 0.25 GeV^2 < Q^2 < 10^8 GeV^2 and 10^-5 < x < 1.\n\nvoid GRVpiL::xfUpdate(int , double x, double Q2) {\n\n  // Common expressions. Constrain Q2 for which parametrization is valid.\n  double mu2  = 0.25;\n  double lam2 = 0.232 * 0.232;\n  double s    = (Q2 > mu2) ? log( log(Q2/lam2) / log(mu2/lam2) ) : 0.;\n  double s2   = s * s;\n  double x1   = 1. - x;\n  double xL   = -log(x);\n  double xS   = sqrt(x);\n\n  // uv, dbarv.\n  double uv = (0.519 + 0.180 * s - 0.011 * s2) * pow(x, 0.499 - 0.027 * s)\n    * (1. + (0.381 - 0.419 * s) * xS) * pow(x1, 0.367 + 0.563 * s);\n\n  // g.\n  double gl = ( pow(x, 0.482 + 0.341 * sqrt(s))\n    * ( (0.678 + 0.877 * s - 0.175 * s2) + (0.338 - 1.597 * s) * xS\n    + (-0.233 * s + 0.406 * s2) * x) + pow(s, 0.599)\n    * exp(-(0.618 + 2.070 * s) + sqrt(3.676 * pow(s, 1.263) * xL) ) )\n    * pow(x1, 0.390 + 1.053 * s);\n\n  // sea: u, d, s.\n  double ub = pow(s, 0.55) * (1. - 0.748 * xS + (0.313 + 0.935 * s) * x)\n    * pow(x1, 3.359) * exp(-(4.433 + 1.301 * s) + sqrt((9.30 - 0.887 * s)\n    * pow(s, 0.56) * xL) ) / pow(xL, 2.538 - 0.763 * s);\n\n  // c.\n  double chm = (s < 0.888) ? 0. : pow(s - 0.888, 1.02) * (1. + 1.008 * x)\n    * pow(x1, 1.208 + 0.771 * s) * exp(-(4.40 + 1.493 * s)\n    + sqrt( (2.032 + 1.901 * s) * pow(s, 0.39) * xL) );\n\n  // b.\n  double bot = (s < 1.351) ? 0. : pow(s - 1.351, 1.03)\n    * pow(x1, 0.697 + 0.855 * s) * exp(-(4.51 + 1.490 * s)\n    + sqrt( (3.056 + 1.694 * s) * pow(s, 0.39) * xL) );\n\n  // Update values.\n  xg    = gl;\n  xu    = uv + ub;\n  xd    = ub;\n  xubar = ub;\n  xdbar = uv + ub;\n  xs    = ub;\n  xsbar = ub;\n  xc    = chm;\n  xb    = bot;\n\n  // Subdivision of valence and sea.\n  xuVal = uv;\n  xuSea = ub;\n  xdVal = uv;\n  xdSea = ub;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// Pomeron PDF: simple Q2-independent parametrizations N x^a (1 - x)^b.\n\n//--------------------------------------------------------------------------\n\n// Calculate normalization factors once and for all.\n\nvoid PomFix::init() {\n\n  normGluon = GammaReal(PomGluonA + PomGluonB + 2.)\n            / (GammaReal(PomGluonA + 1.) * GammaReal(PomGluonB + 1.));\n  normQuark = GammaReal(PomQuarkA + PomQuarkB + 2.)\n            / (GammaReal(PomQuarkA + 1.) * GammaReal(PomQuarkB + 1.));\n\n}\n\n//--------------------------------------------------------------------------\n\n// Gives a generic Q2-independent Pomeron PDF.\n\nvoid PomFix::xfUpdate(int , double x, double) {\n\n  // Gluon and quark distributions.\n  double gl = normGluon * pow(x, PomGluonA) * pow( (1. - x), PomGluonB);\n  double qu = normQuark * pow(x, PomQuarkA) * pow( (1. - x), PomQuarkB);\n\n  // Update values\n  xg    = (1. - PomQuarkFrac) * gl;\n  xu    = (PomQuarkFrac / (4. + 2. * PomStrangeSupp) ) * qu;\n  xd    = xu;\n  xubar = xu;\n  xdbar = xu;\n  xs    = PomStrangeSupp * xu;\n  xsbar = xs;\n  xc    = 0.;\n  xb    = 0.;\n\n  // Subdivision of valence and sea.\n  xuVal = 0.;\n  xuSea = xu;\n  xdVal = 0.;\n  xdSea = xd;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// Pomeron PDF: the H1 2006 Fit A and Fit B Q2-dependent parametrizations.\n\n//--------------------------------------------------------------------------\n\nvoid PomH1FitAB::init( int iFit, string xmlPath, Info* infoPtr) {\n\n  // Open files from which grids should be read in.\n  if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += \"/\";\n  string         dataFile = \"pomH1FitBlo.data\";\n  if (iFit == 1) dataFile = \"pomH1FitA.data\";\n  if (iFit == 2) dataFile = \"pomH1FitB.data\";\n  ifstream is( (xmlPath + dataFile).c_str() );\n  if (!is.good()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from PomH1FitAB::init: \"\n      \"the H1 Pomeron parametrization file was not found\");\n    else cout << \" Error from PomH1FitAB::init: \"\n      << \"the H1 Pomeron parametrization file was not found\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // Lower and upper bounds. Bin widths for logarithmic spacing.\n  nx    = 100;\n  xlow  = 0.001;\n  xupp  = 0.99;\n  dx    = log(xupp / xlow) / (nx - 1.);\n  nQ2   = 30;\n  Q2low = 1.0;\n  Q2upp = 30000.;\n  dQ2   = log(Q2upp / Q2low) / (nQ2 - 1.);\n\n  // Read in quark data grid.\n  for (int i = 0; i < nx; ++i)\n    for (int j = 0; j < nQ2; ++j)\n      is >> quarkGrid[i][j];\n\n  // Read in gluon data grid.\n  for (int i = 0; i < nx; ++i)\n    for (int j = 0; j < nQ2; ++j)\n      is >> gluonGrid[i][j];\n\n  // Check for errors during read-in of file.\n  if (!is) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from PomH1FitAB::init: \"\n      \"the H1 Pomeron parametrization files could not be read\");\n    else cout << \" Error from PomH1FitAB::init: \"\n      << \"the H1 Pomeron parametrization files could not be read\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // Done.\n  isSet = true;\n  return;\n}\n\n//--------------------------------------------------------------------------\n\nvoid PomH1FitAB::xfUpdate(int , double x, double Q2) {\n\n  // Retrict input to validity range.\n  double xt  = min( xupp, max( xlow, x) );\n  double Q2t = min( Q2upp, max( Q2low, Q2) );\n\n  // Lower grid point and distance above it.\n  double dlx  = log( xt / xlow) / dx;\n  int i       = min( nx - 2,  int(dlx) );\n  dlx        -= i;\n  double dlQ2 = log( Q2t / Q2low) / dQ2;\n  int j       = min( nQ2 - 2, int(dlQ2) );\n  dlQ2       -= j;\n\n  // Interpolate to derive quark PDF.\n  double qu = (1. - dlx) * (1. - dlQ2) * quarkGrid[i][j]\n            +       dlx  * (1. - dlQ2) * quarkGrid[i + 1][j]\n            + (1. - dlx) *       dlQ2  * quarkGrid[i][j + 1]\n            +       dlx  *       dlQ2  * quarkGrid[i + 1][j + 1];\n\n  // Interpolate to derive gluon PDF.\n  double gl = (1. - dlx) * (1. - dlQ2) * gluonGrid[i][j]\n            +       dlx  * (1. - dlQ2) * gluonGrid[i + 1][j]\n            + (1. - dlx) *       dlQ2  * gluonGrid[i][j + 1]\n            +       dlx  *       dlQ2  * gluonGrid[i + 1][j + 1];\n\n  // Update values.\n  xg    = rescale * gl;\n  xu    = rescale * qu;\n  xd    = xu;\n  xubar = xu;\n  xdbar = xu;\n  xs    = xu;\n  xsbar = xu;\n  xc    = 0.;\n  xb    = 0.;\n\n  // Subdivision of valence and sea.\n  xuVal = 0.;\n  xuSea = xu;\n  xdVal = 0.;\n  xdSea = xu;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// Pomeron PDF: the H1 2007 Jets Q2-dependent parametrization.\n\n//--------------------------------------------------------------------------\n\nvoid PomH1Jets::init( string xmlPath, Info* infoPtr) {\n\n  // Open files from which grids should be read in.\n  if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += \"/\";\n  ifstream isg( (xmlPath + \"pomH1JetsGluon.data\").c_str() );\n  ifstream isq( (xmlPath + \"pomH1JetsSinglet.data\").c_str() );\n  ifstream isc( (xmlPath + \"pomH1JetsCharm.data\").c_str() );\n  if (!isg.good() || !isq.good() || !isc.good()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from PomH1Jets::init: \"\n      \"the H1 Pomeron parametrization files were not found\");\n    else cout << \" Error from PomH1Jets::init: \"\n      << \"the H1 Pomeron parametrization files were not found\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // Read in x and Q grids. Do interpolation logarithmically in Q2.\n  for (int i = 0; i < 100; ++i) {\n    isg >> setw(13) >> xGrid[i];\n  }\n  for (int j = 0; j < 88; ++j) {\n    isg >> setw(13) >> Q2Grid[j];\n    Q2Grid[j] = log( Q2Grid[j] );\n  }\n\n  // Read in  gluon data grid.\n  for (int j = 0; j < 88; ++j) {\n    for (int i = 0; i < 100; ++i) {\n      isg >> setw(13) >> gluonGrid[i][j];\n    }\n  }\n\n  // Identical x and Q2 grid for singlet, so skip ahead.\n  double dummy;\n  for (int i = 0; i < 188; ++i) isq >> setw(13) >> dummy;\n\n  // Read in singlet data grid.\n  for (int j = 0; j < 88; ++j) {\n    for (int i = 0; i < 100; ++i) {\n      isq >> setw(13) >> singletGrid[i][j];\n    }\n  }\n\n  // Identical x and Q2 grid for charm, so skip ahead.\n  for (int i = 0; i < 188; ++i) isc >> setw(13) >> dummy;\n\n  // Read in charm data grid.\n  for (int j = 0; j < 88; ++j) {\n    for (int i = 0; i < 100; ++i) {\n      isc >> setw(13) >> charmGrid[i][j];\n    }\n  }\n\n  // Check for errors during read-in of files.\n  if (!isg || !isq || !isc) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from PomH1Jets::init: \"\n      \"the H1 Pomeron parametrization files could not be read\");\n    else cout << \" Error from PomH1Jets::init: \"\n      << \"the H1 Pomeron parametrization files could not be read\" << endl;\n    isSet = false;\n    return;\n  }\n\n  // Done.\n  isSet = true;\n  return;\n}\n\n//--------------------------------------------------------------------------\n\nvoid PomH1Jets::xfUpdate(int , double x, double Q2) {\n\n  // Find position in x array.\n  double xLog = log(x);\n  int    i    = 0;\n  double dx   = 0.;\n  if (xLog <= xGrid[0]);\n  else if (xLog >= xGrid[99]) {\n    i  = 98;\n    dx = 1.;\n  } else {\n    while (xLog > xGrid[i]) ++i;\n    --i;\n    dx = (xLog - xGrid[i]) / (xGrid[i + 1] - xGrid[i]);\n  }\n\n  // Find position in y array.\n  double Q2Log = log(Q2);\n  int    j     = 0;\n  double dQ2   = 0.;\n  if (Q2Log <= Q2Grid[0]);\n  else if (Q2Log >= Q2Grid[87]) {\n    j   = 86;\n    dQ2 = 1.;\n  } else {\n    while (Q2Log > Q2Grid[j]) ++j;\n    --j;\n    dQ2 = (Q2Log - Q2Grid[j]) / (Q2Grid[j + 1] - Q2Grid[j]);\n  }\n\n  // Interpolate to derive gluon PDF.\n  double gl = (1. - dx) * (1. - dQ2) * gluonGrid[i][j]\n            +       dx  * (1. - dQ2) * gluonGrid[i + 1][j]\n            + (1. - dx) *       dQ2  * gluonGrid[i][j + 1]\n            +       dx  *       dQ2  * gluonGrid[i + 1][j + 1];\n\n  // Interpolate to derive singlet PDF. (Sum of u, d, s, ubar, dbar, sbar.)\n  double sn = (1. - dx) * (1. - dQ2) * singletGrid[i][j]\n            +       dx  * (1. - dQ2) * singletGrid[i + 1][j]\n            + (1. - dx) *       dQ2  * singletGrid[i][j + 1]\n            +       dx  *       dQ2  * singletGrid[i + 1][j + 1];\n\n  // Interpolate to derive charm PDF. (Charge-square times c and cbar.)\n  double ch = (1. - dx) * (1. - dQ2) * charmGrid[i][j]\n            +       dx  * (1. - dQ2) * charmGrid[i + 1][j]\n            + (1. - dx) *       dQ2  * charmGrid[i][j + 1]\n            +       dx  *       dQ2  * charmGrid[i + 1][j + 1];\n\n  // Update values.\n  xg    = rescale * gl;\n  xu    = rescale * sn / 6.;\n  xd    = xu;\n  xubar = xu;\n  xdbar = xu;\n  xs    = xu;\n  xsbar = xu;\n  xc    = rescale * ch * 9./8.;\n  xb    = 0.;\n\n  // Subdivision of valence and sea.\n  xuVal = 0.;\n  xuSea = xu;\n  xdVal = 0.;\n  xdSea = xd;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// Gives electron (or muon, or tau) parton distribution.\n\n// Constants: alphaEM(0), m_e, m_mu, m_tau.\nconst double Lepton::ALPHAEM = 0.00729735;\nconst double Lepton::ME      = 0.0005109989;\nconst double Lepton::MMU     = 0.10566;\nconst double Lepton::MTAU    = 1.77699;\n\nvoid Lepton::xfUpdate(int id, double x, double Q2) {\n\n  // Squared mass of lepton species: electron, muon, tau.\n  if (!isInit) {\n    double             mLep = ME;\n    if (abs(id) == 13) mLep = MMU;\n    if (abs(id) == 15) mLep = MTAU;\n    m2Lep  = pow2( mLep );\n    isInit = true;\n  }\n\n  // Electron inside electron, see R. Kleiss et al., in Z physics at\n  // LEP 1, CERN 89-08, p. 34\n  double xLog = log(max(1e-10,x));\n  double xMinusLog = log( max(1e-10, 1. - x) );\n  double Q2Log = log( max(3., Q2/m2Lep) );\n  double beta = (ALPHAEM / M_PI) * (Q2Log - 1.);\n  double delta = 1. + (ALPHAEM / M_PI) * (1.5 * Q2Log + 1.289868)\n    + pow2(ALPHAEM / M_PI) * (-2.164868 * Q2Log*Q2Log\n    + 9.840808 * Q2Log - 10.130464);\n  double fPrel =  beta * pow(1. - x, beta - 1.) * sqrtpos( delta )\n     - 0.5 * beta * (1. + x) + 0.125 * beta*beta * ( (1. + x)\n     * (-4. * xMinusLog + 3. * xLog) - 4. * xLog / (1. - x) - 5. - x);\n\n  // Zero distribution for very large x and rescale it for intermediate.\n  if (x > 1. - 1e-10) fPrel = 0.;\n  else if (x > 1. - 1e-7) fPrel *= pow(1000.,beta) / (pow(1000.,beta) - 1.);\n  xlepton = x * fPrel;\n\n  // Photon inside electron (one possible scheme - primitive).\n  xgamma = (0.5 * ALPHAEM / M_PI) * Q2Log * (1. + pow2(1. - x));\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav = 9;\n\n}\n\n//==========================================================================\n\n// The NNPDF class.\n// Code for handling NNPDF2.3 QCD+QED LO\n// Code provided by Juan Rojo and Stefano Carrazza.\n\n//--------------------------------------------------------------------------\n\n// Freeze PDFs below XMINGRID\nconst double NNPDF::fXMINGRID = 1e-9;\n\n//--------------------------------------------------------------------------\n\n// Initialize PDF: read in data grid from file.\n\nvoid NNPDF::init(int iFitIn, string xmlPath, Info* infoPtr) {\n\n  // Choice of fit among possibilities.\n  iFit = iFitIn;\n\n  // Select which data file to read for current fit.\n  if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += \"/\";\n  string fileName = \"  \";\n  // NNPDF2.3 LO QCD+QED, for two values of alphas\n  if (iFit == 1) fileName = \"NNPDF23_lo_as_0130_qed_mem0.grid\";\n  if (iFit == 2) fileName = \"NNPDF23_lo_as_0119_qed_mem0.grid\";\n  // NNPDF2.3 NLO QCD+QED\n  if (iFit == 3) fileName = \"NNPDF23_nlo_as_0119_qed_mc_mem0.grid\";\n  // NNPDF2.4 NLO QCD+QED\n  if (iFit == 4) fileName = \"NNPDF23_nnlo_as_0119_qed_mc_mem0.grid\";\n\n  // Open data file.\n  fstream f;\n  f.open( (xmlPath + fileName).c_str(),ios::in);\n  if (f.fail()) {\n    if (infoPtr != 0) infoPtr->errorMsg(\"Error from NNPDF::init: \"\n      \"did not find data file \", fileName);\n    else cout << \"Error: cannot open file \" << (xmlPath + fileName) << endl;\n    isSet = false;\n    return;\n  }\n\n  // Reading grid: removing header.\n  string tmp;\n  for (;;) {\n    getline(f,tmp);\n    if (tmp.find(\"NNPDF20intqed\") != string::npos) {\n      getline(f,tmp);\n      break;\n    }\n  }\n\n  // Get nx and x grid.\n  f >> fNX;\n  fXGrid = new double[fNX];\n  for (int ix = 0; ix < fNX; ix++) f >> fXGrid[ix];\n  fLogXGrid = new double[fNX];\n  for (int ix = 0; ix < fNX; ix++) fLogXGrid[ix] = log(fXGrid[ix]);\n\n  // Get nQ2 and Q2 grid (ignorming first value).\n  f >> fNQ2;\n  f >> tmp;\n  fQ2Grid = new double[fNQ2];\n  for (int iq = 0; iq < fNQ2; iq++) f >> fQ2Grid[iq];\n  fLogQ2Grid = new double[fNQ2];\n  for (int iq = 0; iq < fNQ2; iq++) fLogQ2Grid[iq] = log(fQ2Grid[iq]);\n\n  // Prepare grid array.\n  fPDFGrid = new double**[fNFL];\n  for (int i = 0; i < fNFL; i++) {\n    fPDFGrid[i] = new double*[fNX];\n    for (int j = 0; j < fNX; j++) {\n      fPDFGrid[i][j] = new double[fNQ2];\n      for (int z = 0; z < fNQ2; z++) fPDFGrid[i][j][z] = 0.0;\n    }\n  }\n\n  // Check values of number of grid entries.\n  if (fNX<= 0 || fNX>100 || fNQ2<=0 || fNQ2>50) {\n    cout << \"Error in NNPDF::init, Invalid grid values\" << endl\n         << \"fNX = \" << fNX << endl << \"fNQ2 = \" << fNQ2 << endl\n         << \"fNFL = \" <<fNFL << endl;\n    isSet = false;\n    return;\n  }\n\n  // Ignore replica number. Read PDF grid points.\n  f >> tmp;\n  for (int ix = 0; ix < fNX; ix++)\n    for (int iq = 0; iq < fNQ2; iq++)\n      for (int fl = 0; fl < fNFL; fl++)\n        f >> fPDFGrid[fl][ix][iq];\n  f.close();\n\n  // Other vectors.\n  fRes = new double[fNFL];\n\n}\n\n//--------------------------------------------------------------------------\n\nvoid NNPDF::xfUpdate(int , double x, double Q2) {\n\n  // Update using NNPDF routine, within allowed (x, q) range.\n  xfxevolve(x,Q2);\n\n  // Then transfer to Pythia8 notation.\n  xg     = fRes[6];\n  xu     = fRes[8];\n  xd     = fRes[7];\n  xubar  = fRes[4];\n  xdbar  = fRes[5];\n  xs     = fRes[9];\n  xsbar  = fRes[3];\n  xc     = fRes[10];\n  xb     = fRes[11];\n  xgamma = fRes[13];\n\n  // Subdivision of valence and sea.\n  xuVal  = xu - xubar;\n  xuSea  = xubar;\n  xdVal  = xd - xdbar;\n  xdSea  = xdbar;\n\n  // idSav = 9 to indicate that all flavours reset.\n  idSav  = 9;\n\n}\n\n//--------------------------------------------------------------------------\n\nvoid NNPDF::xfxevolve(double x, double Q2) {\n\n  // Freeze outside x-Q2 grid.\n  if (x < fXMINGRID || x > fXGrid[fNX-1]) {\n    if (x < fXMINGRID)  x = fXMINGRID;\n    if (x > fXGrid[fNX-1]) x = fXGrid[fNX-1];\n  }\n  if (Q2 < fQ2Grid[0] || Q2 > fQ2Grid[fNQ2-1]) {\n    if (Q2 < fQ2Grid[0]) Q2 = fQ2Grid[0];\n    if (Q2 > fQ2Grid[fNQ2-1]) Q2 = fQ2Grid[fNQ2-1];\n  }\n\n  // Find nearest points in the x-Q2 grid.\n  int minx = 0;\n  int maxx = fNX;\n  while (maxx-minx > 1) {\n    int midx = (minx+maxx)/2;\n    if (x < fXGrid[midx]) maxx = midx;\n    else minx = midx;\n  }\n  int ix = minx;\n  int minq = 0;\n  int maxq = fNQ2;\n  while (maxq-minq > 1) {\n    int midq = (minq+maxq)/2;\n    if (Q2 < fQ2Grid[midq]) maxq = midq;\n    else minq = midq;\n  }\n  int iq2 = minq;\n\n  // Assign grid for interpolation. M,N -> order of polyN interpolation.\n  int    ix1a[fM], ix2a[fN];\n  double x1a[fM], x2a[fN];\n  double ya[fM][fN];\n\n  for (int i = 0; i < fM; i++) {\n    if (ix+1 >= fM/2 && ix+1 <= (fNX-fM/2)) ix1a[i] = ix+1 - fM/2 + i;\n    if (ix+1 < fM/2) ix1a[i] = i;\n    if (ix+1 > (fNX-fM/2)) ix1a[i] = (fNX-fM) + i;\n    // Check grids.\n    if (ix1a[i] < 0 || ix1a[i] >= fNX) {\n      cout << \"Error in grids! i, ixia[i] = \" << i << \"\\t\" << ix1a[i] << endl;\n      return;\n    }\n  }\n\n  for (int j = 0; j < fN; j++) {\n    if (iq2+1 >= fN/2 && iq2+1 <= (fNQ2-fN/2)) ix2a[j] = iq2+1 - fN/2 + j;\n    if (iq2+1 < fN/2) ix2a[j] = j;\n    if (iq2+1 > (fNQ2-fN/2)) ix2a[j] = (fNQ2-fN) + j;\n    // Check grids.\n    if (ix2a[j] < 0 || ix2a[j] >= fNQ2) {\n      cout << \"Error in grids! j, ix2a[j] = \" << j << \"\\t\" << ix2a[j] << endl;\n      return;\n    }\n  }\n\n  const double xch = 1e-1;\n  double x1;\n  if (x < xch) x1 = log(x);\n  else x1 = x;\n  double x2 = log(Q2);\n\n  for (int ipdf = 0; ipdf < fNFL; ipdf++) {\n    fRes[ipdf] = 0.0;\n    for (int i = 0; i < fM; i++) {\n      if (x < xch) x1a[i] = fLogXGrid[ix1a[i]];\n      else         x1a[i] = fXGrid[ix1a[i]];\n\n      for (int j = 0; j < fN; j++) {\n        x2a[j] = fLogQ2Grid[ix2a[j]];\n        ya[i][j] = fPDFGrid[ipdf][ix1a[i]][ix2a[j]];\n      }\n    }\n\n    // 2D polynomial interpolation.\n    double y = 0, dy = 0;\n    polin2(x1a,x2a,ya,x1,x2,y,dy);\n    fRes[ipdf] = y;\n  }\n\n}\n\n//--------------------------------------------------------------------------\n\n// 1D polynomial interpolation.\n\nvoid NNPDF::polint(double xa[], double yal[], int n, double x,\n  double& y, double& dy) {\n\n  int ns = 0;\n  double dif = abs(x-xa[0]);\n  double c[fM > fN ? fM : fN];\n  double d[fM > fN ? fM : fN];\n\n  for (int i = 0; i < n; i++) {\n    double dift = abs(x-xa[i]);\n    if (dift < dif) {\n      ns = i;\n      dif = dift;\n    }\n    c[i] = yal[i];\n    d[i] = yal[i];\n  }\n  y = yal[ns];\n  ns--;\n  for (int m = 1; m < n; m++) {\n    for (int i = 0; i < n-m; i++) {\n      double ho = xa[i]-x;\n      double hp = xa[i+m]-x;\n      double w = c[i+1]-d[i];\n      double den = ho-hp;\n      if (den == 0) {\n        cout << \"NNPDF::polint, failure\" << endl;\n        return;\n      }\n      den = w/den;\n      d[i] = hp*den;\n      c[i] = ho*den;\n    }\n    if (2*(ns+1) < n-m) dy = c[ns+1];\n    else {\n      dy = d[ns];\n      ns--;\n    }\n    y+=dy;\n  }\n}\n\n//--------------------------------------------------------------------------\n\n// 2D polynomial interpolation.\n\nvoid NNPDF::polin2(double x1al[], double x2al[], double yal[][fN],\n  double x1, double x2, double& y, double& dy) {\n\n  double yntmp[fN];\n  double ymtmp[fM];\n\n  for (int j = 0; j < fM; j++) {\n    for (int k = 0; k < fN; k++) yntmp[k] = yal[j][k];\n    polint(x2al,yntmp,fN,x2,ymtmp[j],dy);\n  }\n  polint(x1al,ymtmp,fM,x1,y,dy);\n\n}\n\n//==========================================================================\n\n// LHAPDF plugin interface.\n\n//--------------------------------------------------------------------------\n\n// Constructor.\n\nLHAPDF::LHAPDF(int idIn, string pSet, Info* infoPtrIn) :\n  pdfPtr(0), infoPtr(infoPtrIn) {\n  isSet = false;\n  if (!infoPtr) return;\n\n  // Determine the plugin library name.\n  if (pSet.size() < 8) {\n    infoPtr->errorMsg(\"Error from LHAPDF::LHAPDF: invalid pSet \" + pSet);\n    return;\n  }\n  libName = pSet.substr(0, 7);\n  if (libName != \"LHAPDF5\" && libName != \"LHAPDF6\") {\n    infoPtr->errorMsg(\"Error from LHAPDF::LHAPDF: invalid pSet \" + pSet);\n    return;\n  }\n  libName = \"libpythia8lhapdf\" + libName.substr(6) + \".so\";\n\n  // Determine the PDF set and member.\n  string   set = pSet.substr(8);\n  int      mem = 0;\n  size_t   pos = set.find_last_of(\"/\");\n  if (pos != string::npos) {\n    istringstream memStream(set.substr(pos + 1));\n    memStream >> mem;\n  }\n  set = set.substr(0, pos);\n\n  // Load the PDF.\n  NewLHAPDF* newLHAPDF = (NewLHAPDF*)symbol(\"newLHAPDF\");\n  if (!newLHAPDF) return;\n  pdfPtr = newLHAPDF(idIn, set, mem, infoPtr);\n  isSet = true;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Destructor.\n\nLHAPDF::~LHAPDF() {\n  if (!infoPtr) return;\n  if (!isSet)   return;\n\n  // Delete the PDF.\n  DeleteLHAPDF* deleteLHAPDF = (DeleteLHAPDF*)symbol(\"deleteLHAPDF\");\n  if (deleteLHAPDF) deleteLHAPDF(pdfPtr);\n\n  // Close the plugin library if not needed by other instances.\n  map<string, pair<void*, int> >::iterator plugin =\n    infoPtr->plugins.find(libName);\n  if (plugin == infoPtr->plugins.end()) return;\n  --plugin->second.second;\n  if (plugin->second.first && plugin->second.second == 0) {\n    dlclose(plugin->second.first);\n    dlerror();\n    infoPtr->plugins.erase(plugin);\n  }\n\n}\n\n//--------------------------------------------------------------------------\n\n// Access a plugin library symbol.\n\nLHAPDF::Symbol LHAPDF::symbol(string symName) {\n  void  *lib(0);\n  Symbol sym(0);\n  const char* error(0);\n  if (!infoPtr) return sym;\n\n  // Load the library if not loaded.\n  map<string, pair<void*, int> >::iterator plugin =\n    infoPtr->plugins.find(libName);\n  if (plugin == infoPtr->plugins.end()) {\n    lib   = dlopen(libName.c_str(), RTLD_LAZY);\n    error = dlerror();\n  }\n  if (error) {\n    infoPtr->errorMsg(\"Error from LHAPDF::symbol: \" + string(error));\n    return sym;\n  }\n  if (plugin == infoPtr->plugins.end())\n    infoPtr->plugins[libName] = pair<void*, int>(lib, 1);\n  else {\n    lib = plugin->second.first;\n    ++plugin->second.second;\n  }\n  dlerror();\n\n  // Load the symbol.\n  sym = (Symbol)dlsym(lib, symName.c_str());\n  error = dlerror();\n  if (error) infoPtr->errorMsg(\"Error from LHAPDF::symbol: \" + string(error));\n  dlerror();\n  return sym;\n\n}\n\n//==========================================================================\n\n} // end namespace Pythia8\n",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/include/Pythia8Plugins/PowhegProcs.h": "// PowhegProcs.h is a part of the PYTHIA event generator.\n// Copyright (C) 2015 Torbjorn Sjostrand.\n// PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.\n// Please respect the MCnet Guidelines, see GUIDELINES for details.\n// Author: Philip Ilten, May 2015.\n\n#ifndef Pythia8_PowhegProcs_H\n#define Pythia8_PowhegProcs_H\n\n#include \"Pythia8/Pythia.h\"\n#include \"Pythia8Plugins/PowhegHooks.h\"\n\nnamespace Pythia8 {\n\n//==========================================================================\n\n// A class to generate events with hard processes from POWHEGBOX\n// matrix elements. See http://powhegbox.mib.infn.it/ for further\n// details on POWHEGBOX.\n\nclass PowhegProcs {\n\npublic:\n\n  // Constructor.\n  PowhegProcs(Pythia *pythiaPtrIn, string procIn, string dirIn = \"powhegrun\",\n    string pdfIn = \"\", bool random = true);\n\n  // Destructor.\n  ~PowhegProcs();\n\n  // Read a POWHEG settings string.\n  bool readString(string line);\n\n  // Read a POWHEG settings file.\n  bool readFile(string name);\n\n  // Write out the input for POWHEG.\n  bool init();\n\n  // The POWHEG LHAup pointer.\n  LHAup *lhaup;\n\nprivate:\n\n  // Typedefs of the hooks used to access the plugin.\n  typedef LHAup* NewLHAupPowheg(Pythia*);\n  typedef void DeleteLHAupPowheg(LHAup*);\n\n  // The POWHEG process name, run directory, and PDF file (if not LHAPDF).\n  string proc, dir, pdf;\n\n  // The map of POWHEG settings.\n  map<string, string> settings;\n\n  // The associated PYTHIA pointer.\n  Pythia *pythia;\n\n  // The POWHEG plugin library.\n  void *lib;\n\n  // The POWHEG hooks.\n  PowhegHooks hooks;\n\n};\n\n//--------------------------------------------------------------------------\n\n// Constructor.\n\n// pythiaPtrIn: The PYTHIA object the plugin will use for settings and\n// random numbers.\n\n// procIn: the process name. An attempt is made to load the plugin\n// library libpythia8powheg<procIn>.so.\n\n// dirIn: The directory where the POWHEG matrix element will be\n// run. This is needed if two instances are to be run concurrently\n// since the matrix element generates a large number of files.\n\n// pdfIn: The full path and name of the PDF file to use, if not using\n// LHAPDF. This file is copied to the run directory via the init()\n// method.\n\n// random: Flag to use the Pythia random number generator with\n// POWHEGBOX. If true, the POWHEGBOX random number block is\n// initialized for each event from the Pythia random number\n// generator. If false, the default POWHEGBOX random number generation\n// is performed. Note that the initialization is always performed\n// using the POWHEGBOX random number generation (which can be modified\n// via the POWHEGBOX configuration).\n\nPowhegProcs::PowhegProcs(Pythia *pythiaPtrIn, string procIn, string dirIn,\n  string pdfIn, bool random) : lhaup(0), proc(procIn), dir(dirIn), pdf(pdfIn),\n  pythia(pythiaPtrIn), lib(0) {\n\n  if (!pythia) return;\n  NewLHAupPowheg *sym(0);\n  const char* error(0);\n\n  // Load the library.\n  lib = dlopen((\"libpythia8powheg\" + proc + \".so\").c_str(), RTLD_LAZY);\n  error = dlerror();\n  if (error) {\n    pythia->info.errorMsg(\"Error from PowhegProcs::PowhegProcs: \"\n      + string(error));\n    return;\n  }\n  dlerror();\n\n  // Load the LHAup pointer.\n  sym = (NewLHAupPowheg*)dlsym(lib, \"newLHAupPowheg\");\n  error = dlerror();\n  if (error) {\n    pythia->info.errorMsg(\"Error from PowhegProcs::PowhegProcs: \"\n      + string(error));\n  }\n  dlerror();\n  pythia->settings.addWord(\"POWHEG:dir\", dir);\n  pythia->settings.addFlag(\"POWHEG:pythiaRandom\", random);\n  if (sym) lhaup = sym(pythia);\n\n  // Configure PYTHIA.\n  pythia->setLHAupPtr(lhaup);\n  pythia->setUserHooksPtr(&hooks);\n\n}\n\n//--------------------------------------------------------------------------\n\n// Destructor.\n\nPowhegProcs::~PowhegProcs() {\n\n  // Delete the LHAup pointer.\n  if (lhaup && lib) {\n    DeleteLHAupPowheg *sym(0);\n    sym = (DeleteLHAupPowheg*)dlsym(lib, \"deleteLHAupPowheg\");\n    if (sym) sym(lhaup);\n  }\n\n  // Unload the library.\n  if (lib) {dlclose(lib); dlerror();}\n\n}\n\n//--------------------------------------------------------------------------\n\n// Read a POWHEG settings string. If a setting is repeated a warning\n// is printed but the most recent setting is used.\n\nbool PowhegProcs::readString(string line) {\n\n  // Copy string without initial and trailing blanks.\n  if (!pythia) return false;\n  if (line.find_first_not_of(\" \\n\\t\\v\\b\\r\\f\\a\") == string::npos) return true;\n  int firstChar = line.find_first_not_of(\" \\n\\t\\v\\b\\r\\f\\a\");\n  int lastChar  = line.find_last_not_of(\" \\n\\t\\v\\b\\r\\f\\a\");\n  line = line.substr(firstChar, lastChar + 1 - firstChar);\n\n  // Find the key.\n  firstChar = line.find_first_of(\"  \\t\\f\\v\\n\\r\");\n  string key = line.substr(0, firstChar);\n  for (int i = 0; i < int(key.length()); ++i) key[i] = tolower(key[i]);\n\n  // Add the setting.\n  if (key.size() > 0\n    && key.find_first_of(\"abcdedfghijklmnopqrtsuvwxyz\") == 0) {\n    map<string, string>::iterator setting = settings.find(key);\n    if (setting != settings.end()) {\n      pythia->info.errorMsg(\"Warning from PowhegProcs::readString: replacing \"\n        \"previous POWHEG setting for \" + key + \".\");\n      setting->second = line;\n    } else settings[key] = line;\n  }\n  return true;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Read a POWHEG settings file.\n\nbool PowhegProcs::readFile(string name) {\n\n  fstream config(name.c_str(), ios::in); string line;\n  while (getline(config, line, '\\n')) readString(line);\n  config.close();\n  return true;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Write the input for POWHEG.\n\nbool PowhegProcs::init() {\n\n  // Copy over the PDF file if needed.\n  if (pdf != \"\") {\n    fstream pdfin(pdf.c_str(), ios::in | ios::binary);\n    fstream pdfout((dir + \"/\" + pdf.substr(0, pdf.find_last_of(\"/\"))).c_str(),\n      ios::out | ios::binary);\n    pdfout << pdfin.rdbuf();\n    pdfin.close();\n    pdfout.close();\n  }\n\n  // Copy the settings to the configuration file.\n  fstream config((dir + \"/\" + \"powheg.input\").c_str(), ios::out);\n  for (map<string, string>::iterator setting = settings.begin();\n    setting != settings.end(); ++setting) config << setting->second << \"\\n\";\n  config.close();\n  return true;\n\n}\n\n//==========================================================================\n\n} // end namespace Pythia8\n\n#endif // Pythia8_PowhegProcs_H\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/src/HardDiffraction.cc",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/htmldoc/pythia99.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/htmldoc/pythia32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/phpdoc/pythia99.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/phpdoc/pythia32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/pdfdoc/evtgen.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/pdfdoc/worksheet8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/pdfdoc/pythia8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/pdfdoc/pdfwarning.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/share/Pythia8/pdfdoc/g2qqbarsplit.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/zProduction_UnlopsLoop_01.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/ttbar.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/zProduction_UnlopsTree_12.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/zProduction_Ckkwl_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/zProduction_Mlm_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8212-u24swybrdmmn47amnhzkbplvbetsbze3/spack-src/examples/zProduction_Fxfx_01.lhe.gz"
    ],
    "total_files": 580
}