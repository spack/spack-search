{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/include/Pythia8/Info.h": "// Info.h is a part of the PYTHIA event generator.\n// Copyright (C) 2019 Torbjorn Sjostrand.\n// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.\n// Please respect the MCnet Guidelines, see GUIDELINES for details.\n\n// This file contains classes that keep track of generic event info.\n// Info: contains information on the generation process and errors.\n// Info: user interface to make parts of Info publicly available.\n\n#ifndef Pythia8_Info_H\n#define Pythia8_Info_H\n\n#include \"Pythia8/Basics.h\"\n#include \"Pythia8/LHEF3.h\"\n#include \"Pythia8/PythiaStdlib.h\"\n#include \"Pythia8/SharedPointers.h\"\n\nnamespace Pythia8 {\n\n// Forward declaration of various classes.\nclass Settings;\nclass ParticleData;\nclass Rndm;\nclass CoupSM;\nclass CoupSUSY;\nclass BeamParticle;\nclass PartonSystems;\nclass SigmaTotal;\n\n// Forward declaration of HIInfo class.\nclass HIInfo;\n\n//==========================================================================\n\n// The Info class contains a mixed bag of information on the event\n// generation activity, especially on the current subprocess properties,\n// and on the number of errors encountered. This is used by the\n// generation machinery.\n\nclass Info {\n\npublic:\n\n  // Constructors.\n  Info() = default;\n  Info(bool) : Info() {weightCKKWLSave = 1.;}\n\n  // Destructor for clean-up.\n  ~Info() {\n    if (hasOwnEventAttributes && eventAttributes != nullptr)\n      delete eventAttributes;\n  }\n\n  // Pointers to other class objects, carried piggyback by Info.\n\n  // Set pointers to other class objects.\n  void setPtrs(Settings* settingsPtrIn, ParticleData* particleDataPtrIn,\n    Rndm* rndmPtrIn, CoupSM* coupSMPtrIn, CoupSUSY* coupSUSYPtrIn,\n    BeamParticle* beamAPtrIn,    BeamParticle* beamBPtrIn,\n    BeamParticle* beamPomAPtrIn, BeamParticle*  beamPomBPtrIn,\n    BeamParticle* beamGamAPtrIn, BeamParticle*  beamGamBPtrIn,\n    BeamParticle* beamVMDAPtrIn, BeamParticle*  beamVMDBPtrIn,\n    PartonSystems* partonSystemsPtrIn, SigmaTotal* sigmaTotPtrIn) {\n    settingsPtr = settingsPtrIn; particleDataPtr = particleDataPtrIn;\n    rndmPtr = rndmPtrIn; coupSMPtr = coupSMPtrIn; coupSUSYPtr = coupSUSYPtrIn;\n    beamAPtr    = beamAPtrIn;    beamBPtr    = beamBPtrIn;\n    beamPomAPtr = beamPomAPtrIn; beamPomBPtr = beamPomBPtrIn;\n    beamGamAPtr = beamGamAPtrIn; beamGamBPtr = beamGamBPtrIn;\n    beamVMDAPtr = beamVMDAPtrIn; beamVMDBPtr = beamVMDBPtrIn;\n    partonSystemsPtr = partonSystemsPtrIn; sigmaTotPtr = sigmaTotPtrIn;}\n\n  // Pointer to the settings database.\n  Settings*      settingsPtr{};\n\n  // Pointer to the particle data table.\n  ParticleData*  particleDataPtr{};\n\n  // Pointer to the random number generator.\n  Rndm*          rndmPtr{};\n\n  // Pointers to Standard Model and Beyond SM couplings.\n  CoupSM*        coupSMPtr{};\n  CoupSUSY*      coupSUSYPtr{};\n\n  // Pointers to the two incoming beams and to Pomeron, photon or VMD\n  // beam-inside-beam cases.\n  BeamParticle*  beamAPtr{};\n  BeamParticle*  beamBPtr{};\n  BeamParticle*  beamPomAPtr{};\n  BeamParticle*  beamPomBPtr{};\n  BeamParticle*  beamGamAPtr{};\n  BeamParticle*  beamGamBPtr{};\n  BeamParticle*  beamVMDAPtr{};\n  BeamParticle*  beamVMDBPtr{};\n\n  // Pointer to information on subcollision parton locations.\n  PartonSystems* partonSystemsPtr{};\n\n  // Pointer to the total/elastic/diffractive cross sections.\n  SigmaTotal*    sigmaTotPtr{};\n\n  // Pointer to the UserHooks object set for the run.\n  UserHooksPtr   userHooksPtr{};\n\n  // Pointer to information about a HeavyIons run and the current event.\n  // (Is NULL if HeavyIons object is inactive.)\n  HIInfo*        hiInfo{};\n\n  // Listing of most available information on current event.\n  void   list() const;\n\n  // Beam particles (in rest frame). CM energy of event.\n  int    idA()                const {return idASave;}\n  int    idB()                const {return idBSave;}\n  double pzA()                const {return pzASave;}\n  double pzB()                const {return pzBSave;}\n  double eA()                 const {return eASave;}\n  double eB()                 const {return eBSave;}\n  double mA()                 const {return mASave;}\n  double mB()                 const {return mBSave;}\n  double eCM()                const {return eCMSave;}\n  double s()                  const {return sSave;}\n\n  // Warnings from initialization.\n  bool   tooLowPTmin()        const {return lowPTmin;}\n\n  // Process name and code, and the number of final-state particles.\n  string name()               const {return nameSave;}\n  int    code()               const {return codeSave;}\n  int    nFinal()             const {return nFinalSave;}\n\n  // Are beam particles resolved, with pdf's? Are they diffractive?\n  bool   isResolved()         const {return isRes;}\n  bool   isDiffractiveA()     const {return isDiffA;}\n  bool   isDiffractiveB()     const {return isDiffB;}\n  bool   isDiffractiveC()     const {return isDiffC;}\n  bool   isNonDiffractive()   const {return isND;}\n  bool   isElastic()          const {return (codeSave == 102);}\n  // Retained for backwards compatibility.\n  bool   isMinBias()          const {return isND;}\n\n  // Information for Les Houches Accord and reading files.\n  bool   isLHA()              const {return isLH;}\n  bool   atEndOfFile()        const {return atEOF;}\n\n  // For nondiffractive and Les Houches Accord identify hardest subprocess.\n  bool   hasSub(int i = 0)    const {return hasSubSave[i];}\n  string nameSub(int i = 0)   const {return nameSubSave[i];}\n  int    codeSub(int i = 0)   const {return codeSubSave[i];}\n  int    nFinalSub(int i = 0) const {return nFinalSubSave[i];}\n\n  // Incoming parton flavours and x values.\n  int    id1(int i = 0)       const {return id1Save[i];}\n  int    id2(int i = 0)       const {return id2Save[i];}\n  double x1(int i = 0)        const {return x1Save[i];}\n  double x2(int i = 0)        const {return x2Save[i];}\n  double y(int i = 0)         const {return 0.5 * log( x1Save[i] / x2Save[i]);}\n  double tau(int i = 0)       const {return x1Save[i] * x2Save[i];}\n\n  // Hard process flavours, x values, parton densities, couplings, Q2 scales.\n  int    id1pdf(int i = 0)    const {return id1pdfSave[i];}\n  int    id2pdf(int i = 0)    const {return id2pdfSave[i];}\n  double x1pdf(int i = 0)     const {return x1pdfSave[i];}\n  double x2pdf(int i = 0)     const {return x2pdfSave[i];}\n  double pdf1(int i = 0)      const {return pdf1Save[i];}\n  double pdf2(int i = 0)      const {return pdf2Save[i];}\n  double QFac(int i = 0)      const {return sqrtpos(Q2FacSave[i]);}\n  double Q2Fac(int i = 0)     const {return Q2FacSave[i];}\n  bool   isValence1()         const {return isVal1;}\n  bool   isValence2()         const {return isVal2;}\n  double alphaS(int i = 0)    const {return alphaSSave[i];}\n  double alphaEM(int i = 0)   const {return alphaEMSave[i];}\n  double QRen(int i = 0)      const {return sqrtpos(Q2RenSave[i]);}\n  double Q2Ren(int i = 0)     const {return Q2RenSave[i];}\n  double scalup(int i = 0)    const {return scalupSave[i];}\n\n  // Kinematics of photons from lepton beams.\n  double xGammaA()            const {return x1GammaSave;}\n  double xGammaB()            const {return x2GammaSave;}\n  double Q2GammaA()           const {return Q2Gamma1Save;}\n  double Q2GammaB()           const {return Q2Gamma2Save;}\n  double eCMsub()             const {return eCMsubSave;}\n  double thetaScatLepA()      const {return thetaLepton1;}\n  double thetaScatLepB()      const {return thetaLepton2;}\n  double sHatNew()            const {return sHatNewSave;}\n  int    photonMode()         const {return gammaModeEvent;}\n\n  // Information on VMD state inside a photon.\n  bool   isVMDstateA()        const {return isVMDstateAEvent;}\n  bool   isVMDstateB()        const {return isVMDstateBEvent;}\n  int    idVMDA()             const {return idVMDASave;}\n  int    idVMDB()             const {return idVMDBSave;}\n  double mVMDA()              const {return mVMDASave;}\n  double mVMDB()              const {return mVMDBSave;}\n  double scaleVMDA()          const {return scaleVMDASave;}\n  double scaleVMDB()          const {return scaleVMDBSave;}\n\n  // Mandelstam variables (notation as if subcollision).\n  double mHat(int i = 0)      const {return sqrt(sH[i]);}\n  double sHat(int i = 0)      const {return sH[i];}\n  double tHat(int i = 0)      const {return tH[i];}\n  double uHat(int i = 0)      const {return uH[i];}\n  double pTHat(int i = 0)     const {return pTH[i];}\n  double pT2Hat(int i = 0)    const {return pTH[i] * pTH[i];}\n  double m3Hat(int i = 0)     const {return m3H[i];}\n  double m4Hat(int i = 0)     const {return m4H[i];}\n  double thetaHat(int i = 0)  const {return thetaH[i];}\n  double phiHat(int i = 0)    const {return phiH[i];}\n\n  // Weight of current event; normally 1, but used for Les Houches events\n  // or when reweighting phase space selection. Conversion from mb to pb\n  // for LHA strategy +-4. Uncertainty variations can be accessed by\n  // providing an index >= 1 (0 = no variations). Also cumulative sum.\n  double weight(int i = 0)    const;\n  double weightSum()          const;\n  double lhaStrategy()        const {return lhaStrategySave;}\n\n  // Further access to uncertainty weights: number and labels\n  int nWeights() const { return weightSave.size(); }\n  string weightLabel(int iWeight) const {\n    if (iWeight >= 0 && iWeight < (int)weightLabelSave.size())\n      return weightLabelSave[iWeight];\n    else return \"\";}\n\n  void   initUncertainties(vector<string>*, bool = false);\n  int    nVariationGroups() const { return externalVariationsSize; }\n  string getGroupName(int iGN) const {\n    string tmpString(\"Null\");\n    if( iGN < 0 || iGN >= externalVariationsSize ) return tmpString;\n    return externalGroupNames[iGN];\n  }\n  double getGroupWeight(int iGW) const {\n    double tempWeight(1.0);\n    if( iGW < 0 || iGW >= externalVariationsSize ) return tempWeight;\n    for( vector<int>::const_iterator cit = externalMap[iGW].begin();\n      cit < externalMap[iGW].end(); ++cit ) tempWeight *= weightSave[*cit];\n    return tempWeight;\n  }\n  string getInitialName(int iG) const { return initialNameSave[iG]; }\n  // Variations that must be known by TimeShower and Spaceshower\n  map<int,double> varPDFplus, varPDFminus, varPDFmember;\n\n  // Number of times other steps have been carried out.\n  int    nISR()               const {return nISRSave;}\n  int    nFSRinProc()         const {return nFSRinProcSave;}\n  int    nFSRinRes()          const {return nFSRinResSave;}\n\n  // Maximum pT scales for MPI, ISR and FSR (in hard process).\n  double pTmaxMPI()           const {return pTmaxMPISave;}\n  double pTmaxISR()           const {return pTmaxISRSave;}\n  double pTmaxFSR()           const {return pTmaxFSRSave;}\n\n  // Current evolution scale (for UserHooks).\n  double pTnow()              const {return pTnowSave;}\n\n  // Impact parameter picture, global information\n  double a0MPI()              const {return a0MPISave;}\n\n  // Impact parameter picture, as set by hardest interaction.\n  double bMPI()               const {return (bIsSet) ? bMPISave : 1.;}\n  double enhanceMPI()         const {return (bIsSet) ? enhanceMPISave : 1.;}\n  double enhanceMPIavg()      const {return (bIsSet) ? enhanceMPIavgSave : 1.;}\n  double eMPI(int i)          const {return (bIsSet) ? eMPISave[i] : 1.;}\n  double bMPIold()            const {return (bIsSet) ? bMPIoldSave : 1.;}\n  double enhanceMPIold()      const {return (bIsSet) ? enhanceMPIoldSave : 1.;}\n  double enhanceMPIoldavg()   const {return (bIsSet)\n                                     ? enhanceMPIoldavgSave : 1.;}\n\n  // Number of multiparton interactions, with code and pT for them.\n  int    nMPI()               const {return nMPISave;}\n  int    codeMPI(int i)       const {return codeMPISave[i];}\n  double pTMPI(int i)         const {return pTMPISave[i];}\n  int    iAMPI(int i)         const {return iAMPISave[i];}\n  int    iBMPI(int i)         const {return iBMPISave[i];}\n\n  // Cross section estimate, optionally process by process.\n  vector<int> codesHard();\n  string nameProc(int i = 0)  const {return (i == 0) ? \"sum\"\n    : ( (procNameM.at(i) == \"\") ? \"unknown process\" : procNameM.at(i) );}\n  long   nTried(int i = 0)    const {return (i == 0) ? nTry : nTryM.at(i);}\n  long   nSelected(int i = 0) const {return (i == 0) ? nSel : nSelM.at(i);}\n  long   nAccepted(int i = 0) const {return (i == 0) ? nAcc : nAccM.at(i);}\n  double sigmaGen(int i = 0)  const {return (i == 0) ? sigGen : sigGenM.at(i);}\n  double sigmaErr(int i = 0)  const {return (i == 0) ? sigErr : sigErrM.at(i);}\n\n  // Counters for number of loops in various places.\n  int    getCounter( int i)   const {return counters[i];}\n\n  // Set or increase the value stored in a counter.\n  void   setCounter( int i, int value = 0) {counters[i]  = value;}\n  void   addCounter( int i, int value = 1) {counters[i] += value;}\n\n  // Reset to empty map of error messages.\n  void   errorReset() {messages.clear();}\n\n  // Print a message the first few times. Insert in database.\n  void   errorMsg(string messageIn, string extraIn = \" \",\n    bool showAlways = false);\n\n  // Provide total number of errors/aborts/warnings experienced to date.\n  int    errorTotalNumber() const;\n\n  // Print statistics on errors/aborts/warnings.\n  void   errorStatistics() const;\n\n  // Set initialization warning flag when too low pTmin in ISR/FSR/MPI.\n  void   setTooLowPTmin(bool lowPTminIn) {lowPTmin = lowPTminIn;}\n\n  // Set info on valence character of hard collision partons.\n  void setValence( bool isVal1In, bool isVal2In) {isVal1 = isVal1In;\n    isVal2 = isVal2In;}\n\n  // Set and get some MPI/ISR/FSR properties needed for matching,\n  // i.e. mainly of internal relevance.\n  void   hasHistory( bool hasHistoryIn) {hasHistorySave = hasHistoryIn;}\n  bool   hasHistory() {return hasHistorySave;}\n  void   zNowISR( double zNowIn) {zNowISRSave = zNowIn;}\n  double zNowISR() {return zNowISRSave;}\n  void   pT2NowISR( double pT2NowIn) {pT2NowISRSave = pT2NowIn;}\n  double pT2NowISR() {return pT2NowISRSave;}\n\n  // Update a particular event weight, first entry by default.\n  void updateWeight( double weightIn, int i = 0) { weightSave[i] = weightIn;}\n\n  // Return CKKW-L weight.\n  double getWeightCKKWL() const { return weightCKKWLSave;}\n  // Set CKKW-L weight.\n  void setWeightCKKWL( double weightIn) { weightCKKWLSave = weightIn;}\n  // Return merging weight.\n  double mergingWeight() const { return weightCKKWLSave;}\n\n  // Return the complete NLO weight.\n  double mergingWeightNLO() const {\n    return (weightCKKWLSave - weightFIRSTSave); }\n  // Return the O(\\alpha_s)-term of the CKKW-L weight.\n  double getWeightFIRST() const { return weightFIRSTSave;}\n  // Set the O(\\alpha_s)-term of the CKKW-L weight.\n  void setWeightFIRST( double weightIn) { weightFIRSTSave = weightIn;}\n\n  // Return an LHEF header\n  string header(const string &key) const {\n    if (headers.find(key) == headers.end()) return \"\";\n    else return headers.at(key);\n  }\n\n  // Return a list of all header key names\n  vector<string> headerKeys() const;\n\n  // Return the number of processes in the LHEF.\n  int nProcessesLHEF() const { return int(sigmaLHEFSave.size());}\n  // Return the cross section information read from LHEF.\n  double sigmaLHEF(int iProcess) const { return sigmaLHEFSave[iProcess];}\n\n  // LHEF3 information: Public for easy access.\n  int LHEFversionSave;\n\n  // Save process information as read from init block of LHEF.\n  vector<double> sigmaLHEFSave;\n\n  // Contents of the LHAinitrwgt tag\n  LHAinitrwgt *initrwgt{};\n\n  // Contents of the LHAgenerator tags.\n  vector<LHAgenerator > *generators{};\n\n  // A map of the LHAweightgroup tags, indexed by name.\n  map<string,LHAweightgroup > *weightgroups{};\n\n  // A map of the LHAweight tags, indexed by name.\n  map<string,LHAweight > *init_weights{};\n\n  // Store current-event Les Houches event tags.\n  bool hasOwnEventAttributes;\n  map<string, string > *eventAttributes{};\n\n  // The weights associated with this event, as given by the LHAwgt tags\n  map<string,double > *weights_detailed{};\n\n  // The weights associated with this event, as given by the LHAweights tags\n  vector<double > *weights_compressed{};\n\n  // Contents of the LHAscales tag.\n  LHAscales *scales{};\n\n  // Contents of the LHAweights tag (compressed format)\n  LHAweights *weights{};\n\n  // Contents of the LHArwgt tag (detailed format)\n  LHArwgt *rwgt{};\n\n  // Vectorized version of LHArwgt tag, for easy and ordered access.\n  vector<double> weights_detailed_vector;\n\n  // Value of the unit event weight read from a Les Houches event, necessary\n  // if additional weights in an otherwise unweighted input file are in\n  // relation to this number.\n  double eventWeightLHEF = {};\n\n  // Set the LHEF3 objects read from the init and header blocks.\n  void setLHEF3InitInfo();\n  void setLHEF3InitInfo( int LHEFversionIn, LHAinitrwgt *initrwgtIn,\n    vector<LHAgenerator> *generatorsIn,\n    map<string,LHAweightgroup> *weightgroupsIn,\n    map<string,LHAweight> *init_weightsIn, string headerBlockIn );\n  // Set the LHEF3 objects read from the event block.\n  void setLHEF3EventInfo();\n  void setLHEF3EventInfo( map<string, string> *eventAttributesIn,\n    map<string, double > *weights_detailedIn,\n    vector<double > *weights_compressedIn,\n    LHAscales *scalesIn, LHAweights *weightsIn,\n    LHArwgt *rwgtIn, vector<double> weights_detailed_vecIn,\n    string eventCommentsIn, double eventWeightLHEFIn );\n\n  // Retrieve events tag information.\n  string getEventAttribute(string key, bool doRemoveWhitespace = false) const;\n\n  // Externally set event tag auxiliary information.\n  void setEventAttribute(string key, string value, bool doOverwrite = true) {\n    if (eventAttributes == NULL) {\n      eventAttributes = new map<string,string>();\n      hasOwnEventAttributes = true;\n    }\n    map<string, string>::iterator it = eventAttributes->find(key);\n    if ( it != eventAttributes->end() && !doOverwrite ) return;\n    if ( it != eventAttributes->end() ) eventAttributes->erase(it);\n    eventAttributes->insert(make_pair(key,value));\n  }\n\n  // Retrieve LHEF version\n  int LHEFversion() const { return LHEFversionSave; }\n\n  // Retrieve initrwgt tag information.\n  unsigned int getInitrwgtSize() const;\n\n  // Retrieve generator tag information.\n  unsigned int getGeneratorSize() const;\n  string getGeneratorValue(unsigned int n = 0) const;\n  string getGeneratorAttribute( unsigned int n, string key,\n    bool doRemoveWhitespace = false) const;\n\n  // Retrieve rwgt tag information.\n  unsigned int getWeightsDetailedSize() const;\n  double getWeightsDetailedValue(string n) const;\n  string getWeightsDetailedAttribute(string n, string key,\n    bool doRemoveWhitespace = false) const;\n\n  // Retrieve weights tag information.\n  unsigned int getWeightsCompressedSize() const;\n  double getWeightsCompressedValue(unsigned int n) const;\n  string getWeightsCompressedAttribute(string key,\n    bool doRemoveWhitespace = false) const;\n\n  // Retrieve scales tag information.\n  string getScalesValue(bool doRemoveWhitespace = false) const;\n  double getScalesAttribute(string key) const;\n\n  // Retrieve complete header block and event comments\n  // Retrieve scales tag information.\n  string getHeaderBlock() const { return headerBlock;}\n  string getEventComments() const { return eventComments;}\n\n  // Set LHEF headers\n  void setHeader(const string &key, const string &val)\n    { headers[key] = val; }\n\n  // Set abort in parton level.\n  void setAbortPartonLevel(bool abortIn) {abortPartonLevel = abortIn;}\n  bool getAbortPartonLevel() const {return abortPartonLevel;}\n\n  // Get information on hard diffractive events.\n  bool   hasUnresolvedBeams() const {return hasUnresBeams;}\n  bool   hasPomPsystem()      const {return hasPomPsys;}\n  bool   isHardDiffractive()  const {return isHardDiffA || isHardDiffB;}\n  bool   isHardDiffractiveA() const {return isHardDiffA;}\n  bool   isHardDiffractiveB() const {return isHardDiffB;}\n  double xPomeronA()          const {return xPomA;}\n  double xPomeronB()          const {return xPomB;}\n  double tPomeronA()          const {return tPomA;}\n  double tPomeronB()          const {return tPomB;}\n\n  // History information needed to setup the weak shower for 2 -> n.\n  vector<int> getWeakModes() const {return weakModes;}\n  vector<pair<int,int> > getWeakDipoles() const {return weakDipoles;}\n  vector<Vec4> getWeakMomenta() const {return weakMomenta;}\n  vector<int> getWeak2to2lines() const {return weak2to2lines;}\n  void setWeakModes(vector<int> weakModesIn) {weakModes = weakModesIn;}\n  void setWeakDipoles(vector<pair<int,int> > weakDipolesIn)\n    {weakDipoles = weakDipolesIn;}\n  void setWeakMomenta(vector<Vec4> weakMomentaIn)\n    {weakMomenta = weakMomentaIn;}\n  void setWeak2to2lines(vector<int> weak2to2linesIn)\n    {weak2to2lines = weak2to2linesIn;}\n\n  // From here on what used to be the private part of the class.\n\n  // Number of times the same error message is repeated, unless overridden.\n  static const int TIMESTOPRINT;\n\n  // Allow conversion from mb to pb.\n  static const double CONVERTMB2PB;\n\n  // Store common beam quantities.\n  int    idASave{}, idBSave{};\n  double pzASave{}, eASave{}, mASave{}, pzBSave{},  eBSave{}, mBSave{},\n         eCMSave{}, sSave{};\n\n  // Store initialization information.\n  bool   lowPTmin;\n\n  // Store common integrated cross section quantities.\n  long   nTry{}, nSel{}, nAcc{};\n  double sigGen{}, sigErr{}, wtAccSum{};\n  map<int, string> procNameM;\n  map<int, long> nTryM, nSelM, nAccM;\n  map<int, double> sigGenM, sigErrM;\n  int    lhaStrategySave{};\n\n  // Store common MPI information.\n  double a0MPISave;\n\n  // Store current-event quantities.\n  bool   isRes{}, isDiffA{}, isDiffB{}, isDiffC{}, isND{}, isLH{},\n         hasSubSave[4], bIsSet{}, evolIsSet{}, atEOF{}, isVal1{}, isVal2{},\n         hasHistorySave{}, abortPartonLevel{}, isHardDiffA{}, isHardDiffB{},\n         hasUnresBeams{}, hasPomPsys{};\n  int    codeSave{}, codeSubSave[4], nFinalSave{}, nFinalSubSave[4], nTotal{},\n         id1Save[4], id2Save[4], id1pdfSave[4], id2pdfSave[4], nMPISave{},\n         nISRSave{}, nFSRinProcSave{}, nFSRinResSave{};\n  double x1Save[4], x2Save[4], x1pdfSave[4], x2pdfSave[4], pdf1Save[4],\n         pdf2Save[4], Q2FacSave[4], alphaEMSave[4], alphaSSave[4],\n         Q2RenSave[4], scalupSave[4], sH[4], tH[4], uH[4], pTH[4], m3H[4],\n         m4H[4], thetaH[4], phiH[4], bMPISave{}, enhanceMPISave{},\n         enhanceMPIavgSave{}, bMPIoldSave{}, enhanceMPIoldSave{},\n         enhanceMPIoldavgSave{}, pTmaxMPISave{}, pTmaxISRSave{},\n         pTmaxFSRSave{}, pTnowSave{}, zNowISRSave{}, pT2NowISRSave{}, xPomA{},\n         xPomB{}, tPomA{}, tPomB{};\n  string nameSave{}, nameSubSave[4];\n  vector<int>    codeMPISave, iAMPISave, iBMPISave;\n  vector<double> pTMPISave, eMPISave, weightSave;\n  vector<string> weightLabelSave;\n  vector<string>          externalVariations;\n  vector<vector<string> > externalVarNames;\n  vector<string>          externalGroupNames;\n  vector<string>          initialNameSave;\n  vector<vector<int> >    externalMap;\n  int                     externalVariationsSize{};\n\n  // Variables related to photon kinematics.\n  bool   isVMDstateAEvent{}, isVMDstateBEvent{};\n  int    gammaModeEvent{}, idVMDASave{}, idVMDBSave{};\n  double x1GammaSave{}, x2GammaSave{}, Q2Gamma1Save{}, Q2Gamma2Save{},\n         eCMsubSave{}, thetaLepton1{}, thetaLepton2{}, sHatNewSave{},\n         mVMDASave{}, mVMDBSave{}, scaleVMDASave{}, scaleVMDBSave{};\n\n  // Vector of various loop counters.\n  int    counters[50];\n\n  // Map for all error messages.\n  map<string, int> messages;\n\n  // Map for LHEF headers.\n  map<string, string> headers;\n\n  // Strings for complete header block and event comments.\n  string headerBlock{}, eventComments{};\n\n  // Map for plugin libraries.\n  map<string, void*> plugins;\n\n  // Load a plugin library.\n  void* loadPlugin(string nameIn) {\n      void *lib;\n      map<string, void*>::iterator plugin = plugins.find(nameIn);\n      if (plugin == plugins.end()) {\n        lib = dlopen(nameIn.c_str(), RTLD_LAZY);\n        const char* cerror = dlerror();\n        string serror(cerror == nullptr ? \"\" : cerror);\n        dlerror();\n        if (serror.size()) {\n          errorMsg(\"Error in Info::loadPlugin: \" + serror); return nullptr;}\n        plugins[nameIn] = lib;\n      } else lib = plugin->second;\n      return lib;\n  };\n\n  // Set info on the two incoming beams: only from Pythia class.\n  void setBeamA( int idAin, double pzAin, double eAin, double mAin) {\n    idASave = idAin; pzASave = pzAin; eASave = eAin; mASave = mAin;}\n  void setBeamB( int idBin, double pzBin, double eBin, double mBin) {\n    idBSave = idBin; pzBSave = pzBin; eBSave = eBin; mBSave = mBin;}\n  void setECM( double eCMin) {eCMSave = eCMin; sSave = eCMSave * eCMSave;}\n\n  // Set info related to gamma+gamma subcollision.\n  void setX1Gamma( double x1GammaIn)     { x1GammaSave    = x1GammaIn;   }\n  void setX2Gamma( double x2GammaIn)     { x2GammaSave    = x2GammaIn;   }\n  void setQ2Gamma1( double Q2gammaIn)    { Q2Gamma1Save   = Q2gammaIn;   }\n  void setQ2Gamma2( double Q2gammaIn)    { Q2Gamma2Save   = Q2gammaIn;   }\n  void setTheta1( double theta1In)       { thetaLepton1   = theta1In;    }\n  void setTheta2( double theta2In)       { thetaLepton2   = theta2In;    }\n  void setECMsub( double eCMsubIn)       { eCMsubSave     = eCMsubIn;    }\n  void setsHatNew( double sHatNewIn)     { sHatNewSave    = sHatNewIn;   }\n  void setGammaMode( double gammaModeIn) { gammaModeEvent = gammaModeIn; }\n  // Set info on VMD state.\n  void setVMDstateA(bool isVMDAIn, int idAIn, double mAIn, double scaleAIn)\n    {isVMDstateAEvent = isVMDAIn; idVMDASave = idAIn; mVMDASave = mAIn;\n    scaleVMDASave = scaleAIn;}\n  void setVMDstateB(bool isVMDBIn, int idBIn, double mBIn, double scaleBIn)\n    {isVMDstateBEvent = isVMDBIn; idVMDBSave = idBIn; mVMDBSave = mBIn;\n    scaleVMDBSave = scaleBIn;}\n\n  // Reset info for current event: only from Pythia class.\n  void clear() {\n    isRes = isDiffA = isDiffB = isDiffC = isND = isLH = bIsSet\n      = evolIsSet = atEOF = isVal1 = isVal2 = hasHistorySave\n      = isHardDiffA = isHardDiffB = hasUnresBeams = hasPomPsys = false;\n    codeSave = nFinalSave = nTotal = nMPISave = nISRSave = nFSRinProcSave\n      = nFSRinResSave = 0;\n    bMPISave = enhanceMPISave = enhanceMPIavgSave = bMPIoldSave\n      = enhanceMPIoldSave = enhanceMPIoldavgSave = weightCKKWLSave = 1.;\n    pTmaxMPISave = pTmaxISRSave = pTmaxFSRSave = pTnowSave = zNowISRSave\n      = pT2NowISRSave = weightFIRSTSave = 0.;\n    nameSave = \" \";\n    for (int i = 0; i < 4; ++i) {\n      hasSubSave[i] = false;\n      codeSubSave[i] = nFinalSubSave[i] = id1pdfSave[i] = id2pdfSave[i]\n        = id1Save[i] = id2Save[i] = 0;\n      x1pdfSave[i] = x2pdfSave[i] = pdf1Save[i] = pdf2Save[i]\n        = Q2FacSave[i] = alphaEMSave[i] = alphaSSave[i] = Q2RenSave[i]\n        = scalupSave[i] = x1Save[i] = x2Save[i] = sH[i] = tH[i] = uH[i]\n        = pTH[i] = m3H[i] = m4H[i] = thetaH[i] = phiH[i] = 0.;\n      nameSubSave[i] = \" \";\n    }\n    codeMPISave.resize(0); iAMPISave.resize(0); iBMPISave.resize(0);\n    pTMPISave.resize(0); eMPISave.resize(0); setHardDiff();\n    for (int i = 0; i < nWeights(); ++i) weightSave[i]=1.;}\n\n  // Reset info arrays only for parton and hadron level.\n  int sizeMPIarrays() const { return codeMPISave.size(); }\n  void resizeMPIarrays(int newSize) { codeMPISave.resize(newSize);\n    iAMPISave.resize(newSize); iBMPISave.resize(newSize);\n    pTMPISave.resize(newSize); eMPISave.resize(newSize); }\n\n  // Set info on the (sub)process: from ProcessLevel, ProcessContainer or\n  // MultipartonInteractions classes.\n  void setType( string nameIn, int codeIn, int nFinalIn,\n    bool isNonDiffIn = false, bool isResolvedIn = true,\n    bool isDiffractiveAin = false, bool isDiffractiveBin = false,\n    bool isDiffractiveCin = false, bool isLHAin = false) {\n    nameSave = nameIn; codeSave = codeIn; nFinalSave = nFinalIn;\n    isND = isNonDiffIn; isRes = isResolvedIn; isDiffA = isDiffractiveAin;\n    isDiffB = isDiffractiveBin; isDiffC = isDiffractiveCin; isLH = isLHAin;\n    nTotal = 2 + nFinalSave; bIsSet = false; hasSubSave[0] = false;\n    nameSubSave[0] = \" \"; codeSubSave[0] = 0; nFinalSubSave[0] = 0;\n    evolIsSet = false;}\n  void setSubType( int iDS, string nameSubIn, int codeSubIn,\n    int nFinalSubIn) { hasSubSave[iDS] = true; nameSubSave[iDS] = nameSubIn;\n    codeSubSave[iDS] = codeSubIn; nFinalSubSave[iDS] = nFinalSubIn;}\n  void setPDFalpha( int iDS, int id1pdfIn, int id2pdfIn, double x1pdfIn,\n    double x2pdfIn, double pdf1In, double pdf2In, double Q2FacIn,\n    double alphaEMIn, double alphaSIn, double Q2RenIn, double scalupIn) {\n    id1pdfSave[iDS] = id1pdfIn; id2pdfSave[iDS] = id2pdfIn;\n    x1pdfSave[iDS] = x1pdfIn; x2pdfSave[iDS] = x2pdfIn;\n    pdf1Save[iDS] = pdf1In; pdf2Save[iDS] = pdf2In; Q2FacSave[iDS] = Q2FacIn;\n    alphaEMSave[iDS] = alphaEMIn; alphaSSave[iDS] = alphaSIn;\n    Q2RenSave[iDS] = Q2RenIn; scalupSave[iDS] = scalupIn;}\n  void setScalup( int iDS, double scalupIn) {scalupSave[iDS] = scalupIn;}\n  void setKin( int iDS, int id1In, int id2In, double x1In, double x2In,\n    double sHatIn, double tHatIn, double uHatIn, double pTHatIn,\n    double m3HatIn, double m4HatIn, double thetaHatIn, double phiHatIn) {\n    id1Save[iDS] = id1In; id2Save[iDS] = id2In; x1Save[iDS] = x1In;\n    x2Save[iDS] = x2In; sH[iDS] = sHatIn; tH[iDS] = tHatIn;\n    uH[iDS] = uHatIn; pTH[iDS] = pTHatIn; m3H[iDS] = m3HatIn;\n    m4H[iDS] = m4HatIn; thetaH[iDS] = thetaHatIn; phiH[iDS] = phiHatIn;}\n  void setTypeMPI( int codeMPIIn, double pTMPIIn, int iAMPIIn = 0,\n    int iBMPIIn = 0, double eMPIIn = 1.) {codeMPISave.push_back(codeMPIIn);\n    pTMPISave.push_back(pTMPIIn); iAMPISave.push_back(iAMPIIn);\n    iBMPISave.push_back(iBMPIIn); eMPISave.push_back(eMPIIn); }\n\n  // Set info on cross section: from ProcessLevel (reset in Pythia).\n  void sigmaReset() { nTry = nSel = nAcc = 0; sigGen = sigErr = wtAccSum = 0.;\n    procNameM.clear(); nTryM.clear(); nSelM.clear(); nAccM.clear();\n    sigGenM.clear(); sigErrM.clear();}\n  void setSigma( int i, string procNameIn, long nTryIn, long nSelIn,\n    long nAccIn, double sigGenIn, double sigErrIn, double wtAccSumIn) {\n    if (i == 0) {nTry = nTryIn; nSel = nSelIn; nAcc = nAccIn;\n      sigGen = sigGenIn; sigErr = sigErrIn; wtAccSum = wtAccSumIn;}\n    else {procNameM[i] = procNameIn; nTryM[i] = nTryIn; nSelM[i] = nSelIn;\n      nAccM[i] = nAccIn; sigGenM[i] = sigGenIn; sigErrM[i] = sigErrIn;} }\n  void addSigma( int i, long nTryIn, long nSelIn, long nAccIn, double sigGenIn,\n    double sigErrIn) { nTryM[i] += nTryIn; nSelM[i] += nSelIn;\n    nAccM[i] += nAccIn; sigGenM[i] += sigGenIn;\n    sigErrM[i] = sqrtpos(sigErrM[i]*sigErrM[i] + sigErrIn*sigErrIn); }\n\n  // Set info on impact parameter: from PartonLevel.\n  void setImpact( double bMPIIn, double enhanceMPIIn, double enhanceMPIavgIn,\n    bool bIsSetIn = true, bool pushBack = false) {\n    if (pushBack) {bMPIoldSave = bMPISave; enhanceMPIoldSave = enhanceMPISave;\n      enhanceMPIoldavgSave = enhanceMPIavgSave;}\n    bMPISave = bMPIIn; enhanceMPISave = eMPISave[0] = enhanceMPIIn,\n    enhanceMPIavgSave = enhanceMPIavgIn, bIsSet = bIsSetIn;}\n\n  // Set info on pTmax scales and number of evolution steps: from PartonLevel.\n  void setPartEvolved( int nMPIIn, int nISRIn) {\n    nMPISave = nMPIIn; nISRSave = nISRIn;}\n  void setEvolution( double pTmaxMPIIn, double pTmaxISRIn, double pTmaxFSRIn,\n    int nMPIIn, int nISRIn, int nFSRinProcIn, int nFSRinResIn) {\n    pTmaxMPISave = pTmaxMPIIn; pTmaxISRSave = pTmaxISRIn;\n    pTmaxFSRSave = pTmaxFSRIn; nMPISave = nMPIIn; nISRSave = nISRIn;\n    nFSRinProcSave = nFSRinProcIn; nFSRinResSave = nFSRinResIn;\n    evolIsSet = true;}\n\n  // Set current pT evolution scale for MPI/ISR/FSR; from PartonLevel.\n  void setPTnow( double pTnowIn) {pTnowSave = pTnowIn;}\n\n  // Set a0 from MultipartonInteractions.\n  void seta0MPI(double a0MPIin) {a0MPISave = a0MPIin;}\n\n  // Set info whether reading of Les Houches Accord file at end.\n  void setEndOfFile( bool atEOFin) {atEOF = atEOFin;}\n\n  // Set number and labels of weights (for uncertainty evaluations).\n  void setNWeights(int mWeights) {\n    mWeights = max(1,mWeights);\n    int lWeights = weightSave.size();\n    weightSave.resize(mWeights);\n    weightLabelSave.resize(mWeights);\n    for (int i=lWeights; i<mWeights; ++i) weightLabelSave[i]=\"\";\n  }\n  void setWeightLabel(int iWeight, string labelIn) {\n    if (iWeight >= 0 && iWeight < (int)weightLabelSave.size())\n      weightLabelSave[iWeight] = labelIn;\n  }\n\n  // Set event weight, either for LHEF3 or for uncertainty bands.\n  void setWeight( double weightIn, int lhaStrategyIn) {\n    for (int i = 0; i < nWeights(); ++i) weightSave[i] = weightIn;\n    if (nWeights() == 0) weightSave.push_back(weightIn);\n    lhaStrategySave = lhaStrategyIn;}\n\n  // Apply weight modification (used for automated uncertainty variations).\n  void reWeight( int iWeight, double rwIn) {\n    if (iWeight >= 0 || iWeight < nWeights()) weightSave[iWeight] *= rwIn;}\n\n  // Save merging weight (i.e. CKKW-L-type weight, summed O(\\alpha_s) weight).\n  double weightCKKWLSave{}, weightFIRSTSave{};\n\n  // Set info on resolved processes.\n  void setIsResolved(bool isResIn) {isRes = isResIn;}\n\n  // Set info on hard diffraction.\n  void setHardDiff( bool hasUnresBeamsIn = false, bool hasPomPsysIn = false,\n    bool isHardDiffAIn = false, bool isHardDiffBIn = false,\n    double xPomAIn = 0., double xPomBIn = 0., double tPomAIn = 0.,\n    double tPomBIn = 0.) { hasUnresBeams = hasUnresBeamsIn;\n    hasPomPsys = hasPomPsysIn; isHardDiffA = isHardDiffAIn;\n    isHardDiffB = isHardDiffBIn;\n    xPomA = xPomAIn; xPomB = xPomBIn;\n    tPomA = tPomAIn; tPomB = tPomBIn;}\n\n  // Set information in hard diffractive events.\n  void setHasUnresolvedBeams(bool hasUnresBeamsIn)\n    {hasUnresBeams = hasUnresBeamsIn;}\n  void setHasPomPsystem(bool hasPomPsysIn) {hasPomPsys = hasPomPsysIn;}\n\n  // Variables for weak shower setup.\n  vector<int> weakModes, weak2to2lines;\n  vector<Vec4> weakMomenta;\n  vector<pair<int, int> > weakDipoles;\n\n};\n\n//==========================================================================\n\n} // end namespace Pythia8\n\n#endif // Pythia8_Info_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/plugins/python/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (tstate))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 3\n\n#if defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)       { e.restore();   return;\n                } catch (const builtin_exception &e) { e.set_error(); return;\n                }\n            }\n        );\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)           { e.restore();                                    return;\n                } catch (const builtin_exception &e)     { e.set_error();                                  return;\n                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n                } catch (...) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n                    return;\n                }\n            }\n        );\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/htmldoc/vincia-kins.png",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/htmldoc/pythia99.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/htmldoc/dot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/htmldoc/pythia32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/pdfdoc/evtgen.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/pdfdoc/worksheet8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/pdfdoc/pythia8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/pdfdoc/pdfwarning.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/share/Pythia8/pdfdoc/g2qqbarsplit.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/zProduction_UnlopsLoop_01.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/ttbar.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/zProduction_UnlopsTree_12.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/zProduction_Ckkwl_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/zProduction_Mlm_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8301-qggalsdmdsxvb6p35t37f53ov6sg3qtr/spack-src/examples/zProduction_Fxfx_01.lhe.gz"
    ],
    "total_files": 826
}