{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/src/Info.cc": "// Info.cc is a part of the PYTHIA event generator.\n// Copyright (C) 2020 Torbjorn Sjostrand.\n// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.\n// Please respect the MCnet Guidelines, see GUIDELINES for details.\n\n// Function definitions (not found in the header) for the Info class.\n\n#include \"Pythia8/Info.h\"\n#include <limits>\n\nnamespace Pythia8 {\n\n//==========================================================================\n\n// Info class.\n// This class contains a mixed bag of information on the event generation\n// activity, especially on the current subprocess properties.\n\n//--------------------------------------------------------------------------\n\n// Constants: could be changed here if desired, but normally should not.\n// These are of technical nature, as described for each.\n\n// Number of times the same error message will be repeated at most.\nconst int Info::TIMESTOPRINT = 1;\n\n// LHA convention with cross section in pb may require conversion from mb.\nconst double Info::CONVERTMB2PB = 1e9;\n\n//--------------------------------------------------------------------------\n\n// List (almost) all information currently set.\n\nvoid Info::list() const {\n\n  // Header and beam info.\n  cout << \"\\n --------  PYTHIA Info Listing  ------------------------\"\n       << \"---------------- \\n \\n\"\n       << scientific << setprecision(3)\n       << \" Beam A: id = \" << setw(6) << idASave << \", pz = \" << setw(10)\n       << pzASave << \", e = \" << setw(10) << eASave << \", m = \" << setw(10)\n       << mASave << \".\\n\"\n       << \" Beam B: id = \" << setw(6) << idBSave << \", pz = \" << setw(10)\n       << pzBSave << \", e = \" << setw(10) << eBSave << \", m = \" << setw(10)\n       << mBSave << \".\\n\\n\";\n\n  // Done if no subprocess has been defined.\n  if (codeSave == 0 && nFinalSave == 0) {\n    cout << \" No process has been set; something must have gone wrong! \\n\"\n         << \"\\n --------  End PYTHIA Info Listing  --------------------\"\n         << \"----------------\" << endl;\n    return;\n  }\n\n  // Colliding parton info.\n  if (isRes) {\n    cout << \" In 1: id = \" << setw(4) << id1pdfSave[0] << \", x = \"\n         << setw(10) << x1pdfSave[0] << \", pdf = \" << setw(10) << pdf1Save[0]\n         << \" at Q2 = \" << setw(10) << Q2FacSave[0] << \".\\n\"\n         << \" In 2: id = \" << setw(4) << id2pdfSave[0] << \", x = \"\n         << setw(10) << x2pdfSave[0] << \", pdf = \" << setw(10) << pdf2Save[0]\n         << \" at same Q2.\\n\";\n    bool matchIdX = true;\n    if (id1pdfSave[0] != id1Save[0] || id2pdfSave[0] != id2Save[0])\n      matchIdX = false;\n    if (abs(x1pdfSave[0] - x1Save[0]) > 1e-4 * x1Save[0]) matchIdX = false;\n    if (abs(x2pdfSave[0] - x2Save[0]) > 1e-4 * x2Save[0]) matchIdX = false;\n    if (!matchIdX) cout << \" Warning: above flavour/x info does not match\"\n         << \" incoming partons in event!\\n\";\n    cout << \"\\n\";\n  }\n\n  // Process name and code.\n  cout << ((isRes && !hasSubSave[0]) ? \" Subprocess \" : \" Process \")\n       << nameSave << \" with code \" << codeSave << \" is 2 -> \"\n       << nFinalSave << \".\\n\";\n\n  // Subprocess name and code for nondiffractive processes.\n  if (hasSubSave[0])\n    cout << \" Subprocess \" << nameSubSave[0] << \" with code \" << codeSubSave[0]\n         << \" is 2 -> \" << nFinalSubSave[0] << \".\\n\";\n\n  // Process-type-specific kinematics information.\n  if ( isRes && nFinalSave == 1)\n    cout << \" It has sHat = \" << setw(10) << sH[0] << \".\\n\";\n  else if ( isRes && nFinalSave == 2)\n    cout << \" It has sHat = \" << setw(10) << sH[0] << \",    tHat = \"\n         << setw(10) << tH[0] << \",    uHat = \" << setw(10) << uH[0] << \",\\n\"\n         << \"       pTHat = \" << setw(10) << pTH[0] << \",   m3Hat = \"\n         << setw(10) << m3H[0] << \",   m4Hat = \" << setw(10) << m4H[0] << \",\\n\"\n         << \"    thetaHat = \" << setw(10) << thetaH[0] << \",  phiHat = \"\n         << setw(10) << phiH[0] << \".\\n\";\n    else if ( nFinalSave == 2)\n    cout << \" It has s = \" << setw(10) << sH[0] << \",    t = \" << setw(10)\n         << tH[0] << \",    u = \" << setw(10) << uH[0] << \",\\n\"\n         << \"       pT = \" << setw(10) << pTH[0] << \",   m3 = \" << setw(10)\n         << m3H[0] << \",   m4 = \" << setw(10) << m4H[0] << \",\\n\"\n         << \"    theta = \" << setw(10) << thetaH[0] << \",  phi = \" << setw(10)\n         << phiH[0] << \".\\n\";\n  else if ( isRes && nFinalSave == 3)\n    cout << \" It has sHat = \" << setw(10) << sH[0] << \", <pTHat> = \"\n         << setw(10) << pTH[0] << \".\\n\";\n  else if ( nFinalSave == 3)\n    cout << \" It has s = \" << setw(10) << sH[0] << \",  t_A = \" << setw(10)\n         << tH[0] << \",  t_B = \" << setw(10) << uH[0] << \",\\n\"\n         << \"     <pT> = \" << setw(10) << pTH[0] << \".\\n\";\n\n  // Couplings.\n  if (isRes) cout << \"     alphaEM = \" << setw(10) << alphaEMSave[0]\n    << \",  alphaS = \" << setw(10) << alphaSSave[0] << \"    at Q2 = \"\n    << setw(10) << Q2RenSave[0] << \".\\n\";\n\n  // Diffractive subsystems.\n  for (int iDS = 1; iDS < 4; ++iDS) if (id1Save[iDS] != 0) {\n    if (iDS == 1) cout << \"\\n Diffractive system on side A: \\n\";\n    if (iDS == 2) cout << \"\\n Diffractive system on side B: \\n\";\n    if (iDS == 3) cout << \"\\n Central diffractive system: \\n\";\n    cout << \" In 1: id = \" << setw(4) << id1pdfSave[iDS] << \", x = \"\n         << setw(10) << x1pdfSave[iDS] << \", pdf = \" << setw(10)\n         << pdf1Save[iDS] << \" at Q2 = \" << setw(10) << Q2FacSave[iDS]\n         << \".\\n\" << \" In 2: id = \" << setw(4) << id2pdfSave[iDS]\n         << \", x = \" << setw(10) << x2pdfSave[iDS] << \", pdf = \"\n         << setw(10) << pdf2Save[iDS] << \" at same Q2.\\n\";\n    cout << \" Subprocess \" << nameSubSave[iDS] << \" with code \"\n         << codeSubSave[iDS] << \" is 2 -> \" << nFinalSubSave[iDS] << \".\\n\";\n    if (nFinalSubSave[iDS] == 1) {\n      cout << \" It has sHat = \" << setw(10) << sH[iDS] << \".\\n\";\n    } else if (nFinalSubSave[iDS] == 2) {\n      cout << \" It has sHat = \" << setw(10) << sH[iDS] << \",    tHat = \"\n           << setw(10) << tH[iDS] << \",    uHat = \" << setw(10) << uH[iDS]\n           << \",\\n\" << \"       pTHat = \" << setw(10) << pTH[iDS]\n           << \",   m3Hat = \" << setw(10) << m3H[iDS] << \",   m4Hat = \"\n           << setw(10) << m4H[iDS] << \",\\n\" << \"    thetaHat = \" << setw(10)\n           << thetaH[iDS] << \",  phiHat = \"  << setw(10) << phiH[iDS] << \".\\n\";\n    }\n    cout << \"     alphaEM = \" << setw(10) << alphaEMSave[iDS]\n         << \",  alphaS = \" << setw(10) << alphaSSave[iDS] << \"    at Q2 = \"\n         << setw(10) << Q2RenSave[iDS] << \".\\n\";\n  }\n\n  // Impact parameter.\n  if (bIsSet) cout << \"\\n Impact parameter b = \" << setw(10) << bMPISave\n    << \" gives enhancement factor = \" << setw(10) << enhanceMPISave\n    << \".\\n\";\n\n  // Multiparton interactions and shower evolution.\n  if (evolIsSet) cout << \" Max pT scale for MPI = \" << setw(10) << pTmaxMPISave\n    << \", ISR = \" << setw(10) << pTmaxISRSave << \", FSR = \" << setw(10)\n    << pTmaxISRSave << \".\\n Number of MPI = \" << setw(5) << nMPISave\n    << \", ISR = \" << setw(5) << nISRSave << \", FSRproc = \" << setw(5)\n    << nFSRinProcSave << \", FSRreson = \" << setw(5) << nFSRinResSave\n    << \".\\n\";\n\n  // Listing finished.\n  cout << \"\\n --------  End PYTHIA Info Listing  --------------------\"\n       << \"----------------\" << endl;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Event weights and accumulated weight.\n\ndouble Info::weight(int iWeight) const {\n  double weightNominal = weightContainerPtr->weightNominal;\n  double wt = (iWeight <= 0 ||\n      iWeight >= int(weightContainerPtr->weightsPS.getWeightsSize()))\n    ? weightNominal :\n      weightContainerPtr->weightsPS.getWeightsValue(iWeight)*weightNominal;\n  return wt;\n}\n\ndouble Info::weightSum() const {\n  return (abs(lhaStrategySave) == 4) ? CONVERTMB2PB * wtAccSum : wtAccSum;\n}\n\n//--------------------------------------------------------------------------\n\n// List of all hard processes switched on.\n\nvector<int> Info::codesHard() {\n  vector<int> codesNow;\n  for (map<int, long>::iterator nTryEntry = nTryM.begin();\n    nTryEntry != nTryM.end(); ++nTryEntry)\n      codesNow.push_back( nTryEntry->first );\n  return codesNow;\n}\n\n//--------------------------------------------------------------------------\n\n// Print a message the first few times. Insert in database.\n\nvoid Info::errorMsg(string messageIn, string extraIn, bool showAlways) {\n\n  // Recover number of times message occured. Also inserts new string.\n  int times = messages[messageIn];\n  ++messages[messageIn];\n\n  // Print message the first few times.\n  if (times < TIMESTOPRINT || showAlways) cout << \" PYTHIA \"\n    << messageIn << \" \" << extraIn << endl;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Provide total number of errors/aborts/warnings experienced to date.\n\nint Info::errorTotalNumber() const {\n\n  int nTot = 0;\n  for (pair<string, int> messageEntry : messages)\n    nTot += messageEntry.second;\n  return nTot;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Print statistics on errors/aborts/warnings.\n\nvoid Info::errorStatistics() const {\n\n  // Header.\n  cout << \"\\n *-------  PYTHIA Error and Warning Messages Statistics  \"\n       << \"----------------------------------------------------------* \\n\"\n       << \" |                                                       \"\n       << \"                                                          | \\n\"\n       << \" |  times   message                                      \"\n       << \"                                                          | \\n\"\n       << \" |                                                       \"\n       << \"                                                          | \\n\";\n\n  // Loop over all messages\n  map<string, int>::const_iterator messageEntry = messages.begin();\n  if (messageEntry == messages.end())\n    cout << \" |      0   no errors or warnings to report              \"\n         << \"                                                          | \\n\";\n  while (messageEntry != messages.end()) {\n    // Message printout.\n    string temp = messageEntry->first;\n    int len = temp.length();\n    temp.insert( len, max(0, 102 - len), ' ');\n    cout << \" | \" << setw(6) << messageEntry->second << \"   \"\n         << temp << \" | \\n\";\n    ++messageEntry;\n  }\n\n  // Done.\n  cout << \" |                                                       \"\n       << \"                                                          | \\n\"\n       << \" *-------  End PYTHIA Error and Warning Messages Statistics\"\n       << \"  ------------------------------------------------------* \"\n       << endl;\n\n}\n\n//--------------------------------------------------------------------------\n\n// Return a list of all header key names\n\nvector<string> Info::headerKeys() const {\n  vector<string> keys;\n  for (pair<string, string> headerEntry : headers)\n    keys.push_back(headerEntry.first);\n  return keys;\n}\n\n//--------------------------------------------------------------------------\n\n// Reset the LHEF3 objects read from the init and header blocks.\n\nvoid Info::setLHEF3InitInfo() {\n  initrwgt     = 0;\n  generators   = 0;\n  weightgroups = 0;\n  init_weights = 0;\n  headerBlock  = \"\";\n}\n\n//--------------------------------------------------------------------------\n\n// Set the LHEF3 objects read from the init and header blocks.\n\nvoid Info::setLHEF3InitInfo( int LHEFversionIn, LHAinitrwgt *initrwgtIn,\n  vector<LHAgenerator> *generatorsIn,\n  map<string,LHAweightgroup> *weightgroupsIn,\n  map<string,LHAweight> *init_weightsIn, string headerBlockIn ) {\n  LHEFversionSave = LHEFversionIn;\n  initrwgt        = initrwgtIn;\n  generators      = generatorsIn;\n  weightgroups    = weightgroupsIn;\n  init_weights    = init_weightsIn;\n  headerBlock     = headerBlockIn;\n  weightContainerPtr->weightsLHEF.\n    identifyVariationsFromLHAinit( init_weightsIn );\n  weightContainerPtr->weightsMerging.setLHEFvariationMapping();\n}\n\n//--------------------------------------------------------------------------\n\n// Reset the LHEF3 objects read from the event block.\n\nvoid Info::setLHEF3EventInfo() {\n  eventAttributes    = 0;\n  weights_detailed   = 0;\n  weights_compressed = 0;\n  scales             = 0;\n  weights            = 0;\n  rwgt               = 0;\n  weights_detailed_vector.resize(0);\n  eventComments      = \"\";\n  eventWeightLHEF    = 1.0;\n  weightContainerPtr->weightsLHEF.clear();\n}\n\n//--------------------------------------------------------------------------\n\n// Set the LHEF3 objects read from the event block.\n\nvoid Info::setLHEF3EventInfo( map<string, string> *eventAttributesIn,\n   map<string,double> *weights_detailedIn,\n   vector<double> *weights_compressedIn,\n   LHAscales *scalesIn, LHAweights *weightsIn,\n   LHArwgt *rwgtIn, vector<double> weights_detailed_vecIn,\n   vector<string> weights_detailed_name_vecIn,\n   string eventCommentsIn, double eventWeightLHEFIn ) {\n   eventAttributes    = eventAttributesIn;\n   weights_detailed   = weights_detailedIn;\n   weights_compressed = weights_compressedIn;\n   scales             = scalesIn;\n   weights            = weightsIn;\n   rwgt               = rwgtIn;\n   weights_detailed_vector = weights_detailed_vecIn;\n   eventComments      = eventCommentsIn;\n   eventWeightLHEF    = eventWeightLHEFIn;\n   weightContainerPtr->weightsLHEF.bookVectors(weights_detailed_vecIn,\n     weights_detailed_name_vecIn);\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve events tag information.\n\nstring Info::getEventAttribute(string key, bool doRemoveWhitespace) const {\n  if (!eventAttributes) return \"\";\n  if ( eventAttributes->find(key) != eventAttributes->end() ) {\n    string res = (*eventAttributes)[key];\n    if (doRemoveWhitespace)\n      res.erase (remove (res.begin(), res.end(), ' '), res.end());\n    return res;\n  }\n  return \"\";\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve initrwgt tag information.\n\nunsigned int Info::getInitrwgtSize() const {\n  if (!initrwgt) return 0;\n  return initrwgt->weights.size();\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve generator tag information.\n\nunsigned int Info::getGeneratorSize() const {\n  if (!generators) return 0;\n  return generators->size();\n}\n\nstring Info::getGeneratorValue(unsigned int n) const {\n  if (!generators || generators->size() < n+1) return \"\";\n  return (*generators)[n].contents;\n}\n\nstring Info::getGeneratorAttribute( unsigned int n, string key,\n  bool doRemoveWhitespace) const {\n  if (!generators || generators->size() < n+1) return \"\";\n  string res(\"\");\n  if ( key == \"name\") {\n    res = (*generators)[n].name;\n  } else if ( key == \"version\") {\n    res = (*generators)[n].version;\n  } else if ( (*generators)[n].attributes.find(key)\n           != (*generators)[n].attributes.end() ) {\n    res = (*generators)[n].attributes[key];\n  }\n  if (doRemoveWhitespace && res != \"\")\n    res.erase (remove (res.begin(), res.end(), ' '), res.end());\n  return res;\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve rwgt tag information.\n\nunsigned int Info::getWeightsDetailedSize() const {\n  if (!weights_detailed) return 0;\n  return weights_detailed->size();\n}\n\ndouble Info::getWeightsDetailedValue(string n) const {\n  if (weights_detailed->empty()\n    || weights_detailed->find(n) == weights_detailed->end())\n    return std::numeric_limits<double>::quiet_NaN();\n  return (*weights_detailed)[n];\n}\n\nstring Info::getWeightsDetailedAttribute(string n, string key,\n  bool doRemoveWhitespace) const {\n  if (!rwgt || rwgt->wgts.find(n) == rwgt->wgts.end())\n    return \"\";\n  string res(\"\");\n  if ( key == \"id\") {\n    res = rwgt->wgts[n].id;\n  } else if ( rwgt->wgts[n].attributes.find(key)\n           != rwgt->wgts[n].attributes.end() ) {\n    res = rwgt->wgts[n].attributes[key];\n  }\n  if (doRemoveWhitespace && res != \"\")\n    res.erase (remove (res.begin(), res.end(), ' '), res.end());\n  return res;\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve weights tag information.\n\nunsigned int Info::getWeightsCompressedSize() const {\n  if (!weights_compressed) return 0;\n  return weights_compressed->size();\n}\n\ndouble Info::getWeightsCompressedValue(unsigned int n) const {\n  if (weights_compressed->empty() || weights_compressed->size() < n+1)\n    return std::numeric_limits<double>::quiet_NaN();\n  return (*weights_compressed)[n];\n}\n\nstring Info::getWeightsCompressedAttribute(string key,\n  bool doRemoveWhitespace) const {\n  if (!weights || weights->attributes.find(key) == weights->attributes.end())\n    return \"\";\n  string res(\"\");\n  if ( weights->attributes.find(key)\n           != weights->attributes.end() ) {\n    res = weights->attributes[key];\n  }\n  if (doRemoveWhitespace && res != \"\")\n    res.erase (remove (res.begin(), res.end(), ' '), res.end());\n  return res;\n}\n\n//--------------------------------------------------------------------------\n\n// Retrieve scales tag information.\n\nstring Info::getScalesValue(bool doRemoveWhitespace) const {\n  if (!scales) return \"\";\n  string res = scales->contents;\n  if (doRemoveWhitespace && res != \"\")\n    res.erase (remove (res.begin(), res.end(), ' '), res.end());\n  return res;\n}\n\ndouble Info::getScalesAttribute(string key) const {\n  if (!scales) return std::numeric_limits<double>::quiet_NaN();\n  double res = std::numeric_limits<double>::quiet_NaN();\n  if ( key == \"muf\") {\n    res = scales->muf;\n  } else if ( key == \"mur\") {\n    res = scales->mur;\n  } else if ( key == \"mups\") {\n    res = scales->mups;\n  } else if ( key == \"SCALUP\") {\n    res = scales->SCALUP;\n  } else if ( scales->attributes.find(key)\n           != scales->attributes.end() ) {\n    res = scales->attributes[key];\n  }\n  return res;\n}\n\n//--------------------------------------------------------------------------\n//==========================================================================\n\n// Class for loading plugin libraries at run time.\n\n//--------------------------------------------------------------------------\n\n// Constructor, with library name and info pointer.\n\nPlugin::Plugin(string nameIn, Info *infoPtrIn) {\n  name = nameIn;\n  infoPtr = infoPtrIn;\n  libPtr = dlopen(nameIn.c_str(), RTLD_LAZY);\n  const char* cerror = dlerror();\n  string serror(cerror == nullptr ? \"\" : cerror);\n  dlerror();\n  if (serror.size()) {\n    errorMsg(\"Error in Plugin::Plugin: \" + serror);\n    libPtr = nullptr;\n  }\n\n}\n\n//--------------------------------------------------------------------------\n\n// Destructor.\n\nPlugin::~Plugin() {\n  if (libPtr != nullptr) dlclose(libPtr);\n  dlerror();\n\n}\n\n//--------------------------------------------------------------------------\n\n// Access plugin library symbols.\n\nPlugin::Symbol Plugin::symbol(string symName) {\n    Symbol sym(0);\n    const char* error(0);\n    if (libPtr == nullptr) return sym;\n    sym = (Symbol)dlsym(libPtr, symName.c_str());\n    error = dlerror();\n    if (error) errorMsg(\"Error in Plugin::symbol: \" + string(error));\n    dlerror();\n    return sym;\n\n}\n\n\n//==========================================================================\n\n} // end namespace Pythia8\n",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/plugins/python/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (tstate))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 3\n\n#if defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)       { e.restore();   return;\n                } catch (const builtin_exception &e) { e.set_error(); return;\n                }\n            }\n        );\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(\n            [](std::exception_ptr p) -> void {\n                try {\n                    if (p) std::rethrow_exception(p);\n                } catch (error_already_set &e)           { e.restore();                                    return;\n                } catch (const builtin_exception &e)     { e.set_error();                                  return;\n                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n                } catch (...) {\n                    PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n                    return;\n                }\n            }\n        );\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/htmldoc/vincia-kins.png",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/htmldoc/pythia99.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/htmldoc/dot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/htmldoc/pythia32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/pdfdoc/evtgen.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/pdfdoc/worksheet8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/pdfdoc/pythia8200.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/pdfdoc/pdfwarning.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/share/Pythia8/pdfdoc/g2qqbarsplit.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/zProduction_UnlopsLoop_01.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/ttbar.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/zProduction_UnlopsTree_12.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/zProduction_Ckkwl_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/zProduction_Mlm_012.lhe.gz",
        "/tmp/vanessa/spack-stage/spack-stage-pythia8-8303-am2gglpkcrsffazjtt2nogxdgeiocdtr/spack-src/examples/zProduction_Fxfx_01.lhe.gz"
    ],
    "total_files": 890
}