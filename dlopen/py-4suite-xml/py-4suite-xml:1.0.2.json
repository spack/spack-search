{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/Ft/Lib/ImportUtil.py": "########################################################################\n# $Header: /var/local/cvsroot/4Suite/Ft/Lib/ImportUtil.py,v 1.1.2.2 2006/12/08 22:50:53 jkloth Exp $\n\"\"\"\nUtilites for working with Python PEP 302 import hooks.\n\nCopyright 2006 Fourthought, Inc. (USA).\nDetailed license and copyright information: http://4suite.org/COPYRIGHT\nProject home, documentation, distributions: http://4suite.org/\n\"\"\"\n\nfrom __future__ import generators\nimport os\nimport sys\nimport imp\nimport time\nimport types\nimport cStringIO\ntry:\n    from zipimport import zipimporter\nexcept ImportError:\n    # placeholder for Python 2.2 to simplify code paths\n    class zipimporter(object): pass\n\n__all__ = [\n    # Module Utilities\n    'FindLoader', 'FindImporter', 'GetImporter', 'IterModules',\n    'GetLastModified', 'GetSearchPath',\n    # Resource Utilities\n    'OsPathToResource', 'NormalizeResource', 'GetResourceFilename',\n    'GetResourceString', 'GetResourceStream', 'GetResourceLastModified',\n    ]\n\n# Indicate that the use of \"special\" names is handled in a \"zip-safe\" way.\n__zipsafe__ = True\n\nIMP_SEARCH_ORDER = [ desc[0] for desc in imp.get_suffixes() ]\n\n# ZIP imports always search for .pyc AND .pyo, but reverse their order\n# depending on the optimzation flag (-O).\nZIP_SEARCH_ORDER = [ '.py', '.pyc', '.pyo']\nif not __debug__:\n    ZIP_SEARCH_ORDER.remove('.pyc')\n    ZIP_SEARCH_ORDER.append('.pyc')\n\ntry:\n    # New in Python 2.5 (or setuptools 0.7+)\n    from pkgutil import ImpImporter, ImpLoader, iter_importers, get_loader, \\\n         find_loader, iter_modules, get_importer\nexcept ImportError:\n    import marshal, inspect, re\n\n    MODULE_TYPE_INFO = {}\n    for suffix, mode, module_type in imp.get_suffixes():\n        MODULE_TYPE_INFO[module_type] = (suffix, mode)\n\n    class ImpImporter:\n        \"\"\"PEP 302 Importer that wraps Python's \"classic\" import algorithm\n\n        ImpImporter(dirname) produces a PEP 302 importer that searches that\n        directory.  ImpImporter(None) produces a PEP 302 importer that\n        searches the current sys.path, plus any modules that are frozen or\n        built-in.\n\n        Note that ImpImporter does not currently support being used by\n        placement on sys.meta_path.\n        \"\"\"\n\n        def __init__(self, path=None):\n            if path is not None:\n                if not path:\n                    path = '.'\n                elif not os.path.isdir(path):\n                    raise ImportError(\"not a directory\")\n            self.path = path\n\n        def __repr__(self):\n            return \"<ImpImporter object %r>\" % self.path\n\n        def find_module(self, fullname, path=None):\n            # Note: we ignore 'path' argument since it is only used via\n            # meta_path\n            subname = fullname.split(\".\")[-1]\n            if subname != fullname and self.path is None:\n                return None\n            if self.path is None:\n                path = None\n            else:\n                path = [os.path.realpath(self.path)]\n            try:\n                file, filename, etc = imp.find_module(subname, path)\n            except ImportError:\n                return None\n            return ImpLoader(fullname, file, filename, etc)\n\n        def iter_modules(self, prefix=''):\n            if self.path is None or not os.path.isdir(self.path):\n                return\n\n            yielded = {}\n\n            filenames = os.listdir(self.path)\n            filenames.sort()  # handle packages before same-named modules\n\n            for fn in filenames:\n                modname = inspect.getmodulename(fn)\n                if modname == '__init__' or modname in yielded:\n                    continue\n\n                path = os.path.join(self.path, fn)\n                ispkg = False\n\n                if not modname and os.path.isdir(path) and '.' not in fn:\n                    modname = fn\n                    for fn in os.listdir(path):\n                        subname = inspect.getmodulename(fn)\n                        if subname == '__init__':\n                            ispkg = True\n                            break\n                    else:\n                        continue    # not a package\n\n                if modname and '.' not in modname:\n                    yielded[modname] = 1\n                    yield prefix + modname, ispkg\n            return\n\n    class ImpLoader:\n        \"\"\"PEP 302 Loader that wraps Python's \"classic\" import algorithm\n        \"\"\"\n        code = None\n        source = None\n\n        def __init__(self, fullname, file, filename, etc):\n            self.file = file\n            self.filename = filename\n            self.fullname = fullname\n            self.etc = etc\n\n        def load_module(self, fullname):\n            self._reopen()\n            try:\n                mod = imp.load_module(fullname, self.file, self.filename,\n                                      self.etc)\n            finally:\n                self.file.close()\n            # Note: we don't set __loader__ because we want the module to\n            # look normal; i.e. this is just a wrapper for standard import\n            # machinery\n            return mod\n\n        def get_data(self, pathname):\n            f = open(pathname, 'rb')\n            try:\n                data = f.read()\n            finally:\n                f.close()\n            return data\n\n        def _reopen(self):\n            if self.file and self.file.closed:\n                suffix, mode, module_type = self.etc\n                self.file = open(self.filename, mode)\n            return\n\n        def _fix_name(self, fullname):\n            if fullname is None:\n                fullname = self.fullname\n            elif fullname != self.fullname:\n                raise ImportError(\"Loader for module %s cannot handle \"\n                                  \"module %s\" % (self.fullname, fullname))\n            return fullname\n\n        def _get_package_loader(self):\n            return ImpImporter(self.filename).find_module('__init__')\n\n        def is_package(self, fullname):\n            fullname = self._fix_name(fullname)\n            return self.etc[2] == imp.PKG_DIRECTORY\n\n        def get_code(self, fullname=None):\n            fullname = self._fix_name(fullname)\n            if self.code is None:\n                module_type = self.etc[2]\n                if module_type == imp.PY_SOURCE:\n                    source = self.get_source(fullname)\n                    self.code = compile(source, self.filename, 'exec')\n                elif module_type == imp.PY_COMPILED:\n                    self._reopen()\n                    try:\n                        magic = self.file.read(4)\n                        if magic == imp.get_magic():\n                            timestamp = self.file.read(4)\n                            self.code = marshal.load(self.file)\n                    finally:\n                        self.file.close()\n                elif module_type == imp.PKG_DIRECTORY:\n                    self.code = self._get_package_loader().get_code()\n            return self.code\n\n        def get_source(self, fullname=None):\n            fullname = self._fix_name(fullname)\n            if self.source is None:\n                module_type = self.etc[2]\n                if module_type == imp.PY_SOURCE:\n                    self._reopen()\n                    try:\n                        self.source = self.file.read()\n                    finally:\n                        self.file.close()\n                elif module_type == imp.PY_COMPILED:\n                    suffix, mode = MODULE_TYPE_INFO[imp.PY_COMPILED]\n                    filename = os.path.splitext(self.filename)[0] + suffix\n                    if os.path.exists(filename):\n                        f = open(filename, mode)\n                        try:\n                            self.source = f.read()\n                        finally:\n                            f.close()\n                elif module_type == imp.PKG_DIRECTORY:\n                    self.source = self._get_package_loader().get_source()\n            return self.source\n\n        def get_filename(self, fullname=None):\n            fullname = self._fix_name(fullname)\n            module_type = self.etc[2]\n            if module_type == imp.PKG_DIRECTORY:\n                return self._get_package_loader().get_filename()\n            elif module_type in MODULE_TYPE_INFO:\n                return self.filename\n            return None\n\n    def get_importer(path_item):\n        \"\"\"Retrieve a PEP 302 importer for the given path item\n        \"\"\"\n        if sys.version < '2.3':\n            importer = None\n        else:\n            try:\n                importer = sys.path_importer_cache[path_item]\n            except KeyError:\n                for path_hook in sys.path_hooks:\n                    try:\n                        importer = path_hook(path_item)\n                        break\n                    except ImportError:\n                        pass\n                else:\n                    importer = None\n                sys.path_importer_cache.setdefault(path_item, importer)\n\n        # The boolean values are used for caching valid and invalid\n        # file paths for the built-in import machinery\n        if importer in (None, True, False):\n            try:\n                importer = ImpImporter(path_item)\n            except ImportError:\n                importer = None\n        return importer\n\n    def iter_importers(fullname=''):\n        if '.' in fullname:\n            # Get the containing package's __path__\n            pkg = '.'.join(fullname.split('.')[:-1])\n            if pkg not in sys.modules:\n                __import__(pkg)\n            path = sys.modules[pkg].__path__\n        else:\n            # sys.meta_path is available in Python 2.3+\n            for importer in getattr(sys, 'meta_path', []):\n                yield importer\n            path = sys.path\n        for item in path:\n            yield get_importer(item)\n        if '.' not in fullname:\n            yield ImpImporter()\n\n    def get_loader(module_or_name):\n        \"\"\"Get a PEP 302 \"loader\" object for module_or_name\n\n        If the module or package is accessible via the normal import\n        mechanism, a wrapper around the relevant part of that machinery\n        is returned.  Returns None if the module cannot be found or imported.\n        If the named module is not already imported, its containing package\n        (if any) is imported, in order to establish the package __path__.\n        \"\"\"\n        if module_or_name in sys.modules:\n            module_or_name = sys.modules[module_or_name]\n        if isinstance(module_or_name, types.ModuleType):\n            module = module_or_name\n            loader = getattr(module, '__loader__', None)\n            if loader is not None:\n                return loader\n            fullname = module.__name__\n        else:\n            fullname = module_or_name\n        return find_loader(fullname)\n\n    def find_loader(fullname):\n        \"\"\"Find a PEP 302 \"loader\" object for fullname\n\n        If fullname contains dots, path must be the containing package's\n        __path__. Returns None if the module cannot be found or imported.\n        \"\"\"\n        for importer in iter_importers(fullname):\n            loader = importer.find_module(fullname)\n            if loader is not None:\n                return loader\n        return None\n\n    def iter_zipimport_modules(importer, prefix):\n        # make the path components regex safe\n        sep = os.sep.replace('\\\\', '\\\\\\\\')\n        path = prefix.replace(os.sep, sep)\n        # using \"non-greedy\" matching in case a suffix is not just an\n        # extension (like module.so for dlopen imports)\n        modname = '[a-zA-Z_][a-zA-Z0-9_]*?'\n        pkginit = sep + '__init__'\n        suffix = '|'.join([ desc[0] for desc in imp.get_suffixes() ])\n        suffix = suffix.replace('.', '\\\\.')\n        pattern = '^%s(%s)(%s)?(%s)$' % (path, modname, pkginit, suffix)\n        submodule_match = re.compile(pattern).match\n        yielded = {}\n        dirlist = list(importer._files)\n        dirlist.sort()\n        for fn in dirlist:\n            match = submodule_match(fn)\n            if match is not None:\n                modname, pkginit, suffix = match.groups()\n                if pkginit:\n                    ispkg = True\n                elif modname == '__init__':\n                    continue\n                else:\n                    ispkg = False\n                if modname not in yielded:\n                    yielded[modname] = True\n                    yield modname, ispkg\n        return\n\n    def iter_modules(path=None, prefix=''):\n        \"\"\"Yield submodule names+loaders for path or sys.path\"\"\"\n        if path is None:\n            importers = iter_importers()\n        else:\n            importers = map(get_importer, path)\n\n        yielded = {}\n        for importer in importers:\n            if hasattr(importer, 'iter_modules'):\n                modules = importer.iter_modules(prefix)\n            elif isinstance(importer, zipimporter):\n                modules = iter_zipimport_modules(importer, prefix)\n            else:\n                modules = []\n            for name, ispkg in modules:\n                if name not in yielded:\n                    yielded[name] = 1\n                    yield importer, name, ispkg\n        return\n\ntry:\n    from pkg_resources import get_provider, resource_filename\nexcept ImportError:\n    class DefaultProvider:\n        \"\"\"Resource provider for \"classic\" loaders\"\"\"\n        def __init__(self, module):\n            self.loader = getattr(module, '__loader__', None)\n            self.module_path = os.path.dirname(module.__file__)\n\n        def get_resource_filename(self, manager, resource_name):\n            return self._fn(self.module_path, resource_name)\n\n        def get_resource_stream(self, manager, resource_name):\n            return open(self._fn(self.module_path, resource_name), 'rb')\n\n        def get_resource_string(self, manager, resource_name):\n            stream = self.get_resource_stream(manager, resource_name)\n            try:\n                return stream.read()\n            finally:\n                stream.close()\n\n        def has_resource(self, resource_name):\n            return self._has(self._fn(self.module_path, resource_name))\n\n        def resource_isdir(self, resource_name):\n            return self._isdir(self._fn(self.module_path, resource_name))\n\n        def resource_listdir(self, resource_name):\n            return self._listdir(self._fn(self.module_path, resource_name))\n\n        def _fn(self, base, resource_name):\n            return os.path.join(base, *resource_name.split('/'))\n\n        def _has(self, pathname):\n            return os.path.exists(pathname)\n\n        def _isdir(self, pathname):\n            return os.path.isdir(pathname)\n\n        def _listdir(self, pathname):\n            return os.listdir(pathname)\n\n    class ZipProvider(DefaultProvider):\n        \"\"\"Resource provider for ZIP loaders\"\"\"\n\n        _dirindex = None\n\n        def __init__(self, module):\n            DefaultProvider.__init__(self, module)\n            self.zipinfo = self.loader._files\n            self.zip_pre = self.loader.archive + os.sep\n\n        def get_resource_filename(self, manager, resource_name):\n            raise NotImplementedError(\"not supported by ZIP loaders\")\n\n        def get_resource_stream(self, manager, resource_name):\n            data = self.get_resource_string(manager, resource_name)\n            return cStringIO.StringIO(data)\n\n        def get_resource_string(self, manager, resource_name):\n            pathname = self._fn(self.module_path, resource_name)\n            return self.loader.get_data(pathname)\n\n        def _zipinfo_name(self, pathname):\n            # Convert a virtual filename (full path to file) into a zipfile\n            # subpath usable with the zipimport directory cache for our\n            # target archive.\n            if pathname.startswith(self.zip_pre):\n                return pathname[len(self.zip_pre):]\n            raise ValueError(\"%s not in %s\" % (pathname, self.zip_pre))\n\n        def _build_index(self):\n            self._dirindex = index = {}\n            for path in self.zipinfo:\n                parts = path.split(os.sep)\n                while parts:\n                    parent = os.sep.join(parts[:-1])\n                    if parent in index:\n                        index[parent].append(parts[-1])\n                        break\n                    else:\n                        index[parent] = [parts.pop()]\n            return index\n\n        def _has(self, pathname):\n            arcname = self._zipinfo_name(fspath)\n            return (arcname in self.zipinfo or\n                    arcname in (self._dirindex or self._build_index()))\n\n        def _isdir(self, pathname):\n            arcname = self._zipinfo_name(pathname)\n            return arcname in (self._dirindex or self._build_index())\n\n        def _listdir(self, pathname):\n            arcname = self._zipinfo_name(pathname)\n            if arcname in (self._dirindex or self._build_index()):\n                return self._dirindex[arcname][:]\n            return []\n\n    def get_provider(fullname):\n        if fullname not in sys.modules:\n            __import__(fullname)\n        module = sys.modules[fullname]\n        loader = getattr(module, '__loader__', None)\n        if loader is None:\n            provider = DefaultProvider(module)\n        elif isinstance(loader, zipimporter):\n            provider = ZipProvider(module)\n        else:\n            raise NotImplementedError('unsupported loader type: %s' % loader)\n        return provider\n\n    _resource_manager = None\nelse:\n    # pkg_resources (aka setuptools) installed.; the resource_filename\n    # top-level name is actually the bound method of the global\n    # ResourceManager (at least that is what the PkgResources docs say).\n    _resource_manager = resource_filename.im_self\n    del resource_filename\n\nGetImporter = get_importer\nFindLoader = find_loader\nIterModules = iter_modules\n\ndef FindImporter(fullname):\n    \"\"\"Find a PEP 302 \"loader\" object for fullname\n\n    If fullname contains dots, path must be the containing package's\n    __path__. Returns None if the module cannot be found or imported.\n    \"\"\"\n    for importer in iter_importers(fullname):\n        if importer.find_module(fullname) is not None:\n            return importer\n    return None\n\ndef GetLastModified(fullname):\n    \"\"\"\n    Returns the last modified timestamp for the given module.\n    \"\"\"\n    loader = get_loader(fullname)\n    if hasattr(loader, 'get_filename'):\n        suffixes = IMP_SEARCH_ORDER\n    elif isinstance(loader, zipimporter):\n        suffixes = ZIP_SEARCH_ORDER\n    else:\n        raise NotImplementedError(\"unsupported loader %s\" % laoder)\n\n    barename = '/' + fullname.replace('.', '/')\n    if loader.is_package(fullname):\n        barename += '/__init__'\n    for suffix in suffixes:\n        resource = barename + suffix\n        try:\n            timestamp = GetResourceLastModified(fullname, resource)\n        except EnvironmentError:\n            timestamp = 0\n        else:\n            break\n    return timestamp\n\ndef GetSearchPath(fullname):\n    loader = get_loader(fullname)\n    if loader.is_package(fullname):\n        if fullname in sys.modules:\n            package = sys.modules[fullname]\n        else:\n            package = loader.load_module(fullname)\n        return package.__path__\n    return None\n\n# -- Resource Handling ------------------------------------------------\n\ndef OsPathToResource(pathname):\n    components = []\n    for component in pathname.split(os.sep):\n        if component == '..':\n            del components[-1:]\n        elif component not in ('', '.'):\n            components.append(component)\n    resource = '/'.join(components)\n    if pathname.startswith(os.sep):\n        resource = '/' + resource\n    return resource\n\ndef NormalizeResource(package, resource):\n    # normalize the resource pathname\n    # Note, posixpath is not used as it doesn't remove leading '..'s\n    components = []\n    for component in resource.split('/'):\n        if component == '..':\n            del components[-1:]\n        elif component not in ('', '.'):\n            components.append(component)\n    absolute = resource.startswith('/')\n    resource = '/'.join(components)\n    provider = get_provider(package)\n    if absolute:\n        # Find the provider for the distribution directory\n        module_path = provider.module_path\n        packages = package.split('.')\n        if not get_loader(package).is_package(package):\n            del packages[-1]\n        for module in packages:\n            module_path = os.path.dirname(module_path)\n        provider.module_path = module_path\n    return (provider, resource)\n\ndef GetResourceFilename(package, resource):\n    \"\"\"Returns a true filesystem name for the specified resource.\n    \"\"\"\n    provider, resource = NormalizeResource(package, resource)\n    return provider.get_resource_filename(_resource_manager, resource)\n\ndef GetResourceString(package, resource):\n    \"\"\"Return a string containing the contents of the specified resource.\n\n    If the pathname is absolute it is retrieved starting at the path of\n    the importer for 'fullname'.  Otherwise, it is retrieved relative\n    to the module within the loader.\n    \"\"\"\n    provider, resource = NormalizeResource(package, resource)\n    return provider.get_resource_string(_resource_manager, resource)\n\ndef GetResourceStream(package, resource):\n    \"\"\"Return a readable stream for specified resource\"\"\"\n    provider, resource = NormalizeResource(package, resource)\n    return provider.get_resource_stream(_resource_manager, resource)\n\ndef GetResourceLastModified(package, resource):\n    \"\"\"Return a timestamp indicating the last-modified time of the\n    specified resource.  Raises IOError is the pathname cannot be found\n    from the loader for 'fullname'.\n    \"\"\"\n    provider, resource = NormalizeResource(package, resource)\n    if isinstance(provider.loader, zipimporter):\n        if not resource:\n            # it is the archive itself\n            timestamp = os.stat(provider.module_path).st_mtime\n        else:\n            filename = provider._fn(provider.module_path, resource)\n            zipinfo_name = provider._zipinfo_name(filename)\n            try:\n                dostime, dosdate = provider.zipinfo[zipinfo_name][5:7]\n            except:\n                import errno\n                errorcode = errno.ENOENT\n                raise IOError(errorcode, os.strerror(errorcode), zipinfo_name)\n            timestamp = time.mktime((\n                ((dosdate >> 9)  & 0x7f) + 1980, # tm_year\n                ((dosdate >> 5)  & 0x0f) - 1,    # tm_mon\n                ((dosdate >> 0)  & 0x1f),        # tm_mday\n                ((dostime >> 11) & 0x1f),        # tm_hour\n                ((dostime >> 5)  & 0x3f),        # tm_min\n                ((dostime >> 0)  & 0x1f) * 2,    # tm_secs\n                0, 0, -1))\n    else:\n        filename = provider.get_resource_filename(_resource_manager, resource)\n        timestamp = os.stat(filename).st_mtime\n    return timestamp\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/XPath/Borrowed/od_20000608.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Xslt/Borrowed/da_20000714.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Xslt/Borrowed/mg_20010530.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Xslt/Borrowed/ep_20020718.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Xslt/Borrowed/ce_20000527.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Xslt/Borrowed/fc_20001125.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/goodXml_16LE_LEBOM_noDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/goodXml_16LE_LEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/badXml_16LE_BEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/goodXml_16BE_BEBOM_noDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/badXml_16LE_LEBOM_16LEDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/test/Xml/Core/goodXml_16BE_BEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/Ft/Lib/DistExt/stubmain.exe",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-tpuqoagr24abhiveui3v643lmpk6toem/spack-src/Ft/Data/draft.gif"
    ],
    "total_files": 979
}