{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/util/ckdll_dlopen.C": "/*\n dlopen version of CkDll class.  \n This file can be #included whole by the configure script or ckdll.C.\n\n Orion Sky Lawlor, olawlor@acm.org, 9/10/2002\n*/\n#include \"ckdll.h\"\n#include <unistd.h> //For unlink\n#include <dlfcn.h> //for dlopen, etc.\n\nCkDll::CkDll(const char *name) {\n\thandle=dlopen(name,RTLD_NOW);\n}\nvoid *CkDll::lookup(const char *name) {\n\treturn dlsym(handle,name);\n}\nCkDll::~CkDll() {\n\tdlclose(handle);\n}\n\nconst char *CkDll::extension=\".so\";\n",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/util/ckdll.C": "/*\nPortable Dynamically Linked Libraries (DLL) interface\n\nOrion Sky Lawlor, olawlor@acm.org, 7/26/2002\n*/\n#include \"converse.h\" //For CMK_ symbols\n#include \"ckdll.h\"\n#include <stdio.h> //For fopen\n#include <stdlib.h> //For system\n#include <string.h>\n\n\n/*#include the appropriate CkDll implementation: */\n\n#if CMK_DLL_USE_DLOPEN  /*********** UNIX .so/dlopen Version ******/\n#include \"ckdll_dlopen.C\"\n\nstatic void deleteFile(const char *fileName) {\n\tunlink(fileName);\n}\n#define CMK_SCRATCH_PATH \"/tmp\"\n\n#elif CMK_DLL_USE_WIN32 /*********** Win32 .dll/GetProcAddress Version ******/\n#include \"ckdll_win32.C\"\n\nstatic void deleteFile(const char *fileName) {\n\tDeleteFile(fileName);\n}\n#define CMK_SCRATCH_PATH \"\"\n\n#else \n/********* It ain't UNIX, it ain't win32-- what *is* it? */\nCkDll::CkDll(const char *name) {\n\thandle=0; /*DLL's not supported here.*/\n}\nvoid *CkDll::lookup(const char *name) {\n\treturn 0;\n}\nCkDll::~CkDll() {\n\t;\n}\n\nconst char *CkDll::extension=0;\nstatic void deleteFile(const char *fileName) { }\n\n#define CMK_SCRATCH_PATH \"\"\n#endif\n\n/****************************************************************\nCkCppInterpreter interface:\n\tCall the C++ compiler on a string, then use CkDll to link the\nresulting dll into the running program.\n\n\tThis depends on conv-mach.h or conv-mach-opt.h setting the symbol\nCMK_DLL_CC to the correct invokation of the C++ compiler to generate a shared\nlibrary.  CMK_DLL_CC will immediately be followed by the output library name,\nso it should end with, e.g., \"-o \" on UNIX platforms.\n\n\tCMK_DLL_LINK is an optional extra link step (required on HP machines);\nand CMK_DLL_INC is the compiler flag to change the #include path.\n*/\n\n/* \nCommand-line compilers for various platforms (now in conv-mach.h files)\n#if CMK_DLL_VIA_SUN_CC\n#  define CMK_DLL_CC  \"CC -G -O3 -o \"\n#elif CMK_DLL_VIA_SGI_CC\n#  define CMK_DLL_CC  \"CC -shared -64 -LANG:std -O3 -o \"\n#elif CMK_DLL_VIA_CXX\n#  define CMK_DLL_CC  \"cxx -shared -O3 -o \"\n#elif CMK_DLL_VIA_HP_CC\n#  define CMK_DLL_CC  \"CC +z -O -c -o \"\n#  define CMK_DLL_LINK \"CC -b -o \"\n#else\n//Default: try g++\n#  define CMK_DLL_CC  \"g++ -shared -O3 -o \"\n#endif\n*/\n\n\n#ifdef CMK_DLL_CC //We have a command-line dynamic-link library compiler:\n\n#ifndef CMK_DLL_INC\n#  define CMK_DLL_INC \"-I\" /*Assume unix-style command-line flags*/\n#endif\n\n/*Return 1 if this file exists*/\nstatic int fileExists(const char *fileName) {\n\tFILE *f=fopen(fileName,\"r\");\n\tif (f==NULL) return 0;\n\telse {\n\t\tfclose(f);\n\t\treturn 1;\n\t}\n}\n\n\n#ifdef CMK_SIGSAFE_SYSTEM\n#  include \"ckdll_system.C\"\n#else\n/*No need for a signal-safe system call*/\nstatic int CkSystem (const char *command) {\n\tsystem(command);\n}\n#endif\n\n//Compile \"cppCode\", making available the includes at inclPath\nCkCppInterpreter::CkCppInterpreter(const char *cppCode,const char *inclPath)\n\t:library(NULL)\n{\n\tint verbose=0;\n\tint randA=CrnRand();\n\tint randB=CmiMyPe();\n\n/*Write the c++ code to a temporary file:*/\n\tchar sourceFile[256];\n\tsprintf(sourceFile,\"%s/ckSharedLib_%d_%d_%p.%s\",\n\t\tCMK_SCRATCH_PATH,randA,randB,this,\"cpp\");\n\tFILE *f=fopen(sourceFile,\"w\"); if (f==NULL) return;\n\tfputs(cppCode,f);\n\tfclose(f);\n\n/*Allocate a spot for the library file:*/\n\tsprintf(libraryFile,\"%s/ckSharedLib_%d_%d_%p%s\",\n\t\tCMK_SCRATCH_PATH,randA,randB,this,CkDll::extension);\n\t\n//Compile the .cpp file into a .dll:\n\tchar compilerCmd[1024];\n\tsprintf(compilerCmd,\"%s%s %s %s%s\",\n\t\tCMK_DLL_CC, libraryFile, sourceFile,\n\t\tinclPath!=NULL?CMK_DLL_INC:\"\",inclPath!=NULL?inclPath:\"\");\n\t\n\tif (verbose) CmiPrintf(\"Executing: '%s'\\n\",compilerCmd);\n\tint compilerRet=CkSystem(compilerCmd);\n\tdeleteFile(sourceFile);\n\tif (compilerRet!=0) { //!fileExists(libraryFile)) {\n\t\tCmiPrintf(\"Compilation error! Cmd='%s', err=%d, src='%s'\\n\",\n\t\t\tcompilerCmd,compilerRet,cppCode);\n\t\treturn; /*with library set to NULL*/\n\t}\n\t\n#ifdef CMK_DLL_LINK\n//Link the .so into a \".sop\"\n\t// HIDEOUS HACK: playing silly games with filename:\n\t//    CC source -o foo.so\n\t//    CC foo.so -o foo.sop\n\tsprintf(compilerCmd,\"%s%sp %s\",\n\t\tCMK_DLL_LINK, libraryFile, libraryFile);\n\tcompilerRet=CkSystem(compilerCmd);\n\tunlink(libraryFile);\n\tstrcat(libraryFile,\"p\");\n\tif (compilerRet!=0) { //!fileExists(libraryFile)) {\n\t\tCmiPrintf(\"Link error! Cmd='%s', err=%d, src='%s'\\n\",\n\t\t\tcompilerCmd,compilerRet,cppCode);\n\t\treturn; \n\t}\n#endif\n\t\n/*Link the library into the program: */\t\n\tlibrary=new CkDll(libraryFile);\n}\n\n//Remove \"cppCode\" from the program.\n//  This invalidates any function pointers created with lookup\nCkCppInterpreter::~CkCppInterpreter()\n{\n\tif (library) {\n\t\tdelete library;\n\t\tdeleteFile(libraryFile);\n\t}\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/scripts/conv-autoconfig.h.in": "/* conv-autoconfig.h.in.  Generated from configure.in by autoheader.  */\n\n/* Charm++ Release/API version number */\n#undef CHARM_VERSION\n\n/* whether Cray gni_pub has GNI_GetBIConfig */\n#undef CMK_BALANCED_INJECTION_API\n\n/* whether C++ bool works */\n#undef CMK_BOOL_DEFINED\n\n/* bproc version */\n#undef CMK_BPROC_VERSION\n\n/* build MPI. */\n#undef CMK_BUILD_ON_MPI\n\n/* enable ccs */\n#undef CMK_CCS_AVAILABLE\n\n/* enable charmdebug */\n#undef CMK_CHARMDEBUG\n\n/* whether c compiler knows of the c11 standard */\n#undef CMK_COMPILER_KNOWS_C11\n\n/* whether c++ compiler knows of the cpp11 standard */\n#undef CMK_COMPILER_KNOWS_CPP11\n\n/* whether ucontext has pointer */\n#undef CMK_CONTEXT_FPU_POINTER\n\n/* whether ucontext uses uc_regs union */\n#undef CMK_CONTEXT_FPU_POINTER_UCREGS\n\n/* whether ucontext has pointer (v_regs) of vector type */\n#undef CMK_CONTEXT_V_REGS\n\n/* C++ *_casts<> does not work */\n#undef CMK_CPP_CAST_ILLEGAL\n\n/* C++ *_casts<> work */\n#undef CMK_CPP_CAST_LEGAL\n\n/* Cray MAXNID */\n#undef CMK_CRAY_MAXNID\n\n/* whether Xfence intrinsics works in C */\n#undef CMK_C_BUILTIN_IA32_XFENCE\n\n/* whether C inline works in C */\n#undef CMK_C_INLINE\n\n/* whether sync_add_and_fetch primitive works in C */\n#undef CMK_C_SYNC_ADD_AND_FETCH_PRIMITIVE\n\n/* whether sync_synchronize primitives works in C */\n#undef CMK_C_SYNC_SYNCHRONIZE_PRIMITIVE\n\n/* whether C++ allows declaration of variable sized array */\n#undef CMK_DECLARE_VARSIZE_ARRAY\n\n/* dlopen */\n#undef CMK_DLL_USE_DLOPEN\n\n/* whether getProcAddress works */\n#undef CMK_DLL_USE_WIN32\n\n/* enable error checking */\n#undef CMK_ERROR_CHECKING\n\n/* whether C++ class explicit keyword works */\n#undef CMK_EXPLICIT\n\n/* ALLCAPS */\n#undef CMK_FORTRAN_USES_ALLCAPS\n\n/* NOSCORE */\n#undef CMK_FORTRAN_USES_NOSCORE\n\n/* ONESCORE */\n#undef CMK_FORTRAN_USES_ONESCORE\n\n/* TWOSCORE */\n#undef CMK_FORTRAN_USES_TWOSCORE\n\n/* Allows gcc IA64 assembly. */\n#undef CMK_GCC_IA64_ASM\n\n/* Allows gcc x86 assembly. */\n#undef CMK_GCC_X86_ASM\n\n/* Allows gcc x86 assembly for atomic increment. */\n#undef CMK_GCC_X86_ASM_ATOMICINCREMENT\n\n/* whether personality() and ADDR_NO_RANDOMIZE exist */\n#undef CMK_HAS_ADDR_NO_RANDOMIZE\n\n/* whether has alloca.h */\n#undef CMK_HAS_ALLOCA_H\n\n/* whether anon structs are permitted */\n#undef CMK_HAS_ANON_STRUCTS\n\n/* whether has asctime */\n#undef CMK_HAS_ASCTIME\n\n/* whether the bindprocessor() exists */\n#undef CMK_HAS_BINDPROCESSOR\n\n/* whether PAPI exists */\n#undef CMK_HAS_COUNTER_PAPI\n\n/* whether has elf.h */\n#undef CMK_HAS_ELF_H\n\n/* whether has fabsf */\n#undef CMK_HAS_FABSF\n\n/* whether gethostname() exists */\n#undef CMK_HAS_GETHOSTNAME\n\n/* whether getifaddrs() exists */\n#undef CMK_HAS_GETIFADDRS\n\n/* whether getpagesize exists */\n#undef CMK_HAS_GETPAGESIZE\n\n/* whether getpid exists */\n#undef CMK_HAS_GETPID\n\n/* whether has get_myaddress */\n#undef CMK_HAS_GET_MYADDRESS\n\n/* whether iterator_traits works */\n#undef CMK_HAS_ITERATOR_TRAITS\n\n/* whether kill exists */\n#undef CMK_HAS_KILL\n\n/* whether has log2 */\n#undef CMK_HAS_LOG2\n\n/* whether has mallinfo */\n#undef CMK_HAS_MALLINFO\n\n/* whether has malloc.h */\n#undef CMK_HAS_MALLOC_H\n\n/* whether the mmap() syscall exists */\n#undef CMK_HAS_MMAP\n\n/* whether mmap() accepts MAP_ANON */\n#undef CMK_HAS_MMAP_ANON\n\n/* whether mmap() accepts MAP_NORESERVE */\n#undef CMK_HAS_MMAP_NORESERVE\n\n/* whether has mprotect */\n#undef CMK_HAS_MPROTECT\n\n/* whether has mstats */\n#undef CMK_HAS_MSTATS\n\n/* whether has Multiprocessing.h */\n#undef CMK_HAS_MULTIPROCESSING_H\n\n/* whether ntohl is available */\n#undef CMK_HAS_NTOHL\n\n/* whether NUMA control related functions exist */\n#undef CMK_HAS_NUMACTRL\n\n/* whether offsetof exists */\n#undef CMK_HAS_OFFSETOF\n\n/* whether PMI_Get_nid exists */\n#undef CMK_HAS_PMI_GET_NID\n\n/* whether has popen */\n#undef CMK_HAS_POPEN\n\n/* whether the pthread_setaffinity_np() exists */\n#undef CMK_HAS_PTHREAD_SETAFFINITY\n\n/* whether Python is installed */\n#undef CMK_HAS_PYTHON\n\n/* whether Cray rca library is available */\n#undef CMK_HAS_RCALIB\n\n/* whether Cray rca has rca_get_max_dimension */\n#undef CMK_HAS_RCA_MAX_DIMENSION\n\n/* whether has regex.h */\n#undef CMK_HAS_REGEX_H\n\n/* whether getrusage accepts RUSAGE_THREAD */\n#undef CMK_HAS_RUSAGE_THREAD\n\n/* whether has sbrk */\n#undef CMK_HAS_SBRK\n\n/* whether the sched_setaffinity() exists */\n#undef CMK_HAS_SETAFFINITY\n\n/* whether the setpriority exists */\n#undef CMK_HAS_SETPRIORITY\n\n/* whether has sleep */\n#undef CMK_HAS_SLEEP\n\n/* whether has socklen_t */\n#undef CMK_HAS_SOCKLEN\n\n/* whether the pthread_spin_lock exists */\n#undef CMK_HAS_SPINLOCK\n\n/* whether has sqrtf */\n#undef CMK_HAS_SQRTF\n\n/* whether has stdint.h */\n#undef CMK_HAS_STDINT_H\n\n/* whether std::distance works */\n#undef CMK_HAS_STD_DISTANCE\n\n/* whether std::inserter works */\n#undef CMK_HAS_STD_INSERTER\n\n/* whether std::unordered_map works */\n#undef CMK_HAS_STD_UNORDERED_MAP\n\n/* whether has strings.h */\n#undef CMK_HAS_STRINGS_H\n\n/* sync program */\n#undef CMK_HAS_SYNC\n\n/* whether has sync */\n#undef CMK_HAS_SYNC_FUNC\n\n/* whether has system */\n#undef CMK_HAS_SYSTEM\n\n/* Allows __thread. */\n#undef CMK_HAS_TLS_VARIABLES\n\n/* whether typeinfo/typeid works */\n#undef CMK_HAS_TYPEINFO\n\n/* whether has _setjmp/_longjmp */\n#undef CMK_HAS_UNDERSCORE_SETJMP\n\n/* whether has usleep */\n#undef CMK_HAS_USLEEP\n\n/* whether has values.h */\n#undef CMK_HAS_VALUES_H\n\n/* whether ibv_port_attr has link_layer field */\n#undef CMK_IBV_PORT_ATTR_HAS_LINK_LAYER\n\n/* Setting load balancing timer type */\n#undef CMK_LBTIME_TYPE\n\n/* whether long double works */\n#undef CMK_LONG_DOUBLE_DEFINED\n\n/* whether long long works */\n#undef CMK_LONG_LONG_DEFINED\n\n/* machine name */\n#undef CMK_MACHINE_NAME\n\n/* Allows MPI_Init_thread. */\n#undef CMK_MPI_INIT_THREAD\n\n/* expected message priorities are arbitrarily sized */\n#undef CMK_MSG_PRIO_TYPE\n\n/* whether operator delete can be overloaded in same class */\n#undef CMK_MULTIPLE_DELETE\n\n/* whether namespaces work */\n#undef CMK_NAMESPACES_BROKEN\n\n/* OS is Linux */\n#undef CMK_OS_IS_LINUX\n\n/* whether is power7 */\n#undef CMK_POWER7\n\n/* Allows asm eieio assembly. */\n#undef CMK_PPC_ASM\n\n/* whether has zlib */\n#undef CMK_PROJECTIONS_USE_ZLIB\n\n/* Python version */\n#undef CMK_PYTHON_VERSION\n\n/* envelope refnum field set to UInt */\n#undef CMK_REFNUM_TYPE\n\n/* disable replay */\n#undef CMK_REPLAYSYSTEM\n\n/* whether C++ signed char and char differ */\n#undef CMK_SIGNEDCHAR_DIFF_CHAR\n\n/* whether to use signal-safe system() */\n#undef CMK_SIGSAFE_SYSTEM\n\n/* whether size_t 64bit */\n#undef CMK_SIZET_64BIT\n\n/* disable tracing comm thread */\n#undef CMK_SMP_TRACE_COMMTHREAD\n\n/* Allows switching TLS in 32-bit. */\n#undef CMK_TLS_SWITCHING32\n\n/* Allows switching TLS 64-bit. */\n#undef CMK_TLS_SWITCHING64\n\n/* enable tracing */\n#undef CMK_TRACE_ENABLED\n\n/* whether glibc backtrace works */\n#undef CMK_USE_BACKTRACE\n\n/* whether has libjpeg */\n#undef CMK_USE_LIBJPEG\n\n/* whether has mkstemp */\n#undef CMK_USE_MKSTEMP\n\n/* whether the poll syscall exists */\n#undef CMK_USE_POLL\n\n/* whether charm scheduler should use an STL-based msg q */\n#undef CMK_USE_STL_MSGQ\n\n/* disable controlpoint */\n#undef CMK_WITH_CONTROLPOINT\n\n/* enable statistics collection */\n#undef CMK_WITH_STATS\n\n/* whether __int128 works */\n#undef CMK___int128_DEFINED\n\n/* whether __int128_t works */\n#undef CMK___int128_t_DEFINED\n\n/* whether __int64 works */\n#undef CMK___int64_DEFINED\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/scripts/configure.in": "\nAC_INIT(./Makefile)\n\nAC_CONFIG_HEADER(conv-autoconfig.h)\n\nCHARMINC=\".\"\ntest -r ./conv-config.sh && . ./conv-config.sh\n\n# Decimal representation of Charm++ release line and API revision\n# Increment the last 2 digits when making an API change\n# Increase the first three after branching for a release\nVERSION=60500\necho $VERSION > ../include/VERSION\nAC_DEFINE_UNQUOTED([CHARM_VERSION], $VERSION, [Charm++ Release/API version number])\n\ncharmout=\"charmconfig.out\"\n/bin/rm -rf $charmout\nMAKEFILE_EXT=Make.extlib\n\nEcho() {\n\techo $* \n\techo $* >> $charmout\n}\n\n# add into conv-mach-opt.sh\n# add_flag $1 $2\n# $2 is description\nadd_flag() {\n        key=`echo $1 | cut -d'=' -f1`\n        last=`grep \"$key=\" ../include/conv-mach-opt.sh 2>/dev/null | tail -1 | sed -e 's/ *#.*$//'`\n        skip=0\n\tif test -n \"$last\" -a  \"$last\" = \"$1\" \n\tthen\n\t  skip=1\n        fi\n\tif test $skip = 0\n        then\n\t  cat >> ../include/conv-mach-opt.sh << EOT\n\n$1   # Option added by configure script's $2 section\nEOT\n\tfi\n}\n\n# remove_flag $1\nremove_flag() {\n     sed -e '/^'\"$1\"'=/d' ../include/conv-mach-opt.sh > tmp.$$\n     cp tmp.$$ ../include/conv-mach-opt.sh\n     /bin/rm -f tmp.$$\n}\n\n\n# enable/disable error checking\nAC_ARG_ENABLE([error-checking],\n            [AS_HELP_STRING([--enable-error-checking],\n              [enable error checking])], ,\n            [enable_error_checking=yes])\n\nif test \"$enable_error_checking\" = \"no\"\nthen\n  Echo \"Error checking is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 0, [disable error checking])\nelse\n  Echo \"Error checking is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 1, [enable error checking])\nfi\n\n# enable/disable statistics collection\nAC_ARG_ENABLE([stats],\n            [AS_HELP_STRING([--enable-stats],\n              [enable statistics collection])], ,\n            [enable_stats=yes])\n\nif test \"$enable_stats\" = \"no\"\nthen\n  Echo \"Statistics collection is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 0, [disable statistics collection])\nelse\n  Echo \"Statistics collection is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 1, [enable statistics collection])\nfi\n\n# check enable/disable\nAC_ARG_ENABLE([tracing],\n            [AS_HELP_STRING([--enable-tracing],\n              [enable tracing modules])], ,\n            [enable_tracing=yes])\n\nif test \"$enable_tracing\" = \"no\"\nthen\n  Echo \"Charm tracing is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 0, [disable tracing])\n  add_flag CMK_TRACE_ENABLED=0\nelse\n  Echo \"Charm tracing is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 1, [enable tracing])\n  add_flag CMK_TRACE_ENABLED=1\nfi\n\nAC_ARG_ENABLE([tracing-commthread],\n            [AS_HELP_STRING([--enable-tracing-commthread],\n              [enable tracing communication thread])], ,\n            [enable_tracing_commthread=no])\n\nif test \"$enable_tracing_commthread\" = \"yes\"\nthen\n  Echo \"Charm tracing communication thread is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 1, [enable tracing comm thread])\nelse\n  Echo \"Charm tracing communication thread is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 0, [disable tracing comm thread])\nfi\n\n\nAC_ARG_ENABLE([charmdebug],\n            [AS_HELP_STRING([--enable-charmdebug],\n              [enable charmDebug])], ,\n            [enable_charmdebug=yes])\n\nif test \"$enable_charmdebug\" = \"no\"\nthen\n  Echo \"CharmDebug is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 0, [disable charmdebug])\n  add_flag CMK_CHARMDEBUG=0\nelse\n  Echo \"CharmDebug is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 1, [enable charmdebug])\n  add_flag CMK_CHARMDEBUG=1\nfi\n\nAC_ARG_ENABLE([replay],\n            [AS_HELP_STRING([--enable-replay],\n              [enable record/replay])],\n            [enable_replay=$enableval],\n            [enable_replay=yes])\n\nif test \"$enable_replay\" = \"no\"\nthen\n  Echo \"Charm record/replay is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 0, [disable replay])\nelse\n  Echo \"Charm record/replay is enabled\"\nfi\n\nAC_ARG_ENABLE([ccs],\n            [AS_HELP_STRING([--enable-ccs],\n              [enable CCS])], ,\n            [enable_ccs=yes])\n\nif test \"$enable_ccs\" = \"no\"\nthen\n  Echo \"CCS is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 0, [disable ccs])\nelse\n  Echo \"CCS is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 1, [enable ccs])\nfi\n\nAC_ARG_ENABLE([controlpoint],\n            [AS_HELP_STRING([--enable-controlpoint],\n              [enable control point])],\n            [enable_controlpoint=$enableval],\n            [enable_controlpoint=yes])\n\nif test \"$enable_controlpoint\" = \"yes\"\nthen\n  Echo \"Charm control point is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 1, [enable controlpoint])\nelse\n  Echo \"Charm control point is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])\nfi\n\nAC_ARG_WITH([numa],\n            [AS_HELP_STRING([--with-numa],\n              [support memory affinity with NUMA])],\n            [],\n            [with_numa=no])\n\nWITH_NUMA=no\nif test \"$with_numa\" = \"yes\"\nthen\n  Echo \"Charm NUMA support is builtin\"\n  WITH_NUMA=yes\nfi\n\nAC_ARG_WITH([lbtime-type],\n            [AS_HELP_STRING([--with-lbtime-type=type],\n                            [load balancing timer type])],\n            [], [with_lbtime_type=double])\n\nif test \"$with_lbtime_type\" = \"float\" -o \"$with_lbtime_type\" = \"double\"\nthen\n  Echo \"Setting load balancing timer type as '$with_lbtime_type'\"\n  AC_DEFINE_UNQUOTED(CMK_LBTIME_TYPE, $with_lbtime_type, [Setting load balancing timer type])\nelse\n  Echo \"Invalid type specified for load balancing timer type\"\n  test_finish 1\nfi\n\n#clean up conv-mach-opt.sh\nsed -e '/Option added by configure/d' ../include/conv-mach-opt.sh  | sed -e '/^$/d' > conv-mach-opt.sh.clean\ncp -f conv-mach-opt.sh.clean   ../include/conv-mach-opt.sh\nrm -f conv-mach-opt.sh.clean\n\n\n#\nAC_MSG_CHECKING(machine name)\nversion=`pwd | awk -F/ '{print $(NF-1)}'`\nbase_version=`cat .vdir`\nAC_DEFINE_UNQUOTED(CMK_MACHINE_NAME, \"$version\",[machine name])\nAC_MSG_RESULT($version)\nAC_SUBST(base_version)\n\nt=\"test.cpp\"\ntc=\"test.c\"\n\n# test result passed in $1\n# If the test suceeded, print $3 and set \"pass\"/clear \"fail\"\n# If the test failed, print $2 and clear \"pass\"/set \"fail\"\ntest_result() {\n\tif test $1 -eq 0\n\tthen\n                AC_MSG_RESULT(\"$3\")\n\t\tpass=\"1\"\n\t\tfail=\"0\"\n\telse\n                AC_MSG_RESULT(\"$4\")\n\t\tpass=\"0\"\n\t\tfail=\"1\"\n# For debugging the configure script, just \"export autoconf_debug=1\"\n#  to get this verbose data on any failed tests:\n\t\tif test ! -z \"$autoconf_debug\"\n\t\tthen\n\t\t\techo \"------- test script for $2 failed:\"\n\t\t\tcat out\n\t\t\techo \"------- the test program was:\"\n\t\t\tcat $t\n\t\t\techo \"-------\"\n\t\tfi\n\tfi\n}\n\n# Test: tries to compile C file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_cc() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $tc >> $charmout\n\techo $CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CC $OPTS_LD -c $tc -o test.o $4 >> $charmout\n\t$CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CC $OPTS_LD -c $tc -o test.o $4 > out 2>&1\n\ttest_result $? \"$1\" \"$2\" \"$3\"\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Test: tries to compile C++ file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_cxx() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CXX $OPTS_LD -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CXX $OPTS_LD -c $t -o test.o $4 > out 2>&1\n\ttest_result $? \"$1\" \"$2\" \"$3\"\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Testlink: tries to compile and link a C++ file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_link() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 > out 2>&1\n        if test $? -ne 0\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n          echo $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout\n          $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1\n          ret=$?\n\t  test ! -x testlink && ret=1\n          test_result $ret \"$1\" \"$2\" \"$3\"\n        fi\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Testlinkc: tries to compile and link a C file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_linkc() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $tc >> $charmout\n\techo $CMK_CC -I../include -I. $CMK_INCDIR $OPTS_CC -c $tc -o test.o $4 >> $charmout\n\t$CMK_CC -I../include -I. $CMK_INCDIR $OPTS_CC -c $tc -o test.o $4 > out 2>&1\n        if test $? -ne 0\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n          echo $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout\n          $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1\n          test_result $? \"$1\" \"$2\" \"$3\"\n        fi\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# test_linkso $1 $2 $3 $4, where\n# $1: debug msg\n# $2: yes msg\n# $3: no msg\n# $4: extra link option\ntest_linkso() {\n        AC_MSG_CHECKING(\"$1\")\n\techo $1 >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX $CMK_PIC -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $CMK_PIC $t -o test.o $4 > out 2>&1\n        if test $? = 1\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n\t  echo $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED test.o -o testlink.$CMK_SHARED_SUF $4 >> $charmout\n\t  $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED test.o -o testlink.$CMK_SHARED_SUF $4 > out 2>&1\n\t  test_result $? \"$1\" \"$2\" \"$3\"\n\tfi\n\tcat out >> $charmout\n\t/bin/rm -f out testlink.$CMK_SHARED_SUF\n}\n\ntest_finish() {\n\trm -f $t $tc testlink test.o\t> /dev/null 2>&1\n\t/bin/rm -f out\n\ttest $1 -eq 1 && echo \"*** Please find detailed output in charmconfig.out ***\"\n\texit $1\n}\n\n# detect certain architectures\nif cat /proc/cpuinfo 2>/dev/null | grep 'POWER7'  > /dev/null\nthen\n  AC_DEFINE_UNQUOTED(CMK_POWER7, 1, [whether is power7])\nfi\n\n# detect OS\nOSNAME=`uname -s`\nif test $OSNAME = \"Linux\"\nthen\n  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 1, [OS is Linux])\nelse\n  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 0, [OS is Linux])\nfi\n\n# test cp -p\nAC_MSG_CHECKING(\"cp command as\")\nCP=\"cp -p\"\ntouch test_file\nif ! $CP test_file test_file.cp 2>err\nthen\n  CP=\"cp\"\nfi\nrm -f test_file test_file.cp\nAC_MSG_RESULT($CP)\nadd_flag CP=\\\"\"$CP\"\\\" \"cp command\"\n \n\n# try to decide the version of glibc\nget_glibc_version() {\nt=test.c\ncat > $t <<EOT\n#include <stdio.h>\n#include <gnu/libc-version.h>\nint main (void) { puts (gnu_get_libc_version ()); return 0; }\nEOT\ngcc -o gver test.c\nGLIBCVERSION=`./gver`\n/bin/rm -f $t gver\n}\n\ncat > $t <<EOT\n#include <stdio.h>\nvoid foo(void) {\n\tprintf(\"Hello, world!\\n\");\n}\nEOT\n\nif test \"$CMK_BUILD_CRAY\" = \"1\"\nthen\n#echo \"Test for known incompatible compiler versions\"\n\n if test \"$CRAY_CC_VERSION\" = \"8.1.4\"\n then\n\techo \"CCE 8.1.4 produces incorrect Charm++ code\"\n\techo \"Please use a newer version of the CCE compiler\"\n\techo \"e.g. module load cce/8.1.7\"\n\ttest_finish 1\n fi\nfi\n\n#echo \"set C++ compiler as: $CMK_CXX $OPTS_CXX $OPTS\"\nAC_MSG_CHECKING(\"C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_CXX $OPTS_CXX $OPTS\")\ntest_cxx \"whether C++ compiler works\" \"ok\" \"no\" \"\"\nif test $fail -eq 1\nthen\n\techo \"Cannot compile C++ programs with $CMK_CXX\"\n\techo \" (check your charm++ version)\"\n\ttest_finish 1\nfi\n\ncat > $t <<EOT\n#include <stdio.h>\nint main() {\n\tprintf(\"Hello, world!\\n\");\n\treturn 0;\n}\nEOT\n#echo \"set C++ linker as: $CMK_LDXX $OPTS_LDXX\"\nAC_MSG_CHECKING(\"C++ linker as\")\nAC_MSG_RESULT(\"$CMK_LDXX $OPTS_LDXX\")\ntest_link \"whether linker works\" \"ok\" \"no\" \"\"\nif test $fail -eq 1\nthen\n\techo \"Cannot link C++ programs with $CMK_LDXX\"\n\techo \" (check your charm++ version)\"\n\ttest_finish 1\nfi\n\nAC_MSG_CHECKING(\"Native C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_NATIVE_CXX\")\nAC_MSG_CHECKING(\"Sequential C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_SEQ_CXX\")\n\nif test \"$base_version\" = \"net-linux\" \nthen\n  test_link \"whether linker accept --allow-multiple-definition\" \"ok\" \"no\" \"-Wl,--allow-multiple-definition\"\n  if test $pass -eq 1\n  then\n        remove_flag CMK_LDXX\n\tadd_flag CMK_LDXX='\"$CMK_LDXX -Wl,--allow-multiple-definition\"' \"net-linux linker\"\n  fi\nfi\n\nif echo \"$base_version\" | grep \"linux\" > /dev/null 2> /dev/null\nthen\n  test_link \"whether compiler accept -fno-stack-protector\" \"ok\" \"no\" \"-fno-stack-protector\"\n  if test $strictpass -eq 1\n  then\n\tadd_flag OPTS_CC='\"$OPTS_CC -fno-stack-protector\"' \"linux compiler\"\n\tadd_flag OPTS_CXX='\"$OPTS_CXX -fno-stack-protector\"' \"linux compiler\"\n  fi\nfi\n\n\n# Figure out if the user has asked to enable the latest language standards\nUSER_ASKED_FOR_NEW_STD=`echo \"$BUILDOPTS\" | grep \"-use-new-std\" | wc -l`\n\n# If the user has asked for the newer standards, check if the compilers know about them\nif test $USER_ASKED_FOR_NEW_STD -ge 1\nthen\n\n#### check if c compiler supports c11 compilation flags ####\ncat > $tc <<EOT\n#include <stdio.h>\n\nint foo()\n{\n  return 0;\n}\nEOT\ntest_cc \"whether c compiler knows of the c11 standard\" \"ok\" \"no\" \"$CMK_ENABLE_C11\"\nAC_DEFINE_UNQUOTED(CMK_COMPILER_KNOWS_C11, $pass, [whether c compiler knows of the c11 standard] )\nif test $pass -eq 1\nthen\n        # Record results for charmc's future use\n        add_flag 'CMK_COMPILER_KNOWS_C11=\"1\"' \"c11\"\n        # For the rest of configure, append this to compilation flags\n        OPTS_CC=\"$CMK_ENABLE_C11 $OPTS\"\nfi\n\n#### check if C++ compiler supports cpp11 compilation flags ####\ncat > $t <<EOT\n#include <iostream>\n\nint foo()\n{\n  return 0;\n}\nEOT\ntest_cxx \"whether c++ compiler knows of the cpp11 standard\" \"ok\" \"no\" \"$CMK_ENABLE_CPP11\"\nAC_DEFINE_UNQUOTED(CMK_COMPILER_KNOWS_CPP11, $pass, [whether c++ compiler knows of the cpp11 standard] )\nif test $pass -eq 1\nthen\n        # Record results for charmc's future use\n        add_flag 'CMK_COMPILER_KNOWS_CPP11=\"1\"' \"cpp11\"\n        # For the rest of configure, append this to compilation flags\n        OPTS_CXX=\"$CMK_ENABLE_CPP11 $OPTS\"\nfi\n\nfi # endif USER_ASKED_FOR_NEW_STD\n\n\n# Perform the tests\n\nAC_ARG_WITH([refnum-type],\n            [AS_HELP_STRING([--with-refnum-type=type],\n                            [size of the envelope refnum field])],\n            [], [with_refnum_type=no])\n\nif test \"$with_refnum_type\" = \"no\" -o \"$with_refnum_type\" = \"short\"\nthen\n  Echo \"Setting charm++ envelope refnum field to unsigned short\"\n  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned short, [envelope refnum field set to UShort])\nelif test \"$with_refnum_type\" = \"int\"\nthen\n  Echo \"Setting charm++ envelope refnum field to unsigned int\"\n  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned int, [envelope refnum field set to UInt])\nelse\n  Echo \"Invalid size specified for refnum field\"\n  test_finish 1\nfi\n\n\nAC_ARG_WITH([prio-type],\n            [AS_HELP_STRING([--with-prio-type=type],\n                            [size of expected message priorities])],\n            [], [with_prio_type=bitvec])\n\nif test \"$with_prio_type\" = \"char\" -o \"$with_prio_type\" = \"short\" -o \"$with_prio_type\" = \"int\" -o \"$with_prio_type\" = \"long\" -o \"$with_prio_type\" = \"float\" -o \"$with_prio_type\" = \"double\"\nthen\n  Echo \"Configuring support for message priorities of sizeof type $with_prio_type\"\n  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 1, [whether charm scheduler should use an STL-based msg q])\n  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are sizeof $with_prio_type])\nelif test \"$with_prio_type\" = \"bitvec\"\nthen\n  Echo \"Configuring support for message priorities of arbitrary size (bitvectors)\"\n  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 0, [whether charm scheduler should use an STL-based msg q])\n  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are arbitrarily sized])\nelse\n  Echo \"Invalid size ($with_prio_type) specified for message priorities. Can only accept char, short, int, long, float, double and bitvec\"\n  test_finish 1\nfi\n\n#### Check if compiler if 64 bit ####\ncat > $t <<EOT\n#include <stdio.h>\n\nint foo()\n{\nint x[[(int)(sizeof(void *) - 7)]]={0};\nreturn x[[0]];\n}\nEOT\ntest_cxx \"whether compiler generates code for 64-bit\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIZET_64BIT, $strictpass, [whether size_t 64bit])\nin64bit=$strictpass\n\n\n#### check strings.h ####\ncat > $t <<EOT\n#include <strings.h>\nint main() { \n  char str[[8]];\n  bzero(str, 8);\n  return 0;\n}\nEOT\ntest_cxx \"whether has strings.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STRINGS_H, $pass, [whether has strings.h])\n\n#### test if has values.h ####\ncat > $t <<EOT\n#include <values.h>\nint main() { \n  double d = MAXDOUBLE;\n  return 0;\n}\nEOT\ntest_cxx \"whether has values.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_VALUES_H, $pass, [whether has values.h])\n\n#### test if has stdint.h ####\ncat > $t <<EOT\n#include <stdint.h>\nint main() { \n  return 0;\n}\nEOT\ntest_cxx \"whether has stdint.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STDINT_H, $pass, [whether has stdint.h])\n\n#### test if has malloc.h ####\ncat > $t <<EOT\n#include <malloc.h>\nint main() { \n  return 0;\n}\nEOT\ntest_cxx \"whether has malloc.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MALLOC_H, $pass, [whether has malloc.h])\n\n#### test if has alloca.h ####\ncat > $t <<EOT\n#include <alloca.h>\nint main() {\n  double *s=(double *)alloca(sizeof(double));\n  *s=1.0;\n  return 0;\n}\nEOT\ntest_cxx \"whether has alloca.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ALLOCA_H, $pass, [whether has alloca.h])\n\n#### test if has regex.h ####\ncat > $t <<EOT\n#include <regex.h>\nint main() {\n  regex_t re;\n  regcomp(&re, \".*MOD.*\", REG_EXTENDED|REG_NOSUB);\n  return 0;\n}\nEOT\ntest_cxx \"whether has regex.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_REGEX_H, $pass, [whether has regex.h])\n\n#### Check bool ####\ncat > $t <<EOT\n#include <stdlib.h>\nbool foo(void) { return true; }\nEOT\ntest_cxx \"whether C++ bool works\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_BOOL_DEFINED, $pass, [whether C++ bool works])\n\n#### Check long long ####\ncat > $t <<EOT\n#include <stdlib.h>\nlong long foo(void) { return 17; }\nEOT\ntest_cxx \"whether long long works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_LONG_LONG_DEFINED, $pass, [whether long long works])\n\n#### Check __int64 ####\ncat > $t <<EOT\n#include <stdlib.h>\n__int64 foo(void) { return 17; }\nEOT\ntest_cxx \"whether __int64 works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int64_DEFINED], $pass, [whether __int64 works])\n\n#### Check __int128 ####\ncat > $t <<EOT\n#include <stdlib.h>\nint foo(void) {\n  __int128   a;\n  int x[[(int)(sizeof(__int128) - 15)]]={0};\n  return x[[0]];\n}\nEOT\ntest_cxx \"whether __int128 (128-bit integer) works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int128_DEFINED], $pass, [whether __int128 works])\nif test $pass -eq 1\nthen\n  add_flag CMK_HAS_INT16=1\nfi\n\n#### Check __int128_t ####\ncat > $t <<EOT\n#include <stdlib.h>\nint foo(void) {\n  __int128_t   a;\n  __uint128_t   b;\n  int x[[(int)(sizeof(__int128_t) - 15)]]={0};\n  return x[[0]];\n}\nEOT\ntest_cxx \"whether __int128_t (128-bit integer) works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int128_t_DEFINED], $pass, [whether __int128_t works])\nif test $pass -eq 1\nthen\n  add_flag CMK_HAS_INT16=1\nfi\n\n#### Check long double ####\ncat > $t <<EOT\n#include <stdlib.h>\nlong double foo(void) { return 17.0; }\nEOT\ntest_cxx \"whether long double works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_LONG_DOUBLE_DEFINED, $strictpass, [whether long double works])\n\n#### Check ucontext and FPU pointer ####\ncat > $t <<EOT\n#include <ucontext.h>\nstruct _libc_fpstate   fpstate;\nfpregset_t *fp;\nEOT\ntest_cxx \"whether ucontext has FPU pointer\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER, $pass, [whether ucontext has pointer])\n\nif test $pass -eq 1\nthen\ncat > $t <<EOT\n#include <ucontext.h>\n\nint main()\n{\n  ucontext_t context;\n  context.uc_mcontext.uc_regs = 0;\n}\nEOT\ntest_cxx \"whether ucontext uses uc_regs\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER_UCREGS, $pass, [whether ucontext uses uc_regs union])\nfi\n\ncat > $t <<EOT\n#include <ucontext.h>\nvrregset_t *v_regs;\nucontext_t  uc;\n\nvoid foo()\n{\n  vrregset_t *ptr = uc.uc_mcontext.v_regs;\n}\nEOT\ntest_cxx \"whether ucontext has pointer (v_regs) of vector type\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_V_REGS, $pass, [whether ucontext has pointer (v_regs) of vector type])\n\n#### Check ucontext and FPU pointer ####\ncat > $t <<EOT\n#include <infiniband/verbs.h>\nvoid test()\n{\n    struct ibv_context    *context;\n    int ibPort;\n    struct ibv_port_attr attr;\n    if (ibv_query_port(context, ibPort, &attr) != 0) return;\n    if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND)  return;\n}\nEOT\ntest_cxx \"whether ibverbs ibv_port_attr has link_layer field\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_IBV_PORT_ATTR_HAS_LINK_LAYER, $pass, [whether ibv_port_attr has link_layer field])\n\n\n###################### C++ Compiler Features #####################\n\n#### check C inline ####\ncat > $tc <<EOT\ninline static int foo()\n{\n  return 1;\n}\nEOT\ntest_cc \"whether inline works in C\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_C_INLINE, $strictpass, [whether C inline works in C])\n\n#### check explicit ####\ncat > $t <<EOT\n#include <stdlib.h>\nclass er {\n protected:\n   explicit er(unsigned int inType) {};\n};\nEOT\ntest_cxx \"whether C++ class explicit keyword works\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_EXPLICIT, $pass, [whether C++ class explicit keyword works])\n\n#### check if signed char is same as char ####\ncat > $t <<EOT\n#include <stdlib.h>\nclass er {\n protected:\n   void operator()(char &v,const char *desc=NULL) {};\n   void operator()(signed char &v,const char *desc=NULL) {};\n};\nEOT\ntest_cxx \"whether C++ signed char and char differ\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIGNEDCHAR_DIFF_CHAR, $pass, [whether C++ signed char and char differ])\n\n#### check if C++ casts work ####\ncat > $t <<EOT\nint foo(float *t) {return *reinterpret_cast<int *>(t);}\nEOT\ntest_cxx \"whether C++ *_casts<> work\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CPP_CAST_LEGAL, $pass, [C++ *_casts<> work])\nAC_DEFINE_UNQUOTED(CMK_CPP_CAST_ILLEGAL, $fail, [C++ *_casts<> does not work])\n\n\n### check if varsize array on stack ####\ncat > $t <<EOT\n#include <stdio.h>\nvoid foo()\n{\n  int size=10;\n  char arr[size];\n}\n\nEOT\ntest_cxx \"whether C++ allows declaration of varsize array\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_DECLARE_VARSIZE_ARRAY, $pass, [whether C++ allows declaration of variable sized array])\n\n#### check if namespaces can be defined #####\ncat > $t <<EOT\nnamespace foo {\n\tint x;\n}\nEOT\ntest_cxx \"whether namespaces work\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_NAMESPACES_BROKEN, $fail, [whether namespaces work])\n\n\n#### check if typeinfo exists and works #####\ncat > $t <<EOT\n#include <typeinfo>\nconst char *foo(void) {\n\tint x;\n\treturn typeid(x).name();\n}\nEOT\ntest_cxx \"whether typeinfo/typeid works\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_TYPEINFO, $pass, [whether typeinfo/typeid works])\n\n#### check if iterator_traits is defined #####\ncat > $t <<EOT\n#include <iterator>\n\ntemplate <typename T> // T models Input Iterator\ntypename std::iterator_traits<T>::value_type accumulate(T first, T last)\n{\n      typename std::iterator_traits<T>::value_type result = 0;\n      while(first != last)\n            result += *first++;\n      return result;\n}\nEOT\ntest_cxx \"whether std::iterator_traits is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ITERATOR_TRAITS, $pass, [whether iterator_traits works])\n\n#### check if std::distance is defined #####\ncat > $t <<EOT\n#include <vector>\n#include <iterator>\n\nint foo()\n{\n  std::vector<int> tree;\n  return std::distance(tree.begin(), tree.end());\n}\nEOT\ntest_cxx \"whether std::distance is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_DISTANCE, $pass, [whether std::distance works])\n\n#### check if std::inserter is defined #####\ncat > $t <<EOT\n#include <list>\n#include <iterator>\n\nvoid foo()\n{\n  using namespace std;\n  list<int> L;\n  inserter ( L, L.end ( ) ) = 500;\n}\nEOT\ntest_cxx \"whether std::inserter is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_INSERTER, $pass, [whether std::inserter works])\n\n\n####### Check support for features added by the new C11 and CPP11 standards ########\n\n#### check if std::unordered_map is defined #####\ncat > $t <<EOT\n#include <unordered_map>\n\nint foo()\n{\n  std::unordered_map<int,int> myhashtbl;\n  myhashtbl[[0]] = 42;\n  myhashtbl[[1234]] = 0;\n  return myhashtbl[[1234]];\n}\nEOT\ntest_cxx \"whether std::unordered_map is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_UNORDERED_MAP, $pass, [whether std::unordered_map works])\n\n\n#### check if anon structs are permitted #####\ncat > $t <<EOT\n#include <iostream>\nusing std::cout;\n\nstruct idx\n{\n    const static int dims = 3;\n    union\n    {\n        int data[[dims]];\n        struct { int x, y, z; };\n    };\n\n    idx(const int i=0, const int j=0, const int k=0): x(i), y(j), z(k) {}\n};\n\nint main()\n{\n    cout<<\"Hello World!\\n\";\n    idx myidx(1, 2, 3);\n    cout<< \"idx = (\"\n        << myidx.data[[0]] << \",\"\n        << myidx.data[[1]] << \",\"\n        << myidx.z << \")\\n\";\n    return (myidx.data[[0]] == 1 && myidx.y == 2 && myidx.data[[2]] == 3);\n}\nEOT\ntest_cxx \"whether anon structs are permitted\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ANON_STRUCTS, $pass, [whether anon structs are permitted])\n\n\n#### test if we can have multiple delete like this ####\ncat > $t <<EOT\nclass foo {\npublic:\n  void operator delete(void*p){};\n  void operator delete(void*p,int*){};\n};\nEOT\ntest_cxx \"whether operator delete can be overloaded in same class\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_MULTIPLE_DELETE, $strictpass, [whether operator delete can be overloaded in same class])\n\n#### test if offsetof exists ####\ncat > $t <<EOT\n#include <stddef.h>\n\nstruct FooType {\n        int f1;\n        int f2;\n        double f3;\n};\n\nvoid foo()\n{\n  int off = offsetof(FooType, f2);\n}\nEOT\ntest_cxx \"whether offsetof is defined\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_OFFSETOF, $pass, [whether offsetof exists])\n\n#### test if we can use gcc x86 assembly like this ####\ncat > $t <<EOT\ndouble foo(void)\n{\n  unsigned long long int v=0;\n  int *lo=0+(int *)&v;\n  int *hi=1+(int *)&v;\n  __asm__ __volatile__(\n      \"rdtsc; movl %%edx,%0; movl %%eax,%1\"\n      : /* output  */ \"=m\" (*hi), \"=m\" (*lo)\n      : /* input */\n      : /* trashes */ \"%edx\", \"%eax\"\n  );\n  return v;\n}\nEOT\ntest_cxx \"whether GCC x86 assembly works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM, $strictpass, [Allows gcc x86 assembly.])\n\n#### test if we can use gcc x86 assembly like this ####\nif test $strictpass = 1\nthen\ncat > $t <<EOT\nint foo(void)\n{\n  int x;\n  asm(\"lock incl %0\" :: \"m\" (x));\n  asm(\"lock decl %0\" :: \"m\" (x));\n  return x;\n}\nEOT\ntest_cxx \"whether GCC x86 assembly for atomic increment works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM_ATOMICINCREMENT, $strictpass, [Allows gcc x86 assembly for atomic increment.])\nfi\n\n#### test if we can use gcc IA64 assembly like this ####\ncat > $t <<EOT\ndouble foo(void)\n{\n        unsigned long long int x;\n\t__asm__ __volatile__(\"mov %0=ar.itc\" : \"=r\"(x) :: \"memory\");\n        return x;\n}\nEOT\ntest_cxx \"whether GCC IA64 assembly works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_GCC_IA64_ASM, $strictpass, [Allows gcc IA64 assembly.])\n\n\n#### test if we can use asm eieio assembly like this ####\ncat > $t <<EOT\ndouble foo(void)\n{\n        unsigned long long int x;\n\tasm volatile(\"eieio\" ::: \"memory\");\n        return x;\n}\nEOT\ntest_cxx \"whether asm eieio assembly works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_PPC_ASM, $strictpass, [Allows asm eieio assembly.])\n\n\n\n#### test if we can use __thread ####\ncat > $t <<EOT\n__thread unsigned long long int x;\nstatic __thread  int y;\nvoid foo(void)\n{\n\tx = 1;\n\ty = 1;\n}\nEOT\ntest_cxx \"whether __thread (Thread Local Storage) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_TLS_VARIABLES, $strictpass, [Allows __thread.])\n\n#### check __sync_add_and_fetch ####\ncat > $tc <<EOT\n#include <stdio.h>\nint main()\n{\n  int t=1;\n  __sync_add_and_fetch(&t, 1);\n  return 1;\n}\nEOT\ntest_linkc \"whether synchronization primitives (__sync_add_and_fetch) works in C\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_C_SYNC_ADD_AND_FETCH_PRIMITIVE, $pass, [whether sync_add_and_fetch primitive works in C])\n\n#### check __sync_synchronize ####\ncat > $tc <<EOT\n#include <stdio.h>\nint main()\n{\n  __sync_synchronize();\n}\nEOT\n\ntest_linkc \"whether synchronization primitives (__sync_synchronize) works in C\" \"yes\" \"no\" \"\"\n\nAC_DEFINE_UNQUOTED(CMK_C_SYNC_SYNCHRONIZE_PRIMITIVE, $pass, [whether sync_synchronize primitives works in C])\n\n\n#### check __BUILTIN_IA32_XFENCE ####\ncat > $tc <<EOT\n#include <stdio.h>\n#include <intrinsics.h>\nint main()\n{\n  __builtin_ia32_lfence();  __builtin_ia32_sfence();   __builtin_ia32_mfence();\n}\nEOT\n\ntest_linkc \"whether fence intrinsic primitives (__builtin_Xfence_ia32) works in C\" \"yes\" \"no\" \"\"\n\nAC_DEFINE_UNQUOTED(CMK_C_BUILTIN_IA32_XFENCE, $pass, [whether Xfence intrinsics works in C])\n\n\n### test if switching TLS register ###\nif test $in64bit = 1\nthen\ncat > $t <<EOT\n#include <elf.h>\n#include <stdlib.h>\n#include <malloc.h>\n\nvoid switchTLS() {\n  Elf64_Addr m1, m2;\n  asm volatile (\"movq %%fs:0x0, %0\\n\\t\"\n                \"movq %1, %%fs:0x0\\n\\t\"\n                : \"=r\"(m1)\n                : \"r\"(m2));\n}\nEOT\ntest_cxx \"whether switching TLS register (64-bit) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING64, $strictpass, [Allows switching TLS 64-bit.])\nelse\ncat > $t <<EOT\n#include <elf.h>\n#include <stdlib.h>\n#include <malloc.h>\n\nvoid switchTLS() {\n  Elf32_Addr m1, m2;\n  asm volatile (\"movl %%gs:0x0, %0\\n\\t\"\n                \"movl %1, %%gs:0x0\\n\\t\"\n                : \"=r\"(m1)\n                : \"r\"(m2));\n}\nEOT\ntest_cxx \"whether switching TLS register (32-bit) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING32, $strictpass, [Allows switching TLS in 32-bit.])\nfi\n\n#### test if we can build MPI ####\nif test \"$CMK_BUILD_MPI\" = 1\nthen\n\ncat > $t <<EOT\n#include \"mpi.h\"\nint main(int argc, char **argv)\n{\n  MPI_Init(&argc, &argv);\n}\nEOT\nmv -f ../include/mpi.h ../include/mpi.h.bak 2>/dev/null\ntest_cxx \"whether build on MPI\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_BUILD_ON_MPI, $strictpass, [build MPI.])\nBUILD_MPI=$strictpass\n\nif test $BUILD_MPI -eq 0\nthen\n  echo \"Error: Can not compile a MPI program\"\n  test_finish 1\nfi\n\nif test $BUILD_MPI -eq 1 -a -z \"$BGP_FLOOR\"\nthen\n  test_link \"whether need to specify MPI library\" \"no\" \"yes\" \"\"\n  if test $pass -ne 1\n  then\n    if test -z \"$CMK_MPI_LIB\"\n    then\n      test_link \"whether -lmpich\" \"ok\" \"no\" \"-lmpich\"\n      if test $pass -eq 1\n      then\n        add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS -lmpich\"' \"mpi lib\"\n      else\n        test_link \"whether -lmpi\" \"ok\" \"no\" \"-lmpi\"\n        if test $pass -eq 1\n        then\n                add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS -lmpi\"' \"mpi lib\"\n        else\n                echo \"Error: can not find mpi library\"\n                test_finish 1\n        fi\n      fi\n    else\n      add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS $CMK_MPI_LIB\"' \"mpi lib\"\n    fi\n  fi\nfi\n\nif test \"$BUILD_MPI\" = \"1\"\nthen\ncat > $t <<EOT\n#include \"mpi.h\"\nint main(int argc, char **argv)\n{\n  int thread_level, provided;\n  thread_level = MPI_THREAD_FUNNELED;\n  MPI_Init_thread(&argc, &argv, thread_level, &provided);\n}\nEOT\ntest_cxx \"whether MPI_Init_thread is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_MPI_INIT_THREAD, $strictpass, [Allows MPI_Init_thread.])\nfi\nmv -f ../include/mpi.h.bak ../include/mpi.h 2>/dev/null\n\nfi\n\n################### Syscalls and Libraries ###################\n\n#### test for getrusage with RUSAGE_THREAD ###\ncat > $tc <<EOT\n#include <sys/time.h>\n#define __USE_GNU   1\n#include <sys/resource.h>\nint main() {\n  struct rusage usage;\n  getrusage(RUSAGE_THREAD, &usage);\n  return 0;\n}\nEOT\ntest_linkc \"whether getrusage accepts RUSAGE_THREAD\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RUSAGE_THREAD, $pass, [whether getrusage accepts RUSAGE_THREAD])\n\n#### test for asctime ###\n\ncat > $tc <<EOT\n#include <time.h>\nint main() {\n  struct tm *local;\n  time_t t;\n  t = time(NULL);\n  local = localtime(&t);\n  asctime(local);\n  return 0;\n}\nEOT\ntest_linkc \"whether has asctime\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ASCTIME, $pass, [whether has asctime])\n\n#### test for log2 ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  int i = log2(10);\n  return 0;\n}\nEOT\ntest_link \"whether has log2\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_LOG2, $pass, [whether has log2])\n\n#### test for sqrtf ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  float i = sqrtf((float)10.0);\n  return 0;\n}\nEOT\ntest_link \"whether has sqrtf\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SQRTF, $pass, [whether has sqrtf])\n\n#### test for fabsf ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  float i = fabsf((float)10.0);\n  return 0;\n}\nEOT\ntest_link \"whether has fabsf\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_FABSF, $pass, [whether has fabsf])\n\n#### test for mkstemp ###\ncat > $t <<EOT\n#include <stdlib.h>\n#include <string.h>\nint main() {\n  char fname[[128]];\n  strcpy(fname, \"/tmp/fdXXX.XXX\");\n  mkstemp(fname);\n  return 0;\n}\nEOT\ntest_link \"whether has mkstemp\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_USE_MKSTEMP, $pass, [whether has mkstemp])\n\n#### test for system ###\ncat > $t <<EOT\n#include <stdlib.h>\nint main() {\n  system(\"/bin/ls\");\n  return 0;\n}\nEOT\ntest_link \"whether has system\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SYSTEM, $pass, [whether has system])\n\n#### test for sync() ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  sync();\n  return 0;\n}\nEOT\ntest_link \"whether has sync()\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SYNC_FUNC, $pass, [whether has sync])\n\n#### test for sbrk ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  void *ptr  = sbrk(0); \n}\nEOT\ntest_link \"whether has sbrk\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SBRK, $pass, [whether has sbrk])\n\n#### test for _setjmp/_longjmp ###\ncat > $t <<EOT\n#include <setjmp.h>\nint main() {\n  jmp_buf buf;\n  _setjmp(buf);\n  _longjmp(buf, 0);\n}\nEOT\ntest_link \"whether has _setjmp/_longjmp\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_UNDERSCORE_SETJMP, $pass, [whether has _setjmp/_longjmp])\n\n#### test for mstats ###\ncat > $t <<EOT\n#include <malloc.h>\nint main() {\n  struct mstats ms = mstats();\n}\nEOT\ntest_link \"whether has mstats\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MSTATS, $pass, [whether has mstats])\n\n#### test for mallinfo ###\ncat > $t <<EOT\n#include <malloc.h>\nint main() {\n  struct mallinfo mi = mallinfo();\n}\nEOT\ntest_link \"whether has mallinfo\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MALLINFO, $pass, [whether has mallinfo])\n\n#### test for popen ###\ncat > $t <<EOT\n#include <stdio.h>\nint main() {\n  FILE *p = popen(\"/bin/ps\", \"r\");\n  pclose(p);\n}\nEOT\ntest_link \"whether has popen\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_POPEN, $pass, [whether has popen])\n\n#### test for poll ###\ncat > $t <<EOT\n#include <poll.h>\nvoid foo(void) { \n  struct pollfd pos[[3]];\n  poll(pos, 1, 1);\n}\nEOT\ntest_cxx \"whether has poll\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_USE_POLL, $pass, [whether the poll syscall exists])\n\n#### check if getpagesize exists ####\ncat > $tc <<EOT\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s = getpagesize();\n}\nEOT\ntest_linkc \"whether has getpagesize\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETPAGESIZE, $pass, [whether getpagesize exists])\n\n#### check if getpid exists ####\ncat > $tc <<EOT\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    pid_t pid = getpid();\n}\nEOT\ntest_linkc \"whether has getpid\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETPID, $pass, [whether getpid exists])\n\n#### check if kill exists ####\ncat > $tc <<EOT\n#include <sys/types.h>\n#include <unistd.h>\n#include <signal.h>\n\nint main(int argc, char**argv) \n{\n    pid_t pid = getpid();\n    kill(pid, 9);\n}\nEOT\ntest_linkc \"whether has kill\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_KILL, $pass, [whether kill exists])\n\n#### test for setpriority ###\ncat > $t <<EOT\n#include <sys/time.h>\n#include <sys/resource.h>\nvoid foo(void) { \n  setpriority(PRIO_PROCESS, 0, 0);\n}\nEOT\ntest_cxx \"whether has setpriority\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SETPRIORITY, $pass, [whether the setpriority exists])\n\n#### test for system ###\ncat > $t <<EOT\n#include \"ckdll_system.C\"\nEOT\ntest_cxx \"whether to use signal-safe system() \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIGSAFE_SYSTEM, $pass, [whether to use signal-safe system()])\n\n### test sched_setaffinity ####\ncat > $tc <<EOT\n#define _GNU_SOURCE\n#include <sched.h>\n\nint main()\n{\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(0, &cpuset);\n  if (sched_setaffinity(0, sizeof(cpuset), &cpuset) < 0) {\n    return -1;\n  }\n  return 0;\n}\nEOT\ntest_linkc \"whether sched_setaffinity call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SETAFFINITY, $pass, [whether the sched_setaffinity() exists])\n\n### test pthread_setaffinity_np ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint main()\n{\n  unsigned long mask = 0xffffffff;\n  unsigned int len = sizeof(mask);\n\n  if (pthread_setaffinity_np(pthread_self(), len, &mask) < 0) {\n    return -1;\n  }\n  return 0;\n}\nEOT\ntest_linkc \"whether pthread_setaffinity_np call exists\" \"yes\" \"no\" \"-lpthread\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PTHREAD_SETAFFINITY, $pass, [whether the pthread_setaffinity_np() exists])\n\n### test pthread_spin_lock ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint main()\n{\n  pthread_spinlock_t  lock;\n\n  pthread_spin_init(&lock, 0);\n\n  pthread_spin_lock(&lock);\n\n  return 0;\n}\nEOT\ntest_linkc \"whether pthread_spin_lock exists\" \"yes\" \"no\" \"-lpthread\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SPINLOCK, $pass, [whether the pthread_spin_lock exists])\n\n### check libnuma on Linux ####\nif test \"$WITH_NUMA\" = \"yes\"\nthen\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <linux/mempolicy.h>\n#include <numaif.h>\n#include <numa.h>\n\nint main()\n{\n  if (get_mempolicy(NULL, NULL, 0, 0, 0) == 0) return 0;\n  return -1;\n}\nEOT\ntest_linkc \"whether libnuma exists\" \"yes\" \"no\" \"-lnuma\"\nAC_DEFINE_UNQUOTED(CMK_HAS_NUMACTRL, $pass, [whether NUMA control related functions exist])\nif test $pass -eq 1\nthen\n        add_flag 'CMK_SYSLIBS=\"$CMK_SYSLIBS -lnuma\"' \"libnuma\"\nfi\nfi\n\n#### check bindprocessors on AIX ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <sys/processor.h>\n\nint main()\n{\n  int retValue = 0;\n  int pid;\n  pid = getpid();\n  if (bindprocessor(BINDPROCESS, pid, 0) == -1) return -1;\n  return 0;\n}\nEOT\ntest_linkc \"whether bindprocessor call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_BINDPROCESSOR, $pass, [whether the bindprocessor()\nexists])\n\n\n#### check if dlopen works ####\nskip_dl=0\n# for bproc, ignore -ldl\ntest -n \"$CMK_BPROC\" && skip_dl=1\ntest -n \"$CMK_NO_DL\" && skip_dl=1\ndl_opt='-ldl'\n#workaround for pgcc 4.0, -ldl crash linking, so use -Wl,-ldl to skip the prelinker.\ncase \"$CMK_CXX\" in\npgCC*) dl_opt='-Wl,-ldl' ;;\nesac\n\nif test $skip_dl -eq 0 \nthen\n\ncat > $t <<EOT\n#include \"ckdll_dlopen.C\"\nint main() {\n\tCkDll dll(\"foo.so\");\n\treturn 0;\n}\nEOT\ntest_link \"whether dlopen links without $dl_opt\" \"yes\" \"no\" \"\"\nnoldl=$pass\ntest_link \"whether dlopen links with $dl_opt\" \"yes\" \"no\" \"$dl_opt\"\nif test $pass -eq 1\nthen \n#dlopen requires -ldl: add it to our link line\n\tadd_flag CMK_LIBS='\"$CMK_LIBS '$dl_opt'\"' \"dlopen\"\nfi\n\nif test $pass -eq 1 -o $noldl -eq 1\nthen\n# One version or another of dlopen worked: compile it in\n\tAC_DEFINE_UNQUOTED(CMK_DLL_USE_DLOPEN, 1, [dlopen])\nfi\n\n### test gethostname ####\ncat > $tc <<EOT\n#ifdef WIN32\n#include <Winsock2.h>\n#else\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#endif\n\nint main()\n{\n  char hostname[[1000]];\n  gethostname(hostname, 999);\n  return 0;\n}\nEOT\ntest_linkc \"whether gethostname call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETHOSTNAME, $pass, [whether gethostname() exists])\n\n#### check if getProcAddress works ####\ncat > $t <<EOT\n#include \"ckdll_win32.C\"\nEOT\ntest_cxx \"whether getProcAddress works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_DLL_USE_WIN32, $pass, [whether getProcAddress works])\n\nfi    # end of skip_dl\n\n#### check if socklen_t exists ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/socket.h>\n\nvoid foo(void) {\n\tint i;\n\tsocklen_t s=sizeof(i);\n}\nEOT\ntest_cxx \"whether has socklen_t\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SOCKLEN, $pass, [whether has socklen_t])\n\n### test getifaddrs ####\ncat > $tc <<EOT\n#include <netinet/in.h> /* for sockaddr_in */\n#include <ifaddrs.h> /* for getifaddrs */\n#include <net/if.h> /* for IFF_RUNNING */\n\nint main()\n{\n  struct ifaddrs *interfaces=0;\n  if( getifaddrs(&interfaces) == 0 ) {\n        struct ifaddrs *interface;\n        for( interface=interfaces; interface; interface=interface->ifa_next ) {\n            if( (interface->ifa_flags & IFF_UP) && ! (interface->ifa_flags & IFF_LOOPBACK) ) {\n                const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;\n                if( addr && addr->sin_family==AF_INET ) {\n                    break;\n                }\n            }\n        }\n        freeifaddrs(interfaces);\n  }\n}\nEOT\ntest_linkc \"whether getifaddrs call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETIFADDRS, $pass, [whether getifaddrs() exists])\n\n#### check if mmap exists ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l,int fd) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                 MAP_FIXED+MAP_PRIVATE,fd,0);\n}\nEOT\ntest_cxx \"whether the mmap() syscall exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP, $pass, [whether the mmap() syscall exists])\n\n#### check if mmap accepts MAP_ANON ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                MAP_FIXED+MAP_PRIVATE+MAP_ANON,-1,0);\n}\nEOT\ntest_cxx \"whether mmap() accepts MAP_ANON\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP_ANON, $pass, [whether mmap() accepts MAP_ANON])\n\n#### check if mmap accepts MAP_NORESERVE ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                MAP_FIXED+MAP_PRIVATE+MAP_NORESERVE,-1,0);\n}\nEOT\ntest_cxx \"whether mmap() accepts MAP_NORESERVE\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP_NORESERVE, $pass, [whether mmap() accepts MAP_NORESERVE])\n\n#### check if get_myaddress exists ####\ncat > $t <<EOT\n#include <rpc/rpc.h>\n\nvoid foo(void *a) {\n    get_myaddress((struct sockaddr_in*)a);\n}\nEOT\ntest_cxx \"whether has get_myaddress\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GET_MYADDRESS, $pass, [whether has get_myaddress])\n\n#### check if mprotect exists ####\ncat > $t <<EOT\n#include <stdio.h>\n#include <sys/mman.h>\n\nvoid foo(void *a,int l,int fd) {\n     void *pg = NULL;\n     size_t pagesize = 4096;\n     mprotect(pg, pagesize, PROT_READ | PROT_WRITE);\n}\nEOT\ntest_cxx \"whether has mprotect\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MPROTECT, $pass, [whether has mprotect])\n\n#### check if glibc backtrace exists ####\ncat > $t <<EOT\n#include \"cmibacktrace.c\"\n\nint main() {\n\tint nLevels=1;\n\tvoid *stack;\n\tCmiBacktraceRecord(&stack,0,&nLevels);\n\treturn 0;\n}\nEOT\nTRACE_LINK_FLAG=\"-rdynamic\"\ntest_link \"whether glibc backtrace works\" \"yes\" \"no\" \"-DCMK_USE_BACKTRACE=1 $TRACE_LINK_FLAG\"\nAC_DEFINE_UNQUOTED(CMK_USE_BACKTRACE, $pass, [whether glibc backtrace works])\n\nif test $strictpass -eq 1\nthen \n\tadd_flag 'CMK_LD=\"$CMK_LD '$TRACE_LINK_FLAG'\"' \"backtrace\"\n\tadd_flag 'CMK_LDXX=\"$CMK_LDXX '$TRACE_LINK_FLAG'\"' \"backtrace\"\nfi\n\n#### test sleep ####\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  sleep(1);\n  return 0;\n}\nEOT\ntest_cxx \"whether has sleep \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SLEEP, $pass, [whether has sleep])\n\n#### test usleep ####\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  usleep(100);\n  return 0;\n}\nEOT\ntest_cxx \"whether has usleep \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_USLEEP, $pass, [whether has usleep])\n\n#### test personality() and ADDR_NO_RANDOMIZE ####\n# Only works on modern Linux systems\ncat > $t <<EOT\n#include <sys/personality.h>\nint main() {\n    int orig_persona = personality(0xffffffff);\n    personality(orig_persona | ADDR_NO_RANDOMIZE);\n    return 0;\n}\nEOT\ntest_cxx \"whether personality() and ADDR_NO_RANDOMIZE exist\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ADDR_NO_RANDOMIZE, $pass, [whether personality() and ADDR_NO_RANDOMIZE exist])\n\n\n#### test if has zlib ####\n# bproc doesnot like -lz in any case\nif test -z \"$CMK_BPROC\"\nthen\n\ncat > $t <<EOT\n#include <zlib.h>\nint main() { \n  gzFile f = gzopen(\"/tmp/x\",\"r\");\n  gzprintf(f, \"test...\\n\");\n  gzclose(f);\n  return 0;\n}\nEOT\ntest_link \"whether has zlib\" \"yes\" \"no\" \"-lz\"\nAC_DEFINE_UNQUOTED(CMK_PROJECTIONS_USE_ZLIB, $pass, [whether has zlib])\nif test $pass -eq 1\nthen \n\tadd_flag 'CMK_LIBZ=\"-lz\"' \"zlib\"\nfi\n\nfi\n\n#### test if has elf.h ####\ncat > $t <<EOT\n#include <elf.h>\ntypedef Elf32_Addr ELF_TYPE_Addr;\nint main() { \n}\nEOT\ntest_cxx \"whether has elf.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_ELF_H], $pass, [whether has elf.h])\n\n#### test if has Multiprocessing.h for apple ####\ncat > $t <<EOT\n#include <Carbon/Carbon.h>\n#include <Multiprocessing.h>\nint main() {\n  int a = MPProcessorsScheduled();\n}\nEOT\ntest_cxx \"whether has Multiprocessing.h for Apple \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_MULTIPROCESSING_H], $pass, [whether has Multiprocessing.h])\n\n#### test if \"ntohl\" is available ####\ncat > $t <<EOT\n#if defined(_WIN32) && ! defined(__CYGWIN__) || defined(__MINGW_H)\n#include <winsock.h>\n#else\n#include <stdint.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#endif\n\nint main() {\n  int i = 100;\n  i = ntohl(i);\n  return 0;\n}\nEOT\ntest_link \"whether ntohl is available\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_NTOHL, $pass, [whether ntohl is available])\n\n### test for libjpeg ####\ncat > $t <<EOT\n#include <stdio.h>\n#include <stdlib.h>\n#include \"jpeglib.h\"\n\nint main()\n{\n  struct jpeg_compress_struct cinfo;\n  jpeg_create_compress(&cinfo);\n  return 0;\n}\nEOT\ntest_link \"whether has libjpeg\" \"yes\" \"no\" \"-ljpeg\"\nAC_DEFINE_UNQUOTED(CMK_USE_LIBJPEG, $pass, [whether has libjpeg])\nif test $pass -eq 1\nthen\n        add_flag 'CMK_LIBJPEG=\"-ljpeg\"' \"libjpeg\"\nfi\n\n#### check if PAPI exists ####\nif test -n \"$CMK_USE_PAPI\"\nthen\ncat > $t <<EOT\n#include <stdio.h>\n#include <papi.h>\n                                                                                \nint main() {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT) return 1;\n    return 0;\n}\nEOT\ntest_link \"whether PAPI exists\" \"yes\" \"no\" \"-lpapi\"\nAC_DEFINE_UNQUOTED(CMK_HAS_COUNTER_PAPI, $pass, [whether PAPI exists])\nif test $pass -eq 1\nthen \n\tadd_flag 'CMK_LIBS=\"$CMK_LIBS -lpapi\"' \"papi\"\nfi\nfi\n\n#### test if Python headers are installed ####\nPYTHON_VERSION=`python -V 2>&1 | awk {'print $2'} | awk -F. {'print $1\".\"$2'}`\ncat > $t <<EOT\n#include \"python${PYTHON_VERSION}/Python.h\"\n#include \"python${PYTHON_VERSION}/compile.h\"\n#include \"python${PYTHON_VERSION}/eval.h\"\n#include \"python${PYTHON_VERSION}/node.h\"\n\nint main() {\n    Py_Initialize();\n    PyEval_InitThreads();\n    struct _node* programNode = PyParser_SimpleParseString(\"return 1\\n\",Py_file_input);\n    PyCodeObject *program = PyNode_Compile(programNode, \"\");\n}\nEOT\ntest_link \"whether Python is installed\" \"yes\" \"no\" \"-lpython$PYTHON_VERSION -lpthread -lutil -ldl\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PYTHON, $pass, [whether Python is installed])\nAC_DEFINE_UNQUOTED(CMK_PYTHON_VERSION, ${PYTHON_VERSION}, [Python version])\nif test $pass -eq 1\nthen\n\tadd_flag \"CMK_BUILD_PYTHON=$PYTHON_VERSION\" \"python\"\nfi\n\n#### Pick up METIS if the user asks for it ####\n\nAC_ARG_WITH([metis],\n\t    [AS_HELP_STRING([--with-metis],\n\t     [support the METIS graph partitioner and associated load balancer])],\n\t    [],\n\t    [with_metis=no])\n\nWITH_METIS=no\nif test \"$with_metis\" != \"no\"\nthen\n  Echo \"Compiling Charm with support for METIS\"\n  WITH_METIS=yes\n  echo 'charm++: $(L)/libmoduleMetisLB.a $(L)/libmoduleTeamLB.a' >> $MAKEFILE_EXT\n  add_flag 'CMK_LIBS=\"$CMK_LIBS -lmetis\"' \"libmetis\"\n  if test \"$with_metis\" != \"yes\"\n  then\n    add_flag \"CMK_METIS=$with_metis\" \"Where to find METIS\"\n    add_flag 'CMK_LIBDIR=\"$CMK_LIBDIR -L$CMK_METIS\"' \"Library path for METIS\"\n    if test -r $with_metis/Lib/metis.h\n    then\n      add_flag 'CMK_INCDIR=\"$CMK_INCDIR -I$CMK_METIS/Lib\"' \"Include path for METIS 4\"\n    elif test -r $with_metis/../../include/metis.h\n    then\n      add_flag 'CMK_INCDIR=\"$CMK_INCDIR -I$CMK_METIS/../../include\"' \"Include path for METIS 5\"\n    else\n      echo \"I can't find metis.h, since the path you specified (which should point to the directory containing libmetis.a) is not laid out as I expect for version 4 or 5.\"\n      test_finish 1\n    fi\n  fi\nfi\n\n## Cray specific test\nif test \"$CMK_BUILD_CRAY\" = \"1\"\nthen\n#echo \"Test for known incompatible compiler versions\"\n\n if test \"$CRAY_CC_VERSION\" = \"8.1.4\"\n then\n\techo \"CCE 8.1.4 produces incorrect Charm++ code\"\n\techo \"Please use a newer version of the CCE compiler\"\n\techo \"e.g. module load cce/8.1.7\"\n\ttest_finish 1\n fi\n\n#### test if Cray node topology will work ####\ncat > $tc <<EOT\n#include <pmi.h>\n\nint main() {\n    int nid;\n    PMI_Get_nid(0, &nid);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether PMI_Get_nid exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PMI_GET_NID, $pass, [whether PMI_Get_nid exists])\n\n#### test if Cray mesh topology will work ####\ncat > $tc <<EOT\n#include <rca_lib.h>\n\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_meshcoord(0, &xyz);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether Cray rca library is available\" \"yes\" \"no\" \"-lrca\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RCALIB, $pass, [whether Cray rca library is available])\n\n#### test if Cray mesh dimension query function will work ####\ncat > $tc <<EOT\n#include <rca_lib.h>\n\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_max_dimension(&xyz);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether Cray rca_has get_max_dimension\" \"yes\" \"no\" \"-lrca\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RCA_MAX_DIMENSION, $pass, [whether Cray rca has rca_get_max_dimension])\n\n#### query Cray machine max NID if get_max_dimension not exist ####\n\nif test $pass -eq 0\nthen\ncmd=`which xtprocadmin 2>/dev/null`\nif test -n \"$cmd\"\nthen\n    #maxnid=`xtprocadmin  | tail -1  | awk '{print $1}'`\n    # workaround for hopper\n    (export SHELL=/bin/csh; xtprocadmin >& t.$$)\n    maxnid=`cat t.$$  | tail -1  | awk '{print $1}'`\n    /bin/rm -f t.$$\n    AC_MSG_CHECKING(Cray machine maxnid)\n    AC_MSG_RESULT(\"$maxnid\")\n    if test -n \"$maxnid\"\n    then\n    AC_DEFINE_UNQUOTED(CMK_CRAY_MAXNID, $maxnid, [Cray MAXNID])\n    fi\nfi\nfi\n\n\n\n\n#### query Cray machine supports BANDWIDTH_INJECTION controls####\n\nif test \"$CMK_BUILD_MPI\" = \"1\"\nthen\necho \"BANDWIDTH_INJECTION test disabled on MPI\"\nelse\ncat > $tc <<EOT\n#include <stdint.h>\n#include <gni_pub.h>\n\nint main() {\n    gni_bi_desc_t gni_bi_desc;\n    uint32_t gni_device_id = 0;\n    gni_return_t gni_rc = GNI_GetBIConfig(gni_device_id, &gni_bi_desc);\n    if (gni_rc == GNI_RC_SUCCESS) {\n    }\n    return 0;\n}\nEOT\ntest_linkc \"whether GNI_GetBIConfig exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_BALANCED_INJECTION_API, $pass, [whether Cray gni_pub has GNI_GetBIConfig])\nfi # end of BIConfig test\n\n\nfi  # end of Cray specific test\n\n#### test if it can build shared library ####\ncat > $t <<EOT\n#include \"stdlib.h\"\nextern int foo();\nint foo1() { \n  void * t= malloc(2);\n  foo();\n  return 0;\n}\nEOT\ntest_linkso \"whether can build shared library\" \"yes\" \"no\" \"\"\nif test $pass -eq 0\nthen \n\tadd_flag 'CMK_NO_BUILD_SHARED=\"true\"' \"build-shared\"\nelse\n\tBUILD_SHARED=1\n        if test \"$BUILD_MPI\" = \"1\"\n\tthen\ncat > $t <<EOT\n#include \"stdlib.h\"\n#include \"mpi.h\"\nextern int foo();\nint foo(int argc, char ** argv) {\n  void * t= malloc(2);\n  foo();\n  MPI_Init(&argc, &argv);\n  return 0;\n}\nEOT\n\t\ttest_linkso \"whether can build shared library with MPI\" \"yes\" \"no\" \"\"\n\t\tBUILD_SHARED=$pass\n\tfi\n\tif test $BUILD_SHARED -eq 0\n\tthen\n\t\tadd_flag 'CMK_NO_BUILD_SHARED=\"true\"' \"build-shared\"\n\tfi\nfi\n\n#### test the version number of bproc ####\nif test -n \"$CMK_BPROC\"\nthen\ncat > $t <<EOT\n#include <stdio.h>\n#include <sys/bproc.h>\nint main()\n{\n  struct bproc_version_t vers;\n  bproc_version(&vers);\n  printf(\"%s\\n\", vers.version_string);\n}\nEOT\ntest_link \"whether bproc compiles\" \"yes\" \"no\" \"-lbproc\"\nif test $pass -eq 1\nthen \nAC_MSG_CHECKING(\"bproc version\")\nbproc_ver=`./testlink`\nif test x$bproc_ver = x\nthen\ntest_result 0 \"bproc version\" \"ERROR\" \"\"\ntest_finish 1\nelse\ntest_result 0 \"bproc version\" \"$bproc_ver\" \"\"\nfi\nbproc_ver=`echo $bproc_ver | cut -d'.' -f1`\nAC_DEFINE_UNQUOTED(CMK_BPROC_VERSION, $bproc_ver, [bproc version])\nfi\nfi\n\n#### test the if command sync exists ####\nAC_CHECK_PROG(SYNC, sync, sync )\nif test -n \"$SYNC\"\nthen\nAC_DEFINE_UNQUOTED(CMK_HAS_SYNC, 1, [sync program])\nfi\n\n################## Fortran #########################\n\n#echo \"set F77 compiler as: $CMK_CF77\"\nAC_MSG_CHECKING(\"F77 compiler as\")\nAC_MSG_RESULT(\"$CMK_CF77\")\n\nAC_MSG_CHECKING(\"whether Fortran 77 compiler works\")\n### test fortran 77 compiler ###\ncat > conftest.f <<EOF\n      SUBROUTINE FOO_foo\n      END\nEOF\n$CMK_CF77 -c conftest.f > /dev/null 2> /dev/null\nif test ! -r conftest.o\nthen\n  AC_MSG_RESULT(\"no\")\nelse\n  AC_MSG_RESULT(\"yes\")\nfi\n\n### test fortran 90 compiler ###\n#echo \"set F90 compiler as: $CMK_CF90\"\nAC_MSG_CHECKING(\"F90 compiler as\")\nAC_MSG_RESULT(\"$CMK_CF90\")\n\nAC_MSG_CHECKING(\"whether Fortran 90 compiler works\")\ncat > conftest2.f90 <<EOF\n      SUBROUTINE FOO_foo\n      END\nEOF\n$CMK_CF90 -c conftest2.f90 > /dev/null 2> /dev/null\nif test ! -r conftest2.o\nthen\n  AC_MSG_RESULT(\"no\")\nelse\n  AC_MSG_RESULT(\"yes\")\n  mv -f conftest2.o conftest.o\n  USE_FORTRAN90=1\nfi\n\n### check fortran name mangling\nAC_MSG_CHECKING(subroutine name used by Fortran 90 compiler)\n\nif test -r conftest.o\nthen\n  AC_CACHE_VAL(_cv_fortran_postfix,\n\n  NAME=`$CMK_NM conftest.o | grep \"foo_foo__\"`\n  if test \"$NAME\" != \"\"\n  then\n    _cv_fortran_postfix=TWOSCORE\n    AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_TWOSCORE, 1, [TWOSCORE])\n  else\n    NAME=`$CMK_NM conftest.o | grep \"foo_foo_\"`\n    if test \"$NAME\" != \"\"\n    then\n      _cv_fortran_postfix=ONESCORE\n      AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ONESCORE, 1, [ONESCORE])\n    else\n      NAME=`$CMK_NM conftest.o | grep \"foo_foo\"`\n      if test \"$NAME\" != \"\"\n      then\n        _cv_fortran_postfix=NOSCORE\n        AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_NOSCORE, 1, [NOSCORE])\n      else\n        NAME=`$CMK_NM conftest.o | grep \"FOO_FOO\"`\n        if test \"$NAME\" != \"\"\n        then\n          _cv_fortran_postfix=ALLCAPS\n          AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ALLCAPS, 1, [ALLCAPS])\n        else\n          echo \"#################################################\"\n          echo \"FORTRAN compiler generated name not supported yet\"\n          echo \"#################################################\"\n        fi\n      fi\n    fi\n  fi\n  rm -f conftest.f conftest.o\n  )\n  AC_MSG_RESULT($_cv_fortran_postfix)\nelse\n  AC_MSG_RESULT(\"Fortran compiler not working\")\nfi\n\n### check module name ###\n\nif test \"$USE_FORTRAN90\" = 1\nthen\n  cat > conftest.f90 <<EOF\n      MODULE testmod\n        interface \n          function fpup_issizing(p)\n          INTEGER :: p\n          logical fpup_issizing\n          end function\n        end interface\n      END MODULE\nEOF\n  AC_MSG_CHECKING(Fortran 90 mod name is capital)\n  $CMK_CF90 -c conftest.f90 > /dev/null 2> /dev/null\n  name=`ls TESTMOD.* 2>/dev/null`\n  if test -n \"$name\"\n  then\n        AC_MSG_RESULT(\"yes\")\n\tadd_flag 'CMK_MOD_NAME_ALLCAPS=1' \"mod name capital\"\n  else\n        AC_MSG_RESULT(\"no\")\n\tname=`ls testmod.* 2>/dev/null`\n  fi\n  if test -n \"$name\"\n  then\n  \tAC_MSG_CHECKING(Fortran 90 mod name extension)\n    \text=`echo $name | sed -e 's/^[[^.]]*\\.//'`\n\tadd_flag 'CMK_MOD_EXT=\"'$ext'\"' \"mod name extension\"\n        AC_MSG_RESULT(\"$ext\")\n        /bin/rm -f $name\n  fi\n  /bin/rm -f conftest.f90\nfi\n\nAC_OUTPUT(\nlibs/ck-libs/ampi/ampiCC libs/ck-libs/ampi/ampirun,\n\nchmod +x libs/ck-libs/ampi/ampiCC libs/ck-libs/ampi/ampirun\n)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/libs/ck-libs/parmetis/Manual/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/arch/mpi-bluegenel/libxlfmath.a",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/ck-cp/NelderMeadStateDiagram.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/langs/charj/lib/JSAP-2.1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/langs/charj/lib/antlr-3.2.jar",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/langs/charj/lib/ant-antlr3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/src/ck-ldb/GridCommRefineLB.C",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/tests/charm++/simplearrayhello/msvc_6/hello.opt",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/examples/charm++/wave2d/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/examples/charm++/satisfiability/TNM/TNM.C",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/examples/charm++/satisfiability/TNM/TNM.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/examples/bigsim/tools/text2log/examples.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/examples/pose/LBSim/sample-graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/charisma/libmodule.tex",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/netfem/fig/example.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/create_field.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/ghost_edge.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/simple_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/ghost_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/conn_indexing_old.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/partitioned_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/forcedecomp.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/sym_ghost.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/ghost_pre.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/conn_indexing.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/fem/fig/indexlists.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/charj/fig/fig0.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/charj/fig/fig1.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/manual.tex",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/cache.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/prac.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/migrate.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/ratio.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/virtualization.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/ampi/figs/global.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/timeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_512_CommTimeProfile.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_128_userEventsView.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/front-with-summary.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_512_overviewEPColored.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/histogram.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_512_overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/piechart.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/mainwindow.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/outlier_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_512_CommProcessorProfile.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/animation.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/viewlog.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/usageprofile.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/NoiseMiner1.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/NoiseMiner2.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/commhistogram.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/userevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/apoa1_512_outlierWithClusters.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/timeprofile.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/standard_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/projections/fig/overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bignetsim/figures/detailedsim_newer.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/mblock/fig/ghostwidth.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/mblock/fig/indexing.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/mblock/fig/nodeloc.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/mblock/fig/terminology.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/mblock/fig/decompose.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/charm++/fig/pup.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/charm++/fig/ckgraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/snapshot4-crop.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/snapshot4.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/memoryLeaking.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/snapshot1.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/memoryView.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/snapshot2.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/arrayelement.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/snapshot3.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/memoryStatistics.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/debugger/figs/memoryInspector.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram2.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/InterpolationFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/detailedsim_newer.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/InterpolationFlow.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/event_diagram2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/bigsim/figures/InterpolationFlow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/parfum/fig/parfum_structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-charmpp-6.5.1-vmxlb3mqrekpx7rtx2xbawobo2emkpma/spack-src/doc/assets/hatchbkgd.png"
    ],
    "total_files": 4247
}