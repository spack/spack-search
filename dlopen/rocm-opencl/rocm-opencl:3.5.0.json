{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.5.0-2xa4n7bcfhfymr3oqvr5blkv4v6m3wav/spack-src/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.5.0-2xa4n7bcfhfymr3oqvr5blkv4v6m3wav/spack-src/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    return dlopen (libraryName, RTLD_NOW);\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [],
    "total_files": 194
}