{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/pal/paldevicegl.cpp": "/* Copyright (c) 2015-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"platform/context.hpp\"\n#include \"device/device.hpp\"\n#include \"platform/runtime.hpp\"\n#include \"platform/agent.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"CL/cl_d3d10.h\"\n#include \"CL/cl_d3d11.h\"\n#endif  // _WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#include \"paldevice.hpp\"\n//#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n\n/**\n * Device information returned by Mesa/Orca.\n */\ntypedef struct _mesa_glinterop_device_info {\n  uint32_t size; /* size of this structure */\n\n  /* PCI location */\n  uint32_t pci_segment_group;\n  uint32_t pci_bus;\n  uint32_t pci_device;\n  uint32_t pci_function;\n\n  /* Device identification */\n  uint32_t vendor_id;\n  uint32_t device_id;\n} mesa_glinterop_device_info;\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress pfnGlxGetProcAddress = nullptr;\ntypedef int(APIENTRYP PFNMesaGLInteropGLXQueryDeviceInfo)(Display* dpy, GLXContext context,\n                                                          mesa_glinterop_device_info* out);\nstatic PFNMesaGLInteropGLXQueryDeviceInfo pfnMesaGLInteropGLXQueryDeviceInfo = nullptr;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = nullptr;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = nullptr;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = nullptr;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = nullptr;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = nullptr;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = nullptr;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = nullptr;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = nullptr;\n#endif\n\nnamespace pal {\n\n//\n/// GSL Surface Formats as per defined in cmSurfFmtEnum enum in\n/// //depot/stg/ugl/drivers/ugl/src/include/cm_enum.h\n//\ntypedef enum cmSurfFmtEnum {\n  CM_SURF_FMT_NOOVERRIDE = -1,\n  CM_SURF_FMT_LUMINANCE8,    ///< Luminance,  8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16,   ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F,  ///< Luminance, 32 bits per element packed as (@c\n                             ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8,    ///< Intensity,  8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16,   ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY16F,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY32F,  ///< Intensity, 32 bits per element packed as (@c\n                             ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8,        ///< Alpha,      8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16,       ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA16F,      ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA32F,      ///< Alpha,     32 bits per element packed as (@c\n                             ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE8_ALPHA8,      ///< Luminance Alpha, 16 bits per element packed as (@c\n                                      ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_ALPHA16,    ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F_ALPHA16F,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F_ALPHA32F,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_B2_G3_R3,  ///< RGB,    8 bits per element packed as (@c RRRGGGBB)\n  CM_SURF_FMT_B5_G6_R5,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n  CM_SURF_FMT_BGRX4,     ///< RGB,   16 bits per element packed as (@c XXXXRRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_X1,   ///< RGB,   16 bits per element packed as (@c XRRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXRRRRRRRRGGGGGGGGBBBBBBBB) - XXX unused by current driver\n  CM_SURF_FMT_BGR10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXRRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX4,     ///< RGB,   16 bits per element packed as (@c XXXXBBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_X1,   ///< RGB,   16 bits per element packed as (@c XBBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXBBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_BGRA4,     ///< RGBA,  16 bits per element packed as (@c AAAARRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_A1,   ///< RGBA,  16 bits per element packed as (@c ARRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB)\n  CM_SURF_FMT_BGR10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBA4,     ///< RGBA,  16 bits per element packed as (@c AAAABBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_A1,   ///< RGBA,  16 bits per element packed as (@c ABBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32I,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32F,  ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_DUDV8,    ///< DUDV   16 bits per element packed as (@c VVVVVVVVUUUUUUUU)\n  CM_SURF_FMT_DXT1,     ///< compressed, DXT1\n  CM_SURF_FMT_DXT2_3,   ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5,   ///< compressed, DXT4_5\n  CM_SURF_FMT_ATI1N,    ///< compressed, 1 component\n  CM_SURF_FMT_ATI2N,    ///< compressed, 2 component\n  CM_SURF_FMT_DEPTH16,  ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH16F,            ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_X8,          ///< depth, 32 bits per element packed as (@c\n                                   ///< XXXXXXXXDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_X8,         ///< depth, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_STEN8,       ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_STEN8,      ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_X24_STEN8,  ///< depth + stencil, 64 bits per element packed as (@c\n                                   ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F,        ///< depth, 32 bits per element packed as (@c\n                               ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_sR11_sG11_sB10,  ///< RGB,   32 bits per element packed as (@c\n                               ///< RRRRRRRRRRRGGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_sU16,            ///<\n  CM_SURF_FMT_sUV16,           ///<\n  CM_SURF_FMT_sUVWQ16,         ///<\n  CM_SURF_FMT_RG16,  ///< RG,    32 bits per element packed as (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG16F,     ///< RG,    32 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG32F,     ///< RG,    64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_ABGR4,     ///< RGBA,  16 bits per element packed as (@c RRRRGGGGBBBBAAAA)\n  CM_SURF_FMT_A1_BGR5,   ///< RGBA,  16 bits per element packed as (@c RRRRRGGGGGBBBBBA)\n  CM_SURF_FMT_ABGR8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_A2_BGR10,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_ABGR16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_DXT1A,\n  CM_SURF_FMT_sRGB10_A2,  ///< RGBA,  32  bits per element packed as signed (@c\n                          ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_sR8,        ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_sRG8,       ///< RG,    16  bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sR32I,      ///< R,     32  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRG32I,     ///< RG,    64  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRGBA32I,   ///< RGBA,  128 bits per element packed as signed (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_R32I,    ///< R,     32  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG32I,   ///< RG,    64  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG8,     ///< RG8,   16 bits per element packed as (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRGBA8,  ///< RGBA8, 32 bits per element packed as signed (@c\n                       ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_R11F_G11F_B10F,                ///< RGB,   32 bits per element packed as (@c\n                                             ///< BBBBBBBBBBGGGGGGGGGGGRRRRRRRRRRR)\n  CM_SURF_FMT_RGB9_E5,                       ///< RGB,   32 bits per element packed as (@c\n                                             ///< EEEEEBBBBBBBBBGGGGGGGGGRRRRRRRRR)\n  CM_SURF_FMT_LUMINANCE_LATC1,               ///< compressed LATC1\n  CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,        ///< compressed signed LATC1\n  CM_SURF_FMT_LUMINANCE_ALPHA_LATC2,         ///< compressed LATC2\n  CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2,  ///< compressed signed LATC2\n  CM_SURF_FMT_RED_RGTC1,                     ///< compressed RGTC1\n  CM_SURF_FMT_SIGNED_RED_RGTC1,              ///< compressed signed RGTC1\n  CM_SURF_FMT_RED_GREEN_RGTC2,               ///< compressed RGTC2\n  CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,        ///< compressed signed RGTC2\n  CM_SURF_FMT_R8,                            ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_R16,     ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R16F,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R32F,    ///< R,    32   bits per element packed (@c RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R8I,     ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_sR8I,    ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_RG8I,    ///< RG,   16   bits per element packed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRG8I,   ///< RG,   16   bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_R16I,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sR16I,   ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG16I,   ///< RG,   32   bits per element packed (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRG16I,  ///< RG,   32   bits per element packed as signed (@c\n                       ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBA32UI,  ///< RGBA, 128 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX32UI,  ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_ALPHA32UI,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY32UI,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE32UI,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA32UI,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA16UI,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16UI,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_ALPHA16UI,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY16UI,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE16UI,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16UI,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA8UI,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX8UI,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_ALPHA8UI,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_INTENSITY8UI,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_LUMINANCE8UI,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA8UI,   ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_sRGBX32I,             ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_sALPHA32I,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY32I,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE32I,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA32I,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA16I,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRGBX16I,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sALPHA16I,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY16I,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE16I,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA16I,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA8I,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sRGBX8I,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sALPHA8I,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sINTENSITY8I,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_sLUMINANCE8I,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA8I,   ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sDXT6,                ///< compressed, CM_SURF_FMT_sDXT6\n  CM_SURF_FMT_DXT6,                 ///< compressed, CM_SURF_FMT_DXT6\n  CM_SURF_FMT_DXT7,                 ///< compressed, DXT7\n  CM_SURF_FMT_LUMINANCE8_SNORM,   ///< Luminance,  8 bits per element packed as signed (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_SNORM,  ///< Luminance, 16 bits per element packed as signed (@c\n                                  ///< LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8_SNORM,   ///< Intensity,  8 bits per element packed as signed (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16_SNORM,  ///< Intensity, 16 bits per element packed as signed (@c\n                                  ///< IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8_SNORM,       ///< Alpha,      8 bits per element packed as signed (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16_SNORM,      ///< Alpha,     16 bits per element packed as signed (@c\n                                  ///< AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,   ///< Luminance Alpha, 16 bits per element packed as signed\n                                        ///< (@c AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,  ///< Luminance Alpha, 32 bits per element packed as signed\n                                        ///< (@c AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_R8_SNORM,      ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_R16_SNORM,     ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG8_SNORM,     ///< RG8,   16 bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_RG16_SNORM,    ///< RG,    32 bits per element packed as signed (@c\n                             ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBX8_SNORM,   ///< RGB,   32 bits per element packed as signed (@c\n                             ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX16_SNORM,  ///< RGB,   64 bits per element packed as signed (@c\n                             ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SNORM,   ///< RGBA,  32 bits per element packed as signed (@c\n                             ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA16_SNORM,  ///< RGBA,  64 bits per element packed as signed (@c\n                             ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2UI,    ///< RGBA,  32 bits per element packed as (@c\n                             ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGB32F,        ///< RGB, float, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32I,  ///< RGB, unnormalized int, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32UI,  ///< RGB, unnormalized uint, 96 bits per element packed as (@c\n                        ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX8_SRGB,             ///< RGB,   32 bits per element packed as (@c\n                                      ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SRGB,             ///< RGBA,  32 bits per element packed as (@c\n                                      ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_DXT1_SRGB,              ///< compressed, DXT1\n  CM_SURF_FMT_DXT1A_SRGB,             ///<\n  CM_SURF_FMT_DXT2_3_SRGB,            ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5_SRGB,            ///< compressed, DXT4_5\n  CM_SURF_FMT_DXT7_SRGB,              ///< compressed, DXT7\n  CM_SURF_FMT_RGB8_ETC2,              ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_ETC2,             ///< ETC2 compressed, SRGB8 in 64 bits\n  CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   ///< ETC2 compressed, sRGB8A1 in 64 bits\n  CM_SURF_FMT_RGBA8_ETC2_EAC,         ///< ETC2 compressed, RGBA8 in 128 bits\n  CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  ///< ETC2 compressed, sRGBA8 in 128 bits\n  CM_SURF_FMT_R11_EAC,                ///< EAC compressed, R11 in 64 bits\n  CM_SURF_FMT_SIGNED_R11_EAC,         ///< EAC compressed, signed R11 in 64 bits\n  CM_SURF_FMT_RG11_EAC,               ///< EAC compressed, RG11 in 128 bits\n  CM_SURF_FMT_SIGNED_RG11_EAC,        ///< EAC compressed, signed RG11 in 128 bits\n\n  CM_SURF_FMT_RGBA8_ASTC_4x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x8,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x5,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x6,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x8,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x12,  ///< ASTC compressed RGBA8 in 128 bits block\n\n  CM_SURF_FMT_SRGBA8_ASTC_4x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x8,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x5,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x6,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x8,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x12,  ///< ASTC compressed SRGBA8 in 128 bits block\n\n  CM_SURF_FMT_BGR10_A2UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_A2_BGR10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_A2_RGB10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< BBBBBBBBBBGGGGGGGGGGRRRRRRRRRRAA)\n  CM_SURF_FMT_B5_G6_R5UI,  ///< RGB,   16 bits per element packed as (@c BBBBBGGGGGGRRRRR)\n  CM_SURF_FMT_R5_G6_B5UI,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n\n  CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED,  ///< depth + stencil, 64 bits per element packed as (@c\n                                             ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_UNCLAMPED,  ///< depth, 32 bits per element packed as (@c\n                                   ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n\n  CM_SURF_FMT_L8_X16_A8_SRGB,  ///< Sluminance Alpha,  32 bits per element packed as (@c\n                               ///< AAAAAAAAXXXXXXXXXXXXXXXXLLLLLLLL)\n  CM_SURF_FMT_L8_X24_SRGB,     ///< Sluminance,        32 bits per element packed as (@c\n                               ///< XXXXXXXXXXXXXXXXXXXXXXXXLLLLLLLL)\n\n  CM_SURF_FMT_STENCIL8,  ///< stencil, 32 bits per element packed as (@c\n                         ///< SSSSSSSSXXXXXXXXXXXXXXXXXXXXXXXX)\n\n\n  // non-native surface formats after this line, will be ignored by HWL\n  // all non-native surface formats should use the _NN suffix to distinguish\n  // them from potential corresponding native formats added in the future\n  CM_SURF_FMT_I420_NN,                              ///< 4:2:0 Planar Y-U-V format\n  CM_SURF_FMT_YV12_NN,                              ///< 4:2:0 Planar Y-V-U format\n  CM_SURF_FMT_NV12_NN,                              ///< 4:2:0 Semi-planar Y-UV format\n  CM_SURF_FMT_NV21_NN,                              ///< 4:2:0 Semi-planar Y-VU format\n  cmSurfFmt_FIRST = CM_SURF_FMT_LUMINANCE8,         ///< First surface format\n  cmSurfFmt_LAST = CM_SURF_FMT_STENCIL8,            ///< Last native surface format\n  cmSurfFmt_LAST_NON_NATIVE = CM_SURF_FMT_NV21_NN,  ///< Last non-native surface format\n} cmSurfFmt;\n\ntypedef struct cmFormatXlateRec {\n  cmSurfFmt raw_cmFormat;\n  cl_channel_type image_channel_data_type;\n  cl_channel_order image_channel_order;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic const cmFormatXlateParams cmFormatXlateTable[] = {\n    {CM_SURF_FMT_LUMINANCE8, CL_UNORM_INT8, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16, CL_UNORM_INT16, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16F, CL_HALF_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE32F, CL_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_INTENSITY8, CL_UNORM_INT8, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16, CL_UNORM_INT16, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16F, CL_HALF_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY32F, CL_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_ALPHA8, CL_UNSIGNED_INT8, CL_A},\n    {CM_SURF_FMT_ALPHA16, CL_UNORM_INT16, CL_A},\n    {CM_SURF_FMT_ALPHA16F, CL_HALF_FLOAT, CL_A},\n    {CM_SURF_FMT_ALPHA32F, CL_FLOAT, CL_A},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_B2_G3_R3, 500, CL_R},\n    {CM_SURF_FMT_B5_G6_R5, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_X1, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_X2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_BGRX16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRX16F, CL_HALF_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_BGRX32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBX4, 500, CL_RGB},\n    {CM_SURF_FMT_RGB5_X1, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_RGBX8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_X2, CL_UNORM_INT_101010, CL_RGBA},\n    {CM_SURF_FMT_RGBX16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBX32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_BGRA4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_A1, CL_UNSIGNED_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_A2, 500, CL_BGRA},\n    {CM_SURF_FMT_BGRA16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA16F, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBA4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB5_A1, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_RGBA16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBA32I, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBA32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_DUDV8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_DXT1, 500, CL_R},\n    {CM_SURF_FMT_DXT2_3, 500, CL_R},\n    {CM_SURF_FMT_DXT4_5, 500, CL_R},\n    {CM_SURF_FMT_ATI1N, 500, CL_R},\n    {CM_SURF_FMT_ATI2N, 500, CL_R},\n    {CM_SURF_FMT_DEPTH16, CL_UNORM_INT16, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH16F, CL_HALF_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24F_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_STEN8, CL_UNORM_INT24, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH24F_STEN8, 500, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8, CL_FLOAT, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F, CL_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_sR11_sG11_sB10, 500, CL_R},\n    {CM_SURF_FMT_sU16, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_sUV16, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_sUVWQ16, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RG16, CL_UNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RG16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_RG32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_ABGR4, 500, CL_ARGB},\n    {CM_SURF_FMT_A1_BGR5, CL_UNSIGNED_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR8, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_A2_BGR10, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_ABGR16, CL_UNORM_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR16F, CL_HALF_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_ABGR32F, CL_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_DXT1A, 500, CL_R},\n    {CM_SURF_FMT_sRGB10_A2, 500, CL_RGBA},\n    {CM_SURF_FMT_sR8, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_sRG8, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sR32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sRG32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_R32I, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_RG32I, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RG8, CL_UNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBA8, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB9_E5, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_R8, CL_UNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16, CL_UNORM_INT16, CL_R},\n    {CM_SURF_FMT_R16F, CL_HALF_FLOAT, CL_R},\n    {CM_SURF_FMT_R32F, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_R8I, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sR8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_RG8I, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRG8I, CL_SIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_R16I, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sR16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_RG16I, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRG16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_RGBA32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBX32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_ALPHA32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_INTENSITY32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_ALPHA16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA8UI, CL_UNSIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX8UI, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_ALPHA8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBX32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_sALPHA32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sINTENSITY32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sRGBX16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sALPHA16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sINTENSITY16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRGBA8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sRGBX8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sALPHA8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sINTENSITY8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I, CM_SURF_FMT_sRG8I, CL_RG},\n    {CM_SURF_FMT_sDXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT7, 500, CL_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_ALPHA8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_ALPHA16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_R8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_RG8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_RG16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RGBX8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32I, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBX8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1A_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT2_3_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT4_5_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT7_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI, 500, CL_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI, 500, CL_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI, 500, CL_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI, 500, CL_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI, 500, CL_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_STENCIL8, CL_UNSIGNED_INT8, CL_R},\n};\n\nbool Device::initGLInteropPrivateExt(void* GLplatformContext, void* GLdeviceContext) const {\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  void* pModule = dlopen(\"libGL.so.1\", RTLD_NOW);\n\n  if (nullptr == pModule) {\n    return false;\n  }\n  pfnGlxGetProcAddress = (PFNGlxGetProcAddress)dlsym(pModule, \"glXGetProcAddress\");\n  if (nullptr == pfnGlxGetProcAddress) {\n    return false;\n  }\n\n  pfnMesaGLInteropGLXQueryDeviceInfo =\n      (PFNMesaGLInteropGLXQueryDeviceInfo)dlsym(pModule, \"MesaGLInteropGLXQueryDeviceInfo\");\n  if (nullptr == pfnMesaGLInteropGLXQueryDeviceInfo) {\n    return false;\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXBeginCLInteroperabilityAMD\");\n    glXEndCLInteropAMD =\n        (PFNGLXENDCLINTEROPAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXEndCLInteroperabilityAMD\");\n    glXResourceAttachAMD =\n        (PFNGLXRESOURCEATTACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAttachAMD\");\n    glxResourceAcquireAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAcquireAMD\");\n    glxResourceReleaseAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceReleaseAMD\");\n    glXResourceDetachAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceDetachAMD\");\n    glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXGetContextMVPUInfoAMD\");\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    return false;\n  }\n#else\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    HGLRC fakeRC = nullptr;\n\n    if (!wglGetCurrentContext()) {\n      fakeRC = wglCreateContext((HDC)GLdeviceContext);\n      wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n    }\n\n    wglBeginCLInteropAMD =\n        (PFNWGLBEGINCLINTEROPAMD)wglGetProcAddress(\"wglBeginCLInteroperabilityAMD\");\n    wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD)wglGetProcAddress(\"wglEndCLInteroperabilityAMD\");\n    wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD)wglGetProcAddress(\"wglResourceAttachAMD\");\n    wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceAcquireAMD\");\n    wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceReleaseAMD\");\n    wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceDetachAMD\");\n    wglGetContextGPUInfoAMD =\n        (PFNWGLGETCONTEXTGPUINFOAMD)wglGetProcAddress(\"wglGetContextGPUInfoAMD\");\n\n    if (fakeRC) {\n      wglMakeCurrent(nullptr, nullptr);\n      wglDeleteContext(fakeRC);\n    }\n  }\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    return false;\n  }\n#endif\n  return true;\n}\n\nbool Device::glCanInterop(void* GLplatformContext, void* GLdeviceContext) const {\n  bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n  LUID glAdapterLuid = {0, 0};\n  UINT glChainBitMask = 0;\n  HGLRC hRC = (HGLRC)GLplatformContext;\n\n  // get GL context's LUID and chainBitMask from UGL\n  if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask)) {\n    // match the adapter\n    canInteroperate = (properties().osProperties.luidHighPart == glAdapterLuid.HighPart) &&\n        (properties().osProperties.luidLowPart == glAdapterLuid.LowPart) &&\n        ((1 << properties().gpuIndex) == glChainBitMask);\n  }\n#else\n  GLuint glDeviceId = 0;\n  GLuint glChainMask = 0;\n  GLXContext ctx = static_cast<GLXContext>(GLplatformContext);\n  Display* disp = static_cast<Display*>(GLdeviceContext);\n\n\n  if (glXGetContextMVPUInfoAMD(ctx, &glDeviceId, &glChainMask)) {\n    mesa_glinterop_device_info info = {};\n    if (pfnMesaGLInteropGLXQueryDeviceInfo(disp, ctx, &info) == 0) {\n      // match the adapter\n      canInteroperate = (properties().pciProperties.busNumber == info.pci_bus) &&\n          (properties().pciProperties.deviceNumber == info.pci_device) &&\n          (properties().pciProperties.functionNumber == info.pci_function) &&\n          (static_cast<GLuint>(1 << properties().gpuIndex) == glChainMask);\n    }\n  }\n#endif\n  return canInteroperate;\n}\n\nbool Device::glAssociate(void* GLplatformContext, void* GLdeviceContext) const {\n  // initialize pointers to the gl extension that supports interoperability\n  if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n      !glCanInterop(GLplatformContext, GLdeviceContext)) {\n    return false;\n  }\n\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglBeginCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::glDissociate(void* GLplatformContext, void* GLdeviceContext) const {\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglEndCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::resGLAssociate(void* GLContext, uint name, uint type, Pal::OsExternalHandle* handle,\n                            void** mbResHandle, size_t* offset, cl_image_format& newClFormat\n#ifdef ATI_OS_WIN\n                            ,\n                            Pal::DoppDesktopInfo& doppDesktopInfo\n#endif\n                            ) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  GLResourceData hData = {};\n\n  bool status = false;\n\n  hRes.type = type;\n  hRes.name = name;\n\n  hData.version = GL_RESOURCE_DATA_VERSION;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLContext;\n  if (glXResourceAttachAMD(ctx, &hRes, &hData)) {\n    status = true;\n  }\n#else\n  HGLRC hRC = (HGLRC)GLContext;\n  if (wglResourceAttachAMD(hRC, &hRes, &hData)) {\n    status = true;\n  }\n#endif\n\n  if (!status) {\n    return false;\n  }\n\n  *mbResHandle = reinterpret_cast<void*>(hData.mbResHandle);\n  *offset = static_cast<size_t>(hData.offset);\n#ifdef ATI_OS_WIN\n  *handle = reinterpret_cast<Pal::OsExternalHandle>(hData.handle);\n  if (hData.isDoppDesktopTexture) {\n    doppDesktopInfo.gpuVirtAddr = hData.cardAddr;\n    doppDesktopInfo.vidPnSourceId = hData.vidpnSourceId;\n  } else {\n    doppDesktopInfo.gpuVirtAddr = 0;\n    doppDesktopInfo.vidPnSourceId = 0;\n  }\n#else\n  *handle = static_cast<Pal::OsExternalHandle>(hData.sharedBufferID);\n#endif\n\n  // OCL supports only a limited number of cm_surf formats, so we\n  // have to translate incoming cm_surf formats\n  uint index = hData.format - (uint)CM_SURF_FMT_LUMINANCE8;\n  if (index >= sizeof(cmFormatXlateTable) / sizeof(cmFormatXlateParams)) {\n    LogError(\"\\nInvalid GL surface reported in hData\\n\");\n    return status;\n  }\n  assert(static_cast<cmSurfFmt>(hData.format) == cmFormatXlateTable[index].raw_cmFormat);\n  cl_channel_type imageDataType;\n  imageDataType = cmFormatXlateTable[index].image_channel_data_type;\n  if (imageDataType == 500) {\n    LogError(\"\\nGL surface is not supported by OCL\\n\");\n    return status;\n  }\n\n  newClFormat.image_channel_data_type = cmFormatXlateTable[index].image_channel_data_type;\n  newClFormat.image_channel_order = cmFormatXlateTable[index].image_channel_order;\n\n  return status;\n}\n\nbool Device::resGLAcquire(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLRelease(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  // TODO : make sure the application GL context is current. if not no\n  // point calling into the GL RT.\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n  // Make the call into the GL driver only if the application GL context is current\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLFree(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\n}  // namespace pal\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/gpu/gslbe/src/rt/GSLDeviceGL.cpp": " /* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"gsl_ctx.h\"\n#include \"GSLDevice.h\"\n#include \"component_types.h\"\n#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n#include \"memory/MemObject.h\"\n\ntypedef struct cmFormatXlateRec{\n    cmSurfFmt   raw_cmFormat;\n    cmSurfFmt   cal_cmFormat;\n    gslChannelOrder channelOrder;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic const   cmFormatXlateParams cmFormatXlateTable [] = {\n    {CM_SURF_FMT_LUMINANCE8,            CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8,            CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_INTENSITY16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8,                CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16,               CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA32F,              CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8,     CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16,   CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_B2_G3_R3,              (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_B5_G6_R5,              CM_SURF_FMT_B5_G6_R5,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_X2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_X2,              CM_SURF_FMT_RGB10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGRA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16F,               CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32I,               CM_SURF_FMT_RGBA32I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DUDV8,                 CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_DXT1,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT2_3,                (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT4_5,                (cmSurfFmt)00,          GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI1N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI2N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH16,               CM_SURF_FMT_DEPTH16,    GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_X8,            (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24F_X8,           (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_STEN8,         CM_SURF_FMT_DEPTH24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH24F_STEN8,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8,    CM_SURF_FMT_DEPTH32F_X24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F,              CM_SURF_FMT_DEPTH32F,   GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_sR11_sG11_sB10,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sU16,                  CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sUV16,                 CM_SURF_FMT_sUV16,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sUVWQ16,               CM_SURF_FMT_sUVWQ16,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RG16,                  CM_SURF_FMT_RG16,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16F,                 CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG32F,                 CM_SURF_FMT_RG32F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_ABGR4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A1_BGR5,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_BGR10,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_DXT1A,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRGB10_A2,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sR8,                   CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG8,                  CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sR32I,                 CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG32I,                CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R32I,                  CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_RG32I,                 CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG8,                   CM_SURF_FMT_RG8,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8,                CM_SURF_FMT_sRGBA8,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB9_E5,               CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,  GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_RGTC1,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1,      (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R8,                    CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16,                   CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16F,                  CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R32F,                  CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8I,                   CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR8I,                  CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8I,                  CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG8I,                 CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R16I,                  CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR16I,                 CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG16I,                 CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG16I,                CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA32UI,             CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI,   CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA16UI,             CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI,   CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA8UI,              CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI,    CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    {CM_SURF_FMT_sRGBA32I_EXT,          CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n#endif\n    {CM_SURF_FMT_sRGBX32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA32I,             CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I,   CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA16I,             CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I,   CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA8I,              CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I,    CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sDXT6,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT6,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT7,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8_SNORM,          CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16_SNORM,         CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R8_SNORM,               CM_SURF_FMT_sR8,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16_SNORM,              CM_SURF_FMT_sU16,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SNORM,              CM_SURF_FMT_sRG8,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16_SNORM,             CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBX8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2,              (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11_EAC,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG11_EAC,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC,        (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CM_SURF_FMT_RG32I, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED,    CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB,            (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_STENCIL8,               CM_SURF_FMT_R8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_L8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SRGB,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    };\n\nFINLINE void\ndummyAssertIfCmSurfFmtChanges(void)\n{\n    //\n    //  Assert if cmSurfFmt defined in ugl/src/include/cmndefs.h changes.\n    //\n    COMPILE_TIME_ASSERT(cmSurfFmt_FIRST == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  0 == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  1 == CM_SURF_FMT_LUMINANCE16);\n    COMPILE_TIME_ASSERT(  2 == CM_SURF_FMT_LUMINANCE16F);\n    COMPILE_TIME_ASSERT(  3 == CM_SURF_FMT_LUMINANCE32F);\n    COMPILE_TIME_ASSERT(  4 == CM_SURF_FMT_INTENSITY8);\n    COMPILE_TIME_ASSERT(  5 == CM_SURF_FMT_INTENSITY16);\n    COMPILE_TIME_ASSERT(  6 == CM_SURF_FMT_INTENSITY16F);\n    COMPILE_TIME_ASSERT(  7 == CM_SURF_FMT_INTENSITY32F);\n    COMPILE_TIME_ASSERT(  8 == CM_SURF_FMT_ALPHA8);\n    COMPILE_TIME_ASSERT(  9 == CM_SURF_FMT_ALPHA16);\n    COMPILE_TIME_ASSERT( 10 == CM_SURF_FMT_ALPHA16F);\n    COMPILE_TIME_ASSERT( 11 == CM_SURF_FMT_ALPHA32F);\n    COMPILE_TIME_ASSERT( 12 == CM_SURF_FMT_LUMINANCE8_ALPHA8);\n    COMPILE_TIME_ASSERT( 13 == CM_SURF_FMT_LUMINANCE16_ALPHA16);\n    COMPILE_TIME_ASSERT( 14 == CM_SURF_FMT_LUMINANCE16F_ALPHA16F);\n    COMPILE_TIME_ASSERT( 15 == CM_SURF_FMT_LUMINANCE32F_ALPHA32F);\n    COMPILE_TIME_ASSERT( 16 == CM_SURF_FMT_B2_G3_R3);\n    COMPILE_TIME_ASSERT( 17 == CM_SURF_FMT_B5_G6_R5);\n    COMPILE_TIME_ASSERT( 18 == CM_SURF_FMT_BGRX4);\n    COMPILE_TIME_ASSERT( 19 == CM_SURF_FMT_BGR5_X1);\n    COMPILE_TIME_ASSERT( 20 == CM_SURF_FMT_BGRX8);\n    COMPILE_TIME_ASSERT( 21 == CM_SURF_FMT_BGR10_X2);\n    COMPILE_TIME_ASSERT( 22 == CM_SURF_FMT_BGRX16);\n    COMPILE_TIME_ASSERT( 23 == CM_SURF_FMT_BGRX16F);\n    COMPILE_TIME_ASSERT( 24 == CM_SURF_FMT_BGRX32F);\n    COMPILE_TIME_ASSERT( 25 == CM_SURF_FMT_RGBX4);\n    COMPILE_TIME_ASSERT( 26 == CM_SURF_FMT_RGB5_X1);\n    COMPILE_TIME_ASSERT( 27 == CM_SURF_FMT_RGBX8);\n    COMPILE_TIME_ASSERT( 28 == CM_SURF_FMT_RGB10_X2);\n    COMPILE_TIME_ASSERT( 29 == CM_SURF_FMT_RGBX16);\n    COMPILE_TIME_ASSERT( 30 == CM_SURF_FMT_RGBX16F);\n    COMPILE_TIME_ASSERT( 31 == CM_SURF_FMT_RGBX32F);\n    COMPILE_TIME_ASSERT( 32 == CM_SURF_FMT_BGRA4);\n    COMPILE_TIME_ASSERT( 33 == CM_SURF_FMT_BGR5_A1);\n    COMPILE_TIME_ASSERT( 34 == CM_SURF_FMT_BGRA8);\n    COMPILE_TIME_ASSERT( 35 == CM_SURF_FMT_BGR10_A2);\n    COMPILE_TIME_ASSERT( 36 == CM_SURF_FMT_BGRA16);\n    COMPILE_TIME_ASSERT( 37 == CM_SURF_FMT_BGRA16F);\n    COMPILE_TIME_ASSERT( 38 == CM_SURF_FMT_BGRA32F);\n    COMPILE_TIME_ASSERT( 39 == CM_SURF_FMT_RGBA4);\n    COMPILE_TIME_ASSERT( 40 == CM_SURF_FMT_RGB5_A1);\n    COMPILE_TIME_ASSERT( 41 == CM_SURF_FMT_RGBA8);\n    COMPILE_TIME_ASSERT( 42 == CM_SURF_FMT_RGB10_A2);\n    COMPILE_TIME_ASSERT( 43 == CM_SURF_FMT_RGBA16);\n    COMPILE_TIME_ASSERT( 44 == CM_SURF_FMT_RGBA16F);\n    COMPILE_TIME_ASSERT( 45 == CM_SURF_FMT_RGBA32I);\n    COMPILE_TIME_ASSERT( 46 == CM_SURF_FMT_RGBA32F);\n    COMPILE_TIME_ASSERT( 47 == CM_SURF_FMT_DUDV8);\n    COMPILE_TIME_ASSERT( 48 == CM_SURF_FMT_DXT1);\n    COMPILE_TIME_ASSERT( 49 == CM_SURF_FMT_DXT2_3);\n    COMPILE_TIME_ASSERT( 50 == CM_SURF_FMT_DXT4_5);\n    COMPILE_TIME_ASSERT( 51 == CM_SURF_FMT_ATI1N);\n    COMPILE_TIME_ASSERT( 52 == CM_SURF_FMT_ATI2N);\n    COMPILE_TIME_ASSERT( 53 == CM_SURF_FMT_DEPTH16);\n    COMPILE_TIME_ASSERT( 54 == CM_SURF_FMT_DEPTH16F);\n    COMPILE_TIME_ASSERT( 55 == CM_SURF_FMT_DEPTH24_X8);\n    COMPILE_TIME_ASSERT( 56 == CM_SURF_FMT_DEPTH24F_X8);\n    COMPILE_TIME_ASSERT( 57 == CM_SURF_FMT_DEPTH24_STEN8);\n    COMPILE_TIME_ASSERT( 58 == CM_SURF_FMT_DEPTH24F_STEN8);\n    COMPILE_TIME_ASSERT( 59 == CM_SURF_FMT_DEPTH32F_X24_STEN8);\n    COMPILE_TIME_ASSERT( 60 == CM_SURF_FMT_DEPTH32F);\n    COMPILE_TIME_ASSERT( 61 == CM_SURF_FMT_sR11_sG11_sB10);\n    COMPILE_TIME_ASSERT( 62 == CM_SURF_FMT_sU16);\n    COMPILE_TIME_ASSERT( 63 == CM_SURF_FMT_sUV16);\n    COMPILE_TIME_ASSERT( 64 == CM_SURF_FMT_sUVWQ16);\n    COMPILE_TIME_ASSERT( 65 == CM_SURF_FMT_RG16);\n    COMPILE_TIME_ASSERT( 66 == CM_SURF_FMT_RG16F);\n    COMPILE_TIME_ASSERT( 67 == CM_SURF_FMT_RG32F);\n    COMPILE_TIME_ASSERT( 68 == CM_SURF_FMT_ABGR4);\n    COMPILE_TIME_ASSERT( 69 == CM_SURF_FMT_A1_BGR5);\n    COMPILE_TIME_ASSERT( 70 == CM_SURF_FMT_ABGR8);\n    COMPILE_TIME_ASSERT( 71 == CM_SURF_FMT_A2_BGR10);\n    COMPILE_TIME_ASSERT( 72 == CM_SURF_FMT_ABGR16);\n    COMPILE_TIME_ASSERT( 73 == CM_SURF_FMT_ABGR16F);\n    COMPILE_TIME_ASSERT( 74 == CM_SURF_FMT_ABGR32F);\n    COMPILE_TIME_ASSERT( 75 == CM_SURF_FMT_DXT1A);\n    COMPILE_TIME_ASSERT( 76 == CM_SURF_FMT_sRGB10_A2);\n    COMPILE_TIME_ASSERT( 77 == CM_SURF_FMT_sR8);\n    COMPILE_TIME_ASSERT( 78 == CM_SURF_FMT_sRG8);\n    COMPILE_TIME_ASSERT( 79 == CM_SURF_FMT_sR32I);\n    COMPILE_TIME_ASSERT( 80 == CM_SURF_FMT_sRG32I);\n    COMPILE_TIME_ASSERT( 81 == CM_SURF_FMT_sRGBA32I);\n    COMPILE_TIME_ASSERT( 82 == CM_SURF_FMT_R32I);\n    COMPILE_TIME_ASSERT( 83 == CM_SURF_FMT_RG32I);\n    COMPILE_TIME_ASSERT( 84 == CM_SURF_FMT_RG8);\n    COMPILE_TIME_ASSERT( 85 == CM_SURF_FMT_sRGBA8);\n    COMPILE_TIME_ASSERT( 86 == CM_SURF_FMT_R11F_G11F_B10F);\n    COMPILE_TIME_ASSERT( 87 == CM_SURF_FMT_RGB9_E5);\n    COMPILE_TIME_ASSERT( 88 == CM_SURF_FMT_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 89 == CM_SURF_FMT_SIGNED_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 90 == CM_SURF_FMT_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 91 == CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 92 == CM_SURF_FMT_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 93 == CM_SURF_FMT_SIGNED_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 94 == CM_SURF_FMT_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 95 == CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 96 == CM_SURF_FMT_R8);\n    COMPILE_TIME_ASSERT( 97 == CM_SURF_FMT_R16);\n    COMPILE_TIME_ASSERT( 98 == CM_SURF_FMT_R16F);\n    COMPILE_TIME_ASSERT( 99 == CM_SURF_FMT_R32F);\n    COMPILE_TIME_ASSERT(100 == CM_SURF_FMT_R8I);\n    COMPILE_TIME_ASSERT(101 == CM_SURF_FMT_sR8I);\n    COMPILE_TIME_ASSERT(102 == CM_SURF_FMT_RG8I);\n    COMPILE_TIME_ASSERT(103 == CM_SURF_FMT_sRG8I);\n    COMPILE_TIME_ASSERT(104 == CM_SURF_FMT_R16I);\n    COMPILE_TIME_ASSERT(105 == CM_SURF_FMT_sR16I);\n    COMPILE_TIME_ASSERT(106 == CM_SURF_FMT_RG16I);\n    COMPILE_TIME_ASSERT(107 == CM_SURF_FMT_sRG16I);\n    COMPILE_TIME_ASSERT(108 == CM_SURF_FMT_RGBA32UI);\n    COMPILE_TIME_ASSERT(109 == CM_SURF_FMT_RGBX32UI);\n    COMPILE_TIME_ASSERT(110 == CM_SURF_FMT_ALPHA32UI);\n    COMPILE_TIME_ASSERT(111 == CM_SURF_FMT_INTENSITY32UI);\n    COMPILE_TIME_ASSERT(112 == CM_SURF_FMT_LUMINANCE32UI);\n    COMPILE_TIME_ASSERT(113 == CM_SURF_FMT_LUMINANCE_ALPHA32UI);\n    COMPILE_TIME_ASSERT(114 == CM_SURF_FMT_RGBA16UI);\n    COMPILE_TIME_ASSERT(115 == CM_SURF_FMT_RGBX16UI);\n    COMPILE_TIME_ASSERT(116 == CM_SURF_FMT_ALPHA16UI);\n    COMPILE_TIME_ASSERT(117 == CM_SURF_FMT_INTENSITY16UI);\n    COMPILE_TIME_ASSERT(118 == CM_SURF_FMT_LUMINANCE16UI);\n    COMPILE_TIME_ASSERT(119 == CM_SURF_FMT_LUMINANCE_ALPHA16UI);\n    COMPILE_TIME_ASSERT(120 == CM_SURF_FMT_RGBA8UI);\n    COMPILE_TIME_ASSERT(121 == CM_SURF_FMT_RGBX8UI);\n    COMPILE_TIME_ASSERT(122 == CM_SURF_FMT_ALPHA8UI);\n    COMPILE_TIME_ASSERT(123 == CM_SURF_FMT_INTENSITY8UI);\n    COMPILE_TIME_ASSERT(124 == CM_SURF_FMT_LUMINANCE8UI);\n    COMPILE_TIME_ASSERT(125 == CM_SURF_FMT_LUMINANCE_ALPHA8UI);\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBA32I_EXT);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(224 == CM_SURF_FMT_RG8_SRGB);\n#else\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_RG8_SRGB);\n#endif\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST  == CM_SURF_FMT_RG8_SRGB);\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST < 501);\n}\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress    pfnGlxGetProcAddress=NULL;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = NULL;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = NULL;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = NULL;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = NULL;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = NULL;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = NULL;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = NULL;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = NULL;\n#endif\n\nbool\nCALGSLDevice::initGLInteropPrivateExt(CALvoid* GLplatformContext, CALvoid* GLdeviceContext) const\n{\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    void * pModule = dlopen(\"libGL.so.1\",RTLD_NOW);\n\n    if(NULL == pModule){\n        return false;\n    }\n    pfnGlxGetProcAddress = (PFNGlxGetProcAddress) dlsym(pModule,\"glXGetProcAddress\");\n\n    if (NULL == pfnGlxGetProcAddress){\n        return false;\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD)\n    {\n        glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXBeginCLInteroperabilityAMD\");\n        glXEndCLInteropAMD = (PFNGLXENDCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXEndCLInteroperabilityAMD\");\n        glXResourceAttachAMD = (PFNGLXRESOURCEATTACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAttachAMD\");\n        glxResourceAcquireAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAcquireAMD\");\n        glxResourceReleaseAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceReleaseAMD\");\n        glXResourceDetachAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceDetachAMD\");\n        glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXGetContextMVPUInfoAMD\");\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD\n#ifndef BRAHMA\n        || !glXGetContextMVPUInfoAMD\n#endif\n        )\n    {\n        return false;\n    }\n#else\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        HGLRC fakeRC = NULL;\n\n        if (!wglGetCurrentContext())\n        {\n            fakeRC = wglCreateContext((HDC)GLdeviceContext);\n            wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n        }\n\n        wglBeginCLInteropAMD = (PFNWGLBEGINCLINTEROPAMD) wglGetProcAddress (\"wglBeginCLInteroperabilityAMD\");\n        wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD) wglGetProcAddress (\"wglEndCLInteroperabilityAMD\");\n        wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD) wglGetProcAddress (\"wglResourceAttachAMD\");\n        wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceAcquireAMD\");\n        wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceReleaseAMD\");\n        wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceDetachAMD\");\n        wglGetContextGPUInfoAMD = (PFNWGLGETCONTEXTGPUINFOAMD) wglGetProcAddress (\"wglGetContextGPUInfoAMD\");\n\n        if (fakeRC)\n        {\n            wglMakeCurrent(NULL, NULL);\n            wglDeleteContext(fakeRC);\n        }\n    }\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        return false;\n    }\n#endif\n    return true;\n}\n\nbool\nCALGSLDevice::glCanInterop(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n    LUID glAdapterLuid = {0, 0};\n    UINT glChainBitMask = 0;\n\n    LUID calAdapterLuid = {0, 0};\n    UINT calChainBitMask = 0;\n\n    HGLRC hRC = (HGLRC)GLplatformContext;\n\n    //get GL context's LUID and chainBitMask from UGL\n    if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask))\n    {\n        //now check against the CAL device' LUID and chainBitMask.\n        if (m_adp->getMVPUinfo(&calAdapterLuid, &calChainBitMask))\n        {\n            canInteroperate = ((glAdapterLuid.HighPart == calAdapterLuid.HighPart) &&\n                               (glAdapterLuid.LowPart == calAdapterLuid.LowPart) &&\n                               (glChainBitMask == calChainBitMask));\n        }\n    }\n#elif defined (ATI_OS_LINUX)\n#ifdef BRAHMA\n    canInteroperate = true;\n#else\n    GLuint glDeviceId = 0 ;\n    GLuint glChainMask = 0 ;\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    \n    if (glXGetContextMVPUInfoAMD(ctx,&glDeviceId,&glChainMask)){\n        GLuint deviceId = 0 ;\n        GLuint chainMask = 0 ;\n\n        if (m_adp->getMVPUinfo(&deviceId, &chainMask))\n        {\n        // we allow intoperability only with GL context\n        // reside on a single GPU\n            if (deviceId == glDeviceId && chainMask == glChainMask){\n                    canInteroperate = true;\n            }\n        }\n    }\n#endif\n#endif\n    return canInteroperate;\n}\n\nbool\nCALGSLDevice::glAssociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    //initialize pointers to the gl extension that supports interoperability\n    if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n        !glCanInterop(GLplatformContext, GLdeviceContext))\n    {\n        return false;\n    }\n\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglBeginCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::glDissociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglEndCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLAssociate(GLResAssociate & resData) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    bool status = false;\n    cmSurfFmt cal_cmFormat;\n    uint32 depth;\n\n    gslMemObjectAttribs attribs(\n        GSL_MOA_TEXTURE_2D,      // type\n        GSL_MOA_MEMORY_ALIAS,    // location\n        GSL_MOA_TILING_TILED,    // tiling\n        GSL_MOA_DISPLAYABLE_NO,  // displayable\n        ATIGL_FALSE,             // mipmap\n        1,                       // samples\n        0,                       // cpu_address\n        GSL_MOA_SIGNED_NO,       // signed_format\n        GSL_MOA_FORMAT_DERIVED,  // numFormat\n        DRIVER_MODULE_GLL,       // module\n        GSL_ALLOCATION_INSTANCED // alloc_type\n    );\n\n    hRes.type = resData.type;\n\n    GLResourceData* hData = new GLResourceData;\n    if (NULL == hData)\n    {\n        return false;\n    }\n    memset(hData, 0, sizeof(GLResourceData));\n\n    hRes.name = resData.name;\n    hRes.flags = resData.flags;\n    hData->version = GL_RESOURCE_DATA_VERSION;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)resData.GLContext;\n    if (glXResourceAttachAMD(ctx, &hRes, hData))\n    {\n        attribs.dynamicSharedBufferID = hData->sharedBufferID;\n        status = true;\n    }\n#else\n    HGLRC hRC = (HGLRC)resData.GLContext;\n    if (wglResourceAttachAMD(hRC, &hRes, hData))\n    {\n        status =  true;\n    }\n#endif\n\n    if (!status)\n    {\n        return false;\n    }\n\n    // for now, to be safe, allow only textures to have a depth other than 1\n    if (hRes.type == GL_RESOURCE_ATTACH_TEXTURE_AMD)\n    {\n        depth = hData->rawDimensions.depth;\n    }\n    else\n    {\n        depth = 1;\n    }\n\n    attribs.type = static_cast<gslMemObjectAttribType>(hData->objectAttribType);\n\n    osAssert(depth <= GLRDATA_MAX_LAYERS);\n    osAssert(depth >= 1);\n    attribs.alias_swizzles = (uint32*)malloc(depth * 2 * sizeof(uint32));\n    osAssert(attribs.alias_swizzles);\n    memcpy (attribs.alias_swizzles, hData->swizzles, sizeof(uint32) * depth);\n    if (hData->levels > 1)\n    {\n        attribs.mipmap = ATIGL_TRUE;\n        attribs.levels = static_cast<GLuint>(hData->levels);\n        memcpy (&attribs.alias_swizzles[depth], hData->swizzlesMip, sizeof(uint32) * depth);\n    }\n\n    attribs.cpu_address = (void*)hData->handle;\n    attribs.alias_subtile = hData->tilingMode;\n    attribs.mcaddress = hData->cardAddr;\n    if (hData->isDoppDesktopTexture == GL_TRUE || (hData->isDoppPresentTexture == GL_TRUE) ||\n        (hData->isDisplayable == GL_TRUE))\n    {\n        attribs.isDOPPDesktopTexture = (hData->isDoppDesktopTexture == GL_TRUE);\n        attribs.displayable = hData->isTilingRotated\n                                  ? GSL_MOA_DISPLAYABLE_PORTRAIT_ROTATED : GSL_MOA_DISPLAYABLE_LAYOUT;\n    }\n    attribs.doppVidpnSourceId = hData->vidpnSourceId;\n\n    // VBOs are hardcoded to have a UINT8 type format\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        hData->format = CM_SURF_FMT_LUMINANCE8;\n    }\n    // CAL supports only a limited number of cm_surf formats, so we\n    // have to translate incoming cm_surf formats\n    uint32 index = hData->format - (uint32)CM_SURF_FMT_LUMINANCE8;\n    if (index >= sizeof(cmFormatXlateTable)/sizeof(cmFormatXlateParams))\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;\n    }\n    osAssert(static_cast<cmSurfFmt>(hData->format) == cmFormatXlateTable[index].raw_cmFormat);\n    cal_cmFormat = cmFormatXlateTable[index].cal_cmFormat;\n    if (cal_cmFormat == 500)\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;  // format is not supported by CAL\n    }\n    attribs.channelOrder = cmFormatXlateTable[index].channelOrder;\n    attribs.alias_perSurfTileInfo = hData->perSurfTileInfo;\n    attribs.alias_GLInterop = ATIGL_TRUE;\n    attribs.numFormat = GSL_MOA_FORMAT_DERIVED;\n\n    gslMemObject    mem;\n\n    if (hData->offset != 0)\n    {\n        osAssert((hData->rawDimensions.height == 1) && (depth == 1));\n        mem = m_cs->createMemObject2D(CM_SURF_FMT_LUMINANCE8, hData->surfaceSize, 1, &attribs);\n    }\n    else\n    {\n        mem = m_cs->createMemObject3D(cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        attribs.tiling = mem->getAttribs().tiling;\n        resData.mem_base = mem;\n        mem  = m_cs->createOffsetMemObject2D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n                                                                cal_cmFormat,\n                                                                hData->paddedDimensions.width,\n                                                                1, &attribs);\n    }\n    else if ((hData->offset != 0) && (hData->rawDimensions.height == 1) && (depth == 1))\n    {\n        resData.mem_base = mem;\n        attribs.tiling = mem->getAttribs().tiling;\n        mem = m_cs->createOffsetMemObject3D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n            cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    free (attribs.alias_swizzles);\n    resData.mbResHandle = (CALvoid*)hData->mbResHandle;\n    resData.memObject = mem;\n    delete hData;\n    return mem != 0;\n}\n\nbool\nCALGSLDevice::resGLAcquire(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLRelease(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    //TODO : make sure the application GL context is current. if not no\n    // point calling into the GL RT.\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n    // Make the call into the GL driver only if the application GL context is current\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLFree (\n    CALvoid* GLplatformContext,\n    CALvoid* GLdeviceContext,\n    gslMemObject mem,\n    gslMemObject mem_base,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n    if (mem_base)\n    {\n        m_cs->destroyMemObject(mem_base);\n    }\n    m_cs->destroyMemObject(mem);\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/rocm/rocglinterop.cpp": "/* Copyright (c) 2016-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef WITHOUT_HSA_BACKEND\n\n#include \"os/os.hpp\"\n#include \"utils/debug.hpp\"\n#include \"utils/flags.hpp\"\n#include \"device/rocm/rocglinterop.hpp\"\n\n#if !defined(_WIN32)\n#include <dlfcn.h>\n#endif\n\nnamespace roc {\n\nnamespace MesaInterop {\n\n#if !defined(_WIN32)\nstatic PFNMESAGLINTEROPGLXQUERYDEVICEINFOPROC* GlxInfo   = nullptr;\nstatic PFNMESAGLINTEROPGLXEXPORTOBJECTPROC*    GlxExport = nullptr;\nstatic PFNMESAGLINTEROPEGLQUERYDEVICEINFOPROC* EglInfo   = nullptr;\nstatic PFNMESAGLINTEROPEGLEXPORTOBJECTPROC*    EglExport = nullptr;\nstatic MESA_INTEROP_KIND loadedGLAPITypes(MESA_INTEROP_NONE);\n#endif\n\nstatic const char* errorStrings[] = {\"MESA_GLINTEROP_SUCCESS\",\n                                     \"MESA_GLINTEROP_OUT_OF_RESOURCES\",\n                                     \"MESA_GLINTEROP_OUT_OF_HOST_MEMORY\",\n                                     \"MESA_GLINTEROP_INVALID_OPERATION\",\n                                     \"MESA_GLINTEROP_INVALID_VERSION\",\n                                     \"MESA_GLINTEROP_INVALID_DISPLAY\",\n                                     \"MESA_GLINTEROP_INVALID_CONTEXT\",\n                                     \"MESA_GLINTEROP_INVALID_TARGET\",\n                                     \"MESA_GLINTEROP_INVALID_OBJECT\",\n                                     \"MESA_GLINTEROP_INVALID_MIP_LEVEL\",\n                                     \"MESA_GLINTEROP_UNSUPPORTED\"};\n\nbool Supported() {\n#ifdef _WIN32\n  return false;\n#else\n  return true;\n#endif\n}\n\n// Returns true if the required subsystem is supported on the GL device.\n// Must be called at least once, may be called multiple times.\nbool Init(MESA_INTEROP_KIND Kind) {\n#if defined(_WIN32)\n  return false;\n#else\n  if (loadedGLAPITypes == MESA_INTEROP_NONE) {\n  void* glxinfo=dlsym(RTLD_DEFAULT, \"MesaGLInteropGLXQueryDeviceInfo\");\n  void* eglinfo=dlsym(RTLD_DEFAULT, \"MesaGLInteropEGLQueryDeviceInfo\");\n  \n  GlxInfo=(PFNMESAGLINTEROPGLXQUERYDEVICEINFOPROC*)glxinfo;\n  EglInfo=(PFNMESAGLINTEROPEGLQUERYDEVICEINFOPROC*)eglinfo;\n\n  GlxExport=(PFNMESAGLINTEROPGLXEXPORTOBJECTPROC*)dlsym(RTLD_DEFAULT, \"MesaGLInteropGLXExportObject\");\n  EglExport=(PFNMESAGLINTEROPEGLEXPORTOBJECTPROC*)dlsym(RTLD_DEFAULT, \"MesaGLInteropEGLExportObject\");\n\n  uint32_t ret=MESA_INTEROP_NONE;\n    if (GlxInfo && GlxExport) ret |= MESA_INTEROP_GLX;\n    if (EglInfo && EglExport) ret |= MESA_INTEROP_EGL;\n    loadedGLAPITypes = MESA_INTEROP_KIND(ret);\n  }\n\n  return ((loadedGLAPITypes & Kind) == Kind);\n#endif\n}\n\nbool GetInfo(mesa_glinterop_device_info& info, MESA_INTEROP_KIND Kind, const DisplayHandle display,\n             const ContextHandle context) {\n#ifdef _WIN32\n  return false;\n#else\n  assert((loadedGLAPITypes & Kind) == Kind && \"Requested interop API is not currently loaded.\");\n  int ret;\n  switch (Kind) {\n  case MESA_INTEROP_GLX:\n      ret = GlxInfo(display.glxDisplay, context.glxContext, &info);\n      break;\n  case MESA_INTEROP_EGL:\n      ret = EglInfo(display.eglDisplay, context.eglContext, &info);\n      break;\n  default:\n      assert(false && \"Invalid interop kind.\");\n    return false;\n  }\n  if (ret == MESA_GLINTEROP_SUCCESS) return true;\n  if (ret < int(sizeof(errorStrings) / sizeof(errorStrings[0])))\n    LogPrintfError(\"Mesa interop: GetInfo failed with \\\"%s\\\".\\n\", errorStrings[ret]);\n  else\n    LogError(\"Mesa interop: GetInfo failed with invalid error code.\\n\");\n  return false;\n#endif\n}\n\nbool Export(mesa_glinterop_export_in& in, mesa_glinterop_export_out& out, MESA_INTEROP_KIND Kind,\n            const DisplayHandle display, const ContextHandle context) {\n#ifdef _WIN32\n  return false;\n#else\n  assert((loadedGLAPITypes & Kind) == Kind && \"Requested interop API is not currently loaded.\");\n  int ret;\n  switch (Kind) {\n  case MESA_INTEROP_GLX:\n      ret = GlxExport(display.glxDisplay, context.glxContext, &in, &out);\n      break;\n  case MESA_INTEROP_EGL:\n      ret = EglExport(display.eglDisplay, context.eglContext, &in, &out);\n      break;\n  default:\n      assert(false && \"Invalid interop kind.\");\n    return false;\n  }\n  if (ret == MESA_GLINTEROP_SUCCESS) return true;\n  if (ret < int(sizeof(errorStrings) / sizeof(errorStrings[0])))\n    LogPrintfError(\"Mesa interop: Export failed with \\\"%s\\\".\\n\", errorStrings[ret]);\n  else\n    LogError(\"Mesa interop: Export failed with invalid error code.\\n\");\n  return false;\n#endif\n}\n}\n}\n\n#endif  // WITHOUT_HSA_BACKEND\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/rocm/pro/prodevice.cpp": "/* Copyright (c) 2017-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef WITHOUT_HSA_BACKEND\n\n#include \"hsa_ext_amd.h\"\n#include \"lnxheaders.h\"\n#include \"prodevice.hpp\"\n#include \"amdgpu_drm.h\"\n\nnamespace roc {\n\nconstexpr uint32_t kMaxDevices  = 32;\nconstexpr uint32_t kAtiVendorId = 0x1002;\n\nvoid*      ProDevice::lib_drm_handle_ = nullptr;\nbool       ProDevice::initialized_ = false;\ndrm::Funcs ProDevice::funcs_;\n\nIProDevice* IProDevice::Init(uint32_t bus, uint32_t dev, uint32_t func)\n{\n  // Make sure DRM lib is initialized\n  if (!ProDevice::DrmInit()) {\n    return nullptr;\n  }\n\n  ProDevice* pro_device = new ProDevice();\n\n  if (pro_device == nullptr || !pro_device->Create(bus, dev, func)) {\n    delete pro_device;\n    return nullptr;\n  }\n  return pro_device;\n}\n\nProDevice::~ProDevice() {\n  delete alloc_ops_;\n\n  if (dev_handle_ != nullptr) {\n    Funcs().AmdgpuDeviceDeinitialize(dev_handle_);\n  }\n  if (file_desc_ > 0) {\n    close(file_desc_);\n  }\n}\n\nbool ProDevice::DrmInit()\n{\n  if (initialized_ == false) {\n    // Find symbols in libdrm_amdgpu.so.1\n    lib_drm_handle_ = dlopen(\"libdrm_amdgpu.so.1\", RTLD_NOW);\n    if (lib_drm_handle_ == nullptr) {\n      return false;\n    } else {\n      funcs_.DrmGetDevices = reinterpret_cast<drm::DrmGetDevices>(dlsym(\n                             lib_drm_handle_,\n                             \"drmGetDevices\"));\n      if (funcs_.DrmGetDevices == nullptr) return false;\n      funcs_.AmdgpuDeviceInitialize = reinterpret_cast<drm::AmdgpuDeviceInitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_initialize\"));\n      if (funcs_.AmdgpuDeviceInitialize == nullptr) return false;\n      funcs_.AmdgpuDeviceDeinitialize = reinterpret_cast<drm::AmdgpuDeviceDeinitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_deinitialize\"));\n      if (funcs_.AmdgpuDeviceDeinitialize == nullptr) return false;\n      funcs_.AmdgpuQueryGpuInfo = reinterpret_cast<drm::AmdgpuQueryGpuInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_gpu_info\"));\n      if (funcs_.AmdgpuQueryGpuInfo == nullptr) return false;\n      funcs_.AmdgpuQueryInfo = reinterpret_cast<drm::AmdgpuQueryInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_info\"));\n      if (funcs_.AmdgpuQueryInfo == nullptr) return false;\n      funcs_.AmdgpuBoAlloc = reinterpret_cast<drm::AmdgpuBoAlloc>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_alloc\"));\n      if (funcs_.AmdgpuBoAlloc == nullptr) return false;\n      funcs_.AmdgpuBoExport = reinterpret_cast<drm::AmdgpuBoExport>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_export\"));\n      if (funcs_.AmdgpuBoExport == nullptr) return false;\n      funcs_.AmdgpuBoFree = reinterpret_cast<drm::AmdgpuBoFree>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_free\"));\n      if (funcs_.AmdgpuBoFree == nullptr) return false;\n      funcs_.AmdgpuBoCpuMap = reinterpret_cast<drm::AmdgpuBoCpuMap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_map\"));\n      if (funcs_.AmdgpuBoCpuMap == nullptr) return false;\n      funcs_.AmdgpuBoCpuUnmap = reinterpret_cast<drm::AmdgpuBoCpuUnmap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_unmap\"));\n      if (funcs_.AmdgpuBoCpuUnmap == nullptr) return false;\n    }\n  }\n\n  initialized_ = true;\n  return true;\n}\n\n#ifndef AMDGPU_CAPABILITY_SSG_FLAG\n#define AMDGPU_CAPABILITY_SSG_FLAG 4\n#endif\n\n// ================================================================================================\n// Open drm device and initialize it. And also get the drm information.\nbool ProDevice::Create(uint32_t bus, uint32_t device, uint32_t func) {\n  drmDevicePtr  devices[kMaxDevices] = { };\n  int32_t device_count = Funcs().DrmGetDevices(devices, kMaxDevices);\n  bool    result = false;\n\n  for (int32_t i = 0; i < device_count; i++) {\n    // Check if the device vendor is AMD\n    if (devices[i]->deviceinfo.pci->vendor_id != kAtiVendorId) {\n      continue;\n    }\n    if ((devices[i]->businfo.pci->bus == bus) &&\n        (devices[i]->businfo.pci->dev == device) &&\n        (devices[i]->businfo.pci->func == func)) {\n\n      // pDevices[i]->nodes[DRM_NODE_PRIMARY];\n      // Using render node here so that we can do the off-screen rendering without authentication\n      file_desc_ = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDWR, 0);\n\n      if (file_desc_ > 0) {\n        void* data, *file, *cap;\n\n        // Initialize the admgpu device.\n        if (Funcs().AmdgpuDeviceInitialize(file_desc_, &major_ver_,\n                                           &minor_ver_, &dev_handle_) == 0) {\n          uint32_t version = 0;\n          // amdgpu_query_gpu_info will never fail only if it is initialized\n          Funcs().AmdgpuQueryGpuInfo(dev_handle_, &gpu_info_);\n\n          drm_amdgpu_capability cap = {};\n          Funcs().AmdgpuQueryInfo(dev_handle_, AMDGPU_INFO_CAPABILITY, sizeof(drm_amdgpu_capability), &cap);\n\n          // Check if DGMA and SSG are available\n          if ((cap.flag & (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) == \n              (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (result) {\n    alloc_ops_ = new amd::Monitor(\"DGMA mem alloc lock\", true);\n    if (nullptr == alloc_ops_) {\n      return true;\n    }\n  }\n\n  return result;\n}\n\nvoid* ProDevice::AllocDmaBuffer(hsa_agent_t agent, size_t size, void** host_ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  void* ptr = nullptr;\n  amdgpu_bo_handle buf_handle = 0;\n  amdgpu_bo_alloc_request req = {0};\n  *host_ptr = nullptr;\n\n  req.alloc_size = size;\n  req.phys_alignment = 64 * Ki;\n  req.preferred_heap = AMDGPU_GEM_DOMAIN_DGMA;\n\n  // Allocate buffer in DGMA heap\n  if (0 == Funcs().AmdgpuBoAlloc(dev_handle_, &req, &buf_handle)) {\n    amdgpu_bo_handle_type type = amdgpu_bo_handle_type_dma_buf_fd;\n    uint32_t shared_handle = 0;\n    // Find the base driver handle\n    if (0 == Funcs().AmdgpuBoExport(buf_handle, type, &shared_handle)) {\n      uint32_t  flags = 0;\n      size_t    buf_size = 0;\n      // Map memory object to HSA device\n      if (0 == hsa_amd_interop_map_buffer(1, &agent, shared_handle,\n                                          flags, &buf_size, &ptr, nullptr, nullptr)) {\n        // Ask GPUPro driver to provide CPU access to allocation\n        if (0 == Funcs().AmdgpuBoCpuMap(buf_handle, host_ptr)) {\n          allocs_.insert({ptr, {buf_handle, shared_handle}});\n        }\n        else {\n          hsa_amd_interop_unmap_buffer(ptr);\n          close(shared_handle);\n          Funcs().AmdgpuBoFree(buf_handle);\n        }\n      }\n      else {\n        close(shared_handle);\n        Funcs().AmdgpuBoFree(buf_handle);\n      }\n    }\n    else {\n      Funcs().AmdgpuBoFree(buf_handle);\n    }\n  }\n\n  return ptr;\n}\n\nvoid ProDevice::FreeDmaBuffer(void* ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  auto it = allocs_.find(ptr);\n  if (it != allocs_.end()) {\n    Funcs().AmdgpuBoCpuUnmap(it->second.first);\n    // Unmap memory from HSA device\n    hsa_amd_interop_unmap_buffer(ptr);\n    // Close shared handle\n    close(it->second.second);\n    int error = Funcs().AmdgpuBoFree(it->second.first);\n    allocs_.erase(it);\n  }\n}\n\n}\n\n#endif  // WITHOUT_HSA_BACKEND\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/os/os_posix.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n\n#include \"os/os.hpp\"\n#include \"thread/thread.hpp\"\n#include \"utils/util.hpp\"\n\n#include <iostream>\n#include <stdarg.h>\n\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include <signal.h>\n\n#include <sys/prctl.h>\n\n#include <link.h>\n#include <time.h>\n#include <elf.h>\n#ifndef DT_GNU_HASH\n#define DT_GNU_HASH 0x6ffffef5\n#endif  // DT_GNU_HASH\n\n#include <atomic>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstring>  // for strncmp\n#include <cstdlib>\n#include <cstdio>  // for tempnam\n#include <limits.h>\n#include <memory>\n#include <algorithm>\n#include <mutex>\n\n\nnamespace amd {\n\nstatic struct sigaction oldSigAction;\n\nstatic bool callOldSignalHandler(int sig, siginfo_t* info, void* ptr) {\n  if (oldSigAction.sa_handler == SIG_DFL) {\n    // no signal handler was previously installed.\n    return false;\n  } else if (oldSigAction.sa_handler != SIG_IGN) {\n    if ((oldSigAction.sa_flags & SA_NODEFER) == 0) {\n      sigaddset(&oldSigAction.sa_mask, sig);\n    }\n\n    void (*handler)(int) = oldSigAction.sa_handler;\n    if (oldSigAction.sa_flags & SA_RESETHAND) {\n      oldSigAction.sa_handler = SIG_DFL;\n    }\n\n    sigset_t savedSigSet;\n    pthread_sigmask(SIG_SETMASK, &oldSigAction.sa_mask, &savedSigSet);\n\n    if (oldSigAction.sa_flags & SA_SIGINFO) {\n      oldSigAction.sa_sigaction(sig, info, ptr);\n    } else {\n      handler(sig);\n    }\n\n    pthread_sigmask(SIG_SETMASK, &savedSigSet, NULL);\n  }\n\n  return true;\n}\n\nstatic void divisionErrorHandler(int sig, siginfo_t* info, void* ptr) {\n  assert(info != NULL && ptr != NULL && \"just checking\");\n  ucontext_t* uc = (ucontext_t*)ptr;\n  address insn;\n\n#if defined(ATI_ARCH_X86)\n  insn = (address)uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)];\n#else\n  assert(!\"Unimplemented\");\n#endif\n\n  if (Thread::current()->isWorkerThread()) {\n    if (Os::skipIDIV(insn)) {\n#if defined(ATI_ARCH_X86)\n      uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)] = (greg_t)insn;\n#else\n      assert(!\"Unimplemented\");\n#endif\n      return;\n    }\n  }\n\n  // Call the chained signal handler\n  if (callOldSignalHandler(sig, info, ptr)) {\n    return;\n  }\n\n\n  std::cerr << \"Unhandled signal in divisionErrorHandler()\" << std::endl;\n  ::abort();\n}\n\ntypedef int (*pthread_setaffinity_fn)(pthread_t, size_t, const cpu_set_t*);\nstatic pthread_setaffinity_fn pthread_setaffinity_fptr;\n\nstatic void init() __attribute__((constructor(101)));\nstatic void init() { Os::init(); }\n\nbool Os::installSigfpeHandler() {\n  // Install a SIGFPE signal handler @todo: Chain the handlers\n  struct sigaction sa;\n  sigfillset(&sa.sa_mask);\n  sa.sa_handler = SIG_DFL;\n  sa.sa_sigaction = divisionErrorHandler;\n  sa.sa_flags = SA_SIGINFO | SA_RESTART;\n\n  if (sigaction(SIGFPE, &sa, &oldSigAction) != 0) {\n    return false;\n  }\n  return true;\n}\n\nvoid Os::uninstallSigfpeHandler() {}\n\nbool Os::init() {\n  static bool initialized_ = false;\n\n  // We could use pthread_once here:\n  if (initialized_) {\n    return true;\n  }\n  initialized_ = true;\n\n  pageSize_ = (size_t)::sysconf(_SC_PAGESIZE);\n  processorCount_ = ::sysconf(_SC_NPROCESSORS_CONF);\n\n  pthread_setaffinity_fptr = (pthread_setaffinity_fn)dlsym(RTLD_NEXT, \"pthread_setaffinity_np\");\n\n  return Thread::init();\n}\n\nstatic void __exit() __attribute__((destructor(101)));\nstatic void __exit() { Os::tearDown(); }\n\nvoid Os::tearDown() { Thread::tearDown(); }\n\nvoid* Os::loadLibrary_(const char* filename) {\n  return (*filename == '\\0') ? NULL : ::dlopen(filename, RTLD_LAZY);\n}\n\nvoid Os::unloadLibrary(void* handle) { ::dlclose(handle); }\n\nvoid* Os::getSymbol(void* handle, const char* name) { return ::dlsym(handle, name); }\n\nstatic inline int memProtToOsProt(Os::MemProt prot) {\n  switch (prot) {\n    case Os::MEM_PROT_NONE:\n      return PROT_NONE;\n    case Os::MEM_PROT_READ:\n      return PROT_READ;\n    case Os::MEM_PROT_RW:\n      return PROT_READ | PROT_WRITE;\n    case Os::MEM_PROT_RWX:\n      return PROT_READ | PROT_WRITE | PROT_EXEC;\n    default:\n      break;\n  }\n  ShouldNotReachHere();\n  return -1;\n}\n\naddress Os::reserveMemory(address start, size_t size, size_t alignment, MemProt prot) {\n  size = alignUp(size, pageSize());\n  alignment = std::max(pageSize(), alignUp(alignment, pageSize()));\n  assert(isPowerOfTwo(alignment) && \"not a power of 2\");\n\n  size_t requested = size + alignment - pageSize();\n  address mem = (address)::mmap(start, requested, memProtToOsProt(prot),\n                                MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS, 0, 0);\n\n  // check for out of memory\n  if (mem == NULL) return NULL;\n\n  address aligned = alignUp(mem, alignment);\n\n  // return the unused leading pages to the free state\n  if (&aligned[0] != &mem[0]) {\n    assert(&aligned[0] > &mem[0] && \"check this code\");\n    if (::munmap(&mem[0], &aligned[0] - &mem[0]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n  // return the unused trailing pages to the free state\n  if (&aligned[size] != &mem[requested]) {\n    assert(&aligned[size] < &mem[requested] && \"check this code\");\n    if (::munmap(&aligned[size], &mem[requested] - &aligned[size]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n\n  return aligned;\n}\n\nbool Os::releaseMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::munmap(addr, size);\n}\n\nbool Os::commitMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, memProtToOsProt(prot), MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::uncommitMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::protectMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::mprotect(addr, size, memProtToOsProt(prot));\n}\n\nuint64_t Os::hostTotalPhysicalMemory() {\n  static uint64_t totalPhys = 0;\n\n  if (totalPhys != 0) {\n    return totalPhys;\n  }\n\n  totalPhys = sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n  return totalPhys;\n}\n\nvoid* Os::alignedMalloc(size_t size, size_t alignment) {\n  void* ptr = NULL;\n  if (0 == ::posix_memalign(&ptr, alignment, size)) {\n    return ptr;\n  }\n  return NULL;\n}\n\nvoid Os::alignedFree(void* mem) { ::free(mem); }\n\nvoid Os::currentStackInfo(address* base, size_t* size) {\n  // There could be some issue trying to get the pthread_attr of\n  // the primordial thread if the pthread library is not present\n  // at load time (a binary loads the OpenCL/HIP app/runtime dynamically.\n  // We should look into this... -laurent\n\n  pthread_t self = ::pthread_self();\n\n  pthread_attr_t threadAttr;\n  if (0 != ::pthread_getattr_np(self, &threadAttr)) {\n    fatal(\"pthread_getattr_np() failed\");\n  }\n\n  if (0 != ::pthread_attr_getstack(&threadAttr, (void**)base, size)) {\n    fatal(\"pthread_attr_getstack() failed\");\n  }\n  *base += *size;\n\n  ::pthread_attr_destroy(&threadAttr);\n\n  assert(Os::currentStackPtr() >= *base - *size && Os::currentStackPtr() < *base &&\n         \"just checking\");\n}\n\nvoid Os::setCurrentThreadName(const char* name) { ::prctl(PR_SET_NAME, name); }\n\n\nvoid* Thread::entry(Thread* thread) {\n  sigset_t set;\n\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n  sigemptyset(&set);\n  sigaddset(&set, SIGFPE);\n  pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n  return thread->main();\n}\n\nbool Os::isThreadAlive(const Thread& thread) {\n  return ::pthread_kill((pthread_t)thread.handle(), 0) == 0;\n}\n\nstatic size_t tlsSize = 0;\n\n// Try to guess the size of TLS (plus some frames)\nvoid* guessTlsSizeThread(void* param) {\n  address stackBase;\n  address currentFrame;\n  size_t stackSize;\n  Os::currentStackInfo(&stackBase, &stackSize);\n  currentFrame = reinterpret_cast<address>(&stackSize);\n  tlsSize = stackBase - currentFrame;\n  // align up to page boundary\n  tlsSize = alignUp(tlsSize, amd::Os::pageSize());\n  return NULL;\n}\n\nstatic void guessTlsSize(void) {\n  int retval;\n  pthread_t handle;\n  pthread_attr_t threadAttr;\n\n  ::pthread_attr_init(&threadAttr);\n  retval = ::pthread_create(&handle, &threadAttr, guessTlsSizeThread, NULL);\n  if (retval == 0) {\n    pthread_join(handle, NULL);\n  } else {\n    fatal(\"pthread_create() failed with default stack size\");\n  }\n  ::pthread_attr_destroy(&threadAttr);\n}\n\nconst void* Os::createOsThread(amd::Thread* thread) {\n  pthread_attr_t threadAttr;\n  ::pthread_attr_init(&threadAttr);\n\n  if (thread->stackSize_ != 0) {\n    size_t guardsize = 0;\n    if (0 != ::pthread_attr_getguardsize(&threadAttr, &guardsize)) {\n      fatal(\"pthread_attr_getguardsize() failed\");\n    }\n\n    static std::once_flag initOnce;\n    std::call_once(initOnce, guessTlsSize);\n    ::pthread_attr_setstacksize(&threadAttr, thread->stackSize_ + guardsize + tlsSize);\n  }\n\n  // We never plan the use join, so free the resources now.\n  ::pthread_attr_setdetachstate(&threadAttr, PTHREAD_CREATE_DETACHED);\n\n  pthread_t handle = 0;\n  if (0 != ::pthread_create(&handle, &threadAttr, (void* (*)(void*)) & Thread::entry, thread)) {\n    thread->setState(Thread::FAILED);\n  }\n\n  ::pthread_attr_destroy(&threadAttr);\n  return reinterpret_cast<const void*>(handle);\n}\n\n\nvoid Os::setThreadAffinity(const void* handle, const Os::ThreadAffinityMask& mask) {\n  if (pthread_setaffinity_fptr != NULL) {\n    pthread_setaffinity_fptr((pthread_t)handle, sizeof(cpu_set_t), &mask.mask_);\n  }\n}\n\nvoid Os::yield() { ::sched_yield(); }\n\nuint64_t Os::timeNanos() {\n  struct timespec tp;\n  ::clock_gettime(CLOCK_MONOTONIC, &tp);\n  return (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n}\n\nuint64_t Os::timerResolutionNanos() {\n  static uint64_t resolution = 0;\n  if (resolution == 0) {\n    struct timespec tp;\n    ::clock_getres(CLOCK_MONOTONIC, &tp);\n    resolution = (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n  }\n  return resolution;\n}\n\n\nconst char* Os::libraryExtension() { return MACOS_SWITCH(\".dylib\", \".so\"); }\n\nconst char* Os::libraryPrefix() { return \"lib\"; }\n\nconst char* Os::objectExtension() { return \".o\"; }\n\nchar Os::fileSeparator() { return '/'; }\n\nchar Os::pathSeparator() { return ':'; }\n\nbool Os::pathExists(const std::string& path) {\n  struct stat st;\n  if (stat(path.c_str(), &st) != 0) return false;\n  return S_ISDIR(st.st_mode);\n}\n\nbool Os::createPath(const std::string& path) {\n  mode_t mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n  size_t pos = 0;\n  while (true) {\n    pos = path.find(fileSeparator(), pos);\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty() && !pathExists(currPath)) {\n      int ret = mkdir(currPath.c_str(), mode);\n      if (ret == -1) return false;\n    }\n    if (pos == std::string::npos) break;\n    ++pos;\n  }\n  return true;\n}\n\nbool Os::removePath(const std::string& path) {\n  size_t pos = std::string::npos;\n  bool removed = false;\n  while (true) {\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty()) {\n      int ret = rmdir(currPath.c_str());\n      if (ret == -1) return removed;\n      removed = true;\n    }\n    if (pos == 0) break;\n    pos = path.rfind(fileSeparator(), pos == std::string::npos ? pos : pos - 1);\n    if (pos == std::string::npos) break;\n  }\n  return true;\n}\n\nint Os::printf(const char* fmt, ...) {\n  va_list ap;\n\n  va_start(ap, fmt);\n  int len = ::vprintf(fmt, ap);\n  va_end(ap);\n\n  return len;\n}\n\n// Os::systemCall()\n// ================\n// Execute a program and return the program exitcode or -1 if there were problems.\n// The input argument 'command' is expected to be a space separated string of\n// command-line arguments with arguments containing spaces between double-quotes.\n//\n// In order to avoid duplication of memory, we use vfork()+exec(). vfork() has\n// potiential security risks; read the following for details:\n//\n//     https://www.securecoding.cert.org/confluence/display/seccode/POS33-C.+Do+not+use+vfork()\n//\n// In spite of these risks, the alternatives (system() or fork()) create resource\n// issues when running conformance test_allocation which stretches the system\n// memory to its limits. Thus we will accept this compromise under the condition\n// that the runtime will soon remove any need to call out to external commands.\n//\n// Note that stdin/stdout/stderr of the command are sent to /dev/null.\n//\nint Os::systemCall(const std::string& command) {\n#if 1\n  size_t len = command.size();\n  char* cmd = new char[len + 1];\n  fastMemcpy(cmd, command.c_str(), len);\n  cmd[len] = 0;\n\n  // Split the command into arguments. This is a very\n  // simple parser that only takes care of quotes and\n  // doesn't support escaping with back-slash. In\n  // the future, Os::systemCall() will either\n  // disappear or it will be replaced with an\n  // argc/argv interface. This parser also assumes\n  // that if an argument is quoted, the whole\n  // argument starts and ends with a double-quote.\n  bool inQuote = false;\n  int argLength = 0;\n  int n = 0;\n  char* cp = cmd;\n  while (*cp) {\n    switch (static_cast<int>(*cp)) {\n      case ' ':\n        if (inQuote) {\n          ++argLength;\n        } else {\n          *cp = '\\0';\n          argLength = 0;\n        }\n        break;\n      case '\"':\n        if (inQuote) {\n          inQuote = false;\n          *cp = '\\0';\n        } else {\n          inQuote = true;\n          *cp = '\\0';\n          argLength = 1;\n          ++n;\n        }\n        break;\n      default:\n        if (++argLength == 1) {\n          ++n;\n        }\n        break;\n    }\n    ++cp;\n  }\n\n  char** argv = new char*[n + 1];\n  int argc = 0;\n  cp = cmd;\n  do {\n    while ('\\0' == *cp) {\n      ++cp;\n    }\n    argv[argc++] = cp;\n    while ('\\0' != *cp) {\n      ++cp;\n    }\n  } while (argc < n);\n  argv[argc] = NULL;\n\n  int ret = -1;\n  pid_t pid = vfork();\n  if (0 == pid) {\n    // Child. Redirect stdin/stdout/stderr to /dev/null\n    int fdIn = open(\"/dev/null\", O_RDONLY);\n    int fdOut = open(\"/dev/null\", O_WRONLY);\n    if (0 <= fdIn || 0 <= fdOut) {\n      dup2(fdIn, 0);\n      dup2(fdOut, 1);\n      dup2(fdOut, 2);\n\n      // Execute the program\n      execvp(argv[0], argv);\n    }\n    _exit(-1);\n  } else if (0 > pid) {\n    // Can't vfork\n  } else {\n    // Parent - wait for program to complete and get exit code.\n    int exitCode;\n    if (0 <= waitpid(pid, &exitCode, 0)) {\n      ret = exitCode;\n    }\n  }\n  delete[] argv;\n  delete[] cmd;\n\n  return ret;\n#else\n  return ::system(command.c_str());\n#endif\n}\n\nstd::string Os::getEnvironment(const std::string& name) {\n  char* dstBuf;\n\n  dstBuf = ::getenv(name.c_str());\n  if (dstBuf == NULL) {\n    return std::string(\"\");\n  }\n  return std::string(dstBuf);\n}\n\nstd::string Os::getTempPath() {\n  std::string tempFolder = amd::Os::getEnvironment(\"TEMP\");\n  if (tempFolder.empty()) {\n    tempFolder = amd::Os::getEnvironment(\"TMP\");\n  }\n\n  if (tempFolder.empty()) {\n    tempFolder = \"/tmp\";\n    ;\n  }\n  return tempFolder;\n}\n\nstd::string Os::getTempFileName() {\n  static std::atomic_size_t counter(0);\n\n  std::string tempPath = getTempPath();\n  std::stringstream tempFileName;\n\n  tempFileName << tempPath << \"/OCL\" << ::getpid() << 'T' << counter++;\n  return tempFileName.str();\n}\n\nint Os::unlink(const std::string& path) { return ::unlink(path.c_str()); }\n\n#if defined(ATI_ARCH_X86)\nvoid Os::cpuid(int regs[4], int info) {\n#ifdef _LP64\n  __asm__ __volatile__(\n      \"movq %%rbx, %%rsi;\"\n      \"cpuid;\"\n      \"xchgq %%rbx, %%rsi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#else\n  __asm__ __volatile__(\n      \"movl %%ebx, %%esi;\"\n      \"cpuid;\"\n      \"xchgl %%ebx, %%esi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#endif\n}\n\nuint64_t Os::xgetbv(uint32_t ecx) {\n  uint32_t eax, edx;\n\n  __asm__ __volatile__(\".byte 0x0f,0x01,0xd0\"  // in case assembler doesn't recognize xgetbv\n                       : \"=a\"(eax), \"=d\"(edx)\n                       : \"c\"(ecx));\n\n  return ((uint64_t)edx << 32) | (uint64_t)eax;\n}\n#endif  // ATI_ARCH_X86\n\nvoid* Os::fastMemcpy(void* dest, const void* src, size_t n) { return memcpy(dest, src, n); }\n\nuint64_t Os::offsetToEpochNanos() {\n  static uint64_t offset = 0;\n\n  if (offset != 0) {\n    return offset;\n  }\n\n  struct timeval now;\n  if (::gettimeofday(&now, NULL) != 0) {\n    return 0;\n  }\n\n  offset = (now.tv_sec * UINT64_C(1000000) + now.tv_usec) * UINT64_C(1000) - timeNanos();\n\n  return offset;\n}\n\nvoid Os::setCurrentStackPtr(address sp) {\n  sp -= sizeof(void*);\n  *(void**)sp = __builtin_return_address(0);\n\n#if defined(ATI_ARCH_ARM)\n  assert(!\"Unimplemented\");\n#else\n  __asm__ __volatile__(\n#if !defined(OMIT_FRAME_POINTER)\n      LP64_SWITCH(\"movl (%%ebp),%%ebp;\", \"movq (%%rbp),%%rbp;\")\n#endif  // !OMIT_FRAME_POINTER\n          LP64_SWITCH(\"movl %0,%%esp; ret;\", \"movq %0,%%rsp; ret;\")::\"r\"(sp));\n#endif\n}\n\nsize_t Os::getPhysicalMemSize() {\n  struct ::sysinfo si;\n\n  if (::sysinfo(&si) != 0) {\n    return 0;\n  }\n\n  if (si.mem_unit == 0) {\n    // Linux kernels prior to 2.3.23 return sizes in bytes.\n    si.mem_unit = 1;\n  }\n\n  return (size_t)si.totalram * si.mem_unit;\n}\n\nvoid Os::getAppPathAndFileName(std::string& appName, std::string& appPathAndName) {\n  std::unique_ptr<char[]> buff(new char[FILE_PATH_MAX_LENGTH]());\n\n  if (readlink(\"/proc/self/exe\", buff.get(), FILE_PATH_MAX_LENGTH) > 0) {\n    // Get filename without path and extension.\n    appName = std::string(basename(buff.get()));\n    appPathAndName = std::string(buff.get());\n  }\n  else {\n    appName = \"\";\n    appPathAndName = \"\";\n  }\n  return;\n}\n\nbool Os::MemoryUnmapFile(const void* mmap_ptr, size_t mmap_size) {\n  if(munmap(const_cast<void*>(mmap_ptr), mmap_size) != 0) {\n    return false;\n  }\n\n  return true;\n}\n\nbool Os::MemoryMapFile(const char* fname, const void** mmap_ptr, size_t* mmap_size) {\n  if ((mmap_ptr == nullptr) || (mmap_size == nullptr)) {\n    return false;\n  }\n\n  FILE* fp = fopen(fname, \"r\");\n  if (fp == nullptr) {\n    return false;\n  }\n\n  int fd = fileno(fp);\n  if (fd < 0 ) {\n    fclose(fp);\n    return false;\n  }\n\n  fseek(fp, 0L, SEEK_END);\n  *mmap_size = ftell(fp);\n  fseek(fp, 0L, SEEK_SET);\n\n  *mmap_ptr = mmap(NULL, *mmap_size, PROT_READ, MAP_SHARED, fd, 0);\n\n  fclose(fp);\n\n  if (*mmap_ptr == nullptr) {\n    return false;\n  }\n\n  return true;\n}\n\n}  // namespace amd\n\n#endif  // !defined(_WIN32) && !defined(__CYGWIN__)\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/opencl-on-vdi/amdocl/cl_gl_amd.hpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef CL_GL_AMD_HPP_\n#define CL_GL_AMD_HPP_\n\n#ifdef _WIN32\n#include <windows.h>\n#else //!_WIN32\n#include <dlfcn.h>\n#endif //!_WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#ifndef _WIN32\n#include <GL/glx.h>\n#endif //!_WIN32\n\n#include <EGL/egl.h>\n#include <EGL/eglext.h>\n#include <EGL/eglplatform.h>\n\n#include \"platform/context.hpp\"\n#include \"platform/command.hpp\"\n\nnamespace amd\n{\n\n//! Class GLObject keeps all the info about the GL object\n//! from which the CL object is created\nclass GLObject : public InteropObject\n{\nprotected:\n    cl_gl_object_type   clGLType_;  //!< CL GL object type\n    GLenum  glTarget_;\n    GLuint  gluiName_;\n    GLint   gliMipLevel_;\n    GLenum  glInternalFormat_;\n    GLint   gliWidth_;\n    GLint   gliHeight_;\n    GLint   gliDepth_;\n    GLenum  glCubemapFace_;\n    GLsizei glNumSamples_;\n\npublic:\n//! GLObject constructor initializes member variables\n    GLObject(\n        GLenum  glTarget,\n        GLuint  gluiName,\n        GLint   gliMipLevel,\n        GLenum  glInternalFormat,\n        GLint   gliWidth,\n        GLint   gliHeight,\n        GLint   gliDepth,\n        cl_gl_object_type   clGLType,\n        GLenum  glCubemapFace,\n        GLsizei glNumSamples\n    ): // Initialization of member variables\n            clGLType_(clGLType),\n            glTarget_(glTarget),\n            gluiName_(gluiName),\n            gliMipLevel_(gliMipLevel),\n            glInternalFormat_(glInternalFormat),\n            gliWidth_(gliWidth),\n            gliHeight_(gliHeight),\n            gliDepth_(gliDepth),\n            glCubemapFace_(glCubemapFace),\n            glNumSamples_(glNumSamples)\n    {\n    }\n\n    virtual ~GLObject() {}\n    virtual GLObject* asGLObject() {return this;}\n\n//! GLObject query functions to get GL info from member variables\n    GLenum  getGLTarget() const {return glTarget_;}\n    GLuint  getGLName() const {return gluiName_;}\n    GLint   getGLMipLevel() const {return gliMipLevel_;}\n    GLenum  getGLInternalFormat() const {return glInternalFormat_;}\n    GLint   getGLSize() const {return gliWidth_;}\n    GLint   getGLWidth() const {return gliWidth_;}\n    GLint   getGLHeight() const {return gliHeight_;}\n    GLint   getGLDepth() const {return gliDepth_;}\n    cl_gl_object_type getCLGLObjectType() const { return clGLType_; }\n    GLenum  getCubemapFace() const {return glCubemapFace_;}\n    GLsizei getNumSamples() const { return glNumSamples_;}\n};\n\n\n//! Class BufferGL is drived from classes Buffer and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass BufferGL : public Buffer, public GLObject\n{\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\npublic:\n//! BufferGL constructor just calls constructors of base classes\n//! to pass down the parameters\n    BufferGL(\n        Context&        amdContext,\n        cl_mem_flags    clFlags,\n        size_t          uiSizeInBytes,\n        GLenum          glTarget,\n        GLuint          gluiName)\n        : // Call base classes constructors\n            Buffer(\n                amdContext,\n                clFlags,\n                uiSizeInBytes\n            ),\n            GLObject(\n                glTarget,\n                gluiName,\n                0,                  // Mipmap level default\n                GL_ARRAY_BUFFER,    // Just init to some value\n                (GLint) uiSizeInBytes,\n                1,\n                1,\n                CL_GL_OBJECT_BUFFER,\n                0,\n                0\n            )\n    {\n        setInteropObj(this);\n    }\n    virtual ~BufferGL() {}\n\n    virtual BufferGL* asBufferGL() { return this; }\n};\n\n\n//! Class ImageGL is derived from classes Image and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass ImageGL : public Image, public GLObject\n{\npublic:\n    //! ImageGL constructor just calls constructors of base classes\n    //! to pass down the parameters\n    ImageGL(\n        Context&            amdContext,\n        cl_mem_object_type  clType,\n        cl_mem_flags        clFlags,\n        const Format&       format,\n        size_t              width,\n        size_t              height,\n        size_t              depth,\n        GLenum              glTarget,\n        GLuint              gluiName,\n        GLint               gliMipLevel,\n        GLenum              glInternalFormat,\n        cl_gl_object_type   clGLType,\n        GLsizei             numSamples,\n        GLenum              glCubemapFace = 0)\n        : Image(amdContext, clType, clFlags, format, width, height, depth,\n            Format(format).getElementSize() * width,    \n            Format(format).getElementSize() * width * depth)\n        , GLObject(glTarget, gluiName, gliMipLevel, glInternalFormat,\n            static_cast<GLint>(width), static_cast<GLint>(height),\n            static_cast<GLint>(depth), clGLType, glCubemapFace,numSamples)\n    {\n        setInteropObj(this);\n    }\n\n    virtual ~ImageGL() {}\n\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\n};\n\n#ifdef _WIN32\n#define APICALL WINAPI\n#define GETPROCADDRESS      GetProcAddress\n#define API_GETPROCADDR     \"wglGetProcAddress\"\n#define FCN_STR_TYPE        LPCSTR\n    typedef PROC (WINAPI* PFN_xxxGetProcAddress) (LPCSTR fcnName);\n    typedef HGLRC (APICALL* PFN_wglCreateContext) (HDC hdc);\n    typedef HGLRC (APICALL* PFN_wglGetCurrentContext) (void);\n    typedef HDC   (APICALL* PFN_wglGetCurrentDC) (void);\n    typedef BOOL  (APICALL* PFN_wglDeleteContext) (HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglMakeCurrent) (HDC hdc, HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglShareLists) (HGLRC hglrc1, HGLRC hglrc2);\n#else //!_WIN32\n#define APICALL // __stdcall   //??? todo odintsov\n#define API_GETPROCADDR     \"glXGetProcAddress\"\n#define GETPROCADDRESS      dlsym\n#define FCN_STR_TYPE        const GLubyte*\n#define WINAPI\n#define PROC void*\n    typedef void* (*PFN_xxxGetProcAddress) (const GLubyte* procName);\n    // X11 typedef\n    typedef Display* (*PFNXOpenDisplay)(_Xconst char* display_name );\n    typedef int (*PFNXCloseDisplay)(Display* display );\n\n    //glx typedefs\n    typedef GLXDrawable (*PFNglXGetCurrentDrawable)();\n    typedef Display* (*PFNglXGetCurrentDisplay)();\n    typedef GLXContext (*PFNglXGetCurrentContext)( void );\n    typedef XVisualInfo* (*PFNglXChooseVisual)(Display *dpy, int screen, int *attribList);\n    typedef GLXContext(*PFNglXCreateContext)(Display* dpy,XVisualInfo* vis,GLXContext shareList,Bool direct);\n    typedef void(*PFNglXDestroyContext)(Display* dpy, GLXContext ctx);\n    typedef Bool(*PFNglXMakeCurrent)( Display* dpy, GLXDrawable drawable, GLXContext ctx);\n    typedef void* HMODULE;\n#endif //!_WIN32\n\n#define GLPREFIX(rtype, fcn, dclargs) \\\n    typedef rtype (APICALL* PFN_##fcn) dclargs;\n\n// Declare prototypes for GL functions\n#include \"gl_functions.hpp\"\n\nclass GLFunctions\n{\npublic:\n    //! Locks any access to the virtual GPUs\n    class SetIntEnv : public amd::StackObject {\n    public:\n        //! Default constructor\n        SetIntEnv(GLFunctions* env);\n\n        //! Destructor\n        ~SetIntEnv();\n\n        //! Checks if the environment setup was successful\n        bool isValid() const { return isValid_; }\n\n    private:\n        GLFunctions*    env_;       //!< GL environment\n        bool            isValid_;   //!< If TRUE, then it's a valid setup\n    };\n\nprivate:\n    HMODULE libHandle_;\n    int missed_;    // Indicates how many GL functions not init'ed, if any\n\n    amd::Monitor lock_;\n\n    EGLDisplay eglDisplay_;\n    EGLContext eglOriginalContext_;\n    EGLContext eglInternalContext_;\n    EGLContext eglTempContext_;\n    bool isEGL_;\n\n#ifdef _WIN32\n    HGLRC       hOrigGLRC_;\n    HDC         hDC_;\n    HGLRC       hIntGLRC_;  // handle for internal GLRC to access shared context\n    HDC         tempDC_;\n    HGLRC       tempGLRC_;\n\n    PFN_wglCreateContext     wglCreateContext_;\n    PFN_wglGetCurrentContext wglGetCurrentContext_;\n    PFN_wglGetCurrentDC      wglGetCurrentDC_;\n    PFN_wglDeleteContext     wglDeleteContext_;\n    PFN_wglMakeCurrent       wglMakeCurrent_;\n    PFN_wglShareLists        wglShareLists_;\n#else\npublic:\n    Display*    Dpy_;\n    GLXDrawable Drawable_;\n    GLXContext  origCtx_;\n    Display*    intDpy_;\n    Window      intDrawable_;\n    GLXContext  intCtx_;\n    Display*    tempDpy_;\n    GLXDrawable tempDrawable_;\n    GLXContext  tempCtx_;\n\n    //pointers to X11 functions\n    PFNXOpenDisplay XOpenDisplay_;\n    PFNXCloseDisplay XCloseDisplay_;\n\n    //pointers to GLX functions\n    PFNglXGetCurrentDrawable glXGetCurrentDrawable_;\n    PFNglXGetCurrentDisplay glXGetCurrentDisplay_;\n    PFNglXGetCurrentContext glXGetCurrentContext_;\n    PFNglXChooseVisual glXChooseVisual_;\n    PFNglXCreateContext glXCreateContext_;\n    PFNglXDestroyContext glXDestroyContext_;\n    PFNglXMakeCurrent glXMakeCurrent_;\n#endif\npublic:\n\n    GLFunctions(HMODULE h, bool isEGL);\n    ~GLFunctions();\n\n    // Query CL-GL context association\n    bool isAssociated() const\n    {\n        if (isEGL_ && eglDisplay_ && eglOriginalContext_) return true;\n#ifdef _WIN32\n        if(hDC_ && hOrigGLRC_) return true;\n#else //!_WIN32\n        if(Dpy_ && origCtx_) return true;\n#endif //!_WIN32\n        return false;\n    }\n    bool isEGL() const\n    {\n        return isEGL_;\n    }\n    // Accessor methods\n#ifdef _WIN32\n    HGLRC getOrigGLRC() const {return hOrigGLRC_;}\n    HDC getDC() const {return hDC_;}\n    HGLRC getIntGLRC() const {return hIntGLRC_;}\n#else //!_WIN32\n    Display* getDpy() const {return Dpy_;}\n    GLXDrawable getDrawable() const {return Drawable_;}\n    GLXContext getOrigCtx() const {return origCtx_;}\n\n    Display* getIntDpy() const {return intDpy_;}\n    GLXDrawable getIntDrawable() const {return intDrawable_;}\n    GLXContext getIntCtx() const {return intCtx_;}\n\n    EGLDisplay getEglDpy() const { return eglDisplay_; }\n    EGLContext getEglOrigCtx() const { return eglOriginalContext_; }\n#endif //!_WIN32\n\n    // Initialize GL dynamic library and function pointers\n    bool init(intptr_t hdc, intptr_t hglrc);\n\n    // Return true if successful, false - if error occurred\n    bool setIntEnv();\n    bool restoreEnv();\n\n    amd::Monitor& getLock() { return lock_; }\n\n    PFN_xxxGetProcAddress GetProcAddress_;\n\n#define GLPREFIX(rtype, fcn, dclargs)   \\\n    PFN_##fcn fcn##_;\n// Declare pointers to GL functions\n#include \"gl_functions.hpp\"\n};\n\n//! Functions for executing the GL related stuff\ncl_mem clCreateFromGLBufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint bufobj, cl_int* errcode_ret);\ncl_mem clCreateFromGLTextureAMD(Context& amdContext, cl_mem_flags flags,\n    GLenum target, GLint miplevel, GLuint texture, int* errcode_ret);\ncl_mem clCreateFromGLRenderbufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint renderbuffer, int* errcode_ret);\n\nbool\ngetCLFormatFromGL(\n    const Context& amdContext,\n    GLint gliInternalFormat,\n    cl_image_format* pclImageFormat,\n    int* piBytesPerPixel,\n    cl_mem_flags flags\n);\n\n} //namespace amd\n\n#endif //CL_GL_AMD_HPP_\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/opencl-on-vdi/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/opencl-on-vdi/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    return dlopen (libraryName, RTLD_NOW);\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/pal/palsched.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.5.0-2j47n5ozlpklwi3p6sxesdrufzowr7hd/spack-src/device/gpu/gpusched.hpp"
    ],
    "total_files": 508
}