{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/op/example/op_example_component.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2011 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/** @file\n *\n * This is the \"example\" component source code.  It contains the\n * well-known struct that OMPI will dlsym() (or equivalent) for to\n * find how to access the rest of the component and any modules that\n * are created.\n */\n\n#include \"ompi_config.h\"\n\n#include \"opal/util/printf.h\"\n\n#include \"ompi/constants.h\"\n#include \"ompi/op/op.h\"\n#include \"ompi/mca/op/op.h\"\n#include \"ompi/mca/op/base/base.h\"\n#include \"ompi/mca/op/example/op_example.h\"\n\nstatic int example_component_open(void);\nstatic int example_component_close(void);\nstatic int example_component_init_query(bool enable_progress_threads,\n                                     bool enable_mpi_thread_multiple);\nstatic struct ompi_op_base_module_1_0_0_t *\n    example_component_op_query(struct ompi_op_t *op, int *priority);\nstatic int example_component_register(void);\n\nompi_op_example_component_t mca_op_example_component = {\n    /* First, the mca_base_component_t struct containing meta\n       information about the component itself */\n    {\n        .opc_version = {\n            OMPI_OP_BASE_VERSION_1_0_0,\n\n            .mca_component_name = \"example\",\n            MCA_BASE_MAKE_VERSION(component, OMPI_MAJOR_VERSION, OMPI_MINOR_VERSION,\n                                  OMPI_RELEASE_VERSION),\n            .mca_open_component = example_component_open,\n            .mca_close_component = example_component_close,\n            .mca_register_component_params = example_component_register,\n        },\n        .opc_data = {\n            /* The component is checkpoint ready */\n            MCA_BASE_METADATA_PARAM_CHECKPOINT\n        },\n\n        .opc_init_query = example_component_init_query,\n        .opc_op_query = example_component_op_query,\n    },\n\n    /* Now comes the example-component-specific data.  In this case,\n       we'll just leave it blank, defaulting all the values to\n       0/false/whatever.  We'll fill them in with meaningful values\n       during _component_init_query(). */\n};\n\n/*\n * Component open\n */\nstatic int example_component_open(void)\n{\n    opal_output(ompi_op_base_framework.framework_output, \"example component open\");\n\n    /* A first level check to see if example is even available in this\n       process.  E.g., you may want to do a first-order check to see\n       if hardware is available.  If so, return OMPI_SUCCESS.  If not,\n       return anything other than OMPI_SUCCESS and the component will\n       silently be ignored.\n\n       Note that if this function returns non-OMPI_SUCCESS, then this\n       component won't even be shown in ompi_info output (which is\n       probably not what you want).\n    */\n\n    return OMPI_SUCCESS;\n}\n\n\n/*\n * Component close\n */\nstatic int example_component_close(void)\n{\n    opal_output(ompi_op_base_framework.framework_output, \"example component close\");\n\n    /* If example was opened successfully, close it (i.e., release any\n       resources that may have been allocated on this component).\n       Note that _component_close() will always be called at the end\n       of the process, so it may have been after any/all of the other\n       component functions have been invoked (and possibly even after\n       modules have been created and/or destroyed). */\n\n    return OMPI_SUCCESS;\n}\n\nstatic char *example_component_version;\n\n/*\n * Register MCA params.\n */\nstatic int example_component_register(void)\n{\n    int val;\n    char *str;\n\n    opal_output(ompi_op_base_framework.framework_output, \"example component register\");\n\n    /* Register any relevant MCA params.  At a minimum, perhaps some\n       information MCA params that return version and capability\n       information.  */\n\n    /* For example, let's make a string MCA information parameter\n       containing the major.minor.release version number from the\n       libfoo support library (see configure.m4 for how we got these C\n       macros). */\n    opal_asprintf(&str, \"%s.%s.%s\",\n             OP_EXAMPLE_LIBFOO_VERSION_MAJOR,\n             OP_EXAMPLE_LIBFOO_VERSION_MINOR,\n             OP_EXAMPLE_LIBFOO_VERSION_RELEASE);\n    example_component_version = str;\n    (void) mca_base_component_var_register(&mca_op_example_component.super.opc_version,\n                                           \"libfoo_version\",\n                                           \"Version of the libfoo support library that this component was built against.\",\n                                           MCA_BASE_VAR_TYPE_STRING, NULL, 0,\n                                           MCA_BASE_VAR_FLAG_DEFAULT_ONLY,\n                                           OPAL_INFO_LVL_9,\n                                           MCA_BASE_VAR_SCOPE_CONSTANT,\n                                           &example_component_version);\n    /* The variable system duplicated the string. */\n    free(str);\n\n    /* Additionally, since this component is simulating hardware,\n       let's make MCA params that determine whethere a) the hardware\n       is available, and b) whether double precision floating point\n       types are supported.  This allows you to change the behavior of\n       this component at run-time (by setting these MCA params at\n       run-time), simulating different kinds of hardware. */\n    mca_op_example_component.hardware_available = false;\n    (void) mca_base_component_var_register(&mca_op_example_component.super.opc_version,\n                                           \"hardware_available\",\n                                           \"Whether the hardware is available or not\",\n                                           MCA_BASE_VAR_TYPE_BOOL, NULL, 0, 0,\n                                           OPAL_INFO_LVL_9,\n                                           MCA_BASE_VAR_SCOPE_READONLY,\n                                           &mca_op_example_component.hardware_available);\n\n    mca_op_example_component.double_supported = true;\n    (void) mca_base_component_var_register(&mca_op_example_component.super.opc_version,\n                                           \"double_supported\",\n                                           \"Whether the double precision data types are supported or not\",\n                                           MCA_BASE_VAR_TYPE_BOOL, NULL, 0, 0,\n                                           OPAL_INFO_LVL_9,\n                                           MCA_BASE_VAR_SCOPE_READONLY,\n                                           &mca_op_example_component.double_supported);\n\n    return OMPI_SUCCESS;\n}\n\n\n/*\n * Query whether this component wants to be used in this process.\n */\nstatic int example_component_init_query(bool enable_progress_threads,\n                                        bool enable_mpi_thread_multiple)\n{\n    opal_output(ompi_op_base_framework.framework_output, \"example component init query\");\n\n    /* Query to see if we have the desired hardware / resources to be\n       able to perform reduction operations.  This is a much more\n       comprehensive check than _component_open().\n\n       If this component can be used in this process, return\n       OMPI_SUCCESS, meaning that we'll be queried later via during\n       the MPI_Op component selection process via\n       _component_op_query().  Otherwise, return anything other than\n       OMPI_SUCCESS and this component will be silently ignored for\n       the MPI_Op component selection process.\n\n       The input parameters enable_progress_threads and\n       enable_mpi_thread_multiple also tell the component the following:\n\n       - If enable_progress_threads==true, then the component is\n         allowed to have a progress thread in the background that is\n         supported by the OMPI infrastructure (i.e., all of OMPI's\n         locks and whatnot are active in this build).  Note that the\n         component can *always* have a progress thread in the\n         background regardless of the value of this parameter as lone\n         as the HAVE_THREADS macro is true and the component uses its\n         own locking schemes (i.e., does not rely on external\n         OPAL/OMPI data structures to be thread safe).  This flag\n         simply indicates whether OPAL/OMPI data structures are\n         multi-threaded safe and whether multi-threading sync/IPC\n         mechanisms in the OMPI code base are active.\n\n       - If enable_mpi_thread_multiple==true, then MPI_THREAD_MULTIPLE is\n         active.\n\n       Note that a component can uses these values to deactivate\n       themselves if multi-threading is not supported (keep in mind\n       that in MPI_THREAD_MULTIPLE scenarios, the same MPI_Op can be\n       used in multiple, concurrent operations in different threads).\n       Let's assume that this component does not support\n       MPI_THREAD_MULTIPLE, and will therefore deactivate itself if\n       MPI_THREAD_MULTIPLE is used.\n    */\n\n    /* Note that we used MCA parameters to fill in the\n       _component.hardware_available and _component.double_supported\n       values.  Typically, you'd probe the hardware here and fill in\n       those values instead of using MCA parameters (the MCA params\n       are only used in this example to allow simulating different\n       types of hardware). */\n\n    /* If we have the hardware and are not using MPI_THREAD_MULITPLE,\n       return OMPI_SUCCESS (indicating that _component_op_query() will\n       be called in the future for each intrinsic MPI_Op).  Otherwise,\n       return OMPI_ERR_NOT_SUPPORTED (indicating that this component\n       will be closed and discarded). */\n    if (mca_op_example_component.hardware_available && !enable_mpi_thread_multiple) {\n        return OMPI_SUCCESS;\n    }\n    return OMPI_ERR_NOT_SUPPORTED;\n}\n\n\n/*\n * Query whether this component can be used for a specific op\n */\nstatic struct ompi_op_base_module_1_0_0_t *\n    example_component_op_query(struct ompi_op_t *op, int *priority)\n{\n    ompi_op_base_module_t *module = NULL;\n\n    opal_output(ompi_op_base_framework.framework_output, \"example component op query\");\n\n    /* Sanity check -- although the framework should never invoke the\n       _component_op_query() on non-intrinsic MPI_Op's, we'll put a\n       check here just to be sure. */\n    if (0 == (OMPI_OP_FLAGS_INTRINSIC & op->o_flags)) {\n        opal_output(0, \"example component op query: not an intrinsic MPI_Op -- skipping\");\n        return NULL;\n    }\n\n    /* What follows is an example of how to determine whether your\n       component supports the queried MPI_Op.  You can do this lots of\n       different ways; this is but one example. */\n\n    /* Note that we *do* have the hardware; _component_init_query()\n       would not have returned OMPI_SUCCESS if we didn't have the\n       hardware (and therefore this function would never have been\n       called).  So we don't need to check for the hardware again.\n       Instead, we need to do finer-grained checks (e.g., do we\n       support this op, and if so, what datatypes are supported?).\n\n       So check to see whether this MPI_Op operation is supported on\n       the hardware that this component supports (which may involve\n       querying the hardware to see what it is capable of).\n\n       You can see what operation is being requested by checking the\n       \"op->o_f_to_c_index\" value against the OMPI_OP_BASE_FORTRAN_*\n       enums.  See ompi/mca/op/op.h for a full list of the\n       OMPI_OP_BASE_FORTRAN_* enums.\n\n       In this example component, we support MAX and BXOR. */\n    switch (op->o_f_to_c_index) {\n    case OMPI_OP_BASE_FORTRAN_MAX:\n        /* Corresponds to MPI_MAX */\n        module = ompi_op_example_setup_max(op);\n        break;\n\n    case OMPI_OP_BASE_FORTRAN_BXOR:\n        /* Corresponds to MPI_BXOR */\n        module = ompi_op_example_setup_bxor(op);\n        break;\n    }\n\n    /* If we got a module from above, we'll return it.  Otherwise,\n       we'll return NULL, indicating that this component does not want\n       to be considered for selection for this MPI_Op.  Note that the\n       \"setup\" functions each returned a *example* component pointer\n       (vs. a *base* component pointer -- where an *example* component\n       is a base component plus some other module-specific cached\n       information), so we have to cast it to the right pointer type\n       before returning. */\n    if (NULL != module) {\n        *priority = 50;\n    }\n    return (ompi_op_base_module_1_0_0_t *) module;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/btl/usnic/test/usnic_btl_run_tests.c": "/*\n * Copyright (c) 2014      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/* A simple test runner program for the usnic BTL unit tests.  See README.test\n * for more information. */\n\n/* for dladdr() */\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libgen.h> /* for dirname() */\n\n#include <dlfcn.h>\n\n#define MCA_BTL_USNIC_SO \"mca_btl_usnic.so\"\n\ntypedef void (*run_tests_fn_t)(void);\n\nint main(int argc, char **argv)\n{\n    void *mpi_handle;\n    void *usnic_handle;\n    void (*run_tests)(void);\n    int (*init)(int *, char ***);\n    int (*finalize)(void);\n    Dl_info info;\n    char *libmpi_path;\n    char *path;\n    char *to;\n    int path_len;\n\n    mpi_handle = dlopen(\"lib\" OMPI_LIBMPI_NAME \".so\", RTLD_NOW|RTLD_GLOBAL);\n    if (mpi_handle == NULL) {\n        fprintf(stderr, \"mpi_handle=NULL dlerror()=%s\\n\", dlerror());\n        abort();\n    }\n\n    /* casting awfulness needed for GCC's \"-pedantic\" option :( */\n    *(void **)(&init) = dlsym(mpi_handle, \"MPI_Init\");\n    if (init == NULL) {\n        fprintf(stderr, \"init=NULL dlerror()=%s\\n\", dlerror());\n        abort();\n    }\n    /* casting awfulness needed for GCC's \"-pedantic\" option :( */\n    *(void **)(&finalize) = dlsym(mpi_handle, \"MPI_Finalize\");\n    if (finalize == NULL) {\n        fprintf(stderr, \"finalize=%p dlerror()=%s\\n\", *(void **)(&finalize), dlerror());\n        abort();\n    }\n\n    /* call MPI_Init this way to avoid build-time dependency issues */\n    init(&argc, &argv);\n\n    /* figure out where the usnic BTL shared object is relative to libmpi.so */\n    if (!dladdr(*(void **)(&init), &info)) {\n        fprintf(stderr, \"ERROR: unable to dladdr(init,...)\\n\");\n        abort();\n    }\n    libmpi_path = strdup(info.dli_fname);\n    assert(libmpi_path != NULL);\n    path_len = strlen(libmpi_path) + strlen(\"/openmpi/\") + strlen(MCA_BTL_USNIC_SO);\n    path = calloc(path_len+1, 1);\n    to = path;\n    to = stpcpy(to, dirname(libmpi_path));\n    to = stpcpy(to, \"/openmpi/\");\n    to = stpcpy(to, MCA_BTL_USNIC_SO);\n\n    usnic_handle = dlopen(path, RTLD_NOW|RTLD_LOCAL);\n    if (usnic_handle == NULL) {\n        fprintf(stderr, \"usnic_handle=%p dlerror()=%s\\n\", (void *)usnic_handle, dlerror());\n        abort();\n    }\n\n    free(libmpi_path);\n    free(path);\n\n    /* casting awfulness needed for GCC's \"-pedantic\" option :( */\n    *(void **)(&run_tests) = dlsym(usnic_handle, BTL_USNIC_RUN_TESTS_SYMBOL);\n    if (run_tests == NULL) {\n        fprintf(stderr, \"run_tests=%p dlerror()=%s\\n\",\n                *(void **)(&run_tests), dlerror());\n        abort();\n    }\n    run_tests();\n\n    finalize();\n\n    /* deliberately do not dlclose() either handle so that any valgrind stack\n     * traces are more useful */\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/common/cuda/common_cuda.c": "/*\n * Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2014 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2006 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2011-2015 NVIDIA Corporation.  All rights reserved.\n * Copyright (c) 2015      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * This file contains various support functions for doing CUDA\n * operations.\n */\n#include \"opal_config.h\"\n\n#include <errno.h>\n#include <unistd.h>\n#include <cuda.h>\n\n#include \"opal/align.h\"\n#include \"opal/datatype/opal_convertor.h\"\n#include \"opal/datatype/opal_datatype_cuda.h\"\n#include \"opal/util/output.h\"\n#include \"opal/util/show_help.h\"\n#include \"opal/util/proc.h\"\n#include \"opal/util/argv.h\"\n#include \"opal/util/printf.h\"\n\n#include \"opal/mca/rcache/base/base.h\"\n#include \"opal/runtime/opal_params.h\"\n#include \"opal/mca/timer/base/base.h\"\n#include \"opal/mca/dl/base/base.h\"\n\n#include \"common_cuda.h\"\n\n/**\n * Since function names can get redefined in cuda.h file, we need to do this\n * stringifying to get the latest function name from the header file.  For\n * example, cuda.h may have something like this:\n * #define cuMemFree cuMemFree_v2\n * We want to make sure we find cuMemFree_v2, not cuMemFree.\n */\n#define STRINGIFY2(x) #x\n#define STRINGIFY(x) STRINGIFY2(x)\n\n#define OPAL_CUDA_DLSYM(libhandle, funcName)                                         \\\ndo {                                                                                 \\\n char *err_msg;                                                                      \\\n void *ptr;                                                                          \\\n if (OPAL_SUCCESS !=                                                                 \\\n     opal_dl_lookup(libhandle, STRINGIFY(funcName), &ptr, &err_msg)) {               \\\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"dlsym failed\", true,             \\\n                       STRINGIFY(funcName), err_msg);                                \\\n        return 1;                                                                    \\\n    } else {                                                                         \\\n        *(void **)(&cuFunc.funcName) = ptr;                                          \\\n        opal_output_verbose(15, mca_common_cuda_output,                              \\\n                            \"CUDA: successful dlsym of %s\",                          \\\n                            STRINGIFY(funcName));                                    \\\n    }                                                                                \\\n} while (0)\n\n/* Structure to hold CUDA function pointers that get dynamically loaded. */\nstruct cudaFunctionTable {\n    int (*cuPointerGetAttribute)(void *, CUpointer_attribute, CUdeviceptr);\n    int (*cuMemcpyAsync)(CUdeviceptr, CUdeviceptr, size_t, CUstream);\n    int (*cuMemcpy)(CUdeviceptr, CUdeviceptr, size_t);\n    int (*cuMemAlloc)(CUdeviceptr *, unsigned int);\n    int (*cuMemFree)(CUdeviceptr buf);\n    int (*cuCtxGetCurrent)(void *cuContext);\n    int (*cuStreamCreate)(CUstream *, int);\n    int (*cuEventCreate)(CUevent *, int);\n    int (*cuEventRecord)(CUevent, CUstream);\n    int (*cuMemHostRegister)(void *, size_t, unsigned int);\n    int (*cuMemHostUnregister)(void *);\n    int (*cuEventQuery)(CUevent);\n    int (*cuEventDestroy)(CUevent);\n    int (*cuStreamWaitEvent)(CUstream, CUevent, unsigned int);\n    int (*cuMemGetAddressRange)(CUdeviceptr*, size_t*, CUdeviceptr);\n    int (*cuIpcGetEventHandle)(CUipcEventHandle*, CUevent);\n    int (*cuIpcOpenEventHandle)(CUevent*, CUipcEventHandle);\n    int (*cuIpcOpenMemHandle)(CUdeviceptr*, CUipcMemHandle, unsigned int);\n    int (*cuIpcCloseMemHandle)(CUdeviceptr);\n    int (*cuIpcGetMemHandle)(CUipcMemHandle*, CUdeviceptr);\n    int (*cuCtxGetDevice)(CUdevice *);\n    int (*cuDeviceCanAccessPeer)(int *, CUdevice, CUdevice);\n    int (*cuDeviceGet)(CUdevice *, int);\n#if OPAL_CUDA_GDR_SUPPORT\n    int (*cuPointerSetAttribute)(const void *, CUpointer_attribute, CUdeviceptr);\n#endif /* OPAL_CUDA_GDR_SUPPORT */\n    int (*cuCtxSetCurrent)(CUcontext);\n    int (*cuEventSynchronize)(CUevent);\n    int (*cuStreamSynchronize)(CUstream);\n    int (*cuStreamDestroy)(CUstream);\n#if OPAL_CUDA_GET_ATTRIBUTES\n    int (*cuPointerGetAttributes)(unsigned int, CUpointer_attribute *, void **, CUdeviceptr);\n#endif /* OPAL_CUDA_GET_ATTRIBUTES */\n};\ntypedef struct cudaFunctionTable cudaFunctionTable_t;\nstatic cudaFunctionTable_t cuFunc;\n\nstatic int stage_one_init_ref_count = 0;\nstatic bool stage_three_init_complete = false;\nstatic bool common_cuda_initialized = false;\nstatic bool common_cuda_mca_parames_registered = false;\nstatic int mca_common_cuda_verbose;\nstatic int mca_common_cuda_output = 0;\nbool mca_common_cuda_enabled = false;\nstatic bool mca_common_cuda_register_memory = true;\nstatic bool mca_common_cuda_warning = false;\nstatic opal_list_t common_cuda_memory_registrations;\nstatic CUstream ipcStream = NULL;\nstatic CUstream dtohStream = NULL;\nstatic CUstream htodStream = NULL;\nstatic CUstream memcpyStream = NULL;\nstatic int mca_common_cuda_gpu_mem_check_workaround = (CUDA_VERSION > 7000) ? 0 : 1;\nstatic opal_mutex_t common_cuda_init_lock;\nstatic opal_mutex_t common_cuda_htod_lock;\nstatic opal_mutex_t common_cuda_dtoh_lock;\nstatic opal_mutex_t common_cuda_ipc_lock;\n\n/* Functions called by opal layer - plugged into opal function table */\nstatic int mca_common_cuda_is_gpu_buffer(const void*, opal_convertor_t*);\nstatic int mca_common_cuda_memmove(void*, void*, size_t);\nstatic int mca_common_cuda_cu_memcpy_async(void*, const void*, size_t, opal_convertor_t*);\nstatic int mca_common_cuda_cu_memcpy(void*, const void*, size_t);\n\n/* Function that gets plugged into opal layer */\nstatic int mca_common_cuda_stage_two_init(opal_common_cuda_function_table_t *);\n\n/* Structure to hold memory registrations that are delayed until first\n * call to send or receive a GPU pointer */\nstruct common_cuda_mem_regs_t {\n    opal_list_item_t super;\n    void *ptr;\n    size_t amount;\n    char *msg;\n};\ntypedef struct common_cuda_mem_regs_t common_cuda_mem_regs_t;\nOBJ_CLASS_DECLARATION(common_cuda_mem_regs_t);\nOBJ_CLASS_INSTANCE(common_cuda_mem_regs_t,\n                   opal_list_item_t,\n                   NULL,\n                   NULL);\n\nstatic int mca_common_cuda_async = 1;\nstatic int mca_common_cuda_cumemcpy_async;\n#if OPAL_ENABLE_DEBUG\nstatic int mca_common_cuda_cumemcpy_timing;\n#endif /* OPAL_ENABLE_DEBUG */\n\n/* Array of CUDA events to be queried for IPC stream, sending side and\n * receiving side. */\nCUevent *cuda_event_ipc_array = NULL;\nCUevent *cuda_event_dtoh_array = NULL;\nCUevent *cuda_event_htod_array = NULL;\n\n/* Array of fragments currently being moved by cuda async non-blocking\n * operations */\nstruct mca_btl_base_descriptor_t **cuda_event_ipc_frag_array = NULL;\nstruct mca_btl_base_descriptor_t **cuda_event_dtoh_frag_array = NULL;\nstruct mca_btl_base_descriptor_t **cuda_event_htod_frag_array = NULL;\n\n/* First free/available location in cuda_event_status_array */\nstatic int cuda_event_ipc_first_avail, cuda_event_dtoh_first_avail, cuda_event_htod_first_avail;\n\n/* First currently-being used location in the cuda_event_status_array */\nstatic int cuda_event_ipc_first_used, cuda_event_dtoh_first_used, cuda_event_htod_first_used;\n\n/* Number of status items currently in use */\nstatic volatile int cuda_event_ipc_num_used, cuda_event_dtoh_num_used, cuda_event_htod_num_used;\n\n/* Size of array holding events */\nint cuda_event_max = 400;\nstatic int cuda_event_ipc_most = 0;\nstatic int cuda_event_dtoh_most = 0;\nstatic int cuda_event_htod_most = 0;\n\n/* Handle to libcuda.so */\nopal_dl_handle_t *libcuda_handle = NULL;\n\n/* Unused variable that we register at init time and unregister at fini time.\n * This is used to detect if user has done a device reset prior to MPI_Finalize.\n * This is a workaround to avoid SEGVs.\n */\nstatic int checkmem;\nstatic int ctx_ok = 1;\n\n#define CUDA_COMMON_TIMING 0\n#if OPAL_ENABLE_DEBUG\n/* Some timing support structures.  Enable this to help analyze\n * internal performance issues. */\nstatic opal_timer_t ts_start;\nstatic opal_timer_t ts_end;\nstatic double accum;\n#define THOUSAND  1000L\n#define MILLION   1000000L\nstatic float mydifftime(opal_timer_t ts_start, opal_timer_t ts_end);\n#endif /* OPAL_ENABLE_DEBUG */\n\n/* These functions are typically unused in the optimized builds. */\nstatic void cuda_dump_evthandle(int, void *, char *) __opal_attribute_unused__ ;\nstatic void cuda_dump_memhandle(int, void *, char *) __opal_attribute_unused__ ;\n#if OPAL_ENABLE_DEBUG\n#define CUDA_DUMP_MEMHANDLE(a) cuda_dump_memhandle a\n#define CUDA_DUMP_EVTHANDLE(a) cuda_dump_evthandle a\n#else\n#define CUDA_DUMP_MEMHANDLE(a)\n#define CUDA_DUMP_EVTHANDLE(a)\n#endif /* OPAL_ENABLE_DEBUG */\n\n/* This is a seperate function so we can see these variables with ompi_info and\n * also set them with the tools interface */\nvoid mca_common_cuda_register_mca_variables(void)\n{\n\n    if (false == common_cuda_mca_parames_registered) {\n        common_cuda_mca_parames_registered = true;\n    }\n    /* Set different levels of verbosity in the cuda related code. */\n    mca_common_cuda_verbose = 0;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"verbose\",\n                                 \"Set level of common cuda verbosity\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_verbose);\n\n    /* Control whether system buffers get CUDA pinned or not.  Allows for\n     * performance analysis. */\n    mca_common_cuda_register_memory = true;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"register_memory\",\n                                 \"Whether to cuMemHostRegister preallocated BTL buffers\",\n                                 MCA_BASE_VAR_TYPE_BOOL, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_register_memory);\n\n    /* Control whether we see warnings when CUDA memory registration fails.  This is\n     * useful when CUDA support is configured in, but we are running a regular MPI\n     * application without CUDA. */\n    mca_common_cuda_warning = true;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"warning\",\n                                 \"Whether to print warnings when CUDA registration fails\",\n                                 MCA_BASE_VAR_TYPE_BOOL, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_warning);\n\n    /* Use this flag to test async vs sync copies */\n    mca_common_cuda_async = 1;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"memcpy_async\",\n                                 \"Set to 0 to force CUDA sync copy instead of async\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_async);\n\n    /* Use this parameter to increase the number of outstanding events allows */\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"event_max\",\n                                 \"Set number of oustanding CUDA events\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &cuda_event_max);\n\n    /* Use this flag to test cuMemcpyAsync vs cuMemcpy */\n    mca_common_cuda_cumemcpy_async = 1;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"cumemcpy_async\",\n                                 \"Set to 0 to force CUDA cuMemcpy instead of cuMemcpyAsync/cuStreamSynchronize\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_5,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_cumemcpy_async);\n\n#if OPAL_ENABLE_DEBUG\n    /* Use this flag to dump out timing of cumempcy sync and async */\n    mca_common_cuda_cumemcpy_timing = 0;\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"cumemcpy_timing\",\n                                 \"Set to 1 to dump timing of eager copies\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_5,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_cumemcpy_timing);\n#endif /* OPAL_ENABLE_DEBUG */\n\n    (void) mca_base_var_register(\"ompi\", \"mpi\", \"common_cuda\", \"gpu_mem_check_workaround\",\n                                 \"Set to 0 to disable GPU memory check workaround. A user would rarely have to do this.\",\n                                 MCA_BASE_VAR_TYPE_INT, NULL, 0, 0,\n                                 OPAL_INFO_LVL_9,\n                                 MCA_BASE_VAR_SCOPE_READONLY,\n                                 &mca_common_cuda_gpu_mem_check_workaround);\n}\n\n/**\n * This is the first stage of initialization.  This function is called\n * explicitly by any BTLs that can support CUDA-aware. It is called during\n * the component open phase of initialization. This fuction will look for\n * the SONAME of the library which is libcuda.so.1. In most cases, this will\n * result in the library found.  However, there are some setups that require\n * the extra steps for searching. This function will then load the symbols\n * needed from the CUDA driver library. Any failure will result in this\n * initialization failing and status will be set showing that.\n */\nint mca_common_cuda_stage_one_init(void)\n{\n    int retval, i, j;\n    char *cudalibs[] = {\"libcuda.so.1\", \"libcuda.dylib\", NULL};\n    char *searchpaths[] = {\"\", \"/usr/lib64\", NULL};\n    char **errmsgs = NULL;\n    char *errmsg = NULL;\n    int errsize;\n    bool stage_one_init_passed = false;\n\n    stage_one_init_ref_count++;\n    if (stage_one_init_ref_count > 1) {\n        opal_output_verbose(10, mca_common_cuda_output,\n                            \"CUDA: stage_one_init_ref_count is now %d, no need to init\",\n                            stage_one_init_ref_count);\n        return OPAL_SUCCESS;\n    }\n\n    /* This is a no-op in most cases as the parameters were registered earlier */\n    mca_common_cuda_register_mca_variables();\n\n    OBJ_CONSTRUCT(&common_cuda_init_lock, opal_mutex_t);\n    OBJ_CONSTRUCT(&common_cuda_htod_lock, opal_mutex_t);\n    OBJ_CONSTRUCT(&common_cuda_dtoh_lock, opal_mutex_t);\n    OBJ_CONSTRUCT(&common_cuda_ipc_lock, opal_mutex_t);\n\n    mca_common_cuda_output = opal_output_open(NULL);\n    opal_output_set_verbosity(mca_common_cuda_output, mca_common_cuda_verbose);\n\n    opal_output_verbose(10, mca_common_cuda_output,\n                        \"CUDA: stage_one_init_ref_count is now %d, initializing\",\n                        stage_one_init_ref_count);\n\n    /* First check if the support is enabled.  In the case that the user has\n     * turned it off, we do not need to continue with any CUDA specific\n     * initialization.  Do this after MCA parameter registration. */\n    if (!opal_cuda_support) {\n        return 1;\n    }\n\n    if (!OPAL_HAVE_DL_SUPPORT) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"dlopen disabled\", true);\n        return 1;\n    }\n\n    /* Now walk through all the potential names libcuda and find one\n     * that works.  If it does, all is good.  If not, print out all\n     * the messages about why things failed.  This code was careful\n     * to try and save away all error messages if the loading ultimately\n     * failed to help with debugging.\n     *\n     * NOTE: On the first loop we just utilize the default loading\n     * paths from the system.  For the second loop, set /usr/lib64 to\n     * the search path and try again.  This is done to handle the case\n     * where we have both 32 and 64 bit libcuda.so libraries\n     * installed.  Even when running in 64-bit mode, the /usr/lib\n     * directory is searched first and we may find a 32-bit\n     * libcuda.so.1 library.  Loading of this library will fail as the\n     * OPAL DL framework does not handle having the wrong ABI in the\n     * search path (unlike ld or ld.so).  Note that we only set this\n     * search path after the original search.  This is so that\n     * LD_LIBRARY_PATH and run path settings are respected.  Setting\n     * this search path overrides them (rather then being\n     * appended). */\n    j = 0;\n    while (searchpaths[j] != NULL) {\n        i = 0;\n        while (cudalibs[i] != NULL) {\n            char *filename = NULL;\n            char *str = NULL;\n\n            /* If there's a non-empty search path, prepend it\n               to the library filename */\n            if (strlen(searchpaths[j]) > 0) {\n                opal_asprintf(&filename, \"%s/%s\", searchpaths[j], cudalibs[i]);\n            } else {\n                filename = strdup(cudalibs[i]);\n            }\n            if (NULL == filename) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                               true, OPAL_PROC_MY_HOSTNAME);\n                return 1;\n            }\n\n            retval = opal_dl_open(filename, false, false,\n                                  &libcuda_handle, &str);\n            if (OPAL_SUCCESS != retval || NULL == libcuda_handle) {\n                if (NULL != str) {\n                    opal_argv_append(&errsize, &errmsgs, str);\n                } else {\n                    opal_argv_append(&errsize, &errmsgs,\n                                     \"opal_dl_open() returned NULL.\");\n                }\n                opal_output_verbose(10, mca_common_cuda_output,\n                                    \"CUDA: Library open error: %s\",\n                                    errmsgs[errsize-1]);\n            } else {\n                opal_output_verbose(10, mca_common_cuda_output,\n                                    \"CUDA: Library successfully opened %s\",\n                                    cudalibs[i]);\n                stage_one_init_passed = true;\n                break;\n            }\n            i++;\n\n            free(filename);\n        }\n        if (true == stage_one_init_passed) {\n            break; /* Break out of outer loop */\n        }\n        j++;\n    }\n\n    if (true != stage_one_init_passed) {\n        errmsg = opal_argv_join(errmsgs, '\\n');\n        if (opal_warn_on_missing_libcuda) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"dlopen failed\", true,\n                           errmsg);\n        }\n        opal_cuda_support = 0;\n    }\n    opal_argv_free(errmsgs);\n    free(errmsg);\n\n    if (true != stage_one_init_passed) {\n        return 1;\n    }\n    opal_cuda_add_initialization_function(&mca_common_cuda_stage_two_init);\n    OBJ_CONSTRUCT(&common_cuda_memory_registrations, opal_list_t);\n\n    /* Map in the functions that we need.  Note that if there is an error\n     * the macro OPAL_CUDA_DLSYM will print an error and call return.  */\n    OPAL_CUDA_DLSYM(libcuda_handle, cuStreamCreate);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuCtxGetCurrent);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuEventCreate);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuEventRecord);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemHostRegister);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemHostUnregister);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuPointerGetAttribute);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuEventQuery);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuEventDestroy);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuStreamWaitEvent);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemcpyAsync);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemcpy);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemFree);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemAlloc);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuMemGetAddressRange);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuIpcGetEventHandle);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuIpcOpenEventHandle);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuIpcOpenMemHandle);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuIpcCloseMemHandle);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuIpcGetMemHandle);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuCtxGetDevice);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuDeviceCanAccessPeer);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuDeviceGet);\n#if OPAL_CUDA_GDR_SUPPORT\n    OPAL_CUDA_DLSYM(libcuda_handle, cuPointerSetAttribute);\n#endif /* OPAL_CUDA_GDR_SUPPORT */\n    OPAL_CUDA_DLSYM(libcuda_handle, cuCtxSetCurrent);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuEventSynchronize);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuStreamSynchronize);\n    OPAL_CUDA_DLSYM(libcuda_handle, cuStreamDestroy);\n#if OPAL_CUDA_GET_ATTRIBUTES\n    OPAL_CUDA_DLSYM(libcuda_handle, cuPointerGetAttributes);\n#endif /* OPAL_CUDA_GET_ATTRIBUTES */\n    return 0;\n}\n\n/**\n * This function is registered with the OPAL CUDA support.  In that way,\n * these function pointers will be loaded into the OPAL CUDA code when\n * the first convertor is initialized.  This does not trigger any CUDA\n * specific initialization as this may just be a host buffer that is\n * triggering this call.\n */\nstatic int mca_common_cuda_stage_two_init(opal_common_cuda_function_table_t *ftable)\n{\n    if (OPAL_UNLIKELY(!opal_cuda_support)) {\n        return OPAL_ERROR;\n    }\n\n    ftable->gpu_is_gpu_buffer = &mca_common_cuda_is_gpu_buffer;\n    ftable->gpu_cu_memcpy_async = &mca_common_cuda_cu_memcpy_async;\n    ftable->gpu_cu_memcpy = &mca_common_cuda_cu_memcpy;\n    ftable->gpu_memmove = &mca_common_cuda_memmove;\n\n    opal_output_verbose(30, mca_common_cuda_output,\n                        \"CUDA: support functions initialized\");\n    return OPAL_SUCCESS;\n}\n\n/**\n * This is the last phase of initialization.  This is triggered when we examine\n * a buffer pointer and determine it is a GPU buffer.  We then assume the user\n * has selected their GPU and we can go ahead with all the CUDA related\n * initializations.  If we get an error, just return.  Cleanup of resources\n * will happen when fini is called.\n */\nstatic int mca_common_cuda_stage_three_init(void)\n{\n    int i, s, rc;\n    CUresult res;\n    CUcontext cuContext;\n    common_cuda_mem_regs_t *mem_reg;\n\n    OPAL_THREAD_LOCK(&common_cuda_init_lock);\n    opal_output_verbose(20, mca_common_cuda_output,\n                        \"CUDA: entering stage three init\");\n\n/* Compiled without support or user disabled support */\n    if (OPAL_UNLIKELY(!opal_cuda_support)) {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: No mpi cuda support, exiting stage three init\");\n        stage_three_init_complete = true;\n        OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n        return OPAL_ERROR;\n    }\n\n    /* In case another thread snuck in and completed the initialization */\n    if (true == stage_three_init_complete) {\n        if (common_cuda_initialized) {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: Stage three already complete, exiting stage three init\");\n            OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n            return OPAL_SUCCESS;\n        } else {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: Stage three already complete, failed during the init\");\n            OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n            return OPAL_ERROR;\n        }\n    }\n\n    /* Check to see if this process is running in a CUDA context.  If\n     * so, all is good.  If not, then disable registration of memory. */\n    res = cuFunc.cuCtxGetCurrent(&cuContext);\n    if (CUDA_SUCCESS != res) {\n        if (mca_common_cuda_warning) {\n            /* Check for the not initialized error since we can make suggestions to\n             * user for this error. */\n            if (CUDA_ERROR_NOT_INITIALIZED == res) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuCtxGetCurrent failed not initialized\",\n                               true);\n            } else {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuCtxGetCurrent failed\",\n                               true, res);\n            }\n        }\n        mca_common_cuda_enabled = false;\n        mca_common_cuda_register_memory = false;\n    } else if ((CUDA_SUCCESS == res) && (NULL == cuContext)) {\n        if (mca_common_cuda_warning) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuCtxGetCurrent returned NULL\",\n                           true);\n        }\n        mca_common_cuda_enabled = false;\n        mca_common_cuda_register_memory = false;\n    } else {\n        /* All is good.  mca_common_cuda_register_memory will retain its original\n         * value.  Normally, that is 1, but the user can override it to disable\n         * registration of the internal buffers. */\n        mca_common_cuda_enabled = true;\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: cuCtxGetCurrent succeeded\");\n    }\n\n    /* No need to go on at this point.  If we cannot create a context and we are at\n     * the point where we are making MPI calls, it is time to fully disable\n     * CUDA support.\n     */\n    if (false == mca_common_cuda_enabled) {\n        OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n        return OPAL_ERROR;\n    }\n\n    if (true == mca_common_cuda_enabled) {\n        /* Set up an array to store outstanding IPC async copy events */\n        cuda_event_ipc_num_used = 0;\n        cuda_event_ipc_first_avail = 0;\n        cuda_event_ipc_first_used = 0;\n\n        cuda_event_ipc_array = (CUevent *) calloc(cuda_event_max, sizeof(CUevent *));\n        if (NULL == cuda_event_ipc_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n            rc = OPAL_ERROR;\n            goto cleanup_and_error;\n        }\n\n        /* Create the events since they can be reused. */\n        for (i = 0; i < cuda_event_max; i++) {\n            res = cuFunc.cuEventCreate(&cuda_event_ipc_array[i], CU_EVENT_DISABLE_TIMING);\n            if (CUDA_SUCCESS != res) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventCreate failed\",\n                               true, OPAL_PROC_MY_HOSTNAME, res);\n                rc = OPAL_ERROR;\n                goto cleanup_and_error;\n            }\n        }\n\n        /* The first available status index is 0.  Make an empty frag\n           array. */\n        cuda_event_ipc_frag_array = (struct mca_btl_base_descriptor_t **)\n            malloc(sizeof(struct mca_btl_base_descriptor_t *) * cuda_event_max);\n        if (NULL == cuda_event_ipc_frag_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n            rc = OPAL_ERROR;\n            goto cleanup_and_error;\n        }\n    }\n\n    if (true == mca_common_cuda_enabled) {\n        /* Set up an array to store outstanding async dtoh events.  Used on the\n         * sending side for asynchronous copies. */\n        cuda_event_dtoh_num_used = 0;\n        cuda_event_dtoh_first_avail = 0;\n        cuda_event_dtoh_first_used = 0;\n\n        cuda_event_dtoh_array = (CUevent *) calloc(cuda_event_max, sizeof(CUevent *));\n        if (NULL == cuda_event_dtoh_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n            rc = OPAL_ERROR;\n            goto cleanup_and_error;\n        }\n\n        /* Create the events since they can be reused. */\n        for (i = 0; i < cuda_event_max; i++) {\n            res = cuFunc.cuEventCreate(&cuda_event_dtoh_array[i], CU_EVENT_DISABLE_TIMING);\n            if (CUDA_SUCCESS != res) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventCreate failed\",\n                               true, OPAL_PROC_MY_HOSTNAME, res);\n                rc = OPAL_ERROR;\n                goto cleanup_and_error;\n            }\n        }\n\n        /* The first available status index is 0.  Make an empty frag\n           array. */\n        cuda_event_dtoh_frag_array = (struct mca_btl_base_descriptor_t **)\n            malloc(sizeof(struct mca_btl_base_descriptor_t *) * cuda_event_max);\n        if (NULL == cuda_event_dtoh_frag_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n            rc = OPAL_ERROR;\n            goto cleanup_and_error;\n        }\n\n        /* Set up an array to store outstanding async htod events.  Used on the\n         * receiving side for asynchronous copies. */\n        cuda_event_htod_num_used = 0;\n        cuda_event_htod_first_avail = 0;\n        cuda_event_htod_first_used = 0;\n\n        cuda_event_htod_array = (CUevent *) calloc(cuda_event_max, sizeof(CUevent *));\n        if (NULL == cuda_event_htod_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n           rc = OPAL_ERROR;\n           goto cleanup_and_error;\n        }\n\n        /* Create the events since they can be reused. */\n        for (i = 0; i < cuda_event_max; i++) {\n            res = cuFunc.cuEventCreate(&cuda_event_htod_array[i], CU_EVENT_DISABLE_TIMING);\n            if (CUDA_SUCCESS != res) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventCreate failed\",\n                               true, OPAL_PROC_MY_HOSTNAME, res);\n               rc = OPAL_ERROR;\n               goto cleanup_and_error;\n            }\n        }\n\n        /* The first available status index is 0.  Make an empty frag\n           array. */\n        cuda_event_htod_frag_array = (struct mca_btl_base_descriptor_t **)\n            malloc(sizeof(struct mca_btl_base_descriptor_t *) * cuda_event_max);\n        if (NULL == cuda_event_htod_frag_array) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"No memory\",\n                           true, OPAL_PROC_MY_HOSTNAME);\n           rc = OPAL_ERROR;\n           goto cleanup_and_error;\n        }\n    }\n\n    s = opal_list_get_size(&common_cuda_memory_registrations);\n    for(i = 0; i < s; i++) {\n        mem_reg = (common_cuda_mem_regs_t *)\n            opal_list_remove_first(&common_cuda_memory_registrations);\n        if (mca_common_cuda_enabled && mca_common_cuda_register_memory) {\n            res = cuFunc.cuMemHostRegister(mem_reg->ptr, mem_reg->amount, 0);\n            if (res != CUDA_SUCCESS) {\n                /* If registering the memory fails, print a message and continue.\n                 * This is not a fatal error. */\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemHostRegister during init failed\",\n                               true, mem_reg->ptr, mem_reg->amount,\n                               OPAL_PROC_MY_HOSTNAME, res, mem_reg->msg);\n            } else {\n                opal_output_verbose(20, mca_common_cuda_output,\n                                    \"CUDA: cuMemHostRegister OK on rcache %s: \"\n                                    \"address=%p, bufsize=%d\",\n                                    mem_reg->msg, mem_reg->ptr, (int)mem_reg->amount);\n            }\n        }\n        free(mem_reg->msg);\n        OBJ_RELEASE(mem_reg);\n    }\n\n    /* Create stream for use in ipc asynchronous copies */\n    res = cuFunc.cuStreamCreate(&ipcStream, 0);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamCreate failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res);\n        rc = OPAL_ERROR;\n        goto cleanup_and_error;\n    }\n\n    /* Create stream for use in dtoh asynchronous copies */\n    res = cuFunc.cuStreamCreate(&dtohStream, 0);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamCreate failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res);\n        rc = OPAL_ERROR;\n        goto cleanup_and_error;\n    }\n\n    /* Create stream for use in htod asynchronous copies */\n    res = cuFunc.cuStreamCreate(&htodStream, 0);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamCreate failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res);\n        rc = OPAL_ERROR;\n        goto cleanup_and_error;\n    }\n\n    if (mca_common_cuda_cumemcpy_async) {\n        /* Create stream for use in cuMemcpyAsync synchronous copies */\n        res = cuFunc.cuStreamCreate(&memcpyStream, 0);\n        if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamCreate failed\",\n                           true, OPAL_PROC_MY_HOSTNAME, res);\n            rc = OPAL_ERROR;\n            goto cleanup_and_error;\n        }\n    }\n\n    res = cuFunc.cuMemHostRegister(&checkmem, sizeof(int), 0);\n    if (res != CUDA_SUCCESS) {\n        /* If registering the memory fails, print a message and continue.\n         * This is not a fatal error. */\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemHostRegister during init failed\",\n                       true, &checkmem, sizeof(int),\n                       OPAL_PROC_MY_HOSTNAME, res, \"checkmem\");\n\n    } else {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: cuMemHostRegister OK on test region\");\n    }\n\n    opal_output_verbose(20, mca_common_cuda_output,\n                        \"CUDA: the extra gpu memory check is %s\", (mca_common_cuda_gpu_mem_check_workaround == 1) ? \"on\":\"off\");\n\n    opal_output_verbose(30, mca_common_cuda_output,\n                        \"CUDA: initialized\");\n    opal_atomic_mb();  /* Make sure next statement does not get reordered */\n    common_cuda_initialized = true;\n    stage_three_init_complete = true;\n    OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n    return OPAL_SUCCESS;\n\n    /* If we are here, something went wrong.  Cleanup and return an error. */\n cleanup_and_error:\n    opal_atomic_mb(); /* Make sure next statement does not get reordered */\n    stage_three_init_complete = true;\n    OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n    return rc;\n}\n\n/**\n * Cleanup all CUDA resources.\n *\n * Note: Still figuring out how to get cuMemHostUnregister called from the smcuda sm\n * rcache.  Looks like with the memory pool from openib (grdma), the unregistering is\n * called as the free list is destructed.  Not true for the sm mpool.  This means we\n * are currently still leaking some host memory we registered with CUDA.\n */\nvoid mca_common_cuda_fini(void)\n{\n    int i;\n    CUresult res;\n\n    if (false == common_cuda_initialized) {\n        stage_one_init_ref_count--;\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, never completed initialization so \"\n                            \"skipping fini, ref_count is now %d\", stage_one_init_ref_count);\n        return;\n    }\n\n    if (0 == stage_one_init_ref_count) {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, ref_count=%d, fini is already complete\",\n                            stage_one_init_ref_count);\n        return;\n    }\n\n    if (1 == stage_one_init_ref_count) {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, ref_count=%d, cleaning up started\",\n                            stage_one_init_ref_count);\n\n        /* This call is in here to make sure the context is still valid.\n         * This was the one way of checking which did not cause problems\n         * while calling into the CUDA library.  This check will detect if\n         * a user has called cudaDeviceReset prior to MPI_Finalize. If so,\n         * then this call will fail and we skip cleaning up CUDA resources. */\n        res = cuFunc.cuMemHostUnregister(&checkmem);\n        if (CUDA_SUCCESS != res) {\n            ctx_ok = 0;\n        }\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, cuMemHostUnregister returned %d, ctx_ok=%d\",\n                            res, ctx_ok);\n\n        if (NULL != cuda_event_ipc_array) {\n            if (ctx_ok) {\n                for (i = 0; i < cuda_event_max; i++) {\n                    if (NULL != cuda_event_ipc_array[i]) {\n                        cuFunc.cuEventDestroy(cuda_event_ipc_array[i]);\n                    }\n                }\n            }\n            free(cuda_event_ipc_array);\n        }\n        if (NULL != cuda_event_htod_array) {\n            if (ctx_ok) {\n                for (i = 0; i < cuda_event_max; i++) {\n                    if (NULL != cuda_event_htod_array[i]) {\n                        cuFunc.cuEventDestroy(cuda_event_htod_array[i]);\n                    }\n                }\n            }\n            free(cuda_event_htod_array);\n        }\n\n        if (NULL != cuda_event_dtoh_array) {\n            if (ctx_ok) {\n                for (i = 0; i < cuda_event_max; i++) {\n                    if (NULL != cuda_event_dtoh_array[i]) {\n                        cuFunc.cuEventDestroy(cuda_event_dtoh_array[i]);\n                    }\n                }\n            }\n            free(cuda_event_dtoh_array);\n        }\n\n        if (NULL != cuda_event_ipc_frag_array) {\n            free(cuda_event_ipc_frag_array);\n        }\n        if (NULL != cuda_event_htod_frag_array) {\n            free(cuda_event_htod_frag_array);\n        }\n        if (NULL != cuda_event_dtoh_frag_array) {\n            free(cuda_event_dtoh_frag_array);\n        }\n        if ((NULL != ipcStream) && ctx_ok) {\n            cuFunc.cuStreamDestroy(ipcStream);\n        }\n        if ((NULL != dtohStream) && ctx_ok) {\n            cuFunc.cuStreamDestroy(dtohStream);\n        }\n        if ((NULL != htodStream) && ctx_ok) {\n            cuFunc.cuStreamDestroy(htodStream);\n        }\n        if ((NULL != memcpyStream) && ctx_ok) {\n            cuFunc.cuStreamDestroy(memcpyStream);\n        }\n        OBJ_DESTRUCT(&common_cuda_init_lock);\n        OBJ_DESTRUCT(&common_cuda_htod_lock);\n        OBJ_DESTRUCT(&common_cuda_dtoh_lock);\n        OBJ_DESTRUCT(&common_cuda_ipc_lock);\n        if (NULL != libcuda_handle) {\n            opal_dl_close(libcuda_handle);\n        }\n\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, ref_count=%d, cleaning up all done\",\n                            stage_one_init_ref_count);\n\n        opal_output_close(mca_common_cuda_output);\n\n    } else {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: mca_common_cuda_fini, ref_count=%d, cuda still in use\",\n                            stage_one_init_ref_count);\n    }\n    stage_one_init_ref_count--;\n}\n\n/**\n * Call the CUDA register function so we pin the memory in the CUDA\n * space.\n */\nvoid mca_common_cuda_register(void *ptr, size_t amount, char *msg) {\n    int res;\n\n    /* Always first check if the support is enabled.  If not, just return */\n    if (!opal_cuda_support)\n        return;\n\n    if (!common_cuda_initialized) {\n        OPAL_THREAD_LOCK(&common_cuda_init_lock);\n        if (!common_cuda_initialized) {\n            common_cuda_mem_regs_t *regptr;\n            regptr = OBJ_NEW(common_cuda_mem_regs_t);\n            regptr->ptr = ptr;\n            regptr->amount = amount;\n            regptr->msg = strdup(msg);\n            opal_list_append(&common_cuda_memory_registrations,\n                             (opal_list_item_t*)regptr);\n            OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n            return;\n        }\n        OPAL_THREAD_UNLOCK(&common_cuda_init_lock);\n    }\n\n    if (mca_common_cuda_enabled && mca_common_cuda_register_memory) {\n        res = cuFunc.cuMemHostRegister(ptr, amount, 0);\n        if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n            /* If registering the memory fails, print a message and continue.\n             * This is not a fatal error. */\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemHostRegister failed\",\n                           true, ptr, amount,\n                           OPAL_PROC_MY_HOSTNAME, res, msg);\n        } else {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuMemHostRegister OK on rcache %s: \"\n                                \"address=%p, bufsize=%d\",\n                                msg, ptr, (int)amount);\n        }\n    }\n}\n\n/**\n * Call the CUDA unregister function so we unpin the memory in the CUDA\n * space.\n */\nvoid mca_common_cuda_unregister(void *ptr, char *msg) {\n    int res, i, s;\n    common_cuda_mem_regs_t *mem_reg;\n\n    /* This can happen if memory was queued up to be registered, but\n     * no CUDA operations happened, so it never was registered.\n     * Therefore, just release any of the resources. */\n    if (!common_cuda_initialized) {\n        s = opal_list_get_size(&common_cuda_memory_registrations);\n        for(i = 0; i < s; i++) {\n            mem_reg = (common_cuda_mem_regs_t *)\n                opal_list_remove_first(&common_cuda_memory_registrations);\n            free(mem_reg->msg);\n            OBJ_RELEASE(mem_reg);\n        }\n        return;\n    }\n\n    if (mca_common_cuda_enabled && mca_common_cuda_register_memory) {\n        res = cuFunc.cuMemHostUnregister(ptr);\n        if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n            /* If unregistering the memory fails, just continue.  This is during\n             * shutdown.  Only print when running in verbose mode. */\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuMemHostUnregister failed: ptr=%p, res=%d, rcache=%s\",\n                                ptr, res, msg);\n\n        } else {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuMemHostUnregister OK on rcache %s: \"\n                                \"address=%p\",\n                                msg, ptr);\n        }\n    }\n}\n\n/*\n * Get the memory handle of a local section of memory that can be sent\n * to the remote size so it can access the memory.  This is the\n * registration function for the sending side of a message transfer.\n */\nint cuda_getmemhandle(void *base, size_t size, mca_rcache_base_registration_t *newreg,\n                      mca_rcache_base_registration_t *hdrreg)\n\n{\n    CUmemorytype memType;\n    CUresult result;\n    CUipcMemHandle *memHandle;\n    CUdeviceptr pbase;\n    size_t psize;\n\n    mca_rcache_common_cuda_reg_t *cuda_reg = (mca_rcache_common_cuda_reg_t*)newreg;\n    memHandle = (CUipcMemHandle *)cuda_reg->data.memHandle;\n\n    /* We should only be there if this is a CUDA device pointer */\n    result = cuFunc.cuPointerGetAttribute(&memType,\n                                          CU_POINTER_ATTRIBUTE_MEMORY_TYPE, (CUdeviceptr)base);\n    assert(CUDA_SUCCESS == result);\n    assert(CU_MEMORYTYPE_DEVICE == memType);\n\n    /* Get the memory handle so we can send it to the remote process. */\n    result = cuFunc.cuIpcGetMemHandle(memHandle, (CUdeviceptr)base);\n    CUDA_DUMP_MEMHANDLE((100, memHandle, \"GetMemHandle-After\"));\n\n    if (CUDA_SUCCESS != result) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuIpcGetMemHandle failed\",\n                       true, result, base);\n        return OPAL_ERROR;\n    } else {\n        opal_output_verbose(20, mca_common_cuda_output,\n                            \"CUDA: cuIpcGetMemHandle passed: base=%p size=%d\",\n                            base, (int)size);\n    }\n\n    /* Need to get the real base and size of the memory handle.  This is\n     * how the remote side saves the handles in a cache. */\n    result = cuFunc.cuMemGetAddressRange(&pbase, &psize, (CUdeviceptr)base);\n    if (CUDA_SUCCESS != result) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemGetAddressRange failed\",\n                       true, result, base);\n        return OPAL_ERROR;\n    } else {\n        opal_output_verbose(10, mca_common_cuda_output,\n                            \"CUDA: cuMemGetAddressRange passed: addr=%p, size=%d, pbase=%p, psize=%d \",\n                            base, (int)size, (void *)pbase, (int)psize);\n    }\n\n    /* Store all the information in the registration */\n    cuda_reg->base.base = (void *)pbase;\n    cuda_reg->base.bound = (unsigned char *)pbase + psize - 1;\n    cuda_reg->data.memh_seg_addr.pval = (void *) pbase;\n    cuda_reg->data.memh_seg_len = psize;\n\n#if OPAL_CUDA_SYNC_MEMOPS\n    /* With CUDA 6.0, we can set an attribute on the memory pointer that will\n     * ensure any synchronous copies are completed prior to any other access\n     * of the memory region.  This means we do not need to record an event\n     * and send to the remote side.\n     */\n    memType = 1; /* Just use this variable since we already have it */\n    result = cuFunc.cuPointerSetAttribute(&memType, CU_POINTER_ATTRIBUTE_SYNC_MEMOPS,\n                                          (CUdeviceptr)base);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuPointerSetAttribute failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result, base);\n        return OPAL_ERROR;\n    }\n#else\n    /* Need to record the event to ensure that any memcopies into the\n     * device memory have completed.  The event handle associated with\n     * this event is sent to the remote process so that it will wait\n     * on this event prior to copying data out of the device memory.\n     * Note that this needs to be the NULL stream to make since it is\n     * unknown what stream any copies into the device memory were done\n     * with. */\n    result = cuFunc.cuEventRecord((CUevent)cuda_reg->data.event, 0);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                       true, result, base);\n        return OPAL_ERROR;\n    }\n#endif /* OPAL_CUDA_SYNC_MEMOPS */\n\n    return OPAL_SUCCESS;\n}\n\n/*\n * This function is called by the local side that called the cuda_getmemhandle.\n * There is nothing to be done so just return.\n */\nint cuda_ungetmemhandle(void *reg_data, mca_rcache_base_registration_t *reg)\n{\n    opal_output_verbose(10, mca_common_cuda_output,\n                        \"CUDA: cuda_ungetmemhandle (no-op): base=%p\", reg->base);\n    CUDA_DUMP_MEMHANDLE((100, ((mca_rcache_common_cuda_reg_t *)reg)->data.memHandle, \"cuda_ungetmemhandle\"));\n\n    return OPAL_SUCCESS;\n}\n\n/*\n * Open a memory handle that refers to remote memory so we can get an address\n * that works on the local side.  This is the registration function for the\n * remote side of a transfer.  newreg contains the new handle.  hddrreg contains\n * the memory handle that was received from the remote side.\n */\nint cuda_openmemhandle(void *base, size_t size, mca_rcache_base_registration_t *newreg,\n                       mca_rcache_base_registration_t *hdrreg)\n{\n    CUresult result;\n    CUipcMemHandle *memHandle;\n    mca_rcache_common_cuda_reg_t *cuda_newreg = (mca_rcache_common_cuda_reg_t*)newreg;\n\n    /* Save in local variable to avoid ugly casting */\n    memHandle = (CUipcMemHandle *)cuda_newreg->data.memHandle;\n    CUDA_DUMP_MEMHANDLE((100, memHandle, \"Before call to cuIpcOpenMemHandle\"));\n\n    /* Open the memory handle and store it into the registration structure. */\n    result = cuFunc.cuIpcOpenMemHandle((CUdeviceptr *)&newreg->alloc_base, *memHandle,\n                                       CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS);\n\n    /* If there are some stale entries in the cache, they can cause other\n     * registrations to fail.  Let the caller know that so that can attempt\n     * to clear them out. */\n    if (CUDA_ERROR_ALREADY_MAPPED == result) {\n        opal_output_verbose(10, mca_common_cuda_output,\n                            \"CUDA: cuIpcOpenMemHandle returned CUDA_ERROR_ALREADY_MAPPED for \"\n                            \"p=%p,size=%d: notify memory pool\\n\", base, (int)size);\n        return OPAL_ERR_WOULD_BLOCK;\n    }\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuIpcOpenMemHandle failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result, base);\n        /* Currently, this is a non-recoverable error */\n        return OPAL_ERROR;\n    } else {\n        opal_output_verbose(10, mca_common_cuda_output,\n                            \"CUDA: cuIpcOpenMemHandle passed: base=%p (remote base=%p,size=%d)\",\n                            newreg->alloc_base, base, (int)size);\n        CUDA_DUMP_MEMHANDLE((200, memHandle, \"cuIpcOpenMemHandle\"));\n    }\n\n    return OPAL_SUCCESS;\n}\n\n/*\n * Close a memory handle that refers to remote memory.\n */\nint cuda_closememhandle(void *reg_data, mca_rcache_base_registration_t *reg)\n{\n    CUresult result;\n    mca_rcache_common_cuda_reg_t *cuda_reg = (mca_rcache_common_cuda_reg_t*)reg;\n\n    /* Only attempt to close if we have valid context.  This can change if a call\n     * to the fini function is made and we discover context is gone. */\n    if (ctx_ok) {\n        result = cuFunc.cuIpcCloseMemHandle((CUdeviceptr)cuda_reg->base.alloc_base);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            if (CUDA_ERROR_DEINITIALIZED != result) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuIpcCloseMemHandle failed\",\n                true, result, cuda_reg->base.alloc_base);\n            }\n            /* We will just continue on and hope things continue to work. */\n        } else {\n            opal_output_verbose(10, mca_common_cuda_output,\n                                \"CUDA: cuIpcCloseMemHandle passed: base=%p\",\n                                cuda_reg->base.alloc_base);\n            CUDA_DUMP_MEMHANDLE((100, cuda_reg->data.memHandle, \"cuIpcCloseMemHandle\"));\n        }\n    }\n\n    return OPAL_SUCCESS;\n}\n\nvoid mca_common_cuda_construct_event_and_handle(uintptr_t *event, void *handle)\n{\n    CUresult result;\n\n    result = cuFunc.cuEventCreate((CUevent *)event, CU_EVENT_INTERPROCESS | CU_EVENT_DISABLE_TIMING);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventCreate failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result);\n    }\n\n    result = cuFunc.cuIpcGetEventHandle((CUipcEventHandle *)handle, (CUevent)*event);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuIpcGetEventHandle failed\",\n                       true, result);\n    }\n\n    CUDA_DUMP_EVTHANDLE((10, handle, \"construct_event_and_handle\"));\n\n}\n\nvoid mca_common_cuda_destruct_event(uintptr_t event)\n{\n    CUresult result;\n\n    /* Only attempt to destroy if we have valid context.  This can change if a call\n     * to the fini function is made and we discover context is gone. */\n    if (ctx_ok) {\n        result = cuFunc.cuEventDestroy((CUevent)event);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventDestroy failed\",\n                           true, result);\n        }\n    }\n}\n\n\n/*\n * Put remote event on stream to ensure that the the start of the\n * copy does not start until the completion of the event.\n */\nvoid mca_common_wait_stream_synchronize(mca_rcache_common_cuda_reg_t *rget_reg)\n{\n#if OPAL_CUDA_SYNC_MEMOPS\n    /* No need for any of this with SYNC_MEMOPS feature */\n    return;\n#else /* OPAL_CUDA_SYNC_MEMOPS */\n    CUipcEventHandle evtHandle;\n    CUevent event;\n    CUresult result;\n\n    memcpy(&evtHandle, rget_reg->data.evtHandle, sizeof(evtHandle));\n    CUDA_DUMP_EVTHANDLE((100, &evtHandle, \"stream_synchronize\"));\n\n    result = cuFunc.cuIpcOpenEventHandle(&event, evtHandle);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuIpcOpenEventHandle failed\",\n                       true, result);\n    }\n\n    /* BEGIN of Workaround - There is a bug in CUDA 4.1 RC2 and earlier\n     * versions.  Need to record an event on the stream, even though\n     * it is not used, to make sure we do not short circuit our way\n     * out of the cuStreamWaitEvent test.\n     */\n    result = cuFunc.cuEventRecord(event, 0);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result);\n    }\n    /* END of Workaround */\n\n    result = cuFunc.cuStreamWaitEvent(0, event, 0);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamWaitEvent failed\",\n                       true, result);\n    }\n\n    /* All done with this event. */\n    result = cuFunc.cuEventDestroy(event);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventDestroy failed\",\n                       true, result);\n    }\n#endif /* OPAL_CUDA_SYNC_MEMOPS */\n}\n\n/*\n * Start the asynchronous copy.  Then record and save away an event that will\n * be queried to indicate the copy has completed.\n */\nint mca_common_cuda_memcpy(void *dst, void *src, size_t amount, char *msg,\n                           struct mca_btl_base_descriptor_t *frag, int *done)\n{\n    CUresult result;\n    int iter;\n\n    OPAL_THREAD_LOCK(&common_cuda_ipc_lock);\n    /* First make sure there is room to store the event.  If not, then\n     * return an error.  The error message will tell the user to try and\n     * run again, but with a larger array for storing events. */\n    if (cuda_event_ipc_num_used == cuda_event_max) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"Out of cuEvent handles\",\n                       true, cuda_event_max, cuda_event_max+100, cuda_event_max+100);\n        OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n        return OPAL_ERR_OUT_OF_RESOURCE;\n    }\n\n    if (cuda_event_ipc_num_used > cuda_event_ipc_most) {\n        cuda_event_ipc_most = cuda_event_ipc_num_used;\n        /* Just print multiples of 10 */\n        if (0 == (cuda_event_ipc_most % 10)) {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"Maximum ipc events used is now %d\", cuda_event_ipc_most);\n        }\n    }\n\n    /* This is the standard way to run.  Running with synchronous copies is available\n     * to measure the advantages of asynchronous copies. */\n    if (OPAL_LIKELY(mca_common_cuda_async)) {\n        result = cuFunc.cuMemcpyAsync((CUdeviceptr)dst, (CUdeviceptr)src, amount, ipcStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpyAsync failed\",\n                           true, dst, src, amount, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        } else {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuMemcpyAsync passed: dst=%p, src=%p, size=%d\",\n                                dst, src, (int)amount);\n        }\n        result = cuFunc.cuEventRecord(cuda_event_ipc_array[cuda_event_ipc_first_avail], ipcStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                           true, OPAL_PROC_MY_HOSTNAME, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        }\n        cuda_event_ipc_frag_array[cuda_event_ipc_first_avail] = frag;\n\n        /* Bump up the first available slot and number used by 1 */\n        cuda_event_ipc_first_avail++;\n        if (cuda_event_ipc_first_avail >= cuda_event_max) {\n            cuda_event_ipc_first_avail = 0;\n        }\n        cuda_event_ipc_num_used++;\n\n        *done = 0;\n    } else {\n        /* Mimic the async function so they use the same memcpy call. */\n        result = cuFunc.cuMemcpyAsync((CUdeviceptr)dst, (CUdeviceptr)src, amount, ipcStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpyAsync failed\",\n                           true, dst, src, amount, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        } else {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuMemcpyAsync passed: dst=%p, src=%p, size=%d\",\n                                dst, src, (int)amount);\n        }\n\n        /* Record an event, then wait for it to complete with calls to cuEventQuery */\n        result = cuFunc.cuEventRecord(cuda_event_ipc_array[cuda_event_ipc_first_avail], ipcStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                           true, OPAL_PROC_MY_HOSTNAME, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        }\n\n        cuda_event_ipc_frag_array[cuda_event_ipc_first_avail] = frag;\n\n        /* Bump up the first available slot and number used by 1 */\n        cuda_event_ipc_first_avail++;\n        if (cuda_event_ipc_first_avail >= cuda_event_max) {\n            cuda_event_ipc_first_avail = 0;\n        }\n        cuda_event_ipc_num_used++;\n\n        result = cuFunc.cuEventQuery(cuda_event_ipc_array[cuda_event_ipc_first_used]);\n        if ((CUDA_SUCCESS != result) && (CUDA_ERROR_NOT_READY != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventQuery failed\",\n                           true, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        }\n\n        iter = 0;\n        while (CUDA_ERROR_NOT_READY == result) {\n            if (0 == (iter % 10)) {\n                opal_output(-1, \"EVENT NOT DONE (iter=%d)\", iter);\n            }\n            result = cuFunc.cuEventQuery(cuda_event_ipc_array[cuda_event_ipc_first_used]);\n            if ((CUDA_SUCCESS != result) && (CUDA_ERROR_NOT_READY != result)) {\n                opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventQuery failed\",\n                               true, result);\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n                return OPAL_ERROR;\n            }\n            iter++;\n        }\n\n        --cuda_event_ipc_num_used;\n        ++cuda_event_ipc_first_used;\n        if (cuda_event_ipc_first_used >= cuda_event_max) {\n            cuda_event_ipc_first_used = 0;\n        }\n        *done = 1;\n    }\n    OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n    return OPAL_SUCCESS;\n}\n\n/*\n * Record an event and save the frag.  This is called by the sending side and\n * is used to queue an event when a htod copy has been initiated.\n */\nint mca_common_cuda_record_dtoh_event(char *msg, struct mca_btl_base_descriptor_t *frag)\n{\n    CUresult result;\n\n    /* First make sure there is room to store the event.  If not, then\n     * return an error.  The error message will tell the user to try and\n     * run again, but with a larger array for storing events. */\n    OPAL_THREAD_LOCK(&common_cuda_dtoh_lock);\n    if (cuda_event_dtoh_num_used == cuda_event_max) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"Out of cuEvent handles\",\n                       true, cuda_event_max, cuda_event_max+100, cuda_event_max+100);\n        return OPAL_ERR_OUT_OF_RESOURCE;\n    }\n\n    if (cuda_event_dtoh_num_used > cuda_event_dtoh_most) {\n        cuda_event_dtoh_most = cuda_event_dtoh_num_used;\n        /* Just print multiples of 10 */\n        if (0 == (cuda_event_dtoh_most % 10)) {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"Maximum DtoH events used is now %d\", cuda_event_dtoh_most);\n        }\n    }\n\n    result = cuFunc.cuEventRecord(cuda_event_dtoh_array[cuda_event_dtoh_first_avail], dtohStream);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result);\n        OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n        return OPAL_ERROR;\n    }\n    cuda_event_dtoh_frag_array[cuda_event_dtoh_first_avail] = frag;\n\n    /* Bump up the first available slot and number used by 1 */\n    cuda_event_dtoh_first_avail++;\n    if (cuda_event_dtoh_first_avail >= cuda_event_max) {\n        cuda_event_dtoh_first_avail = 0;\n    }\n    cuda_event_dtoh_num_used++;\n\n    OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n    return OPAL_SUCCESS;\n}\n\n/*\n * Record an event and save the frag.  This is called by the receiving side and\n * is used to queue an event when a dtoh copy has been initiated.\n */\nint mca_common_cuda_record_htod_event(char *msg, struct mca_btl_base_descriptor_t *frag)\n{\n    CUresult result;\n\n    OPAL_THREAD_LOCK(&common_cuda_htod_lock);\n    /* First make sure there is room to store the event.  If not, then\n     * return an error.  The error message will tell the user to try and\n     * run again, but with a larger array for storing events. */\n    if (cuda_event_htod_num_used == cuda_event_max) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"Out of cuEvent handles\",\n                       true, cuda_event_max, cuda_event_max+100, cuda_event_max+100);\n        OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n        return OPAL_ERR_OUT_OF_RESOURCE;\n    }\n\n    if (cuda_event_htod_num_used > cuda_event_htod_most) {\n        cuda_event_htod_most = cuda_event_htod_num_used;\n        /* Just print multiples of 10 */\n        if (0 == (cuda_event_htod_most % 10)) {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"Maximum HtoD events used is now %d\", cuda_event_htod_most);\n        }\n    }\n\n    result = cuFunc.cuEventRecord(cuda_event_htod_array[cuda_event_htod_first_avail], htodStream);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventRecord failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, result);\n        OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n        return OPAL_ERROR;\n    }\n    cuda_event_htod_frag_array[cuda_event_htod_first_avail] = frag;\n\n   /* Bump up the first available slot and number used by 1 */\n    cuda_event_htod_first_avail++;\n    if (cuda_event_htod_first_avail >= cuda_event_max) {\n        cuda_event_htod_first_avail = 0;\n    }\n    cuda_event_htod_num_used++;\n\n    OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n    return OPAL_SUCCESS;\n}\n\n/**\n * Used to get the dtoh stream for initiating asynchronous copies.\n */\nvoid *mca_common_cuda_get_dtoh_stream(void) {\n    return (void *)dtohStream;\n}\n\n/**\n * Used to get the htod stream for initiating asynchronous copies.\n */\nvoid *mca_common_cuda_get_htod_stream(void) {\n    return (void *)htodStream;\n}\n\n/*\n * Function is called every time progress is called with the sm BTL.  If there\n * are outstanding events, check to see if one has completed.  If so, hand\n * back the fragment for further processing.\n */\nint progress_one_cuda_ipc_event(struct mca_btl_base_descriptor_t **frag) {\n    CUresult result;\n\n    if( OPAL_LIKELY(0 == cuda_event_ipc_num_used) )\n        return 0;\n\n    OPAL_THREAD_LOCK(&common_cuda_ipc_lock);\n    if (cuda_event_ipc_num_used > 0) {\n        opal_output_verbose(20, mca_common_cuda_output,\n                           \"CUDA: progress_one_cuda_ipc_event, outstanding_events=%d\",\n                            cuda_event_ipc_num_used);\n\n        result = cuFunc.cuEventQuery(cuda_event_ipc_array[cuda_event_ipc_first_used]);\n\n        /* We found an event that is not ready, so return. */\n        if (CUDA_ERROR_NOT_READY == result) {\n            opal_output_verbose(20, mca_common_cuda_output,\n                                \"CUDA: cuEventQuery returned CUDA_ERROR_NOT_READY\");\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return 0;\n        } else if (CUDA_SUCCESS != result) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventQuery failed\",\n                           true, result);\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n            return OPAL_ERROR;\n        }\n\n        *frag = cuda_event_ipc_frag_array[cuda_event_ipc_first_used];\n        opal_output_verbose(10, mca_common_cuda_output,\n                            \"CUDA: cuEventQuery returned %d\", result);\n\n        /* Bump counters, loop around the circular buffer if necessary */\n        --cuda_event_ipc_num_used;\n        ++cuda_event_ipc_first_used;\n        if (cuda_event_ipc_first_used >= cuda_event_max) {\n            cuda_event_ipc_first_used = 0;\n        }\n        /* A return value of 1 indicates an event completed and a frag was returned */\n        OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n        return 1;\n    }\n    OPAL_THREAD_UNLOCK(&common_cuda_ipc_lock);\n    return 0;\n}\n\n/**\n * Progress any dtoh event completions.\n */\nint progress_one_cuda_dtoh_event(struct mca_btl_base_descriptor_t **frag) {\n    CUresult result;\n\n    OPAL_THREAD_LOCK(&common_cuda_dtoh_lock);\n    if (cuda_event_dtoh_num_used > 0) {\n        opal_output_verbose(30, mca_common_cuda_output,\n                           \"CUDA: progress_one_cuda_dtoh_event, outstanding_events=%d\",\n                            cuda_event_dtoh_num_used);\n\n        result = cuFunc.cuEventQuery(cuda_event_dtoh_array[cuda_event_dtoh_first_used]);\n\n        /* We found an event that is not ready, so return. */\n        if (CUDA_ERROR_NOT_READY == result) {\n            opal_output_verbose(30, mca_common_cuda_output,\n                                \"CUDA: cuEventQuery returned CUDA_ERROR_NOT_READY\");\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n            return 0;\n        } else if (CUDA_SUCCESS != result) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventQuery failed\",\n                           true, result);\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n            return OPAL_ERROR;\n        }\n\n        *frag = cuda_event_dtoh_frag_array[cuda_event_dtoh_first_used];\n        opal_output_verbose(30, mca_common_cuda_output,\n                            \"CUDA: cuEventQuery returned %d\", result);\n\n        /* Bump counters, loop around the circular buffer if necessary */\n        --cuda_event_dtoh_num_used;\n        ++cuda_event_dtoh_first_used;\n        if (cuda_event_dtoh_first_used >= cuda_event_max) {\n            cuda_event_dtoh_first_used = 0;\n        }\n        /* A return value of 1 indicates an event completed and a frag was returned */\n        OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n        return 1;\n    }\n    OPAL_THREAD_UNLOCK(&common_cuda_dtoh_lock);\n    return 0;\n}\n\n/**\n * Progress any dtoh event completions.\n */\nint progress_one_cuda_htod_event(struct mca_btl_base_descriptor_t **frag) {\n    CUresult result;\n\n    OPAL_THREAD_LOCK(&common_cuda_htod_lock);\n    if (cuda_event_htod_num_used > 0) {\n        opal_output_verbose(30, mca_common_cuda_output,\n                           \"CUDA: progress_one_cuda_htod_event, outstanding_events=%d\",\n                            cuda_event_htod_num_used);\n\n        result = cuFunc.cuEventQuery(cuda_event_htod_array[cuda_event_htod_first_used]);\n\n        /* We found an event that is not ready, so return. */\n        if (CUDA_ERROR_NOT_READY == result) {\n            opal_output_verbose(30, mca_common_cuda_output,\n                                \"CUDA: cuEventQuery returned CUDA_ERROR_NOT_READY\");\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n            return 0;\n        } else if (CUDA_SUCCESS != result) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuEventQuery failed\",\n                           true, result);\n            *frag = NULL;\n            OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n            return OPAL_ERROR;\n        }\n\n        *frag = cuda_event_htod_frag_array[cuda_event_htod_first_used];\n        opal_output_verbose(30, mca_common_cuda_output,\n                            \"CUDA: cuEventQuery returned %d\", result);\n\n        /* Bump counters, loop around the circular buffer if necessary */\n        --cuda_event_htod_num_used;\n        ++cuda_event_htod_first_used;\n        if (cuda_event_htod_first_used >= cuda_event_max) {\n            cuda_event_htod_first_used = 0;\n        }\n        /* A return value of 1 indicates an event completed and a frag was returned */\n        OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n        return 1;\n    }\n    OPAL_THREAD_UNLOCK(&common_cuda_htod_lock);\n    return OPAL_ERR_RESOURCE_BUSY;\n}\n\n\n/**\n * Need to make sure the handle we are retrieving from the cache is still\n * valid.  Compare the cached handle to the one received.\n */\nint mca_common_cuda_memhandle_matches(mca_rcache_common_cuda_reg_t *new_reg,\n                                      mca_rcache_common_cuda_reg_t *old_reg)\n{\n\n    if (0 == memcmp(new_reg->data.memHandle, old_reg->data.memHandle, sizeof(new_reg->data.memHandle))) {\n        return 1;\n    } else {\n        return 0;\n    }\n\n}\n\n/*\n * Function to dump memory handle information.  This is based on\n * definitions from cuiinterprocess_private.h.\n */\nstatic void cuda_dump_memhandle(int verbose, void *memHandle, char *str) {\n\n    struct InterprocessMemHandleInternal\n    {\n        /* The first two entries are the CUinterprocessCtxHandle */\n        int64_t ctxId; /* unique (within a process) id of the sharing context */\n        int     pid;   /* pid of sharing context */\n\n        int64_t size;\n        int64_t blocksize;\n        int64_t offset;\n        int     gpuId;\n        int     subDeviceIndex;\n        int64_t serial;\n    } memH;\n\n    if (NULL == str) {\n        str = \"CUDA\";\n    }\n    memcpy(&memH, memHandle, sizeof(memH));\n    opal_output_verbose(verbose, mca_common_cuda_output,\n                        \"%s:ctxId=0x%\" PRIx64 \", pid=%d, size=%\" PRIu64 \", blocksize=%\" PRIu64 \", offset=%\"\n                        PRIu64 \", gpuId=%d, subDeviceIndex=%d, serial=%\" PRIu64,\n                        str, memH.ctxId, memH.pid, memH.size, memH.blocksize, memH.offset,\n                        memH.gpuId, memH.subDeviceIndex, memH.serial);\n}\n\n/*\n * Function to dump memory handle information.  This is based on\n * definitions from cuiinterprocess_private.h.\n */\nstatic void cuda_dump_evthandle(int verbose, void *evtHandle, char *str) {\n\n    struct InterprocessEventHandleInternal\n    {\n        unsigned long pid;\n        unsigned long serial;\n        int index;\n    } evtH;\n\n    if (NULL == str) {\n        str = \"CUDA\";\n    }\n    memcpy(&evtH, evtHandle, sizeof(evtH));\n    opal_output_verbose(verbose, mca_common_cuda_output,\n                        \"CUDA: %s:pid=%lu, serial=%lu, index=%d\",\n                        str, evtH.pid, evtH.serial, evtH.index);\n}\n\n\n/* Return microseconds of elapsed time. Microseconds are relevant when\n * trying to understand the fixed overhead of the communication. Used\n * when trying to time various functions.\n *\n * Cut and past the following to get timings where wanted.\n *\n *   clock_gettime(CLOCK_MONOTONIC, &ts_start);\n *   FUNCTION OF INTEREST\n *   clock_gettime(CLOCK_MONOTONIC, &ts_end);\n *   accum = mydifftime(ts_start, ts_end);\n *   opal_output(0, \"Function took   %7.2f usecs\\n\", accum);\n *\n */\n#if OPAL_ENABLE_DEBUG\nstatic float mydifftime(opal_timer_t ts_start, opal_timer_t ts_end) {\n    return (ts_end - ts_start);\n}\n#endif /* OPAL_ENABLE_DEBUG */\n\n/* Routines that get plugged into the opal datatype code */\nstatic int mca_common_cuda_is_gpu_buffer(const void *pUserBuf, opal_convertor_t *convertor)\n{\n    int res;\n    CUmemorytype memType = 0;\n    CUdeviceptr dbuf = (CUdeviceptr)pUserBuf;\n    CUcontext ctx = NULL, memCtx = NULL;\n#if OPAL_CUDA_GET_ATTRIBUTES\n    uint32_t isManaged = 0;\n    /* With CUDA 7.0, we can get multiple attributes with a single call */\n    CUpointer_attribute attributes[3] = {CU_POINTER_ATTRIBUTE_MEMORY_TYPE,\n                                         CU_POINTER_ATTRIBUTE_CONTEXT,\n                                         CU_POINTER_ATTRIBUTE_IS_MANAGED};\n    void *attrdata[] = {(void *)&memType, (void *)&memCtx, (void *)&isManaged};\n\n    res = cuFunc.cuPointerGetAttributes(3, attributes, attrdata, dbuf);\n    OPAL_OUTPUT_VERBOSE((101, mca_common_cuda_output,\n                        \"dbuf=%p, memType=%d, memCtx=%p, isManaged=%d, res=%d\",\n                         (void *)dbuf, (int)memType, (void *)memCtx, isManaged, res));\n\n    /* Mark unified memory buffers with a flag.  This will allow all unified\n     * memory to be forced through host buffers.  Note that this memory can\n     * be either host or device so we need to set this flag prior to that check. */\n    if (1 == isManaged) {\n        if (NULL != convertor) {\n            convertor->flags |= CONVERTOR_CUDA_UNIFIED;\n        }\n    }\n    if (res != CUDA_SUCCESS) {\n        /* If we cannot determine it is device pointer,\n         * just assume it is not. */\n        return 0;\n    } else if (memType == CU_MEMORYTYPE_HOST) {\n        /* Host memory, nothing to do here */\n        return 0;\n    } else if (memType == 0) {\n        /* This can happen when CUDA is initialized but dbuf is not valid CUDA pointer */\n        return 0;\n    }\n    /* Must be a device pointer */\n    assert(memType == CU_MEMORYTYPE_DEVICE);\n#else /* OPAL_CUDA_GET_ATTRIBUTES */\n    res = cuFunc.cuPointerGetAttribute(&memType,\n                                       CU_POINTER_ATTRIBUTE_MEMORY_TYPE, dbuf);\n    if (res != CUDA_SUCCESS) {\n        /* If we cannot determine it is device pointer,\n         * just assume it is not. */\n        return 0;\n    } else if (memType == CU_MEMORYTYPE_HOST) {\n        /* Host memory, nothing to do here */\n        return 0;\n    }\n    /* Must be a device pointer */\n    assert(memType == CU_MEMORYTYPE_DEVICE);\n#endif /* OPAL_CUDA_GET_ATTRIBUTES */\n\n    /* This piece of code was added in to handle in a case involving\n     * OMP threads.  The user had initialized CUDA and then spawned\n     * two threads.  The first thread had the CUDA context, but the\n     * second thread did not.  We therefore had no context to act upon\n     * and future CUDA driver calls would fail.  Therefore, if we have\n     * GPU memory, but no context, get the context from the GPU memory\n     * and set the current context to that.  It is rare that we will not\n     * have a context. */\n    res = cuFunc.cuCtxGetCurrent(&ctx);\n    if (OPAL_UNLIKELY(NULL == ctx)) {\n        if (CUDA_SUCCESS == res) {\n#if !OPAL_CUDA_GET_ATTRIBUTES\n            res = cuFunc.cuPointerGetAttribute(&memCtx,\n                                               CU_POINTER_ATTRIBUTE_CONTEXT, dbuf);\n            if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n                opal_output(0, \"CUDA: error calling cuPointerGetAttribute: \"\n                            \"res=%d, ptr=%p aborting...\", res, pUserBuf);\n                return OPAL_ERROR;\n            }\n#endif /* OPAL_CUDA_GET_ATTRIBUTES */\n            res = cuFunc.cuCtxSetCurrent(memCtx);\n            if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n                opal_output(0, \"CUDA: error calling cuCtxSetCurrent: \"\n                            \"res=%d, ptr=%p aborting...\", res, pUserBuf);\n                return OPAL_ERROR;\n            } else {\n                OPAL_OUTPUT_VERBOSE((10, mca_common_cuda_output,\n                                     \"CUDA: cuCtxSetCurrent passed: ptr=%p\", pUserBuf));\n            }\n        } else {\n            /* Print error and proceed */\n            opal_output(0, \"CUDA: error calling cuCtxGetCurrent: \"\n                        \"res=%d, ptr=%p aborting...\", res, pUserBuf);\n            return OPAL_ERROR;\n        }\n    }\n\n    /* WORKAROUND - They are times when the above code determines a pice of memory\n     * is GPU memory, but it actually is not.  That has been seen on multi-GPU systems\n     * with 6 or 8 GPUs on them. Therefore, we will do this extra check.  Note if we\n     * made it this far, then the assumption at this point is we have GPU memory.\n     * Unfotunately, this extra call is costing us another 100 ns almost doubling\n     * the cost of this entire function. */\n    if (OPAL_LIKELY(mca_common_cuda_gpu_mem_check_workaround)) {\n        CUdeviceptr pbase;\n        size_t psize;\n        res = cuFunc.cuMemGetAddressRange(&pbase, &psize, dbuf);\n        if (CUDA_SUCCESS != res) {\n            opal_output_verbose(5, mca_common_cuda_output,\n                                \"CUDA: cuMemGetAddressRange failed on this pointer: res=%d, buf=%p \"\n                                \"Overriding check and setting to host pointer. \",\n                              res, (void *)dbuf);\n            /* This cannot be GPU memory if the previous call failed */\n            return 0;\n        }\n    }\n\n    /* First access on a device pointer finalizes CUDA support initialization.\n     * If initialization fails, disable support. */\n    if (!stage_three_init_complete) {\n        if (0 != mca_common_cuda_stage_three_init()) {\n            opal_cuda_support = 0;\n        }\n    }\n\n    return 1;\n}\n\nstatic int mca_common_cuda_cu_memcpy_async(void *dest, const void *src, size_t size,\n                                         opal_convertor_t* convertor)\n{\n    return cuFunc.cuMemcpyAsync((CUdeviceptr)dest, (CUdeviceptr)src, size,\n                                (CUstream)convertor->stream);\n}\n\n/**\n * This function is plugged into various areas where a cuMemcpy would be called.\n * This is a synchronous operation that will not return until the copy is complete.\n */\nstatic int mca_common_cuda_cu_memcpy(void *dest, const void *src, size_t size)\n{\n    CUresult result;\n#if OPAL_ENABLE_DEBUG\n    CUmemorytype memTypeSrc, memTypeDst;\n    if (OPAL_UNLIKELY(mca_common_cuda_cumemcpy_timing)) {\n        /* Nice to know type of source and destination for timing output. Do\n         * not care about return code as memory type will just be set to 0 */\n        result = cuFunc.cuPointerGetAttribute(&memTypeDst,\n                                              CU_POINTER_ATTRIBUTE_MEMORY_TYPE, (CUdeviceptr)dest);\n        result = cuFunc.cuPointerGetAttribute(&memTypeSrc,\n                                              CU_POINTER_ATTRIBUTE_MEMORY_TYPE, (CUdeviceptr)src);\n        ts_start = opal_timer_base_get_usec();\n    }\n#endif\n    if (mca_common_cuda_cumemcpy_async) {\n        result = cuFunc.cuMemcpyAsync((CUdeviceptr)dest, (CUdeviceptr)src, size, memcpyStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpyAsync failed\",\n                           true, dest, src, size, result);\n            return OPAL_ERROR;\n        }\n        result = cuFunc.cuStreamSynchronize(memcpyStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamSynchronize failed\",\n                           true, OPAL_PROC_MY_HOSTNAME, result);\n            return OPAL_ERROR;\n        }\n    } else {\n         result = cuFunc.cuMemcpy((CUdeviceptr)dest, (CUdeviceptr)src, size);\n         if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n             opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpy failed\",\n                            true, OPAL_PROC_MY_HOSTNAME, result);\n             return OPAL_ERROR;\n         }\n    }\n#if OPAL_ENABLE_DEBUG\n    if (OPAL_UNLIKELY(mca_common_cuda_cumemcpy_timing)) {\n        ts_end = opal_timer_base_get_usec();\n        accum = mydifftime(ts_start, ts_end);\n        if (mca_common_cuda_cumemcpy_async) {\n            opal_output(0, \"cuMemcpyAsync took   %7.2f usecs, size=%d, (src=%p (%d), dst=%p (%d))\\n\",\n                        accum, (int)size, src, memTypeSrc, dest, memTypeDst);\n        } else {\n            opal_output(0, \"cuMemcpy took   %7.2f usecs, size=%d,  (src=%p (%d), dst=%p (%d))\\n\",\n                        accum, (int)size, src, memTypeSrc, dest, memTypeDst);\n        }\n    }\n#endif\n    return OPAL_SUCCESS;\n}\n\nstatic int mca_common_cuda_memmove(void *dest, void *src, size_t size)\n{\n    CUdeviceptr tmp;\n    int result;\n\n    result = cuFunc.cuMemAlloc(&tmp,size);\n    if (mca_common_cuda_cumemcpy_async) {\n        result = cuFunc.cuMemcpyAsync(tmp, (CUdeviceptr)src, size, memcpyStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpyAsync failed\",\n                           true, tmp, src, size, result);\n            return OPAL_ERROR;\n        }\n        result = cuFunc.cuMemcpyAsync((CUdeviceptr)dest, tmp, size, memcpyStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemcpyAsync failed\",\n                           true, dest, tmp, size, result);\n            return OPAL_ERROR;\n        }\n        result = cuFunc.cuStreamSynchronize(memcpyStream);\n        if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n            opal_show_help(\"help-mpi-common-cuda.txt\", \"cuStreamSynchronize failed\",\n                           true, OPAL_PROC_MY_HOSTNAME, result);\n            return OPAL_ERROR;\n        }\n    } else {\n        result = cuFunc.cuMemcpy(tmp, (CUdeviceptr)src, size);\n        if (OPAL_UNLIKELY(result != CUDA_SUCCESS)) {\n            opal_output(0, \"CUDA: memmove-Error in cuMemcpy: res=%d, dest=%p, src=%p, size=%d\",\n                        result, (void *)tmp, src, (int)size);\n            return OPAL_ERROR;\n        }\n        result = cuFunc.cuMemcpy((CUdeviceptr)dest, tmp, size);\n        if (OPAL_UNLIKELY(result != CUDA_SUCCESS)) {\n            opal_output(0, \"CUDA: memmove-Error in cuMemcpy: res=%d, dest=%p, src=%p, size=%d\",\n                        result, dest, (void *)tmp, (int)size);\n            return OPAL_ERROR;\n        }\n    }\n    cuFunc.cuMemFree(tmp);\n    return OPAL_SUCCESS;\n}\n\nint mca_common_cuda_get_device(int *devicenum)\n{\n    CUdevice cuDev;\n    int res;\n\n    res = cuFunc.cuCtxGetDevice(&cuDev);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_output(0, \"CUDA: cuCtxGetDevice failed: res=%d\",\n                    res);\n        return res;\n    }\n    *devicenum = cuDev;\n    return 0;\n}\n\nint mca_common_cuda_device_can_access_peer(int *access, int dev1, int dev2)\n{\n    int res;\n    res = cuFunc.cuDeviceCanAccessPeer(access, (CUdevice)dev1, (CUdevice)dev2);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_output(0, \"CUDA: cuDeviceCanAccessPeer failed: res=%d\",\n                    res);\n        return res;\n    }\n    return 0;\n}\n\nint mca_common_cuda_get_address_range(void *pbase, size_t *psize, void *base)\n{\n    CUresult result;\n    result = cuFunc.cuMemGetAddressRange((CUdeviceptr *)pbase, psize, (CUdeviceptr)base);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != result)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuMemGetAddressRange failed 2\",\n                       true, OPAL_PROC_MY_HOSTNAME, result, base);\n        return OPAL_ERROR;\n    } else {\n        opal_output_verbose(50, mca_common_cuda_output,\n                            \"CUDA: cuMemGetAddressRange passed: addr=%p, pbase=%p, psize=%lu \",\n                            base, *(char **)pbase, *psize);\n    }\n    return 0;\n}\n\n#if OPAL_CUDA_GDR_SUPPORT\n/* Check to see if the memory was freed between the time it was stored in\n * the registration cache and now.  Return true if the memory was previously\n * freed.  This is indicated by the BUFFER_ID value in the registration cache\n * not matching the BUFFER_ID of the buffer we are checking.  Return false\n * if the registration is still good.\n */\nbool mca_common_cuda_previously_freed_memory(mca_rcache_base_registration_t *reg)\n{\n    int res;\n    unsigned long long bufID;\n    unsigned char *dbuf = reg->base;\n\n    res = cuFunc.cuPointerGetAttribute(&bufID, CU_POINTER_ATTRIBUTE_BUFFER_ID,\n                                       (CUdeviceptr)dbuf);\n    /* If we cannot determine the BUFFER_ID, then print a message and default\n     * to forcing the registration to be kicked out. */\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"bufferID failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res);\n        return true;\n    }\n    opal_output_verbose(50, mca_common_cuda_output,\n                        \"CUDA: base=%p, bufID=%llu, reg->gpu_bufID=%llu, %s\", dbuf, bufID, reg->gpu_bufID,\n                        (reg->gpu_bufID == bufID ? \"BUFFER_ID match\":\"BUFFER_ID do not match\"));\n    if (bufID != reg->gpu_bufID) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/*\n * Get the buffer ID from the memory and store it in the registration.\n * This is needed to ensure the cached registration is not stale.  If\n * we fail to get buffer ID, print an error and set buffer ID to 0.\n * Also set SYNC_MEMOPS on any GPU registration to ensure that\n * synchronous copies complete before the buffer is accessed.\n */\nvoid mca_common_cuda_get_buffer_id(mca_rcache_base_registration_t *reg)\n{\n    int res;\n    unsigned long long bufID = 0;\n    unsigned char *dbuf = reg->base;\n    int enable = 1;\n\n    res = cuFunc.cuPointerGetAttribute(&bufID, CU_POINTER_ATTRIBUTE_BUFFER_ID,\n                                       (CUdeviceptr)dbuf);\n    if (OPAL_UNLIKELY(res != CUDA_SUCCESS)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"bufferID failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res);\n    }\n    reg->gpu_bufID = bufID;\n\n    res = cuFunc.cuPointerSetAttribute(&enable, CU_POINTER_ATTRIBUTE_SYNC_MEMOPS,\n                                       (CUdeviceptr)dbuf);\n    if (OPAL_UNLIKELY(CUDA_SUCCESS != res)) {\n        opal_show_help(\"help-mpi-common-cuda.txt\", \"cuPointerSetAttribute failed\",\n                       true, OPAL_PROC_MY_HOSTNAME, res, dbuf);\n    }\n}\n#endif /* OPAL_CUDA_GDR_SUPPORT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/common/cuda/help-mpi-common-cuda.txt": "# -*- text -*-\n#\n# Copyright (c) 2011-2015 NVIDIA.  All rights reserved.\n# Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n[cuCtxGetCurrent failed not initialized]\nWARNING: The call to cuCtxGetCurrent() failed while attempting to register\ninternal memory with the CUDA environment.  The program will continue to run,\nbut the performance of GPU memory transfers may be reduced.  This failure\nindicates that the CUDA environment is not yet initialized.  To eliminate\nthis warning, ensure that CUDA is initialized prior to calling MPI_Init.\n\nNOTE: You can turn off this warning by setting the MCA parameter\n      mpi_common_cuda_warning to 0.\n#\n[cuCtxGetCurrent failed]\nWARNING: The call to cuCtxGetCurrent() failed while attempting to register\ninternal memory with the CUDA environment.  The program will continue to run,\nbut the performance of GPU memory transfers may be reduced.\n  cuCtxGetCurrent return value:   %d\n\nNOTE: You can turn off this warning by setting the MCA parameter\n      mpi_common_cuda_warning to 0.\n#\n[cuCtxGetCurrent returned NULL]\nWARNING: The call to cuCtxGetCurrent() failed while attempting to register\ninternal memory with the CUDA environment.  The program will continue to run,\nbut the performance of GPU memory transfers may be reduced.  This failure\nindicates that there is no CUDA context yet.  To eliminate this warning,\nensure that there is a CUDA context prior to calling MPI_Init.\n\nNOTE: You can turn off this warning by setting the MCA parameter\n      mpi_common_cuda_warning to 0.\n#\n[cuMemHostRegister during init failed]\nThe call to cuMemHostRegister(%p, %d, 0) failed.\n  Host:  %s\n  cuMemHostRegister return value:  %d\n  Registration cache:  %s\n#\n[cuMemHostRegister failed]\nThe call to cuMemHostRegister(%p, %d, 0) failed.\n  Host:  %s\n  cuMemHostRegister return value:  %d\n  Registration cache:  %s\n#\n[cuIpcGetMemHandle failed]\nThe call to cuIpcGetMemHandle failed. This means the GPU RDMA protocol\ncannot be used.\n  cuIpcGetMemHandle return value:   %d\n  address: %p\nCheck the cuda.h file for what the return value means. Perhaps a reboot\nof the node will clear the problem.\n#\n[cuMemGetAddressRange failed]\nThe call to cuMemGetAddressRange failed. This means the GPU RDMA protocol\ncannot be used.\n  cuMemGetAddressRange return value:   %d\n  address: %p\nCheck the cuda.h file for what the return value means. Perhaps a reboot\nof the node will clear the problem.\n#\n[cuMemGetAddressRange failed 2]\nThe call to cuMemGetAddressRange failed during the GPU RDMA protocol.\n  Host:  %s\n  cuMemGetAddressRange return value:  %d\n  address:  %p\nCheck the cuda.h file for what the return value means. This is highly\nunusual and should not happen. The program will probably abort.\n#\n[Out of cuEvent handles]\nThe library has exceeded its number of outstanding event handles.\nFor better performance, this number should be increased.\n  Current maximum handles:   %4d\n  Suggested new maximum:     %4d\nRerun with --mca mpi_common_cuda_event_max %d\n#\n[cuIpcOpenMemHandle failed]\nThe call to cuIpcOpenMemHandle failed. This is an unrecoverable error\nand will cause the program to abort.\n  Hostname:                         %s\n  cuIpcOpenMemHandle return value:  %d\n  address:                          %p\nCheck the cuda.h file for what the return value means. A possible cause\nfor this is not enough free device memory.  Try to reduce the device\nmemory footprint of your application.\n#\n[cuIpcCloseMemHandle failed]\nThe call to cuIpcCloseMemHandle failed. This is a warning and the program\nwill continue to run.\n  cuIpcCloseMemHandle return value:   %d\n  address: %p\nCheck the cuda.h file for what the return value means. Perhaps a reboot\nof the node will clear the problem.\n#\n[cuMemcpyAsync failed]\nThe call to cuMemcpyAsync failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuMemcpyAsync(%p, %p, %d) returned value %d\nCheck the cuda.h file for what the return value means.\n#\n[cuEventCreate failed]\nThe call to cuEventCreate failed. This is a unrecoverable error and will\ncause the program to abort.\n  Hostname:                     %s\n  cuEventCreate return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuEventRecord failed]\nThe call to cuEventRecord failed. This is a unrecoverable error and will\ncause the program to abort.\n  Hostname:                     %s\n  cuEventRecord return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuEventQuery failed]\nThe call to cuEventQuery failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuEventQuery return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuIpcGetEventHandle failed]\nThe call to cuIpcGetEventHandle failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuIpcGetEventHandle return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuIpcOpenEventHandle failed]\nThe call to cuIpcOpenEventHandle failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuIpcOpenEventHandle return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuStreamWaitEvent failed]\nThe call to cuStreamWaitEvent failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuStreamWaitEvent return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuEventDestroy failed]\nThe call to cuEventDestory failed. This is a unrecoverable error and will\ncause the program to abort.\n  cuEventDestory return value:   %d\nCheck the cuda.h file for what the return value means.\n#\n[cuStreamCreate failed]\nThe call to cuStreamCreate failed.  This is a unrecoverable error and will\ncause the program to abort.\n  Hostname:                      %s\n  cuStreamCreate return value:   %d\nCheck the cuda.h file for what the return vale means.\n#\n[dlopen disabled]\nOpen MPI was compiled without dynamic library support (e.g., with the\n --disable-dlopen flag), and therefore cannot utilize CUDA support.\n\nIf you need CUDA support, reconfigure Open MPI with dynamic library support enabled.\n#\n[dlopen failed]\nThe library attempted to open the following supporting CUDA libraries,\nbut each of them failed.  CUDA-aware support is disabled.\n%s\nIf you do not require CUDA-aware support, then run with\n--mca opal_warn_on_missing_libcuda 0 to suppress this message.  If you do\nrequire CUDA-aware support, then try setting LD_LIBRARY_PATH to the location\nof libcuda.so.1 to resolve this issue.\n#\n[dlsym failed]\nAn error occurred while trying to map in the address of a function.\n  Function Name: %s\n  Error string:  %s\nCUDA-aware support is disabled.\n#\n[bufferID failed]\nAn error occurred while trying to get the BUFFER_ID of a GPU memory\nregion.  This could cause incorrect results.  Turn of GPU Direct RDMA\nsupport by running with --mca btl_openib_cuda_want_gdr_support 0.\n  Hostname:                             %s\n  cuPointerGetAttribute return value:   %d\nCheck the cuda.h file for what the return value means.\n[cuPointerSetAttribute failed]\nThe call to cuPointerSetAttribute with CU_POINTER_ATTRIBUTE_SYNC_MEMOPS\nfailed. This is highly unusual and should not happen.  The program will\ncontinue, but report this error to the Open MPI developers.\n  Hostname:                             %s\n  cuPointerSetAttribute return value:   %d\n  Address:                              %p\nCheck the cuda.h file for what the return value means.\n#\n[cuStreamSynchronize failed]\nThe call to cuStreamSynchronize failed. This is highly unusual and should\nnot happen.  Please report this error to the Open MPI developers.\n  Hostname:                             %s\n  cuStreamSynchronize return value:     %d\nCheck the cuda.h file for what the return value means.\n#\n[cuMemcpy failed]\nThe call to cuMemcpy failed. This is highly unusual and should\nnot happen.  Please report this error to the Open MPI developers.\n  Hostname:                  %s\n  cuMemcpy return value:     %d\nCheck the cuda.h file for what the return value means.\n#\n[No memory]\nA call to allocate memory within the CUDA support failed.  This is\nan unrecoverable error and will cause the program to abort.\n  Hostname:  %s\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/crs/self/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2004-2010 The Trustees of Indiana University.\n#                         All rights reserved.\n# Copyright (c) 2004-2005 The Trustees of the University of Tennessee.\n#                         All rights reserved.\n# Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n#                         University of Stuttgart.  All rights reserved.\n# Copyright (c) 2004-2005 The Regents of the University of California.\n#                         All rights reserved.\n# Copyright (c) 2010      Cisco Systems, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\n# MCA_crs_self_CONFIG([action-if-found], [action-if-not-found])\n# -----------------------------------------------------------\nAC_DEFUN([MCA_opal_crs_self_CONFIG],[\n    AC_CONFIG_FILES([opal/mca/crs/self/Makefile])\n\n    # If we don't want FT, don't compile this component\n    AS_IF([test \"$opal_want_ft_cr\" = \"1\"],\n        [crs_self_good=\"yes\"],\n        [crs_self_good=\"no\"])\n\n    # We need the dlfcn.h so we can access dlsym and friends\n    AS_IF([test \"$crs_self_good\" = \"yes\"],\n        [AC_CHECK_HEADER([dlfcn.h],\n                         [crs_self_good=\"yes\"],\n                         [crs_self_good=\"no\"])])\n\n    # If they did not ask for dlopen support,\n    # they probably do not want this component either\n    AS_IF([test \"$crs_self_good\" = \"yes\"],\n        [AS_IF([test \"$OPAL_ENABLE_DLOPEN_SUPPORT\" = \"1\"],\n                [crs_self_good=\"yes\"],\n                [crs_self_good=\"no\"])])\n\n    AS_IF([test \"$crs_self_good\" = \"yes\"],\n        [$1],\n        [$2])\n\n])dnl\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/crs/self/crs_self_module.c": "/*\n * Copyright (c) 2004-2010 The Trustees of Indiana University.\n *                         All rights reserved.\n * Copyright (c) 2004-2005 The Trustees of the University of Tennessee.\n *                         All rights reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2007      Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * Copyright (c) 2007      Evergrid, Inc. All rights reserved.\n *\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"opal_config.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif  /* HAVE_UNISTD_H */\n#include <string.h>\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include \"opal/util/opal_environ.h\"\n#include \"opal/util/output.h\"\n#include \"opal/util/show_help.h\"\n#include \"opal/util/argv.h\"\n#include \"opal/util/opal_environ.h\"\n#include \"opal/util/printf.h\"\n\n#include \"opal/constants.h\"\n#include \"opal/mca/base/mca_base_var.h\"\n\n#include \"opal/mca/crs/crs.h\"\n#include \"opal/mca/crs/base/base.h\"\n#include \"opal/runtime/opal_cr.h\"\n\n#include \"crs_self.h\"\n\n/*\n * Self module\n */\nstatic opal_crs_base_module_t loc_module = {\n    /** Initialization Function */\n    opal_crs_self_module_init,\n    /** Finalization Function */\n    opal_crs_self_module_finalize,\n\n    /** Checkpoint interface */\n    opal_crs_self_checkpoint,\n\n    /** Restart Command Access */\n    opal_crs_self_restart,\n\n    /** Disable checkpoints */\n    opal_crs_self_disable_checkpoint,\n    /** Enable checkpoints */\n    opal_crs_self_enable_checkpoint,\n\n    /** Prelaunch */\n    opal_crs_self_prelaunch,\n\n    /** Register Thread */\n    opal_crs_self_reg_thread\n};\n\n/*\n * Snapshot structure\n */\nOBJ_CLASS_DECLARATION(opal_crs_self_snapshot_t);\n\nstruct opal_crs_self_snapshot_t {\n    /** Base CRS snapshot type */\n    opal_crs_base_snapshot_t super;\n    /** Command Line used to restart the app */\n    char * cmd_line;\n};\ntypedef struct opal_crs_self_snapshot_t opal_crs_self_snapshot_t;\n\nstatic void opal_crs_self_construct(opal_crs_self_snapshot_t *obj);\nstatic void opal_crs_self_destruct( opal_crs_self_snapshot_t *obj);\n\nOBJ_CLASS_INSTANCE(opal_crs_self_snapshot_t,\n                   opal_crs_base_snapshot_t,\n                   opal_crs_self_construct,\n                   opal_crs_self_destruct);\n\n\ntypedef void (*opal_crs_self_dlsym_dummy_fn_t)(void);\n\n/************************************\n * Locally Global vars & functions :)\n ************************************/\nstatic int crs_self_find_function(char *prefix, char *suffix,\n                                  opal_crs_self_dlsym_dummy_fn_t *fn_ptr);\n\nstatic int self_update_snapshot_metadata(opal_crs_self_snapshot_t *snapshot);\n\nstatic int opal_crs_self_restart_cmd(opal_crs_self_snapshot_t *snapshot, char **cmd);\nstatic int self_cold_start(opal_crs_self_snapshot_t *snapshot);\n\nvoid opal_crs_self_construct(opal_crs_self_snapshot_t *snapshot)\n{\n    snapshot->cmd_line = NULL;\n}\n\nvoid opal_crs_self_destruct( opal_crs_self_snapshot_t *snapshot)\n{\n    if(NULL != snapshot->cmd_line)\n        free(snapshot->cmd_line);\n}\n\nstatic int opal_crs_self_extract_callbacks(void);\n\n/*\n * MCA Functions\n */\nint opal_crs_self_component_query(mca_base_module_t **module, int *priority)\n{\n    int ret;\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: component_query()\");\n\n    /*\n     * If this is a tool, then return a module with the lowest priority.\n     * This allows 'mpirun' to select the 'none' component since it has\n     * a priority higher than 0.\n     * But also allows 'opal-restart' to select this component if needed\n     * since it only ever requests that a specific component be opened\n     * that is defined in the snapshot metadata file.\n     */\n    if( opal_cr_is_tool ) {\n        *priority = 0;\n        *module = (mca_base_module_t *)&loc_module;\n        return OPAL_SUCCESS;\n    }\n\n    /*\n     * Extract the user level callbacks if they exist\n     */\n    ret = opal_crs_self_extract_callbacks();\n\n    if( OPAL_SUCCESS != ret ||\n        !mca_crs_self_component.can_checkpoint ) {\n        *priority = -1;\n        *module = NULL;\n        return OPAL_ERROR;\n    }\n    else {\n        *priority = mca_crs_self_component.super.priority;\n        *module = (mca_base_module_t *)&loc_module;\n        return OPAL_SUCCESS;\n    }\n}\n\nstatic int opal_crs_self_extract_callbacks(void)\n{\n    opal_crs_self_dlsym_dummy_fn_t loc_fn;\n\n    /*\n     * Find the function names\n     */\n    crs_self_find_function(mca_crs_self_component.prefix,\n                           SUFFIX_CHECKPOINT,\n                           &loc_fn);\n    mca_crs_self_component.ucb_checkpoint_fn = (opal_crs_self_checkpoint_callback_fn_t)loc_fn;\n\n    crs_self_find_function(mca_crs_self_component.prefix,\n                           SUFFIX_CONTINUE,\n                           &loc_fn);\n    mca_crs_self_component.ucb_continue_fn = (opal_crs_self_continue_callback_fn_t)loc_fn;\n\n    crs_self_find_function(mca_crs_self_component.prefix,\n                           SUFFIX_RESTART,\n                           &loc_fn);\n    mca_crs_self_component.ucb_restart_fn = (opal_crs_self_restart_callback_fn_t)loc_fn;\n\n    /*\n     * Sanity check\n     */\n    mca_crs_self_component.can_checkpoint = true;\n\n    if(NULL == mca_crs_self_component.ucb_checkpoint_fn) {\n        mca_crs_self_component.can_checkpoint = false;\n    }\n    if(NULL == mca_crs_self_component.ucb_continue_fn) {\n    }\n    if(NULL == mca_crs_self_component.ucb_restart_fn) {\n    }\n\n    return OPAL_SUCCESS;\n}\n\nint opal_crs_self_module_init(void)\n{\n    bool callback_matched = true;\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: module_init()\");\n\n    if( opal_cr_is_tool ) {\n        return OPAL_SUCCESS;\n    }\n\n    /*\n     * Sanity check\n     */\n    if(NULL == mca_crs_self_component.ucb_checkpoint_fn) {\n        callback_matched = false;\n        mca_crs_self_component.can_checkpoint = false;\n    }\n    if(NULL == mca_crs_self_component.ucb_continue_fn) {\n        callback_matched = false;\n    }\n    if(NULL == mca_crs_self_component.ucb_restart_fn) {\n        callback_matched = false;\n    }\n    if( !callback_matched ) {\n        if( 1 <= mca_crs_self_component.super.verbose ) {\n            opal_show_help(\"help-opal-crs-self.txt\", \"self:no_callback\", false,\n                           \"checkpoint\", mca_crs_self_component.prefix, SUFFIX_CHECKPOINT,\n                           \"continue  \", mca_crs_self_component.prefix, SUFFIX_CONTINUE,\n                           \"restart   \", mca_crs_self_component.prefix, SUFFIX_RESTART,\n                           PREFIX_DEFAULT);\n        }\n    }\n\n    /*\n     * If the user requested that we do_restart, then call their callback\n     */\n    if(mca_crs_self_component.do_restart) {\n        opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                            \"crs:self: module_init: Call their restart function\");\n        if( NULL != mca_crs_self_component.ucb_restart_fn)\n            mca_crs_self_component.ucb_restart_fn();\n    }\n\n    return OPAL_SUCCESS;\n}\n\nint opal_crs_self_module_finalize(void)\n{\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: module_finalize()\");\n\n    return OPAL_SUCCESS;\n}\n\n\nint opal_crs_self_checkpoint(pid_t pid,\n                             opal_crs_base_snapshot_t *base_snapshot,\n                             opal_crs_base_ckpt_options_t *options,\n                             opal_crs_state_type_t *state)\n{\n    opal_crs_self_snapshot_t *snapshot = OBJ_NEW(opal_crs_self_snapshot_t);\n    int ret, exit_status = OPAL_SUCCESS;\n    char * restart_cmd = NULL;\n\n    /*\n     * This function should never be called by a tool\n     */\n    if( opal_cr_is_tool ) {\n        return OPAL_ERR_NOT_SUPPORTED;\n    }\n\n    if( options->stop ) {\n        opal_output(0,\n                    \"crs:self: checkpoint(): Error: SIGSTOP Not currently supported!\");\n    }\n\n    /*\n     * Setup for snapshot directory creation\n     */\n    snapshot->super = *base_snapshot;\n#if 0\n    snapshot->super.snapshot_directory = strdup(base_snapshot->snapshot_directory);\n    snapshot->super.metadata_filename  = strdup(base_snapshot->metadata_filename);\n#endif\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: checkpoint(%d, ---)\", pid);\n\n    if(!mca_crs_self_component.can_checkpoint) {\n        opal_show_help(\"help-opal-crs-self.txt\", \"self:ckpt_disabled\", false);\n        exit_status = OPAL_ERROR;\n        goto cleanup;\n    }\n\n    /*\n     * Update the snapshot metadata\n     */\n    snapshot->super.component_name = strdup(mca_crs_self_component.super.base_version.mca_component_name);\n    if( NULL == snapshot->super.metadata ) {\n        if (NULL == (snapshot->super.metadata = fopen(snapshot->super.metadata_filename, \"a\")) ) {\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:self: checkpoint(): Error: Unable to open the file (%s)\",\n                        snapshot->super.metadata_filename);\n            exit_status = OPAL_ERROR;\n            goto cleanup;\n        }\n    }\n    fprintf(snapshot->super.metadata, \"%s%s\\n\", CRS_METADATA_COMP, snapshot->super.component_name);\n\n    /*\n     * Call the user callback function\n     */\n    if(NULL != mca_crs_self_component.ucb_checkpoint_fn) {\n        mca_crs_self_component.ucb_checkpoint_fn(&restart_cmd);\n    }\n\n    /*\n     * Save the restart command\n     */\n    if( NULL == restart_cmd) {\n        *state = OPAL_CRS_ERROR;\n        opal_show_help(\"help-opal-crs-self.txt\", \"self:no-restart-cmd\",\n                       true);\n        exit_status = OPAL_ERROR;\n        goto cleanup;\n    }\n    else {\n        snapshot->cmd_line = strdup(restart_cmd);\n\n        opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                            \"crs:self: checkpoint: Restart Command (%s)\", snapshot->cmd_line);\n    }\n\n    /*\n     * The best we can do is update the metadata file with the\n     * application argv and argc we started with.\n     */\n    if( OPAL_SUCCESS != (ret = self_update_snapshot_metadata(snapshot)) ) {\n        *state = OPAL_CRS_ERROR;\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: checkpoint(): Error: Unable to update metadata for snapshot (%s).\",\n                    snapshot->super.metadata_filename);\n        exit_status = ret;\n        goto cleanup;\n    }\n\n\n    *state = OPAL_CRS_CONTINUE;\n\n    /*\n     * Call their continue routine for completeness\n     */\n    if(NULL != mca_crs_self_component.ucb_continue_fn) {\n        mca_crs_self_component.ucb_continue_fn();\n    }\n\n    base_snapshot = &(snapshot->super);\n\n cleanup:\n    if( NULL != restart_cmd) {\n        free(restart_cmd);\n        restart_cmd = NULL;\n    }\n\n    return exit_status;\n}\n\n/*\n * Notice that the user restart callback is not called here, but always from\n *  opal_init for the self module.\n */\nint opal_crs_self_restart(opal_crs_base_snapshot_t *base_snapshot, bool spawn_child, pid_t *child_pid)\n{\n    opal_crs_self_snapshot_t *snapshot = OBJ_NEW(opal_crs_self_snapshot_t);\n    char **cr_argv = NULL;\n    char * cr_cmd = NULL;\n    int ret;\n    int exit_status = OPAL_SUCCESS;\n    int status;\n\n    snapshot->super = *base_snapshot;\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: restart(%d)\", spawn_child);\n\n    /*\n     * If we need to reconstruct the snapshot\n     */\n    if(snapshot->super.cold_start) {\n        if( OPAL_SUCCESS != (ret = self_cold_start(snapshot)) ){\n            exit_status = ret;\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:blcr: blcr_restart: Unable to reconstruct the snapshot.\");\n            goto cleanup;\n        }\n    }\n\n    /*\n     * JJH: Check to make sure the application exists?\n     */\n\n    /*\n     * Get the restart command\n     */\n    if ( OPAL_SUCCESS != (ret = opal_crs_self_restart_cmd(snapshot, &cr_cmd)) ) {\n        exit_status = ret;\n        goto cleanup;\n    }\n    if ( NULL == (cr_argv = opal_argv_split(cr_cmd, ' ')) ) {\n        exit_status = OPAL_ERROR;\n        goto cleanup;\n    }\n\n\n    if (!spawn_child) {\n        opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                            \"crs:self: self_restart: SELF: exec :(%s, %s):\",\n                            strdup(cr_argv[0]),\n                            opal_argv_join(cr_argv, ' '));\n\n        status = execvp(strdup(cr_argv[0]), cr_argv);\n\n        if(status < 0) {\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:self: self_restart: SELF: Child failed to execute :(%d):\", status);\n        }\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: self_restart: SELF: execvp returned %d\", status);\n        exit_status = status;\n        goto cleanup;\n    }\n    else {\n        *child_pid = fork();\n        if( *child_pid == 0) {\n            /* Child Process */\n            opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                                \"crs:self: self_restart: CHILD: exec :(%s, %s):\",\n                                strdup(cr_argv[0]),\n                                opal_argv_join(cr_argv, ' '));\n\n            status = execvp(strdup(cr_argv[0]), cr_argv);\n\n            if(status < 0) {\n                opal_output(mca_crs_self_component.super.output_handle,\n                            \"crs:self: self_restart: CHILD: Child failed to execute :(%d):\", status);\n            }\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:self: self_restart: CHILD: execvp returned %d\", status);\n            exit_status = status;\n            goto cleanup;\n        }\n        else if(*child_pid > 0) {\n            /* Parent is done once it is started. */\n            ;\n        }\n        else {\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:self: self_restart: CHILD: fork failed :(%d):\", *child_pid);\n        }\n    }\n\n cleanup:\n    if( NULL != cr_cmd)\n        free(cr_cmd);\n    if( NULL != cr_argv)\n        opal_argv_free(cr_argv);\n\n    return exit_status;\n}\n\nint opal_crs_self_disable_checkpoint(void)\n{\n    /*\n     * This function should never be called by a tool\n     */\n    if( opal_cr_is_tool ) {\n        return OPAL_ERR_NOT_SUPPORTED;\n    }\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: disable_checkpoint()\");\n\n    mca_crs_self_component.can_checkpoint = false;\n\n    return OPAL_SUCCESS;\n}\n\nint opal_crs_self_enable_checkpoint(void)\n{\n    /*\n     * This function should never be called by a tool\n     */\n    if( opal_cr_is_tool ) {\n        return OPAL_ERR_NOT_SUPPORTED;\n    }\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: enable_checkpoint()\");\n\n    mca_crs_self_component.can_checkpoint = true;\n\n    return OPAL_SUCCESS;\n}\n\nint opal_crs_self_prelaunch(int32_t rank,\n                            char *base_snapshot_dir,\n                            char **app,\n                            char **cwd,\n                            char ***argv,\n                            char ***env)\n{\n    char * tmp_env_var = NULL;\n\n    /*\n     * This function should never be called by a tool\n     */\n    if( opal_cr_is_tool ) {\n        return OPAL_ERR_NOT_SUPPORTED;\n    }\n\n    (void) mca_base_var_env_name(\"opal_cr_is_tool\", &tmp_env_var);\n    opal_setenv(tmp_env_var,\n                \"0\", true, env);\n    free(tmp_env_var);\n    tmp_env_var = NULL;\n\n    return OPAL_SUCCESS;\n}\n\nint opal_crs_self_reg_thread(void)\n{\n    /*\n     * This function should never be called by a tool\n     */\n    if( opal_cr_is_tool ) {\n        return OPAL_ERR_NOT_SUPPORTED;\n    }\n\n    return OPAL_SUCCESS;\n}\n\n/******************\n * Local functions\n ******************/\nstatic int crs_self_find_function(char *prefix, char *suffix,\n                                  opal_crs_self_dlsym_dummy_fn_t *fn_ptr) {\n    char *func_to_find = NULL;\n\n    if( NULL == prefix || 0 >= strlen(prefix) ) {\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: crs_self_find_function: Error: prefix is NULL or empty string!\");\n        *fn_ptr = NULL;\n        return OPAL_ERROR;\n    }\n    if( NULL == suffix || 0 >= strlen(suffix) ) {\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: crs_self_find_function: Error: suffix is NULL or empty string!\");\n        *fn_ptr = NULL;\n        return OPAL_ERROR;\n    }\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: crs_self_find_function(--, %s, %s)\",\n                        prefix, suffix);\n\n    opal_asprintf(&func_to_find, \"%s_%s\", prefix, suffix);\n\n    /* The RTLD_DEFAULT is a special handle that searches the default libraries\n     * including the current application for the indicated symbol. This allows\n     * us to not have to dlopen/dlclose the executable. A bit of short hand\n     * really.\n     */\n    *((void**) fn_ptr) = dlsym(RTLD_DEFAULT, func_to_find);\n    if( NULL == fn_ptr) {\n        opal_output_verbose(12, mca_crs_self_component.super.output_handle,\n                            \"crs:self: crs_self_find_function: WARNING: Function \\\"%s\\\" not found\",\n                            func_to_find);\n    }\n    else {\n        opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                            \"crs:self: crs_self_find_function: Found function \\\"%s\\\"\",\n                            func_to_find);\n    }\n\n    if( NULL == func_to_find) {\n        free(func_to_find);\n    }\n\n    return OPAL_SUCCESS;\n}\n\n/*\n * Self is a special case. The 'fname' here is the command line that the user\n * wishes to execute. This function takes this command line and adds\n *   -mca crs_self_do_restart 1\n * Which will trigger the restart callback once the program has been run.\n *\n * For example, The user starts their program with:\n *   $ my_prog arg1 arg2\n *\n * They checkpoint it:\n *   $ opal_checkpoint -mca crs self 1234\n *\n * They restart it:\n *   $ opal_restart -mca crs self my_prog arg1 arg2\n *\n * fname is then:\n *   fname = \"my_prog arg1 arg2\"\n *\n * This funciton translates that to the command:\n *   cmd = \"my_prog arg1 arg2 -mca crs self -mca crs_self_do_restart 1\"\n *\n * Which will cause the program \"my_prog\" to call their restart function\n * upon opal_init time.\n *\n * Note: The user could bypass the opal_restart routine safely by simply calling\n *   $ my_prog arg1 arg2 -mca crs self -mca crs_self_do_restart 1\n * However, for consistency sake, we should not encourage this as it won't work for\n * all of the other checkpointers.\n */\nstatic int opal_crs_self_restart_cmd(opal_crs_self_snapshot_t *snapshot, char **cmd)\n{\n    char * tmp_env_var = NULL;\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: restart_cmd(%s, ---)\", snapshot->cmd_line);\n\n    (void) mca_base_var_env_name(\"crs\", &tmp_env_var);\n    opal_setenv(tmp_env_var,\n                \"self\",\n                true, &environ);\n    free(tmp_env_var);\n    tmp_env_var = NULL;\n\n    (void) mca_base_var_env_name(\"crs_self_do_restart\", &tmp_env_var);\n    opal_setenv(tmp_env_var,\n                \"1\",\n                true, &environ);\n    free(tmp_env_var);\n    tmp_env_var = NULL;\n\n    (void) mca_base_var_env_name(\"crs_self_prefix\", &tmp_env_var);\n    opal_setenv(tmp_env_var,\n                mca_crs_self_component.prefix,\n                true, &environ);\n    free(tmp_env_var);\n    tmp_env_var = NULL;\n\n    /* Instead of adding it to the command line, we should use the environment\n     * to pass the values. This allow sthe OPAL application to be braindead\n     * WRT MCA parameters\n     *   add_args = strdup(\"-mca crs self -mca crs_self_do_restart 1\");\n     */\n\n    opal_asprintf(cmd, \"%s\", snapshot->cmd_line);\n\n    return OPAL_SUCCESS;\n}\n\nstatic int self_cold_start(opal_crs_self_snapshot_t *snapshot) {\n    int ret, exit_status = OPAL_SUCCESS;\n    char **tmp_argv = NULL;\n    char * component_name = NULL;\n    int prev_pid;\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: cold_start()\");\n\n    /*\n     * Find the snapshot directory, read the metadata file\n     */\n    if( NULL == snapshot->super.metadata ) {\n        if (NULL == (snapshot->super.metadata = fopen(snapshot->super.metadata_filename, \"a\")) ) {\n            opal_output(mca_crs_self_component.super.output_handle,\n                        \"crs:self: checkpoint(): Error: Unable to open the file (%s)\",\n                        snapshot->super.metadata_filename);\n            exit_status = OPAL_ERROR;\n            goto cleanup;\n        }\n    }\n    if( OPAL_SUCCESS != (ret = opal_crs_base_extract_expected_component(snapshot->super.metadata,\n                                                                        &component_name, &prev_pid) ) ) {\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: self_cold_start: Error: Failed to extract the metadata from the local snapshot (%s). Returned %d.\",\n                    snapshot->super.metadata_filename, ret);\n        exit_status = ret;\n        goto cleanup;\n    }\n\n    snapshot->super.component_name = strdup(component_name);\n\n    /* Compare the strings to make sure this is our snapshot before going further */\n    if ( 0 != strncmp(mca_crs_self_component.super.base_version.mca_component_name,\n                      component_name, strlen(component_name)) ) {\n        exit_status = OPAL_ERROR;\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: self_cold_start: Error: This snapshot (%s) is not intended for us (%s)\\n\",\n                    component_name, mca_crs_self_component.super.base_version.mca_component_name);\n        goto cleanup;\n    }\n\n    /*\n     * Restart command\n     * JJH: Command lines limited to 256 chars.\n     */\n    opal_crs_base_metadata_read_token(snapshot->super.metadata, CRS_METADATA_CONTEXT, &tmp_argv);\n    if( NULL == tmp_argv ) {\n        opal_output(mca_crs_self_component.super.output_handle,\n                    \"crs:self: self_cold_start: Error: Failed to read the %s token from the local checkpoint in %s\",\n                    CRS_METADATA_CONTEXT, snapshot->super.snapshot_directory);\n        exit_status = OPAL_ERROR;\n        goto cleanup;\n    }\n    opal_asprintf(&snapshot->cmd_line, \"%s\", tmp_argv[0]);\n\n    /*\n     * Reset the cold_start flag\n     */\n    snapshot->super.cold_start = false;\n\n cleanup:\n    if(NULL != tmp_argv) {\n        opal_argv_free(tmp_argv);\n        tmp_argv = NULL;\n    }\n\n    return exit_status;\n\n}\n\nstatic int self_update_snapshot_metadata(opal_crs_self_snapshot_t *snapshot) {\n    int exit_status = OPAL_SUCCESS;\n\n    if(NULL == snapshot->cmd_line) {\n        opal_show_help(\"help-opal-crs-self.txt\", \"self:no-restart-cmd\",\n                       true);\n        exit_status = OPAL_ERROR;\n        goto cleanup;\n    }\n\n    opal_output_verbose(10, mca_crs_self_component.super.output_handle,\n                        \"crs:self: update_snapshot_metadata(%s)\",\n                        snapshot->super.metadata_filename);\n\n    /*\n     * Append to the metadata file the command line to restart with\n     *  - How user wants us to restart\n     */\n    fprintf(snapshot->super.metadata, \"%s%s\\n\", CRS_METADATA_CONTEXT, snapshot->cmd_line);\n\n cleanup:\n    return exit_status;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/patcher/overwrite/patcher_overwrite_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2016-2018 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2017      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"patcher_overwrite.h\"\n\n#include \"opal/mca/patcher/base/base.h\"\n\n#include \"opal/constants.h\"\n#include \"opal/util/sys_limits.h\"\n#include \"opal/util/output.h\"\n#include \"opal/prefetch.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <assert.h>\n\n#if (OPAL_ASSEMBLY_ARCH == OPAL_IA32) || (OPAL_ASSEMBLY_ARCH == OPAL_X86_64)\n\nstatic int mca_patcher_overwrite_apply_patch (mca_patcher_base_patch_t *patch)\n{\n    uintptr_t func_new_addr = patch->patch_value;\n\n    {\n#if (OPAL_ASSEMBLY_ARCH == OPAL_IA32)\n        patch->patch_data_size = 5;\n        *(unsigned char *)(patch->patch_data+0) = 0xe9;\n        *(unsigned int *) (patch->patch_data+1) = (unsigned int)(func_new_addr - patch->patch_orig - 5);\n#elif (OPAL_ASSEMBLY_ARCH == OPAL_X86_64)\n        patch->patch_data_size = 13;\n        *(unsigned short*)(patch->patch_data + 0) = 0xbb49;\n        *(unsigned long* )(patch->patch_data + 2) = (unsigned long) func_new_addr;\n        *(unsigned char*) (patch->patch_data +10) = 0x41;\n        *(unsigned char*) (patch->patch_data +11) = 0xff;\n        *(unsigned char*) (patch->patch_data +12) = 0xe3;\n#endif\n    }\n\n    mca_base_patcher_patch_apply_binary (patch);\n\n    return OPAL_SUCCESS;\n}\n\n/* end of #if defined(__i386__) || defined(__x86_64__) || defined(__ia64__) */\n// ------------------------------------------------- PPC equivalent:\n#elif (OPAL_ASSEMBLY_ARCH == OPAL_POWERPC32) || (OPAL_ASSEMBLY_ARCH == OPAL_POWERPC64)\n\n// PowerPC instructions used in patching\n// Reference: \"PowerPC User Instruction Set Architecture\"\nstatic unsigned int addis(unsigned int RT, unsigned int RS, unsigned int UI) {\n    return (15<<26) + (RT<<21) + (RS<<16) + (UI&0xffff);\n}\nstatic unsigned int ori(unsigned int RT, unsigned int RS, unsigned int UI) {\n    return (24<<26) + (RS<<21) + (RT<<16) + (UI&0xffff);\n}\nstatic unsigned int oris(unsigned int RT, unsigned int RS, unsigned int UI) {\n    return (25<<26) + (RS<<21) + (RT<<16) + (UI&0xffff);\n}\nstatic unsigned int mtspr(unsigned int SPR, unsigned int RS) {\n    return (31<<26) + (RS<<21) + ((SPR&0x1f)<<16) + ((SPR>>5)<<11) + (467<<1);\n}\nstatic unsigned int bcctr(unsigned int BO, unsigned int BI, unsigned int BH) {\n    return (19<<26) + (BO<<21) + (BI<<16) + (BH<<11) + (528<<1);\n}\nstatic unsigned int rldicr(unsigned int RT, unsigned int RS, unsigned int SH, unsigned int MB)\n{\n    return (30<<26) + (RS<<21) + (RT<<16) + ((SH&0x1f)<<11) + ((SH>>5)<<1)\n        + ((MB&0x1f)<<6) + ((MB>>5)<<5) + (1<<2);\n}\n\nstatic int\nPatchLoadImm(uintptr_t addr, unsigned int reg, size_t value)\n{\n#if (OPAL_ASSEMBLY_ARCH == OPAL_POWERPC64)\n    *(unsigned int *) (addr + 0) = addis ( reg, 0,   (value >> 48));\n    *(unsigned int *) (addr + 4) = ori   ( reg, reg, (value >> 32));\n    *(unsigned int *) (addr + 8) = rldicr( reg, reg, 32, 31);\n    *(unsigned int *) (addr +12) = oris  ( reg, reg, (value >> 16));\n    *(unsigned int *) (addr +16) = ori   ( reg, reg, (value >>  0));\n    return 20;\n#else\n    *(unsigned int *) (addr + 0) = addis ( reg, 0,   (value >> 16));\n    *(unsigned int *) (addr + 4) = ori   ( reg, reg, (value >>  0));\n    return 8;\n#endif\n}\n\n\nstatic int mca_patcher_overwrite_apply_patch (mca_patcher_base_patch_t *patch)\n{\n    uintptr_t sys_addr, hook_addr;\n    int offset, rc;\n\n    // get system function address\n    sys_addr = mca_patcher_base_addr_text(patch->patch_orig);\n    hook_addr = mca_patcher_base_addr_text(patch->patch_value);\n\n// Patch for hook function:\n#if (OPAL_ASSEMBLY_ARCH == OPAL_POWERPC64)\n    rc = mca_patcher_base_patch_hook (&mca_patcher_overwrite_module, hook_addr);\n    if (OPAL_SUCCESS != rc) {\n        return rc;\n    }\n\n#if defined(_CALL_ELF) && (_CALL_ELF == 2)\n    sys_addr += 8;\n    hook_addr += 8;\n#endif /* _CALL_ELF == 2*/\n#endif\n\n    // Patch for system function:\n    // generate patch code\n    // r11 is a volatile register according to PowerPC EABI\n    const unsigned int gr = 11;\n    offset = PatchLoadImm ((uintptr_t) patch->patch_data, gr, hook_addr);\n    *(unsigned int *) (patch->patch_data + offset + 0) = mtspr (9, gr);   // 9 = CTR\n    *(unsigned int *) (patch->patch_data + offset + 4) = bcctr (20, 0, 0);// 20 = always\n    patch->patch_data_size = offset + 8;\n    patch->patch_orig = sys_addr;\n\n    mca_base_patcher_patch_apply_binary (patch);\n\n    return OPAL_SUCCESS;\n}\n\n#elif defined(__aarch64__)\n\n/**\n * @brief Generate a mov immediate instruction\n *\n * @param[in] reg   register number (0-31)\n * @param[in] shift shift amount (0-3) * 16-bits\n * @param[in] value immediate value\n */\nstatic uint32_t mov (unsigned int reg, uint16_t shift, uint16_t value)\n{\n    return (0x1a5 << 23) + ((uint32_t) shift << 21) + ((uint32_t) value << 5) + reg;\n}\n\n/**\n * @brief Generate a mov immediate with keep instruction\n *\n * @param[in] reg   register number (0-31)\n * @param[in] shift shift amount (0-3) * 16-bits\n * @param[in] value immediate value\n */\nstatic uint32_t movk (unsigned int reg, uint16_t shift, uint16_t value)\n{\n    return (0x1e5 << 23) + ((uint32_t) shift << 21) + ((uint32_t) value << 5) + reg;\n}\n\nstatic uint32_t br (unsigned int reg)\n{\n    return (0xd61f << 16) + (reg << 5);\n}\n\nstatic int\nPatchLoadImm(uintptr_t addr, unsigned int reg, uint64_t value)\n{\n    *(uint32_t *) (addr +  0) = mov(reg, 3, value >> 48);\n    *(uint32_t *) (addr +  4) = movk(reg, 2, value >> 32);\n    *(uint32_t *) (addr +  8) = movk(reg, 1, value >> 16);\n    *(uint32_t *) (addr + 12) = movk(reg, 0, value);\n    return 16;\n}\n\nstatic int mca_patcher_overwrite_apply_patch (mca_patcher_base_patch_t *patch)\n{\n    uintptr_t sys_addr, hook_addr;\n    int offset, rc;\n\n    /* get system function address */\n    sys_addr = mca_patcher_base_addr_text(patch->patch_orig);\n    hook_addr = mca_patcher_base_addr_text(patch->patch_value);\n\n    /* Patch for hook function: */\n    rc = mca_patcher_base_patch_hook (&mca_patcher_overwrite_module, hook_addr);\n    if (OPAL_SUCCESS != rc) {\n        return rc;\n    }\n\n    /* Patch for system function:\n     * generate patch code\n     * r15 is the highest numbered temporary register. I am assuming this one is safe\n     * to use. */\n    const unsigned int gr = 15;\n    offset = PatchLoadImm ((uintptr_t) patch->patch_data, gr, hook_addr);\n    *(uint32_t *) (patch->patch_data + offset) = br(gr);\n    patch->patch_data_size = offset + 4;\n    patch->patch_orig = sys_addr;\n\n    mca_base_patcher_patch_apply_binary (patch);\n\n    return OPAL_SUCCESS;\n}\n\n#endif\n\nstatic int mca_patcher_overwrite_patch_address (uintptr_t sys_addr, uintptr_t hook_addr)\n{\n    mca_patcher_base_patch_t *patch;\n    int rc;\n\n    patch = OBJ_NEW(mca_patcher_base_patch_t);\n    if (OPAL_UNLIKELY(NULL == patch)) {\n        return OPAL_ERR_OUT_OF_RESOURCE;\n    }\n\n    patch->patch_orig = sys_addr;\n    patch->patch_value = hook_addr;\n\n    opal_mutex_lock (&mca_patcher_overwrite_module.patch_list_mutex);\n    do {\n        rc = mca_patcher_overwrite_apply_patch (patch);\n        if (OPAL_SUCCESS != rc) {\n            break;\n        }\n\n        opal_list_append (&mca_patcher_overwrite_module.patch_list, &patch->super);\n    } while (0);\n\n    opal_mutex_unlock (&mca_patcher_overwrite_module.patch_list_mutex);\n\n    return OPAL_SUCCESS;\n}\n\nstatic int mca_patcher_overwrite_patch_symbol (const char *func_symbol_name, uintptr_t func_new_addr,\n                                               uintptr_t *func_old_addr)\n{\n    void *sym_addr;\n    char *error;\n    uintptr_t old_addr;\n\n    /* NTH: might want to update opal/mca/dl to handle lookups in the default\n     * handle. */\n    sym_addr = dlsym (RTLD_NEXT, func_symbol_name);\n    if (NULL == sym_addr) {\n        sym_addr = dlsym(RTLD_DEFAULT, func_symbol_name);\n        if ( (sym_addr == NULL) && ((error = dlerror()) != NULL) )  {\n            opal_output(0, \"error locating symbol %s to patch. %s\", func_symbol_name,\n                        error);\n            return OPAL_ERR_NOT_FOUND;\n        }\n    }\n\n    old_addr = (unsigned long)sym_addr;\n\n    if (func_old_addr) {\n        /* we will be overwritting part of the original function. do not return\n         * its address */\n        *func_old_addr = 0;\n    }\n\n    return mca_patcher_overwrite_patch_address (old_addr, func_new_addr);\n}\n\nmca_patcher_base_module_t mca_patcher_overwrite_module = {\n    .patch_symbol = mca_patcher_overwrite_patch_symbol,\n    .patch_address = mca_patcher_overwrite_patch_address,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/dl/dl.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * @file\n *\n * Dynamic library framework\n *\n * General Description:\n *\n * This framework provides portable access to dlopen- and dlsym-like\n * functionality, very similar to Libtool's libltdl.  Indeed, one of\n * the components in this framework will use libltdl, if it is\n * present/available.  However, on some common types systems where\n * libltdl headers and libraries are *not* available, we can support\n * plugins via this simple framework.\n *\n * This is a compile-time framework: a single component will be\n * selected by the priority that its configure.m4 provides.  All other\n * components will be ignored (i.e., not built/not part of the\n * installation).  Meaning: the static_components of the dl framework\n * will always contain 0 or 1 components.\n *\n * SIDENOTE: Open MPI used to embed libltdl.  However, as of early\n * 2015, this became problematic, for a variety of complex and\n * uninteresting reasons (see the following if you care about the\n * details: https://github.com/open-mpi/ompi/issues/311,\n * http://debbugs.gnu.org/cgi/bugreport.cgi?bug=19370,\n * https://github.com/open-mpi/ompi/pull/366,\n * https://github.com/open-mpi/ompi/pull/390).  That being said, we,\n * as a developer community, still wanted to be able to natively use\n * DSOs by default.  A small/simple framework for DL functionality,\n * along with a simple component that supports dlopen/dlsym on POSIX\n * platforms and another component that natively uses libltdl seemed\n * like a good solution.\n */\n\n#ifndef OPAL_MCA_DL_DL_H\n#define OPAL_MCA_DL_DL_H\n\n#include \"opal_config.h\"\n\n#include \"opal/mca/mca.h\"\n#include \"opal/mca/base/base.h\"\n\nBEGIN_C_DECLS\n\n/**\n * Handle for an opened file\n */\nstruct opal_dl_handle_t;\ntypedef struct opal_dl_handle_t opal_dl_handle_t;\n\n/**\n * Dynamically open the file specified.\n *\n * Arguments:\n *   fname   = Base filename to open.  If NULL, open this process.\n *   use_ext = If true, try various filename suffixes that are\n *       relevant on this platform (e.g., .so, .dll, .dylib).  If\n *       false, just use exactly whatever was passed as fname.\n *   private = If true, open the file in a private namespace.\n *       Otherwise, open the file in a global namespace.\n *   handle = Upon successful open, a handle to the opened file will\n *       be returned.\n *   err_msg= if non-NULL and !=OPAL_SUCCESS is returned, will point to a\n *       string error message\n *\n * Returns:\n *   OPAL_SUCCESS on success, or OPAL_ERROR\n *\n * Space for the handle must be allocated by the module (it can be\n * freed during the call to opal_dl_base_module_dlclose_fn_t).\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to opal_dl API calls.\n */\ntypedef int (*opal_dl_base_module_open_fn_t)\n    (const char *fname, bool use_ext, bool private_namespace,\n     opal_dl_handle_t **handle, char **err_msg);\n\n/**\n * Lookup a symbol in an opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file\n *   symbol = name of the symbol to lookup\n *   ptr    = if found, a pointer to the symbol.  Otherwise, NULL.\n *   err_msg= if non-NULL and !=OPAL_SUCCESS is returned, will point to a\n *            string error message\n * Returns:\n *   OPAL_SUCCESS on success, or OPAL_ERROR\n *\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to opal_dl API calls.\n */\ntypedef int (*opal_dl_base_module_lookup_fn_t)\n    (opal_dl_handle_t *handle, const char *symbol, void **ptr, char **err_msg);\n\n/**\n * Dynamically close a previously dynamically-opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file.\n * Returns:\n *   OPAL_SUCCESS on success, or OPAL_ERROR\n *\n * This function should close the file and free and resources\n * associated with it (e.g., whatever is cached on the handle).\n */\ntypedef int (*opal_dl_base_module_close_fn_t)\n    (opal_dl_handle_t *handle);\n\n/**\n * Search through a path of directories, invoking a callback on each\n * unique regular (non-Libtool) file basename found (e.g., will only\n * be invoked once for the files \"foo.la\" and \"foo.so\", with the\n * parameter \"foo\").\n *\n * Arguments:\n *   path   = OPAL_ENV_SEP-delimited list of directories\n *   cb_func= function to invoke on each filename found\n *   data   = context for callback function\n * Returns:\n *   OPAL_SUCESS on success, OPAL_ERR* otherwise\n */\ntypedef int (*opal_dl_base_module_foreachfile_fn_t)\n    (const char *search_path,\n     int (*cb_func)(const char *filename, void *context),\n     void *context);\n\n/**\n * Structure for DL components.\n */\nstruct opal_dl_base_component_1_0_0_t {\n    /** MCA base component */\n    mca_base_component_t base_version;\n    /** MCA base data */\n    mca_base_component_data_t base_data;\n\n    /** Default priority */\n    int priority;\n};\ntypedef struct opal_dl_base_component_1_0_0_t opal_dl_base_component_1_0_0_t;\ntypedef struct opal_dl_base_component_1_0_0_t opal_dl_base_component_t;\n\n/**\n * Structure for DL modules\n */\nstruct opal_dl_base_module_1_0_0_t {\n    mca_base_module_2_0_0_t                 super;\n\n    /** Open / close */\n    opal_dl_base_module_open_fn_t           open;\n    opal_dl_base_module_close_fn_t          close;\n\n    /** Lookup a symbol */\n    opal_dl_base_module_lookup_fn_t         lookup;\n\n    /** Iterate looking for files */\n    opal_dl_base_module_foreachfile_fn_t    foreachfile;\n};\ntypedef struct opal_dl_base_module_1_0_0_t opal_dl_base_module_1_0_0_t;\ntypedef struct opal_dl_base_module_1_0_0_t opal_dl_base_module_t;\n\n/**\n * Macro for use in components that are of type DL\n */\n#define OPAL_DL_BASE_VERSION_1_0_0              \\\n    OPAL_MCA_BASE_VERSION_2_1_0(\"dl\", 1, 0, 0)\n\nEND_C_DECLS\n\n#endif /* OPAL_MCA_DL_DL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/dl/dlopen/dl_dlopen_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"opal_config.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"opal/constants.h\"\n#include \"opal/mca/dl/dl.h\"\n#include \"opal/util/argv.h\"\n#include \"opal/util/printf.h\"\n\n#include \"dl_dlopen.h\"\n\n\n/*\n * Trivial helper function to avoid replicating code\n */\nstatic void do_dlopen(const char *fname, int flags,\n                      void **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = dlopen(fname, flags);\n\n    if (NULL != err_msg) {\n        if (NULL != *handle) {\n            *err_msg = NULL;\n        } else {\n            *err_msg = dlerror();\n        }\n    }\n}\n\n\nstatic int dlopen_open(const char *fname, bool use_ext, bool private_namespace,\n                       opal_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n\n    /* Setup the dlopen flags */\n    int flags = RTLD_LAZY;\n    if (private_namespace) {\n        flags |= RTLD_LOCAL;\n    } else {\n        flags |= RTLD_GLOBAL;\n    }\n\n    /* If the caller wants to use filename extensions, loop through\n       them */\n    void *local_handle = NULL;\n    if (use_ext && NULL != fname) {\n        int i;\n        char *ext;\n\n        for (i = 0, ext = mca_dl_dlopen_component.filename_suffixes[i];\n             NULL != ext;\n             ext = mca_dl_dlopen_component.filename_suffixes[++i]) {\n            char *name;\n\n            opal_asprintf(&name, \"%s%s\", fname, ext);\n            if (NULL == name) {\n                return OPAL_ERR_IN_ERRNO;\n            }\n\n            /* Does the file exist? */\n            struct stat buf;\n            if (stat(name, &buf) < 0) {\n                free(name);\n                if (NULL != err_msg) {\n                    *err_msg = \"File not found\";\n                }\n                continue;\n            }\n\n            /* Yes, the file exists -- try to dlopen it.  If we can't\n               dlopen it, bail. */\n            do_dlopen(name, flags, &local_handle, err_msg);\n            free(name);\n            break;\n        }\n    }\n\n    /* Otherwise, the caller does not want to use filename extensions,\n       so just use the single filename that the caller provided */\n    else {\n        do_dlopen(fname, flags, &local_handle, err_msg);\n    }\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(opal_dl_handle_t));\n        (*handle)->dlopen_handle = local_handle;\n\n#if OPAL_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n    }\n    return (NULL != local_handle) ? OPAL_SUCCESS : OPAL_ERROR;\n}\n\n\nstatic int dlopen_lookup(opal_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->dlopen_handle);\n    assert(symbol);\n    assert(ptr);\n\n    *ptr = dlsym(handle->dlopen_handle, symbol);\n    if (NULL != *ptr) {\n        return OPAL_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = dlerror();\n    }\n    return OPAL_ERROR;\n}\n\n\nstatic int dlopen_close(opal_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = dlclose(handle->dlopen_handle);\n\n#if OPAL_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\n/*\n * Scan all the files in a directory (or path) and invoke a callback\n * on each one.\n */\nstatic int dlopen_foreachfile(const char *search_path,\n                              int (*func)(const char *filename, void *data),\n                              void *data)\n{\n    int ret;\n    DIR *dp = NULL;\n    char **dirs = NULL;\n    char **good_files = NULL;\n\n    dirs = opal_argv_split(search_path, OPAL_ENV_SEP);\n    for (int i = 0; NULL != dirs && NULL != dirs[i]; ++i) {\n\n        dp = opendir(dirs[i]);\n        if (NULL == dp) {\n            ret = OPAL_ERR_IN_ERRNO;\n            goto error;\n        }\n\n        struct dirent *de;\n        while (NULL != (de = readdir(dp))) {\n\n            /* Make the absolute path name */\n            char *abs_name = NULL;\n            opal_asprintf(&abs_name, \"%s/%s\", dirs[i], de->d_name);\n            if (NULL == abs_name) {\n                ret = OPAL_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Stat the file */\n            struct stat buf;\n            if (stat(abs_name, &buf) < 0) {\n                free(abs_name);\n                ret = OPAL_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Skip if not a file */\n            if (!S_ISREG(buf.st_mode)) {\n                free(abs_name);\n                continue;\n            }\n\n            /* Find the suffix */\n            char *ptr = strrchr(abs_name, '.');\n            if (NULL != ptr) {\n\n                /* Skip libtool files */\n                if (strcmp(ptr, \".la\") == 0 ||\n                    strcmp(ptr, \".lo\") == 0) {\n                    free (abs_name);\n                    continue;\n                }\n\n                *ptr = '\\0';\n            }\n\n            /* Have we already found this file?  Or already found a\n               file with the same basename (but different suffix)? */\n            bool found = false;\n            for (int j = 0; NULL != good_files &&\n                     NULL != good_files[j]; ++j) {\n                if (strcmp(good_files[j], abs_name) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                opal_argv_append_nosize(&good_files, abs_name);\n            }\n            free(abs_name);\n        }\n        closedir(dp);\n    }\n    dp = NULL;\n\n    /* Invoke the callback on all the found files */\n    if (NULL != good_files) {\n        for (int i = 0; NULL != good_files[i]; ++i) {\n            ret = func(good_files[i], data);\n            if (OPAL_SUCCESS != ret) {\n                goto error;\n            }\n        }\n    }\n\n    ret = OPAL_SUCCESS;\n\n error:\n    if (NULL != dp) {\n        closedir(dp);\n    }\n    if (NULL != dirs) {\n        opal_argv_free(dirs);\n    }\n    if (NULL != good_files) {\n        opal_argv_free(good_files);\n    }\n\n    return ret;\n}\n\n\n/*\n * Module definition\n */\nopal_dl_base_module_t opal_dl_dlopen_module = {\n    .open = dlopen_open,\n    .lookup = dlopen_lookup,\n    .close = dlopen_close,\n    .foreachfile = dlopen_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/dl/libltdl/dl_libltdl_module.c": "/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"opal_config.h\"\n\n#include \"opal/constants.h\"\n#include \"opal/mca/dl/dl.h\"\n\n#include \"dl_libltdl.h\"\n\n\nstatic int libltdl_open(const char *fname, bool use_ext, bool private_namespace,\n                       opal_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    lt_dlhandle local_handle;\n\n#if OPAL_DL_LIBLTDL_HAVE_LT_DLADVISE\n    opal_dl_libltdl_component_t *c = &mca_dl_libltdl_component;\n\n    if (use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_ext);\n    } else if (use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_ext);\n    } else if (!use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_noext);\n    } else if (!use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_noext);\n    }\n#else\n    if (use_ext) {\n        local_handle = lt_dlopenext(fname);\n    } else {\n        local_handle = lt_dlopen(fname);\n    }\n#endif\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(opal_dl_handle_t));\n        (*handle)->ltdl_handle = local_handle;\n\n#if OPAL_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n\n        return OPAL_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = (char*) lt_dlerror();\n    }\n    return OPAL_ERROR;\n}\n\n\nstatic int libltdl_lookup(opal_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->ltdl_handle);\n    assert(symbol);\n    assert(ptr);\n\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    *ptr = lt_dlsym(handle->ltdl_handle, symbol);\n    if (NULL != *ptr) {\n        return OPAL_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = (char*) lt_dlerror();\n    }\n    return OPAL_ERROR;\n}\n\n\nstatic int libltdl_close(opal_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = lt_dlclose(handle->ltdl_handle);\n\n#if OPAL_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\nstatic int libltdl_foreachfile(const char *search_path,\n                               int (*func)(const char *filename, void *data),\n                               void *data)\n{\n    assert(search_path);\n    assert(func);\n\n    int ret = lt_dlforeachfile(search_path, func, data);\n    return (0 == ret) ? OPAL_SUCCESS : OPAL_ERROR;\n}\n\n\n/*\n * Module definition\n */\nopal_dl_base_module_t opal_dl_libltdl_module = {\n    .open = libltdl_open,\n    .lookup = libltdl_lookup,\n    .close = libltdl_close,\n    .foreachfile = libltdl_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/memory/malloc_solaris/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n#                         University Research and Technology\n#                         Corporation.  All rights reserved.\n# Copyright (c) 2004-2005 The University of Tennessee and The University\n#                         of Tennessee Research Foundation.  All rights\n#                         reserved.\n# Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n#                         University of Stuttgart.  All rights reserved.\n# Copyright (c) 2004-2005 The Regents of the University of California.\n#                         All rights reserved.\n# Copyright (c) 2007-2011 Oracle and/or its affiliates.  All rights reserved.\n# Copyright (c) 2010-2011 Cisco Systems, Inc.  All rights reserved.\n# Copyright (c) 2015      Research Organization for Information Science\n#                         and Technology (RIST). All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\nAC_DEFUN([MCA_opal_memory_malloc_solaris_PRIORITY], [0])\n\nAC_DEFUN([MCA_opal_memory_malloc_solaris_COMPILE_MODE], [\n    AC_MSG_CHECKING([for MCA component $2:$3 compile mode])\n    $4=\"static\"\n    AC_MSG_RESULT([$$4])\n])\n\n# MCA_memory_malloc_solaris_CONFIG(action-if-can-compile,\n#                        [action-if-cant-compile])\n# ------------------------------------------------\nAC_DEFUN([MCA_opal_memory_malloc_solaris_CONFIG],[\n    AC_CONFIG_FILES([opal/mca/memory/malloc_solaris/Makefile])\n\n    OPAL_VAR_SCOPE_PUSH([memory_malloc_solaris_happy memory_malloc_solaris_should_use memory_malloc_solaris_munmap memory_alloc_solaris_legacy])\n\n    AC_MSG_CHECKING([for Solaris])\n\n    case \"$host\" in\n    *solaris*)\n\n        AC_MSG_RESULT([yes])\n\n        AS_IF([test \"$with_memory_manager\" = \"malloc_solaris\"],\n              [memory_malloc_solaris_happy=\"yes\"\n                memory_malloc_solaris_should_use=1],\n              [memory_malloc_solaris_should_use=0\n                AS_IF([test \"$with_memory_manager\" = \"\"],\n                      [memory_malloc_solaris_happy=\"yes\"],\n                      [memory_malloc_solaris_happy=\"no\"])])\n\n        AS_IF([test \"$memory_malloc_solaris_happy\" = \"yes\"],\n              [AC_CHECK_HEADER([malloc.h], [],\n              [memory_malloc_solaris_happy=\"no\"])])\n\n        AS_IF([test \"$memory_malloc_solaris_happy\" = \"yes\"],\n              [memory_malloc_solaris_munmap=0\n\n              AC_CHECK_HEADER([sys/syscall.h],\n                              [AC_CHECK_FUNCS([syscall],\n                                              [memory_malloc_solaris_munmap=1])])\n\n              AC_CHECK_FUNCS([__munmap], [memory_malloc_solaris_munmap=1])\n\n              # only allow dlsym (and therefore add -ldl) if we\n              # really need to\n              AS_IF([test \"$memory_malloc_solaris_munmap\" = \"0\"],\n                    [memory_malloc_solaris_LIBS_SAVE=\"$LIBS\"\n                      AC_CHECK_LIB([dl],\n                                   [dlsym],\n                                   [memory_malloc_solaris_LIBS=\"-ldl\"\n                                     memory_malloc_solaris_munmap=1])\n                      AC_CHECK_FUNCS([dlsym])\n                      LIBS=\"$memory_malloc_solaris_LIBS_SAVE\"])\n\n              AS_IF([test \"$memory_malloc_solaris_munmap\" = \"0\"],\n                    [memory_malloc_solaris_happy=\"no\"])])\n\n        # There is a difference in the munmap prototypes for different\n        # Solaris versions.  So determine whether we are to use Legacy\n        # S10 or later prototypes.\n        memory_alloc_solaris_legacy=0\n        AS_IF([test \"$memory_malloc_solaris_happy\" = \"yes\"],\n              [AC_MSG_CHECKING([for Solaris Legacy MUNMAP])\n               AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/mman.h>]],\n                                                  [[char *addr;\n                                                    extern int munmap(caddr_t addr, size_t len);]])],\n                                 [memory_alloc_solaris_legacy=1\n                                  AC_MSG_RESULT([yes])],\n                                 [AC_MSG_RESULT([no])])\n               AC_DEFINE_UNQUOTED([USE_SOLARIS_LEGACY_MUNMAP_PROTOTYPE],\n                                  [$memory_alloc_solaris_legacy],\n                                  [Whether to use the legacy Solaris munmap prototype or not])\n               ])\n\n        AS_IF([test \"$memory_malloc_solaris_happy\" = \"no\" && \\\n               test \"$memory_malloc_solaris_should_use\" = \"1\"],\n              [AC_MSG_ERROR([malloc_solaris memory management requested but not available.  Aborting.])])\n\n        AC_SUBST(memory_malloc_solaris_LIBS)\n\n    ;;\n    *)\n        AC_MSG_RESULT([no])\n        AS_IF([test \"$with_memory_manager\" = \"malloc_solaris\"],\n              [memory_malloc_solaris_happy=\"no\"\n                memory_malloc_solaris_should_use=0])\n    ;;\n    esac\n\n    AS_IF([test \"$memory_malloc_solaris_happy\" = \"yes\"],\n          [memory_base_found=1\n           $1], [$2])\n\n    OPAL_VAR_SCOPE_POP\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/opal/mca/memory/malloc_solaris/memory_malloc_solaris_component.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2005 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2007-2011 Oracle and/or its affiliates.  All rights reserved.\n * Copyright (c) 2009-2011 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015-2016 Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * Copyright (c) 2016      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"opal_config.h\"\n#include \"opal/mca/memory/memory.h\"\n#include \"opal/mca/memory/base/empty.h\"\n#include \"opal/memoryhooks/memory_internal.h\"\n#include \"opal/constants.h\"\n\n#include <sys/types.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#if defined(HAVE___MUNMAP)\n/* here so we only include others if we absolutely have to */\n#elif defined(HAVE_SYSCALL)\n#include <sys/syscall.h>\n#include <unistd.h>\n#endif\n\n\n#if defined(HAVE___MUNMAP)\nint  __munmap(caddr_t addr, size_t len);\n#endif\n\nstatic int opal_memory_malloc_open(void);\nstatic int opal_memory_malloc_query(int *);\n\nconst opal_memory_base_component_2_0_0_t mca_memory_malloc_solaris_component = {\n    /* First, the mca_component_t struct containing meta information\n       about the component itself */\n    .memoryc_version = {\n        OPAL_MEMORY_BASE_VERSION_2_0_0,\n\n        /* Component name and version */\n        .mca_component_name = \"malloc_solaris\",\n        MCA_BASE_MAKE_VERSION(component, OPAL_MAJOR_VERSION, OPAL_MINOR_VERSION,\n                              OPAL_RELEASE_VERSION),\n\n        /* Component open and close functions */\n        .mca_open_component = opal_memory_malloc_open,\n    },\n    .memoryc_data = {\n        /* The component is checkpoint ready */\n        MCA_BASE_METADATA_PARAM_CHECKPOINT\n    },\n\n    /* This component doesn't need these functions, but need to\n       provide safe/empty register/deregister functions to call */\n    .memoryc_query = opal_memory_malloc_query,\n    .memoryc_register = opal_memory_base_component_register_empty,\n    .memoryc_deregister = opal_memory_base_component_deregister_empty,\n    .memoryc_set_alignment = opal_memory_base_component_set_alignment_empty,\n};\n\n/*\n * This component exists to establish the memory hook support\n * level available on Solaris. By default Solaris does not\n * return memory to the system, i.e. does not unmap memory\n * from the process space, when a user calls free(). This allows\n * us to declare OPAL_MEMORY_FREE_SUPPORT. Additionally, by\n * intercepting munmap we can declare OPAL_MEMORY_MUNMAP_SUPPORT.\n *\n * NOTE: Not releasing memory back to the system when calling\n * free() may be unique to Solaris which is why this component\n * was created.\n */\nstatic int\nopal_memory_malloc_open(void)\n{\n    opal_mem_hooks_set_support(\n        (OPAL_MEMORY_FREE_SUPPORT | OPAL_MEMORY_MUNMAP_SUPPORT));\n    return OPAL_SUCCESS;\n}\n\nstatic int opal_memory_malloc_query (int *priority)\n{\n    *priority = 79;\n    return OPAL_SUCCESS;\n}\n\n/*\n * Three ways to call munmap.  Prefered is to call __munmap, which\n * will exist if munmap is a weak symbol.  If not available next try\n * the syscall, and if that doesn't work, try looking in the dynamic\n * libc.\n */\n#if USE_SOLARIS_LEGACY_MUNMAP_PROTOTYPE\n/* We are compiling using S10 so use its munmap prototype */\nint\nmunmap(caddr_t addr, size_t len)\n#else\n/* From S11 on forward munmap's addr is void * */\nint\nmunmap(void *addr, size_t len)\n#endif\n{\n#if !defined(HAVE___MUNMAP) && \\\n    !defined(HAVE_SYSCALL) && defined(HAVE_DLSYM)\n    static int (*realmunmap)(void*, size_t);\n#endif\n\n    opal_mem_hooks_release_hook(addr, len, 0);\n\n#if defined(HAVE___MUNMAP)\n    return __munmap(addr, len);\n#elif defined(HAVE_SYSCALL)\n    return syscall(SYS_munmap, addr, len);\n#elif defined(HAVE_DLSYM)\n    if (NULL == realmunmap) {\n        union {\n            int (*munmap_fp)(void*, size_t);\n            void *munmap_p;\n        } tmp;\n\n        tmp.munmap_p = dlsym(RTLD_NEXT, \"munmap\");\n        realmunmap = tmp.munmap_fp;\n    }\n    return realmunmap(addr, len);\n#else\n    #error \"Can not determine how to call munmap\"\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/contrib/ompi-time.sh": "#!/bin/sh\n#\n# Copyright (c) 2015      Mellanox Technologies, Inc.\n#                         All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n# This script is used to measure PMIx performance.\n#\n# --exec: scenario to run as sync or \"test1 test2\"\n# --mpidir: path to mpi installation (/usr default)\n# --parse: path to collected results\n# HOWTO:\n# 1 .Set test matrix using variables $node_list, ppn_list, test_list\n# 2. Allocate nodes:\n#   $salloc --nodelist=node[1-4]\n#   or\n#   $salloc -N4\n# 3. Launch script:\n#   $./opmi-time.sh --exec=\"test1 test2\" --mpidir=<open>\n#   $./opmi-time.sh --mpidir=<open>\n#\n# Output location is test name folder\n# Output file formats\n# ()_base.log\n# timestamp (usec)      hostnode label\n# 1441715028369350\tmir14    start\n# 1441715030540656\tmir14    end\n#\n# ()_out.log\n# timestamp (usec)      rank    node\n# 1441715030460727\t0\tmir9\n# 1441715030460628\t1\tmir10\n#\n# ()_result.log\n# time  rank    node\n# 2.089\t3\tmir12\n# 2.093\t2\tmir11\n#\n# report.log\n# nodes ppn     mintime maxtime\n# 4\t1\t2.089\t2.093\n\n\n# Settings\n###############################################################################\n\nnode_list=(2 4)\nppn_list=(1 2)\ntest_list=\"test1 test2 test3 test4 test5 test6 test7 test8 test9 test10 test11 test12 test13\"\n\n# Declarations\n###############################################################################\n\nprefix=pmix\nmodule=${BASH_SOURCE[0]}\n\n# Command line parsing\n###############################################################################\n\nopt=\"\"\nwhile [ \"$#\" -gt 0 ]; do\n  case \"$1\" in\n\n    --parse=*) parse=\"${1#*=}\"; shift 1;;\n    --exec=*) exec=\"${1#*=}\"; shift 1;;\n    --mpidir=*) mpidir=\"${1#*=}\"; shift 1;;\n    --parse|--exec|--mpidir) echo \"$1 requires an argument\" >&2; exit 1;;\n\n    -*) echo \"unknown option: $1\" >&2; exit 1;;\n    *) shift 1;;\n  esac\ndone\n\n# The scenario of measurement\nif [ -n \"$exec\" ]; then\n  test_list=\"$exec\"\nfi\n\n# The mpi path\nmpidir=${mpidir:=/usr}\n\n# Functions\n###############################################################################\n\n# format text\nfunction do_format() {\n  local is_format=true\n  if [[ $is_format == true ]] ; then\n    res=\"\"\n    for ((i=2; i<=$#; i++)) ; do\n      case \"${!i}\" in\n        \"bold\" ) res=\"$res\\e[1m\" ;;\n        \"underline\" ) res=\"$res\\e[4m\" ;;\n        \"reverse\" ) res=\"$res\\e[7m\" ;;\n        \"red\" ) res=\"$res\\e[91m\" ;;\n        \"green\" ) res=\"$res\\e[92m\" ;;\n        \"yellow\" ) res=\"$res\\e[93m\" ;;\n      esac\n    done\n    echo -e \"$res$1\\e[0m\"\n  else\n    echo \"$1\"\n  fi\n}\n\n# print message\nfunction do_msg() {\n  echo -e \"$*\" 2>&1 | tee -a $logfile\n}\n\n# print error message and exit script\nfunction do_err() {\n  echo -e $(do_format \"$module failed. aborting. $*\" \"red\" \"bold\") 2>&1 | tee -a $logfile\n  exit 1\n}\n\n# print the seconds and current microseconds.\nfunction do_timestamp() {\n  do_msg \"$(($(date +%s%N)/1000))\\t$(hostname -s)\" \"$1\"\n}\n\n# swap two files\nfunction do_fswap() {\n  if (( $# == 2 )); then\n    mv \"$1\" /tmp/\n    mv \"$2\" \"`dirname $1`\"\n    mv \"/tmp/`basename $1`\" \"`dirname $2`\"\n  else\n    echo \"Usage: swap <file1> <file2>\"\n    return 1\n  fi\n}\n\nfunction do_cmd() {\n  cmd=\"$*\"\n  do_msg \"Doing:\"\n  do_msg \"==================================================\"\n  do_msg \"$*\"\n  eval $cmd >> $logfile 2>&1\n  local status=$?\n  if test \"$status\" != \"0\"; then\n    echo \"$module failed.  Log:\"\n\ttail -20 $logfile\n    cat $logfile\n    exit $status\n  fi\n  do_msg \"DONE\"\n  do_msg \"\"\n}\n\nfunction do_export() {\n  do_msg \"Exporting PATHs:\"\n  do_msg \"==================================================\"\n  do_msg \"$1\"\n  export PATH=\"$1/bin:${PATH}\"\n  export LD_LIBRARY_PATH=\"$1/lib:${LD_LIBRARY_PATH}\"\n  export MANPATH=\"$1/share/man:${MANPATH}\"\n  do_msg \"DONE\"\n  do_msg \"\"\n}\n\nfunction do_nodeinfo() {\n  do_msg \"Node information:\"\n  do_msg \"==================================================\"\n  do_msg $(hostname)\n  do_msg $(cat /etc/issue | grep We)\n  do_msg $(cat /proc/cpuinfo | grep 'model name' | sort -u | awk '{print $4, $5, $6, $7, $9}')\n  do_msg $(cat /proc/cpuinfo | grep proce | wc | awk '{print $1}')\n  do_msg $(uname -a | awk '{print $12}')\n  do_msg $(cat /proc/meminfo | grep [M,m]em)\n  do_msg $(uname -a | awk '{print $3}')\n  do_msg $(ibstat | grep -e \"CA type\" -e \"Firmware version\")\n  do_msg $(ibstatus | grep -e rate -e state | grep -v 'phys state')\n  do_msg $(ofed_info | head -6 | grep OFED)\n  do_msg \"DONE\"\n  do_msg \"\"\n}\n\nfunction do_validate() {\n  command -v mpiexec >/dev/null 2>&1 || { do_err \"mpiexec is not found.\"; }\n  command -v srun >/dev/null 2>&1 || { do_err \"srun is not found.\"; }\n  command -v salloc >/dev/null 2>&1 || { do_err \"salloc is not found.\"; }\n}\n\nfunction do_check_pmix() {\n  eval \"srun --mpi=list 2>&1 | grep pmix\"\n}\n\nfunction do_checksync_mpisync() {\n  local status\n  local tooldir=${tempdir}/mpisync\n  local verbose=$1\n  local option=$*\n\n  do_msg \"Checking synchronization using mpisync:\"\n\n  if [ ! -e ${tooldir} ]; then\n    mkdir -p ${tooldir}\n    cd ${tooldir}\n    wget --no-check-certificate https://github.com/open-mpi/ompi/raw/master/ompi/tools/mpisync/mpigclock.c >> $logfile 2>&1\n    wget --no-check-certificate https://github.com/open-mpi/ompi/raw/master/ompi/tools/mpisync/mpigclock.h >> $logfile 2>&1\n    wget --no-check-certificate https://github.com/open-mpi/ompi/raw/master/ompi/tools/mpisync/hpctimer.c >> $logfile 2>&1\n    wget --no-check-certificate https://github.com/open-mpi/ompi/raw/master/ompi/tools/mpisync/hpctimer.h >> $logfile 2>&1\n    wget --no-check-certificate https://github.com/open-mpi/ompi/raw/master/ompi/tools/mpisync/sync.c >> $logfile 2>&1\n    mpicc hpctimer.c mpigclock.c sync.c -o mpisync >> $logfile 2>&1\n  fi\n  if [ ! -e \"$tooldir\" ] || [ ! -f \"$tooldir/mpisync\" ]; then\n    do_err \"can not find $tooldir/mpisync\"\n  fi\n  mpiexec -n $(($nodes)) -npernode 1 $mpioptions $tooldir/mpisync -o ${syncfile} ${option} 2>&1\n  do_msg \"Analysing ${syncfile}\"\n  cat ${syncfile} >> $logfile 2>&1\n  diff=$(grep -v '^#' ${syncfile} | cut -f3 -d' ' | sort -n | awk 'BEGIN {min=1000000; max=0;}; { if($1<min && $1 != \"\") min = $1; if($1>max && $1 != \"\") max = $1; } END { printf(\"%0.06f %0.06f %0.06f\", min, max, max-min) }') >> $logfile 2>&1\n  do_msg \"sync drift is equal: $diff\"\n  diff=`echo $diff | cut -f3 -d' '`\n  status=$(if (( `bc <<< \"$diff >= 0.001\"` == 1 )); then echo \"value $diff >= 0.001\"; fi)\n  if [ -n \"$status\" ] && [ -n $verbose -a \"$verbose\" == \"on\" ]; then\n    do_err \"mpisync reports issue with synchronization as $status\"\n  else\n    do_msg \"Warning: mpiperf reports issue with synchronization as $status\"\n  fi\n\n  do_msg \"DONE\"\n  do_msg \"\"\n}\n\nfunction do_checksync_mpiperf() {\n  local status\n  local tooldir=${tempdir}/mpiperf-0.0.3\n  local verbose=$1\n\n  do_msg \"Checking synchronization using mpiperf:\"\n\n  if [ ! -f ${tempdir}/mpiperf-0.0.3.tar.gz ]; then\n    wget http://mpiperf.cpct.sibsutis.ru/uploads/Main/mpiperf-0.0.3.tar.gz >> $logfile 2>&1\n    tar zxvf mpiperf-0.0.3.tar.gz >> $logfile 2>&1\n    cd $tooldir\n    make >> $logfile 2>&1\n  fi\n  if [ ! -e \"$tooldir\" ] || [ ! -f \"$tooldir/src/mpiperf\" ]; then\n    do_err \"can not find $tooldir/src/mpiperf\"\n  fi\n  mpiexec -n 1 $mpioptions $tooldir/src/mpiperf -T >> $logfile 2>&1\n  if [ -z \"$(mpiexec -n 1 $mpioptions $tooldir/src/mpiperf -j -t gettimeofday 2>&1 | tee -a $logfile | sed -n '/PASSED/p')\" ]; then\n    do_err \"mpiperf does not support gettimeofday\"\n  fi\n  mpiexec -n $(($nodes)) -npernode 1 $mpioptions $tooldir/src/mpiperf -t gettimeofday WaitPatternNull >> ${syncfile} 2>&1\n  do_msg \"Analysing ${syncfile}\"\n  cat ${syncfile} >> $logfile 2>&1\n  status=$(grep -v '^#' ${syncfile} | awk -F ' ' '{ print $6 }' | while read i; do if (( `bc <<< \"$i >= 1\"` == 1 )); then echo \"value $i >= 1.00\"; break; fi; done)\n  if [ -n \"$status\" ] && [ -n $verbose -a \"$verbose\" == \"on\" ]; then\n    do_err \"mpiperf reports issue with synchronization as $status\"\n  else\n    do_msg \"Warning: mpiperf reports issue with synchronization as $status\"\n  fi\n\n  do_msg \"DONE\"\n  do_msg \"\"\n}\n\n# $1 - sync filename\n# $2 - verbose mode: on - exit in case synchronization values exceed a treshold and off - silent mode (default: off)\n# $3+ - application additional options\nfunction do_checksync() {\n  if [ -z \"$1\" ]; then\n    syncfile=${tempdir}/mpisync.log\n  else\n    syncfile=$1\n  fi\n\n  do_checksync_mpisync $2 \"-a 0\"\n#  do_checksync_mpisync $2 \"-a 1\"\n#  do_checksync_mpiperf\n  do_msg \"syncfile: $syncfile\"\n}\n\nfunction do_analysis() {\n  local testdir=$1\n  local basefile=$2\n  local outfile=$3\n  local outfile1=\"${3}.1\"\n  local resultfile=${testdir}/${nodes}x${ppn}_result.log\n\n  if [ ! -e $tesdir ]; then\n    do_err \"can not find testdir: $testdir\"\n  fi\n  if [ -z $basefile -o ! -f $basefile ]; then\n    do_err \"can not find basefile: $basefile\"\n  fi\n  if [ -z $outfile -o ! -f $outfile ]; then\n    do_err \"can not find outfile: $outfile\"\n  fi\n  if [ \"$(cat $outfile | wc -l)\" != \"$(($nodes * $ppn))\" ]; then\n    do_msg \"Warning: number of lines in $outfile ($(cat $outfile | wc -l)) is not equal ($nodes * $ppn).\"\n  fi\n  start_t=`awk -F $'\\t' '{ if (NR == 1) print $1 }' $basefile`\n\n  # Add sync value in output file\n  while read line; do\n    if [[ ! $line =~ ^[0-9] ]]; then\n      do_msg \"Warning: ignoring line: $line.\"\n      continue\n    fi\n    local n=$(echo $line | cut -f3 -d' ')\n    local v1=$(echo $line | cut -f1 -d' ')\n    local v2=0\n\n    if [ ! -z $syncfile -o -f $syncfile ]; then\n      v2=$(echo \"scale=2; ($(grep $n $syncfile | cut -f3 -d' ') * 1000000)\" | bc -l)\n      # Round float value to int\n      v2=$(echo ${v2%%.*})\n      v2=${v2:=0}\n    fi\n    echo -e \"$(($v1 + $v2))\\t${v2}\\t${line}\" >> $outfile1\n  done < $outfile\n\n  # Find maximum and minimum lines\n  min_line=`sort -n $outfile1 | head -n1`\n  max_line=`sort -n $outfile1 | tail -n1`\n  if [ -z \"$min_line\" -o -z \"$max_line\" ]; then\n    do_err \"can not find max/min lines in : $outfile1\"\n  fi\n  min_t=$( echo \"$min_line\" | cut -f1 -d$'\\t')\n  max_t=$( echo \"$max_line\" | cut -f1 -d$'\\t')\n  echo -e \"`bc -l <<< \"scale=3; (($min_t - $start_t) / 1000000)\"`\\t`echo \"$min_line\" | cut -f4 -d$'\\t'`\\t`echo \"$min_line\" | cut -f5 -d$'\\t'`\" >> $resultfile 2>&1\n  echo -e \"`bc -l <<< \"scale=3; (($max_t - $start_t) / 1000000)\"`\\t`echo \"$max_line\" | cut -f4 -d$'\\t'`\\t`echo \"$max_line\" | cut -f5 -d$'\\t'`\" >> $resultfile 2>&1\n\n  echo -e \"\\n# Used synchronization file: $syncfile\" >> $outfile1\n\n  do_report $testdir $resultfile\n}\n\nfunction do_report() {\n  local testdir=$1\n  local resultfile=$2\n  local reportfile=${testdir}/report.log\n\n  if [ -z $resultfile -o ! -f $resultfile ]; then\n    do_err \"can not find resultfile: $resultfile\"\n  fi\n  min_t=`awk -F $'\\t' '{ if (NR == 1) print $1 }' $resultfile`\n  max_t=`awk -F $'\\t' '{ if (NR == 2) print $1 }' $resultfile`\n  echo -e \"${nodes}\\t${ppn}\\t${min_t}\\t${max_t}\" >> $reportfile 2>&1\n}\n\nfunction do_postresult() {\n  cd $tempdir/..\n  tar -zcvf $PWD/pmix.$$.tar.gz $tempdir > /dev/null 2>&1\n}\n\ninclude_timestamp_func=$(cat <<END_MSG\n#include <dlfcn.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <sys/time.h>\n\nstatic inline void timestamp(FILE *file)\n{\n    struct timeval tv;\n    char name[256];\n    char *host_name = NULL;\n    char *domain = NULL;\n    int procid = -1;\n    char *str = NULL;\n\n    gettimeofday(&tv, NULL);\n\n    if (gethostname(name, sizeof(name)) != 0)\n        strcpy(name, \"localhost\");\n    host_name = strdup(name);\n    domain = strchr(host_name, '.');\n    if (domain)\n        *domain = '\\0';\n\n    str = getenv(\"SLURM_PROCID\");\n    procid = ( str ? strtol(str, NULL, 10) : -1);\n    fprintf(file, \"%lld\\t%d\\t%s\\n\", tv.tv_sec * 1000000LL + tv.tv_usec, procid, host_name);\n    fflush(file);\n}\n\nEND_MSG\n)\n\nfunction do_exec() {\n\n# The number of nodes (see SLURM_NNODES)\nnodes=${SLURM_NNODES}\nnodes=${nodes:=2}\n\n# The number of tasks per node (see SLURM_NTASKS_PER_NODE or SLURM_TASKS_PER_NODE)\nppn=${SLURM_NTASKS_PER_NODE}\nppn=${ppn:=1}\n\nmpioptions=' -novm -mca btl_openib_warn_default_gid_prefix 0 -mca mpi_add_procs_cutoff 100000 '\nslurmoptions=' OMPI_MCA_btl_openib_warn_default_gid_prefix=0 OMPI_MCA_mpi_add_procs_cutoff=100000 '\n\nif [ -z \"$(env | grep SLURM)\" ]; then\n  do_err \"Do not see allocated nodes by SLURM. Probably salloc -N option is not set\"\nfi\n\n#if [ \"${SLURM_NPROCS}\" != \"$(($nodes * $ppn))\" ]; then\n#  do_err \"SLURM_NPROCS=${SLURM_NPROCS} is not equal ($nodes * $ppn). Probably salloc -N option is not set\"\n#fi\n\ndo_msg \"\"\ndo_msg \"Configuration:\"\ndo_msg \"==================================================\"\ndo_msg \"tempdir: $tempdir\"\ndo_msg \"logfile: $logfile\"\ndo_msg \"mpi: $mpidir\"\ndo_msg \"exec: $exec\"\ndo_msg \"nodes: $nodes\"\ndo_msg \"ppn: $ppn\"\ndo_msg \"mpioptions: $mpioptions\"\ndo_msg \"slurmoptions: $slurmoptions\"\ndo_msg \"node list: $node_list\"\ndo_msg \"ppn list: $ppn_list\"\ndo_msg \"test list: $test_list\"\ndo_msg \"\"\n\ndo_export $mpidir\ndo_nodeinfo\ndo_validate\n\nif [ -f \"${tempdir}/mpisync.log\" ]; then\n  syncfile=${tempdir}/mpisync.log\n  do_msg \"found sync data at  ${syncfile}\"\nelif [ -f \"${tempdir}/mpiperf.log\" ]; then\n  syncfile=${tempdir}/mpiperf.log\n  do_msg \"found sync data at  ${syncfile}\"\nelse\n  do_msg \"sync data is not found\"\nfi\n\n# Launch scenario\nnode_list_len=${#node_list[*]}\nppn_list_len=${#ppn_list[*]}\n\nfor ((i=0; $i < $node_list_len; i=$((i=$i+1)))); do\n  for ((j=0; $j < $ppn_list_len; j=$((j=$j+1)))); do\n    for test in $test_list; do\n      nodes=${node_list[$i]}\n      ppn=${ppn_list[$j]}\n      if [ \"$test\" = \"sync\" ]; then\n        do_checksync \"${tempdir}/${nodes}x${ppn}_mpisync00.log\" \"off\"\n      else\n        do_checksync \"${tempdir}/${nodes}x${ppn}_mpisync_before.log\" \"off\"\n        eval \"do_${test}\"\n        do_checksync \"${tempdir}/${nodes}x${ppn}_mpisyn_after.log\" \"off\"\n      fi\n    done\n  done\ndone\n\ndo_postresult\n}\n\n# $1 - result location\nfunction do_parse() {\n  local parsedir=$1\n  local result_list\n  local test_list\n  local parsefile\n\n  for result in `ls -1 $workdir`; do\n    if [ ! -d \"${parsedir}/${result}\" ]; then\n      continue\n    fi\n    for test in `ls -1 \"${parsedir}/${result}\" | grep -v mpisync`; do\n      if [ ! -d \"${parsedir}/${result}/${test}\" ]; then\n        continue\n      fi\n      result_list=\"${result_list} ${result}\"\n      test_list=\"${test_list} ${test}\"\n    done\n  done\n\n  result_list=`echo $result_list | tr \" \" \"\\n\" | sort | uniq | tr \"\\n\" \" \"`\n  test_list=`echo $test_list | tr \" \" \"\\n\" | sort | uniq | tr \"\\n\" \" \"`\n\n  do_msg \"results: $result_list\"\n  do_msg \"tests: $test_list\"\n\n  for test in $test_list; do\n    parsefile=\"${parsedir}/parse_${test}.log\"\n    for result in $result_list; do\n       echo -e \"\\n${result}:\" >> $parsefile 2>&1\n       echo -e \"nodes\\tppn\\tmin\\tmax\" >> $parsefile 2>&1\n       cat \"${parsedir}/${result}/${test}/report.log\" >> $parsefile 2>&1\n    done\n  done\n}\n\n# Pure application srun launch\n#####################################################\nfunction do_test1\n{\n  local status\n  local scenario=test1\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n\nint main()\n{\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  gcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  srun -n$(($nodes * $ppn)) -N$nodes --ntasks-per-node=$ppn ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"srun pure overhead\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# Pure application mpiexec launch\n#####################################################\nfunction do_test2\n{\n  local status\n  local scenario=test2\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n\nint main()\n{\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  gcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  mpiexec -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"mpiexec pure overhead\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# Pure application oshrun launch\n#####################################################\nfunction do_test3\n{\n  local status\n  local scenario=test3\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n\nint main()\n{\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  gcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  oshrun -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"osrun pure overhead\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# MPI_init application srun/pmi2 launch\n#####################################################\nfunction do_test4\n{\n  local status\n  local scenario=test4\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    MPI_Init(&argc, &argv);\n    timestamp(stdout);\n    MPI_Finalize();\n    return 0;\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  env $slurmoptions srun -n$(($nodes * $ppn)) -N$nodes --ntasks-per-node=$ppn --mpi=pmi2 ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"srun --mpi=pmi2:MPI_Init\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# start_pes application srun/pmi2 launch\n#####################################################\nfunction do_test5\n{\n  local status\n  local scenario=test5\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"shmem.h\"\nint main(int argc, char* argv[])\n{\n    start_pes(0);\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  oshcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  env $slurmoptions srun -n$(($nodes * $ppn)) -N$nodes --ntasks-per-node=$ppn --mpi=pmi2 ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"srun --mpi=pmi2:start_pes\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# MPI_Init application mpiexec launch\n#####################################################\nfunction do_test6\n{\n  local status\n  local scenario=test6\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    MPI_Init(&argc, &argv);\n    timestamp(stdout);\n    MPI_Finalize();\n    return 0;\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  mpiexec -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"mpiexec:MPI_Init\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# start_pes application oshrun launch\n#####################################################\nfunction do_test7\n{\n  local status\n  local scenario=test7\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"shmem.h\"\nint main(int argc, char* argv[])\n{\n    start_pes(0);\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  oshcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  oshrun -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"osrun:start_pes\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# pure application mpiexec:orte_daemon\n#####################################################\nfunction do_test8\n{\n  local status\n  local scenario=test8\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    return 0;\n}\nEND_MSG\n\n  cat > lib_$scenario.c <<END_MSG\n#define _GNU_SOURCE\n$include_timestamp_func\n\nint orte_daemon(int argc, char *argv[])\n{\n    static int (*_orte_daemon)(int argc, char *argv[]) = NULL;\n\n    if (!_orte_daemon) {\n        _orte_daemon=dlsym(RTLD_NEXT,\"orte_daemon\");\n        if (!_orte_daemon) {\n            fprintf(stderr, \"Error in 'dlsym': %s\\n\", dlerror());\n            exit(1);\n        } else {\n            FILE *fd = NULL;\n            char filename[1024];\n            char *str = getenv(\"SLURM_PROCID\");\n\n            if (str) {\n                sprintf(filename, \"%s.%s\", \"$outfile\", str);\n                fd = fopen(filename, \"a\");\n                if (fd) {\n                    timestamp(fd);\n                    fclose(fd);\n                }\n            }\n        }\n    }\n\n    return _orte_daemon(argc, argv);\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n  gcc lib_$scenario.c -o $scenario.so -shared -fPIC -ldl >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  LD_PRELOAD=$PWD/$scenario.so mpiexec -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  eval cat $outfile.* >> $outfile\n  rm $outfile.*\n  echo -e \"mpiexec:orte_daemon\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# pure application oshrun:orte_daemon\n#####################################################\nfunction do_test9\n{\n  local status\n  local scenario=test9\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    return 0;\n}\nEND_MSG\n\n  cat > lib_$scenario.c <<END_MSG\n#define _GNU_SOURCE\n$include_timestamp_func\n\nint orte_daemon(int argc, char *argv[])\n{\n    static int (*_orte_daemon)(int argc, char *argv[]) = NULL;\n\n    if (!_orte_daemon) {\n        _orte_daemon=dlsym(RTLD_NEXT,\"orte_daemon\");\n        if (!_orte_daemon) {\n            fprintf(stderr, \"Error in 'dlsym': %s\\n\", dlerror());\n            exit(1);\n        } else {\n            FILE *fd = NULL;\n            char filename[1024];\n            char *str = getenv(\"SLURM_PROCID\");\n\n            if (str) {\n                sprintf(filename, \"%s.%s\", \"$outfile\", str);\n                fd = fopen(filename, \"a\");\n                if (fd) {\n                    timestamp(fd);\n                    fclose(fd);\n                }\n            }\n        }\n    }\n\n    return _orte_daemon(argc, argv);\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n  gcc lib_$scenario.c -o $scenario.so -shared -fPIC -ldl >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  LD_PRELOAD=$PWD/$scenario.so oshrun -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  eval cat $outfile.* >> $outfile\n  rm $outfile.*\n  echo -e \"oshrun:orte_daemon\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# pure application mpiexec:orte_rml_base_update_contact_info\n#####################################################\nfunction do_test10\n{\n  local status\n  local scenario=test10\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    return 0;\n}\nEND_MSG\n\n  cat > lib_$scenario.c <<END_MSG\n#define _GNU_SOURCE\n$include_timestamp_func\n\nint orte_rml_base_update_contact_info(void * data)\n{\n    static int (*_real_func)(void* data) = NULL;\n\n    if (!_real_func) {\n        _real_func=dlsym(RTLD_NEXT,\"orte_rml_base_update_contact_info\");\n        if (!_real_func) {\n            fprintf(stderr, \"Error in 'dlsym': %s\\n\", dlerror());\n            exit(1);\n        } else {\n            FILE *fd = NULL;\n            char filename[1024];\n            char *str = getenv(\"SLURM_PROCID\");\n\n            if (str) {\n                sprintf(filename, \"%s.%s\", \"$outfile\", str);\n                fd = fopen(filename, \"a\");\n                if (fd) {\n                    timestamp(fd);\n                    fclose(fd);\n                }\n            }\n        }\n    }\n\n    return _real_func(data);\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n  mpicc lib_$scenario.c -o $scenario.so -shared -fPIC -ldl >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  LD_PRELOAD=$PWD/$scenario.so mpiexec -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  eval \"cat $outfile.* >> $outfile\" >> $logfile 2>&1\n  rm $outfile.* >> $logfile 2>&1\n  echo -e \"mpiexec:orte_rml_base_update_contact_info\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# pure application oshrun:orte_rml_base_update_contact_info\n#####################################################\nfunction do_test11\n{\n  local status\n  local scenario=test11\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n#include \"shmem.h\"\nint main(int argc, char* argv[])\n{\n    return 0;\n}\nEND_MSG\n\n  cat > lib_$scenario.c <<END_MSG\n#define _GNU_SOURCE\n$include_timestamp_func\n\nint orte_rml_base_update_contact_info(void * data)\n{\n    static int (*_real_func)(void* data) = NULL;\n\n    if (!_real_func) {\n        _real_func=dlsym(RTLD_NEXT,\"orte_rml_base_update_contact_info\");\n        if (!_real_func) {\n            fprintf(stderr, \"Error in 'dlsym': %s\\n\", dlerror());\n            exit(1);\n        } else {\n            FILE *fd = NULL;\n            char filename[1024];\n            char *str = getenv(\"SLURM_PROCID\");\n\n            if (str) {\n                sprintf(filename, \"%s.%s\", \"$outfile\", str);\n                fd = fopen(filename, \"a\");\n                if (fd) {\n                    timestamp(fd);\n                    fclose(fd);\n                }\n            }\n        }\n    }\n\n    return _real_func(data);\n}\nEND_MSG\n\n  oshcc $scenario.c -o $scenario.out >> $logfile 2>&1\n  oshcc lib_$scenario.c -o $scenario.so -shared -fPIC -ldl >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  LD_PRELOAD=$PWD/$scenario.so oshrun -n $(($nodes * $ppn)) -npernode $ppn $mpioptions ./$scenario.out\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  eval \"cat $outfile.* >> $outfile\" >> $logfile 2>&1\n  rm $outfile.* >> $logfile 2>&1\n  echo -e \"oshrun:orte_rml_base_update_contact_info\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# MPI_Init application mpiexec:srun/pmix\n#####################################################\nfunction do_test12\n{\n  local status\n  local scenario=test12\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  do_check_pmix\n  if [ $? -eq 0 ]; then\n    do_msg \"slurm has pmix plugin\"\n  else\n    do_msg \"skipping this test : slurm does not have pmix plugin\"\n    return 1\n  fi\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"mpi.h\"\nint main(int argc, char* argv[])\n{\n    MPI_Init(&argc, &argv);\n    timestamp(stdout);\n    MPI_Finalize();\n    return 0;\n}\nEND_MSG\n\n  mpicc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  env $slurmoptions srun -n$(($nodes * $ppn)) -N$nodes --ntasks-per-node=$ppn --mpi=pmix ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"srun --mpi=pmix:MPI_Init\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# start_pes application oshrun:srun/pmix\n#####################################################\nfunction do_test13\n{\n  local status\n  local scenario=test13\n  local testdir=${tempdir}/$scenario\n  local outfile=${testdir}/${nodes}x${ppn}_out.log\n  local basefile=${testdir}/${nodes}x${ppn}_base.log\n\n  do_msg \"Running $scenario ${nodes}x${ppn} :\"\n\n  do_check_pmix\n  if [ $? -eq 0 ]; then\n    do_msg \"slurm has pmix plugin\"\n  else\n    do_msg \"skipping this test : slurm does not have pmix plugin\"\n    return 1\n  fi\n\n  mkdir -p $testdir\n  cd $testdir\n\n  cat > $scenario.c <<END_MSG\n$include_timestamp_func\n#include \"shmem.h\"\nint main(int argc, char* argv[])\n{\n    start_pes(0);\n    timestamp(stdout);\n    return 0;\n}\nEND_MSG\n\n  oshcc $scenario.c -o $scenario.out >> $logfile 2>&1\n\n  # Do test\n  do_timestamp \"start\" 2>&1 | tee -a $basefile\n  env $slurmoptions srun -n$(($nodes * $ppn)) -N$nodes --ntasks-per-node=$ppn --mpi=pmix ./$scenario.out >> $outfile 2>&1\n  test $? -eq 0 && status=OK || status=FAIL\n  do_timestamp \"end\" 2>&1 | tee -a $basefile\n  if [ \"$status\" == \"FAIL\" ]; then\n    do_err \"can not launch a test\"\n  fi\n\n  echo -e \"srun --mpi=pmix:start_pes\" > ${testdir}/info.log 2>&1\n  do_analysis $testdir $basefile $outfile\n\n  do_msg \"DONE\"\n}\n\n# Main\n###############################################################################\n\n\n# Check if --exec option is passed ($exec is defined)\nif test ${exec+defined}; then\n  tempdir=$PWD/tmp/${prefix}.$$\n  logfile=${tempdir}/${prefix}-time.log\n\n  mkdir -p $tempdir\n  rm -f $logfile\n  cd $tempdir\n\n  do_exec\nfi\n\n# Check if --parse option is passed ($parse is defined)\nif test ${parse+defined}; then\n  if [ -z \"$parse\" ]; then\n    tempdir=$PWD/tmp\n  else\n    tempdir=$parse\n  fi\n  logfile=${tempdir}/${prefix}-parse.log\n\n  mkdir -p $tempdir\n  rm -f $logfile\n  cd $tempdir\n\n  do_parse \"$tempdir\"\nfi\n\nexit 0\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/io/romio321/romio/adio/common/ad_iwrite_coll.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/io/romio321/romio/adio/common/ad_iread_coll.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/io/romio321/romio/doc/source-guide.tex",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/io/romio321/romio/doc/users-guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mca/coll/sm/memory-layout.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/ompi/mpi/fortran/c_to_integer_kind_mapping.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/.git/objects/pack/pack-d7fbf7bfc09b91624522e907d9aa0aed328c27d9.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/.git/objects/pack/pack-d7fbf7bfc09b91624522e907d9aa0aed328c27d9.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/3rd-party/hwloc-2.4.0.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openmpi-master-uwxoihb4pf2epcurx5vxxlbry2j2q5qw/spack-src/3rd-party/libevent-2.1.12-stable.tar.gz"
    ],
    "total_files": 5727
}