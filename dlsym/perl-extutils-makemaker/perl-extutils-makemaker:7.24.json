{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MakeMaker.pm": "# $Id$\npackage ExtUtils::MakeMaker;\n\nuse strict;\n\nBEGIN {require 5.006;}\n\nrequire Exporter;\nuse ExtUtils::MakeMaker::Config;\nuse ExtUtils::MakeMaker::version; # ensure we always have our fake version.pm\nuse Carp;\nuse File::Path;\nmy $CAN_DECODE = eval { require ExtUtils::MakeMaker::Locale; }; # 2 birds, 1 stone\neval { ExtUtils::MakeMaker::Locale::reinit('UTF-8') }\n  if $CAN_DECODE and Encode::find_encoding('locale')->name eq 'ascii';\n\nour $Verbose = 0;       # exported\nour @Parent;            # needs to be localized\nour @Get_from_Config;   # referenced by MM_Unix\nour @MM_Sections;\nour @Overridable;\nmy @Prepend_parent;\nmy %Recognized_Att_Keys;\nour %macro_fsentity; # whether a macro is a filesystem name\nour %macro_dep; # whether a macro is a dependency\n\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]\n\n# Emulate something resembling CVS $Revision$\n(our $Revision = $VERSION) =~ s{_}{};\n$Revision = int $Revision * 10000;\n\nour $Filename = __FILE__;   # referenced outside MakeMaker\n\nour @ISA = qw(Exporter);\nour @EXPORT    = qw(&WriteMakefile $Verbose &prompt);\nour @EXPORT_OK = qw($VERSION &neatvalue &mkbootstrap &mksymlists\n                    &WriteEmptyMakefile &open_for_writing &write_file_via_tmp\n                    &_sprintf562);\n\n# These will go away once the last of the Win32 & VMS specific code is\n# purged.\nmy $Is_VMS     = $^O eq 'VMS';\nmy $Is_Win32   = $^O eq 'MSWin32';\nour $UNDER_CORE = $ENV{PERL_CORE}; # needs to be our\n\nfull_setup();\n\nrequire ExtUtils::MM;  # Things like CPAN assume loading ExtUtils::MakeMaker\n                       # will give them MM.\n\nrequire ExtUtils::MY;  # XXX pre-5.8 versions of ExtUtils::Embed expect\n                       # loading ExtUtils::MakeMaker will give them MY.\n                       # This will go when Embed is its own CPAN module.\n\n\n# 5.6.2 can't do sprintf \"%1$s\" - this can only do %s\nsub _sprintf562 {\n    my ($format, @args) = @_;\n    for (my $i = 1; $i <= @args; $i++) {\n        $format =~ s#%$i\\$s#$args[$i-1]#g;\n    }\n    $format;\n}\n\nsub WriteMakefile {\n    croak \"WriteMakefile: Need even number of args\" if @_ % 2;\n\n    require ExtUtils::MY;\n    my %att = @_;\n\n    _convert_compat_attrs(\\%att);\n\n    _verify_att(\\%att);\n\n    my $mm = MM->new(\\%att);\n    $mm->flush;\n\n    return $mm;\n}\n\n\n# Basic signatures of the attributes WriteMakefile takes.  Each is the\n# reference type.  Empty value indicate it takes a non-reference\n# scalar.\nmy %Att_Sigs;\nmy %Special_Sigs = (\n AUTHOR             => 'ARRAY',\n C                  => 'ARRAY',\n CONFIG             => 'ARRAY',\n CONFIGURE          => 'CODE',\n DIR                => 'ARRAY',\n DL_FUNCS           => 'HASH',\n DL_VARS            => 'ARRAY',\n EXCLUDE_EXT        => 'ARRAY',\n EXE_FILES          => 'ARRAY',\n FUNCLIST           => 'ARRAY',\n H                  => 'ARRAY',\n IMPORTS            => 'HASH',\n INCLUDE_EXT        => 'ARRAY',\n LIBS               => ['ARRAY',''],\n MAN1PODS           => 'HASH',\n MAN3PODS           => 'HASH',\n META_ADD           => 'HASH',\n META_MERGE         => 'HASH',\n OBJECT             => ['ARRAY', ''],\n PL_FILES           => 'HASH',\n PM                 => 'HASH',\n PMLIBDIRS          => 'ARRAY',\n PMLIBPARENTDIRS    => 'ARRAY',\n PREREQ_PM          => 'HASH',\n BUILD_REQUIRES     => 'HASH',\n CONFIGURE_REQUIRES => 'HASH',\n TEST_REQUIRES      => 'HASH',\n SKIP               => 'ARRAY',\n TYPEMAPS           => 'ARRAY',\n XS                 => 'HASH',\n XSBUILD            => 'HASH',\n VERSION            => ['version',''],\n _KEEP_AFTER_FLUSH  => '',\n\n clean      => 'HASH',\n depend     => 'HASH',\n dist       => 'HASH',\n dynamic_lib=> 'HASH',\n linkext    => 'HASH',\n macro      => 'HASH',\n postamble  => 'HASH',\n realclean  => 'HASH',\n test       => 'HASH',\n tool_autosplit => 'HASH',\n);\n\n@Att_Sigs{keys %Recognized_Att_Keys} = ('') x keys %Recognized_Att_Keys;\n@Att_Sigs{keys %Special_Sigs} = values %Special_Sigs;\n\nsub _convert_compat_attrs { #result of running several times should be same\n    my($att) = @_;\n    if (exists $att->{AUTHOR}) {\n        if ($att->{AUTHOR}) {\n            if (!ref($att->{AUTHOR})) {\n                my $t = $att->{AUTHOR};\n                $att->{AUTHOR} = [$t];\n            }\n        } else {\n                $att->{AUTHOR} = [];\n        }\n    }\n}\n\nsub _verify_att {\n    my($att) = @_;\n\n    foreach my $key (sort keys %$att) {\n        my $val = $att->{$key};\n        my $sig = $Att_Sigs{$key};\n        unless( defined $sig ) {\n            warn \"WARNING: $key is not a known parameter.\\n\";\n            next;\n        }\n\n        my @sigs   = ref $sig ? @$sig : $sig;\n        my $given  = ref $val;\n        unless( grep { _is_of_type($val, $_) } @sigs ) {\n            my $takes = join \" or \", map { _format_att($_) } @sigs;\n\n            my $has = _format_att($given);\n            warn \"WARNING: $key takes a $takes not a $has.\\n\".\n                 \"         Please inform the author.\\n\";\n        }\n    }\n}\n\n\n# Check if a given thing is a reference or instance of $type\nsub _is_of_type {\n    my($thing, $type) = @_;\n\n    return 1 if ref $thing eq $type;\n\n    local $SIG{__DIE__};\n    return 1 if eval{ $thing->isa($type) };\n\n    return 0;\n}\n\n\nsub _format_att {\n    my $given = shift;\n\n    return $given eq ''        ? \"string/number\"\n         : uc $given eq $given ? \"$given reference\"\n         :                       \"$given object\"\n         ;\n}\n\n\nsub prompt ($;$) {  ## no critic\n    my($mess, $def) = @_;\n    confess(\"prompt function called without an argument\")\n        unless defined $mess;\n\n    my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;\n\n    my $dispdef = defined $def ? \"[$def] \" : \" \";\n    $def = defined $def ? $def : \"\";\n\n    local $|=1;\n    local $\\;\n    print \"$mess $dispdef\";\n\n    my $ans;\n    if ($ENV{PERL_MM_USE_DEFAULT} || (!$isa_tty && eof STDIN)) {\n        print \"$def\\n\";\n    }\n    else {\n        $ans = <STDIN>;\n        if( defined $ans ) {\n            $ans =~ s{\\015?\\012$}{};\n        }\n        else { # user hit ctrl-D\n            print \"\\n\";\n        }\n    }\n\n    return (!defined $ans || $ans eq '') ? $def : $ans;\n}\n\nsub eval_in_subdirs {\n    my($self) = @_;\n    use Cwd qw(cwd abs_path);\n    my $pwd = cwd() || die \"Can't figure out your cwd!\";\n\n    local @INC = map eval {abs_path($_) if -e} || $_, @INC;\n    push @INC, '.';     # '.' has to always be at the end of @INC\n\n    foreach my $dir (@{$self->{DIR}}){\n        my($abs) = $self->catdir($pwd,$dir);\n        eval { $self->eval_in_x($abs); };\n        last if $@;\n    }\n    chdir $pwd;\n    die $@ if $@;\n}\n\nsub eval_in_x {\n    my($self,$dir) = @_;\n    chdir $dir or carp(\"Couldn't change to directory $dir: $!\");\n\n    {\n        package main;\n        do './Makefile.PL';\n    };\n    if ($@) {\n#         if ($@ =~ /prerequisites/) {\n#             die \"MakeMaker WARNING: $@\";\n#         } else {\n#             warn \"WARNING from evaluation of $dir/Makefile.PL: $@\";\n#         }\n        die \"ERROR from evaluation of $dir/Makefile.PL: $@\";\n    }\n}\n\n\n# package name for the classes into which the first object will be blessed\nmy $PACKNAME = 'PACK000';\n\nsub full_setup {\n    $Verbose ||= 0;\n\n    my @dep_macros = qw/\n    PERL_INCDEP        PERL_ARCHLIBDEP     PERL_ARCHIVEDEP\n    /;\n\n    my @fs_macros = qw/\n    FULLPERL XSUBPPDIR\n\n    INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR\n    INSTALLDIRS\n    DESTDIR PREFIX INSTALL_BASE\n    PERLPREFIX      SITEPREFIX      VENDORPREFIX\n    INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB\n    INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH\n    INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN\n    INSTALLMAN1DIR          INSTALLMAN3DIR\n    INSTALLSITEMAN1DIR      INSTALLSITEMAN3DIR\n    INSTALLVENDORMAN1DIR    INSTALLVENDORMAN3DIR\n    INSTALLSCRIPT   INSTALLSITESCRIPT  INSTALLVENDORSCRIPT\n    PERL_LIB        PERL_ARCHLIB\n    SITELIBEXP      SITEARCHEXP\n\n    MAKE LIBPERL_A LIB PERL_SRC PERL_INC\n    PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC\n    PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT\n    /;\n\n    my @attrib_help = qw/\n\n    AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION\n    C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME\n    DL_FUNCS DL_VARS\n    EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE\n    FULLPERLRUN FULLPERLRUNINST\n    FUNCLIST H IMPORTS\n\n    INC INCLUDE_EXT LDFROM LIBS LICENSE\n    LINKTYPE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET\n    META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES\n    MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL\n    NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN\n    PERLRUNINST PERL_CORE\n    PERM_DIR PERM_RW PERM_RWX MAGICXS\n    PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE\n    PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ\n    SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS\n    XSBUILD XSMULTI XSOPT XSPROTOARG XS_VERSION\n    clean depend dist dynamic_lib linkext macro realclean tool_autosplit\n\n    MAN1EXT MAN3EXT\n\n    MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC\n    MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED\n        /;\n    push @attrib_help, @fs_macros;\n    @macro_fsentity{@fs_macros, @dep_macros} = (1) x (@fs_macros+@dep_macros);\n    @macro_dep{@dep_macros} = (1) x @dep_macros;\n\n    # IMPORTS is used under OS/2 and Win32\n\n    # @Overridable is close to @MM_Sections but not identical.  The\n    # order is important. Many subroutines declare macros. These\n    # depend on each other. Let's try to collect the macros up front,\n    # then pasthru, then the rules.\n\n    # MM_Sections are the sections we have to call explicitly\n    # in Overridable we have subroutines that are used indirectly\n\n\n    @MM_Sections =\n        qw(\n\n post_initialize const_config constants platform_constants\n tool_autosplit tool_xsubpp tools_other\n\n makemakerdflt\n\n dist macro depend cflags const_loadlibs const_cccmd\n post_constants\n\n pasthru\n\n special_targets\n c_o xs_c xs_o\n top_targets blibdirs linkext dlsyms dynamic_bs dynamic\n dynamic_lib static static_lib manifypods processPL\n installbin subdirs\n clean_subdirs clean realclean_subdirs realclean\n metafile signature\n dist_basics dist_core distdir dist_test dist_ci distmeta distsignature\n install force perldepend makefile staticmake test ppd\n\n          ); # loses section ordering\n\n    @Overridable = @MM_Sections;\n    push @Overridable, qw[\n\n libscan makeaperl needs_linking\n subdir_x test_via_harness test_via_script\n\n init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan\n init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker\n                         ];\n\n    push @MM_Sections, qw[\n\n pm_to_blib selfdocument\n\n                         ];\n\n    # Postamble needs to be the last that was always the case\n    push @MM_Sections, \"postamble\";\n    push @Overridable, \"postamble\";\n\n    # All sections are valid keys.\n    @Recognized_Att_Keys{@MM_Sections} = (1) x @MM_Sections;\n\n    # we will use all these variables in the Makefile\n    @Get_from_Config =\n        qw(\n           ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld\n           lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib\n           sitelibexp sitearchexp so\n          );\n\n    # 5.5.3 doesn't have any concept of vendor libs\n    push @Get_from_Config, qw( vendorarchexp vendorlibexp ) if $] >= 5.006;\n\n    foreach my $item (@attrib_help){\n        $Recognized_Att_Keys{$item} = 1;\n    }\n    foreach my $item (@Get_from_Config) {\n        $Recognized_Att_Keys{uc $item} = $Config{$item};\n        print \"Attribute '\\U$item\\E' => '$Config{$item}'\\n\"\n            if ($Verbose >= 2);\n    }\n\n    #\n    # When we eval a Makefile.PL in a subdirectory, that one will ask\n    # us (the parent) for the values and will prepend \"..\", so that\n    # all files to be installed end up below OUR ./blib\n    #\n    @Prepend_parent = qw(\n           INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT\n           MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC\n           PERL FULLPERL\n    );\n}\n\nsub _has_cpan_meta_requirements {\n    return eval {\n      require CPAN::Meta::Requirements;\n      CPAN::Meta::Requirements->VERSION(2.130);\n      require B; # CMR requires this, for core we have to too.\n    };\n}\n\nsub new {\n    my($class,$self) = @_;\n    my($key);\n\n    _convert_compat_attrs($self) if defined $self && $self;\n\n    # Store the original args passed to WriteMakefile()\n    foreach my $k (keys %$self) {\n        $self->{ARGS}{$k} = $self->{$k};\n    }\n\n    $self = {} unless defined $self;\n\n    # Temporarily bless it into MM so it can be used as an\n    # object.  It will be blessed into a temp package later.\n    bless $self, \"MM\";\n\n    # Cleanup all the module requirement bits\n    my %key2cmr;\n    for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {\n        $self->{$key}      ||= {};\n        if (_has_cpan_meta_requirements) {\n            my $cmr = CPAN::Meta::Requirements->from_string_hash(\n                $self->{$key},\n                {\n                  bad_version_hook => sub {\n                    #no warnings 'numeric'; # module doesn't use warnings\n                    my $fallback;\n                    if ( $_[0] =~ m!^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {\n                      $fallback = sprintf \"%f\", $_[0];\n                    } else {\n                      ($fallback) = $_[0] ? ($_[0] =~ /^([0-9.]+)/) : 0;\n                      $fallback += 0;\n                      carp \"Unparsable version '$_[0]' for prerequisite $_[1] treated as $fallback\";\n                    }\n                    version->new($fallback);\n                  },\n                },\n            );\n            $self->{$key} = $cmr->as_string_hash;\n            $key2cmr{$key} = $cmr;\n        } else {\n            for my $module (sort keys %{ $self->{$key} }) {\n                my $version = $self->{$key}->{$module};\n                my $fallback = 0;\n                if (!defined($version) or !length($version)) {\n                    carp \"Undefined requirement for $module treated as '0' (CPAN::Meta::Requirements not available)\";\n                }\n                elsif ($version =~ /^\\d+(?:\\.\\d+(?:_\\d+)*)?$/) {\n                    next;\n                }\n                else {\n                    if ( $version =~ m!^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {\n                      $fallback = sprintf \"%f\", $version;\n                    } else {\n                      ($fallback) = $version ? ($version =~ /^([0-9.]+)/) : 0;\n                      $fallback += 0;\n                      carp \"Unparsable version '$version' for prerequisite $module treated as $fallback (CPAN::Meta::Requirements not available)\";\n                    }\n                }\n                $self->{$key}->{$module} = $fallback;\n            }\n        }\n    }\n\n    if (\"@ARGV\" =~ /\\bPREREQ_PRINT\\b/) {\n        $self->_PREREQ_PRINT;\n    }\n\n    # PRINT_PREREQ is RedHatism.\n    if (\"@ARGV\" =~ /\\bPRINT_PREREQ\\b/) {\n        $self->_PRINT_PREREQ;\n   }\n\n    print \"MakeMaker (v$VERSION)\\n\" if $Verbose;\n    if (-f \"MANIFEST\" && ! -f \"Makefile\" && ! $UNDER_CORE){\n        check_manifest();\n    }\n\n    check_hints($self);\n\n    if ( defined $self->{MIN_PERL_VERSION}\n          && $self->{MIN_PERL_VERSION} !~ /^v?[\\d_\\.]+$/ ) {\n      require version;\n      my $normal = eval {\n        local $SIG{__WARN__} = sub {\n            # simulate \"use warnings FATAL => 'all'\" for vintage perls\n            die @_;\n        };\n        version->new( $self->{MIN_PERL_VERSION} )\n      };\n      $self->{MIN_PERL_VERSION} = $normal if defined $normal && !$@;\n    }\n\n    # Translate X.Y.Z to X.00Y00Z\n    if( defined $self->{MIN_PERL_VERSION} ) {\n        $self->{MIN_PERL_VERSION} =~ s{ ^v? (\\d+) \\. (\\d+) \\. (\\d+) $ }\n                                      {sprintf \"%d.%03d%03d\", $1, $2, $3}ex;\n    }\n\n    my $perl_version_ok = eval {\n        local $SIG{__WARN__} = sub {\n            # simulate \"use warnings FATAL => 'all'\" for vintage perls\n            die @_;\n        };\n        !$self->{MIN_PERL_VERSION} or $self->{MIN_PERL_VERSION} <= $]\n    };\n    if (!$perl_version_ok) {\n        if (!defined $perl_version_ok) {\n            die <<'END';\nWarning: MIN_PERL_VERSION is not in a recognized format.\nRecommended is a quoted numerical value like '5.005' or '5.008001'.\nEND\n        }\n        elsif ($self->{PREREQ_FATAL}) {\n            die sprintf <<\"END\", $self->{MIN_PERL_VERSION}, $];\nMakeMaker FATAL: perl version too low for this distribution.\nRequired is %s. We run %s.\nEND\n        }\n        else {\n            warn sprintf\n                \"Warning: Perl version %s or higher required. We run %s.\\n\",\n                $self->{MIN_PERL_VERSION}, $];\n        }\n    }\n\n    my %configure_att;         # record &{$self->{CONFIGURE}} attributes\n    my(%initial_att) = %$self; # record initial attributes\n\n    my(%unsatisfied) = ();\n    my %prereq2version;\n    my $cmr;\n    if (_has_cpan_meta_requirements) {\n        $cmr = CPAN::Meta::Requirements->new;\n        for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {\n            $cmr->add_requirements($key2cmr{$key}) if $key2cmr{$key};\n        }\n        foreach my $prereq ($cmr->required_modules) {\n            $prereq2version{$prereq} = $cmr->requirements_for_module($prereq);\n        }\n    } else {\n        for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {\n            next unless my $module2version = $self->{$key};\n            $prereq2version{$_} = $module2version->{$_} for keys %$module2version;\n        }\n    }\n    foreach my $prereq (sort keys %prereq2version) {\n        my $required_version = $prereq2version{$prereq};\n\n        my $pr_version = 0;\n        my $installed_file;\n\n        if ( $prereq eq 'perl' ) {\n          if ( defined $required_version && $required_version =~ /^v?[\\d_\\.]+$/\n               || $required_version !~ /^v?[\\d_\\.]+$/ ) {\n            require version;\n            my $normal = eval { version->new( $required_version ) };\n            $required_version = $normal if defined $normal;\n          }\n          $installed_file = $prereq;\n          $pr_version = $];\n        }\n        else {\n          $installed_file = MM->_installed_file_for_module($prereq);\n          $pr_version = MM->parse_version($installed_file) if $installed_file;\n          $pr_version = 0 if $pr_version eq 'undef';\n          if ( !eval { version->new( $pr_version ); 1 } ) {\n            #no warnings 'numeric'; # module doesn't use warnings\n            my $fallback;\n            if ( $pr_version =~ m!^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {\n              $fallback = sprintf '%f', $pr_version;\n            } else {\n              ($fallback) = $pr_version ? ($pr_version =~ /^([0-9.]+)/) : 0;\n              $fallback += 0;\n              carp \"Unparsable version '$pr_version' for installed prerequisite $prereq treated as $fallback\";\n            }\n            $pr_version = $fallback;\n          }\n        }\n\n        # convert X.Y_Z alpha version #s to X.YZ for easier comparisons\n        $pr_version =~ s/(\\d+)\\.(\\d+)_(\\d+)/$1.$2$3/;\n\n        if (!$installed_file) {\n            warn sprintf \"Warning: prerequisite %s %s not found.\\n\",\n              $prereq, $required_version\n                   unless $self->{PREREQ_FATAL}\n                       or $UNDER_CORE;\n\n            $unsatisfied{$prereq} = 'not installed';\n        }\n        elsif (\n            $cmr\n                ? !$cmr->accepts_module($prereq, $pr_version)\n                : $required_version > $pr_version\n        ) {\n            warn sprintf \"Warning: prerequisite %s %s not found. We have %s.\\n\",\n              $prereq, $required_version, ($pr_version || 'unknown version')\n                  unless $self->{PREREQ_FATAL}\n                       or $UNDER_CORE;\n\n            $unsatisfied{$prereq} = $required_version || 'unknown version' ;\n        }\n    }\n\n    if (%unsatisfied && $self->{PREREQ_FATAL}){\n        my $failedprereqs = join \"\\n\", map {\"    $_ $unsatisfied{$_}\"}\n                            sort { $a cmp $b } keys %unsatisfied;\n        die <<\"END\";\nMakeMaker FATAL: prerequisites not found.\n$failedprereqs\n\nPlease install these modules first and rerun 'perl Makefile.PL'.\nEND\n    }\n\n    if (defined $self->{CONFIGURE}) {\n        if (ref $self->{CONFIGURE} eq 'CODE') {\n            %configure_att = %{&{$self->{CONFIGURE}}};\n            _convert_compat_attrs(\\%configure_att);\n            $self = { %$self, %configure_att };\n        } else {\n            croak \"Attribute 'CONFIGURE' to WriteMakefile() not a code reference\\n\";\n        }\n    }\n\n    # This is for old Makefiles written pre 5.00, will go away\n    if ( Carp::longmess(\"\") =~ /runsubdirpl/s ){\n        carp(\"WARNING: Please rerun 'perl Makefile.PL' to regenerate your Makefiles\\n\");\n    }\n\n    my $newclass = ++$PACKNAME;\n    local @Parent = @Parent;    # Protect against non-local exits\n    {\n        print \"Blessing Object into class [$newclass]\\n\" if $Verbose>=2;\n        mv_all_methods(\"MY\",$newclass);\n        bless $self, $newclass;\n        push @Parent, $self;\n        require ExtUtils::MY;\n\n        no strict 'refs';   ## no critic;\n        @{\"$newclass\\:\\:ISA\"} = 'MM';\n    }\n\n    if (defined $Parent[-2]){\n        $self->{PARENT} = $Parent[-2];\n        for my $key (@Prepend_parent) {\n            next unless defined $self->{PARENT}{$key};\n\n            # Don't stomp on WriteMakefile() args.\n            next if defined $self->{ARGS}{$key} and\n                    $self->{ARGS}{$key} eq $self->{$key};\n\n            $self->{$key} = $self->{PARENT}{$key};\n\n            if ($Is_VMS && $key =~ /PERL$/) {\n                # PERL or FULLPERL will be a command verb or even a\n                # command with an argument instead of a full file\n                # specification under VMS.  So, don't turn the command\n                # into a filespec, but do add a level to the path of\n                # the argument if not already absolute.\n                my @cmd = split /\\s+/, $self->{$key};\n                $cmd[1] = $self->catfile('[-]',$cmd[1])\n                  unless (@cmd < 2) || $self->file_name_is_absolute($cmd[1]);\n                $self->{$key} = join(' ', @cmd);\n            } else {\n                my $value = $self->{$key};\n                # not going to test in FS so only stripping start\n                $value =~ s/^\"// if $key =~ /PERL$/;\n                $value = $self->catdir(\"..\", $value)\n                  unless $self->file_name_is_absolute($value);\n                $value = qq{\"$value} if $key =~ /PERL$/;\n                $self->{$key} = $value;\n            }\n        }\n        if ($self->{PARENT}) {\n            $self->{PARENT}->{CHILDREN}->{$newclass} = $self;\n            foreach my $opt (qw(POLLUTE PERL_CORE LINKTYPE LD OPTIMIZE)) {\n                if (exists $self->{PARENT}->{$opt}\n                    and not exists $self->{$opt})\n                    {\n                        # inherit, but only if already unspecified\n                        $self->{$opt} = $self->{PARENT}->{$opt};\n                    }\n            }\n        }\n        my @fm = grep /^FIRST_MAKEFILE=/, @ARGV;\n        parse_args($self,@fm) if @fm;\n    }\n    else {\n        parse_args($self, _shellwords($ENV{PERL_MM_OPT} || ''),@ARGV);\n    }\n\n    # RT#91540 PREREQ_FATAL not recognized on command line\n    if (%unsatisfied && $self->{PREREQ_FATAL}){\n        my $failedprereqs = join \"\\n\", map {\"    $_ $unsatisfied{$_}\"}\n                            sort { $a cmp $b } keys %unsatisfied;\n        die <<\"END\";\nMakeMaker FATAL: prerequisites not found.\n$failedprereqs\n\nPlease install these modules first and rerun 'perl Makefile.PL'.\nEND\n    }\n\n    $self->{NAME} ||= $self->guess_name;\n\n    warn \"Warning: NAME must be a package name\\n\"\n      unless $self->{NAME} =~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;\n\n    ($self->{NAME_SYM} = $self->{NAME}) =~ s/\\W+/_/g;\n\n    $self->init_MAKE;\n    $self->init_main;\n    $self->init_VERSION;\n    $self->init_dist;\n    $self->init_INST;\n    $self->init_INSTALL;\n    $self->init_DEST;\n    $self->init_dirscan;\n    $self->init_PM;\n    $self->init_MANPODS;\n    $self->init_xs;\n    $self->init_PERL;\n    $self->init_DIRFILESEP;\n    $self->init_linker;\n    $self->init_ABSTRACT;\n\n    $self->arch_check(\n        $INC{'Config.pm'},\n        $self->catfile($Config{'archlibexp'}, \"Config.pm\")\n    );\n\n    $self->init_tools();\n    $self->init_others();\n    $self->init_platform();\n    $self->init_PERM();\n    my @args = @ARGV;\n    @args = map { Encode::decode(locale => $_) } @args if $CAN_DECODE;\n    my($argv) = neatvalue(\\@args);\n    $argv =~ s/^\\[/(/;\n    $argv =~ s/\\]$/)/;\n\n    push @{$self->{RESULT}}, <<END;\n# This Makefile is for the $self->{NAME} extension to perl.\n#\n# It was generated automatically by MakeMaker version\n# $VERSION (Revision: $Revision) from the contents of\n# Makefile.PL. Don't edit this file, edit Makefile.PL instead.\n#\n#       ANY CHANGES MADE HERE WILL BE LOST!\n#\n#   MakeMaker ARGV: $argv\n#\nEND\n\n    push @{$self->{RESULT}}, $self->_MakeMaker_Parameters_section(\\%initial_att);\n\n    if (defined $self->{CONFIGURE}) {\n       push @{$self->{RESULT}}, <<END;\n\n#   MakeMaker 'CONFIGURE' Parameters:\nEND\n        if (scalar(keys %configure_att) > 0) {\n            foreach my $key (sort keys %configure_att){\n               next if $key eq 'ARGS';\n               my($v) = neatvalue($configure_att{$key});\n               $v =~ s/(CODE|HASH|ARRAY|SCALAR)\\([\\dxa-f]+\\)/$1\\(...\\)/;\n               $v =~ tr/\\n/ /s;\n               push @{$self->{RESULT}}, \"#     $key => $v\";\n            }\n        }\n        else\n        {\n           push @{$self->{RESULT}}, \"# no values returned\";\n        }\n        undef %configure_att;  # free memory\n    }\n\n    # turn the SKIP array into a SKIPHASH hash\n    for my $skip (@{$self->{SKIP} || []}) {\n        $self->{SKIPHASH}{$skip} = 1;\n    }\n    delete $self->{SKIP}; # free memory\n\n    if ($self->{PARENT}) {\n        for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/) {\n            $self->{SKIPHASH}{$_} = 1;\n        }\n    }\n\n    # We run all the subdirectories now. They don't have much to query\n    # from the parent, but the parent has to query them: if they need linking!\n    unless ($self->{NORECURS}) {\n        $self->eval_in_subdirs if @{$self->{DIR}};\n    }\n\n    foreach my $section ( @MM_Sections ){\n        # Support for new foo_target() methods.\n        my $method = $section;\n        $method .= '_target' unless $self->can($method);\n\n        print \"Processing Makefile '$section' section\\n\" if ($Verbose >= 2);\n        my($skipit) = $self->skipcheck($section);\n        if ($skipit){\n            push @{$self->{RESULT}}, \"\\n# --- MakeMaker $section section $skipit.\";\n        } else {\n            my(%a) = %{$self->{$section} || {}};\n            push @{$self->{RESULT}}, \"\\n# --- MakeMaker $section section:\";\n            push @{$self->{RESULT}}, \"# \" . join \", \", %a if $Verbose && %a;\n            push @{$self->{RESULT}}, $self->maketext_filter(\n                $self->$method( %a )\n            );\n        }\n    }\n\n    push @{$self->{RESULT}}, \"\\n# End.\";\n\n    $self;\n}\n\nsub WriteEmptyMakefile {\n    croak \"WriteEmptyMakefile: Need an even number of args\" if @_ % 2;\n\n    my %att = @_;\n    $att{DIR} = [] unless $att{DIR}; # don't recurse by default\n    my $self = MM->new(\\%att);\n\n    my $new = $self->{MAKEFILE};\n    my $old = $self->{MAKEFILE_OLD};\n    if (-f $old) {\n        _unlink($old) or warn \"unlink $old: $!\";\n    }\n    if ( -f $new ) {\n        _rename($new, $old) or warn \"rename $new => $old: $!\"\n    }\n    open my $mfh, '>', $new or die \"open $new for write: $!\";\n    print $mfh <<'EOP';\nall :\n\nmanifypods :\n\nsubdirs :\n\ndynamic :\n\nstatic :\n\nclean :\n\ninstall :\n\nmakemakerdflt :\n\ntest :\n\ntest_dynamic :\n\ntest_static :\n\nEOP\n    close $mfh or die \"close $new for write: $!\";\n}\n\n\n=begin private\n\n=head3 _installed_file_for_module\n\n  my $file = MM->_installed_file_for_module($module);\n\nReturn the first installed .pm $file associated with the $module.  The\none which will show up when you C<use $module>.\n\n$module is something like \"strict\" or \"Test::More\".\n\n=end private\n\n=cut\n\nsub _installed_file_for_module {\n    my $class  = shift;\n    my $prereq = shift;\n\n    my $file = \"$prereq.pm\";\n    $file =~ s{::}{/}g;\n\n    my $path;\n    for my $dir (@INC) {\n        my $tmp = File::Spec->catfile($dir, $file);\n        if ( -r $tmp ) {\n            $path = $tmp;\n            last;\n        }\n    }\n\n    return $path;\n}\n\n\n# Extracted from MakeMaker->new so we can test it\nsub _MakeMaker_Parameters_section {\n    my $self = shift;\n    my $att  = shift;\n\n    my @result = <<'END';\n#   MakeMaker Parameters:\nEND\n\n    foreach my $key (sort keys %$att){\n        next if $key eq 'ARGS';\n        my $v;\n        if ($key eq 'PREREQ_PM') {\n            # CPAN.pm takes prereqs from this field in 'Makefile'\n            # and does not know about BUILD_REQUIRES\n            $v = neatvalue({\n                %{ $att->{PREREQ_PM} || {} },\n                %{ $att->{BUILD_REQUIRES} || {} },\n                %{ $att->{TEST_REQUIRES} || {} },\n            });\n        } else {\n            $v = neatvalue($att->{$key});\n        }\n\n        $v =~ s/(CODE|HASH|ARRAY|SCALAR)\\([\\dxa-f]+\\)/$1\\(...\\)/;\n        $v =~ tr/\\n/ /s;\n        push @result, \"#     $key => $v\";\n    }\n\n    return @result;\n}\n\n# _shellwords and _parseline borrowed from Text::ParseWords\nsub _shellwords {\n    my (@lines) = @_;\n    my @allwords;\n\n    foreach my $line (@lines) {\n      $line =~ s/^\\s+//;\n      my @words = _parse_line('\\s+', 0, $line);\n      pop @words if (@words and !defined $words[-1]);\n      return() unless (@words || !length($line));\n      push(@allwords, @words);\n    }\n    return(@allwords);\n}\n\nsub _parse_line {\n    my($delimiter, $keep, $line) = @_;\n    my($word, @pieces);\n\n    no warnings 'uninitialized';  # we will be testing undef strings\n\n    while (length($line)) {\n        # This pattern is optimised to be stack conservative on older perls.\n        # Do not refactor without being careful and testing it on very long strings.\n        # See Perl bug #42980 for an example of a stack busting input.\n        $line =~ s/^\n                    (?:\n                        # double quoted string\n                        (\")                             # $quote\n                        ((?>[^\\\\\"]*(?:\\\\.[^\\\\\"]*)*))\"   # $quoted\n        | # --OR--\n                        # singe quoted string\n                        (')                             # $quote\n                        ((?>[^\\\\']*(?:\\\\.[^\\\\']*)*))'   # $quoted\n                    |   # --OR--\n                        # unquoted string\n            (                               # $unquoted\n                            (?:\\\\.|[^\\\\\"'])*?\n                        )\n                        # followed by\n            (                               # $delim\n                            \\Z(?!\\n)                    # EOL\n                        |   # --OR--\n                            (?-x:$delimiter)            # delimiter\n                        |   # --OR--\n                            (?!^)(?=[\"'])               # a quote\n                        )\n        )//xs or return;    # extended layout\n        my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);\n\n\n  return() unless( defined($quote) || length($unquoted) || length($delim));\n\n        if ($keep) {\n      $quoted = \"$quote$quoted$quote\";\n  }\n        else {\n      $unquoted =~ s/\\\\(.)/$1/sg;\n      if (defined $quote) {\n    $quoted =~ s/\\\\(.)/$1/sg if ($quote eq '\"');\n    #$quoted =~ s/\\\\([\\\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq \"'\");\n            }\n  }\n        $word .= substr($line, 0, 0); # leave results tainted\n        $word .= defined $quote ? $quoted : $unquoted;\n\n        if (length($delim)) {\n            push(@pieces, $word);\n            push(@pieces, $delim) if ($keep eq 'delimiters');\n            undef $word;\n        }\n        if (!length($line)) {\n            push(@pieces, $word);\n  }\n    }\n    return(@pieces);\n}\n\nsub check_manifest {\n    print \"Checking if your kit is complete...\\n\";\n    require ExtUtils::Manifest;\n    # avoid warning\n    $ExtUtils::Manifest::Quiet = $ExtUtils::Manifest::Quiet = 1;\n    my(@missed) = ExtUtils::Manifest::manicheck();\n    if (@missed) {\n        print \"Warning: the following files are missing in your kit:\\n\";\n        print \"\\t\", join \"\\n\\t\", @missed;\n        print \"\\n\";\n        print \"Please inform the author.\\n\";\n    } else {\n        print \"Looks good\\n\";\n    }\n}\n\nsub parse_args{\n    my($self, @args) = @_;\n    @args = map { Encode::decode(locale => $_) } @args if $CAN_DECODE;\n    foreach (@args) {\n        unless (m/(.*?)=(.*)/) {\n            ++$Verbose if m/^verb/;\n            next;\n        }\n        my($name, $value) = ($1, $2);\n        if ($value =~ m/^~(\\w+)?/) { # tilde with optional username\n            $value =~ s [^~(\\w*)]\n                [$1 ?\n                 ((getpwnam($1))[7] || \"~$1\") :\n                 (getpwuid($>))[7]\n                 ]ex;\n        }\n\n        # Remember the original args passed it.  It will be useful later.\n        $self->{ARGS}{uc $name} = $self->{uc $name} = $value;\n    }\n\n    # catch old-style 'potential_libs' and inform user how to 'upgrade'\n    if (defined $self->{potential_libs}){\n        my($msg)=\"'potential_libs' => '$self->{potential_libs}' should be\";\n        if ($self->{potential_libs}){\n            print \"$msg changed to:\\n\\t'LIBS' => ['$self->{potential_libs}']\\n\";\n        } else {\n            print \"$msg deleted.\\n\";\n        }\n        $self->{LIBS} = [$self->{potential_libs}];\n        delete $self->{potential_libs};\n    }\n    # catch old-style 'ARMAYBE' and inform user how to 'upgrade'\n    if (defined $self->{ARMAYBE}){\n        my($armaybe) = $self->{ARMAYBE};\n        print \"ARMAYBE => '$armaybe' should be changed to:\\n\",\n                        \"\\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\\n\";\n        my(%dl) = %{$self->{dynamic_lib} || {}};\n        $self->{dynamic_lib} = { %dl, ARMAYBE => $armaybe};\n        delete $self->{ARMAYBE};\n    }\n    if (defined $self->{LDTARGET}){\n        print \"LDTARGET should be changed to LDFROM\\n\";\n        $self->{LDFROM} = $self->{LDTARGET};\n        delete $self->{LDTARGET};\n    }\n    # Turn a DIR argument on the command line into an array\n    if (defined $self->{DIR} && ref \\$self->{DIR} eq 'SCALAR') {\n        # So they can choose from the command line, which extensions they want\n        # the grep enables them to have some colons too much in case they\n        # have to build a list with the shell\n        $self->{DIR} = [grep $_, split \":\", $self->{DIR}];\n    }\n    # Turn a INCLUDE_EXT argument on the command line into an array\n    if (defined $self->{INCLUDE_EXT} && ref \\$self->{INCLUDE_EXT} eq 'SCALAR') {\n        $self->{INCLUDE_EXT} = [grep $_, split '\\s+', $self->{INCLUDE_EXT}];\n    }\n    # Turn a EXCLUDE_EXT argument on the command line into an array\n    if (defined $self->{EXCLUDE_EXT} && ref \\$self->{EXCLUDE_EXT} eq 'SCALAR') {\n        $self->{EXCLUDE_EXT} = [grep $_, split '\\s+', $self->{EXCLUDE_EXT}];\n    }\n\n    foreach my $mmkey (sort keys %$self){\n        next if $mmkey eq 'ARGS';\n        print \"  $mmkey => \", neatvalue($self->{$mmkey}), \"\\n\" if $Verbose;\n        print \"'$mmkey' is not a known MakeMaker parameter name.\\n\"\n            unless exists $Recognized_Att_Keys{$mmkey};\n    }\n    $| = 1 if $Verbose;\n}\n\nsub check_hints {\n    my($self) = @_;\n    # We allow extension-specific hints files.\n\n    require File::Spec;\n    my $curdir = File::Spec->curdir;\n\n    my $hint_dir = File::Spec->catdir($curdir, \"hints\");\n    return unless -d $hint_dir;\n\n    # First we look for the best hintsfile we have\n    my($hint)=\"${^O}_$Config{osvers}\";\n    $hint =~ s/\\./_/g;\n    $hint =~ s/_$//;\n    return unless $hint;\n\n    # Also try without trailing minor version numbers.\n    while (1) {\n        last if -f File::Spec->catfile($hint_dir, \"$hint.pl\");  # found\n    } continue {\n        last unless $hint =~ s/_[^_]*$//; # nothing to cut off\n    }\n    my $hint_file = File::Spec->catfile($hint_dir, \"$hint.pl\");\n\n    return unless -f $hint_file;    # really there\n\n    _run_hintfile($self, $hint_file);\n}\n\nsub _run_hintfile {\n    our $self;\n    local($self) = shift;       # make $self available to the hint file.\n    my($hint_file) = shift;\n\n    local($@, $!);\n    print \"Processing hints file $hint_file\\n\" if $Verbose;\n\n    # Just in case the ./ isn't on the hint file, which File::Spec can\n    # often strip off, we bung the curdir into @INC\n    local @INC = (File::Spec->curdir, @INC);\n    my $ret = do $hint_file;\n    if( !defined $ret ) {\n        my $error = $@ || $!;\n        warn $error;\n    }\n}\n\nsub mv_all_methods {\n    my($from,$to) = @_;\n    local $SIG{__WARN__} = sub {\n        # can't use 'no warnings redefined', 5.6 only\n        warn @_ unless $_[0] =~ /^Subroutine .* redefined/\n    };\n    foreach my $method (@Overridable) {\n        next unless defined &{\"${from}::$method\"};\n        no strict 'refs';   ## no critic\n        *{\"${to}::$method\"} = \\&{\"${from}::$method\"};\n\n        # If we delete a method, then it will be undefined and cannot\n        # be called.  But as long as we have Makefile.PLs that rely on\n        # %MY:: being intact, we have to fill the hole with an\n        # inheriting method:\n\n        {\n            package MY;\n            my $super = \"SUPER::\".$method;\n            *{$method} = sub {\n                shift->$super(@_);\n            };\n        }\n    }\n}\n\nsub skipcheck {\n    my($self) = shift;\n    my($section) = @_;\n    return 'skipped' if $section eq 'metafile' && $UNDER_CORE;\n    if ($section eq 'dynamic') {\n        print \"Warning (non-fatal): Target 'dynamic' depends on targets \",\n        \"in skipped section 'dynamic_bs'\\n\"\n            if $self->{SKIPHASH}{dynamic_bs} && $Verbose;\n        print \"Warning (non-fatal): Target 'dynamic' depends on targets \",\n        \"in skipped section 'dynamic_lib'\\n\"\n            if $self->{SKIPHASH}{dynamic_lib} && $Verbose;\n    }\n    if ($section eq 'dynamic_lib') {\n        print \"Warning (non-fatal): Target '\\$(INST_DYNAMIC)' depends on \",\n        \"targets in skipped section 'dynamic_bs'\\n\"\n            if $self->{SKIPHASH}{dynamic_bs} && $Verbose;\n    }\n    if ($section eq 'static') {\n        print \"Warning (non-fatal): Target 'static' depends on targets \",\n        \"in skipped section 'static_lib'\\n\"\n            if $self->{SKIPHASH}{static_lib} && $Verbose;\n    }\n    return 'skipped' if $self->{SKIPHASH}{$section};\n    return '';\n}\n\n# returns filehandle, dies on fail. :raw so no :crlf\nsub open_for_writing {\n    my ($file) = @_;\n    open my $fh ,\">\", $file or die \"Unable to open $file: $!\";\n    my @layers = ':raw';\n    push @layers, join ' ', ':encoding(locale)' if $CAN_DECODE;\n    binmode $fh, join ' ', @layers;\n    $fh;\n}\n\nsub flush {\n    my $self = shift;\n\n    my $finalname = $self->{MAKEFILE};\n    printf \"Generating a %s %s\\n\", $self->make_type, $finalname if $Verbose || !$self->{PARENT};\n    print \"Writing $finalname for $self->{NAME}\\n\" if $Verbose || !$self->{PARENT};\n\n    unlink($finalname, \"MakeMaker.tmp\", $Is_VMS ? 'Descrip.MMS' : ());\n\n    write_file_via_tmp($finalname, $self->{RESULT});\n\n    # Write MYMETA.yml to communicate metadata up to the CPAN clients\n    print \"Writing MYMETA.yml and MYMETA.json\\n\"\n      if !$self->{NO_MYMETA} and $self->write_mymeta( $self->mymeta );\n\n    # save memory\n    if ($self->{PARENT} && !$self->{_KEEP_AFTER_FLUSH}) {\n        my %keep = map { ($_ => 1) } qw(NEEDS_LINKING HAS_LINK_CODE);\n        delete $self->{$_} for grep !$keep{$_}, keys %$self;\n    }\n\n    system(\"$Config::Config{eunicefix} $finalname\")\n      if $Config::Config{eunicefix} ne \":\";\n\n    return;\n}\n\nsub write_file_via_tmp {\n    my ($finalname, $contents) = @_;\n    my $fh = open_for_writing(\"MakeMaker.tmp\");\n    die \"write_file_via_tmp: 2nd arg must be ref\" unless ref $contents;\n    for my $chunk (@$contents) {\n        my $to_write = $chunk;\n        utf8::encode $to_write if !$CAN_DECODE && $] > 5.008;\n        print $fh \"$to_write\\n\" or die \"Can't write to MakeMaker.tmp: $!\";\n    }\n    close $fh or die \"Can't write to MakeMaker.tmp: $!\";\n    _rename(\"MakeMaker.tmp\", $finalname) or\n      warn \"rename MakeMaker.tmp => $finalname: $!\";\n    chmod 0644, $finalname if !$Is_VMS;\n    return;\n}\n\n# This is a rename for OS's where the target must be unlinked first.\nsub _rename {\n    my($src, $dest) = @_;\n    _unlink($dest);\n    return rename $src, $dest;\n}\n\n# This is an unlink for OS's where the target must be writable first.\nsub _unlink {\n    my @files = @_;\n    chmod 0666, @files;\n    return unlink @files;\n}\n\n\n# The following mkbootstrap() is only for installations that are calling\n# the pre-4.1 mkbootstrap() from their old Makefiles. This MakeMaker\n# writes Makefiles, that use ExtUtils::Mkbootstrap directly.\nsub mkbootstrap {\n    die <<END;\n!!! Your Makefile has been built such a long time ago, !!!\n!!! that is unlikely to work with current MakeMaker.   !!!\n!!! Please rebuild your Makefile                       !!!\nEND\n}\n\n# Ditto for mksymlists() as of MakeMaker 5.17\nsub mksymlists {\n    die <<END;\n!!! Your Makefile has been built such a long time ago, !!!\n!!! that is unlikely to work with current MakeMaker.   !!!\n!!! Please rebuild your Makefile                       !!!\nEND\n}\n\nsub neatvalue {\n    my($v) = @_;\n    return \"undef\" unless defined $v;\n    my($t) = ref $v;\n    return \"q[$v]\" unless $t;\n    if ($t eq 'ARRAY') {\n        my(@m, @neat);\n        push @m, \"[\";\n        foreach my $elem (@$v) {\n            push @neat, \"q[$elem]\";\n        }\n        push @m, join \", \", @neat;\n        push @m, \"]\";\n        return join \"\", @m;\n    }\n    return $v unless $t eq 'HASH';\n    my(@m, $key, $val);\n    for my $key (sort keys %$v) {\n        last unless defined $key; # cautious programming in case (undef,undef) is true\n        push @m,\"$key=>\".neatvalue($v->{$key});\n    }\n    return \"{ \".join(', ',@m).\" }\";\n}\n\nsub _find_magic_vstring {\n    my $value = shift;\n    return $value if $UNDER_CORE;\n    my $tvalue = '';\n    require B;\n    my $sv = B::svref_2object(\\$value);\n    my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;\n    while ( $magic ) {\n        if ( $magic->TYPE eq 'V' ) {\n            $tvalue = $magic->PTR;\n            $tvalue =~ s/^v?(.+)$/v$1/;\n            last;\n        }\n        else {\n            $magic = $magic->MOREMAGIC;\n        }\n    }\n    return $tvalue;\n}\n\nsub selfdocument {\n    my($self) = @_;\n    my(@m);\n    if ($Verbose){\n        push @m, \"\\n# Full list of MakeMaker attribute values:\";\n        foreach my $key (sort keys %$self){\n            next if $key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;\n            my($v) = neatvalue($self->{$key});\n            $v =~ s/(CODE|HASH|ARRAY|SCALAR)\\([\\dxa-f]+\\)/$1\\(...\\)/;\n            $v =~ tr/\\n/ /s;\n            push @m, \"# $key => $v\";\n        }\n    }\n    # added here as selfdocument is not overridable\n    push @m, <<'EOF';\n\n# here so even if top_targets is overridden, these will still be defined\n# gmake will silently still work if any are .PHONY-ed but nmake won't\nEOF\n    push @m, join \"\\n\", map \"$_ ::\\n\\t\\$(NOECHO) \\$(NOOP)\\n\",\n        # config is so manifypods won't puke if no subdirs\n        grep !$self->{SKIPHASH}{$_},\n        qw(static dynamic config);\n    join \"\\n\", @m;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nExtUtils::MakeMaker - Create a module Makefile\n\n=head1 SYNOPSIS\n\n  use ExtUtils::MakeMaker;\n\n  WriteMakefile(\n      NAME              => \"Foo::Bar\",\n      VERSION_FROM      => \"lib/Foo/Bar.pm\",\n  );\n\n=head1 DESCRIPTION\n\nThis utility is designed to write a Makefile for an extension module\nfrom a Makefile.PL. It is based on the Makefile.SH model provided by\nAndy Dougherty and the perl5-porters.\n\nIt splits the task of generating the Makefile into several subroutines\nthat can be individually overridden.  Each subroutine returns the text\nit wishes to have written to the Makefile.\n\nAs there are various Make programs with incompatible syntax, which\nuse operating system shells, again with incompatible syntax, it is\nimportant for users of this module to know which flavour of Make\na Makefile has been written for so they'll use the correct one and\nwon't have to face the possibly bewildering errors resulting from\nusing the wrong one.\n\nOn POSIX systems, that program will likely be GNU Make; on Microsoft\nWindows, it will be either Microsoft NMake, DMake or GNU Make.\nSee the section on the L</\"MAKE\"> parameter for details.\n\nExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current\ndirectory that contains a Makefile.PL is treated as a separate\nobject. This makes it possible to write an unlimited number of\nMakefiles with a single invocation of WriteMakefile().\n\nAll inputs to WriteMakefile are Unicode characters, not just octets. EUMM\nseeks to handle all of these correctly. It is currently still not possible\nto portably use Unicode characters in module names, because this requires\nPerl to handle Unicode filenames, which is not yet the case on Windows.\n\n=head2 How To Write A Makefile.PL\n\nSee L<ExtUtils::MakeMaker::Tutorial>.\n\nThe long answer is the rest of the manpage :-)\n\n=head2 Default Makefile Behaviour\n\nThe generated Makefile enables the user of the extension to invoke\n\n  perl Makefile.PL # optionally \"perl Makefile.PL verbose\"\n  make\n  make test        # optionally set TEST_VERBOSE=1\n  make install     # See below\n\nThe Makefile to be produced may be altered by adding arguments of the\nform C<KEY=VALUE>. E.g.\n\n  perl Makefile.PL INSTALL_BASE=~\n\nOther interesting targets in the generated Makefile are\n\n  make config     # to check if the Makefile is up-to-date\n  make clean      # delete local temp files (Makefile gets renamed)\n  make realclean  # delete derived files (including ./blib)\n  make ci         # check in all the files in the MANIFEST file\n  make dist       # see below the Distribution Support section\n\n=head2 make test\n\nMakeMaker checks for the existence of a file named F<test.pl> in the\ncurrent directory, and if it exists it executes the script with the\nproper set of perl C<-I> options.\n\nMakeMaker also checks for any files matching glob(\"t/*.t\"). It will\nexecute all matching files in alphabetical order via the\nL<Test::Harness> module with the C<-I> switches set correctly.\n\nYou can also organize your tests within subdirectories in the F<t/> directory.\nTo do so, use the F<test> directive in your I<Makefile.PL>. For example, if you\nhad tests in:\n\n    t/foo\n    t/foo/bar\n\nYou could tell make to run tests in both of those directories with the\nfollowing directives:\n\n    test => {TESTS => 't/*/*.t t/*/*/*.t'}\n    test => {TESTS => 't/foo/*.t t/foo/bar/*.t'}\n\nThe first will run all test files in all first-level subdirectories and all\nsubdirectories they contain. The second will run tests in only the F<t/foo>\nand F<t/foo/bar>.\n\nIf you'd like to see the raw output of your tests, set the\nC<TEST_VERBOSE> variable to true.\n\n  make test TEST_VERBOSE=1\n\nIf you want to run particular test files, set the C<TEST_FILES> variable.\nIt is possible to use globbing with this mechanism.\n\n  make test TEST_FILES='t/foobar.t t/dagobah*.t'\n\nWindows users who are using C<nmake> should note that due to a bug in C<nmake>,\nwhen specifying C<TEST_FILES> you must use back-slashes instead of forward-slashes.\n\n  nmake test TEST_FILES='t\\foobar.t t\\dagobah*.t'\n\n=head2 make testdb\n\nA useful variation of the above is the target C<testdb>. It runs the\ntest under the Perl debugger (see L<perldebug>). If the file\nF<test.pl> exists in the current directory, it is used for the test.\n\nIf you want to debug some other testfile, set the C<TEST_FILE> variable\nthusly:\n\n  make testdb TEST_FILE=t/mytest.t\n\nBy default the debugger is called using C<-d> option to perl. If you\nwant to specify some other option, set the C<TESTDB_SW> variable:\n\n  make testdb TESTDB_SW=-Dx\n\n=head2 make install\n\nmake alone puts all relevant files into directories that are named by\nthe macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and\nINST_MAN3DIR.  All these default to something below ./blib if you are\nI<not> building below the perl source directory. If you I<are>\nbuilding below the perl source, INST_LIB and INST_ARCHLIB default to\n../../lib, and INST_SCRIPT is not defined.\n\nThe I<install> target of the generated Makefile copies the files found\nbelow each of the INST_* directories to their INSTALL*\ncounterparts. Which counterparts are chosen depends on the setting of\nINSTALLDIRS according to the following table:\n\n                                 INSTALLDIRS set to\n                           perl        site          vendor\n\n                 PERLPREFIX      SITEPREFIX          VENDORPREFIX\n  INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH\n  INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB\n  INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN\n  INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT\n  INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR\n  INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR\n\nThe INSTALL... macros in turn default to their %Config\n($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.\n\nYou can check the values of these variables on your system with\n\n    perl '-V:install.*'\n\nAnd to check the sequence in which the library directories are\nsearched by perl, run\n\n    perl -le 'print join $/, @INC'\n\nSometimes older versions of the module you're installing live in other\ndirectories in @INC.  Because Perl loads the first version of a module it\nfinds, not the newest, you might accidentally get one of these older\nversions even after installing a brand new version.  To delete I<all other\nversions of the module you're installing> (not simply older ones) set the\nC<UNINST> variable.\n\n    make install UNINST=1\n\n\n=head2 INSTALL_BASE\n\nINSTALL_BASE can be passed into Makefile.PL to change where your\nmodule will be installed.  INSTALL_BASE is more like what everyone\nelse calls \"prefix\" than PREFIX is.\n\nTo have everything installed in your home directory, do the following.\n\n    # Unix users, INSTALL_BASE=~ works fine\n    perl Makefile.PL INSTALL_BASE=/path/to/your/home/dir\n\nLike PREFIX, it sets several INSTALL* attributes at once.  Unlike\nPREFIX it is easy to predict where the module will end up.  The\ninstallation pattern looks like this:\n\n    INSTALLARCHLIB     INSTALL_BASE/lib/perl5/$Config{archname}\n    INSTALLPRIVLIB     INSTALL_BASE/lib/perl5\n    INSTALLBIN         INSTALL_BASE/bin\n    INSTALLSCRIPT      INSTALL_BASE/bin\n    INSTALLMAN1DIR     INSTALL_BASE/man/man1\n    INSTALLMAN3DIR     INSTALL_BASE/man/man3\n\nINSTALL_BASE in MakeMaker and C<--install_base> in Module::Build (as\nof 0.28) install to the same location.  If you want MakeMaker and\nModule::Build to install to the same location simply set INSTALL_BASE\nand C<--install_base> to the same location.\n\nINSTALL_BASE was added in 6.31.\n\n\n=head2 PREFIX and LIB attribute\n\nPREFIX and LIB can be used to set several INSTALL* attributes in one\ngo.  Here's an example for installing into your home directory.\n\n    # Unix users, PREFIX=~ works fine\n    perl Makefile.PL PREFIX=/path/to/your/home/dir\n\nThis will install all files in the module under your home directory,\nwith man pages and libraries going into an appropriate place (usually\n~/man and ~/lib).  How the exact location is determined is complicated\nand depends on how your Perl was configured.  INSTALL_BASE works more\nlike what other build systems call \"prefix\" than PREFIX and we\nrecommend you use that instead.\n\nAnother way to specify many INSTALL directories with a single\nparameter is LIB.\n\n    perl Makefile.PL LIB=~/lib\n\nThis will install the module's architecture-independent files into\n~/lib, the architecture-dependent files into ~/lib/$archname.\n\nNote, that in both cases the tilde expansion is done by MakeMaker, not\nby perl by default, nor by make.\n\nConflicts between parameters LIB, PREFIX and the various INSTALL*\narguments are resolved so that:\n\n=over 4\n\n=item *\n\nsetting LIB overrides any setting of INSTALLPRIVLIB, INSTALLARCHLIB,\nINSTALLSITELIB, INSTALLSITEARCH (and they are not affected by PREFIX);\n\n=item *\n\nwithout LIB, setting PREFIX replaces the initial C<$Config{prefix}>\npart of those INSTALL* arguments, even if the latter are explicitly\nset (but are set to still start with C<$Config{prefix}>).\n\n=back\n\nIf the user has superuser privileges, and is not working on AFS or\nrelatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB,\nINSTALLSCRIPT, etc. will be appropriate, and this incantation will be\nthe best:\n\n    perl Makefile.PL;\n    make;\n    make test\n    make install\n\nmake install by default writes some documentation of what has been\ndone into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This feature\ncan be bypassed by calling make pure_install.\n\n=head2 AFS users\n\nwill have to specify the installation directories as these most\nprobably have changed since perl itself has been installed. They will\nhave to do this by calling\n\n    perl Makefile.PL INSTALLSITELIB=/afs/here/today \\\n        INSTALLSCRIPT=/afs/there/now INSTALLMAN3DIR=/afs/for/manpages\n    make\n\nBe careful to repeat this procedure every time you recompile an\nextension, unless you are sure the AFS installation directories are\nstill valid.\n\n=head2 Static Linking of a new Perl Binary\n\nAn extension that is built with the above steps is ready to use on\nsystems supporting dynamic loading. On systems that do not support\ndynamic loading, any newly created extension has to be linked together\nwith the available resources. MakeMaker supports the linking process\nby creating appropriate targets in the Makefile whenever an extension\nis built. You can invoke the corresponding section of the makefile with\n\n    make perl\n\nThat produces a new perl binary in the current directory with all\nextensions linked in that can be found in INST_ARCHLIB, SITELIBEXP,\nand PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on\nUNIX, this is called F<Makefile.aperl> (may be system dependent). If you\nwant to force the creation of a new perl, it is recommended that you\ndelete this F<Makefile.aperl>, so the directories are searched through\nfor linkable libraries again.\n\nThe binary can be installed into the directory where perl normally\nresides on your machine with\n\n    make inst_perl\n\nTo produce a perl binary with a different name than C<perl>, either say\n\n    perl Makefile.PL MAP_TARGET=myperl\n    make myperl\n    make inst_perl\n\nor say\n\n    perl Makefile.PL\n    make myperl MAP_TARGET=myperl\n    make inst_perl MAP_TARGET=myperl\n\nIn any case you will be prompted with the correct invocation of the\nC<inst_perl> target that installs the new binary into INSTALLBIN.\n\nmake inst_perl by default writes some documentation of what has been\ndone into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This\ncan be bypassed by calling make pure_inst_perl.\n\nWarning: the inst_perl: target will most probably overwrite your\nexisting perl binary. Use with care!\n\nSometimes you might want to build a statically linked perl although\nyour system supports dynamic loading. In this case you may explicitly\nset the linktype with the invocation of the Makefile.PL or make:\n\n    perl Makefile.PL LINKTYPE=static    # recommended\n\nor\n\n    make LINKTYPE=static                # works on most systems\n\n=head2 Determination of Perl Library and Installation Locations\n\nMakeMaker needs to know, or to guess, where certain things are\nlocated.  Especially INST_LIB and INST_ARCHLIB (where to put the files\nduring the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read\nexisting modules from), and PERL_INC (header files and C<libperl*.*>).\n\nExtensions may be built either using the contents of the perl source\ndirectory tree or from the installed perl library. The recommended way\nis to build extensions after you have run 'make install' on perl\nitself. You can do that in any directory on your hard disk that is not\nbelow the perl source tree. The support for extensions below the ext\ndirectory of the perl distribution is only good for the standard\nextensions that come with perl.\n\nIf an extension is being built below the C<ext/> directory of the perl\nsource then MakeMaker will set PERL_SRC automatically (e.g.,\nC<../..>).  If PERL_SRC is defined and the extension is recognized as\na standard extension, then other variables default to the following:\n\n  PERL_INC     = PERL_SRC\n  PERL_LIB     = PERL_SRC/lib\n  PERL_ARCHLIB = PERL_SRC/lib\n  INST_LIB     = PERL_LIB\n  INST_ARCHLIB = PERL_ARCHLIB\n\nIf an extension is being built away from the perl source then MakeMaker\nwill leave PERL_SRC undefined and default to using the installed copy\nof the perl library. The other variables default to the following:\n\n  PERL_INC     = $archlibexp/CORE\n  PERL_LIB     = $privlibexp\n  PERL_ARCHLIB = $archlibexp\n  INST_LIB     = ./blib/lib\n  INST_ARCHLIB = ./blib/arch\n\nIf perl has not yet been installed then PERL_SRC can be defined on the\ncommand line as shown in the previous section.\n\n\n=head2 Which architecture dependent directory?\n\nIf you don't want to keep the defaults for the INSTALL* macros,\nMakeMaker helps you to minimize the typing needed: the usual\nrelationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined\nby Configure at perl compilation time. MakeMaker supports the user who\nsets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not,\nthen MakeMaker defaults the latter to be the same subdirectory of\nINSTALLPRIVLIB as Configure decided for the counterparts in %Config,\notherwise it defaults to INSTALLPRIVLIB. The same relationship holds\nfor INSTALLSITELIB and INSTALLSITEARCH.\n\nMakeMaker gives you much more freedom than needed to configure\ninternal variables and get different results. It is worth mentioning\nthat make(1) also lets you configure most of the variables that are\nused in the Makefile. But in the majority of situations this will not\nbe necessary, and should only be done if the author of a package\nrecommends it (or you know what you're doing).\n\n=head2 Using Attributes and Parameters\n\nThe following attributes may be specified as arguments to WriteMakefile()\nor as NAME=VALUE pairs on the command line. Attributes that became\navailable with later versions of MakeMaker are indicated.\n\nIn order to maintain portability of attributes with older versions of\nMakeMaker you may want to use L<App::EUMM::Upgrade> with your C<Makefile.PL>.\n\n=over 2\n\n=item ABSTRACT\n\nOne line description of the module. Will be included in PPD file.\n\n=item ABSTRACT_FROM\n\nName of the file that contains the package description. MakeMaker looks\nfor a line in the POD matching /^($package\\s-\\s)(.*)/. This is typically\nthe first line in the \"=head1 NAME\" section. $2 becomes the abstract.\n\n=item AUTHOR\n\nArray of strings containing name (and email address) of package author(s).\nIs used in CPAN Meta files (META.yml or META.json) and PPD\n(Perl Package Description) files for PPM (Perl Package Manager).\n\n=item BINARY_LOCATION\n\nUsed when creating PPD files for binary packages.  It can be set to a\nfull or relative path or URL to the binary archive for a particular\narchitecture.  For example:\n\n        perl Makefile.PL BINARY_LOCATION=x86/Agent.tar.gz\n\nbuilds a PPD package that references a binary of the C<Agent> package,\nlocated in the C<x86> directory relative to the PPD itself.\n\n=item BUILD_REQUIRES\n\nAvailable in version 6.5503 and above.\n\nA hash of modules that are needed to build your module but not run it.\n\nThis will go into the C<build_requires> field of your F<META.yml> and the C<build> of the C<prereqs> field of your F<META.json>.\n\nDefaults to C<<< { \"ExtUtils::MakeMaker\" => 0 } >>> if this attribute is not specified.\n\nThe format is the same as PREREQ_PM.\n\n=item C\n\nRef to array of *.c file names. Initialised from a directory scan\nand the values portion of the XS attribute hash. This is not\ncurrently used by MakeMaker but may be handy in Makefile.PLs.\n\n=item CCFLAGS\n\nString that will be included in the compiler call command line between\nthe arguments INC and OPTIMIZE.\n\n=item CONFIG\n\nArrayref. E.g. [qw(archname manext)] defines ARCHNAME & MANEXT from\nconfig.sh. MakeMaker will add to CONFIG the following values anyway:\nar\ncc\ncccdlflags\nccdlflags\ndlext\ndlsrc\nld\nlddlflags\nldflags\nlibc\nlib_ext\nobj_ext\nranlib\nsitelibexp\nsitearchexp\nso\n\n=item CONFIGURE\n\nCODE reference. The subroutine should return a hash reference. The\nhash may contain further attributes, e.g. {LIBS =E<gt> ...}, that have to\nbe determined by some evaluation method.\n\n=item CONFIGURE_REQUIRES\n\nAvailable in version 6.52 and above.\n\nA hash of modules that are required to run Makefile.PL itself, but not\nto run your distribution.\n\nThis will go into the C<configure_requires> field of your F<META.yml> and the C<configure> of the C<prereqs> field of your F<META.json>.\n\nDefaults to C<<< { \"ExtUtils::MakeMaker\" => 0 } >>> if this attribute is not specified.\n\nThe format is the same as PREREQ_PM.\n\n=item DEFINE\n\nSomething like C<\"-DHAVE_UNISTD_H\">\n\n=item DESTDIR\n\nThis is the root directory into which the code will be installed.  It\nI<prepends itself to the normal prefix>.  For example, if your code\nwould normally go into F</usr/local/lib/perl> you could set DESTDIR=~/tmp/\nand installation would go into F<~/tmp/usr/local/lib/perl>.\n\nThis is primarily of use for people who repackage Perl modules.\n\nNOTE: Due to the nature of make, it is important that you put the trailing\nslash on your DESTDIR.  F<~/tmp/> not F<~/tmp>.\n\n=item DIR\n\nRef to array of subdirectories containing Makefile.PLs e.g. ['sdbm']\nin ext/SDBM_File\n\n=item DISTNAME\n\nA safe filename for the package.\n\nDefaults to NAME below but with :: replaced with -.\n\nFor example, Foo::Bar becomes Foo-Bar.\n\n=item DISTVNAME\n\nYour name for distributing the package with the version number\nincluded.  This is used by 'make dist' to name the resulting archive\nfile.\n\nDefaults to DISTNAME-VERSION.\n\nFor example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.\n\nOn some OS's where . has special meaning VERSION_SYM may be used in\nplace of VERSION.\n\n=item DLEXT\n\nSpecifies the extension of the module's loadable object. For example:\n\n  DLEXT => 'unusual_ext', # Default value is $Config{so}\n\nNOTE: When using this option to alter the extension of a module's\nloadable object, it is also necessary that the module's pm file\nspecifies the same change:\n\n  local $DynaLoader::dl_dlext = 'unusual_ext';\n\n=item DL_FUNCS\n\nHashref of symbol names for routines to be made available as universal\nsymbols.  Each key/value pair consists of the package name and an\narray of routine names in that package.  Used only under AIX, OS/2,\nVMS and Win32 at present.  The routine names supplied will be expanded\nin the same way as XSUB names are expanded by the XS() macro.\nDefaults to\n\n  {\"$(NAME)\" => [\"boot_$(NAME)\" ] }\n\ne.g.\n\n  {\"RPC\" => [qw( boot_rpcb rpcb_gettime getnetconfigent )],\n   \"NetconfigPtr\" => [ 'DESTROY'] }\n\nPlease see the L<ExtUtils::Mksymlists> documentation for more information\nabout the DL_FUNCS, DL_VARS and FUNCLIST attributes.\n\n=item DL_VARS\n\nArray of symbol names for variables to be made available as universal symbols.\nUsed only under AIX, OS/2, VMS and Win32 at present.  Defaults to [].\n(e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])\n\n=item EXCLUDE_EXT\n\nArray of extension names to exclude when doing a static build.  This\nis ignored if INCLUDE_EXT is present.  Consult INCLUDE_EXT for more\ndetails.  (e.g.  [ qw( Socket POSIX ) ] )\n\nThis attribute may be most useful when specified as a string on the\ncommand line:  perl Makefile.PL EXCLUDE_EXT='Socket Safe'\n\n=item EXE_FILES\n\nRef to array of executable files. The files will be copied to the\nINST_SCRIPT directory. Make realclean will delete them from there\nagain.\n\nIf your executables start with something like #!perl or\n#!/usr/bin/perl MakeMaker will change this to the path of the perl\n'Makefile.PL' was invoked with so the programs will be sure to run\nproperly even if perl is not in /usr/bin/perl.\n\n=item FIRST_MAKEFILE\n\nThe name of the Makefile to be produced.  This is used for the second\nMakefile that will be produced for the MAP_TARGET.\n\nDefaults to 'Makefile' or 'Descrip.MMS' on VMS.\n\n(Note: we couldn't use MAKEFILE because dmake uses this for something\nelse).\n\n=item FULLPERL\n\nPerl binary able to run this extension, load XS modules, etc...\n\n=item FULLPERLRUN\n\nLike PERLRUN, except it uses FULLPERL.\n\n=item FULLPERLRUNINST\n\nLike PERLRUNINST, except it uses FULLPERL.\n\n=item FUNCLIST\n\nThis provides an alternate means to specify function names to be\nexported from the extension.  Its value is a reference to an\narray of function names to be exported by the extension.  These\nnames are passed through unaltered to the linker options file.\n\n=item H\n\nRef to array of *.h file names. Similar to C.\n\n=item IMPORTS\n\nThis attribute is used to specify names to be imported into the\nextension. Takes a hash ref.\n\nIt is only used on OS/2 and Win32.\n\n=item INC\n\nInclude file dirs eg: C<\"-I/usr/5include -I/path/to/inc\">\n\n=item INCLUDE_EXT\n\nArray of extension names to be included when doing a static build.\nMakeMaker will normally build with all of the installed extensions when\ndoing a static build, and that is usually the desired behavior.  If\nINCLUDE_EXT is present then MakeMaker will build only with those extensions\nwhich are explicitly mentioned. (e.g.  [ qw( Socket POSIX ) ])\n\nIt is not necessary to mention DynaLoader or the current extension when\nfilling in INCLUDE_EXT.  If the INCLUDE_EXT is mentioned but is empty then\nonly DynaLoader and the current extension will be included in the build.\n\nThis attribute may be most useful when specified as a string on the\ncommand line:  perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'\n\n=item INSTALLARCHLIB\n\nUsed by 'make install', which copies files from INST_ARCHLIB to this\ndirectory if INSTALLDIRS is set to perl.\n\n=item INSTALLBIN\n\nDirectory to install binary files (e.g. tkperl) into if\nINSTALLDIRS=perl.\n\n=item INSTALLDIRS\n\nDetermines which of the sets of installation directories to choose:\nperl, site or vendor.  Defaults to site.\n\n=item INSTALLMAN1DIR\n\n=item INSTALLMAN3DIR\n\nThese directories get the man pages at 'make install' time if\nINSTALLDIRS=perl.  Defaults to $Config{installman*dir}.\n\nIf set to 'none', no man pages will be installed.\n\n=item INSTALLPRIVLIB\n\nUsed by 'make install', which copies files from INST_LIB to this\ndirectory if INSTALLDIRS is set to perl.\n\nDefaults to $Config{installprivlib}.\n\n=item INSTALLSCRIPT\n\nUsed by 'make install' which copies files from INST_SCRIPT to this\ndirectory if INSTALLDIRS=perl.\n\n=item INSTALLSITEARCH\n\nUsed by 'make install', which copies files from INST_ARCHLIB to this\ndirectory if INSTALLDIRS is set to site (default).\n\n=item INSTALLSITEBIN\n\nUsed by 'make install', which copies files from INST_BIN to this\ndirectory if INSTALLDIRS is set to site (default).\n\n=item INSTALLSITELIB\n\nUsed by 'make install', which copies files from INST_LIB to this\ndirectory if INSTALLDIRS is set to site (default).\n\n=item INSTALLSITEMAN1DIR\n\n=item INSTALLSITEMAN3DIR\n\nThese directories get the man pages at 'make install' time if\nINSTALLDIRS=site (default).  Defaults to\n$(SITEPREFIX)/man/man$(MAN*EXT).\n\nIf set to 'none', no man pages will be installed.\n\n=item INSTALLSITESCRIPT\n\nUsed by 'make install' which copies files from INST_SCRIPT to this\ndirectory if INSTALLDIRS is set to site (default).\n\n=item INSTALLVENDORARCH\n\nUsed by 'make install', which copies files from INST_ARCHLIB to this\ndirectory if INSTALLDIRS is set to vendor.\n\n=item INSTALLVENDORBIN\n\nUsed by 'make install', which copies files from INST_BIN to this\ndirectory if INSTALLDIRS is set to vendor.\n\n=item INSTALLVENDORLIB\n\nUsed by 'make install', which copies files from INST_LIB to this\ndirectory if INSTALLDIRS is set to vendor.\n\n=item INSTALLVENDORMAN1DIR\n\n=item INSTALLVENDORMAN3DIR\n\nThese directories get the man pages at 'make install' time if\nINSTALLDIRS=vendor.  Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).\n\nIf set to 'none', no man pages will be installed.\n\n=item INSTALLVENDORSCRIPT\n\nUsed by 'make install' which copies files from INST_SCRIPT to this\ndirectory if INSTALLDIRS is set to vendor.\n\n=item INST_ARCHLIB\n\nSame as INST_LIB for architecture dependent files.\n\n=item INST_BIN\n\nDirectory to put real binary files during 'make'. These will be copied\nto INSTALLBIN during 'make install'\n\n=item INST_LIB\n\nDirectory where we put library files of this extension while building\nit.\n\n=item INST_MAN1DIR\n\nDirectory to hold the man pages at 'make' time\n\n=item INST_MAN3DIR\n\nDirectory to hold the man pages at 'make' time\n\n=item INST_SCRIPT\n\nDirectory where executable files should be installed during\n'make'. Defaults to \"./blib/script\", just to have a dummy location during\ntesting. make install will copy the files in INST_SCRIPT to\nINSTALLSCRIPT.\n\n=item LD\n\nProgram to be used to link libraries for dynamic loading.\n\nDefaults to $Config{ld}.\n\n=item LDDLFLAGS\n\nAny special flags that might need to be passed to ld to create a\nshared library suitable for dynamic loading.  It is up to the makefile\nto use it.  (See L<Config/lddlflags>)\n\nDefaults to $Config{lddlflags}.\n\n=item LDFROM\n\nDefaults to \"$(OBJECT)\" and is used in the ld command to specify\nwhat files to link/load from (also see dynamic_lib below for how to\nspecify ld flags)\n\n=item LIB\n\nLIB should only be set at C<perl Makefile.PL> time but is allowed as a\nMakeMaker argument. It has the effect of setting both INSTALLPRIVLIB\nand INSTALLSITELIB to that value regardless any explicit setting of\nthose arguments (or of PREFIX).  INSTALLARCHLIB and INSTALLSITEARCH\nare set to the corresponding architecture subdirectory.\n\n=item LIBPERL_A\n\nThe filename of the perllibrary that will be used together with this\nextension. Defaults to libperl.a.\n\n=item LIBS\n\nAn anonymous array of alternative library\nspecifications to be searched for (in order) until\nat least one library is found. E.g.\n\n  'LIBS' => [\"-lgdbm\", \"-ldbm -lfoo\", \"-L/path -ldbm.nfs\"]\n\nMind, that any element of the array\ncontains a complete set of arguments for the ld\ncommand. So do not specify\n\n  'LIBS' => [\"-ltcl\", \"-ltk\", \"-lX11\"]\n\nSee ODBM_File/Makefile.PL for an example, where an array is needed. If\nyou specify a scalar as in\n\n  'LIBS' => \"-ltcl -ltk -lX11\"\n\nMakeMaker will turn it into an array with one element.\n\n=item LICENSE\n\nAvailable in version 6.31 and above.\n\nThe licensing terms of your distribution.  Generally it's \"perl_5\" for the\nsame license as Perl itself.\n\nSee L<CPAN::Meta::Spec> for the list of options.\n\nDefaults to \"unknown\".\n\n=item LINKTYPE\n\n'static' or 'dynamic' (default unless usedl=undef in\nconfig.sh). Should only be used to force static linking (also see\nlinkext below).\n\n=item MAGICXS\n\nWhen this is set to C<1>, C<OBJECT> will be automagically derived from\nC<O_FILES>.\n\n=item MAKE\n\nVariant of make you intend to run the generated Makefile with.  This\nparameter lets Makefile.PL know what make quirks to account for when\ngenerating the Makefile.\n\nMakeMaker also honors the MAKE environment variable.  This parameter\ntakes precedence.\n\nCurrently the only significant values are 'dmake' and 'nmake' for Windows\nusers, instructing MakeMaker to generate a Makefile in the flavour of\nDMake (\"Dennis Vadura's Make\") or Microsoft NMake respectively.\n\nDefaults to $Config{make}, which may go looking for a Make program\nin your environment.\n\nHow are you supposed to know what flavour of Make a Makefile has\nbeen generated for if you didn't specify a value explicitly? Search\nthe generated Makefile for the definition of the MAKE variable,\nwhich is used to recursively invoke the Make utility. That will tell\nyou what Make you're supposed to invoke the Makefile with.\n\n=item MAKEAPERL\n\nBoolean which tells MakeMaker that it should include the rules to\nmake a perl. This is handled automatically as a switch by\nMakeMaker. The user normally does not need it.\n\n=item MAKEFILE_OLD\n\nWhen 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be\nbacked up at this location.\n\nDefaults to $(FIRST_MAKEFILE).old or $(FIRST_MAKEFILE)_old on VMS.\n\n=item MAN1PODS\n\nHashref of pod-containing files. MakeMaker will default this to all\nEXE_FILES files that include POD directives. The files listed\nhere will be converted to man pages and installed as was requested\nat Configure time.\n\nThis hash should map POD files (or scripts containing POD) to the\nman file names under the C<blib/man1/> directory, as in the following\nexample:\n\n  MAN1PODS            => {\n    'doc/command.pod'    => 'blib/man1/command.1',\n    'scripts/script.pl'  => 'blib/man1/script.1',\n  }\n\n=item MAN3PODS\n\nHashref that assigns to *.pm and *.pod files the files into which the\nmanpages are to be written. MakeMaker parses all *.pod and *.pm files\nfor POD directives. Files that contain POD will be the default keys of\nthe MAN3PODS hashref. These will then be converted to man pages during\nC<make> and will be installed during C<make install>.\n\nExample similar to MAN1PODS.\n\n=item MAP_TARGET\n\nIf it is intended that a new perl binary be produced, this variable\nmay hold a name for that binary. Defaults to perl\n\n=item META_ADD\n\n=item META_MERGE\n\nAvailable in version 6.46 and above.\n\nA hashref of items to add to the CPAN Meta file (F<META.yml> or\nF<META.json>).\n\nThey differ in how they behave if they have the same key as the\ndefault metadata.  META_ADD will override the default value with its\nown.  META_MERGE will merge its value with the default.\n\nUnless you want to override the defaults, prefer META_MERGE so as to\nget the advantage of any future defaults.\n\nWhere prereqs are concerned, if META_MERGE is used, prerequisites are merged\nwith their counterpart C<WriteMakefile()> argument\n(PREREQ_PM is merged into {prereqs}{runtime}{requires},\nBUILD_REQUIRES into C<{prereqs}{build}{requires}>,\nCONFIGURE_REQUIRES into C<{prereqs}{configure}{requires}>,\nand TEST_REQUIRES into C<{prereqs}{test}{requires})>.\nWhen prereqs are specified with META_ADD, the only prerequisites added to the\nfile come from the metadata, not C<WriteMakefile()> arguments.\n\nNote that these configuration options are only used for generating F<META.yml>\nand F<META.json> -- they are NOT used for F<MYMETA.yml> and F<MYMETA.json>.\nTherefore data in these fields should NOT be used for dynamic (user-side)\nconfiguration.\n\nBy default CPAN Meta specification C<1.4> is used. In order to use\nCPAN Meta specification C<2.0>, indicate with C<meta-spec> the version\nyou want to use.\n\n  META_MERGE        => {\n\n    \"meta-spec\" => { version => 2 },\n\n    resources => {\n\n      repository => {\n          type => 'git',\n          url => 'git://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker.git',\n          web => 'https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker',\n      },\n\n    },\n\n  },\n\n=item MIN_PERL_VERSION\n\nAvailable in version 6.48 and above.\n\nThe minimum required version of Perl for this distribution.\n\nEither the 5.006001 or the 5.6.1 format is acceptable.\n\n=item MYEXTLIB\n\nIf the extension links to a library that it builds, set this to the\nname of the library (see SDBM_File)\n\n=item NAME\n\nThe package representing the distribution. For example, C<Test::More>\nor C<ExtUtils::MakeMaker>. It will be used to derive information about\nthe distribution such as the L</DISTNAME>, installation locations\nwithin the Perl library and where XS files will be looked for by\ndefault (see L</XS>).\n\nC<NAME> I<must> be a valid Perl package name and it I<must> have an\nassociated C<.pm> file. For example, C<Foo::Bar> is a valid C<NAME>\nand there must exist F<Foo/Bar.pm>.  Any XS code should be in\nF<Bar.xs> unless stated otherwise.\n\nYour distribution B<must> have a C<NAME>.\n\n=item NEEDS_LINKING\n\nMakeMaker will figure out if an extension contains linkable code\nanywhere down the directory tree, and will set this variable\naccordingly, but you can speed it up a very little bit if you define\nthis boolean variable yourself.\n\n=item NOECHO\n\nCommand so make does not print the literal commands it's running.\n\nBy setting it to an empty string you can generate a Makefile that\nprints all commands. Mainly used in debugging MakeMaker itself.\n\nDefaults to C<@>.\n\n=item NORECURS\n\nBoolean.  Attribute to inhibit descending into subdirectories.\n\n=item NO_META\n\nWhen true, suppresses the generation and addition to the MANIFEST of\nthe META.yml and META.json module meta-data files during 'make distdir'.\n\nDefaults to false.\n\n=item NO_MYMETA\n\nWhen true, suppresses the generation of MYMETA.yml and MYMETA.json module\nmeta-data files during 'perl Makefile.PL'.\n\nDefaults to false.\n\n=item NO_PACKLIST\n\nWhen true, suppresses the writing of C<packlist> files for installs.\n\nDefaults to false.\n\n=item NO_PERLLOCAL\n\nWhen true, suppresses the appending of installations to C<perllocal>.\n\nDefaults to false.\n\n=item NO_VC\n\nIn general, any generated Makefile checks for the current version of\nMakeMaker and the version the Makefile was built under. If NO_VC is\nset, the version check is neglected. Do not write this into your\nMakefile.PL, use it interactively instead.\n\n=item OBJECT\n\nList of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long\nstring or an array containing all object files, e.g. \"tkpBind.o\ntkpButton.o tkpCanvas.o\" or [\"tkpBind.o\", \"tkpButton.o\", \"tkpCanvas.o\"]\n\n(Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)\n\n=item OPTIMIZE\n\nDefaults to C<-O>. Set it to C<-g> to turn debugging on. The flag is\npassed to subdirectory makes.\n\n=item PERL\n\nPerl binary for tasks that can be done by miniperl. If it contains\nspaces or other shell metacharacters, it needs to be quoted in a way\nthat protects them, since this value is intended to be inserted in a\nshell command line in the Makefile. E.g.:\n\n  # Perl executable lives in \"C:/Program Files/Perl/bin\"\n  # Normally you don't need to set this yourself!\n  $ perl Makefile.PL PERL='\"C:/Program Files/Perl/bin/perl.exe\" -w'\n\n=item PERL_CORE\n\nSet only when MakeMaker is building the extensions of the Perl core\ndistribution.\n\n=item PERLMAINCC\n\nThe call to the program that is able to compile perlmain.c. Defaults\nto $(CC).\n\n=item PERL_ARCHLIB\n\nSame as for PERL_LIB, but for architecture dependent files.\n\nUsed only when MakeMaker is building the extensions of the Perl core\ndistribution (because normally $(PERL_ARCHLIB) is automatically in @INC,\nand adding it would get in the way of PERL5LIB).\n\n=item PERL_LIB\n\nDirectory containing the Perl library to use.\n\nUsed only when MakeMaker is building the extensions of the Perl core\ndistribution (because normally $(PERL_LIB) is automatically in @INC,\nand adding it would get in the way of PERL5LIB).\n\n=item PERL_MALLOC_OK\n\ndefaults to 0.  Should be set to TRUE if the extension can work with\nthe memory allocation routines substituted by the Perl malloc() subsystem.\nThis should be applicable to most extensions with exceptions of those\n\n=over 4\n\n=item *\n\nwith bugs in memory allocations which are caught by Perl's malloc();\n\n=item *\n\nwhich interact with the memory allocator in other ways than via\nmalloc(), realloc(), free(), calloc(), sbrk() and brk();\n\n=item *\n\nwhich rely on special alignment which is not provided by Perl's malloc().\n\n=back\n\nB<NOTE.>  Neglecting to set this flag in I<any one> of the loaded extension\nnullifies many advantages of Perl's malloc(), such as better usage of\nsystem resources, error detection, memory usage reporting, catchable failure\nof memory allocations, etc.\n\n=item PERLPREFIX\n\nDirectory under which core modules are to be installed.\n\nDefaults to $Config{installprefixexp}, falling back to\n$Config{installprefix}, $Config{prefixexp} or $Config{prefix} should\n$Config{installprefixexp} not exist.\n\nOverridden by PREFIX.\n\n=item PERLRUN\n\nUse this instead of $(PERL) when you wish to run perl.  It will set up\nextra necessary flags for you.\n\n=item PERLRUNINST\n\nUse this instead of $(PERL) when you wish to run perl to work with\nmodules.  It will add things like -I$(INST_ARCH) and other necessary\nflags so perl can see the modules you're about to install.\n\n=item PERL_SRC\n\nDirectory containing the Perl source code (use of this should be\navoided, it may be undefined)\n\n=item PERM_DIR\n\nDesired permission for directories. Defaults to C<755>.\n\n=item PERM_RW\n\nDesired permission for read/writable files. Defaults to C<644>.\n\n=item PERM_RWX\n\nDesired permission for executable files. Defaults to C<755>.\n\n=item PL_FILES\n\nMakeMaker can run programs to generate files for you at build time.\nBy default any file named *.PL (except Makefile.PL and Build.PL) in\nthe top level directory will be assumed to be a Perl program and run\npassing its own basename in as an argument.  This basename is actually a build\ntarget, and there is an intention, but not a requirement, that the *.PL file\nmake the file passed to to as an argument. For example...\n\n    perl foo.PL foo\n\nThis behavior can be overridden by supplying your own set of files to\nsearch.  PL_FILES accepts a hash ref, the key being the file to run\nand the value is passed in as the first argument when the PL file is run.\n\n    PL_FILES => {'bin/foobar.PL' => 'bin/foobar'}\n\n    PL_FILES => {'foo.PL' => 'foo.c'}\n\nWould run bin/foobar.PL like this:\n\n    perl bin/foobar.PL bin/foobar\n\nIf multiple files from one program are desired an array ref can be used.\n\n    PL_FILES => {'bin/foobar.PL' => [qw(bin/foobar1 bin/foobar2)]}\n\nIn this case the program will be run multiple times using each target file.\n\n    perl bin/foobar.PL bin/foobar1\n    perl bin/foobar.PL bin/foobar2\n\nPL files are normally run B<after> pm_to_blib and include INST_LIB and\nINST_ARCH in their C<@INC>, so the just built modules can be\naccessed... unless the PL file is making a module (or anything else in\nPM) in which case it is run B<before> pm_to_blib and does not include\nINST_LIB and INST_ARCH in its C<@INC>.  This apparently odd behavior\nis there for backwards compatibility (and it's somewhat DWIM).  The argument\npassed to the .PL is set up as a target to build in the Makefile.  In other\nsections such as C<postamble> you can specify a dependency on the\nfilename/argument that the .PL is supposed (or will have, now that that is\nis a dependency) to generate.  Note the file to be generated will still be\ngenerated and the .PL will still run even without an explicit dependency created\nby you, since the C<all> target still depends on running all eligible to run.PL\nfiles.\n\n=item PM\n\nHashref of .pm files and *.pl files to be installed.  e.g.\n\n  {'name_of_file.pm' => '$(INST_LIB)/install_as.pm'}\n\nBy default this will include *.pm and *.pl and the files found in\nthe PMLIBDIRS directories.  Defining PM in the\nMakefile.PL will override PMLIBDIRS.\n\n=item PMLIBDIRS\n\nRef to array of subdirectories containing library files.  Defaults to\n[ 'lib', $(BASEEXT) ]. The directories will be scanned and I<any> files\nthey contain will be installed in the corresponding location in the\nlibrary.  A libscan() method can be used to alter the behaviour.\nDefining PM in the Makefile.PL will override PMLIBDIRS.\n\n(Where BASEEXT is the last component of NAME.)\n\n=item PM_FILTER\n\nA filter program, in the traditional Unix sense (input from stdin, output\nto stdout) that is passed on each .pm file during the build (in the\npm_to_blib() phase).  It is empty by default, meaning no filtering is done.\nYou could use:\n\n  PM_FILTER => 'perl -ne \"print unless /^\\\\#/\"',\n\nto remove all the leading comments on the fly during the build.  In order\nto be as portable as possible, please consider using a Perl one-liner\nrather than Unix (or other) utilities, as above.  The # is escaped for\nthe Makefile, since what is going to be generated will then be:\n\n  PM_FILTER = perl -ne \"print unless /^\\#/\"\n\nWithout the \\ before the #, we'd have the start of a Makefile comment,\nand the macro would be incorrectly defined.\n\nYou will almost certainly be better off using the C<PL_FILES> system,\ninstead. See above, or the L<ExtUtils::MakeMaker::FAQ> entry.\n\n=item POLLUTE\n\nRelease 5.005 grandfathered old global symbol names by providing preprocessor\nmacros for extension source compatibility.  As of release 5.6, these\npreprocessor definitions are not available by default.  The POLLUTE flag\nspecifies that the old names should still be defined:\n\n  perl Makefile.PL POLLUTE=1\n\nPlease inform the module author if this is necessary to successfully install\na module under 5.6 or later.\n\n=item PPM_INSTALL_EXEC\n\nName of the executable used to run C<PPM_INSTALL_SCRIPT> below. (e.g. perl)\n\n=item PPM_INSTALL_SCRIPT\n\nName of the script that gets executed by the Perl Package Manager after\nthe installation of a package.\n\n=item PPM_UNINSTALL_EXEC\n\nName of the executable used to run C<PPM_UNINSTALL_SCRIPT> below. (e.g. perl)\n\n=item PPM_UNINSTALL_SCRIPT\n\nName of the script that gets executed by the Perl Package Manager before\nthe removal of a package.\n\n=item PREFIX\n\nThis overrides all the default install locations.  Man pages,\nlibraries, scripts, etc...  MakeMaker will try to make an educated\nguess about where to place things under the new PREFIX based on your\nConfig defaults.  Failing that, it will fall back to a structure\nwhich should be sensible for your platform.\n\nIf you specify LIB or any INSTALL* variables they will not be affected\nby the PREFIX.\n\n=item PREREQ_FATAL\n\nBool. If this parameter is true, failing to have the required modules\n(or the right versions thereof) will be fatal. C<perl Makefile.PL>\nwill C<die> instead of simply informing the user of the missing dependencies.\n\nIt is I<extremely> rare to have to use C<PREREQ_FATAL>. Its use by module\nauthors is I<strongly discouraged> and should never be used lightly.\n\nFor dependencies that are required in order to run C<Makefile.PL>,\nsee C<CONFIGURE_REQUIRES>.\n\nModule installation tools have ways of resolving unmet dependencies but\nto do that they need a F<Makefile>.  Using C<PREREQ_FATAL> breaks this.\nThat's bad.\n\nAssuming you have good test coverage, your tests should fail with\nmissing dependencies informing the user more strongly that something\nis wrong.  You can write a F<t/00compile.t> test which will simply\ncheck that your code compiles and stop \"make test\" prematurely if it\ndoesn't.  See L<Test::More/BAIL_OUT> for more details.\n\n\n=item PREREQ_PM\n\nA hash of modules that are needed to run your module.  The keys are\nthe module names ie. Test::More, and the minimum version is the\nvalue. If the required version number is 0 any version will do.\nThe versions given may be a Perl v-string (see L<version>) or a range\n(see L<CPAN::Meta::Requirements>).\n\nThis will go into the C<requires> field of your F<META.yml> and the\nC<runtime> of the C<prereqs> field of your F<META.json>.\n\n    PREREQ_PM => {\n        # Require Test::More at least 0.47\n        \"Test::More\" => \"0.47\",\n\n        # Require any version of Acme::Buffy\n        \"Acme::Buffy\" => 0,\n    }\n\n=item PREREQ_PRINT\n\nBool.  If this parameter is true, the prerequisites will be printed to\nstdout and MakeMaker will exit.  The output format is an evalable hash\nref.\n\n  $PREREQ_PM = {\n                 'A::B' => Vers1,\n                 'C::D' => Vers2,\n                 ...\n               };\n\nIf a distribution defines a minimal required perl version, this is\nadded to the output as an additional line of the form:\n\n  $MIN_PERL_VERSION = '5.008001';\n\nIf BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.\n\n=item PRINT_PREREQ\n\nRedHatism for C<PREREQ_PRINT>.  The output format is different, though:\n\n    perl(A::B)>=Vers1 perl(C::D)>=Vers2 ...\n\nA minimal required perl version, if present, will look like this:\n\n    perl(perl)>=5.008001\n\n=item SITEPREFIX\n\nLike PERLPREFIX, but only for the site install locations.\n\nDefaults to $Config{siteprefixexp}.  Perls prior to 5.6.0 didn't have\nan explicit siteprefix in the Config.  In those cases\n$Config{installprefix} will be used.\n\nOverridable by PREFIX\n\n=item SIGN\n\nWhen true, perform the generation and addition to the MANIFEST of the\nSIGNATURE file in the distdir during 'make distdir', via 'cpansign\n-s'.\n\nNote that you need to install the Module::Signature module to\nperform this operation.\n\nDefaults to false.\n\n=item SKIP\n\nArrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the\nMakefile. Caution! Do not use the SKIP attribute for the negligible\nspeedup. It may seriously damage the resulting Makefile. Only use it\nif you really need it.\n\n=item TEST_REQUIRES\n\nAvailable in version 6.64 and above.\n\nA hash of modules that are needed to test your module but not run or\nbuild it.\n\nThis will go into the C<build_requires> field of your F<META.yml> and the C<test> of the C<prereqs> field of your F<META.json>.\n\nThe format is the same as PREREQ_PM.\n\n=item TYPEMAPS\n\nRef to array of typemap file names.  Use this when the typemaps are\nin some directory other than the current directory or when they are\nnot named B<typemap>.  The last typemap in the list takes\nprecedence.  A typemap in the current directory has highest\nprecedence, even if it isn't listed in TYPEMAPS.  The default system\ntypemap has lowest precedence.\n\n=item VENDORPREFIX\n\nLike PERLPREFIX, but only for the vendor install locations.\n\nDefaults to $Config{vendorprefixexp}.\n\nOverridable by PREFIX\n\n=item VERBINST\n\nIf true, make install will be verbose\n\n=item VERSION\n\nYour version number for distributing the package.  This defaults to\n0.1.\n\n=item VERSION_FROM\n\nInstead of specifying the VERSION in the Makefile.PL you can let\nMakeMaker parse a file to determine the version number. The parsing\nroutine requires that the file named by VERSION_FROM contains one\nsingle line to compute the version number. The first line in the file\nthat contains something like a $VERSION assignment or C<package Name\nVERSION> will be used. The following lines will be parsed o.k.:\n\n    # Good\n    package Foo::Bar 1.23;                      # 1.23\n    $VERSION   = '1.00';                        # 1.00\n    *VERSION   = \\'1.01';                       # 1.01\n    ($VERSION) = q$Revision$ =~ /(\\d+)/g;       # The digits in $Revision$\n    $FOO::VERSION = '1.10';                     # 1.10\n    *FOO::VERSION = \\'1.11';                    # 1.11\n\nbut these will fail:\n\n    # Bad\n    my $VERSION         = '1.01';\n    local $VERSION      = '1.02';\n    local $FOO::VERSION = '1.30';\n\n(Putting C<my> or C<local> on the preceding line will work o.k.)\n\n\"Version strings\" are incompatible and should not be used.\n\n    # Bad\n    $VERSION = 1.2.3;\n    $VERSION = v1.2.3;\n\nL<version> objects are fine.  As of MakeMaker 6.35 version.pm will be\nautomatically loaded, but you must declare the dependency on version.pm.\nFor compatibility with older MakeMaker you should load on the same line\nas $VERSION is declared.\n\n    # All on one line\n    use version; our $VERSION = qv(1.2.3);\n\nThe file named in VERSION_FROM is not added as a dependency to\nMakefile. This is not really correct, but it would be a major pain\nduring development to have to rewrite the Makefile for any smallish\nchange in that file. If you want to make sure that the Makefile\ncontains the correct VERSION macro after any change of the file, you\nwould have to do something like\n\n    depend => { Makefile => '$(VERSION_FROM)' }\n\nSee attribute C<depend> below.\n\n=item VERSION_SYM\n\nA sanitized VERSION with . replaced by _.  For places where . has\nspecial meaning (some filesystems, RCS labels, etc...)\n\n=item XS\n\nHashref of .xs files. MakeMaker will default this.  e.g.\n\n  {'name_of_file.xs' => 'name_of_file.c'}\n\nThe .c files will automatically be included in the list of files\ndeleted by a make clean.\n\n=item XSBUILD\n\nHashref with options controlling the operation of C<XSMULTI>:\n\n  {\n    xs => {\n        all => {\n            # options applying to all .xs files for this distribution\n        },\n        'lib/Class/Name/File' => { # specifically for this file\n            DEFINE => '-Dfunktastic', # defines for only this file\n            INC => \"-I$funkyliblocation\", # include flags for only this file\n            # OBJECT => 'lib/Class/Name/File$(OBJ_EXT)', # default\n            LDFROM => \"lib/Class/Name/File\\$(OBJ_EXT) $otherfile\\$(OBJ_EXT)\", # what's linked\n        },\n    },\n  }\n\nNote C<xs> is the file-extension. More possibilities may arise in the\nfuture. Note that object names are specified without their XS extension.\n\nC<LDFROM> defaults to the same as C<OBJECT>. C<OBJECT> defaults to,\nfor C<XSMULTI>, just the XS filename with the extension replaced with\nthe compiler-specific object-file extension.\n\nThe distinction between C<OBJECT> and C<LDFROM>: C<OBJECT> is the make\ntarget, so make will try to build it. However, C<LDFROM> is what will\nactually be linked together to make the shared object or static library\n(SO/SL), so if you override it, make sure it includes what you want to\nmake the final SO/SL, almost certainly including the XS basename with\nC<$(OBJ_EXT)> appended.\n\n=item XSMULTI\n\nWhen this is set to C<1>, multiple XS files may be placed under F<lib/>\nnext to their corresponding C<*.pm> files (this is essential for compiling\nwith the correct C<VERSION> values). This feature should be considered\nexperimental, and details of it may change.\n\nThis feature was inspired by, and small portions of code copied from,\nL<ExtUtils::MakeMaker::BigHelper>. Hopefully this feature will render\nthat module mainly obsolete.\n\n=item XSOPT\n\nString of options to pass to xsubpp.  This might include C<-C++> or\nC<-extern>.  Do not include typemaps here; the TYPEMAP parameter exists for\nthat purpose.\n\n=item XSPROTOARG\n\nMay be set to C<-protoypes>, C<-noprototypes> or the empty string.  The\nempty string is equivalent to the xsubpp default, or C<-noprototypes>.\nSee the xsubpp documentation for details.  MakeMaker\ndefaults to the empty string.\n\n=item XS_VERSION\n\nYour version number for the .xs file of this package.  This defaults\nto the value of the VERSION attribute.\n\n=back\n\n=head2 Additional lowercase attributes\n\ncan be used to pass parameters to the methods which implement that\npart of the Makefile.  Parameters are specified as a hash ref but are\npassed to the method as a hash.\n\n=over 2\n\n=item clean\n\n  {FILES => \"*.xyz foo\"}\n\n=item depend\n\n  {ANY_TARGET => ANY_DEPENDENCY, ...}\n\n(ANY_TARGET must not be given a double-colon rule by MakeMaker.)\n\n=item dist\n\n  {TARFLAGS => 'cvfF', COMPRESS => 'gzip', SUFFIX => '.gz',\n  SHAR => 'shar -m', DIST_CP => 'ln', ZIP => '/bin/zip',\n  ZIPFLAGS => '-rl', DIST_DEFAULT => 'private tardist' }\n\nIf you specify COMPRESS, then SUFFIX should also be altered, as it is\nneeded to tell make the target file of the compression. Setting\nDIST_CP to ln can be useful, if you need to preserve the timestamps on\nyour files. DIST_CP can take the values 'cp', which copies the file,\n'ln', which links the file, and 'best' which copies symbolic links and\nlinks the rest. Default is 'best'.\n\n=item dynamic_lib\n\n  {ARMAYBE => 'ar', OTHERLDFLAGS => '...', INST_DYNAMIC_DEP => '...'}\n\n=item linkext\n\n  {LINKTYPE => 'static', 'dynamic' or ''}\n\nNB: Extensions that have nothing but *.pm files had to say\n\n  {LINKTYPE => ''}\n\nwith Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line\ncan be deleted safely. MakeMaker recognizes when there's nothing to\nbe linked.\n\n=item macro\n\n  {ANY_MACRO => ANY_VALUE, ...}\n\n=item postamble\n\nAnything put here will be passed to MY::postamble() if you have one.\n\n=item realclean\n\n  {FILES => '$(INST_ARCHAUTODIR)/*.xyz'}\n\n=item test\n\nSpecify the targets for testing.\n\n  {TESTS => 't/*.t'}\n\nC<RECURSIVE_TEST_FILES> can be used to include all directories\nrecursively under C<t> that contain C<.t> files. It will be ignored if\nyou provide your own C<TESTS> attribute, defaults to false.\n\n  {RECURSIVE_TEST_FILES=>1}\n\n=item tool_autosplit\n\n  {MAXLEN => 8}\n\n=back\n\n=head2 Overriding MakeMaker Methods\n\nIf you cannot achieve the desired Makefile behaviour by specifying\nattributes you may define private subroutines in the Makefile.PL.\nEach subroutine returns the text it wishes to have written to\nthe Makefile. To override a section of the Makefile you can\neither say:\n\n        sub MY::c_o { \"new literal text\" }\n\nor you can edit the default by saying something like:\n\n        package MY; # so that \"SUPER\" works right\n        sub c_o {\n            my $inherited = shift->SUPER::c_o(@_);\n            $inherited =~ s/old text/new text/;\n            $inherited;\n        }\n\nIf you are running experiments with embedding perl as a library into\nother applications, you might find MakeMaker is not sufficient. You'd\nbetter have a look at ExtUtils::Embed which is a collection of utilities\nfor embedding.\n\nIf you still need a different solution, try to develop another\nsubroutine that fits your needs and submit the diffs to\nC<makemaker@perl.org>\n\nFor a complete description of all MakeMaker methods see\nL<ExtUtils::MM_Unix>.\n\nHere is a simple example of how to add a new target to the generated\nMakefile:\n\n    sub MY::postamble {\n        return <<'MAKE_FRAG';\n    $(MYEXTLIB): sdbm/Makefile\n            cd sdbm && $(MAKE) all\n\n    MAKE_FRAG\n    }\n\n=head2 The End Of Cargo Cult Programming\n\nWriteMakefile() now does some basic sanity checks on its parameters to\nprotect against typos and malformatted values.  This means some things\nwhich happened to work in the past will now throw warnings and\npossibly produce internal errors.\n\nSome of the most common mistakes:\n\n=over 2\n\n=item C<< MAN3PODS => ' ' >>\n\nThis is commonly used to suppress the creation of man pages.  MAN3PODS\ntakes a hash ref not a string, but the above worked by accident in old\nversions of MakeMaker.\n\nThe correct code is C<< MAN3PODS => { } >>.\n\n=back\n\n\n=head2 Hintsfile support\n\nMakeMaker.pm uses the architecture-specific information from\nConfig.pm. In addition it evaluates architecture specific hints files\nin a C<hints/> directory. The hints files are expected to be named\nlike their counterparts in C<PERL_SRC/hints>, but with an C<.pl> file\nname extension (eg. C<next_3_2.pl>). They are simply C<eval>ed by\nMakeMaker within the WriteMakefile() subroutine, and can be used to\nexecute commands as well as to include special variables. The rules\nwhich hintsfile is chosen are the same as in Configure.\n\nThe hintsfile is eval()ed immediately after the arguments given to\nWriteMakefile are stuffed into a hash reference $self but before this\nreference becomes blessed. So if you want to do the equivalent to\noverride or create an attribute you would say something like\n\n    $self->{LIBS} = ['-ldbm -lucb -lc'];\n\n=head2 Distribution Support\n\nFor authors of extensions MakeMaker provides several Makefile\ntargets. Most of the support comes from the ExtUtils::Manifest module,\nwhere additional documentation can be found.\n\n=over 4\n\n=item    make distcheck\n\nreports which files are below the build directory but not in the\nMANIFEST file and vice versa. (See ExtUtils::Manifest::fullcheck() for\ndetails)\n\n=item    make skipcheck\n\nreports which files are skipped due to the entries in the\nC<MANIFEST.SKIP> file (See ExtUtils::Manifest::skipcheck() for\ndetails)\n\n=item    make distclean\n\ndoes a realclean first and then the distcheck. Note that this is not\nneeded to build a new distribution as long as you are sure that the\nMANIFEST file is ok.\n\n=item    make veryclean\n\ndoes a realclean first and then removes backup files such as C<*~>,\nC<*.bak>, C<*.old> and C<*.orig>\n\n=item    make manifest\n\nrewrites the MANIFEST file, adding all remaining files found (See\nExtUtils::Manifest::mkmanifest() for details)\n\n=item    make distdir\n\nCopies all the files that are in the MANIFEST file to a newly created\ndirectory with the name C<$(DISTNAME)-$(VERSION)>. If that directory\nexists, it will be removed first.\n\nAdditionally, it will create META.yml and META.json module meta-data file\nin the distdir and add this to the distdir's MANIFEST.  You can shut this\nbehavior off with the NO_META flag.\n\n=item   make disttest\n\nMakes a distdir first, and runs a C<perl Makefile.PL>, a make, and\na make test in that directory.\n\n=item    make tardist\n\nFirst does a distdir. Then a command $(PREOP) which defaults to a null\ncommand, followed by $(TO_UNIX), which defaults to a null command under\nUNIX, and will convert files in distribution directory to UNIX format\notherwise. Next it runs C<tar> on that directory into a tarfile and\ndeletes the directory. Finishes with a command $(POSTOP) which\ndefaults to a null command.\n\n=item    make dist\n\nDefaults to $(DIST_DEFAULT) which in turn defaults to tardist.\n\n=item    make uutardist\n\nRuns a tardist first and uuencodes the tarfile.\n\n=item    make shdist\n\nFirst does a distdir. Then a command $(PREOP) which defaults to a null\ncommand. Next it runs C<shar> on that directory into a sharfile and\ndeletes the intermediate directory again. Finishes with a command\n$(POSTOP) which defaults to a null command.  Note: For shdist to work\nproperly a C<shar> program that can handle directories is mandatory.\n\n=item    make zipdist\n\nFirst does a distdir. Then a command $(PREOP) which defaults to a null\ncommand. Runs C<$(ZIP) $(ZIPFLAGS)> on that directory into a\nzipfile. Then deletes that directory. Finishes with a command\n$(POSTOP) which defaults to a null command.\n\n=item    make ci\n\nDoes a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.\n\n=back\n\nCustomization of the dist targets can be done by specifying a hash\nreference to the dist attribute of the WriteMakefile call. The\nfollowing parameters are recognized:\n\n    CI           ('ci -u')\n    COMPRESS     ('gzip --best')\n    POSTOP       ('@ :')\n    PREOP        ('@ :')\n    TO_UNIX      (depends on the system)\n    RCS_LABEL    ('rcs -q -Nv$(VERSION_SYM):')\n    SHAR         ('shar')\n    SUFFIX       ('.gz')\n    TAR          ('tar')\n    TARFLAGS     ('cvf')\n    ZIP          ('zip')\n    ZIPFLAGS     ('-r')\n\nAn example:\n\n    WriteMakefile(\n        ...other options...\n        dist => {\n            COMPRESS => \"bzip2\",\n            SUFFIX   => \".bz2\"\n        }\n    );\n\n\n=head2 Module Meta-Data (META and MYMETA)\n\nLong plaguing users of MakeMaker based modules has been the problem of\ngetting basic information about the module out of the sources\nI<without> running the F<Makefile.PL> and doing a bunch of messy\nheuristics on the resulting F<Makefile>.  Over the years, it has become\nstandard to keep this information in one or more CPAN Meta files\ndistributed with each distribution.\n\nThe original format of CPAN Meta files was L<YAML> and the corresponding\nfile was called F<META.yml>.  In 2010, version 2 of the L<CPAN::Meta::Spec>\nwas released, which mandates JSON format for the metadata in order to\novercome certain compatibility issues between YAML serializers and to\navoid breaking older clients unable to handle a new version of the spec.\nThe L<CPAN::Meta> library is now standard for accessing old and new-style\nMeta files.\n\nIf L<CPAN::Meta> is installed, MakeMaker will automatically generate\nF<META.json> and F<META.yml> files for you and add them to your F<MANIFEST> as\npart of the 'distdir' target (and thus the 'dist' target).  This is intended to\nseamlessly and rapidly populate CPAN with module meta-data.  If you wish to\nshut this feature off, set the C<NO_META> C<WriteMakefile()> flag to true.\n\nAt the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed\nto use the CPAN Meta format to communicate post-configuration requirements\nbetween toolchain components.  These files, F<MYMETA.json> and F<MYMETA.yml>,\nare generated when F<Makefile.PL> generates a F<Makefile> (if L<CPAN::Meta>\nis installed).  Clients like L<CPAN> or L<CPANPLUS> will read these\nfiles to see what prerequisites must be fulfilled before building or testing\nthe distribution.  If you wish to shut this feature off, set the C<NO_MYMETA>\nC<WriteMakeFile()> flag to true.\n\n=head2 Disabling an extension\n\nIf some events detected in F<Makefile.PL> imply that there is no way\nto create the Module, but this is a normal state of things, then you\ncan create a F<Makefile> which does nothing, but succeeds on all the\n\"usual\" build targets.  To do so, use\n\n    use ExtUtils::MakeMaker qw(WriteEmptyMakefile);\n    WriteEmptyMakefile();\n\ninstead of WriteMakefile().\n\nThis may be useful if other modules expect this module to be I<built>\nOK, as opposed to I<work> OK (say, this system-dependent module builds\nin a subdirectory of some other distribution, or is listed as a\ndependency in a CPAN::Bundle, but the functionality is supported by\ndifferent means on the current architecture).\n\n=head2 Other Handy Functions\n\n=over 4\n\n=item prompt\n\n    my $value = prompt($message);\n    my $value = prompt($message, $default);\n\nThe C<prompt()> function provides an easy way to request user input\nused to write a makefile.  It displays the $message as a prompt for\ninput.  If a $default is provided it will be used as a default.  The\nfunction returns the $value selected by the user.\n\nIf C<prompt()> detects that it is not running interactively and there\nis nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable\nis set to true, the $default will be used without prompting.  This\nprevents automated processes from blocking on user input.\n\nIf no $default is provided an empty string will be used instead.\n\n=back\n\n=head2 Supported versions of Perl\n\nPlease note that while this module works on Perl 5.6, it is no longer\nbeing routinely tested on 5.6 - the earliest Perl version being routinely\ntested, and expressly supported, is 5.8.1. However, patches to repair\nany breakage on 5.6 are still being accepted.\n\n=head1 ENVIRONMENT\n\n=over 4\n\n=item PERL_MM_OPT\n\nCommand line options used by C<MakeMaker-E<gt>new()>, and thus by\nC<WriteMakefile()>.  The string is split as the shell would, and the result\nis processed before any actual command line arguments are processed.\n\n  PERL_MM_OPT='CCFLAGS=\"-Wl,-rpath -Wl,/foo/bar/lib\" LIBS=\"-lwibble -lwobble\"'\n\n=item PERL_MM_USE_DEFAULT\n\nIf set to a true value then MakeMaker's prompt function will\nalways return the default without waiting for user input.\n\n=item PERL_CORE\n\nSame as the PERL_CORE parameter.  The parameter overrides this.\n\n=back\n\n=head1 SEE ALSO\n\nL<Module::Build> is a pure-Perl alternative to MakeMaker which does\nnot rely on make or any other external utility.  It is easier to\nextend to suit your needs.\n\nL<Module::Install> is a wrapper around MakeMaker which adds features\nnot normally available.\n\nL<ExtUtils::ModuleMaker> and L<Module::Starter> are both modules to\nhelp you setup your distribution.\n\nL<CPAN::Meta> and L<CPAN::Meta::Spec> explain CPAN Meta files in detail.\n\nL<File::ShareDir::Install> makes it easy to install static, sometimes\nalso referred to as 'shared' files. L<File::ShareDir> helps accessing\nthe shared files after installation.\n\nL<Dist::Zilla> makes it easy for the module author to create MakeMaker-based\ndistributions with lots of bells and whistles.\n\n=head1 AUTHORS\n\nAndy Dougherty C<doughera@lafayette.edu>, Andreas KE<ouml>nig\nC<andreas.koenig@mind.de>, Tim Bunce C<timb@cpan.org>.  VMS\nsupport by Charles Bailey C<bailey@newman.upenn.edu>.  OS/2 support\nby Ilya Zakharevich C<ilya@math.ohio-state.edu>.\n\nCurrently maintained by Michael G Schwern C<schwern@pobox.com>\n\nSend patches and ideas to C<makemaker@perl.org>.\n\nSend bug reports via http://rt.cpan.org/.  Please send your\ngenerated Makefile along with your report.\n\nFor more up-to-date information, see L<https://metacpan.org/release/ExtUtils-MakeMaker>.\n\nRepository available at L<https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker>.\n\n=head1 LICENSE\n\nThis program is free software; you can redistribute it and/or\nmodify it under the same terms as Perl itself.\n\nSee L<http://www.perl.com/perl/misc/Artistic.html>\n\n\n=cut\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_Any.pm": "package ExtUtils::MM_Any;\n\nuse strict;\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\nuse Carp;\nuse File::Spec;\nuse File::Basename;\nBEGIN { our @ISA = qw(File::Spec); }\n\n# We need $Verbose\nuse ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);\n\nuse ExtUtils::MakeMaker::Config;\n\n\n# So we don't have to keep calling the methods over and over again,\n# we have these globals to cache the values.  Faster and shrtr.\nmy $Curdir  = __PACKAGE__->curdir;\n#my $Updir   = __PACKAGE__->updir;\n\nmy $METASPEC_URL = 'https://metacpan.org/pod/CPAN::Meta::Spec';\nmy $METASPEC_V = 2;\n\n=head1 NAME\n\nExtUtils::MM_Any - Platform-agnostic MM methods\n\n=head1 SYNOPSIS\n\n  FOR INTERNAL USE ONLY!\n\n  package ExtUtils::MM_SomeOS;\n\n  # Temporarily, you have to subclass both.  Put MM_Any first.\n  require ExtUtils::MM_Any;\n  require ExtUtils::MM_Unix;\n  @ISA = qw(ExtUtils::MM_Any ExtUtils::Unix);\n\n=head1 DESCRIPTION\n\nB<FOR INTERNAL USE ONLY!>\n\nExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of\nmodules.  It contains methods which are either inherently\ncross-platform or are written in a cross-platform manner.\n\nSubclass off of ExtUtils::MM_Any I<and> ExtUtils::MM_Unix.  This is a\ntemporary solution.\n\nB<THIS MAY BE TEMPORARY!>\n\n\n=head1 METHODS\n\nAny methods marked I<Abstract> must be implemented by subclasses.\n\n\n=head2 Cross-platform helper methods\n\nThese are methods which help writing cross-platform code.\n\n\n\n=head3 os_flavor  I<Abstract>\n\n    my @os_flavor = $mm->os_flavor;\n\n@os_flavor is the style of operating system this is, usually\ncorresponding to the MM_*.pm file we're using.\n\nThe first element of @os_flavor is the major family (ie. Unix,\nWindows, VMS, OS/2, etc...) and the rest are sub families.\n\nSome examples:\n\n    Cygwin98       ('Unix',  'Cygwin', 'Cygwin9x')\n    Windows        ('Win32')\n    Win98          ('Win32', 'Win9x')\n    Linux          ('Unix',  'Linux')\n    MacOS X        ('Unix',  'Darwin', 'MacOS', 'MacOS X')\n    OS/2           ('OS/2')\n\nThis is used to write code for styles of operating system.\nSee os_flavor_is() for use.\n\n\n=head3 os_flavor_is\n\n    my $is_this_flavor = $mm->os_flavor_is($this_flavor);\n    my $is_this_flavor = $mm->os_flavor_is(@one_of_these_flavors);\n\nChecks to see if the current operating system is one of the given flavors.\n\nThis is useful for code like:\n\n    if( $mm->os_flavor_is('Unix') ) {\n        $out = `foo 2>&1`;\n    }\n    else {\n        $out = `foo`;\n    }\n\n=cut\n\nsub os_flavor_is {\n    my $self = shift;\n    my %flavors = map { ($_ => 1) } $self->os_flavor;\n    return (grep { $flavors{$_} } @_) ? 1 : 0;\n}\n\n\n=head3 can_load_xs\n\n    my $can_load_xs = $self->can_load_xs;\n\nReturns true if we have the ability to load XS.\n\nThis is important because miniperl, used to build XS modules in the\ncore, can not load XS.\n\n=cut\n\nsub can_load_xs {\n    return defined &DynaLoader::boot_DynaLoader ? 1 : 0;\n}\n\n\n=head3 can_run\n\n  use ExtUtils::MM;\n  my $runnable = MM->can_run($Config{make});\n\nIf called in a scalar context it will return the full path to the binary\nyou asked for if it was found, or C<undef> if it was not.\n\nIf called in a list context, it will return a list of the full paths to instances\nof the binary where found in C<PATH>, or an empty list if it was not found.\n\nCopied from L<IPC::Cmd|IPC::Cmd/\"$path = can_run( PROGRAM );\">, but modified into\na method (and removed C<$INSTANCES> capability).\n\n=cut\n\nsub can_run {\n    my ($self, $command) = @_;\n\n    # a lot of VMS executables have a symbol defined\n    # check those first\n    if ( $^O eq 'VMS' ) {\n        require VMS::DCLsym;\n        my $syms = VMS::DCLsym->new;\n        return $command if scalar $syms->getsym( uc $command );\n    }\n\n    my @possibles;\n\n    if( File::Spec->file_name_is_absolute($command) ) {\n        return $self->maybe_command($command);\n\n    } else {\n        for my $dir (\n            File::Spec->path,\n            File::Spec->curdir\n        ) {\n            next if ! $dir || ! -d $dir;\n            my $abs = File::Spec->catfile($self->os_flavor_is('Win32') ? Win32::GetShortPathName( $dir ) : $dir, $command);\n            push @possibles, $abs if $abs = $self->maybe_command($abs);\n        }\n    }\n    return @possibles if wantarray;\n    return shift @possibles;\n}\n\n\n=head3 can_redirect_error\n\n  $useredirect = MM->can_redirect_error;\n\nTrue if on an OS where qx operator (or backticks) can redirect C<STDERR>\nonto C<STDOUT>.\n\n=cut\n\nsub can_redirect_error {\n  my $self = shift;\n  $self->os_flavor_is('Unix')\n      or ($self->os_flavor_is('Win32') and !$self->os_flavor_is('Win9x'))\n      or $self->os_flavor_is('OS/2')\n}\n\n\n=head3 is_make_type\n\n    my $is_dmake = $self->is_make_type('dmake');\n\nReturns true if C<<$self->make>> is the given type; possibilities are:\n\n  gmake    GNU make\n  dmake\n  nmake\n  bsdmake  BSD pmake-derived\n\n=cut\n\nmy %maketype2true;\n# undocumented - so t/cd.t can still do its thing\nsub _clear_maketype_cache { %maketype2true = () }\n\nsub is_make_type {\n    my($self, $type) = @_;\n    return $maketype2true{$type} if defined $maketype2true{$type};\n    (undef, undef, my $make_basename) = $self->splitpath($self->make);\n    return $maketype2true{$type} = 1\n        if $make_basename =~ /\\b$type\\b/i; # executable's filename\n    return $maketype2true{$type} = 0\n        if $make_basename =~ /\\b[gdn]make\\b/i; # Never fall through for dmake/nmake/gmake\n    # now have to run with \"-v\" and guess\n    my $redirect = $self->can_redirect_error ? '2>&1' : '';\n    my $make = $self->make || $self->{MAKE};\n    my $minus_v = `\"$make\" -v $redirect`;\n    return $maketype2true{$type} = 1\n        if $type eq 'gmake' and $minus_v =~ /GNU make/i;\n    return $maketype2true{$type} = 1\n        if $type eq 'bsdmake'\n      and $minus_v =~ /^usage: make \\[-BeikNnqrstWwX\\]/im;\n    $maketype2true{$type} = 0; # it wasn't whatever you asked\n}\n\n\n=head3 can_dep_space\n\n    my $can_dep_space = $self->can_dep_space;\n\nReturns true if C<make> can handle (probably by quoting)\ndependencies that contain a space. Currently known true for GNU make,\nfalse for BSD pmake derivative.\n\n=cut\n\nmy $cached_dep_space;\nsub can_dep_space {\n    my $self = shift;\n    return $cached_dep_space if defined $cached_dep_space;\n    return $cached_dep_space = 1 if $self->is_make_type('gmake');\n    return $cached_dep_space = 0 if $self->is_make_type('dmake'); # only on W32\n    return $cached_dep_space = 0 if $self->is_make_type('bsdmake');\n    return $cached_dep_space = 0; # assume no\n}\n\n\n=head3 quote_dep\n\n  $text = $mm->quote_dep($text);\n\nMethod that protects Makefile single-value constants (mainly filenames),\nso that make will still treat them as single values even if they\ninconveniently have spaces in. If the make program being used cannot\nachieve such protection and the given text would need it, throws an\nexception.\n\n=cut\n\nsub quote_dep {\n    my ($self, $arg) = @_;\n    die <<EOF if $arg =~ / / and not $self->can_dep_space;\nTried to use make dependency with space for make that can't:\n  '$arg'\nEOF\n    $arg =~ s/( )/\\\\$1/g; # how GNU make does it\n    return $arg;\n}\n\n\n=head3 split_command\n\n    my @cmds = $MM->split_command($cmd, @args);\n\nMost OS have a maximum command length they can execute at once.  Large\nmodules can easily generate commands well past that limit.  Its\nnecessary to split long commands up into a series of shorter commands.\n\nC<split_command> will return a series of @cmds each processing part of\nthe args.  Collectively they will process all the arguments.  Each\nindividual line in @cmds will not be longer than the\n$self->max_exec_len being careful to take into account macro expansion.\n\n$cmd should include any switches and repeated initial arguments.\n\nIf no @args are given, no @cmds will be returned.\n\nPairs of arguments will always be preserved in a single command, this\nis a heuristic for things like pm_to_blib and pod2man which work on\npairs of arguments.  This makes things like this safe:\n\n    $self->split_command($cmd, %pod2man);\n\n\n=cut\n\nsub split_command {\n    my($self, $cmd, @args) = @_;\n\n    my @cmds = ();\n    return(@cmds) unless @args;\n\n    # If the command was given as a here-doc, there's probably a trailing\n    # newline.\n    chomp $cmd;\n\n    # set aside 30% for macro expansion.\n    my $len_left = int($self->max_exec_len * 0.70);\n    $len_left -= length $self->_expand_macros($cmd);\n\n    do {\n        my $arg_str = '';\n        my @next_args;\n        while( @next_args = splice(@args, 0, 2) ) {\n            # Two at a time to preserve pairs.\n            my $next_arg_str = \"\\t  \". join ' ', @next_args, \"\\n\";\n\n            if( !length $arg_str ) {\n                $arg_str .= $next_arg_str\n            }\n            elsif( length($arg_str) + length($next_arg_str) > $len_left ) {\n                unshift @args, @next_args;\n                last;\n            }\n            else {\n                $arg_str .= $next_arg_str;\n            }\n        }\n        chop $arg_str;\n\n        push @cmds, $self->escape_newlines(\"$cmd \\n$arg_str\");\n    } while @args;\n\n    return @cmds;\n}\n\n\nsub _expand_macros {\n    my($self, $cmd) = @_;\n\n    $cmd =~ s{\\$\\((\\w+)\\)}{\n        defined $self->{$1} ? $self->{$1} : \"\\$($1)\"\n    }e;\n    return $cmd;\n}\n\n\n=head3 make_type\n\nReturns a suitable string describing the type of makefile being written.\n\n=cut\n\n# override if this isn't suitable!\nsub make_type { return 'Unix-style'; }\n\n\n=head3 stashmeta\n\n    my @recipelines = $MM->stashmeta($text, $file);\n\nGenerates a set of C<@recipelines> which will result in the literal\nC<$text> ending up in literal C<$file> when the recipe is executed. Call\nit once, with all the text you want in C<$file>. Make macros will not\nbe expanded, so the locations will be fixed at configure-time, not\nat build-time.\n\n=cut\n\nsub stashmeta {\n    my($self, $text, $file) = @_;\n    $self->echo($text, $file, { allow_variables => 0, append => 0 });\n}\n\n\n=head3 echo\n\n    my @commands = $MM->echo($text);\n    my @commands = $MM->echo($text, $file);\n    my @commands = $MM->echo($text, $file, \\%opts);\n\nGenerates a set of @commands which print the $text to a $file.\n\nIf $file is not given, output goes to STDOUT.\n\nIf $opts{append} is true the $file will be appended to rather than\noverwritten.  Default is to overwrite.\n\nIf $opts{allow_variables} is true, make variables of the form\nC<$(...)> will not be escaped.  Other C<$> will.  Default is to escape\nall C<$>.\n\nExample of use:\n\n    my $make = join '', map \"\\t$_\\n\", $MM->echo($text, $file);\n\n=cut\n\nsub echo {\n    my($self, $text, $file, $opts) = @_;\n\n    # Compatibility with old options\n    if( !ref $opts ) {\n        my $append = $opts;\n        $opts = { append => $append || 0 };\n    }\n    $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};\n\n    my $ql_opts = { allow_variables => $opts->{allow_variables} };\n    my @cmds = map { '$(NOECHO) $(ECHO) '.$self->quote_literal($_, $ql_opts) }\n               split /\\n/, $text;\n    if( $file ) {\n        my $redirect = $opts->{append} ? '>>' : '>';\n        $cmds[0] .= \" $redirect $file\";\n        $_ .= \" >> $file\" foreach @cmds[1..$#cmds];\n    }\n\n    return @cmds;\n}\n\n\n=head3 wraplist\n\n  my $args = $mm->wraplist(@list);\n\nTakes an array of items and turns them into a well-formatted list of\narguments.  In most cases this is simply something like:\n\n    FOO \\\n    BAR \\\n    BAZ\n\n=cut\n\nsub wraplist {\n    my $self = shift;\n    return join \" \\\\\\n\\t\", @_;\n}\n\n\n=head3 maketext_filter\n\n    my $filter_make_text = $mm->maketext_filter($make_text);\n\nThe text of the Makefile is run through this method before writing to\ndisk.  It allows systems a chance to make portability fixes to the\nMakefile.\n\nBy default it does nothing.\n\nThis method is protected and not intended to be called outside of\nMakeMaker.\n\n=cut\n\nsub maketext_filter { return $_[1] }\n\n\n=head3 cd  I<Abstract>\n\n  my $subdir_cmd = $MM->cd($subdir, @cmds);\n\nThis will generate a make fragment which runs the @cmds in the given\n$dir.  The rough equivalent to this, except cross platform.\n\n  cd $subdir && $cmd\n\nCurrently $dir can only go down one level.  \"foo\" is fine.  \"foo/bar\" is\nnot.  \"../foo\" is right out.\n\nThe resulting $subdir_cmd has no leading tab nor trailing newline.  This\nmakes it easier to embed in a make string.  For example.\n\n      my $make = sprintf <<'CODE', $subdir_cmd;\n  foo :\n      $(ECHO) what\n      %s\n      $(ECHO) mouche\n  CODE\n\n\n=head3 oneliner  I<Abstract>\n\n  my $oneliner = $MM->oneliner($perl_code);\n  my $oneliner = $MM->oneliner($perl_code, \\@switches);\n\nThis will generate a perl one-liner safe for the particular platform\nyou're on based on the given $perl_code and @switches (a -e is\nassumed) suitable for using in a make target.  It will use the proper\nshell quoting and escapes.\n\n$(PERLRUN) will be used as perl.\n\nAny newlines in $perl_code will be escaped.  Leading and trailing\nnewlines will be stripped.  Makes this idiom much easier:\n\n    my $code = $MM->oneliner(<<'CODE', [...switches...]);\nsome code here\nanother line here\nCODE\n\nUsage might be something like:\n\n    # an echo emulation\n    $oneliner = $MM->oneliner('print \"Foo\\n\"');\n    $make = '$oneliner > somefile';\n\nDollar signs in the $perl_code will be protected from make using the\nC<quote_literal> method, unless they are recognised as being a make\nvariable, C<$(varname)>, in which case they will be left for make\nto expand. Remember to quote make macros else it might be used as a\nbareword. For example:\n\n    # Assign the value of the $(VERSION_FROM) make macro to $vf.\n    $oneliner = $MM->oneliner('$vf = \"$(VERSION_FROM)\"');\n\nIts currently very simple and may be expanded sometime in the figure\nto include more flexible code and switches.\n\n\n=head3 quote_literal  I<Abstract>\n\n    my $safe_text = $MM->quote_literal($text);\n    my $safe_text = $MM->quote_literal($text, \\%options);\n\nThis will quote $text so it is interpreted literally in the shell.\n\nFor example, on Unix this would escape any single-quotes in $text and\nput single-quotes around the whole thing.\n\nIf $options{allow_variables} is true it will leave C<'$(FOO)'> make\nvariables untouched.  If false they will be escaped like any other\nC<$>.  Defaults to true.\n\n=head3 escape_dollarsigns\n\n    my $escaped_text = $MM->escape_dollarsigns($text);\n\nEscapes stray C<$> so they are not interpreted as make variables.\n\nIt lets by C<$(...)>.\n\n=cut\n\nsub escape_dollarsigns {\n    my($self, $text) = @_;\n\n    # Escape dollar signs which are not starting a variable\n    $text =~ s{\\$ (?!\\() }{\\$\\$}gx;\n\n    return $text;\n}\n\n\n=head3 escape_all_dollarsigns\n\n    my $escaped_text = $MM->escape_all_dollarsigns($text);\n\nEscapes all C<$> so they are not interpreted as make variables.\n\n=cut\n\nsub escape_all_dollarsigns {\n    my($self, $text) = @_;\n\n    # Escape dollar signs\n    $text =~ s{\\$}{\\$\\$}gx;\n\n    return $text;\n}\n\n\n=head3 escape_newlines  I<Abstract>\n\n    my $escaped_text = $MM->escape_newlines($text);\n\nShell escapes newlines in $text.\n\n\n=head3 max_exec_len  I<Abstract>\n\n    my $max_exec_len = $MM->max_exec_len;\n\nCalculates the maximum command size the OS can exec.  Effectively,\nthis is the max size of a shell command line.\n\n=for _private\n$self->{_MAX_EXEC_LEN} is set by this method, but only for testing purposes.\n\n\n=head3 make\n\n    my $make = $MM->make;\n\nReturns the make variant we're generating the Makefile for.  This attempts\nto do some normalization on the information from %Config or the user.\n\n=cut\n\nsub make {\n    my $self = shift;\n\n    my $make = lc $self->{MAKE};\n\n    # Truncate anything like foomake6 to just foomake.\n    $make =~ s/^(\\w+make).*/$1/;\n\n    # Turn gnumake into gmake.\n    $make =~ s/^gnu/g/;\n\n    return $make;\n}\n\n\n=head2 Targets\n\nThese are methods which produce make targets.\n\n\n=head3 all_target\n\nGenerate the default target 'all'.\n\n=cut\n\nsub all_target {\n    my $self = shift;\n\n    return <<'MAKE_EXT';\nall :: pure_all\n\t$(NOECHO) $(NOOP)\nMAKE_EXT\n\n}\n\n\n=head3 blibdirs_target\n\n    my $make_frag = $mm->blibdirs_target;\n\nCreates the blibdirs target which creates all the directories we use\nin blib/.\n\nThe blibdirs.ts target is deprecated.  Depend on blibdirs instead.\n\n\n=cut\n\nsub _xs_list_basenames {\n    my ($self) = @_;\n    map { (my $b = $_) =~ s/\\.xs$//; $b } sort keys %{ $self->{XS} };\n}\n\nsub blibdirs_target {\n    my $self = shift;\n\n    my @dirs = map { uc \"\\$(INST_$_)\" } qw(libdir archlib\n                                           autodir archautodir\n                                           bin script\n                                           man1dir man3dir\n                                          );\n    if ($self->{XSMULTI}) {\n        for my $ext ($self->_xs_list_basenames) {\n            my ($v, $d, $f) = File::Spec->splitpath($ext);\n            my @d = File::Spec->splitdir($d);\n            shift @d if $d[0] eq 'lib';\n            push @dirs, $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);\n\t}\n    }\n\n    my @exists = map { $_.'$(DFSEP).exists' } @dirs;\n\n    my $make = sprintf <<'MAKE', join(' ', @exists);\nblibdirs : %s\n\t$(NOECHO) $(NOOP)\n\n# Backwards compat with 6.18 through 6.25\nblibdirs.ts : blibdirs\n\t$(NOECHO) $(NOOP)\n\nMAKE\n\n    $make .= $self->dir_target(@dirs);\n\n    return $make;\n}\n\n\n=head3 clean (o)\n\nDefines the clean target.\n\n=cut\n\nsub clean {\n# --- Cleanup and Distribution Sections ---\n\n    my($self, %attribs) = @_;\n    my @m;\n    push(@m, '\n# Delete temporary files but do not touch installed files. We don\\'t delete\n# the Makefile here so a later make realclean still has a makefile to use.\n\nclean :: clean_subdirs\n');\n\n    my @files = sort values %{$self->{XS}}; # .c files from *.xs files\n    push @files, map {\n\tmy $file = $_;\n\tmap { $file.$_ } $self->{OBJ_EXT}, qw(.def _def.old .bs .bso .exp .base);\n    } $self->_xs_list_basenames;\n    my @dirs  = qw(blib);\n\n    # Normally these are all under blib but they might have been\n    # redefined.\n    # XXX normally this would be a good idea, but the Perl core sets\n    # INST_LIB = ../../lib rather than actually installing the files.\n    # So a \"make clean\" in an ext/ directory would blow away lib.\n    # Until the core is adjusted let's leave this out.\n#     push @dirs, qw($(INST_ARCHLIB) $(INST_LIB)\n#                    $(INST_BIN) $(INST_SCRIPT)\n#                    $(INST_MAN1DIR) $(INST_MAN3DIR)\n#                    $(INST_LIBDIR) $(INST_ARCHLIBDIR) $(INST_AUTODIR)\n#                    $(INST_STATIC) $(INST_DYNAMIC)\n#                 );\n\n\n    if( $attribs{FILES} ) {\n        # Use @dirs because we don't know what's in here.\n        push @dirs, ref $attribs{FILES}                ?\n                        @{$attribs{FILES}}             :\n                        split /\\s+/, $attribs{FILES}   ;\n    }\n\n    push(@files, qw[$(MAKE_APERL_FILE)\n                    MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations\n                    blibdirs.ts pm_to_blib pm_to_blib.ts\n                    *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)\n                    $(BOOTSTRAP) $(BASEEXT).bso\n                    $(BASEEXT).def lib$(BASEEXT).def\n                    $(BASEEXT).exp $(BASEEXT).x\n                   ]);\n\n    push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));\n    push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));\n\n    # core files\n    if ($^O eq 'vos') {\n        push(@files, qw[perl*.kp]);\n    }\n    else {\n        push(@files, qw[core core.*perl.*.? *perl.core]);\n    }\n\n    push(@files, map { \"core.\" . \"[0-9]\"x$_ } (1..5));\n\n    # OS specific things to clean up.  Use @dirs since we don't know\n    # what might be in here.\n    push @dirs, $self->extra_clean_files;\n\n    # Occasionally files are repeated several times from different sources\n    { my(%f) = map { ($_ => 1) } @files; @files = sort keys %f; }\n    { my(%d) = map { ($_ => 1) } @dirs;  @dirs  = sort keys %d; }\n\n    push @m, map \"\\t$_\\n\", $self->split_command('- $(RM_F)',  @files);\n    push @m, map \"\\t$_\\n\", $self->split_command('- $(RM_RF)', @dirs);\n\n    # Leave Makefile.old around for realclean\n    push @m, <<'MAKE';\n\t  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)\n\t- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)\nMAKE\n\n    push(@m, \"\\t$attribs{POSTOP}\\n\")   if $attribs{POSTOP};\n\n    join(\"\", @m);\n}\n\n\n=head3 clean_subdirs_target\n\n  my $make_frag = $MM->clean_subdirs_target;\n\nReturns the clean_subdirs target.  This is used by the clean target to\ncall clean on any subdirectories which contain Makefiles.\n\n=cut\n\nsub clean_subdirs_target {\n    my($self) = shift;\n\n    # No subdirectories, no cleaning.\n    return <<'NOOP_FRAG' unless @{$self->{DIR}};\nclean_subdirs :\n\t$(NOECHO) $(NOOP)\nNOOP_FRAG\n\n\n    my $clean = \"clean_subdirs :\\n\";\n\n    for my $dir (@{$self->{DIR}}) {\n        my $subclean = $self->oneliner(sprintf <<'CODE', $dir);\nexit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';\nCODE\n\n        $clean .= \"\\t$subclean\\n\";\n    }\n\n    return $clean;\n}\n\n\n=head3 dir_target\n\n    my $make_frag = $mm->dir_target(@directories);\n\nGenerates targets to create the specified directories and set its\npermission to PERM_DIR.\n\nBecause depending on a directory to just ensure it exists doesn't work\ntoo well (the modified time changes too often) dir_target() creates a\n.exists file in the created directory.  It is this you should depend on.\nFor portability purposes you should use the $(DIRFILESEP) macro rather\nthan a '/' to separate the directory from the file.\n\n    yourdirectory$(DIRFILESEP).exists\n\n=cut\n\nsub dir_target {\n    my($self, @dirs) = @_;\n\n    my $make = '';\n    foreach my $dir (@dirs) {\n        $make .= sprintf <<'MAKE', ($dir) x 4;\n%s$(DFSEP).exists :: Makefile.PL\n\t$(NOECHO) $(MKPATH) %s\n\t$(NOECHO) $(CHMOD) $(PERM_DIR) %s\n\t$(NOECHO) $(TOUCH) %s$(DFSEP).exists\n\nMAKE\n\n    }\n\n    return $make;\n}\n\n\n=head3 distdir\n\nDefines the scratch directory target that will hold the distribution\nbefore tar-ing (or shar-ing).\n\n=cut\n\n# For backwards compatibility.\n*dist_dir = *distdir;\n\nsub distdir {\n    my($self) = shift;\n\n    my $meta_target = $self->{NO_META} ? '' : 'distmeta';\n    my $sign_target = !$self->{SIGN}   ? '' : 'distsignature';\n\n    return sprintf <<'MAKE_FRAG', $meta_target, $sign_target;\ncreate_distdir :\n\t$(RM_RF) $(DISTVNAME)\n\t$(PERLRUN) \"-MExtUtils::Manifest=manicopy,maniread\" \\\n\t\t-e \"manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');\"\n\ndistdir : create_distdir %s %s\n\t$(NOECHO) $(NOOP)\n\nMAKE_FRAG\n\n}\n\n\n=head3 dist_test\n\nDefines a target that produces the distribution in the\nscratch directory, and runs 'perl Makefile.PL; make ;make test' in that\nsubdirectory.\n\n=cut\n\nsub dist_test {\n    my($self) = shift;\n\n    my $mpl_args = join \" \", map qq[\"$_\"], @ARGV;\n\n    my $test = $self->cd('$(DISTVNAME)',\n                         '$(ABSPERLRUN) Makefile.PL '.$mpl_args,\n                         '$(MAKE) $(PASTHRU)',\n                         '$(MAKE) test $(PASTHRU)'\n                        );\n\n    return sprintf <<'MAKE_FRAG', $test;\ndisttest : distdir\n\t%s\n\nMAKE_FRAG\n\n\n}\n\n\n=head3 xs_dlsyms_ext\n\nReturns file-extension for C<xs_make_dlsyms> method's output file,\nincluding any \".\" character.\n\n=cut\n\nsub xs_dlsyms_ext {\n    die \"Pure virtual method\";\n}\n\n=head3 xs_dlsyms_extra\n\nReturns any extra text to be prepended to the C<$extra> argument of\nC<xs_make_dlsyms>.\n\n=cut\n\nsub xs_dlsyms_extra {\n    '';\n}\n\n=head3 xs_dlsyms_iterator\n\nIterates over necessary shared objects, calling C<xs_make_dlsyms> method\nfor each with appropriate arguments.\n\n=cut\n\nsub xs_dlsyms_iterator {\n    my ($self, $attribs) = @_;\n    if ($self->{XSMULTI}) {\n        my @m;\n        for my $ext ($self->_xs_list_basenames) {\n            my @parts = File::Spec->splitdir($ext);\n            shift @parts if $parts[0] eq 'lib';\n            my $name = join '::', @parts;\n            push @m, $self->xs_make_dlsyms(\n                $attribs,\n                $ext . $self->xs_dlsyms_ext,\n                \"$ext.xs\",\n                $name,\n                $parts[-1],\n                {}, [], {}, [],\n                $self->xs_dlsyms_extra . q!, 'FILE' => ! . neatvalue($ext),\n            );\n        }\n        return join \"\\n\", @m;\n    } else {\n        return $self->xs_make_dlsyms(\n            $attribs,\n            $self->{BASEEXT} . $self->xs_dlsyms_ext,\n            'Makefile.PL',\n            $self->{NAME},\n            $self->{DLBASE},\n            $attribs->{DL_FUNCS} || $self->{DL_FUNCS} || {},\n            $attribs->{FUNCLIST} || $self->{FUNCLIST} || [],\n            $attribs->{IMPORTS} || $self->{IMPORTS} || {},\n            $attribs->{DL_VARS} || $self->{DL_VARS} || [],\n            $self->xs_dlsyms_extra,\n        );\n    }\n}\n\n=head3 xs_make_dlsyms\n\n    $self->xs_make_dlsyms(\n        \\%attribs, # hashref from %attribs in caller\n        \"$self->{BASEEXT}.def\", # output file for Makefile target\n        'Makefile.PL', # dependency\n        $self->{NAME}, # shared object's \"name\"\n        $self->{DLBASE}, # last ::-separated part of name\n        $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {}, # various params\n        $attribs{FUNCLIST} || $self->{FUNCLIST} || [],\n        $attribs{IMPORTS} || $self->{IMPORTS} || {},\n        $attribs{DL_VARS} || $self->{DL_VARS} || [],\n        # optional extra param that will be added as param to Mksymlists\n    );\n\nUtility method that returns Makefile snippet to call C<Mksymlists>.\n\n=cut\n\nsub xs_make_dlsyms {\n    my ($self, $attribs, $target, $dep, $name, $dlbase, $funcs, $funclist, $imports, $vars, $extra) = @_;\n    my @m = (\n     \"\\n$target: $dep\\n\",\n     q!\t$(PERLRUN) -MExtUtils::Mksymlists \\\\\n     -e \"Mksymlists('NAME'=>\\\"!, $name,\n     q!\\\", 'DLBASE' => '!,$dlbase,\n     # The above two lines quoted differently to work around\n     # a bug in the 4DOS/4NT command line interpreter.  The visible\n     # result of the bug was files named q('extension_name',) *with the\n     # single quotes and the comma* in the extension build directories.\n     q!', 'DL_FUNCS' => !,neatvalue($funcs),\n     q!, 'FUNCLIST' => !,neatvalue($funclist),\n     q!, 'IMPORTS' => !,neatvalue($imports),\n     q!, 'DL_VARS' => !, neatvalue($vars)\n    );\n    push @m, $extra if defined $extra;\n    push @m, qq!);\"\\n!;\n    join '', @m;\n}\n\n=head3 dynamic (o)\n\nDefines the dynamic target.\n\n=cut\n\nsub dynamic {\n# --- Dynamic Loading Sections ---\n\n    my($self) = shift;\n    '\ndynamic :: $(FIRST_MAKEFILE) config $(INST_BOOT) $(INST_DYNAMIC)\n\t$(NOECHO) $(NOOP)\n';\n}\n\n\n=head3 makemakerdflt_target\n\n  my $make_frag = $mm->makemakerdflt_target\n\nReturns a make fragment with the makemakerdeflt_target specified.\nThis target is the first target in the Makefile, is the default target\nand simply points off to 'all' just in case any make variant gets\nconfused or something gets snuck in before the real 'all' target.\n\n=cut\n\nsub makemakerdflt_target {\n    return <<'MAKE_FRAG';\nmakemakerdflt : all\n\t$(NOECHO) $(NOOP)\nMAKE_FRAG\n\n}\n\n\n=head3 manifypods_target\n\n  my $manifypods_target = $self->manifypods_target;\n\nGenerates the manifypods target.  This target generates man pages from\nall POD files in MAN1PODS and MAN3PODS.\n\n=cut\n\nsub manifypods_target {\n    my($self) = shift;\n\n    my $man1pods      = '';\n    my $man3pods      = '';\n    my $dependencies  = '';\n\n    # populate manXpods & dependencies:\n    foreach my $name (sort keys %{$self->{MAN1PODS}}, sort keys %{$self->{MAN3PODS}}) {\n        $dependencies .= \" \\\\\\n\\t$name\";\n    }\n\n    my $manify = <<END;\nmanifypods : pure_all config $dependencies\nEND\n\n    my @man_cmds;\n    foreach my $section (qw(1 3)) {\n        my $pods = $self->{\"MAN${section}PODS\"};\n        my $p2m = sprintf <<'CMD', $section, $] > 5.008 ? \" -u\" : \"\";\n\t$(NOECHO) $(POD2MAN) --section=%s --perm_rw=$(PERM_RW)%s\nCMD\n        push @man_cmds, $self->split_command($p2m, map {($_,$pods->{$_})} sort keys %$pods);\n    }\n\n    $manify .= \"\\t\\$(NOECHO) \\$(NOOP)\\n\" unless @man_cmds;\n    $manify .= join '', map { \"$_\\n\" } @man_cmds;\n\n    return $manify;\n}\n\n{\n    my $has_cpan_meta;\n    sub _has_cpan_meta {\n        return $has_cpan_meta if defined $has_cpan_meta;\n        return $has_cpan_meta = !!eval {\n            require CPAN::Meta;\n            CPAN::Meta->VERSION(2.112150);\n            1;\n        };\n    }\n}\n\n=head3 metafile_target\n\n    my $target = $mm->metafile_target;\n\nGenerate the metafile target.\n\nWrites the file META.yml (YAML encoded meta-data) and META.json\n(JSON encoded meta-data) about the module in the distdir.\nThe format follows Module::Build's as closely as possible.\n\n=cut\n\nsub metafile_target {\n    my $self = shift;\n    return <<'MAKE_FRAG' if $self->{NO_META} or ! _has_cpan_meta();\nmetafile :\n\t$(NOECHO) $(NOOP)\nMAKE_FRAG\n\n    my $metadata   = $self->metafile_data(\n        $self->{META_ADD}   || {},\n        $self->{META_MERGE} || {},\n    );\n\n    my $meta = $self->_fix_metadata_before_conversion( $metadata );\n\n    my @write_metayml = $self->stashmeta(\n      $meta->as_string({version => \"1.4\"}), 'META_new.yml'\n    );\n    my @write_metajson = $self->stashmeta(\n      $meta->as_string({version => \"2.0\"}), 'META_new.json'\n    );\n\n    my $metayml = join(\"\\n\\t\", @write_metayml);\n    my $metajson = join(\"\\n\\t\", @write_metajson);\n    return sprintf <<'MAKE_FRAG', $metayml, $metajson;\nmetafile : create_distdir\n\t$(NOECHO) $(ECHO) Generating META.yml\n\t%s\n\t-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml\n\t$(NOECHO) $(ECHO) Generating META.json\n\t%s\n\t-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json\nMAKE_FRAG\n\n}\n\n=begin private\n\n=head3 _fix_metadata_before_conversion\n\n    $mm->_fix_metadata_before_conversion( \\%metadata );\n\nFixes errors in the metadata before it's handed off to CPAN::Meta for\nconversion. This hopefully results in something that can be used further\non, no guarantee is made though.\n\n=end private\n\n=cut\n\nsub _fix_metadata_before_conversion {\n    my ( $self, $metadata ) = @_;\n\n    # we should never be called unless this already passed but\n    # prefer to be defensive in case somebody else calls this\n\n    return unless _has_cpan_meta;\n\n    my $bad_version = $metadata->{version} &&\n                      !CPAN::Meta::Validator->new->version( 'version', $metadata->{version} );\n    # just delete all invalid versions\n    if( $bad_version ) {\n        warn \"Can't parse version '$metadata->{version}'\\n\";\n        $metadata->{version} = '';\n    }\n\n    my $validator2 = CPAN::Meta::Validator->new( $metadata );\n    my @errors;\n    push @errors, $validator2->errors if !$validator2->is_valid;\n    my $validator14 = CPAN::Meta::Validator->new(\n        {\n            %$metadata,\n            'meta-spec' => { version => 1.4 },\n        }\n    );\n    push @errors, $validator14->errors if !$validator14->is_valid;\n    # fix non-camelcase custom resource keys (only other trick we know)\n    for my $error ( @errors ) {\n        my ( $key ) = ( $error =~ /Custom resource '(.*)' must be in CamelCase./ );\n        next if !$key;\n\n        # first try to remove all non-alphabetic chars\n        ( my $new_key = $key ) =~ s/[^_a-zA-Z]//g;\n\n        # if that doesn't work, uppercase first one\n        $new_key = ucfirst $new_key if !$validator14->custom_1( $new_key );\n\n        # copy to new key if that worked\n        $metadata->{resources}{$new_key} = $metadata->{resources}{$key}\n          if $validator14->custom_1( $new_key );\n\n        # and delete old one in any case\n        delete $metadata->{resources}{$key};\n    }\n\n    # paper over validation issues, but still complain, necessary because\n    # there's no guarantee that the above will fix ALL errors\n    my $meta = eval { CPAN::Meta->create( $metadata, { lazy_validation => 1 } ) };\n    warn $@ if $@ and\n               $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;\n\n    # use the original metadata straight if the conversion failed\n    # or if it can't be stringified.\n    if( !$meta                                                  ||\n        !eval { $meta->as_string( { version => $METASPEC_V } ) }      ||\n        !eval { $meta->as_string }\n    ) {\n        $meta = bless $metadata, 'CPAN::Meta';\n    }\n\n    my $now_license = $meta->as_struct({ version => 2 })->{license};\n    if ($self->{LICENSE} and $self->{LICENSE} ne 'unknown' and\n        @{$now_license} == 1 and $now_license->[0] eq 'unknown'\n    ) {\n        warn \"Invalid LICENSE value '$self->{LICENSE}' ignored\\n\";\n    }\n\n    $meta;\n}\n\n\n=begin private\n\n=head3 _sort_pairs\n\n    my @pairs = _sort_pairs($sort_sub, \\%hash);\n\nSorts the pairs of a hash based on keys ordered according\nto C<$sort_sub>.\n\n=end private\n\n=cut\n\nsub _sort_pairs {\n    my $sort  = shift;\n    my $pairs = shift;\n    return map  { $_ => $pairs->{$_} }\n           sort $sort\n           keys %$pairs;\n}\n\n\n# Taken from Module::Build::Base\nsub _hash_merge {\n    my ($self, $h, $k, $v) = @_;\n    if (ref $h->{$k} eq 'ARRAY') {\n        push @{$h->{$k}}, ref $v ? @$v : $v;\n    } elsif (ref $h->{$k} eq 'HASH') {\n        $self->_hash_merge($h->{$k}, $_, $v->{$_}) foreach keys %$v;\n    } else {\n        $h->{$k} = $v;\n    }\n}\n\n\n=head3 metafile_data\n\n    my $metadata_hashref = $mm->metafile_data(\\%meta_add, \\%meta_merge);\n\nReturns the data which MakeMaker turns into the META.yml file \nand the META.json file. It is always in version 2.0 of the format.\n\nValues of %meta_add will overwrite any existing metadata in those\nkeys.  %meta_merge will be merged with them.\n\n=cut\n\nsub metafile_data {\n    my $self = shift;\n    my($meta_add, $meta_merge) = @_;\n\n    $meta_add ||= {};\n    $meta_merge ||= {};\n\n    my $version = _normalize_version($self->{VERSION});\n    my $release_status = ($version =~ /_/) ? 'unstable' : 'stable';\n    my %meta = (\n        # required\n        abstract     => $self->{ABSTRACT} || 'unknown',\n        author       => defined($self->{AUTHOR}) ? $self->{AUTHOR} : ['unknown'],\n        dynamic_config => 1,\n        generated_by => \"ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION\",\n        license      => [ $self->{LICENSE} || 'unknown' ],\n        'meta-spec'  => {\n            url         => $METASPEC_URL,\n            version     => $METASPEC_V,\n        },\n        name         => $self->{DISTNAME},\n        release_status => $release_status,\n        version      => $version,\n\n        # optional\n        no_index     => { directory => [qw(t inc)] },\n    );\n    $self->_add_requirements_to_meta(\\%meta);\n\n    if (!eval { require JSON::PP; require CPAN::Meta::Converter; CPAN::Meta::Converter->VERSION(2.141170) }) {\n      return \\%meta;\n    }\n\n    # needs to be based on the original version\n    my $v1_add = _metaspec_version($meta_add) !~ /^2/;\n\n    for my $frag ($meta_add, $meta_merge) {\n        $frag = CPAN::Meta::Converter->new($frag, default_version => \"1.4\")->upgrade_fragment;\n    }\n\n    # if we upgraded a 1.x _ADD fragment, we gave it a prereqs key that\n    # will override all prereqs, which is more than the user asked for;\n    # instead, we'll go inside the prereqs and override all those\n    while( my($key, $val) = each %$meta_add ) {\n        if ($v1_add and $key eq 'prereqs') {\n            $meta{$key}{$_} = $val->{$_} for keys %$val;\n        } elsif ($key ne 'meta-spec') {\n            $meta{$key} = $val;\n        }\n    }\n\n    while( my($key, $val) = each %$meta_merge ) {\n        next if $key eq 'meta-spec';\n        $self->_hash_merge(\\%meta, $key, $val);\n    }\n\n    return \\%meta;\n}\n\n\n=begin private\n\n=cut\n\nsub _add_requirements_to_meta {\n    my ( $self, $meta ) = @_;\n    # Check the original args so we can tell between the user setting it\n    # to an empty hash and it just being initialized.\n    $meta->{prereqs}{configure}{requires} = $self->{ARGS}{CONFIGURE_REQUIRES}\n        ? $self->{CONFIGURE_REQUIRES}\n        : { 'ExtUtils::MakeMaker' => 0, };\n    $meta->{prereqs}{build}{requires} = $self->{ARGS}{BUILD_REQUIRES}\n        ? $self->{BUILD_REQUIRES}\n        : { 'ExtUtils::MakeMaker' => 0, };\n    $meta->{prereqs}{test}{requires} = $self->{TEST_REQUIRES}\n        if $self->{ARGS}{TEST_REQUIRES};\n    $meta->{prereqs}{runtime}{requires} = $self->{PREREQ_PM}\n        if $self->{ARGS}{PREREQ_PM};\n    $meta->{prereqs}{runtime}{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})\n        if $self->{MIN_PERL_VERSION};\n}\n\n# spec version of given fragment - if not given, assume 1.4\nsub _metaspec_version {\n  my ( $meta ) = @_;\n  return $meta->{'meta-spec'}->{version}\n    if defined $meta->{'meta-spec'}\n       and defined $meta->{'meta-spec'}->{version};\n  return '1.4';\n}\n\nsub _add_requirements_to_meta_v1_4 {\n    my ( $self, $meta ) = @_;\n    # Check the original args so we can tell between the user setting it\n    # to an empty hash and it just being initialized.\n    if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {\n        $meta->{configure_requires} = $self->{CONFIGURE_REQUIRES};\n    } else {\n        $meta->{configure_requires} = {\n            'ExtUtils::MakeMaker'       => 0,\n        };\n    }\n    if( $self->{ARGS}{BUILD_REQUIRES} ) {\n        $meta->{build_requires} = $self->{BUILD_REQUIRES};\n    } else {\n        $meta->{build_requires} = {\n            'ExtUtils::MakeMaker'       => 0,\n        };\n    }\n    if( $self->{ARGS}{TEST_REQUIRES} ) {\n        $meta->{build_requires} = {\n          %{ $meta->{build_requires} },\n          %{ $self->{TEST_REQUIRES} },\n        };\n    }\n    $meta->{requires} = $self->{PREREQ_PM}\n        if defined $self->{PREREQ_PM};\n    $meta->{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})\n        if $self->{MIN_PERL_VERSION};\n}\n\n# Adapted from Module::Build::Base\nsub _normalize_version {\n  my ($version) = @_;\n  $version = 0 unless defined $version;\n\n  if ( ref $version eq 'version' ) { # version objects\n    $version = $version->stringify;\n  }\n  elsif ( $version =~ /^[^v][^.]*\\.[^.]+\\./ ) { # no leading v, multiple dots\n    # normalize string tuples without \"v\": \"1.2.3\" -> \"v1.2.3\"\n    $version = \"v$version\";\n  }\n  else {\n    # leave alone\n  }\n  return $version;\n}\n\n=head3 _dump_hash\n\n    $yaml = _dump_hash(\\%options, %hash);\n\nImplements a fake YAML dumper for a hash given\nas a list of pairs. No quoting/escaping is done. Keys\nare supposed to be strings. Values are undef, strings,\nhash refs or array refs of strings.\n\nSupported options are:\n\n    delta => STR - indentation delta\n    use_header => BOOL - whether to include a YAML header\n    indent => STR - a string of spaces\n          default: ''\n\n    max_key_length => INT - maximum key length used to align\n        keys and values of the same hash\n        default: 20\n    key_sort => CODE - a sort sub\n            It may be undef, which means no sorting by keys\n        default: sub { lc $a cmp lc $b }\n\n    customs => HASH - special options for certain keys\n           (whose values are hashes themselves)\n        may contain: max_key_length, key_sort, customs\n\n=end private\n\n=cut\n\nsub _dump_hash {\n    croak \"first argument should be a hash ref\" unless ref $_[0] eq 'HASH';\n    my $options = shift;\n    my %hash = @_;\n\n    # Use a list to preserve order.\n    my @pairs;\n\n    my $k_sort\n        = exists $options->{key_sort} ? $options->{key_sort}\n                                      : sub { lc $a cmp lc $b };\n    if ($k_sort) {\n        croak \"'key_sort' should be a coderef\" unless ref $k_sort eq 'CODE';\n        @pairs = _sort_pairs($k_sort, \\%hash);\n    } else { # list of pairs, no sorting\n        @pairs = @_;\n    }\n\n    my $yaml     = $options->{use_header} ? \"--- #YAML:1.0\\n\" : '';\n    my $indent   = $options->{indent} || '';\n    my $k_length = min(\n        ($options->{max_key_length} || 20),\n        max(map { length($_) + 1 } grep { !ref $hash{$_} } keys %hash)\n    );\n    my $customs  = $options->{customs} || {};\n\n    # printf format for key\n    my $k_format = \"%-${k_length}s\";\n\n    while( @pairs ) {\n        my($key, $val) = splice @pairs, 0, 2;\n        $val = '~' unless defined $val;\n        if(ref $val eq 'HASH') {\n            if ( keys %$val ) {\n                my %k_options = ( # options for recursive call\n                    delta => $options->{delta},\n                    use_header => 0,\n                    indent => $indent . $options->{delta},\n                );\n                if (exists $customs->{$key}) {\n                    my %k_custom = %{$customs->{$key}};\n                    foreach my $k (qw(key_sort max_key_length customs)) {\n                        $k_options{$k} = $k_custom{$k} if exists $k_custom{$k};\n                    }\n                }\n                $yaml .= $indent . \"$key:\\n\"\n                  . _dump_hash(\\%k_options, %$val);\n            }\n            else {\n                $yaml .= $indent . \"$key:  {}\\n\";\n            }\n        }\n        elsif (ref $val eq 'ARRAY') {\n            if( @$val ) {\n                $yaml .= $indent . \"$key:\\n\";\n\n                for (@$val) {\n                    croak \"only nested arrays of non-refs are supported\" if ref $_;\n                    $yaml .= $indent . $options->{delta} . \"- $_\\n\";\n                }\n            }\n            else {\n                $yaml .= $indent . \"$key:  []\\n\";\n            }\n        }\n        elsif( ref $val and !blessed($val) ) {\n            croak \"only nested hashes, arrays and objects are supported\";\n        }\n        else {  # if it's an object, just stringify it\n            $yaml .= $indent . sprintf \"$k_format  %s\\n\", \"$key:\", $val;\n        }\n    };\n\n    return $yaml;\n\n}\n\nsub blessed {\n    return eval { $_[0]->isa(\"UNIVERSAL\"); };\n}\n\nsub max {\n    return (sort { $b <=> $a } @_)[0];\n}\n\nsub min {\n    return (sort { $a <=> $b } @_)[0];\n}\n\n=head3 metafile_file\n\n    my $meta_yml = $mm->metafile_file(@metadata_pairs);\n\nTurns the @metadata_pairs into YAML.\n\nThis method does not implement a complete YAML dumper, being limited\nto dump a hash with values which are strings, undef's or nested hashes\nand arrays of strings. No quoting/escaping is done.\n\n=cut\n\nsub metafile_file {\n    my $self = shift;\n\n    my %dump_options = (\n        use_header => 1,\n        delta      => ' ' x 4,\n        key_sort   => undef,\n    );\n    return _dump_hash(\\%dump_options, @_);\n\n}\n\n\n=head3 distmeta_target\n\n    my $make_frag = $mm->distmeta_target;\n\nGenerates the distmeta target to add META.yml and META.json to the MANIFEST\nin the distdir.\n\n=cut\n\nsub distmeta_target {\n    my $self = shift;\n\n    my @add_meta = (\n      $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']),\nexit unless -e q{META.yml};\neval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }\n    or die \"Could not add META.yml to MANIFEST: ${'@'}\"\nCODE\n      $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd'])\nexit unless -f q{META.json};\neval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }\n    or die \"Could not add META.json to MANIFEST: ${'@'}\"\nCODE\n    );\n\n    my @add_meta_to_distdir = map { $self->cd('$(DISTVNAME)', $_) } @add_meta;\n\n    return sprintf <<'MAKE', @add_meta_to_distdir;\ndistmeta : create_distdir metafile\n\t$(NOECHO) %s\n\t$(NOECHO) %s\n\nMAKE\n\n}\n\n\n=head3 mymeta\n\n    my $mymeta = $mm->mymeta;\n\nGenerate MYMETA information as a hash either from an existing CPAN Meta file\n(META.json or META.yml) or from internal data.\n\n=cut\n\nsub mymeta {\n    my $self = shift;\n    my $file = shift || ''; # for testing\n\n    my $mymeta = $self->_mymeta_from_meta($file);\n    my $v2 = 1;\n\n    unless ( $mymeta ) {\n        $mymeta = $self->metafile_data(\n            $self->{META_ADD}   || {},\n            $self->{META_MERGE} || {},\n        );\n        $v2 = 0;\n    }\n\n    # Overwrite the non-configure dependency hashes\n    $self->_add_requirements_to_meta($mymeta);\n\n    $mymeta->{dynamic_config} = 0;\n\n    return $mymeta;\n}\n\n\nsub _mymeta_from_meta {\n    my $self = shift;\n    my $metafile = shift || ''; # for testing\n\n    return unless _has_cpan_meta();\n\n    my $meta;\n    for my $file ( $metafile, \"META.json\", \"META.yml\" ) {\n      next unless -e $file;\n      eval {\n          $meta = CPAN::Meta->load_file($file)->as_struct( { version => 2 } );\n      };\n      last if $meta;\n    }\n    return unless $meta;\n\n    # META.yml before 6.25_01 cannot be trusted.  META.yml lived in the source directory.\n    # There was a good chance the author accidentally uploaded a stale META.yml if they\n    # rolled their own tarball rather than using \"make dist\".\n    if ($meta->{generated_by} &&\n        $meta->{generated_by} =~ /ExtUtils::MakeMaker version ([\\d\\._]+)/) {\n        my $eummv = do { local $^W = 0; $1+0; };\n        if ($eummv < 6.2501) {\n            return;\n        }\n    }\n\n    return $meta;\n}\n\n=head3 write_mymeta\n\n    $self->write_mymeta( $mymeta );\n\nWrite MYMETA information to MYMETA.json and MYMETA.yml.\n\n=cut\n\nsub write_mymeta {\n    my $self = shift;\n    my $mymeta = shift;\n\n    return unless _has_cpan_meta();\n\n    my $meta_obj = $self->_fix_metadata_before_conversion( $mymeta );\n\n    $meta_obj->save( 'MYMETA.json', { version => \"2.0\" } );\n    $meta_obj->save( 'MYMETA.yml', { version => \"1.4\" } );\n    return 1;\n}\n\n=head3 realclean (o)\n\nDefines the realclean target.\n\n=cut\n\nsub realclean {\n    my($self, %attribs) = @_;\n\n    my @dirs  = qw($(DISTVNAME));\n    my @files = qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));\n\n    # Special exception for the perl core where INST_* is not in blib.\n    # This cleans up the files built from the ext/ directory (all XS).\n    if( $self->{PERL_CORE} ) {\n        push @dirs, qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));\n        push @files, values %{$self->{PM}};\n    }\n\n    if( $self->has_link_code ){\n        push @files, qw($(OBJECT));\n    }\n\n    if( $attribs{FILES} ) {\n        if( ref $attribs{FILES} ) {\n            push @dirs, @{ $attribs{FILES} };\n        }\n        else {\n            push @dirs, split /\\s+/, $attribs{FILES};\n        }\n    }\n\n    # Occasionally files are repeated several times from different sources\n    { my(%f) = map { ($_ => 1) } @files;  @files = sort keys %f; }\n    { my(%d) = map { ($_ => 1) } @dirs;   @dirs  = sort keys %d; }\n\n    my $rm_cmd  = join \"\\n\\t\", map { \"$_\" }\n                    $self->split_command('- $(RM_F)',  @files);\n    my $rmf_cmd = join \"\\n\\t\", map { \"$_\" }\n                    $self->split_command('- $(RM_RF)', @dirs);\n\n    my $m = sprintf <<'MAKE', $rm_cmd, $rmf_cmd;\n# Delete temporary files (via clean) and also delete dist files\nrealclean purge :: realclean_subdirs\n\t%s\n\t%s\nMAKE\n\n    $m .= \"\\t$attribs{POSTOP}\\n\" if $attribs{POSTOP};\n\n    return $m;\n}\n\n\n=head3 realclean_subdirs_target\n\n  my $make_frag = $MM->realclean_subdirs_target;\n\nReturns the realclean_subdirs target.  This is used by the realclean\ntarget to call realclean on any subdirectories which contain Makefiles.\n\n=cut\n\nsub realclean_subdirs_target {\n    my $self = shift;\n    my @m = <<'EOF';\n# so clean is forced to complete before realclean_subdirs runs\nrealclean_subdirs : clean\nEOF\n    return join '', @m, \"\\t\\$(NOECHO) \\$(NOOP)\\n\" unless @{$self->{DIR}};\n    foreach my $dir (@{$self->{DIR}}) {\n        foreach my $makefile ('$(MAKEFILE_OLD)', '$(FIRST_MAKEFILE)' ) {\n            my $subrclean .= $self->oneliner(_sprintf562 <<'CODE', $dir, $makefile);\nchdir '%1$s';  system '$(MAKE) $(USEMAKEFILE) %2$s realclean' if -f '%2$s';\nCODE\n            push @m, \"\\t- $subrclean\\n\";\n        }\n    }\n    return join '', @m;\n}\n\n\n=head3 signature_target\n\n    my $target = $mm->signature_target;\n\nGenerate the signature target.\n\nWrites the file SIGNATURE with \"cpansign -s\".\n\n=cut\n\nsub signature_target {\n    my $self = shift;\n\n    return <<'MAKE_FRAG';\nsignature :\n\tcpansign -s\nMAKE_FRAG\n\n}\n\n\n=head3 distsignature_target\n\n    my $make_frag = $mm->distsignature_target;\n\nGenerates the distsignature target to add SIGNATURE to the MANIFEST in the\ndistdir.\n\n=cut\n\nsub distsignature_target {\n    my $self = shift;\n\n    my $add_sign = $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']);\neval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }\n    or die \"Could not add SIGNATURE to MANIFEST: ${'@'}\"\nCODE\n\n    my $sign_dist        = $self->cd('$(DISTVNAME)' => 'cpansign -s');\n\n    # cpansign -s complains if SIGNATURE is in the MANIFEST yet does not\n    # exist\n    my $touch_sig        = $self->cd('$(DISTVNAME)' => '$(TOUCH) SIGNATURE');\n    my $add_sign_to_dist = $self->cd('$(DISTVNAME)' => $add_sign );\n\n    return sprintf <<'MAKE', $add_sign_to_dist, $touch_sig, $sign_dist\ndistsignature : distmeta\n\t$(NOECHO) %s\n\t$(NOECHO) %s\n\t%s\n\nMAKE\n\n}\n\n\n=head3 special_targets\n\n  my $make_frag = $mm->special_targets\n\nReturns a make fragment containing any targets which have special\nmeaning to make.  For example, .SUFFIXES and .PHONY.\n\n=cut\n\nsub special_targets {\n    my $make_frag = <<'MAKE_FRAG';\n.SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)\n\n.PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir pure_all subdirs clean_subdirs makemakerdflt manifypods realclean_subdirs subdirs_dynamic subdirs_pure_nolink subdirs_static subdirs-test_dynamic subdirs-test_static test_dynamic test_static\n\nMAKE_FRAG\n\n    $make_frag .= <<'MAKE_FRAG' if $ENV{CLEARCASE_ROOT};\n.NO_CONFIG_REC: Makefile\n\nMAKE_FRAG\n\n    return $make_frag;\n}\n\n\n\n\n=head2 Init methods\n\nMethods which help initialize the MakeMaker object and macros.\n\n\n=head3 init_ABSTRACT\n\n    $mm->init_ABSTRACT\n\n=cut\n\nsub init_ABSTRACT {\n    my $self = shift;\n\n    if( $self->{ABSTRACT_FROM} and $self->{ABSTRACT} ) {\n        warn \"Both ABSTRACT_FROM and ABSTRACT are set.  \".\n             \"Ignoring ABSTRACT_FROM.\\n\";\n        return;\n    }\n\n    if ($self->{ABSTRACT_FROM}){\n        $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or\n            carp \"WARNING: Setting ABSTRACT via file \".\n                 \"'$self->{ABSTRACT_FROM}' failed\\n\";\n    }\n\n    if ($self->{ABSTRACT} && $self->{ABSTRACT} =~ m![[:cntrl:]]+!) {\n            warn \"WARNING: ABSTRACT contains control character(s),\".\n                 \" they will be removed\\n\";\n            $self->{ABSTRACT} =~ s![[:cntrl:]]+!!g;\n            return;\n    }\n}\n\n=head3 init_INST\n\n    $mm->init_INST;\n\nCalled by init_main.  Sets up all INST_* variables except those related\nto XS code.  Those are handled in init_xs.\n\n=cut\n\nsub init_INST {\n    my($self) = shift;\n\n    $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,\"blib\",\"arch\");\n    $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');\n\n    # INST_LIB typically pre-set if building an extension after\n    # perl has been built and installed. Setting INST_LIB allows\n    # you to build directly into, say $Config{privlibexp}.\n    unless ($self->{INST_LIB}){\n        if ($self->{PERL_CORE}) {\n            $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};\n        } else {\n            $self->{INST_LIB} = $self->catdir($Curdir,\"blib\",\"lib\");\n        }\n    }\n\n    my @parentdir = split(/::/, $self->{PARENT_NAME});\n    $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @parentdir);\n    $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @parentdir);\n    $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto',\n                                              '$(FULLEXT)');\n    $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',\n                                              '$(FULLEXT)');\n\n    $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');\n\n    $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');\n    $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');\n\n    return 1;\n}\n\n\n=head3 init_INSTALL\n\n    $mm->init_INSTALL;\n\nCalled by init_main.  Sets up all INSTALL_* variables (except\nINSTALLDIRS) and *PREFIX.\n\n=cut\n\nsub init_INSTALL {\n    my($self) = shift;\n\n    if( $self->{ARGS}{INSTALL_BASE} and $self->{ARGS}{PREFIX} ) {\n        die \"Only one of PREFIX or INSTALL_BASE can be given.  Not both.\\n\";\n    }\n\n    if( $self->{ARGS}{INSTALL_BASE} ) {\n        $self->init_INSTALL_from_INSTALL_BASE;\n    }\n    else {\n        $self->init_INSTALL_from_PREFIX;\n    }\n}\n\n\n=head3 init_INSTALL_from_PREFIX\n\n  $mm->init_INSTALL_from_PREFIX;\n\n=cut\n\nsub init_INSTALL_from_PREFIX {\n    my $self = shift;\n\n    $self->init_lib2arch;\n\n    # There are often no Config.pm defaults for these new man variables so\n    # we fall back to the old behavior which is to use installman*dir\n    foreach my $num (1, 3) {\n        my $k = 'installsiteman'.$num.'dir';\n\n        $self->{uc $k} ||= uc \"\\$(installman${num}dir)\"\n          unless $Config{$k};\n    }\n\n    foreach my $num (1, 3) {\n        my $k = 'installvendorman'.$num.'dir';\n\n        unless( $Config{$k} ) {\n            $self->{uc $k}  ||= $Config{usevendorprefix}\n                              ? uc \"\\$(installman${num}dir)\"\n                              : '';\n        }\n    }\n\n    $self->{INSTALLSITEBIN} ||= '$(INSTALLBIN)'\n      unless $Config{installsitebin};\n    $self->{INSTALLSITESCRIPT} ||= '$(INSTALLSCRIPT)'\n      unless $Config{installsitescript};\n\n    unless( $Config{installvendorbin} ) {\n        $self->{INSTALLVENDORBIN} ||= $Config{usevendorprefix}\n                                    ? $Config{installbin}\n                                    : '';\n    }\n    unless( $Config{installvendorscript} ) {\n        $self->{INSTALLVENDORSCRIPT} ||= $Config{usevendorprefix}\n                                       ? $Config{installscript}\n                                       : '';\n    }\n\n\n    my $iprefix = $Config{installprefixexp} || $Config{installprefix} ||\n                  $Config{prefixexp}        || $Config{prefix} || '';\n    my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';\n    my $sprefix = $Config{siteprefixexp}    || '';\n\n    # 5.005_03 doesn't have a siteprefix.\n    $sprefix = $iprefix unless $sprefix;\n\n\n    $self->{PREFIX}       ||= '';\n\n    if( $self->{PREFIX} ) {\n        @{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =\n          ('$(PREFIX)') x 3;\n    }\n    else {\n        $self->{PERLPREFIX}   ||= $iprefix;\n        $self->{SITEPREFIX}   ||= $sprefix;\n        $self->{VENDORPREFIX} ||= $vprefix;\n\n        # Lots of MM extension authors like to use $(PREFIX) so we\n        # put something sensible in there no matter what.\n        $self->{PREFIX} = '$('.uc $self->{INSTALLDIRS}.'PREFIX)';\n    }\n\n    my $arch    = $Config{archname};\n    my $version = $Config{version};\n\n    # default style\n    my $libstyle = $Config{installstyle} || 'lib/perl5';\n    my $manstyle = '';\n\n    if( $self->{LIBSTYLE} ) {\n        $libstyle = $self->{LIBSTYLE};\n        $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';\n    }\n\n    # Some systems, like VOS, set installman*dir to '' if they can't\n    # read man pages.\n    for my $num (1, 3) {\n        $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'\n          unless $Config{'installman'.$num.'dir'};\n    }\n\n    my %bin_layouts =\n    (\n        bin         => { s => $iprefix,\n                         t => 'perl',\n                         d => 'bin' },\n        vendorbin   => { s => $vprefix,\n                         t => 'vendor',\n                         d => 'bin' },\n        sitebin     => { s => $sprefix,\n                         t => 'site',\n                         d => 'bin' },\n        script      => { s => $iprefix,\n                         t => 'perl',\n                         d => 'bin' },\n        vendorscript=> { s => $vprefix,\n                         t => 'vendor',\n                         d => 'bin' },\n        sitescript  => { s => $sprefix,\n                         t => 'site',\n                         d => 'bin' },\n    );\n\n    my %man_layouts =\n    (\n        man1dir         => { s => $iprefix,\n                             t => 'perl',\n                             d => 'man/man1',\n                             style => $manstyle, },\n        siteman1dir     => { s => $sprefix,\n                             t => 'site',\n                             d => 'man/man1',\n                             style => $manstyle, },\n        vendorman1dir   => { s => $vprefix,\n                             t => 'vendor',\n                             d => 'man/man1',\n                             style => $manstyle, },\n\n        man3dir         => { s => $iprefix,\n                             t => 'perl',\n                             d => 'man/man3',\n                             style => $manstyle, },\n        siteman3dir     => { s => $sprefix,\n                             t => 'site',\n                             d => 'man/man3',\n                             style => $manstyle, },\n        vendorman3dir   => { s => $vprefix,\n                             t => 'vendor',\n                             d => 'man/man3',\n                             style => $manstyle, },\n    );\n\n    my %lib_layouts =\n    (\n        privlib     => { s => $iprefix,\n                         t => 'perl',\n                         d => '',\n                         style => $libstyle, },\n        vendorlib   => { s => $vprefix,\n                         t => 'vendor',\n                         d => '',\n                         style => $libstyle, },\n        sitelib     => { s => $sprefix,\n                         t => 'site',\n                         d => 'site_perl',\n                         style => $libstyle, },\n\n        archlib     => { s => $iprefix,\n                         t => 'perl',\n                         d => \"$version/$arch\",\n                         style => $libstyle },\n        vendorarch  => { s => $vprefix,\n                         t => 'vendor',\n                         d => \"$version/$arch\",\n                         style => $libstyle },\n        sitearch    => { s => $sprefix,\n                         t => 'site',\n                         d => \"site_perl/$version/$arch\",\n                         style => $libstyle },\n    );\n\n\n    # Special case for LIB.\n    if( $self->{LIB} ) {\n        foreach my $var (keys %lib_layouts) {\n            my $Installvar = uc \"install$var\";\n\n            if( $var =~ /arch/ ) {\n                $self->{$Installvar} ||=\n                  $self->catdir($self->{LIB}, $Config{archname});\n            }\n            else {\n                $self->{$Installvar} ||= $self->{LIB};\n            }\n        }\n    }\n\n    my %type2prefix = ( perl    => 'PERLPREFIX',\n                        site    => 'SITEPREFIX',\n                        vendor  => 'VENDORPREFIX'\n                      );\n\n    my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);\n    while( my($var, $layout) = each(%layouts) ) {\n        my($s, $t, $d, $style) = @{$layout}{qw(s t d style)};\n        my $r = '$('.$type2prefix{$t}.')';\n\n        warn \"Prefixing $var\\n\" if $Verbose >= 2;\n\n        my $installvar = \"install$var\";\n        my $Installvar = uc $installvar;\n        next if $self->{$Installvar};\n\n        $d = \"$style/$d\" if $style;\n        $self->prefixify($installvar, $s, $r, $d);\n\n        warn \"  $Installvar == $self->{$Installvar}\\n\"\n          if $Verbose >= 2;\n    }\n\n    # Generate these if they weren't figured out.\n    $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};\n    $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};\n\n    return 1;\n}\n\n\n=head3 init_from_INSTALL_BASE\n\n    $mm->init_from_INSTALL_BASE\n\n=cut\n\nmy %map = (\n           lib      => [qw(lib perl5)],\n           arch     => [('lib', 'perl5', $Config{archname})],\n           bin      => [qw(bin)],\n           man1dir  => [qw(man man1)],\n           man3dir  => [qw(man man3)]\n          );\n$map{script} = $map{bin};\n\nsub init_INSTALL_from_INSTALL_BASE {\n    my $self = shift;\n\n    @{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)} =\n                                                         '$(INSTALL_BASE)';\n\n    my %install;\n    foreach my $thing (keys %map) {\n        foreach my $dir (('', 'SITE', 'VENDOR')) {\n            my $uc_thing = uc $thing;\n            my $key = \"INSTALL\".$dir.$uc_thing;\n\n            $install{$key} ||=\n              $self->catdir('$(INSTALL_BASE)', @{$map{$thing}});\n        }\n    }\n\n    # Adjust for variable quirks.\n    $install{INSTALLARCHLIB} ||= delete $install{INSTALLARCH};\n    $install{INSTALLPRIVLIB} ||= delete $install{INSTALLLIB};\n\n    foreach my $key (keys %install) {\n        $self->{$key} ||= $install{$key};\n    }\n\n    return 1;\n}\n\n\n=head3 init_VERSION  I<Abstract>\n\n    $mm->init_VERSION\n\nInitialize macros representing versions of MakeMaker and other tools\n\nMAKEMAKER: path to the MakeMaker module.\n\nMM_VERSION: ExtUtils::MakeMaker Version\n\nMM_REVISION: ExtUtils::MakeMaker version control revision (for backwards\n             compat)\n\nVERSION: version of your module\n\nVERSION_MACRO: which macro represents the version (usually 'VERSION')\n\nVERSION_SYM: like version but safe for use as an RCS revision number\n\nDEFINE_VERSION: -D line to set the module version when compiling\n\nXS_VERSION: version in your .xs file.  Defaults to $(VERSION)\n\nXS_VERSION_MACRO: which macro represents the XS version.\n\nXS_DEFINE_VERSION: -D line to set the xs version when compiling.\n\nCalled by init_main.\n\n=cut\n\nsub init_VERSION {\n    my($self) = shift;\n\n    $self->{MAKEMAKER}  = $ExtUtils::MakeMaker::Filename;\n    $self->{MM_VERSION} = $ExtUtils::MakeMaker::VERSION;\n    $self->{MM_REVISION}= $ExtUtils::MakeMaker::Revision;\n    $self->{VERSION_FROM} ||= '';\n\n    if ($self->{VERSION_FROM}){\n        $self->{VERSION} = $self->parse_version($self->{VERSION_FROM});\n        if( $self->{VERSION} eq 'undef' ) {\n            carp(\"WARNING: Setting VERSION via file \".\n                 \"'$self->{VERSION_FROM}' failed\\n\");\n        }\n    }\n\n    if (defined $self->{VERSION}) {\n        if ( $self->{VERSION} !~ /^\\s*v?[\\d_\\.]+\\s*$/ ) {\n          require version;\n          my $normal = eval { version->new( $self->{VERSION} ) };\n          $self->{VERSION} = $normal if defined $normal;\n        }\n        $self->{VERSION} =~ s/^\\s+//;\n        $self->{VERSION} =~ s/\\s+$//;\n    }\n    else {\n        $self->{VERSION} = '';\n    }\n\n\n    $self->{VERSION_MACRO}  = 'VERSION';\n    ($self->{VERSION_SYM} = $self->{VERSION}) =~ s/\\W/_/g;\n    $self->{DEFINE_VERSION} = '-D$(VERSION_MACRO)=\\\"$(VERSION)\\\"';\n\n\n    # Graham Barr and Paul Marquess had some ideas how to ensure\n    # version compatibility between the *.pm file and the\n    # corresponding *.xs file. The bottom line was, that we need an\n    # XS_VERSION macro that defaults to VERSION:\n    $self->{XS_VERSION} ||= $self->{VERSION};\n\n    $self->{XS_VERSION_MACRO}  = 'XS_VERSION';\n    $self->{XS_DEFINE_VERSION} = '-D$(XS_VERSION_MACRO)=\\\"$(XS_VERSION)\\\"';\n\n}\n\n\n=head3 init_tools\n\n    $MM->init_tools();\n\nInitializes the simple macro definitions used by tools_other() and\nplaces them in the $MM object.  These use conservative cross platform\nversions and should be overridden with platform specific versions for\nperformance.\n\nDefines at least these macros.\n\n  Macro             Description\n\n  NOOP              Do nothing\n  NOECHO            Tell make not to display the command itself\n\n  SHELL             Program used to run shell commands\n\n  ECHO              Print text adding a newline on the end\n  RM_F              Remove a file\n  RM_RF             Remove a directory\n  TOUCH             Update a file's timestamp\n  TEST_F            Test for a file's existence\n  TEST_S            Test the size of a file\n  CP                Copy a file\n  CP_NONEMPTY       Copy a file if it is not empty\n  MV                Move a file\n  CHMOD             Change permissions on a file\n  FALSE             Exit with non-zero\n  TRUE              Exit with zero\n\n  UMASK_NULL        Nullify umask\n  DEV_NULL          Suppress all command output\n\n=cut\n\nsub init_tools {\n    my $self = shift;\n\n    $self->{ECHO}     ||= $self->oneliner('binmode STDOUT, qq{:raw}; print qq{@ARGV}', ['-l']);\n    $self->{ECHO_N}   ||= $self->oneliner('print qq{@ARGV}');\n\n    $self->{TOUCH}    ||= $self->oneliner('touch', [\"-MExtUtils::Command\"]);\n    $self->{CHMOD}    ||= $self->oneliner('chmod', [\"-MExtUtils::Command\"]);\n    $self->{RM_F}     ||= $self->oneliner('rm_f',  [\"-MExtUtils::Command\"]);\n    $self->{RM_RF}    ||= $self->oneliner('rm_rf', [\"-MExtUtils::Command\"]);\n    $self->{TEST_F}   ||= $self->oneliner('test_f', [\"-MExtUtils::Command\"]);\n    $self->{TEST_S}   ||= $self->oneliner('test_s', [\"-MExtUtils::Command::MM\"]);\n    $self->{CP_NONEMPTY} ||= $self->oneliner('cp_nonempty', [\"-MExtUtils::Command::MM\"]);\n    $self->{FALSE}    ||= $self->oneliner('exit 1');\n    $self->{TRUE}     ||= $self->oneliner('exit 0');\n\n    $self->{MKPATH}   ||= $self->oneliner('mkpath', [\"-MExtUtils::Command\"]);\n\n    $self->{CP}       ||= $self->oneliner('cp', [\"-MExtUtils::Command\"]);\n    $self->{MV}       ||= $self->oneliner('mv', [\"-MExtUtils::Command\"]);\n\n    $self->{MOD_INSTALL} ||=\n      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);\ninstall([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);\nCODE\n    $self->{DOC_INSTALL} ||= $self->oneliner('perllocal_install', [\"-MExtUtils::Command::MM\"]);\n    $self->{UNINSTALL}   ||= $self->oneliner('uninstall', [\"-MExtUtils::Command::MM\"]);\n    $self->{WARN_IF_OLD_PACKLIST} ||=\n      $self->oneliner('warn_if_old_packlist', [\"-MExtUtils::Command::MM\"]);\n    $self->{FIXIN}       ||= $self->oneliner('MY->fixin(shift)', [\"-MExtUtils::MY\"]);\n    $self->{EQUALIZE_TIMESTAMP} ||= $self->oneliner('eqtime', [\"-MExtUtils::Command\"]);\n\n    $self->{UNINST}     ||= 0;\n    $self->{VERBINST}   ||= 0;\n\n    $self->{SHELL}              ||= $Config{sh};\n\n    # UMASK_NULL is not used by MakeMaker but some CPAN modules\n    # make use of it.\n    $self->{UMASK_NULL}         ||= \"umask 0\";\n\n    # Not the greatest default, but its something.\n    $self->{DEV_NULL}           ||= \"> /dev/null 2>&1\";\n\n    $self->{NOOP}               ||= '$(TRUE)';\n    $self->{NOECHO}             = '@' unless defined $self->{NOECHO};\n\n    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';\n    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};\n    $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';\n    $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';\n\n    # Not everybody uses -f to indicate \"use this Makefile instead\"\n    $self->{USEMAKEFILE}        ||= '-f';\n\n    # Some makes require a wrapper around macros passed in on the command\n    # line.\n    $self->{MACROSTART}         ||= '';\n    $self->{MACROEND}           ||= '';\n\n    return;\n}\n\n\n=head3 init_others\n\n    $MM->init_others();\n\nInitializes the macro definitions having to do with compiling and\nlinking used by tools_other() and places them in the $MM object.\n\nIf there is no description, its the same as the parameter to\nWriteMakefile() documented in ExtUtils::MakeMaker.\n\n=cut\n\nsub init_others {\n    my $self = shift;\n\n    $self->{LD_RUN_PATH} = \"\";\n\n    $self->{LIBS} = $self->_fix_libs($self->{LIBS});\n\n    # Compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $self->{LIBS}\n    foreach my $libs ( @{$self->{LIBS}} ){\n        $libs =~ s/^\\s*(.*\\S)\\s*$/$1/; # remove leading and trailing whitespace\n        my(@libs) = $self->extliblist($libs);\n        if ($libs[0] or $libs[1] or $libs[2]){\n            # LD_RUN_PATH now computed by ExtUtils::Liblist\n            ($self->{EXTRALIBS},  $self->{BSLOADLIBS},\n             $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @libs;\n            last;\n        }\n    }\n\n    if ( $self->{OBJECT} ) {\n        $self->{OBJECT} = join(\" \", @{$self->{OBJECT}}) if ref $self->{OBJECT};\n        $self->{OBJECT} =~ s!\\.o(bj)?\\b!\\$(OBJ_EXT)!g;\n    } elsif ( ($self->{MAGICXS} || $self->{XSMULTI}) && @{$self->{O_FILES}||[]} ) {\n        $self->{OBJECT} = join(\" \", @{$self->{O_FILES}});\n        $self->{OBJECT} =~ s!\\.o(bj)?\\b!\\$(OBJ_EXT)!g;\n    } else {\n        # init_dirscan should have found out, if we have C files\n        $self->{OBJECT} = \"\";\n        $self->{OBJECT} = '$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]};\n    }\n    $self->{OBJECT} =~ s/\\n+/ \\\\\\n\\t/g;\n\n    $self->{BOOTDEP}  = (-f \"$self->{BASEEXT}_BS\") ? \"$self->{BASEEXT}_BS\" : \"\";\n    $self->{PERLMAINCC} ||= '$(CC)';\n    $self->{LDFROM} = '$(OBJECT)' unless $self->{LDFROM};\n\n    # Sanity check: don't define LINKTYPE = dynamic if we're skipping\n    # the 'dynamic' section of MM.  We don't have this problem with\n    # 'static', since we either must use it (%Config says we can't\n    # use dynamic loading) or the caller asked for it explicitly.\n    if (!$self->{LINKTYPE}) {\n       $self->{LINKTYPE} = $self->{SKIPHASH}{'dynamic'}\n                        ? 'static'\n                        : ($Config{usedl} ? 'dynamic' : 'static');\n    }\n\n    return;\n}\n\n\n# Lets look at $self->{LIBS} carefully: It may be an anon array, a string or\n# undefined. In any case we turn it into an anon array\nsub _fix_libs {\n    my($self, $libs) = @_;\n\n    return !defined $libs       ? ['']          :\n           !ref $libs           ? [$libs]       :\n           !defined $libs->[0]  ? ['']          :\n                                  $libs         ;\n}\n\n\n=head3 tools_other\n\n    my $make_frag = $MM->tools_other;\n\nReturns a make fragment containing definitions for the macros init_others()\ninitializes.\n\n=cut\n\nsub tools_other {\n    my($self) = shift;\n    my @m;\n\n    # We set PM_FILTER as late as possible so it can see all the earlier\n    # on macro-order sensitive makes such as nmake.\n    for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH\n                      UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP\n                      FALSE TRUE\n                      ECHO ECHO_N\n                      UNINST VERBINST\n                      MOD_INSTALL DOC_INSTALL UNINSTALL\n                      WARN_IF_OLD_PACKLIST\n                      MACROSTART MACROEND\n                      USEMAKEFILE\n                      PM_FILTER\n                      FIXIN\n                      CP_NONEMPTY\n                    } )\n    {\n        next unless defined $self->{$tool};\n        push @m, \"$tool = $self->{$tool}\\n\";\n    }\n\n    return join \"\", @m;\n}\n\n\n=head3 init_DIRFILESEP  I<Abstract>\n\n  $MM->init_DIRFILESEP;\n  my $dirfilesep = $MM->{DIRFILESEP};\n\nInitializes the DIRFILESEP macro which is the separator between the\ndirectory and filename in a filepath.  ie. / on Unix, \\ on Win32 and\nnothing on VMS.\n\nFor example:\n\n    # instead of $(INST_ARCHAUTODIR)/extralibs.ld\n    $(INST_ARCHAUTODIR)$(DIRFILESEP)extralibs.ld\n\nSomething of a hack but it prevents a lot of code duplication between\nMM_* variants.\n\nDo not use this as a separator between directories.  Some operating\nsystems use different separators between subdirectories as between\ndirectories and filenames (for example:  VOLUME:[dir1.dir2]file on VMS).\n\n=head3 init_linker  I<Abstract>\n\n    $mm->init_linker;\n\nInitialize macros which have to do with linking.\n\nPERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic\nextensions.\n\nPERL_ARCHIVE_AFTER: path to a library which should be put on the\nlinker command line I<after> the external libraries to be linked to\ndynamic extensions.  This may be needed if the linker is one-pass, and\nPerl includes some overrides for C RTL functions, such as malloc().\n\nEXPORT_LIST: name of a file that is passed to linker to define symbols\nto be exported.\n\nSome OSes do not need these in which case leave it blank.\n\n\n=head3 init_platform\n\n    $mm->init_platform\n\nInitialize any macros which are for platform specific use only.\n\nA typical one is the version number of your OS specific module.\n(ie. MM_Unix_VERSION or MM_VMS_VERSION).\n\n=cut\n\nsub init_platform {\n    return '';\n}\n\n\n=head3 init_MAKE\n\n    $mm->init_MAKE\n\nInitialize MAKE from either a MAKE environment variable or $Config{make}.\n\n=cut\n\nsub init_MAKE {\n    my $self = shift;\n\n    $self->{MAKE} ||= $ENV{MAKE} || $Config{make};\n}\n\n\n=head2 Tools\n\nA grab bag of methods to generate specific macros and commands.\n\n\n\n=head3 manifypods\n\nDefines targets and routines to translate the pods into manpages and\nput them into the INST_* directories.\n\n=cut\n\nsub manifypods {\n    my $self          = shift;\n\n    my $POD2MAN_macro = $self->POD2MAN_macro();\n    my $manifypods_target = $self->manifypods_target();\n\n    return <<END_OF_TARGET;\n\n$POD2MAN_macro\n\n$manifypods_target\n\nEND_OF_TARGET\n\n}\n\n\n=head3 POD2MAN_macro\n\n  my $pod2man_macro = $self->POD2MAN_macro\n\nReturns a definition for the POD2MAN macro.  This is a program\nwhich emulates the pod2man utility.  You can add more switches to the\ncommand by simply appending them on the macro.\n\nTypical usage:\n\n    $(POD2MAN) --section=3 --perm_rw=$(PERM_RW) podfile1 man_page1 ...\n\n=cut\n\nsub POD2MAN_macro {\n    my $self = shift;\n\n# Need the trailing '--' so perl stops gobbling arguments and - happens\n# to be an alternative end of line separator on VMS so we quote it\n    return <<'END_OF_DEF';\nPOD2MAN_EXE = $(PERLRUN) \"-MExtUtils::Command::MM\" -e pod2man \"--\"\nPOD2MAN = $(POD2MAN_EXE)\nEND_OF_DEF\n}\n\n\n=head3 test_via_harness\n\n  my $command = $mm->test_via_harness($perl, $tests);\n\nReturns a $command line which runs the given set of $tests with\nTest::Harness and the given $perl.\n\nUsed on the t/*.t files.\n\n=cut\n\nsub test_via_harness {\n    my($self, $perl, $tests) = @_;\n\n    return qq{\\t$perl \"-MExtUtils::Command::MM\" \"-MTest::Harness\" }.\n           qq{\"-e\" \"undef *Test::Harness::Switches; test_harness(\\$(TEST_VERBOSE), '\\$(INST_LIB)', '\\$(INST_ARCHLIB)')\" $tests\\n};\n}\n\n=head3 test_via_script\n\n  my $command = $mm->test_via_script($perl, $script);\n\nReturns a $command line which just runs a single test without\nTest::Harness.  No checks are done on the results, they're just\nprinted.\n\nUsed for test.pl, since they don't always follow Test::Harness\nformatting.\n\n=cut\n\nsub test_via_script {\n    my($self, $perl, $script) = @_;\n    return qq{\\t$perl \"-I\\$(INST_LIB)\" \"-I\\$(INST_ARCHLIB)\" $script\\n};\n}\n\n\n=head3 tool_autosplit\n\nDefines a simple perl call that runs autosplit. May be deprecated by\npm_to_blib soon.\n\n=cut\n\nsub tool_autosplit {\n    my($self, %attribs) = @_;\n\n    my $maxlen = $attribs{MAXLEN} ? '$$AutoSplit::Maxlen=$attribs{MAXLEN};'\n                                  : '';\n\n    my $asplit = $self->oneliner(sprintf <<'PERL_CODE', $maxlen);\nuse AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)\nPERL_CODE\n\n    return sprintf <<'MAKE_FRAG', $asplit;\n# Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto\nAUTOSPLITFILE = %s\n\nMAKE_FRAG\n\n}\n\n\n=head3 arch_check\n\n    my $arch_ok = $mm->arch_check(\n        $INC{\"Config.pm\"},\n        File::Spec->catfile($Config{archlibexp}, \"Config.pm\")\n    );\n\nA sanity check that what Perl thinks the architecture is and what\nConfig thinks the architecture is are the same.  If they're not it\nwill return false and show a diagnostic message.\n\nWhen building Perl it will always return true, as nothing is installed\nyet.\n\nThe interface is a bit odd because this is the result of a\nquick refactoring.  Don't rely on it.\n\n=cut\n\nsub arch_check {\n    my $self = shift;\n    my($pconfig, $cconfig) = @_;\n\n    return 1 if $self->{PERL_SRC};\n\n    my($pvol, $pthinks) = $self->splitpath($pconfig);\n    my($cvol, $cthinks) = $self->splitpath($cconfig);\n\n    $pthinks = $self->canonpath($pthinks);\n    $cthinks = $self->canonpath($cthinks);\n\n    my $ret = 1;\n    if ($pthinks ne $cthinks) {\n        print \"Have $pthinks\\n\";\n        print \"Want $cthinks\\n\";\n\n        $ret = 0;\n\n        my $arch = (grep length, $self->splitdir($pthinks))[-1];\n\n        print <<END unless $self->{UNINSTALLED_PERL};\nYour perl and your Config.pm seem to have different ideas about the\narchitecture they are running on.\nPerl thinks: [$arch]\nConfig says: [$Config{archname}]\nThis may or may not cause problems. Please check your installation of perl\nif you have problems building this extension.\nEND\n    }\n\n    return $ret;\n}\n\n\n\n=head2 File::Spec wrappers\n\nExtUtils::MM_Any is a subclass of File::Spec.  The methods noted here\noverride File::Spec.\n\n\n\n=head3 catfile\n\nFile::Spec <= 0.83 has a bug where the file part of catfile is not\ncanonicalized.  This override fixes that bug.\n\n=cut\n\nsub catfile {\n    my $self = shift;\n    return $self->canonpath($self->SUPER::catfile(@_));\n}\n\n\n\n=head2 Misc\n\nMethods I can't really figure out where they should go yet.\n\n\n=head3 find_tests\n\n  my $test = $mm->find_tests;\n\nReturns a string suitable for feeding to the shell to return all\ntests in t/*.t.\n\n=cut\n\nsub find_tests {\n    my($self) = shift;\n    return -d 't' ? 't/*.t' : '';\n}\n\n=head3 find_tests_recursive\n\n  my $tests = $mm->find_tests_recursive;\n\nReturns a string suitable for feeding to the shell to return all\ntests in t/ but recursively. Equivalent to\n\n  my $tests = $mm->find_tests_recursive_in('t');\n\n=cut\n\nsub find_tests_recursive {\n    my $self = shift;\n    return $self->find_tests_recursive_in('t');\n}\n\n=head3 find_tests_recursive_in\n\n  my $tests = $mm->find_tests_recursive_in($dir);\n\nReturns a string suitable for feeding to the shell to return all\ntests in $dir recursively.\n\n=cut\n\nsub find_tests_recursive_in {\n    my($self, $dir) = @_;\n    return '' unless -d $dir;\n\n    require File::Find;\n\n    my $base_depth = grep { $_ ne '' } File::Spec->splitdir( (File::Spec->splitpath($dir))[1] );\n    my %depths;\n\n    my $wanted = sub {\n        return unless m!\\.t$!;\n        my ($volume,$directories,$file) =\n            File::Spec->splitpath( $File::Find::name  );\n        my $depth = grep { $_ ne '' } File::Spec->splitdir( $directories );\n        $depth -= $base_depth;\n        $depths{ $depth } = 1;\n    };\n\n    File::Find::find( $wanted, $dir );\n\n    return join ' ',\n        map { $dir . '/*' x $_ . '.t' }\n        sort { $a <=> $b }\n        keys %depths;\n}\n\n=head3 extra_clean_files\n\n    my @files_to_clean = $MM->extra_clean_files;\n\nReturns a list of OS specific files to be removed in the clean target in\naddition to the usual set.\n\n=cut\n\n# An empty method here tickled a perl 5.8.1 bug and would return its object.\nsub extra_clean_files {\n    return;\n}\n\n\n=head3 installvars\n\n    my @installvars = $mm->installvars;\n\nA list of all the INSTALL* variables without the INSTALL prefix.  Useful\nfor iteration or building related variable sets.\n\n=cut\n\nsub installvars {\n    return qw(PRIVLIB SITELIB  VENDORLIB\n              ARCHLIB SITEARCH VENDORARCH\n              BIN     SITEBIN  VENDORBIN\n              SCRIPT  SITESCRIPT  VENDORSCRIPT\n              MAN1DIR SITEMAN1DIR VENDORMAN1DIR\n              MAN3DIR SITEMAN3DIR VENDORMAN3DIR\n             );\n}\n\n\n=head3 libscan\n\n  my $wanted = $self->libscan($path);\n\nTakes a path to a file or dir and returns an empty string if we don't\nwant to include this file in the library.  Otherwise it returns the\nthe $path unchanged.\n\nMainly used to exclude version control administrative directories from\ninstallation.\n\n=cut\n\nsub libscan {\n    my($self,$path) = @_;\n    my($dirs,$file) = ($self->splitpath($path))[1,2];\n    return '' if grep /^(?:RCS|CVS|SCCS|\\.svn|_darcs)$/,\n                     $self->splitdir($dirs), $file;\n\n    return $path;\n}\n\n\n=head3 platform_constants\n\n    my $make_frag = $mm->platform_constants\n\nReturns a make fragment defining all the macros initialized in\ninit_platform() rather than put them in constants().\n\n=cut\n\nsub platform_constants {\n    return '';\n}\n\n=head3 post_constants (o)\n\nReturns an empty string per default. Dedicated to overrides from\nwithin Makefile.PL after all constants have been defined.\n\n=cut\n\nsub post_constants {\n    \"\";\n}\n\n=head3 post_initialize (o)\n\nReturns an empty string per default. Used in Makefile.PLs to add some\nchunk of text to the Makefile after the object is initialized.\n\n=cut\n\nsub post_initialize {\n    \"\";\n}\n\n=head3 postamble (o)\n\nReturns an empty string. Can be used in Makefile.PLs to write some\ntext to the Makefile at the end.\n\n=cut\n\nsub postamble {\n    \"\";\n}\n\n=begin private\n\n=head3 _PREREQ_PRINT\n\n    $self->_PREREQ_PRINT;\n\nImplements PREREQ_PRINT.\n\nRefactored out of MakeMaker->new().\n\n=end private\n\n=cut\n\nsub _PREREQ_PRINT {\n    my $self = shift;\n\n    require Data::Dumper;\n    my @what = ('PREREQ_PM');\n    push @what, 'MIN_PERL_VERSION' if $self->{MIN_PERL_VERSION};\n    push @what, 'BUILD_REQUIRES'   if $self->{BUILD_REQUIRES};\n    print Data::Dumper->Dump([@{$self}{@what}], \\@what);\n    exit 0;\n}\n\n\n=begin private\n\n=head3 _PRINT_PREREQ\n\n  $mm->_PRINT_PREREQ;\n\nImplements PRINT_PREREQ, a slightly different version of PREREQ_PRINT\nadded by Redhat to, I think, support generating RPMs from Perl modules.\n\nShould not include BUILD_REQUIRES as RPMs do not include them.\n\nRefactored out of MakeMaker->new().\n\n=end private\n\n=cut\n\nsub _PRINT_PREREQ {\n    my $self = shift;\n\n    my $prereqs= $self->{PREREQ_PM};\n    my @prereq = map { [$_, $prereqs->{$_}] } keys %$prereqs;\n\n    if ( $self->{MIN_PERL_VERSION} ) {\n        push @prereq, ['perl' => $self->{MIN_PERL_VERSION}];\n    }\n\n    print join(\" \", map { \"perl($_->[0])>=$_->[1] \" }\n                 sort { $a->[0] cmp $b->[0] } @prereq), \"\\n\";\n    exit 0;\n}\n\n\n=begin private\n\n=head3 _perl_header_files\n\n  my $perl_header_files= $self->_perl_header_files;\n\nreturns a sorted list of header files as found in PERL_SRC or $archlibexp/CORE.\n\nUsed by perldepend() in MM_Unix and MM_VMS via _perl_header_files_fragment()\n\n=end private\n\n=cut\n\nsub _perl_header_files {\n    my $self = shift;\n\n    my $header_dir = $self->{PERL_SRC} || $ENV{PERL_SRC} || $self->catdir($Config{archlibexp}, 'CORE');\n    opendir my $dh, $header_dir\n        or die \"Failed to opendir '$header_dir' to find header files: $!\";\n\n    # we need to use a temporary here as the sort in scalar context would have undefined results.\n    my @perl_headers= sort grep { /\\.h\\z/ } readdir($dh);\n\n    closedir $dh;\n\n    return @perl_headers;\n}\n\n=begin private\n\n=head3 _perl_header_files_fragment ($o, $separator)\n\n  my $perl_header_files_fragment= $self->_perl_header_files_fragment(\"/\");\n\nreturn a Makefile fragment which holds the list of perl header files which\nXS code depends on $(PERL_INC), and sets up the dependency for the $(OBJECT) file.\n\nThe $separator argument defaults to \"\". MM_VMS will set it to \"\" and MM_UNIX to \"/\"\nin perldepend(). This reason child subclasses need to control this is that in\nVMS the $(PERL_INC) directory will already have delimiters in it, but in\nUNIX $(PERL_INC) will need a slash between it an the filename. Hypothetically\nwin32 could use \"\\\\\" (but it doesn't need to).\n\n=end private\n\n=cut\n\nsub _perl_header_files_fragment {\n    my ($self, $separator)= @_;\n    $separator ||= \"\";\n    return join(\"\\\\\\n\",\n                \"PERL_HDRS = \",\n                map {\n                    sprintf( \"        \\$(PERL_INCDEP)%s%s            \", $separator, $_ )\n                } $self->_perl_header_files()\n           ) . \"\\n\\n\"\n           . \"\\$(OBJECT) : \\$(PERL_HDRS)\\n\";\n}\n\n\n=head1 AUTHOR\n\nMichael G Schwern <schwern@pobox.com> and the denizens of\nmakemaker@perl.org with code from ExtUtils::MM_Unix and\nExtUtils::MM_Win32.\n\n\n=cut\n\n1;\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_Win32.pm": "package ExtUtils::MM_Win32;\n\nuse strict;\n\n\n=head1 NAME\n\nExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker\n\n=head1 SYNOPSIS\n\n use ExtUtils::MM_Win32; # Done internally by ExtUtils::MakeMaker if needed\n\n=head1 DESCRIPTION\n\nSee ExtUtils::MM_Unix for a documentation of the methods provided\nthere. This package overrides the implementation of these methods, not\nthe semantics.\n\n=cut\n\nuse ExtUtils::MakeMaker::Config;\nuse File::Basename;\nuse File::Spec;\nuse ExtUtils::MakeMaker qw(neatvalue _sprintf562);\n\nrequire ExtUtils::MM_Any;\nrequire ExtUtils::MM_Unix;\nour @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\n$ENV{EMXSHELL} = 'sh'; # to run `commands`\n\nmy ( $BORLAND, $GCC, $MSVC ) = _identify_compiler_environment( \\%Config );\n\nsub _identify_compiler_environment {\n\tmy ( $config ) = @_;\n\n\tmy $BORLAND = $config->{cc} =~ /\\bbcc/i ? 1 : 0;\n\tmy $GCC     = $config->{cc} =~ /\\bgcc\\b/i ? 1 : 0;\n\tmy $MSVC    = $config->{cc} =~ /\\b(?:cl|icl)/i ? 1 : 0; # MSVC can come as clarm.exe, icl=Intel C\n\n\treturn ( $BORLAND, $GCC, $MSVC );\n}\n\n\n=head2 Overridden methods\n\n=over 4\n\n=item B<dlsyms>\n\n=cut\n\nsub dlsyms {\n    my($self,%attribs) = @_;\n    return '' if $self->{SKIPHASH}{'dynamic'};\n    $self->xs_dlsyms_iterator(\\%attribs);\n}\n\n=item xs_dlsyms_ext\n\nOn Win32, is C<.def>.\n\n=cut\n\nsub xs_dlsyms_ext {\n    '.def';\n}\n\n=item replace_manpage_separator\n\nChanges the path separator with .\n\n=cut\n\nsub replace_manpage_separator {\n    my($self,$man) = @_;\n    $man =~ s,/+,.,g;\n    $man;\n}\n\n\n=item B<maybe_command>\n\nSince Windows has nothing as simple as an executable bit, we check the\nfile extension.\n\nThe PATHEXT env variable will be used to get a list of extensions that\nmight indicate a command, otherwise .com, .exe, .bat and .cmd will be\nused by default.\n\n=cut\n\nsub maybe_command {\n    my($self,$file) = @_;\n    my @e = exists($ENV{'PATHEXT'})\n          ? split(/;/, $ENV{PATHEXT})\n\t  : qw(.com .exe .bat .cmd);\n    my $e = '';\n    for (@e) { $e .= \"\\Q$_\\E|\" }\n    chop $e;\n    # see if file ends in one of the known extensions\n    if ($file =~ /($e)$/i) {\n\treturn $file if -e $file;\n    }\n    else {\n\tfor (@e) {\n\t    return \"$file$_\" if -e \"$file$_\";\n\t}\n    }\n    return;\n}\n\n\n=item B<init_DIRFILESEP>\n\nUsing \\ for Windows, except for \"gmake\" where it is /.\n\n=cut\n\nsub init_DIRFILESEP {\n    my($self) = shift;\n\n    # The ^ makes sure its not interpreted as an escape in nmake\n    $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\\\' :\n                          $self->is_make_type('dmake') ? '\\\\\\\\' :\n                          $self->is_make_type('gmake') ? '/'\n                                                       : '\\\\';\n}\n\n=item init_tools\n\nOverride some of the slower, portable commands with Windows specific ones.\n\n=cut\n\nsub init_tools {\n    my ($self) = @_;\n\n    $self->{NOOP}     ||= 'rem';\n    $self->{DEV_NULL} ||= '> NUL';\n\n    $self->{FIXIN}    ||= $self->{PERL_CORE} ?\n      \"\\$(PERLRUN) $self->{PERL_SRC}\\\\win32\\\\bin\\\\pl2bat.pl\" :\n      'pl2bat.bat';\n\n    $self->SUPER::init_tools;\n\n    # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.\n    delete $self->{SHELL};\n\n    return;\n}\n\n\n=item init_others\n\nOverride the default link and compile tools.\n\nLDLOADLIBS's default is changed to $Config{libs}.\n\nAdjustments are made for Borland's quirks needing -L to come first.\n\n=cut\n\nsub init_others {\n    my $self = shift;\n\n    $self->{LD}     ||= 'link';\n    $self->{AR}     ||= 'lib';\n\n    $self->SUPER::init_others;\n\n    $self->{LDLOADLIBS} ||= $Config{libs};\n    # -Lfoo must come first for Borland, so we put it in LDDLFLAGS\n    if ($BORLAND) {\n        my $libs = $self->{LDLOADLIBS};\n        my $libpath = '';\n        while ($libs =~ s/(?:^|\\s)((\"?)-L.+?\\2)(?:\\s|$)/ /) {\n            $libpath .= ' ' if length $libpath;\n            $libpath .= $1;\n        }\n        $self->{LDLOADLIBS} = $libs;\n        $self->{LDDLFLAGS} ||= $Config{lddlflags};\n        $self->{LDDLFLAGS} .= \" $libpath\";\n    }\n\n    return;\n}\n\n\n=item init_platform\n\nAdd MM_Win32_VERSION.\n\n=item platform_constants\n\n=cut\n\nsub init_platform {\n    my($self) = shift;\n\n    $self->{MM_Win32_VERSION} = $VERSION;\n\n    return;\n}\n\nsub platform_constants {\n    my($self) = shift;\n    my $make_frag = '';\n\n    foreach my $macro (qw(MM_Win32_VERSION))\n    {\n        next unless defined $self->{$macro};\n        $make_frag .= \"$macro = $self->{$macro}\\n\";\n    }\n\n    return $make_frag;\n}\n\n=item specify_shell\n\nSet SHELL to $ENV{COMSPEC} only if make is type 'gmake'.\n\n=cut\n\nsub specify_shell {\n    my $self = shift;\n    return '' unless $self->is_make_type('gmake');\n    \"\\nSHELL = $ENV{COMSPEC}\\n\";\n}\n\n=item constants\n\nAdd MAXLINELENGTH for dmake before all the constants are output.\n\n=cut\n\nsub constants {\n    my $self = shift;\n\n    my $make_text = $self->SUPER::constants;\n    return $make_text unless $self->is_make_type('dmake');\n\n    # dmake won't read any single \"line\" (even those with escaped newlines)\n    # larger than a certain size which can be as small as 8k.  PM_TO_BLIB\n    # on large modules like DateTime::TimeZone can create lines over 32k.\n    # So we'll crank it up to a <ironic>WHOPPING</ironic> 64k.\n    #\n    # This has to come here before all the constants and not in\n    # platform_constants which is after constants.\n    my $size = $self->{MAXLINELENGTH} || 800000;\n    my $prefix = qq{\n# Get dmake to read long commands like PM_TO_BLIB\nMAXLINELENGTH = $size\n\n};\n\n    return $prefix . $make_text;\n}\n\n\n=item special_targets\n\nAdd .USESHELL target for dmake.\n\n=cut\n\nsub special_targets {\n    my($self) = @_;\n\n    my $make_frag = $self->SUPER::special_targets;\n\n    $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');\n.USESHELL :\nMAKE_FRAG\n\n    return $make_frag;\n}\n\n=item static_lib_pure_cmd\n\nDefines how to run the archive utility\n\n=cut\n\nsub static_lib_pure_cmd {\n    my ($self, $from) = @_;\n    $from =~ s/(\\$\\(\\w+)(\\))/$1:^\"+\"$2/g if $BORLAND;\n    sprintf qq{\\t\\$(AR) %s\\n}, ($BORLAND ? '$@ ' . $from\n                          : ($GCC ? '-ru $@ ' . $from\n                                  : '-out:$@ ' . $from));\n}\n\n=item dynamic_lib\n\nMethods are overridden here: not dynamic_lib itself, but the utility\nones that do the OS-specific work.\n\n=cut\n\nsub xs_make_dynamic_lib {\n    my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;\n    my @m = sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(INST_DYNAMIC_DEP)'.\"\\n\", $to, $from, $todir, $exportlist;\n    if ($GCC) {\n      # per https://rt.cpan.org/Ticket/Display.html?id=78395 no longer\n      # uses dlltool - relies on post 2002 MinGW\n      #                             1            2\n      push @m, _sprintf562 <<'EOF', $exportlist, $ldfrom;\n\t$(LD) %1$s -o $@ $(LDDLFLAGS) %2$s $(OTHERLDFLAGS) $(MYEXTLIB) \"$(PERL_ARCHIVE)\" $(LDLOADLIBS) -Wl,--enable-auto-image-base\nEOF\n    } elsif ($BORLAND) {\n      my $ldargs = $self->is_make_type('dmake')\n          ? q{\"$(PERL_ARCHIVE:s,/,\\,)\" $(LDLOADLIBS:s,/,\\,) $(MYEXTLIB:s,/,\\,),}\n          : q{\"$(subst /,\\,$(PERL_ARCHIVE))\" $(subst /,\\,$(LDLOADLIBS)) $(subst /,\\,$(MYEXTLIB)),};\n      my $subbed;\n      if ($exportlist eq '$(EXPORT_LIST)') {\n          $subbed = $self->is_make_type('dmake')\n              ? q{$(EXPORT_LIST:s,/,\\,)}\n              : q{$(subst /,\\,$(EXPORT_LIST))};\n      } else {\n            # in XSMULTI, exportlist is per-XS, so have to sub in perl not make\n          ($subbed = $exportlist) =~ s#/#\\\\#g;\n      }\n      push @m, sprintf <<'EOF', $ldfrom, $ldargs . $subbed;\n        $(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) %s,$@,,%s,$(RESFILES)\nEOF\n    } else {\t# VC\n      push @m, sprintf <<'EOF', $ldfrom, $exportlist;\n\t$(LD) -out:$@ $(LDDLFLAGS) %s $(OTHERLDFLAGS) $(MYEXTLIB) \"$(PERL_ARCHIVE)\" $(LDLOADLIBS) -def:%s\nEOF\n      # Embed the manifest file if it exists\n      push(@m, q{\tif exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2\n\tif exist $@.manifest del $@.manifest});\n    }\n    push @m, \"\\n\\t\\$(CHMOD) \\$(PERM_RWX) \\$\\@\\n\";\n\n    join '', @m;\n}\n\nsub xs_dynamic_lib_macros {\n    my ($self, $attribs) = @_;\n    my $otherldflags = $attribs->{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');\n    my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || \"\";\n    sprintf <<'EOF', $otherldflags, $inst_dynamic_dep;\n# This section creates the dynamically loadable objects from relevant\n# objects and possibly $(MYEXTLIB).\nOTHERLDFLAGS = %s\nINST_DYNAMIC_DEP = %s\nEOF\n}\n\n=item extra_clean_files\n\nClean out some extra dll.{base,exp} files which might be generated by\ngcc.  Otherwise, take out all *.pdb files.\n\n=cut\n\nsub extra_clean_files {\n    my $self = shift;\n\n    return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');\n}\n\n=item init_linker\n\n=cut\n\nsub init_linker {\n    my $self = shift;\n\n    $self->{PERL_ARCHIVE}       = \"\\$(PERL_INC)\\\\$Config{libperl}\";\n    $self->{PERL_ARCHIVEDEP}    = \"\\$(PERL_INCDEP)\\\\$Config{libperl}\";\n    $self->{PERL_ARCHIVE_AFTER} = '';\n    $self->{EXPORT_LIST}        = '$(BASEEXT).def';\n}\n\n\n=item perl_script\n\nChecks for the perl program under several common perl extensions.\n\n=cut\n\nsub perl_script {\n    my($self,$file) = @_;\n    return $file if -r $file && -f _;\n    return \"$file.pl\"  if -r \"$file.pl\" && -f _;\n    return \"$file.plx\" if -r \"$file.plx\" && -f _;\n    return \"$file.bat\" if -r \"$file.bat\" && -f _;\n    return;\n}\n\nsub can_dep_space {\n    my $self = shift;\n    1; # with Win32::GetShortPathName\n}\n\n=item quote_dep\n\n=cut\n\nsub quote_dep {\n    my ($self, $arg) = @_;\n    if ($arg =~ / / and not $self->is_make_type('gmake')) {\n        require Win32;\n        $arg = Win32::GetShortPathName($arg);\n        die <<EOF if not defined $arg or $arg =~ / /;\nTried to use make dependency with space for non-GNU make:\n  '$arg'\nFallback to short pathname failed.\nEOF\n        return $arg;\n    }\n    return $self->SUPER::quote_dep($arg);\n}\n\n\n=item xs_obj_opt\n\nOverride to fixup -o flags for MSVC.\n\n=cut\n\nsub xs_obj_opt {\n    my ($self, $output_file) = @_;\n    ($MSVC ? \"/Fo\" : \"-o \") . $output_file;\n}\n\n\n=item pasthru\n\nAll we send is -nologo to nmake to prevent it from printing its damned\nbanner.\n\n=cut\n\nsub pasthru {\n    my($self) = shift;\n    my $old = $self->SUPER::pasthru;\n    return $old unless $self->is_make_type('nmake');\n    $old =~ s/(PASTHRU\\s*=\\s*)/$1 -nologo /;\n    $old;\n}\n\n\n=item arch_check (override)\n\nNormalize all arguments for consistency of comparison.\n\n=cut\n\nsub arch_check {\n    my $self = shift;\n\n    # Win32 is an XS module, minperl won't have it.\n    # arch_check() is not critical, so just fake it.\n    return 1 unless $self->can_load_xs;\n    return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @_);\n}\n\nsub _normalize_path_name {\n    my $self = shift;\n    my $file = shift;\n\n    require Win32;\n    my $short = Win32::GetShortPathName($file);\n    return defined $short ? lc $short : lc $file;\n}\n\n\n=item oneliner\n\nThese are based on what command.com does on Win98.  They may be wrong\nfor other Windows shells, I don't know.\n\n=cut\n\nsub oneliner {\n    my($self, $cmd, $switches) = @_;\n    $switches = [] unless defined $switches;\n\n    # Strip leading and trailing newlines\n    $cmd =~ s{^\\n+}{};\n    $cmd =~ s{\\n+$}{};\n\n    $cmd = $self->quote_literal($cmd);\n    $cmd = $self->escape_newlines($cmd);\n\n    $switches = join ' ', @$switches;\n\n    return qq{\\$(ABSPERLRUN) $switches -e $cmd --};\n}\n\n\nsub quote_literal {\n    my($self, $text, $opts) = @_;\n    $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};\n\n    # See: http://www.autohotkey.net/~deleyd/parameters/parameters.htm#CPP\n\n    # Apply the Microsoft C/C++ parsing rules\n    $text =~ s{\\\\\\\\\"}{\\\\\\\\\\\\\\\\\\\\\"}g;  # \\\\\" -> \\\\\\\\\\\"\n    $text =~ s{(?<!\\\\)\\\\\"}{\\\\\\\\\\\\\"}g; # \\\"  -> \\\\\\\"\n    $text =~ s{(?<!\\\\)\"}{\\\\\"}g;       # \"   -> \\\"\n    $text = qq{\"$text\"} if $text =~ /[ \\t]/;\n\n    # Apply the Command Prompt parsing rules (cmd.exe)\n    my @text = split /(\"[^\"]*\")/, $text;\n    # We should also escape parentheses, but it breaks one-liners containing\n    # $(MACRO)s in makefiles.\n    s{([<>|&^@!])}{^$1}g foreach grep { !/^\"[^\"]*\"$/ } @text;\n    $text = join('', @text);\n\n    # dmake expands {{ to { and }} to }.\n    if( $self->is_make_type('dmake') ) {\n        $text =~ s/{/{{/g;\n        $text =~ s/}/}}/g;\n    }\n\n    $text = $opts->{allow_variables}\n      ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);\n\n    return $text;\n}\n\n\nsub escape_newlines {\n    my($self, $text) = @_;\n\n    # Escape newlines\n    $text =~ s{\\n}{\\\\\\n}g;\n\n    return $text;\n}\n\n\n=item cd\n\ndmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It\nwants:\n\n    cd dir1\\dir2\n    command\n    another_command\n    cd ..\\..\n\n=cut\n\nsub cd {\n    my($self, $dir, @cmds) = @_;\n\n    return $self->SUPER::cd($dir, @cmds) unless $self->is_make_type('nmake');\n\n    my $cmd = join \"\\n\\t\", map \"$_\", @cmds;\n\n    my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));\n\n    # No leading tab and no trailing newline makes for easier embedding.\n    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;\ncd %s\n\t%s\n\tcd %s\nMAKE_FRAG\n\n    chomp $make_frag;\n\n    return $make_frag;\n}\n\n\n=item max_exec_len\n\nnmake 1.50 limits command length to 2048 characters.\n\n=cut\n\nsub max_exec_len {\n    my $self = shift;\n\n    return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;\n}\n\n\n=item os_flavor\n\nWindows is Win32.\n\n=cut\n\nsub os_flavor {\n    return('Win32');\n}\n\n\n=item cflags\n\nDefines the PERLDLL symbol if we are configured for static building since all\ncode destined for the perl5xx.dll must be compiled with the PERLDLL symbol\ndefined.\n\n=cut\n\nsub cflags {\n    my($self,$libperl)=@_;\n    return $self->{CFLAGS} if $self->{CFLAGS};\n    return '' unless $self->needs_linking();\n\n    my $base = $self->SUPER::cflags($libperl);\n    foreach (split /\\n/, $base) {\n        /^(\\S*)\\s*=\\s*(\\S*)$/ and $self->{$1} = $2;\n    };\n    $self->{CCFLAGS} .= \" -DPERLDLL\" if ($self->{LINKTYPE} eq 'static');\n\n    return $self->{CFLAGS} = qq{\nCCFLAGS = $self->{CCFLAGS}\nOPTIMIZE = $self->{OPTIMIZE}\nPERLTYPE = $self->{PERLTYPE}\n};\n\n}\n\n=item make_type\n\nReturns a suitable string describing the type of makefile being written.\n\n=cut\n\nsub make_type {\n    my ($self) = @_;\n    my $make = $self->make;\n    $make = +( File::Spec->splitpath( $make ) )[-1];\n    $make =~ s!\\.exe$!!i;\n    if ( $make =~ m![^A-Z0-9]!i ) {\n      ($make) = grep { m!make!i } split m![^A-Z0-9]!i, $make;\n    }\n    return \"$make-style\";\n}\n\n1;\n__END__\n\n=back\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_Unix.pm": "package ExtUtils::MM_Unix;\n\nrequire 5.006;\n\nuse strict;\n\nuse Carp;\nuse ExtUtils::MakeMaker::Config;\nuse File::Basename qw(basename dirname);\n\nour %Config_Override;\n\nuse ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);\n\n# If we make $VERSION an our variable parse_version() breaks\nuse vars qw($VERSION);\n$VERSION = '7.24';\n$VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]\n\nrequire ExtUtils::MM_Any;\nour @ISA = qw(ExtUtils::MM_Any);\n\nmy %Is;\nBEGIN {\n    $Is{OS2}     = $^O eq 'os2';\n    $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';\n    $Is{Dos}     = $^O eq 'dos';\n    $Is{VMS}     = $^O eq 'VMS';\n    $Is{OSF}     = $^O eq 'dec_osf';\n    $Is{IRIX}    = $^O eq 'irix';\n    $Is{NetBSD}  = $^O eq 'netbsd';\n    $Is{Interix} = $^O eq 'interix';\n    $Is{SunOS4}  = $^O eq 'sunos';\n    $Is{Solaris} = $^O eq 'solaris';\n    $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};\n    $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or\n                   grep( $^O eq $_, qw(bsdos interix dragonfly) )\n                  );\n    $Is{Android} = $^O =~ /android/;\n}\n\nBEGIN {\n    if( $Is{VMS} ) {\n        # For things like vmsify()\n        require VMS::Filespec;\n        VMS::Filespec->import;\n    }\n}\n\n\n=head1 NAME\n\nExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker\n\n=head1 SYNOPSIS\n\nC<require ExtUtils::MM_Unix;>\n\n=head1 DESCRIPTION\n\nThe methods provided by this package are designed to be used in\nconjunction with ExtUtils::MakeMaker. When MakeMaker writes a\nMakefile, it creates one or more objects that inherit their methods\nfrom a package C<MM>. MM itself doesn't provide any methods, but it\nISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating\nspecific packages take the responsibility for all the methods provided\nby MM_Unix. We are trying to reduce the number of the necessary\noverrides by defining rather primitive operations within\nExtUtils::MM_Unix.\n\nIf you are going to write a platform specific MM package, please try\nto limit the necessary overrides to primitive methods, and if it is not\npossible to do so, let's work out how to achieve that gain.\n\nIf you are overriding any of these methods in your Makefile.PL (in the\nMY class), please report that to the makemaker mailing list. We are\ntrying to minimize the necessary method overrides and switch to data\ndriven Makefile.PLs wherever possible. In the long run less methods\nwill be overridable via the MY class.\n\n=head1 METHODS\n\nThe following description of methods is still under\ndevelopment. Please refer to the code for not suitably documented\nsections and complain loudly to the makemaker@perl.org mailing list.\nBetter yet, provide a patch.\n\nNot all of the methods below are overridable in a\nMakefile.PL. Overridable methods are marked as (o). All methods are\noverridable by a platform specific MM_*.pm file.\n\nCross-platform methods are being moved into MM_Any.  If you can't find\nsomething that used to be in here, look in MM_Any.\n\n=cut\n\n# So we don't have to keep calling the methods over and over again,\n# we have these globals to cache the values.  Faster and shrtr.\nmy $Curdir  = __PACKAGE__->curdir;\nmy $Updir   = __PACKAGE__->updir;\n\n\n=head2 Methods\n\n=over 4\n\n=item os_flavor\n\nSimply says that we're Unix.\n\n=cut\n\nsub os_flavor {\n    return('Unix');\n}\n\n\n=item c_o (o)\n\nDefines the suffix rules to compile different flavors of C files to\nobject files.\n\n=cut\n\nsub c_o {\n# --- Translation Sections ---\n\n    my($self) = shift;\n    return '' unless $self->needs_linking();\n    my(@m);\n\n    my $command = '$(CCCMD)';\n    my $flags   = '$(CCCDLFLAGS) \"-I$(PERL_INC)\" $(PASTHRU_DEFINE) $(DEFINE)';\n\n    if (my $cpp = $Config{cpprun}) {\n        my $cpp_cmd = $self->const_cccmd;\n        $cpp_cmd =~ s/^CCCMD\\s*=\\s*\\$\\(CC\\)/$cpp/;\n        push @m, qq{\n.c.i:\n\t$cpp_cmd $flags \\$*.c > \\$*.i\n};\n    }\n\n    my $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*.s') : '';\n    push @m, sprintf <<'EOF', $command, $flags, $m_o;\n\n.c.s :\n\t%s -S %s $*.c %s\nEOF\n\n    my @exts = qw(c cpp cxx cc);\n    push @exts, 'C' if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific\n    $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*$(OBJ_EXT)') : '';\n    for my $ext (@exts) {\n\tpush @m, \"\\n.$ext\\$(OBJ_EXT) :\\n\\t$command $flags \\$*.$ext\" . ( $m_o ? \" $m_o\" : '' ) . \"\\n\";\n    }\n    return join \"\", @m;\n}\n\n\n=item xs_obj_opt\n\nTakes the object file as an argument, and returns the portion of compile\ncommand-line that will output to the specified object file.\n\n=cut\n\nsub xs_obj_opt {\n    my ($self, $output_file) = @_;\n    \"-o $output_file\";\n}\n\n\n=item cflags (o)\n\nDoes very much the same as the cflags script in the perl\ndistribution. It doesn't return the whole compiler command line, but\ninitializes all of its parts. The const_cccmd method then actually\nreturns the definition of the CCCMD macro which uses these parts.\n\n=cut\n\n#'\n\nsub cflags {\n    my($self,$libperl)=@_;\n    return $self->{CFLAGS} if $self->{CFLAGS};\n    return '' unless $self->needs_linking();\n\n    my($prog, $uc, $perltype, %cflags);\n    $libperl ||= $self->{LIBPERL_A} || \"libperl$self->{LIB_EXT}\" ;\n    $libperl =~ s/\\.\\$\\(A\\)$/$self->{LIB_EXT}/;\n\n    @cflags{qw(cc ccflags optimize shellflags)}\n\t= @Config{qw(cc ccflags optimize shellflags)};\n\n    # Perl 5.21.4 adds the (gcc) warning (-Wall ...) and std (-std=c89)\n    # flags to the %Config, and the modules in the core should be built\n    # with the warning flags, but NOT the -std=c89 flags (the latter\n    # would break using any system header files that are strict C99).\n    my @ccextraflags = qw(ccwarnflags);\n    if ($ENV{PERL_CORE}) {\n      for my $x (@ccextraflags) {\n        if (exists $Config{$x}) {\n          $cflags{$x} = $Config{$x};\n        }\n      }\n    }\n\n    my($optdebug) = \"\";\n\n    $cflags{shellflags} ||= '';\n\n    my(%map) =  (\n\t\tD =>   '-DDEBUGGING',\n\t\tE =>   '-DEMBED',\n\t\tDE =>  '-DDEBUGGING -DEMBED',\n\t\tM =>   '-DEMBED -DMULTIPLICITY',\n\t\tDM =>  '-DDEBUGGING -DEMBED -DMULTIPLICITY',\n\t\t);\n\n    if ($libperl =~ /libperl(\\w*)\\Q$self->{LIB_EXT}/){\n\t$uc = uc($1);\n    } else {\n\t$uc = \"\"; # avoid warning\n    }\n    $perltype = $map{$uc} ? $map{$uc} : \"\";\n\n    if ($uc =~ /^D/) {\n\t$optdebug = \"-g\";\n    }\n\n\n    my($name);\n    ( $name = $self->{NAME} . \"_cflags\" ) =~ s/:/_/g ;\n    if ($prog = $Config{$name}) {\n\t# Expand hints for this extension via the shell\n\tprint \"Processing $name hint:\\n\" if $Verbose;\n\tmy(@o)=`cc=\\\"$cflags{cc}\\\"\n\t  ccflags=\\\"$cflags{ccflags}\\\"\n\t  optimize=\\\"$cflags{optimize}\\\"\n\t  perltype=\\\"$cflags{perltype}\\\"\n\t  optdebug=\\\"$cflags{optdebug}\\\"\n\t  eval '$prog'\n\t  echo cc=\\$cc\n\t  echo ccflags=\\$ccflags\n\t  echo optimize=\\$optimize\n\t  echo perltype=\\$perltype\n\t  echo optdebug=\\$optdebug\n\t  `;\n\tforeach my $line (@o){\n\t    chomp $line;\n\t    if ($line =~ /(.*?)=\\s*(.*)\\s*$/){\n\t\t$cflags{$1} = $2;\n\t\tprint \"\t$1 = $2\\n\" if $Verbose;\n\t    } else {\n\t\tprint \"Unrecognised result from hint: '$line'\\n\";\n\t    }\n\t}\n    }\n\n    if ($optdebug) {\n\t$cflags{optimize} = $optdebug;\n    }\n\n    for (qw(ccflags optimize perltype)) {\n        $cflags{$_} ||= '';\n\t$cflags{$_} =~ s/^\\s+//;\n\t$cflags{$_} =~ s/\\s+/ /g;\n\t$cflags{$_} =~ s/\\s+$//;\n\t$self->{uc $_} ||= $cflags{$_};\n    }\n\n    if ($self->{POLLUTE}) {\n\t$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';\n    }\n\n    for my $x (@ccextraflags) {\n      next unless exists $cflags{$x};\n      $self->{CCFLAGS} .= $cflags{$x} =~ m!^\\s! ? $cflags{$x} : ' ' . $cflags{$x};\n    }\n\n    my $pollute = '';\n    if ($Config{usemymalloc} and not $Config{bincompat5005}\n\tand not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\\b/\n\tand $self->{PERL_MALLOC_OK}) {\n\t$pollute = '$(PERL_MALLOC_DEF)';\n    }\n\n    return $self->{CFLAGS} = qq{\nCCFLAGS = $self->{CCFLAGS}\nOPTIMIZE = $self->{OPTIMIZE}\nPERLTYPE = $self->{PERLTYPE}\nMPOLLUTE = $pollute\n};\n\n}\n\n\n=item const_cccmd (o)\n\nReturns the full compiler call for C programs and stores the\ndefinition in CONST_CCCMD.\n\n=cut\n\nsub const_cccmd {\n    my($self,$libperl)=@_;\n    return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};\n    return '' unless $self->needs_linking();\n    return $self->{CONST_CCCMD} =\n\tq{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\\\\n\t$(CCFLAGS) $(OPTIMIZE) \\\\\n\t$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\\\\n\t$(XS_DEFINE_VERSION)};\n}\n\n=item const_config (o)\n\nSets SHELL if needed, then defines a couple of constants in the Makefile\nthat are imported from %Config.\n\n=cut\n\nsub const_config {\n# --- Constants Sections ---\n\n    my($self) = shift;\n    my @m = $self->specify_shell(); # Usually returns empty string\n    push @m, <<\"END\";\n\n# These definitions are from config.sh (via $INC{'Config.pm'}).\n# They may have been overridden via Makefile.PL or on the command line.\nEND\n\n    my(%once_only);\n    foreach my $key (@{$self->{CONFIG}}){\n        # SITE*EXP macros are defined in &constants; avoid duplicates here\n        next if $once_only{$key};\n        push @m, uc($key) , ' = ' , $self->{uc $key}, \"\\n\";\n        $once_only{$key} = 1;\n    }\n    join('', @m);\n}\n\n=item const_loadlibs (o)\n\nDefines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See\nL<ExtUtils::Liblist> for details.\n\n=cut\n\nsub const_loadlibs {\n    my($self) = shift;\n    return \"\" unless $self->needs_linking;\n    my @m;\n    push @m, qq{\n# $self->{NAME} might depend on some other libraries:\n# See ExtUtils::Liblist for details\n#\n};\n    for my $tmp (qw/\n         EXTRALIBS LDLOADLIBS BSLOADLIBS\n         /) {\n        next unless defined $self->{$tmp};\n        push @m, \"$tmp = $self->{$tmp}\\n\";\n    }\n    # don't set LD_RUN_PATH if empty\n    for my $tmp (qw/\n         LD_RUN_PATH\n         /) {\n        next unless $self->{$tmp};\n        push @m, \"$tmp = $self->{$tmp}\\n\";\n    }\n    return join \"\", @m;\n}\n\n=item constants (o)\n\n  my $make_frag = $mm->constants;\n\nPrints out macros for lots of constants.\n\n=cut\n\nsub constants {\n    my($self) = @_;\n    my @m = ();\n\n    $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use\n\n    for my $macro (qw(\n\n              AR_STATIC_ARGS DIRFILESEP DFSEP\n              NAME NAME_SYM\n              VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION\n              XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION\n              INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB\n              INST_MAN1DIR INST_MAN3DIR\n              MAN1EXT      MAN3EXT\n              INSTALLDIRS INSTALL_BASE DESTDIR PREFIX\n              PERLPREFIX      SITEPREFIX      VENDORPREFIX\n                   ),\n                   (map { (\"INSTALL\".$_,\n                          \"DESTINSTALL\".$_)\n                        } $self->installvars),\n                   qw(\n              PERL_LIB\n              PERL_ARCHLIB PERL_ARCHLIBDEP\n              LIBPERL_A MYEXTLIB\n              FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE\n              PERLMAINCC PERL_SRC PERL_INC PERL_INCDEP\n              PERL            FULLPERL          ABSPERL\n              PERLRUN         FULLPERLRUN       ABSPERLRUN\n              PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST\n              PERL_CORE\n              PERM_DIR PERM_RW PERM_RWX\n\n\t      ) )\n    {\n\tnext unless defined $self->{$macro};\n\n        # pathnames can have sharp signs in them; escape them so\n        # make doesn't think it is a comment-start character.\n        $self->{$macro} =~ s/#/\\\\#/g;\n\t$self->{$macro} = $self->quote_dep($self->{$macro})\n\t  if $ExtUtils::MakeMaker::macro_dep{$macro};\n\tpush @m, \"$macro = $self->{$macro}\\n\";\n    }\n\n    push @m, qq{\nMAKEMAKER   = $self->{MAKEMAKER}\nMM_VERSION  = $self->{MM_VERSION}\nMM_REVISION = $self->{MM_REVISION}\n};\n\n    push @m, q{\n# FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).\n# BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)\n# PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)\n# DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.\n};\n\n    for my $macro (qw/\n              MAKE\n\t      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT\n\t      LDFROM LINKTYPE BOOTDEP\n\t      /\t)\n    {\n\tnext unless defined $self->{$macro};\n\tpush @m, \"$macro = $self->{$macro}\\n\";\n    }\n\n    push @m, \"\n# Handy lists of source code files:\nXS_FILES = \".$self->wraplist(sort keys %{$self->{XS}}).\"\nC_FILES  = \".$self->wraplist(sort @{$self->{C}}).\"\nO_FILES  = \".$self->wraplist(sort @{$self->{O_FILES}}).\"\nH_FILES  = \".$self->wraplist(sort @{$self->{H}}).\"\nMAN1PODS = \".$self->wraplist(sort keys %{$self->{MAN1PODS}}).\"\nMAN3PODS = \".$self->wraplist(sort keys %{$self->{MAN3PODS}}).\"\n\";\n\n\n    push @m, q{\n# Where is the Config information that we are using/depend on\nCONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_INCDEP)$(DFSEP)config.h\n} if -e $self->catfile( $self->{PERL_INC}, 'config.h' );\n\n\n    push @m, qq{\n# Where to build things\nINST_LIBDIR      = $self->{INST_LIBDIR}\nINST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}\n\nINST_AUTODIR     = $self->{INST_AUTODIR}\nINST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}\n\nINST_STATIC      = $self->{INST_STATIC}\nINST_DYNAMIC     = $self->{INST_DYNAMIC}\nINST_BOOT        = $self->{INST_BOOT}\n};\n\n    push @m, qq{\n# Extra linker info\nEXPORT_LIST        = $self->{EXPORT_LIST}\nPERL_ARCHIVE       = $self->{PERL_ARCHIVE}\nPERL_ARCHIVEDEP    = $self->{PERL_ARCHIVEDEP}\nPERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}\n};\n\n    push @m, \"\n\nTO_INST_PM = \".$self->wraplist(map $self->quote_dep($_), sort keys %{$self->{PM}}).\"\\n\";\n\n    join('',@m);\n}\n\n\n=item depend (o)\n\nSame as macro for the depend attribute.\n\n=cut\n\nsub depend {\n    my($self,%attribs) = @_;\n    my(@m,$key,$val);\n    for my $key (sort keys %attribs){\n\tmy $val = $attribs{$key};\n\tnext unless defined $key and defined $val;\n\tpush @m, \"$key : $val\\n\";\n    }\n    join \"\", @m;\n}\n\n\n=item init_DEST\n\n  $mm->init_DEST\n\nDefines the DESTDIR and DEST* variables paralleling the INSTALL*.\n\n=cut\n\nsub init_DEST {\n    my $self = shift;\n\n    # Initialize DESTDIR\n    $self->{DESTDIR} ||= '';\n\n    # Make DEST variables.\n    foreach my $var ($self->installvars) {\n        my $destvar = 'DESTINSTALL'.$var;\n        $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';\n    }\n}\n\n\n=item init_dist\n\n  $mm->init_dist;\n\nDefines a lot of macros for distribution support.\n\n  macro         description                     default\n\n  TAR           tar command to use              tar\n  TARFLAGS      flags to pass to TAR            cvf\n\n  ZIP           zip command to use              zip\n  ZIPFLAGS      flags to pass to ZIP            -r\n\n  COMPRESS      compression command to          gzip --best\n                use for tarfiles\n  SUFFIX        suffix to put on                .gz\n                compressed files\n\n  SHAR          shar command to use             shar\n\n  PREOP         extra commands to run before\n                making the archive\n  POSTOP        extra commands to run after\n                making the archive\n\n  TO_UNIX       a command to convert linefeeds\n                to Unix style in your archive\n\n  CI            command to checkin your         ci -u\n                sources to version control\n  RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q\n                just after CI is run\n\n  DIST_CP       $how argument to manicopy()     best\n                when the distdir is created\n\n  DIST_DEFAULT  default target to use to        tardist\n                create a distribution\n\n  DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)\n                (minus suffixes)\n\n=cut\n\nsub init_dist {\n    my $self = shift;\n\n    $self->{TAR}      ||= 'tar';\n    $self->{TARFLAGS} ||= 'cvf';\n    $self->{ZIP}      ||= 'zip';\n    $self->{ZIPFLAGS} ||= '-r';\n    $self->{COMPRESS} ||= 'gzip --best';\n    $self->{SUFFIX}   ||= '.gz';\n    $self->{SHAR}     ||= 'shar';\n    $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST\n    $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir\n    $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';\n\n    $self->{CI}       ||= 'ci -u';\n    $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';\n    $self->{DIST_CP}  ||= 'best';\n    $self->{DIST_DEFAULT} ||= 'tardist';\n\n    ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};\n    $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};\n}\n\n=item dist (o)\n\n  my $dist_macros = $mm->dist(%overrides);\n\nGenerates a make fragment defining all the macros initialized in\ninit_dist.\n\n%overrides can be used to override any of the above.\n\n=cut\n\nsub dist {\n    my($self, %attribs) = @_;\n\n    my $make = '';\n    if ( $attribs{SUFFIX} && $attribs{SUFFIX} !~ m!^\\.! ) {\n      $attribs{SUFFIX} = '.' . $attribs{SUFFIX};\n    }\n    foreach my $key (qw(\n            TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR\n            PREOP POSTOP TO_UNIX\n            CI RCS_LABEL DIST_CP DIST_DEFAULT\n            DISTNAME DISTVNAME\n           ))\n    {\n        my $value = $attribs{$key} || $self->{$key};\n        $make .= \"$key = $value\\n\";\n    }\n\n    return $make;\n}\n\n=item dist_basics (o)\n\nDefines the targets distclean, distcheck, skipcheck, manifest, veryclean.\n\n=cut\n\nsub dist_basics {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\ndistclean :: realclean distcheck\n\t$(NOECHO) $(NOOP)\n\ndistcheck :\n\t$(PERLRUN) \"-MExtUtils::Manifest=fullcheck\" -e fullcheck\n\nskipcheck :\n\t$(PERLRUN) \"-MExtUtils::Manifest=skipcheck\" -e skipcheck\n\nmanifest :\n\t$(PERLRUN) \"-MExtUtils::Manifest=mkmanifest\" -e mkmanifest\n\nveryclean : realclean\n\t$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old\n\nMAKE_FRAG\n\n}\n\n=item dist_ci (o)\n\nDefines a check in target for RCS.\n\n=cut\n\nsub dist_ci {\n    my($self) = shift;\n    return sprintf \"ci :\\n\\t%s\\n\", $self->oneliner(<<'EOF', [qw(-MExtUtils::Manifest=maniread)]);\n@all = sort keys %{ maniread() };\nprint(qq{Executing $(CI) @all\\n});\nsystem(qq{$(CI) @all}) == 0 or die $!;\nprint(qq{Executing $(RCS_LABEL) ...\\n});\nsystem(qq{$(RCS_LABEL) @all}) == 0 or die $!;\nEOF\n}\n\n=item dist_core (o)\n\n  my $dist_make_fragment = $MM->dist_core;\n\nPuts the targets necessary for 'make dist' together into one make\nfragment.\n\n=cut\n\nsub dist_core {\n    my($self) = shift;\n\n    my $make_frag = '';\n    foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile\n                           shdist))\n    {\n        my $method = $target.'_target';\n        $make_frag .= \"\\n\";\n        $make_frag .= $self->$method();\n    }\n\n    return $make_frag;\n}\n\n\n=item B<dist_target>\n\n  my $make_frag = $MM->dist_target;\n\nReturns the 'dist' target to make an archive for distribution.  This\ntarget simply checks to make sure the Makefile is up-to-date and\ndepends on $(DIST_DEFAULT).\n\n=cut\n\nsub dist_target {\n    my($self) = shift;\n\n    my $date_check = $self->oneliner(<<'CODE', ['-l']);\nprint 'Warning: Makefile possibly out of date with $(VERSION_FROM)'\n    if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';\nCODE\n\n    return sprintf <<'MAKE_FRAG', $date_check;\ndist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)\n\t$(NOECHO) %s\nMAKE_FRAG\n}\n\n=item B<tardist_target>\n\n  my $make_frag = $MM->tardist_target;\n\nReturns the 'tardist' target which is simply so 'make tardist' works.\nThe real work is done by the dynamically named tardistfile_target()\nmethod, tardist should have that as a dependency.\n\n=cut\n\nsub tardist_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\ntardist : $(DISTVNAME).tar$(SUFFIX)\n\t$(NOECHO) $(NOOP)\nMAKE_FRAG\n}\n\n=item B<zipdist_target>\n\n  my $make_frag = $MM->zipdist_target;\n\nReturns the 'zipdist' target which is simply so 'make zipdist' works.\nThe real work is done by the dynamically named zipdistfile_target()\nmethod, zipdist should have that as a dependency.\n\n=cut\n\nsub zipdist_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\nzipdist : $(DISTVNAME).zip\n\t$(NOECHO) $(NOOP)\nMAKE_FRAG\n}\n\n=item B<tarfile_target>\n\n  my $make_frag = $MM->tarfile_target;\n\nThe name of this target is the name of the tarball generated by\ntardist.  This target does the actual work of turning the distdir into\na tarball.\n\n=cut\n\nsub tarfile_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\n$(DISTVNAME).tar$(SUFFIX) : distdir\n\t$(PREOP)\n\t$(TO_UNIX)\n\t$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)\n\t$(RM_RF) $(DISTVNAME)\n\t$(COMPRESS) $(DISTVNAME).tar\n\t$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'\n\t$(POSTOP)\nMAKE_FRAG\n}\n\n=item zipfile_target\n\n  my $make_frag = $MM->zipfile_target;\n\nThe name of this target is the name of the zip file generated by\nzipdist.  This target does the actual work of turning the distdir into\na zip file.\n\n=cut\n\nsub zipfile_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\n$(DISTVNAME).zip : distdir\n\t$(PREOP)\n\t$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)\n\t$(RM_RF) $(DISTVNAME)\n\t$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'\n\t$(POSTOP)\nMAKE_FRAG\n}\n\n=item uutardist_target\n\n  my $make_frag = $MM->uutardist_target;\n\nConverts the tarfile into a uuencoded file\n\n=cut\n\nsub uutardist_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\nuutardist : $(DISTVNAME).tar$(SUFFIX)\n\tuuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu\n\t$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'\nMAKE_FRAG\n}\n\n\n=item shdist_target\n\n  my $make_frag = $MM->shdist_target;\n\nConverts the distdir into a shell archive.\n\n=cut\n\nsub shdist_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\nshdist : distdir\n\t$(PREOP)\n\t$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar\n\t$(RM_RF) $(DISTVNAME)\n\t$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'\n\t$(POSTOP)\nMAKE_FRAG\n}\n\n\n=item dlsyms (o)\n\nUsed by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.\n\nNormally just returns an empty string.\n\n=cut\n\nsub dlsyms {\n    return '';\n}\n\n\n=item dynamic_bs (o)\n\nDefines targets for bootstrap files.\n\n=cut\n\nsub dynamic_bs {\n    my($self, %attribs) = @_;\n    return \"\\nBOOTSTRAP =\\n\" unless $self->has_link_code();\n    my @exts;\n    if ($self->{XSMULTI}) {\n\t@exts = $self->_xs_list_basenames;\n    } else {\n\t@exts = '$(BASEEXT)';\n    }\n    return join \"\\n\",\n        \"BOOTSTRAP = @{[map { qq{$_.bs} } @exts]}\\n\",\n        map { $self->_xs_make_bs($_) } @exts;\n}\n\nsub _xs_make_bs {\n    my ($self, $basename) = @_;\n    my ($v, $d, $f) = File::Spec->splitpath($basename);\n    my @d = File::Spec->splitdir($d);\n    shift @d if $self->{XSMULTI} and $d[0] eq 'lib';\n    my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);\n    $instdir = '$(INST_ARCHAUTODIR)' if $basename eq '$(BASEEXT)';\n    my $instfile = $self->catfile($instdir, \"$f.bs\");\n    my $exists = \"$instdir\\$(DFSEP).exists\"; # match blibdirs_target\n    #                                 1          2          3\n    return _sprintf562 <<'MAKE_FRAG', $basename, $instfile, $exists;\n# As Mkbootstrap might not write a file (if none is required)\n# we use touch to prevent make continually trying to remake it.\n# The DynaLoader only reads a non-empty file.\n%1$s.bs : $(FIRST_MAKEFILE) $(BOOTDEP)\n\t$(NOECHO) $(ECHO) \"Running Mkbootstrap for %1$s ($(BSLOADLIBS))\"\n\t$(NOECHO) $(PERLRUN) \\\n\t\t\"-MExtUtils::Mkbootstrap\" \\\n\t\t-e \"Mkbootstrap('%1$s','$(BSLOADLIBS)');\"\n\t$(NOECHO) $(TOUCH) \"%1$s.bs\"\n\t$(CHMOD) $(PERM_RW) \"%1$s.bs\"\n\n%2$s : %1$s.bs %3$s\n\t$(NOECHO) $(RM_RF) %2$s\n\t- $(CP_NONEMPTY) %1$s.bs %2$s $(PERM_RW)\nMAKE_FRAG\n}\n\n=item dynamic_lib (o)\n\nDefines how to produce the *.so (or equivalent) files.\n\n=cut\n\nsub dynamic_lib {\n    my($self, %attribs) = @_;\n    return '' unless $self->needs_linking(); #might be because of a subdir\n    return '' unless $self->has_link_code;\n    my @m = $self->xs_dynamic_lib_macros(\\%attribs);\n    my @libs;\n    if ($self->{XSMULTI}) {\n        my @exts = $self->_xs_list_basenames;\n        for my $ext (@exts) {\n            my ($v, $d, $f) = File::Spec->splitpath($ext);\n            my @d = File::Spec->splitdir($d);\n            shift @d if $d[0] eq 'lib';\n            my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);\n\n            # Dynamic library names may need special handling.\n            eval { require DynaLoader };\n            if (defined &DynaLoader::mod2fname) {\n                $f = &DynaLoader::mod2fname([@d, $f]);\n            }\n\n            my $instfile = $self->catfile($instdir, \"$f.\\$(DLEXT)\");\n            my $objfile = $self->_xsbuild_value('xs', $ext, 'OBJECT');\n            $objfile = \"$ext\\$(OBJ_EXT)\" unless defined $objfile;\n            my $ldfrom = $self->_xsbuild_value('xs', $ext, 'LDFROM');\n            $ldfrom = $objfile unless defined $ldfrom;\n            my $exportlist = \"$ext.def\";\n            push @libs, [ $objfile, $instfile, $instdir, $ldfrom, $exportlist ];\n        }\n    } else {\n        @libs = ([ qw($(OBJECT) $(INST_DYNAMIC) $(INST_ARCHAUTODIR) $(LDFROM) $(EXPORT_LIST)) ]);\n    }\n    push @m, map { $self->xs_make_dynamic_lib(\\%attribs, @$_); } @libs;\n\n    return join(\"\\n\",@m);\n}\n\n=item xs_dynamic_lib_macros\n\nDefines the macros for the C<dynamic_lib> section.\n\n=cut\n\nsub xs_dynamic_lib_macros {\n    my ($self, $attribs) = @_;\n    my $otherldflags = $attribs->{OTHERLDFLAGS} || \"\";\n    my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || \"\";\n    my $armaybe = $self->_xs_armaybe($attribs);\n    my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : ''; # Useful on other systems too?\n    my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@ && sh -c false )' : '';\n    sprintf <<'EOF', $armaybe, $ld_opt.$otherldflags, $inst_dynamic_dep, $ld_fix;\n# This section creates the dynamically loadable objects from relevant\n# objects and possibly $(MYEXTLIB).\nARMAYBE = %s\nOTHERLDFLAGS = %s\nINST_DYNAMIC_DEP = %s\nINST_DYNAMIC_FIX = %s\nEOF\n}\n\nsub _xs_armaybe {\n    my ($self, $attribs) = @_;\n    my $armaybe = $attribs->{ARMAYBE} || $self->{ARMAYBE} || \":\";\n    $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');\n    $armaybe;\n}\n\n=item xs_make_dynamic_lib\n\nDefines the recipes for the C<dynamic_lib> section.\n\n=cut\n\nsub xs_make_dynamic_lib {\n    my ($self, $attribs, $object, $to, $todir, $ldfrom, $exportlist) = @_;\n    $exportlist = '' if $exportlist ne '$(EXPORT_LIST)';\n    my $armaybe = $self->_xs_armaybe($attribs);\n    my @m = sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)'.\"\\n\", $to, $object, $todir, $exportlist;\n    if ($armaybe ne ':'){\n        $ldfrom = 'tmp$(LIB_EXT)';\n        push(@m,\"\t\\$(ARMAYBE) cr $ldfrom $object\\n\");\n        push(@m,\"\t\\$(RANLIB) $ldfrom\\n\");\n    }\n    $ldfrom = \"-all $ldfrom -none\" if $Is{OSF};\n\n    # The IRIX linker doesn't use LD_RUN_PATH\n    my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?\n                       qq{-rpath \"$self->{LD_RUN_PATH}\"} : '';\n\n    # For example in AIX the shared objects/libraries from previous builds\n    # linger quite a while in the shared dynalinker cache even when nobody\n    # is using them.  This is painful if one for instance tries to restart\n    # a failed build because the link command will fail unnecessarily 'cos\n    # the shared object/library is 'busy'.\n    push(@m,\"\t\\$(RM_F) \\$\\@\\n\");\n\n    my $libs = '$(LDLOADLIBS)';\n    if (($Is{NetBSD} || $Is{Interix} || $Is{Android}) && $Config{'useshrplib'} eq 'true') {\n        # Use nothing on static perl platforms, and to the flags needed\n        # to link against the shared libperl library on shared perl\n        # platforms.  We peek at lddlflags to see if we need -Wl,-R\n        # or -R to add paths to the run-time library search path.\n        if ($Config{'lddlflags'} =~ /-Wl,-R/) {\n            $libs .= ' \"-L$(PERL_INC)\" \"-Wl,-R$(INSTALLARCHLIB)/CORE\" \"-Wl,-R$(PERL_ARCHLIB)/CORE\" -lperl';\n        } elsif ($Config{'lddlflags'} =~ /-R/) {\n            $libs .= ' \"-L$(PERL_INC)\" \"-R$(INSTALLARCHLIB)/CORE\" \"-R$(PERL_ARCHLIB)/CORE\" -lperl';\n        } elsif ( $Is{Android} ) {\n            # The Android linker will not recognize symbols from\n            # libperl unless the module explicitly depends on it.\n            $libs .= ' \"-L$(PERL_INC)\" -lperl';\n        }\n    }\n\n    my $ld_run_path_shell = \"\";\n    if ($self->{LD_RUN_PATH} ne \"\") {\n        $ld_run_path_shell = 'LD_RUN_PATH=\"$(LD_RUN_PATH)\" ';\n    }\n\n    push @m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $ldfrom, $self->xs_obj_opt('$@'), $libs, $exportlist;\n\t%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) %s $(MYEXTLIB) \\\n\t  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) %s \\\n\t  $(INST_DYNAMIC_FIX)\n\t$(CHMOD) $(PERM_RWX) $@\nMAKE\n    join '', @m;\n}\n\n=item exescan\n\nDeprecated method. Use libscan instead.\n\n=cut\n\nsub exescan {\n    my($self,$path) = @_;\n    $path;\n}\n\n=item extliblist\n\nCalled by init_others, and calls ext ExtUtils::Liblist. See\nL<ExtUtils::Liblist> for details.\n\n=cut\n\nsub extliblist {\n    my($self,$libs) = @_;\n    require ExtUtils::Liblist;\n    $self->ext($libs, $Verbose);\n}\n\n=item find_perl\n\nFinds the executables PERL and FULLPERL\n\n=cut\n\nsub find_perl {\n    my($self, $ver, $names, $dirs, $trace) = @_;\n\n    if ($trace >= 2){\n        print \"Looking for perl $ver by these names:\n@$names\nin these dirs:\n@$dirs\n\";\n    }\n\n    my $stderr_duped = 0;\n    local *STDERR_COPY;\n\n    unless ($Is{BSD}) {\n        # >& and lexical filehandles together give 5.6.2 indigestion\n        if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic\n            $stderr_duped = 1;\n        }\n        else {\n            warn <<WARNING;\nfind_perl() can't dup STDERR: $!\nYou might see some garbage while we search for Perl\nWARNING\n        }\n    }\n\n    foreach my $name (@$names){\n        my ($abs, $use_dir);\n        if ($self->file_name_is_absolute($name)) {     # /foo/bar\n            $abs = $name;\n        } elsif ($self->canonpath($name) eq\n                 $self->canonpath(basename($name))) {  # foo\n            $use_dir = 1;\n        } else {                                            # foo/bar\n            $abs = $self->catfile($Curdir, $name);\n        }\n        foreach my $dir ($use_dir ? @$dirs : 1){\n            next unless defined $dir; # $self->{PERL_SRC} may be undefined\n\n            $abs = $self->catfile($dir, $name)\n                if $use_dir;\n\n            print \"Checking $abs\\n\" if ($trace >= 2);\n            next unless $self->maybe_command($abs);\n            print \"Executing $abs\\n\" if ($trace >= 2);\n\n            my $val;\n            my $version_check = qq{\"$abs\" -le \"require $ver; print qq{VER_OK}\"};\n\n            # To avoid using the unportable 2>&1 to suppress STDERR,\n            # we close it before running the command.\n            # However, thanks to a thread library bug in many BSDs\n            # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )\n            # we cannot use the fancier more portable way in here\n            # but instead need to use the traditional 2>&1 construct.\n            if ($Is{BSD}) {\n                $val = `$version_check 2>&1`;\n            } else {\n                close STDERR if $stderr_duped;\n                $val = `$version_check`;\n\n                # 5.6.2's 3-arg open doesn't work with >&\n                open STDERR, \">&STDERR_COPY\"  ## no critic\n                        if $stderr_duped;\n            }\n\n            if ($val =~ /^VER_OK/m) {\n                print \"Using PERL=$abs\\n\" if $trace;\n                return $abs;\n            } elsif ($trace >= 2) {\n                print \"Result: '$val' \".($? >> 8).\"\\n\";\n            }\n        }\n    }\n    print \"Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\\n\";\n    0; # false and not empty\n}\n\n\n=item fixin\n\n  $mm->fixin(@files);\n\nInserts the sharpbang or equivalent magic number to a set of @files.\n\n=cut\n\nsub fixin {    # stolen from the pink Camel book, more or less\n    my ( $self, @files ) = @_;\n\n    for my $file (@files) {\n        my $file_new = \"$file.new\";\n        my $file_bak = \"$file.bak\";\n\n        open( my $fixin, '<', $file ) or croak \"Can't process '$file': $!\";\n        local $/ = \"\\n\";\n        chomp( my $line = <$fixin> );\n        next unless $line =~ s/^\\s*\\#!\\s*//;    # Not a shebang file.\n\n        my $shb = $self->_fixin_replace_shebang( $file, $line );\n        next unless defined $shb;\n\n        open( my $fixout, \">\", \"$file_new\" ) or do {\n            warn \"Can't create new $file: $!\\n\";\n            next;\n        };\n\n        # Print out the new #! line (or equivalent).\n        local $\\;\n        local $/;\n        print $fixout $shb, <$fixin>;\n        close $fixin;\n        close $fixout;\n\n        chmod 0666, $file_bak;\n        unlink $file_bak;\n        unless ( _rename( $file, $file_bak ) ) {\n            warn \"Can't rename $file to $file_bak: $!\";\n            next;\n        }\n        unless ( _rename( $file_new, $file ) ) {\n            warn \"Can't rename $file_new to $file: $!\";\n            unless ( _rename( $file_bak, $file ) ) {\n                warn \"Can't rename $file_bak back to $file either: $!\";\n                warn \"Leaving $file renamed as $file_bak\\n\";\n            }\n            next;\n        }\n        unlink $file_bak;\n    }\n    continue {\n        system(\"$Config{'eunicefix'} $file\") if $Config{'eunicefix'} ne ':';\n    }\n}\n\n\nsub _rename {\n    my($old, $new) = @_;\n\n    foreach my $file ($old, $new) {\n        if( $Is{VMS} and basename($file) !~ /\\./ ) {\n            # rename() in 5.8.0 on VMS will not rename a file if it\n            # does not contain a dot yet it returns success.\n            $file = \"$file.\";\n        }\n    }\n\n    return rename($old, $new);\n}\n\nsub _fixin_replace_shebang {\n    my ( $self, $file, $line ) = @_;\n\n    # Now figure out the interpreter name.\n    my ( $cmd, $arg ) = split ' ', $line, 2;\n    $cmd =~ s!^.*/!!;\n\n    # Now look (in reverse) for interpreter in absolute PATH (unless perl).\n    my $interpreter;\n    if ( $cmd =~ m{^perl(?:\\z|[^a-z])} ) {\n        if ( $Config{startperl} =~ m,^\\#!.*/perl, ) {\n            $interpreter = $Config{startperl};\n            $interpreter =~ s,^\\#!,,;\n        }\n        else {\n            $interpreter = $Config{perlpath};\n        }\n    }\n    else {\n        my (@absdirs)\n            = reverse grep { $self->file_name_is_absolute($_) } $self->path;\n        $interpreter = '';\n\n        foreach my $dir (@absdirs) {\n            my $maybefile = $self->catfile($dir,$cmd);\n            if ( $self->maybe_command($maybefile) ) {\n                warn \"Ignoring $interpreter in $file\\n\"\n                    if $Verbose && $interpreter;\n                $interpreter = $maybefile;\n            }\n        }\n    }\n\n    # Figure out how to invoke interpreter on this machine.\n\n    my ($does_shbang) = $Config{'sharpbang'} =~ /^\\s*\\#\\!/;\n    my ($shb) = \"\";\n    if ($interpreter) {\n        print \"Changing sharpbang in $file to $interpreter\"\n            if $Verbose;\n         # this is probably value-free on DOSISH platforms\n        if ($does_shbang) {\n            $shb .= \"$Config{'sharpbang'}$interpreter\";\n            $shb .= ' ' . $arg if defined $arg;\n            $shb .= \"\\n\";\n        }\n    }\n    else {\n        warn \"Can't find $cmd in PATH, $file unchanged\"\n            if $Verbose;\n        return;\n    }\n    return $shb\n}\n\n=item force (o)\n\nWrites an empty FORCE: target.\n\n=cut\n\nsub force {\n    my($self) = shift;\n    '# Phony target to force checking subdirectories.\nFORCE :\n\t$(NOECHO) $(NOOP)\n';\n}\n\n=item guess_name\n\nGuess the name of this package by examining the working directory's\nname. MakeMaker calls this only if the developer has not supplied a\nNAME attribute.\n\n=cut\n\n# ';\n\nsub guess_name {\n    my($self) = @_;\n    use Cwd 'cwd';\n    my $name = basename(cwd());\n    $name =~ s|[\\-_][\\d\\.\\-]+\\z||;  # this is new with MM 5.00, we\n                                    # strip minus or underline\n                                    # followed by a float or some such\n    print \"Warning: Guessing NAME [$name] from current directory name.\\n\";\n    $name;\n}\n\n=item has_link_code\n\nReturns true if C, XS, MYEXTLIB or similar objects exist within this\nobject that need a compiler. Does not descend into subdirectories as\nneeds_linking() does.\n\n=cut\n\nsub has_link_code {\n    my($self) = shift;\n    return $self->{HAS_LINK_CODE} if defined $self->{HAS_LINK_CODE};\n    if ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB}){\n\t$self->{HAS_LINK_CODE} = 1;\n\treturn 1;\n    }\n    return $self->{HAS_LINK_CODE} = 0;\n}\n\n\n=item init_dirscan\n\nScans the directory structure and initializes DIR, XS, XS_FILES,\nC, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.\n\nCalled by init_main.\n\n=cut\n\nsub init_dirscan {\t# --- File and Directory Lists (.xs .pm .pod etc)\n    my($self) = @_;\n    my(%dir, %xs, %c, %o, %h, %pl_files, %pm);\n\n    my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);\n\n    # ignore the distdir\n    $Is{VMS} ? $ignore{\"$self->{DISTVNAME}.dir\"} = 1\n            : $ignore{$self->{DISTVNAME}} = 1;\n\n    my $distprefix = $Is{VMS} ? qr/^\\Q$self->{DISTNAME}\\E-v?[\\d\\.]+\\.dir$/i\n                              : qr/^\\Q$self->{DISTNAME}\\E-v?[\\d\\.]+$/;\n\n    @ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};\n\n    if ( defined $self->{XS} and !defined $self->{C} ) {\n\tmy @c_files = grep { m/\\.c(pp|xx)?\\z/i } values %{$self->{XS}};\n\tmy @o_files = grep { m/(?:.(?:o(?:bj)?)|\\$\\(OBJ_EXT\\))\\z/i } values %{$self->{XS}};\n\t%c = map { $_ => 1 } @c_files;\n\t%o = map { $_ => 1 } @o_files;\n    }\n\n    foreach my $name ($self->lsdir($Curdir)){\n\tnext if $name =~ /\\#/;\n\tnext if $name =~ $distprefix && -d $name;\n\t$name = lc($name) if $Is{VMS};\n\tnext if $name eq $Curdir or $name eq $Updir or $ignore{$name};\n\tnext unless $self->libscan($name);\n\tif (-d $name){\n\t    next if -l $name; # We do not support symlinks at all\n            next if $self->{NORECURS};\n\t    $dir{$name} = $name if (-f $self->catfile($name,\"Makefile.PL\"));\n\t} elsif ($name =~ /\\.xs\\z/){\n\t    my($c); ($c = $name) =~ s/\\.xs\\z/.c/;\n\t    $xs{$name} = $c;\n\t    $c{$c} = 1;\n\t} elsif ($name =~ /\\.c(pp|xx|c)?\\z/i){  # .c .C .cpp .cxx .cc\n\t    $c{$name} = 1\n\t\tunless $name =~ m/perlmain\\.c/; # See MAP_TARGET\n\t} elsif ($name =~ /\\.h\\z/i){\n\t    $h{$name} = 1;\n\t} elsif ($name =~ /\\.PL\\z/) {\n\t    ($pl_files{$name} = $name) =~ s/\\.PL\\z// ;\n\t} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {\n\t    # case-insensitive filesystem, one dot per name, so foo.h.PL\n\t    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos\n\t    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;\n\t    if ($txt =~ /Extracting \\S+ \\(with variable substitutions/) {\n\t\t($pl_files{$name} = $name) =~ s/[._]pl\\z//i ;\n\t    }\n\t    else {\n                $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);\n            }\n\t} elsif ($name =~ /\\.(p[ml]|pod)\\z/){\n\t    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);\n\t}\n    }\n\n    $self->{PL_FILES}   ||= \\%pl_files;\n    $self->{DIR}        ||= [sort keys %dir];\n    $self->{XS}         ||= \\%xs;\n    $self->{C}          ||= [sort keys %c];\n    $self->{H}          ||= [sort keys %h];\n    $self->{PM}         ||= \\%pm;\n\n    my @o_files = @{$self->{C}};\n    %o = (%o, map { $_ => 1 } grep s/\\.c(pp|xx|c)?\\z/$self->{OBJ_EXT}/i, @o_files);\n    $self->{O_FILES} = [sort keys %o];\n}\n\n\n=item init_MANPODS\n\nDetermines if man pages should be generated and initializes MAN1PODS\nand MAN3PODS as appropriate.\n\n=cut\n\nsub init_MANPODS {\n    my $self = shift;\n\n    # Set up names of manual pages to generate from pods\n    foreach my $man (qw(MAN1 MAN3)) {\n        if ( $self->{\"${man}PODS\"}\n             or $self->{\"INSTALL${man}DIR\"} =~ /^(none|\\s*)$/\n        ) {\n            $self->{\"${man}PODS\"} ||= {};\n        }\n        else {\n            my $init_method = \"init_${man}PODS\";\n            $self->$init_method();\n        }\n    }\n}\n\n\nsub _has_pod {\n    my($self, $file) = @_;\n\n    my($ispod)=0;\n    if (open( my $fh, '<', $file )) {\n        while (<$fh>) {\n            if (/^=(?:head\\d+|item|pod)\\b/) {\n                $ispod=1;\n                last;\n            }\n        }\n        close $fh;\n    } else {\n        # If it doesn't exist yet, we assume, it has pods in it\n        $ispod = 1;\n    }\n\n    return $ispod;\n}\n\n\n=item init_MAN1PODS\n\nInitializes MAN1PODS from the list of EXE_FILES.\n\n=cut\n\nsub init_MAN1PODS {\n    my($self) = @_;\n\n    if ( exists $self->{EXE_FILES} ) {\n\tforeach my $name (@{$self->{EXE_FILES}}) {\n\t    next unless $self->_has_pod($name);\n\n\t    $self->{MAN1PODS}->{$name} =\n\t\t$self->catfile(\"\\$(INST_MAN1DIR)\",\n\t\t\t       basename($name).\".\\$(MAN1EXT)\");\n\t}\n    }\n}\n\n\n=item init_MAN3PODS\n\nInitializes MAN3PODS from the list of PM files.\n\n=cut\n\nsub init_MAN3PODS {\n    my $self = shift;\n\n    my %manifypods = (); # we collect the keys first, i.e. the files\n                         # we have to convert to pod\n\n    foreach my $name (keys %{$self->{PM}}) {\n\tif ($name =~ /\\.pod\\z/ ) {\n\t    $manifypods{$name} = $self->{PM}{$name};\n\t} elsif ($name =~ /\\.p[ml]\\z/ ) {\n\t    if( $self->_has_pod($name) ) {\n\t\t$manifypods{$name} = $self->{PM}{$name};\n\t    }\n\t}\n    }\n\n    my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};\n\n    # Remove \"Configure.pm\" and similar, if it's not the only pod listed\n    # To force inclusion, just name it \"Configure.pod\", or override\n    # MAN3PODS\n    foreach my $name (keys %manifypods) {\n\tif (\n            ($self->{PERL_CORE} and $name =~ /(config|setup).*\\.pm/is) or\n            ( $name =~ m/^README\\.pod$/i ) # don't manify top-level README.pod\n        ) {\n\t    delete $manifypods{$name};\n\t    next;\n\t}\n\tmy($manpagename) = $name;\n\t$manpagename =~ s/\\.p(od|m|l)\\z//;\n\t# everything below lib is ok\n\tunless($manpagename =~ s!^\\W*($parentlibs_re)\\W+!!s) {\n\t    $manpagename = $self->catfile(\n\t        split(/::/,$self->{PARENT_NAME}),$manpagename\n\t    );\n\t}\n\t$manpagename = $self->replace_manpage_separator($manpagename);\n\t$self->{MAN3PODS}->{$name} =\n\t    $self->catfile(\"\\$(INST_MAN3DIR)\", \"$manpagename.\\$(MAN3EXT)\");\n    }\n}\n\n\n=item init_PM\n\nInitializes PMLIBDIRS and PM from PMLIBDIRS.\n\n=cut\n\nsub init_PM {\n    my $self = shift;\n\n    # Some larger extensions often wish to install a number of *.pm/pl\n    # files into the library in various locations.\n\n    # The attribute PMLIBDIRS holds an array reference which lists\n    # subdirectories which we should search for library files to\n    # install. PMLIBDIRS defaults to [ 'lib', $self->{BASEEXT} ].  We\n    # recursively search through the named directories (skipping any\n    # which don't exist or contain Makefile.PL files).\n\n    # For each *.pm or *.pl file found $self->libscan() is called with\n    # the default installation path in $_[1]. The return value of\n    # libscan defines the actual installation location.  The default\n    # libscan function simply returns the path.  The file is skipped\n    # if libscan returns false.\n\n    # The default installation location passed to libscan in $_[1] is:\n    #\n    #  ./*.pm\t\t=> $(INST_LIBDIR)/*.pm\n    #  ./xyz/...\t=> $(INST_LIBDIR)/xyz/...\n    #  ./lib/...\t=> $(INST_LIB)/...\n    #\n    # In this way the 'lib' directory is seen as the root of the actual\n    # perl library whereas the others are relative to INST_LIBDIR\n    # (which includes PARENT_NAME). This is a subtle distinction but one\n    # that's important for nested modules.\n\n    unless( $self->{PMLIBDIRS} ) {\n        if( $Is{VMS} ) {\n            # Avoid logical name vs directory collisions\n            $self->{PMLIBDIRS} = ['./lib', \"./$self->{BASEEXT}\"];\n        }\n        else {\n            $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];\n        }\n    }\n\n    #only existing directories that aren't in $dir are allowed\n\n    # Avoid $_ wherever possible:\n    # @{$self->{PMLIBDIRS}} = grep -d && !$dir{$_}, @{$self->{PMLIBDIRS}};\n    my (@pmlibdirs) = @{$self->{PMLIBDIRS}};\n    @{$self->{PMLIBDIRS}} = ();\n    my %dir = map { ($_ => $_) } @{$self->{DIR}};\n    foreach my $pmlibdir (@pmlibdirs) {\n\t-d $pmlibdir && !$dir{$pmlibdir} && push @{$self->{PMLIBDIRS}}, $pmlibdir;\n    }\n\n    unless( $self->{PMLIBPARENTDIRS} ) {\n\t@{$self->{PMLIBPARENTDIRS}} = ('lib');\n    }\n\n    return if $self->{PM} and $self->{ARGS}{PM};\n\n    if (@{$self->{PMLIBDIRS}}){\n\tprint \"Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\\n\"\n\t    if ($Verbose >= 2);\n\trequire File::Find;\n        File::Find::find(sub {\n            if (-d $_){\n                unless ($self->libscan($_)){\n                    $File::Find::prune = 1;\n                }\n                return;\n            }\n            return if /\\#/;\n            return if /~$/;             # emacs temp files\n            return if /,v$/;            # RCS files\n            return if m{\\.swp$};        # vim swap files\n\n\t    my $path   = $File::Find::name;\n            my $prefix = $self->{INST_LIBDIR};\n            my $striplibpath;\n\n\t    my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};\n\t    $prefix =  $self->{INST_LIB}\n                if ($striplibpath = $path) =~ s{^(\\W*)($parentlibs_re)\\W}\n\t                                       {$1}i;\n\n\t    my($inst) = $self->catfile($prefix,$striplibpath);\n\t    local($_) = $inst; # for backwards compatibility\n\t    $inst = $self->libscan($inst);\n\t    print \"libscan($path) => '$inst'\\n\" if ($Verbose >= 2);\n\t    return unless $inst;\n\t    if ($self->{XSMULTI} and $inst =~ /\\.xs\\z/) {\n\t\tmy($base); ($base = $path) =~ s/\\.xs\\z//;\n\t\t$self->{XS}{$path} = \"$base.c\";\n\t\tpush @{$self->{C}}, \"$base.c\";\n\t\tpush @{$self->{O_FILES}}, \"$base$self->{OBJ_EXT}\";\n\t    } else {\n\t\t$self->{PM}{$path} = $inst;\n\t    }\n\t}, @{$self->{PMLIBDIRS}});\n    }\n}\n\n\n=item init_DIRFILESEP\n\nUsing / for Unix.  Called by init_main.\n\n=cut\n\nsub init_DIRFILESEP {\n    my($self) = shift;\n\n    $self->{DIRFILESEP} = '/';\n}\n\n\n=item init_main\n\nInitializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,\nEXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,\nINSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,\nOBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,\nPERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,\nVERSION_SYM, XS_VERSION.\n\n=cut\n\nsub init_main {\n    my($self) = @_;\n\n    # --- Initialize Module Name and Paths\n\n    # NAME    = Foo::Bar::Oracle\n    # FULLEXT = Foo/Bar/Oracle\n    # BASEEXT = Oracle\n    # PARENT_NAME = Foo::Bar\n### Only UNIX:\n###    ($self->{FULLEXT} =\n###     $self->{NAME}) =~ s!::!/!g ; #eg. BSD/Foo/Socket\n    $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});\n\n\n    # Copied from DynaLoader:\n\n    my(@modparts) = split(/::/,$self->{NAME});\n    my($modfname) = $modparts[-1];\n\n    # Some systems have restrictions on files names for DLL's etc.\n    # mod2fname returns appropriate file base name (typically truncated)\n    # It may also edit @modparts if required.\n    # We require DynaLoader to make sure that mod2fname is loaded\n    eval { require DynaLoader };\n    if (defined &DynaLoader::mod2fname) {\n        $modfname = &DynaLoader::mod2fname(\\@modparts);\n    }\n\n    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\\w:]+)::)?(\\w+)\\z! ;\n    $self->{PARENT_NAME} ||= '';\n\n    if (defined &DynaLoader::mod2fname) {\n\t# As of 5.001m, dl_os2 appends '_'\n\t$self->{DLBASE} = $modfname;\n    } else {\n\t$self->{DLBASE} = '$(BASEEXT)';\n    }\n\n\n    # --- Initialize PERL_LIB, PERL_SRC\n\n    # *Real* information: where did we get these two from? ...\n    my $inc_config_dir = dirname($INC{'Config.pm'});\n    my $inc_carp_dir   = dirname($INC{'Carp.pm'});\n\n    unless ($self->{PERL_SRC}){\n        foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting\n            my $dir = $self->catdir(($Updir) x $dir_count);\n\n            if (-f $self->catfile($dir,\"config_h.SH\")   &&\n                -f $self->catfile($dir,\"perl.h\")        &&\n                -f $self->catfile($dir,\"lib\",\"strict.pm\")\n            ) {\n                $self->{PERL_SRC}=$dir ;\n                last;\n            }\n        }\n    }\n\n    warn \"PERL_CORE is set but I can't find your PERL_SRC!\\n\" if\n      $self->{PERL_CORE} and !$self->{PERL_SRC};\n\n    if ($self->{PERL_SRC}){\n\t$self->{PERL_LIB}     ||= $self->catdir(\"$self->{PERL_SRC}\",\"lib\");\n\n        $self->{PERL_ARCHLIB} = $self->{PERL_LIB};\n        $self->{PERL_INC}     = ($Is{Win32}) ?\n            $self->catdir($self->{PERL_LIB},\"CORE\") : $self->{PERL_SRC};\n\n\t# catch a situation that has occurred a few times in the past:\n\tunless (\n\t\t-s $self->catfile($self->{PERL_SRC},'cflags')\n\t\tor\n\t\t$Is{VMS}\n\t\t&&\n\t\t-s $self->catfile($self->{PERL_SRC},'vmsish.h')\n\t\tor\n\t\t$Is{Win32}\n\t       ){\n\t    warn qq{\nYou cannot build extensions below the perl source tree after executing\na 'make clean' in the perl source tree.\n\nTo rebuild extensions distributed with the perl source you should\nsimply Configure (to include those extensions) and then build perl as\nnormal. After installing perl the source tree can be deleted. It is\nnot needed for building extensions by running 'perl Makefile.PL'\nusually without extra arguments.\n\nIt is recommended that you unpack and build additional extensions away\nfrom the perl source tree.\n};\n\t}\n    } else {\n\t# we should also consider $ENV{PERL5LIB} here\n        my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};\n\t$self->{PERL_LIB}     ||= $Config{privlibexp};\n\t$self->{PERL_ARCHLIB} ||= $Config{archlibexp};\n\t$self->{PERL_INC}     = $self->catdir(\"$self->{PERL_ARCHLIB}\",\"CORE\"); # wild guess for now\n\tmy $perl_h;\n\n\tif (not -f ($perl_h = $self->catfile($self->{PERL_INC},\"perl.h\"))\n\t    and not $old){\n\t    # Maybe somebody tries to build an extension with an\n\t    # uninstalled Perl outside of Perl build tree\n\t    my $lib;\n\t    for my $dir (@INC) {\n\t      $lib = $dir, last if -e $self->catfile($dir, \"Config.pm\");\n\t    }\n\t    if ($lib) {\n              # Win32 puts its header files in /perl/src/lib/CORE.\n              # Unix leaves them in /perl/src.\n\t      my $inc = $Is{Win32} ? $self->catdir($lib, \"CORE\" )\n                                  : dirname $lib;\n\t      if (-e $self->catfile($inc, \"perl.h\")) {\n\t\t$self->{PERL_LIB}\t   = $lib;\n\t\t$self->{PERL_ARCHLIB}\t   = $lib;\n\t\t$self->{PERL_INC}\t   = $inc;\n\t\t$self->{UNINSTALLED_PERL}  = 1;\n\t\tprint <<EOP;\n... Detected uninstalled Perl.  Trying to continue.\nEOP\n\t      }\n\t    }\n\t}\n    }\n\n    if ($Is{Android}) {\n    \t# Android fun times!\n    \t# ../../perl -I../../lib -MFile::Glob -e1 works\n    \t# ../../../perl -I../../../lib -MFile::Glob -e1 fails to find\n    \t# the .so for File::Glob.\n    \t# This always affects core perl, but may also affect an installed\n    \t# perl built with -Duserelocatableinc.\n    \t$self->{PERL_LIB} = File::Spec->rel2abs($self->{PERL_LIB});\n    \t$self->{PERL_ARCHLIB} = File::Spec->rel2abs($self->{PERL_ARCHLIB});\n    }\n    $self->{PERL_INCDEP} = $self->{PERL_INC};\n    $self->{PERL_ARCHLIBDEP} = $self->{PERL_ARCHLIB};\n\n    # We get SITELIBEXP and SITEARCHEXP directly via\n    # Get_from_Config. When we are running standard modules, these\n    # won't matter, we will set INSTALLDIRS to \"perl\". Otherwise we\n    # set it to \"site\". I prefer that INSTALLDIRS be set from outside\n    # MakeMaker.\n    $self->{INSTALLDIRS} ||= \"site\";\n\n    $self->{MAN1EXT} ||= $Config{man1ext};\n    $self->{MAN3EXT} ||= $Config{man3ext};\n\n    # Get some stuff out of %Config if we haven't yet done so\n    print \"CONFIG must be an array ref\\n\"\n        if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');\n    $self->{CONFIG} = [] unless (ref $self->{CONFIG});\n    push(@{$self->{CONFIG}}, @ExtUtils::MakeMaker::Get_from_Config);\n    push(@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};\n    my(%once_only);\n    foreach my $m (@{$self->{CONFIG}}){\n        next if $once_only{$m};\n        print \"CONFIG key '$m' does not exist in Config.pm\\n\"\n                unless exists $Config{$m};\n        $self->{uc $m} ||= $Config{$m};\n        $once_only{$m} = 1;\n    }\n\n# This is too dangerous:\n#    if ($^O eq \"next\") {\n#\t$self->{AR} = \"libtool\";\n#\t$self->{AR_STATIC_ARGS} = \"-o\";\n#    }\n# But I leave it as a placeholder\n\n    $self->{AR_STATIC_ARGS} ||= \"cr\";\n\n    # These should never be needed\n    $self->{OBJ_EXT} ||= '.o';\n    $self->{LIB_EXT} ||= '.a';\n\n    $self->{MAP_TARGET} ||= \"perl\";\n\n    $self->{LIBPERL_A} ||= \"libperl$self->{LIB_EXT}\";\n\n    # make a simple check if we find strict\n    warn \"Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory\n        (strict.pm not found)\"\n        unless -f $self->catfile(\"$self->{PERL_LIB}\",\"strict.pm\") ||\n               $self->{NAME} eq \"ExtUtils::MakeMaker\";\n}\n\n=item init_tools\n\nInitializes tools to use their common (and faster) Unix commands.\n\n=cut\n\nsub init_tools {\n    my $self = shift;\n\n    $self->{ECHO}       ||= 'echo';\n    $self->{ECHO_N}     ||= 'echo -n';\n    $self->{RM_F}       ||= \"rm -f\";\n    $self->{RM_RF}      ||= \"rm -rf\";\n    $self->{TOUCH}      ||= \"touch\";\n    $self->{TEST_F}     ||= \"test -f\";\n    $self->{TEST_S}     ||= \"test -s\";\n    $self->{CP}         ||= \"cp\";\n    $self->{MV}         ||= \"mv\";\n    $self->{CHMOD}      ||= \"chmod\";\n    $self->{FALSE}      ||= 'false';\n    $self->{TRUE}       ||= 'true';\n\n    $self->{LD}         ||= 'ld';\n\n    return $self->SUPER::init_tools(@_);\n\n    # After SUPER::init_tools so $Config{shell} has a\n    # chance to get set.\n    $self->{SHELL}      ||= '/bin/sh';\n\n    return;\n}\n\n\n=item init_linker\n\nUnix has no need of special linker flags.\n\n=cut\n\nsub init_linker {\n    my($self) = shift;\n    $self->{PERL_ARCHIVE} ||= '';\n    $self->{PERL_ARCHIVEDEP} ||= '';\n    $self->{PERL_ARCHIVE_AFTER} ||= '';\n    $self->{EXPORT_LIST}  ||= '';\n}\n\n\n=begin _protected\n\n=item init_lib2arch\n\n    $mm->init_lib2arch\n\n=end _protected\n\n=cut\n\nsub init_lib2arch {\n    my($self) = shift;\n\n    # The user who requests an installation directory explicitly\n    # should not have to tell us an architecture installation directory\n    # as well. We look if a directory exists that is named after the\n    # architecture. If not we take it as a sign that it should be the\n    # same as the requested installation directory. Otherwise we take\n    # the found one.\n    for my $libpair ({l=>\"privlib\",   a=>\"archlib\"},\n                     {l=>\"sitelib\",   a=>\"sitearch\"},\n                     {l=>\"vendorlib\", a=>\"vendorarch\"},\n                    )\n    {\n        my $lib = \"install$libpair->{l}\";\n        my $Lib = uc $lib;\n        my $Arch = uc \"install$libpair->{a}\";\n        if( $self->{$Lib} && ! $self->{$Arch} ){\n            my($ilib) = $Config{$lib};\n\n            $self->prefixify($Arch,$ilib,$self->{$Lib});\n\n            unless (-d $self->{$Arch}) {\n                print \"Directory $self->{$Arch} not found\\n\"\n                  if $Verbose;\n                $self->{$Arch} = $self->{$Lib};\n            }\n            print \"Defaulting $Arch to $self->{$Arch}\\n\" if $Verbose;\n        }\n    }\n}\n\n\n=item init_PERL\n\n    $mm->init_PERL;\n\nCalled by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the\n*PERLRUN* permutations.\n\n    PERL is allowed to be miniperl\n    FULLPERL must be a complete perl\n\n    ABSPERL is PERL converted to an absolute path\n\n    *PERLRUN contains everything necessary to run perl, find it's\n         libraries, etc...\n\n    *PERLRUNINST is *PERLRUN + everything necessary to find the\n         modules being built.\n\n=cut\n\nsub init_PERL {\n    my($self) = shift;\n\n    my @defpath = ();\n    foreach my $component ($self->{PERL_SRC}, $self->path(),\n                           $Config{binexp})\n    {\n\tpush @defpath, $component if defined $component;\n    }\n\n    # Build up a set of file names (not command names).\n    my $thisperl = $self->canonpath($^X);\n    $thisperl .= $Config{exe_ext} unless\n                # VMS might have a file version # at the end\n      $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\\d+)?$/i\n              : $thisperl =~ m/$Config{exe_ext}$/i;\n\n    # We need a relative path to perl when in the core.\n    $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};\n\n    my @perls = ($thisperl);\n    push @perls, map { \"$_$Config{exe_ext}\" }\n                     (\"perl$Config{version}\", 'perl5', 'perl');\n\n    # miniperl has priority over all but the canonical perl when in the\n    # core.  Otherwise its a last resort.\n    my $miniperl = \"miniperl$Config{exe_ext}\";\n    if( $self->{PERL_CORE} ) {\n        splice @perls, 1, 0, $miniperl;\n    }\n    else {\n        push @perls, $miniperl;\n    }\n\n    $self->{PERL} ||=\n        $self->find_perl(5.0, \\@perls, \\@defpath, $Verbose );\n\n    my $perl = $self->{PERL};\n    $perl =~ s/^\"//;\n    my $has_mcr = $perl =~ s/^MCR\\s*//;\n    my $perlflags = '';\n    my $stripped_perl;\n    while ($perl) {\n\t($stripped_perl = $perl) =~ s/\"$//;\n\tlast if -x $stripped_perl;\n\tlast unless $perl =~ s/(\\s+\\S+)$//;\n\t$perlflags = $1.$perlflags;\n    }\n    $self->{PERL} = $stripped_perl;\n    $self->{PERL} = 'MCR '.$self->{PERL} if $has_mcr || $Is{VMS};\n\n    # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.\n    my $perl_name = 'perl';\n    $perl_name = 'ndbgperl' if $Is{VMS} &&\n      defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';\n\n    # XXX This logic is flawed.  If \"miniperl\" is anywhere in the path\n    # it will get confused.  It should be fixed to work only on the filename.\n    # Define 'FULLPERL' to be a non-miniperl (used in test: target)\n    unless ($self->{FULLPERL}) {\n      ($self->{FULLPERL} = $self->{PERL}) =~ s/\\Q$miniperl\\E$/$perl_name$Config{exe_ext}/i;\n      $self->{FULLPERL} = qq{\"$self->{FULLPERL}\"}.$perlflags;\n    }\n    # Can't have an image name with quotes, and findperl will have\n    # already escaped spaces.\n    $self->{FULLPERL} =~ tr/\"//d if $Is{VMS};\n\n    # Little hack to get around VMS's find_perl putting \"MCR\" in front\n    # sometimes.\n    $self->{ABSPERL} = $self->{PERL};\n    $has_mcr = $self->{ABSPERL} =~ s/^MCR\\s*//;\n    if( $self->file_name_is_absolute($self->{ABSPERL}) ) {\n        $self->{ABSPERL} = '$(PERL)';\n    }\n    else {\n        $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});\n\n        # Quote the perl command if it contains whitespace\n        $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})\n          if $self->{ABSPERL} =~ /\\s/;\n\n        $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;\n    }\n    $self->{PERL} = qq{\"$self->{PERL}\"}.$perlflags;\n\n    # Can't have an image name with quotes, and findperl will have\n    # already escaped spaces.\n    $self->{PERL} =~ tr/\"//d if $Is{VMS};\n\n    # Are we building the core?\n    $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};\n    $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};\n\n    # Make sure perl can find itself before it's installed.\n    my $lib_paths = $self->{UNINSTALLED_PERL} || $self->{PERL_CORE}\n        ? ( $self->{PERL_ARCHLIB} && $self->{PERL_LIB} && $self->{PERL_ARCHLIB} ne $self->{PERL_LIB} ) ?\n            q{ \"-I$(PERL_LIB)\" \"-I$(PERL_ARCHLIB)\"} : q{ \"-I$(PERL_LIB)\"}\n        : undef;\n    my $inst_lib_paths = $self->{INST_ARCHLIB} ne $self->{INST_LIB}\n        ? 'RUN)'.$perlflags.' \"-I$(INST_ARCHLIB)\" \"-I$(INST_LIB)\"'\n        : 'RUN)'.$perlflags.' \"-I$(INST_LIB)\"';\n    # How do we run perl?\n    foreach my $perl (qw(PERL FULLPERL ABSPERL)) {\n        my $run  = $perl.'RUN';\n\n        $self->{$run}  = qq{\\$($perl)};\n        $self->{$run} .= $lib_paths if $lib_paths;\n\n        $self->{$perl.'RUNINST'} = '$('.$perl.$inst_lib_paths;\n    }\n\n    return 1;\n}\n\n\n=item init_platform\n\n=item platform_constants\n\nAdd MM_Unix_VERSION.\n\n=cut\n\nsub init_platform {\n    my($self) = shift;\n\n    $self->{MM_Unix_VERSION} = $VERSION;\n    $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.\n                               '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.\n                               '-Dcalloc=Perl_calloc';\n\n}\n\nsub platform_constants {\n    my($self) = shift;\n    my $make_frag = '';\n\n    foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))\n    {\n        next unless defined $self->{$macro};\n        $make_frag .= \"$macro = $self->{$macro}\\n\";\n    }\n\n    return $make_frag;\n}\n\n\n=item init_PERM\n\n  $mm->init_PERM\n\nCalled by init_main.  Initializes PERL_*\n\n=cut\n\nsub init_PERM {\n    my($self) = shift;\n\n    $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};\n    $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};\n    $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};\n\n    return 1;\n}\n\n\n=item init_xs\n\n    $mm->init_xs\n\nSets up macros having to do with XS code.  Currently just INST_STATIC,\nINST_DYNAMIC and INST_BOOT.\n\n=cut\n\nsub init_xs {\n    my $self = shift;\n\n    if ($self->has_link_code()) {\n        $self->{INST_STATIC}  =\n          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');\n        $self->{INST_DYNAMIC} =\n          $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');\n        $self->{INST_BOOT}    =\n          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');\n\tif ($self->{XSMULTI}) {\n\t    my @exts = $self->_xs_list_basenames;\n\t    my (@statics, @dynamics, @boots);\n\t    for my $ext (@exts) {\n\t\tmy ($v, $d, $f) = File::Spec->splitpath($ext);\n\t\tmy @d = File::Spec->splitdir($d);\n\t\tshift @d if defined $d[0] and $d[0] eq 'lib';\n\t\tmy $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);\n\t\tmy $instfile = $self->catfile($instdir, $f);\n\t\tpush @statics, \"$instfile\\$(LIB_EXT)\";\n\n                # Dynamic library names may need special handling.\n                my $dynfile = $instfile;\n                eval { require DynaLoader };\n                if (defined &DynaLoader::mod2fname) {\n                    $dynfile = $self->catfile($instdir, &DynaLoader::mod2fname([@d, $f]));\n                }\n\n\t\tpush @dynamics, \"$dynfile.\\$(DLEXT)\";\n\t\tpush @boots, \"$instfile.bs\";\n\t    }\n\t    $self->{INST_STATIC} = join ' ', @statics;\n\t    $self->{INST_DYNAMIC} = join ' ', @dynamics;\n\t    $self->{INST_BOOT} = join ' ', @boots;\n\t}\n    } else {\n        $self->{INST_STATIC}  = '';\n        $self->{INST_DYNAMIC} = '';\n        $self->{INST_BOOT}    = '';\n    }\n}\n\n=item install (o)\n\nDefines the install target.\n\n=cut\n\nsub install {\n    my($self, %attribs) = @_;\n    my(@m);\n\n    push @m, q{\ninstall :: pure_install doc_install\n\t$(NOECHO) $(NOOP)\n\ninstall_perl :: pure_perl_install doc_perl_install\n\t$(NOECHO) $(NOOP)\n\ninstall_site :: pure_site_install doc_site_install\n\t$(NOECHO) $(NOOP)\n\ninstall_vendor :: pure_vendor_install doc_vendor_install\n\t$(NOECHO) $(NOOP)\n\npure_install :: pure_$(INSTALLDIRS)_install\n\t$(NOECHO) $(NOOP)\n\ndoc_install :: doc_$(INSTALLDIRS)_install\n\t$(NOECHO) $(NOOP)\n\npure__install : pure_site_install\n\t$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site\n\ndoc__install : doc_site_install\n\t$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site\n\npure_perl_install :: all\n\t$(NOECHO) $(MOD_INSTALL) \\\n};\n\n    push @m,\nq{\t\tread \"}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{\" \\\n\t\twrite \"}.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{\" \\\n} unless $self->{NO_PACKLIST};\n\n    push @m,\nq{\t\t\"$(INST_LIB)\" \"$(DESTINSTALLPRIVLIB)\" \\\n\t\t\"$(INST_ARCHLIB)\" \"$(DESTINSTALLARCHLIB)\" \\\n\t\t\"$(INST_BIN)\" \"$(DESTINSTALLBIN)\" \\\n\t\t\"$(INST_SCRIPT)\" \"$(DESTINSTALLSCRIPT)\" \\\n\t\t\"$(INST_MAN1DIR)\" \"$(DESTINSTALLMAN1DIR)\" \\\n\t\t\"$(INST_MAN3DIR)\" \"$(DESTINSTALLMAN3DIR)\"\n\t$(NOECHO) $(WARN_IF_OLD_PACKLIST) \\\n\t\t\"}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{\"\n\n\npure_site_install :: all\n\t$(NOECHO) $(MOD_INSTALL) \\\n};\n    push @m,\nq{\t\tread \"}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{\" \\\n\t\twrite \"}.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{\" \\\n} unless $self->{NO_PACKLIST};\n\n    push @m,\nq{\t\t\"$(INST_LIB)\" \"$(DESTINSTALLSITELIB)\" \\\n\t\t\"$(INST_ARCHLIB)\" \"$(DESTINSTALLSITEARCH)\" \\\n\t\t\"$(INST_BIN)\" \"$(DESTINSTALLSITEBIN)\" \\\n\t\t\"$(INST_SCRIPT)\" \"$(DESTINSTALLSITESCRIPT)\" \\\n\t\t\"$(INST_MAN1DIR)\" \"$(DESTINSTALLSITEMAN1DIR)\" \\\n\t\t\"$(INST_MAN3DIR)\" \"$(DESTINSTALLSITEMAN3DIR)\"\n\t$(NOECHO) $(WARN_IF_OLD_PACKLIST) \\\n\t\t\"}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{\"\n\npure_vendor_install :: all\n\t$(NOECHO) $(MOD_INSTALL) \\\n};\n    push @m,\nq{\t\tread \"}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{\" \\\n\t\twrite \"}.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{\" \\\n} unless $self->{NO_PACKLIST};\n\n    push @m,\nq{\t\t\"$(INST_LIB)\" \"$(DESTINSTALLVENDORLIB)\" \\\n\t\t\"$(INST_ARCHLIB)\" \"$(DESTINSTALLVENDORARCH)\" \\\n\t\t\"$(INST_BIN)\" \"$(DESTINSTALLVENDORBIN)\" \\\n\t\t\"$(INST_SCRIPT)\" \"$(DESTINSTALLVENDORSCRIPT)\" \\\n\t\t\"$(INST_MAN1DIR)\" \"$(DESTINSTALLVENDORMAN1DIR)\" \\\n\t\t\"$(INST_MAN3DIR)\" \"$(DESTINSTALLVENDORMAN3DIR)\"\n\n};\n\n    push @m, q{\ndoc_perl_install :: all\n\t$(NOECHO) $(NOOP)\n\ndoc_site_install :: all\n\t$(NOECHO) $(NOOP)\n\ndoc_vendor_install :: all\n\t$(NOECHO) $(NOOP)\n\n} if $self->{NO_PERLLOCAL};\n\n    push @m, q{\ndoc_perl_install :: all\n\t$(NOECHO) $(ECHO) Appending installation info to \"$(DESTINSTALLARCHLIB)/perllocal.pod\"\n\t-$(NOECHO) $(MKPATH) \"$(DESTINSTALLARCHLIB)\"\n\t-$(NOECHO) $(DOC_INSTALL) \\\n\t\t\"Module\" \"$(NAME)\" \\\n\t\t\"installed into\" \"$(INSTALLPRIVLIB)\" \\\n\t\tLINKTYPE \"$(LINKTYPE)\" \\\n\t\tVERSION \"$(VERSION)\" \\\n\t\tEXE_FILES \"$(EXE_FILES)\" \\\n\t\t>> \"}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{\"\n\ndoc_site_install :: all\n\t$(NOECHO) $(ECHO) Appending installation info to \"$(DESTINSTALLARCHLIB)/perllocal.pod\"\n\t-$(NOECHO) $(MKPATH) \"$(DESTINSTALLARCHLIB)\"\n\t-$(NOECHO) $(DOC_INSTALL) \\\n\t\t\"Module\" \"$(NAME)\" \\\n\t\t\"installed into\" \"$(INSTALLSITELIB)\" \\\n\t\tLINKTYPE \"$(LINKTYPE)\" \\\n\t\tVERSION \"$(VERSION)\" \\\n\t\tEXE_FILES \"$(EXE_FILES)\" \\\n\t\t>> \"}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{\"\n\ndoc_vendor_install :: all\n\t$(NOECHO) $(ECHO) Appending installation info to \"$(DESTINSTALLARCHLIB)/perllocal.pod\"\n\t-$(NOECHO) $(MKPATH) \"$(DESTINSTALLARCHLIB)\"\n\t-$(NOECHO) $(DOC_INSTALL) \\\n\t\t\"Module\" \"$(NAME)\" \\\n\t\t\"installed into\" \"$(INSTALLVENDORLIB)\" \\\n\t\tLINKTYPE \"$(LINKTYPE)\" \\\n\t\tVERSION \"$(VERSION)\" \\\n\t\tEXE_FILES \"$(EXE_FILES)\" \\\n\t\t>> \"}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{\"\n\n} unless $self->{NO_PERLLOCAL};\n\n    push @m, q{\nuninstall :: uninstall_from_$(INSTALLDIRS)dirs\n\t$(NOECHO) $(NOOP)\n\nuninstall_from_perldirs ::\n\t$(NOECHO) $(UNINSTALL) \"}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{\"\n\nuninstall_from_sitedirs ::\n\t$(NOECHO) $(UNINSTALL) \"}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{\"\n\nuninstall_from_vendordirs ::\n\t$(NOECHO) $(UNINSTALL) \"}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{\"\n};\n\n    join(\"\",@m);\n}\n\n=item installbin (o)\n\nDefines targets to make and to install EXE_FILES.\n\n=cut\n\nsub installbin {\n    my($self) = shift;\n\n    return \"\" unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq \"ARRAY\";\n    my @exefiles = sort @{$self->{EXE_FILES}};\n    return \"\" unless @exefiles;\n\n    @exefiles = map vmsify($_), @exefiles if $Is{VMS};\n\n    my %fromto;\n    for my $from (@exefiles) {\n\tmy($path)= $self->catfile('$(INST_SCRIPT)', basename($from));\n\n\tlocal($_) = $path; # for backwards compatibility\n\tmy $to = $self->libscan($path);\n\tprint \"libscan($from) => '$to'\\n\" if ($Verbose >=2);\n\n        $to = vmsify($to) if $Is{VMS};\n\t$fromto{$from} = $to;\n    }\n    my @to   = sort values %fromto;\n\n    my @m;\n    push(@m, qq{\nEXE_FILES = @exefiles\n\npure_all :: @to\n\t\\$(NOECHO) \\$(NOOP)\n\nrealclean ::\n});\n\n    # realclean can get rather large.\n    push @m, map \"\\t$_\\n\", $self->split_command('$(RM_F)', @to);\n    push @m, \"\\n\";\n\n    # A target for each exe file.\n    my @froms = sort keys %fromto;\n    for my $from (@froms) {\n        #                              1      2\n        push @m, _sprintf562 <<'MAKE', $from, $fromto{$from};\n%2$s : %1$s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists\n\t$(NOECHO) $(RM_F) %2$s\n\t$(CP) %1$s %2$s\n\t$(FIXIN) %2$s\n\t-$(NOECHO) $(CHMOD) $(PERM_RWX) %2$s\n\nMAKE\n\n    }\n\n    join \"\", @m;\n}\n\n=item linkext (o)\n\nDefines the linkext target which in turn defines the LINKTYPE.\n\n=cut\n\n# LINKTYPE => static or dynamic or ''\nsub linkext {\n    my($self, %attribs) = @_;\n    my $linktype = $attribs{LINKTYPE};\n    $linktype = $self->{LINKTYPE} unless defined $linktype;\n    if (defined $linktype and $linktype eq '') {\n        warn \"Warning: LINKTYPE set to '', no longer necessary\\n\";\n    }\n    $linktype = '$(LINKTYPE)' unless defined $linktype;\n    \"\nlinkext :: $linktype\n\t\\$(NOECHO) \\$(NOOP)\n\";\n}\n\n=item lsdir\n\nTakes as arguments a directory name and a regular expression. Returns\nall entries in the directory that match the regular expression.\n\n=cut\n\nsub lsdir {\n    #  $self\n    my(undef, $dir, $regex) = @_;\n    opendir(my $dh, defined($dir) ? $dir : \".\")\n        or return;\n    my @ls = readdir $dh;\n    closedir $dh;\n    @ls = grep(/$regex/, @ls) if defined $regex;\n    @ls;\n}\n\n=item macro (o)\n\nSimple subroutine to insert the macros defined by the macro attribute\ninto the Makefile.\n\n=cut\n\nsub macro {\n    my($self,%attribs) = @_;\n    my @m;\n    foreach my $key (sort keys %attribs) {\n\tmy $val = $attribs{$key};\n\tpush @m, \"$key = $val\\n\";\n    }\n    join \"\", @m;\n}\n\n=item makeaperl (o)\n\nCalled by staticmake. Defines how to write the Makefile to produce a\nstatic new perl.\n\nBy default the Makefile produced includes all the static extensions in\nthe perl library. (Purified versions of library files, e.g.,\nDynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)\n\n=cut\n\nsub makeaperl {\n    my($self, %attribs) = @_;\n    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) =\n\t@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};\n    s/^(.*)/\"-I$1\"/ for @{$perlinc || []};\n    my(@m);\n    push @m, \"\n# --- MakeMaker makeaperl section ---\nMAP_TARGET    = $target\nFULLPERL      = $self->{FULLPERL}\nMAP_PERLINC   = @{$perlinc || []}\n\";\n    return join '', @m if $self->{PARENT};\n\n    my($dir) = join \":\", @{$self->{DIR}};\n\n    unless ($self->{MAKEAPERL}) {\n\tpush @m, q{\n$(MAP_TARGET) :: $(MAKE_APERL_FILE)\n\t$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@\n\n$(MAKE_APERL_FILE) : static $(FIRST_MAKEFILE) pm_to_blib\n\t$(NOECHO) $(ECHO) Writing \\\"$(MAKE_APERL_FILE)\\\" for this $(MAP_TARGET)\n\t$(NOECHO) $(PERLRUNINST) \\\n\t\tMakefile.PL DIR=\"}, $dir, q{\" \\\n\t\tMAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \\\n\t\tMAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};\n\n\tforeach (@ARGV){\n\t\tmy $arg = $_; # avoid lvalue aliasing\n\t\tif ( $arg =~ /(^.*?=)(.*['\\s].*)/ ) {\n\t\t\t$arg = $1 . $self->quote_literal($2);\n\t\t}\n\t\tpush @m, \" \\\\\\n\\t\\t$arg\";\n\t}\n\tpush @m, \"\\n\";\n\n\treturn join '', @m;\n    }\n\n    my $cccmd = $self->const_cccmd($libperl);\n    $cccmd =~ s/^CCCMD\\s*=\\s*//;\n    $cccmd =~ s/\\$\\(INC\\)/ \"-I$self->{PERL_INC}\" /;\n    $cccmd .= \" $Config{cccdlflags}\"\n\tif ($Config{useshrplib} eq 'true');\n    $cccmd =~ s/\\(CC\\)/\\(PERLMAINCC\\)/;\n\n    # The front matter of the linkcommand...\n    my $linkcmd = join ' ', \"\\$(CC)\",\n\t    grep($_, @Config{qw(ldflags ccdlflags)});\n    $linkcmd =~ s/\\s+/ /g;\n    $linkcmd =~ s,(perl\\.exp),\\$(PERL_INC)/$1,;\n\n    # Which *.a files could we make use of...\n    my %static;\n    require File::Find;\n    # don't use File::Spec here because on Win32 F::F still uses \"/\"\n    my $installed_version = join('/',\n\t'auto', $self->{FULLEXT}, \"$self->{BASEEXT}$self->{LIB_EXT}\"\n    );\n    File::Find::find(sub {\n\treturn unless m/\\Q$self->{LIB_EXT}\\E$/;\n\n        # Skip perl's libraries.\n        return if m/^libperl/ or m/^perl\\Q$self->{LIB_EXT}\\E$/;\n\n\t# Skip purified versions of libraries\n        # (e.g., DynaLoader_pure_p1_c0_032.a)\n\treturn if m/_pure_\\w+_\\w+_\\w+\\.\\w+$/ and -f \"$File::Find::dir/.pure\";\n\n\tif( exists $self->{INCLUDE_EXT} ){\n\t\tmy $found = 0;\n\n\t\t(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;\n\t\t$xx =~ s,/?$_,,;\n\t\t$xx =~ s,/,::,g;\n\n\t\t# Throw away anything not explicitly marked for inclusion.\n\t\t# DynaLoader is implied.\n\t\tforeach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){\n\t\t\tif( $xx eq $incl ){\n\t\t\t\t$found++;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\treturn unless $found;\n\t}\n\telsif( exists $self->{EXCLUDE_EXT} ){\n\t\t(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;\n\t\t$xx =~ s,/?$_,,;\n\t\t$xx =~ s,/,::,g;\n\n\t\t# Throw away anything explicitly marked for exclusion\n\t\tforeach my $excl (@{$self->{EXCLUDE_EXT}}){\n\t\t\treturn if( $xx eq $excl );\n\t\t}\n\t}\n\n\t# don't include the installed version of this extension. I\n\t# leave this line here, although it is not necessary anymore:\n\t# I patched minimod.PL instead, so that Miniperl.pm won't\n\t# include duplicates\n\n\t# Once the patch to minimod.PL is in the distribution, I can\n\t# drop it\n\treturn if $File::Find::name =~ m:\\Q$installed_version\\E\\z:;\n\tuse Cwd 'cwd';\n\t$static{cwd() . \"/\" . $_}++;\n    }, grep( -d $_, @{$searchdirs || []}) );\n\n    # We trust that what has been handed in as argument, will be buildable\n    $static = [] unless $static;\n    @static{@{$static}} = (1) x @{$static};\n\n    $extra = [] unless $extra && ref $extra eq 'ARRAY';\n    for (sort keys %static) {\n\tnext unless /\\Q$self->{LIB_EXT}\\E\\z/;\n\t$_ = dirname($_) . \"/extralibs.ld\";\n\tpush @$extra, $_;\n    }\n\n    s/^(.*)/\"-I$1\"/ for @{$perlinc || []};\n\n    $target ||= \"perl\";\n    $tmp    ||= \".\";\n\n# MAP_STATIC doesn't look into subdirs yet. Once \"all\" is made and we\n# regenerate the Makefiles, MAP_STATIC and the dependencies for\n# extralibs.all are computed correctly\n    my @map_static = reverse sort keys %static;\n    push @m, \"\nMAP_LINKCMD   = $linkcmd\nMAP_STATIC    = \", join(\" \\\\\\n\\t\", map { qq{\"$_\"} } @map_static), \"\nMAP_STATICDEP = \", join(' ', map { $self->quote_dep($_) } @map_static), \"\n\nMAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}\n\";\n\n    my $lperl;\n    if (defined $libperl) {\n\t($lperl = $libperl) =~ s/\\$\\(A\\)/$self->{LIB_EXT}/;\n    }\n    unless ($libperl && -f $lperl) { # Ilya's code...\n\tmy $dir = $self->{PERL_SRC} || \"$self->{PERL_ARCHLIB}/CORE\";\n\t$dir = \"$self->{PERL_ARCHLIB}/..\" if $self->{UNINSTALLED_PERL};\n\t$libperl ||= \"libperl$self->{LIB_EXT}\";\n\t$libperl   = \"$dir/$libperl\";\n\t$lperl   ||= \"libperl$self->{LIB_EXT}\";\n\t$lperl     = \"$dir/$lperl\";\n\n        if (! -f $libperl and ! -f $lperl) {\n          # We did not find a static libperl. Maybe there is a shared one?\n          if ($Is{SunOS}) {\n            $lperl  = $libperl = \"$dir/$Config{libperl}\";\n            # SUNOS ld does not take the full path to a shared library\n            $libperl = '' if $Is{SunOS4};\n          }\n        }\n\n\tprint <<EOF unless -f $lperl || defined($self->{PERL_SRC});\nWarning: $libperl not found\nIf you're going to build a static perl binary, make sure perl is installed\notherwise ignore this warning\nEOF\n    }\n\n    # SUNOS ld does not take the full path to a shared library\n    my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';\n    my $libperl_dep = $self->quote_dep($libperl);\n\n    push @m, \"\nMAP_LIBPERL = $libperl\nMAP_LIBPERLDEP = $libperl_dep\nLLIBPERL    = $llibperl\n\";\n\n    push @m, '\n$(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(\" \\\\\\n\\t\", @$extra).'\n\t$(NOECHO) $(RM_F)  $@\n\t$(NOECHO) $(TOUCH) $@\n';\n\n    foreach my $catfile (@$extra){\n\tpush @m, \"\\tcat $catfile >> \\$\\@\\n\";\n    }\n\n    my $ldfrom = $self->{XSMULTI} ? '' : '$(LDFROM)';\n    #                             1     2                        3        4\n    push @m, _sprintf562 <<'EOF', $tmp, $ldfrom, $self->xs_obj_opt('$@'), $makefilename;\n$(MAP_TARGET) :: %1$s/perlmain$(OBJ_EXT) $(MAP_LIBPERLDEP) $(MAP_STATICDEP) $(INST_ARCHAUTODIR)/extralibs.all\n\t$(MAP_LINKCMD) %2$s $(OPTIMIZE) %1$s/perlmain$(OBJ_EXT) %3$s $(MAP_STATIC) \"$(LLIBPERL)\" `cat $(INST_ARCHAUTODIR)/extralibs.all` $(MAP_PRELIBS)\n\t$(NOECHO) $(ECHO) \"To install the new '$(MAP_TARGET)' binary, call\"\n\t$(NOECHO) $(ECHO) \"    $(MAKE) $(USEMAKEFILE) %4$s inst_perl MAP_TARGET=$(MAP_TARGET)\"\n\t$(NOECHO) $(ECHO) \"    $(MAKE) $(USEMAKEFILE) %4$s map_clean\"\n\n%1$s/perlmain\\$(OBJ_EXT): %1$s/perlmain.c\nEOF\n    push @m, \"\\t\".$self->cd($tmp, qq[$cccmd \"-I\\$(PERL_INC)\" perlmain.c]).\"\\n\";\n\n    my $maybe_DynaLoader = $Config{usedl} ? 'q(DynaLoader)' : '';\n    push @m, _sprintf562 <<'EOF', $tmp, $makefilename, $maybe_DynaLoader;\n\n%1$s/perlmain.c: %2$s\n\t$(NOECHO) $(ECHO) Writing $@\n\t$(NOECHO) $(PERL) $(MAP_PERLINC) \"-MExtUtils::Miniperl\" \\\n\t\t-e \"writemain(grep(s#.*/auto/##s, @ARGV), %3$s)\" $(MAP_STATIC) > $@t\n\t$(MV) $@t $@\n\nEOF\n    push @m, \"\\t\", q{$(NOECHO) $(PERL) \"$(INSTALLSCRIPT)/fixpmain\"\n} if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);\n\n\n    push @m, q{\ndoc_inst_perl :\n\t$(NOECHO) $(ECHO) Appending installation info to \"$(DESTINSTALLARCHLIB)/perllocal.pod\"\n\t-$(NOECHO) $(MKPATH) \"$(DESTINSTALLARCHLIB)\"\n\t-$(NOECHO) $(DOC_INSTALL) \\\n\t\t\"Perl binary\" \"$(MAP_TARGET)\" \\\n\t\tMAP_STATIC \"$(MAP_STATIC)\" \\\n\t\tMAP_EXTRA \"`cat $(INST_ARCHAUTODIR)/extralibs.all`\" \\\n\t\tMAP_LIBPERL \"$(MAP_LIBPERL)\" \\\n\t\t>> \"}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{\"\n\n};\n\n    push @m, q{\ninst_perl : pure_inst_perl doc_inst_perl\n\npure_inst_perl : $(MAP_TARGET)\n\t}.$self->{CP}.q{ $(MAP_TARGET) \"}.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{\"\n\nclean :: map_clean\n\nmap_clean :\n\t}.$self->{RM_F}.qq{ $tmp/perlmain\\$(OBJ_EXT) $tmp/perlmain.c \\$(MAP_TARGET) $makefilename \\$(INST_ARCHAUTODIR)/extralibs.all\n};\n\n    join '', @m;\n}\n\n=item makefile (o)\n\nDefines how to rewrite the Makefile.\n\n=cut\n\nsub makefile {\n    my($self) = shift;\n    my $m;\n    # We do not know what target was originally specified so we\n    # must force a manual rerun to be sure. But as it should only\n    # happen very rarely it is not a significant problem.\n    $m = '\n$(OBJECT) : $(FIRST_MAKEFILE)\n\n' if $self->{OBJECT};\n\n    my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';\n    my $mpl_args = join \" \", map qq[\"$_\"], @ARGV;\n    my $cross = '';\n    if (defined $::Cross::platform) {\n        # Inherited from win32/buildext.pl\n        $cross = \"-MCross=$::Cross::platform \";\n    }\n    $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $cross, $mpl_args;\n# We take a very conservative approach here, but it's worth it.\n# We move Makefile to Makefile.old here to avoid gnu make looping.\n$(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)\n\t$(NOECHO) $(ECHO) \"Makefile out-of-date with respect to %s\"\n\t$(NOECHO) $(ECHO) \"Cleaning current config before rebuilding Makefile...\"\n\t-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)\n\t-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)\n\t- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)\n\t$(PERLRUN) %sMakefile.PL %s\n\t$(NOECHO) $(ECHO) \"==> Your Makefile has been rebuilt. <==\"\n\t$(NOECHO) $(ECHO) \"==> Please rerun the $(MAKE) command.  <==\"\n\t$(FALSE)\n\nMAKE_FRAG\n\n    return $m;\n}\n\n\n=item maybe_command\n\nReturns true, if the argument is likely to be a command.\n\n=cut\n\nsub maybe_command {\n    my($self,$file) = @_;\n    return $file if -x $file && ! -d $file;\n    return;\n}\n\n\n=item needs_linking (o)\n\nDoes this module need linking? Looks into subdirectory objects (see\nalso has_link_code())\n\n=cut\n\nsub needs_linking {\n    my($self) = shift;\n\n    my $caller = (caller(0))[3];\n    confess(\"needs_linking called too early\") if\n      $caller =~ /^ExtUtils::MakeMaker::/;\n    return $self->{NEEDS_LINKING} if defined $self->{NEEDS_LINKING};\n    if ($self->has_link_code or $self->{MAKEAPERL}){\n\t$self->{NEEDS_LINKING} = 1;\n\treturn 1;\n    }\n    foreach my $child (keys %{$self->{CHILDREN}}) {\n\tif ($self->{CHILDREN}->{$child}->needs_linking) {\n\t    $self->{NEEDS_LINKING} = 1;\n\t    return 1;\n\t}\n    }\n    return $self->{NEEDS_LINKING} = 0;\n}\n\n\n=item parse_abstract\n\nparse a file and return what you think is the ABSTRACT\n\n=cut\n\nsub parse_abstract {\n    my($self,$parsefile) = @_;\n    my $result;\n\n    local $/ = \"\\n\";\n    open(my $fh, '<', $parsefile) or die \"Could not open '$parsefile': $!\";\n    binmode $fh;\n    my $inpod = 0;\n    my $pod_encoding;\n    my $package = $self->{DISTNAME};\n    $package =~ s/-/::/g;\n    while (<$fh>) {\n        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;\n        next if !$inpod;\n        s#\\r*\\n\\z##; # handle CRLF input\n\n        if ( /^=encoding\\s*(.*)$/i ) {\n            $pod_encoding = $1;\n        }\n\n        if ( /^($package(?:\\.pm)? \\s+ -+ \\s+)(.*)/x ) {\n          $result = $2;\n          next;\n        }\n        next unless $result;\n\n        if ( $result && ( /^\\s*$/ || /^\\=/ ) ) {\n          last;\n        }\n        $result = join ' ', $result, $_;\n    }\n    close $fh;\n\n    if ( $pod_encoding and !( $] < 5.008 or !$Config{useperlio} ) ) {\n        # Have to wrap in an eval{} for when running under PERL_CORE\n        # Encode isn't available during build phase and parsing\n        # ABSTRACT isn't important there\n        eval {\n          require Encode;\n          $result = Encode::decode($pod_encoding, $result);\n        }\n    }\n\n    return $result;\n}\n\n=item parse_version\n\n    my $version = MM->parse_version($file);\n\nParse a $file and return what $VERSION is set to by the first assignment.\nIt will return the string \"undef\" if it can't figure out what $VERSION\nis. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION\nare okay, but C<my $VERSION> is not.\n\nC<<package Foo VERSION>> is also checked for.  The first version\ndeclaration found is used, but this may change as it differs from how\nPerl does it.\n\nparse_version() will try to C<use version> before checking for\nC<$VERSION> so the following will work.\n\n    $VERSION = qv(1.2.3);\n\n=cut\n\nsub parse_version {\n    my($self,$parsefile) = @_;\n    my $result;\n\n    local $/ = \"\\n\";\n    local $_;\n    open(my $fh, '<', $parsefile) or die \"Could not open '$parsefile': $!\";\n    my $inpod = 0;\n    while (<$fh>) {\n        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;\n        next if $inpod || /^\\s*#/;\n        chop;\n        next if /^\\s*(if|unless|elsif)/;\n        if ( m{^ \\s* package \\s+ \\w[\\w\\:\\']* \\s+ (v?[0-9._]+) \\s* (;|\\{)  }x ) {\n            local $^W = 0;\n            $result = $1;\n        }\n        elsif ( m{(?<!\\\\) ([\\$*]) (([\\w\\:\\']*) \\bVERSION)\\b .* (?<![<>=!])\\=[^=]}x ) {\n\t\t\t$result = $self->get_version($parsefile, $1, $2);\n        }\n        else {\n          next;\n        }\n        last if defined $result;\n    }\n    close $fh;\n\n    if ( defined $result && $result !~ /^v?[\\d_\\.]+$/ ) {\n      require version;\n      my $normal = eval { version->new( $result ) };\n      $result = $normal if defined $normal;\n    }\n    $result = \"undef\" unless defined $result;\n    return $result;\n}\n\nsub get_version {\n    my ($self, $parsefile, $sigil, $name) = @_;\n    my $line = $_; # from the while() loop in parse_version\n    {\n        package ExtUtils::MakeMaker::_version;\n        undef *version; # in case of unexpected version() sub\n        eval {\n            require version;\n            version::->import;\n        };\n        no strict;\n        local *{$name};\n        local $^W = 0;\n        $line = $1 if $line =~ m{^(.+)}s;\n        eval($line); ## no critic\n        return ${$name};\n    }\n}\n\n=item pasthru (o)\n\nDefines the string that is passed to recursive make calls in\nsubdirectories. The variables like C<PASTHRU_DEFINE> are used in each\nlevel, and passed downwards on the command-line with e.g. the value of\nthat level's DEFINE. Example:\n\n    # Level 0 has DEFINE = -Dfunky\n    # This code will define level 0's PASTHRU=PASTHRU_DEFINE=\"$(DEFINE)\n    #     $(PASTHRU_DEFINE)\"\n    # Level 0's $(CCCMD) will include macros $(DEFINE) and $(PASTHRU_DEFINE)\n    # So will level 1's, so when level 1 compiles, it will get right values\n    # And so ad infinitum\n\n=cut\n\nsub pasthru {\n    my($self) = shift;\n    my(@m);\n\n    my(@pasthru);\n    my($sep) = $Is{VMS} ? ',' : '';\n    $sep .= \"\\\\\\n\\t\";\n\n    foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE\n                     PREFIX INSTALL_BASE)\n                 )\n    {\n        next unless defined $self->{$key};\n\tpush @pasthru, \"$key=\\\"\\$($key)\\\"\";\n    }\n\n    foreach my $key (qw(DEFINE INC)) {\n        # default to the make var\n        my $val = qq{\\$($key)};\n        # expand within perl if given since need to use quote_literal\n        # since INC might include space-protecting \"\"!\n        chomp($val = $self->{$key}) if defined $self->{$key};\n        $val .= \" \\$(PASTHRU_$key)\";\n        my $quoted = $self->quote_literal($val);\n        push @pasthru, qq{PASTHRU_$key=$quoted};\n    }\n\n    push @m, \"\\nPASTHRU = \", join ($sep, @pasthru), \"\\n\";\n    join \"\", @m;\n}\n\n=item perl_script\n\nTakes one argument, a file name, and returns the file name, if the\nargument is likely to be a perl script. On MM_Unix this is true for\nany ordinary, readable file.\n\n=cut\n\nsub perl_script {\n    my($self,$file) = @_;\n    return $file if -r $file && -f _;\n    return;\n}\n\n=item perldepend (o)\n\nDefines the dependency from all *.h files that come with the perl\ndistribution.\n\n=cut\n\nsub perldepend {\n    my($self) = shift;\n    my(@m);\n\n    my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');\n\n    push @m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};\n# Check for unpropogated config.sh changes. Should never happen.\n# We do NOT just update config.h because that is not sufficient.\n# An out of date config.h is not fatal but complains loudly!\n$(PERL_INCDEP)/config.h: $(PERL_SRC)/config.sh\n\t-$(NOECHO) $(ECHO) \"Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh\"; $(FALSE)\n\n$(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh\n\t$(NOECHO) $(ECHO) \"Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh\"\n\t%s\nMAKE_FRAG\n\n    return join \"\", @m unless $self->needs_linking;\n\n    if ($self->{OBJECT}) {\n        # Need to add an object file dependency on the perl headers.\n        # this is very important for XS modules in perl.git development.\n        push @m, $self->_perl_header_files_fragment(\"/\"); # Directory separator between $(PERL_INC)/header.h\n    }\n\n    push @m, join(\" \", sort values %{$self->{XS}}).\" : \\$(XSUBPPDEPS)\\n\"  if %{$self->{XS}};\n\n    return join \"\\n\", @m;\n}\n\n\n=item pm_to_blib\n\nDefines target that copies all files in the hash PM to their\ndestination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>\n\n=cut\n\nsub pm_to_blib {\n    my $self = shift;\n    my($autodir) = $self->catdir('$(INST_LIB)','auto');\n    my $r = q{\npm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)\n};\n\n    # VMS will swallow '' and PM_FILTER is often empty.  So use q[]\n    my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);\npm_to_blib({\\@ARGV}, '$autodir', q[\\$(PM_FILTER)], '\\$(PERM_DIR)')\nCODE\n\n    my @cmds = $self->split_command($pm_to_blib,\n                  map { ($self->quote_literal($_) => $self->quote_literal($self->{PM}->{$_})) } sort keys %{$self->{PM}});\n\n    $r .= join '', map { \"\\t\\$(NOECHO) $_\\n\" } @cmds;\n    $r .= qq{\\t\\$(NOECHO) \\$(TOUCH) pm_to_blib\\n};\n\n    return $r;\n}\n\n# transform dot-separated version string into comma-separated quadruple\n# examples:  '1.2.3.4.5' => '1,2,3,4'\n#            '1.2.3'     => '1,2,3,0'\nsub _ppd_version {\n    my ($self, $string) = @_;\n    return join ',', ((split /\\./, $string), (0) x 4)[0..3];\n}\n\n=item ppd\n\nDefines target that creates a PPD (Perl Package Description) file\nfor a binary distribution.\n\n=cut\n\nsub ppd {\n    my($self) = @_;\n\n    my $abstract = $self->{ABSTRACT} || '';\n    $abstract =~ s/\\n/\\\\n/sg;\n    $abstract =~ s/</&lt;/g;\n    $abstract =~ s/>/&gt;/g;\n\n    my $author = join(', ',@{ ref $self->{AUTHOR} eq 'ARRAY' ? $self->{AUTHOR} : [ $self->{AUTHOR} || '']});\n    $author =~ s/</&lt;/g;\n    $author =~ s/>/&gt;/g;\n\n    my $ppd_file = \"$self->{DISTNAME}.ppd\";\n\n    my @ppd_chunks = qq(<SOFTPKG NAME=\"$self->{DISTNAME}\" VERSION=\"$self->{VERSION}\">\\n);\n\n    push @ppd_chunks, sprintf <<'PPD_HTML', $abstract, $author;\n    <ABSTRACT>%s</ABSTRACT>\n    <AUTHOR>%s</AUTHOR>\nPPD_HTML\n\n    push @ppd_chunks, \"    <IMPLEMENTATION>\\n\";\n    if ( $self->{MIN_PERL_VERSION} ) {\n        my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});\n        push @ppd_chunks, sprintf <<'PPD_PERLVERS', $min_perl_version;\n        <PERLCORE VERSION=\"%s\" />\nPPD_PERLVERS\n\n    }\n\n    # Don't add \"perl\" to requires.  perl dependencies are\n    # handles by ARCHITECTURE.\n    my %prereqs = %{$self->{PREREQ_PM}};\n    delete $prereqs{perl};\n\n    # Build up REQUIRE\n    foreach my $prereq (sort keys %prereqs) {\n        my $name = $prereq;\n        $name .= '::' unless $name =~ /::/;\n        my $version = $prereqs{$prereq};\n\n        my %attrs = ( NAME => $name );\n        $attrs{VERSION} = $version if $version;\n        my $attrs = join \" \", map { qq[$_=\"$attrs{$_}\"] } sort keys %attrs;\n        push @ppd_chunks, qq(        <REQUIRE $attrs />\\n);\n    }\n\n    my $archname = $Config{archname};\n    if ($] >= 5.008) {\n        # archname did not change from 5.6 to 5.8, but those versions may\n        # not be not binary compatible so now we append the part of the\n        # version that changes when binary compatibility may change\n        $archname .= \"-$Config{PERL_REVISION}.$Config{PERL_VERSION}\";\n    }\n    push @ppd_chunks, sprintf <<'PPD_OUT', $archname;\n        <ARCHITECTURE NAME=\"%s\" />\nPPD_OUT\n\n    if ($self->{PPM_INSTALL_SCRIPT}) {\n        if ($self->{PPM_INSTALL_EXEC}) {\n            push @ppd_chunks, sprintf qq{        <INSTALL EXEC=\"%s\">%s</INSTALL>\\n},\n                  $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};\n        }\n        else {\n            push @ppd_chunks, sprintf qq{        <INSTALL>%s</INSTALL>\\n},\n                  $self->{PPM_INSTALL_SCRIPT};\n        }\n    }\n\n    if ($self->{PPM_UNINSTALL_SCRIPT}) {\n        if ($self->{PPM_UNINSTALL_EXEC}) {\n            push @ppd_chunks, sprintf qq{        <UNINSTALL EXEC=\"%s\">%s</UNINSTALL>\\n},\n                  $self->{PPM_UNINSTALL_EXEC}, $self->{PPM_UNINSTALL_SCRIPT};\n        }\n        else {\n            push @ppd_chunks, sprintf qq{        <UNINSTALL>%s</UNINSTALL>\\n},\n                  $self->{PPM_UNINSTALL_SCRIPT};\n        }\n    }\n\n    my ($bin_location) = $self->{BINARY_LOCATION} || '';\n    $bin_location =~ s/\\\\/\\\\\\\\/g;\n\n    push @ppd_chunks, sprintf <<'PPD_XML', $bin_location;\n        <CODEBASE HREF=\"%s\" />\n    </IMPLEMENTATION>\n</SOFTPKG>\nPPD_XML\n\n    my @ppd_cmds = $self->stashmeta(join('', @ppd_chunks), $ppd_file);\n\n    return sprintf <<'PPD_OUT', join \"\\n\\t\", @ppd_cmds;\n# Creates a PPD (Perl Package Description) for a binary distribution.\nppd :\n\t%s\nPPD_OUT\n\n}\n\n=item prefixify\n\n  $MM->prefixify($var, $prefix, $new_prefix, $default);\n\nUsing either $MM->{uc $var} || $Config{lc $var}, it will attempt to\nreplace it's $prefix with a $new_prefix.\n\nShould the $prefix fail to match I<AND> a PREFIX was given as an\nargument to WriteMakefile() it will set it to the $new_prefix +\n$default.  This is for systems whose file layouts don't neatly fit into\nour ideas of prefixes.\n\nThis is for heuristics which attempt to create directory structures\nthat mirror those of the installed perl.\n\nFor example:\n\n    $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');\n\nthis will attempt to remove '/usr' from the front of the\n$MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}\nif necessary) and replace it with '/home/foo'.  If this fails it will\nsimply use '/home/foo/man/man1'.\n\n=cut\n\nsub prefixify {\n    my($self,$var,$sprefix,$rprefix,$default) = @_;\n\n    my $path = $self->{uc $var} ||\n               $Config_Override{lc $var} || $Config{lc $var} || '';\n\n    $rprefix .= '/' if $sprefix =~ m|/$|;\n\n    warn \"  prefixify $var => $path\\n\" if $Verbose >= 2;\n    warn \"    from $sprefix to $rprefix\\n\" if $Verbose >= 2;\n\n    if( $self->{ARGS}{PREFIX} &&\n        $path !~ s{^\\Q$sprefix\\E\\b}{$rprefix}s )\n    {\n\n        warn \"    cannot prefix, using default.\\n\" if $Verbose >= 2;\n        warn \"    no default!\\n\" if !$default && $Verbose >= 2;\n\n        $path = $self->catdir($rprefix, $default) if $default;\n    }\n\n    print \"    now $path\\n\" if $Verbose >= 2;\n    return $self->{uc $var} = $path;\n}\n\n\n=item processPL (o)\n\nDefines targets to run *.PL files.\n\n=cut\n\nsub processPL {\n    my $self = shift;\n    my $pl_files = $self->{PL_FILES};\n\n    return \"\" unless $pl_files;\n\n    my $m = '';\n    foreach my $plfile (sort keys %$pl_files) {\n        my $list = ref($pl_files->{$plfile})\n                     ?  $pl_files->{$plfile}\n                     : [$pl_files->{$plfile}];\n\n        foreach my $target (@$list) {\n            if( $Is{VMS} ) {\n                $plfile = vmsify($self->eliminate_macros($plfile));\n                $target = vmsify($self->eliminate_macros($target));\n            }\n\n            # Normally a .PL file runs AFTER pm_to_blib so it can have\n            # blib in its @INC and load the just built modules.  BUT if\n            # the generated module is something in $(TO_INST_PM) which\n            # pm_to_blib depends on then it can't depend on pm_to_blib\n            # else we have a dependency loop.\n            my $pm_dep;\n            my $perlrun;\n            if( defined $self->{PM}{$target} ) {\n                $pm_dep  = '';\n                $perlrun = 'PERLRUN';\n            }\n            else {\n                $pm_dep  = 'pm_to_blib';\n                $perlrun = 'PERLRUNINST';\n            }\n\n            $m .= <<MAKE_FRAG;\n\nall :: $target\n\t\\$(NOECHO) \\$(NOOP)\n\n$target :: $plfile $pm_dep\n\t\\$($perlrun) $plfile $target\nMAKE_FRAG\n\n        }\n    }\n\n    return $m;\n}\n\n=item specify_shell\n\nSpecify SHELL if needed - not done on Unix.\n\n=cut\n\nsub specify_shell {\n  return '';\n}\n\n=item quote_paren\n\nBackslashes parentheses C<()> in command line arguments.\nDoesn't handle recursive Makefile C<$(...)> constructs,\nbut handles simple ones.\n\n=cut\n\nsub quote_paren {\n    my $arg = shift;\n    $arg =~ s{\\$\\((.+?)\\)}{\\$\\\\\\\\($1\\\\\\\\)}g;\t# protect $(...)\n    $arg =~ s{(?<!\\\\)([()])}{\\\\$1}g;\t\t# quote unprotected\n    $arg =~ s{\\$\\\\\\\\\\((.+?)\\\\\\\\\\)}{\\$($1)}g;\t# unprotect $(...)\n    return $arg;\n}\n\n=item replace_manpage_separator\n\n  my $man_name = $MM->replace_manpage_separator($file_path);\n\nTakes the name of a package, which may be a nested package, in the\nform 'Foo/Bar.pm' and replaces the slash with C<::> or something else\nsafe for a man page file name.  Returns the replacement.\n\n=cut\n\nsub replace_manpage_separator {\n    my($self,$man) = @_;\n\n    $man =~ s,/+,::,g;\n    return $man;\n}\n\n\n=item cd\n\n=cut\n\nsub cd {\n    my($self, $dir, @cmds) = @_;\n\n    # No leading tab and no trailing newline makes for easier embedding\n    my $make_frag = join \"\\n\\t\", map { \"cd $dir && $_\" } @cmds;\n\n    return $make_frag;\n}\n\n=item oneliner\n\n=cut\n\nsub oneliner {\n    my($self, $cmd, $switches) = @_;\n    $switches = [] unless defined $switches;\n\n    # Strip leading and trailing newlines\n    $cmd =~ s{^\\n+}{};\n    $cmd =~ s{\\n+$}{};\n\n    my @cmds = split /\\n/, $cmd;\n    $cmd = join \" \\n\\t  -e \", map $self->quote_literal($_), @cmds;\n    $cmd = $self->escape_newlines($cmd);\n\n    $switches = join ' ', @$switches;\n\n    return qq{\\$(ABSPERLRUN) $switches -e $cmd --};\n}\n\n\n=item quote_literal\n\nQuotes macro literal value suitable for being used on a command line so\nthat when expanded by make, will be received by command as given to\nthis method:\n\n  my $quoted = $mm->quote_literal(q{it isn't});\n  # returns:\n  #   'it isn'\\''t'\n  print MAKEFILE \"target:\\n\\techo $quoted\\n\";\n  # when run \"make target\", will output:\n  #   it isn't\n\n=cut\n\nsub quote_literal {\n    my($self, $text, $opts) = @_;\n    $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};\n\n    # Quote single quotes\n    $text =~ s{'}{'\\\\''}g;\n\n    $text = $opts->{allow_variables}\n      ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);\n\n    return \"'$text'\";\n}\n\n\n=item escape_newlines\n\n=cut\n\nsub escape_newlines {\n    my($self, $text) = @_;\n\n    $text =~ s{\\n}{\\\\\\n}g;\n\n    return $text;\n}\n\n\n=item max_exec_len\n\nUsing POSIX::ARG_MAX.  Otherwise falling back to 4096.\n\n=cut\n\nsub max_exec_len {\n    my $self = shift;\n\n    if (!defined $self->{_MAX_EXEC_LEN}) {\n        if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {\n            $self->{_MAX_EXEC_LEN} = $arg_max;\n        }\n        else {      # POSIX minimum exec size\n            $self->{_MAX_EXEC_LEN} = 4096;\n        }\n    }\n\n    return $self->{_MAX_EXEC_LEN};\n}\n\n\n=item static (o)\n\nDefines the static target.\n\n=cut\n\nsub static {\n# --- Static Loading Sections ---\n\n    my($self) = shift;\n    '\n## $(INST_PM) has been moved to the all: target.\n## It remains here for awhile to allow for old usage: \"make static\"\nstatic :: $(FIRST_MAKEFILE) $(INST_STATIC)\n\t$(NOECHO) $(NOOP)\n';\n}\n\nsub static_lib {\n    my($self) = @_;\n    return '' unless $self->has_link_code;\n    my(@m);\n    my @libs;\n    if ($self->{XSMULTI}) {\n\tfor my $ext ($self->_xs_list_basenames) {\n\t    my ($v, $d, $f) = File::Spec->splitpath($ext);\n\t    my @d = File::Spec->splitdir($d);\n\t    shift @d if $d[0] eq 'lib';\n\t    my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);\n\t    my $instfile = $self->catfile($instdir, \"$f\\$(LIB_EXT)\");\n\t    my $objfile = \"$ext\\$(OBJ_EXT)\";\n\t    push @libs, [ $objfile, $instfile, $instdir ];\n\t}\n    } else {\n\t@libs = ([ qw($(OBJECT) $(INST_STATIC) $(INST_ARCHAUTODIR)) ]);\n    }\n    push @m, map { $self->xs_make_static_lib(@$_); } @libs;\n    join \"\\n\", @m;\n}\n\n=item xs_make_static_lib\n\nDefines the recipes for the C<static_lib> section.\n\n=cut\n\nsub xs_make_static_lib {\n    my ($self, $from, $to, $todir) = @_;\n    my @m = sprintf '%s: %s $(MYEXTLIB) %s$(DFSEP).exists'.\"\\n\", $to, $from, $todir;\n    push @m, \"\\t\\$(RM_F) \\\"\\$\\@\\\"\\n\";\n    push @m, $self->static_lib_fixtures;\n    push @m, $self->static_lib_pure_cmd($from);\n    push @m, \"\\t\\$(CHMOD) \\$(PERM_RWX) \\$\\@\\n\";\n    push @m, $self->static_lib_closures($todir);\n    join '', @m;\n}\n\n=item static_lib_closures\n\nRecords C<$(EXTRALIBS)> in F<extralibs.ld> and F<$(PERL_SRC)/ext.libs>.\n\n=cut\n\nsub static_lib_closures {\n    my ($self, $todir) = @_;\n    my @m = sprintf <<'MAKE_FRAG', $todir;\n\t$(NOECHO) $(ECHO) \"$(EXTRALIBS)\" > %s$(DFSEP)extralibs.ld\nMAKE_FRAG\n    # Old mechanism - still available:\n    push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};\n\t$(NOECHO) $(ECHO) \"$(EXTRALIBS)\" >> $(PERL_SRC)$(DFSEP)ext.libs\nMAKE_FRAG\n    @m;\n}\n\n=item static_lib_fixtures\n\nHandles copying C<$(MYEXTLIB)> as starter for final static library that\nthen gets added to.\n\n=cut\n\nsub static_lib_fixtures {\n    my ($self) = @_;\n    # If this extension has its own library (eg SDBM_File)\n    # then copy that to $(INST_STATIC) and add $(OBJECT) into it.\n    return unless $self->{MYEXTLIB};\n    \"\\t\\$(CP) \\$(MYEXTLIB) \\\"\\$\\@\\\"\\n\";\n}\n\n=item static_lib_pure_cmd\n\nDefines how to run the archive utility.\n\n=cut\n\nsub static_lib_pure_cmd {\n    my ($self, $from) = @_;\n    my $ar;\n    if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {\n        # Prefer the absolute pathed ar if available so that PATH\n        # doesn't confuse us.  Perl itself is built with the full_ar.\n        $ar = 'FULL_AR';\n    } else {\n        $ar = 'AR';\n    }\n    sprintf <<'MAKE_FRAG', $ar, $from;\n\t$(%s) $(AR_STATIC_ARGS) \"$@\" %s\n\t$(RANLIB) \"$@\"\nMAKE_FRAG\n}\n\n=item staticmake (o)\n\nCalls makeaperl.\n\n=cut\n\nsub staticmake {\n    my($self, %attribs) = @_;\n    my(@static);\n\n    my(@searchdirs)=($self->{PERL_ARCHLIB}, $self->{SITEARCHEXP},  $self->{INST_ARCHLIB});\n\n    # And as it's not yet built, we add the current extension\n    # but only if it has some C code (or XS code, which implies C code)\n    if (@{$self->{C}}) {\n\t@static = $self->catfile($self->{INST_ARCHLIB},\n\t\t\t\t \"auto\",\n\t\t\t\t $self->{FULLEXT},\n\t\t\t\t \"$self->{BASEEXT}$self->{LIB_EXT}\"\n\t\t\t\t);\n    }\n\n    # Either we determine now, which libraries we will produce in the\n    # subdirectories or we do it at runtime of the make.\n\n    # We could ask all subdir objects, but I cannot imagine, why it\n    # would be necessary.\n\n    # Instead we determine all libraries for the new perl at\n    # runtime.\n    my(@perlinc) = ($self->{INST_ARCHLIB}, $self->{INST_LIB}, $self->{PERL_ARCHLIB}, $self->{PERL_LIB});\n\n    $self->makeaperl(MAKE\t=> $self->{MAKEFILE},\n\t\t     DIRS\t=> \\@searchdirs,\n\t\t     STAT\t=> \\@static,\n\t\t     INCL\t=> \\@perlinc,\n\t\t     TARGET\t=> $self->{MAP_TARGET},\n\t\t     TMP\t=> \"\",\n\t\t     LIBPERL\t=> $self->{LIBPERL_A}\n\t\t    );\n}\n\n=item subdir_x (o)\n\nHelper subroutine for subdirs\n\n=cut\n\nsub subdir_x {\n    my($self, $subdir) = @_;\n\n    my $subdir_cmd = $self->cd($subdir,\n      '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'\n    );\n    return sprintf <<'EOT', $subdir_cmd;\n\nsubdirs ::\n\t$(NOECHO) %s\nEOT\n\n}\n\n=item subdirs (o)\n\nDefines targets to process subdirectories.\n\n=cut\n\nsub subdirs {\n# --- Sub-directory Sections ---\n    my($self) = shift;\n    my(@m);\n    # This method provides a mechanism to automatically deal with\n    # subdirectories containing further Makefile.PL scripts.\n    # It calls the subdir_x() method for each subdirectory.\n    foreach my $dir (@{$self->{DIR}}){\n\tpush @m, $self->subdir_x($dir);\n####\tprint \"Including $dir subdirectory\\n\";\n    }\n    if (@m){\n\tunshift @m, <<'EOF';\n\n# The default clean, realclean and test targets in this Makefile\n# have automatically been given entries for each subdir.\n\nEOF\n    } else {\n\tpush(@m, \"\\n# none\")\n    }\n    join('',@m);\n}\n\n=item test (o)\n\nDefines the test targets.\n\n=cut\n\nsub test {\n    my($self, %attribs) = @_;\n    my $tests = $attribs{TESTS} || '';\n    if (!$tests && -d 't' && defined $attribs{RECURSIVE_TEST_FILES}) {\n        $tests = $self->find_tests_recursive;\n    }\n    elsif (!$tests && -d 't') {\n        $tests = $self->find_tests;\n    }\n    # have to do this because nmake is broken\n    $tests =~ s!/!\\\\!g if $self->is_make_type('nmake');\n    # note: 'test.pl' name is also hardcoded in init_dirscan()\n    my @m;\n    my $default_testtype = $Config{usedl} ? 'dynamic' : 'static';\n    push @m, <<EOF;\nTEST_VERBOSE=0\nTEST_TYPE=test_\\$(LINKTYPE)\nTEST_FILE = test.pl\nTEST_FILES = $tests\nTESTDB_SW = -d\n\ntestdb :: testdb_\\$(LINKTYPE)\n\t\\$(NOECHO) \\$(NOOP)\n\ntest :: \\$(TEST_TYPE)\n\t\\$(NOECHO) \\$(NOOP)\n\n# Occasionally we may face this degenerate target:\ntest_ : test_$default_testtype\n\t\\$(NOECHO) \\$(NOOP)\n\nEOF\n\n    for my $linktype (qw(dynamic static)) {\n        my $directdeps = \"$linktype pure_all\";\n        push @m, \"subdirs-test_$linktype :: $directdeps\\n\";\n        foreach my $dir (@{ $self->{DIR} }) {\n            my $test = $self->cd($dir, \"\\$(MAKE) test_$linktype \\$(PASTHRU)\");\n            push @m, \"\\t\\$(NOECHO) $test\\n\";\n        }\n        push @m, \"\\n\";\n        if ($tests or -f \"test.pl\") {\n            for my $testspec ([ '', '' ], [ 'db', ' $(TESTDB_SW)' ]) {\n                my ($db, $switch) = @$testspec;\n                my ($command, $deps);\n                # if testdb, build all but don't test all\n                $deps = $db eq 'db' ? $directdeps : \"subdirs-test_$linktype\";\n                if ($linktype eq 'static' and $self->needs_linking) {\n                    my $target = File::Spec->rel2abs('$(MAP_TARGET)');\n                    $command = qq{\"$target\" \\$(MAP_PERLINC)};\n                    $deps .= ' $(MAP_TARGET)';\n                } else {\n                    $command = '$(FULLPERLRUN)' . $switch;\n                }\n                push @m, \"test${db}_$linktype :: $deps\\n\";\n                if ($db eq 'db') {\n                    push @m, $self->test_via_script($command, '$(TEST_FILE)')\n                } else {\n                    push @m, $self->test_via_script($command, '$(TEST_FILE)')\n                        if -f \"test.pl\";\n                    push @m, $self->test_via_harness($command, '$(TEST_FILES)')\n                        if $tests;\n                }\n                push @m, \"\\n\";\n            }\n        } else {\n            push @m, _sprintf562 <<'EOF', $linktype;\ntestdb_%1$s test_%1$s :: subdirs-test_%1$s\n\t$(NOECHO) $(ECHO) 'No tests defined for $(NAME) extension.'\n\nEOF\n        }\n    }\n\n    join \"\", @m;\n}\n\n=item test_via_harness (override)\n\nFor some reason which I forget, Unix machines like to have\nPERL_DL_NONLAZY set for tests.\n\n=cut\n\nsub test_via_harness {\n    my($self, $perl, $tests) = @_;\n    return $self->SUPER::test_via_harness(\"PERL_DL_NONLAZY=1 $perl\", $tests);\n}\n\n=item test_via_script (override)\n\nAgain, the PERL_DL_NONLAZY thing.\n\n=cut\n\nsub test_via_script {\n    my($self, $perl, $script) = @_;\n    return $self->SUPER::test_via_script(\"PERL_DL_NONLAZY=1 $perl\", $script);\n}\n\n\n=item tool_xsubpp (o)\n\nDetermines typemaps, xsubpp version, prototype behaviour.\n\n=cut\n\nsub tool_xsubpp {\n    my($self) = shift;\n    return \"\" unless $self->needs_linking;\n\n    my $xsdir;\n    my @xsubpp_dirs = @INC;\n\n    # Make sure we pick up the new xsubpp if we're building perl.\n    unshift @xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};\n\n    my $foundxsubpp = 0;\n    foreach my $dir (@xsubpp_dirs) {\n        $xsdir = $self->catdir($dir, 'ExtUtils');\n        if( -r $self->catfile($xsdir, \"xsubpp\") ) {\n            $foundxsubpp = 1;\n            last;\n        }\n    }\n    die \"ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp\" if !$foundxsubpp;\n\n    my $tmdir   = $self->catdir($self->{PERL_LIB},\"ExtUtils\");\n    my(@tmdeps) = $self->catfile($tmdir,'typemap');\n    if( $self->{TYPEMAPS} ){\n        foreach my $typemap (@{$self->{TYPEMAPS}}){\n            if( ! -f  $typemap ) {\n                warn \"Typemap $typemap not found.\\n\";\n            }\n            else {\n                $typemap = vmsify($typemap) if $Is{VMS};\n                push(@tmdeps, $typemap);\n            }\n        }\n    }\n    push(@tmdeps, \"typemap\") if -f \"typemap\";\n    # absolutised because with deep-located typemaps, eg \"lib/XS/typemap\",\n    # if xsubpp is called from top level with\n    #     $(XSUBPP) ... -typemap \"lib/XS/typemap\" \"lib/XS/Test.xs\"\n    # it says:\n    #     Can't find lib/XS/type map in (fulldir)/lib/XS\n    # because ExtUtils::ParseXS::process_file chdir's to .xs file's\n    # location. This is the only way to get all specified typemaps used,\n    # wherever located.\n    my @tmargs = map { '-typemap '.$self->quote_literal(File::Spec->rel2abs($_)) } @tmdeps;\n    $_ = $self->quote_dep($_) for @tmdeps;\n    if( exists $self->{XSOPT} ){\n        unshift( @tmargs, $self->{XSOPT} );\n    }\n\n    if ($Is{VMS}                          &&\n        $Config{'ldflags'}               &&\n        $Config{'ldflags'} =~ m!/Debug!i &&\n        (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)\n       )\n    {\n        unshift(@tmargs,'-nolinenumbers');\n    }\n\n\n    $self->{XSPROTOARG} = \"\" unless defined $self->{XSPROTOARG};\n    my $xsdirdep = $self->quote_dep($xsdir);\n    # -dep for use when dependency not command\n\n    return qq{\nXSUBPPDIR = $xsdir\nXSUBPP = \"\\$(XSUBPPDIR)\\$(DFSEP)xsubpp\"\nXSUBPPRUN = \\$(PERLRUN) \\$(XSUBPP)\nXSPROTOARG = $self->{XSPROTOARG}\nXSUBPPDEPS = @tmdeps $xsdirdep\\$(DFSEP)xsubpp\nXSUBPPARGS = @tmargs\nXSUBPP_EXTRA_ARGS =\n};\n}\n\n\n=item all_target\n\nBuild man pages, too\n\n=cut\n\nsub all_target {\n    my $self = shift;\n\n    return <<'MAKE_EXT';\nall :: pure_all manifypods\n\t$(NOECHO) $(NOOP)\nMAKE_EXT\n}\n\n=item top_targets (o)\n\nDefines the targets all, subdirs, config, and O_FILES\n\n=cut\n\nsub top_targets {\n# --- Target Sections ---\n\n    my($self) = shift;\n    my(@m);\n\n    push @m, $self->all_target, \"\\n\" unless $self->{SKIPHASH}{'all'};\n\n    push @m, sprintf <<'EOF';\npure_all :: config pm_to_blib subdirs linkext\n\t$(NOECHO) $(NOOP)\n\n\t$(NOECHO) $(NOOP)\n\nsubdirs :: $(MYEXTLIB)\n\t$(NOECHO) $(NOOP)\n\nconfig :: $(FIRST_MAKEFILE) blibdirs\n\t$(NOECHO) $(NOOP)\nEOF\n\n    push @m, '\n$(O_FILES) : $(H_FILES)\n' if @{$self->{O_FILES} || []} && @{$self->{H} || []};\n\n    push @m, q{\nhelp :\n\tperldoc ExtUtils::MakeMaker\n};\n\n    join('',@m);\n}\n\n=item writedoc\n\nObsolete, deprecated method. Not used since Version 5.21.\n\n=cut\n\nsub writedoc {\n# --- perllocal.pod section ---\n    my($self,$what,$name,@attribs)=@_;\n    my $time = localtime;\n    print \"=head2 $time: $what C<$name>\\n\\n=over 4\\n\\n=item *\\n\\n\";\n    print join \"\\n\\n=item *\\n\\n\", map(\"C<$_>\",@attribs);\n    print \"\\n\\n=back\\n\\n\";\n}\n\n=item xs_c (o)\n\nDefines the suffix rules to compile XS files to C.\n\n=cut\n\nsub xs_c {\n    my($self) = shift;\n    return '' unless $self->needs_linking();\n    '\n.xs.c:\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc\n\t$(MV) $*.xsc $*.c\n';\n}\n\n=item xs_cpp (o)\n\nDefines the suffix rules to compile XS files to C++.\n\n=cut\n\nsub xs_cpp {\n    my($self) = shift;\n    return '' unless $self->needs_linking();\n    '\n.xs.cpp:\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc\n\t$(MV) $*.xsc $*.cpp\n';\n}\n\n=item xs_o (o)\n\nDefines suffix rules to go from XS to object files directly. This was\noriginally only intended for broken make implementations, but is now\nnecessary for per-XS file under C<XSMULTI>, since each XS file might\nhave an individual C<$(VERSION)>.\n\n=cut\n\nsub xs_o {\n    my ($self) = @_;\n    return '' unless $self->needs_linking();\n    my $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*$(OBJ_EXT)') : '';\n    my $frag = '';\n    # dmake makes noise about ambiguous rule\n    $frag .= sprintf <<'EOF', $m_o unless $self->is_make_type('dmake');\n.xs$(OBJ_EXT) :\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc\n\t$(MV) $*.xsc $*.c\n\t$(CCCMD) $(CCCDLFLAGS) \"-I$(PERL_INC)\" $(PASTHRU_DEFINE) $(DEFINE) $*.c %s\nEOF\n    if ($self->{XSMULTI}) {\n\tfor my $ext ($self->_xs_list_basenames) {\n\t    my $pmfile = \"$ext.pm\";\n\t    croak \"$ext.xs has no matching $pmfile: $!\" unless -f $pmfile;\n\t    my $version = $self->parse_version($pmfile);\n\t    my $cccmd = $self->{CONST_CCCMD};\n\t    $cccmd =~ s/^\\s*CCCMD\\s*=\\s*//;\n\t    $cccmd =~ s/\\$\\(DEFINE_VERSION\\)/-DVERSION=\\\\\"$version\\\\\"/;\n\t    $cccmd =~ s/\\$\\(XS_DEFINE_VERSION\\)/-DXS_VERSION=\\\\\"$version\\\\\"/;\n            $self->_xsbuild_replace_macro($cccmd, 'xs', $ext, 'INC');\n            my $define = '$(DEFINE)';\n            $self->_xsbuild_replace_macro($define, 'xs', $ext, 'DEFINE');\n            #                             1     2       3     4\n            $frag .= _sprintf562 <<'EOF', $ext, $cccmd, $m_o, $define;\n\n%1$s$(OBJ_EXT): %1$s.xs\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc\n\t$(MV) $*.xsc $*.c\n\t%2$s $(CCCDLFLAGS) \"-I$(PERL_INC)\" $(PASTHRU_DEFINE) %4$s $*.c %3$s\nEOF\n\t}\n    }\n    $frag;\n}\n\n# param gets modified\nsub _xsbuild_replace_macro {\n    my ($self, undef, $xstype, $ext, $varname) = @_;\n    my $value = $self->_xsbuild_value($xstype, $ext, $varname);\n    return unless defined $value;\n    $_[1] =~ s/\\$\\($varname\\)/$value/;\n}\n\nsub _xsbuild_value {\n    my ($self, $xstype, $ext, $varname) = @_;\n    return $self->{XSBUILD}{$xstype}{$ext}{$varname}\n        if $self->{XSBUILD}{$xstype}{$ext}{$varname};\n    return $self->{XSBUILD}{$xstype}{all}{$varname}\n        if $self->{XSBUILD}{$xstype}{all}{$varname};\n    ();\n}\n\n1;\n\n=back\n\n=head1 SEE ALSO\n\nL<ExtUtils::MakeMaker>\n\n=cut\n\n__END__\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_AIX.pm": "package ExtUtils::MM_AIX;\n\nuse strict;\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\nrequire ExtUtils::MM_Unix;\nour @ISA = qw(ExtUtils::MM_Unix);\n\n=head1 NAME\n\nExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix\n\n=head1 SYNOPSIS\n\n  Don't use this module directly.\n  Use ExtUtils::MM and let it choose.\n\n=head1 DESCRIPTION\n\nThis is a subclass of ExtUtils::MM_Unix which contains functionality for\nAIX.\n\nUnless otherwise stated it works just like ExtUtils::MM_Unix\n\n=head2 Overridden methods\n\n=head3 dlsyms\n\nDefine DL_FUNCS and DL_VARS and write the *.exp files.\n\n=cut\n\nsub dlsyms {\n    my($self,%attribs) = @_;\n    return '' unless $self->needs_linking;\n    my @m;\n    # these will need XSMULTI-fying but maybe that already happens\n    push @m,\"\\ndynamic :: $self->{BASEEXT}.exp\\n\\n\"\n      unless $self->{SKIPHASH}{'dynamic'}; # dynamic and static are subs, so...\n    push @m,\"\\nstatic :: $self->{BASEEXT}.exp\\n\\n\"\n      unless $self->{SKIPHASH}{'static'};  # we avoid a warning if we tick them\n    join \"\\n\", @m, $self->xs_dlsyms_iterator(\\%attribs);\n}\n\n=head3 xs_dlsyms_ext\n\nOn AIX, is C<.exp>.\n\n=cut\n\nsub xs_dlsyms_ext {\n    '.exp';\n}\n\n=head1 AUTHOR\n\nMichael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix\n\n=head1 SEE ALSO\n\nL<ExtUtils::MakeMaker>\n\n=cut\n\n\n1;\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_NW5.pm": "package ExtUtils::MM_NW5;\n\n=head1 NAME\n\nExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker\n\n=head1 SYNOPSIS\n\n use ExtUtils::MM_NW5; # Done internally by ExtUtils::MakeMaker if needed\n\n=head1 DESCRIPTION\n\nSee ExtUtils::MM_Unix for a documentation of the methods provided\nthere. This package overrides the implementation of these methods, not\nthe semantics.\n\n=over\n\n=cut\n\nuse strict;\nuse ExtUtils::MakeMaker::Config;\nuse File::Basename;\n\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\nrequire ExtUtils::MM_Win32;\nour @ISA = qw(ExtUtils::MM_Win32);\n\nuse ExtUtils::MakeMaker qw(&neatvalue &_sprintf562);\n\n$ENV{EMXSHELL} = 'sh'; # to run `commands`\n\nmy $BORLAND  = $Config{'cc'} =~ /\\bbcc/i;\nmy $GCC      = $Config{'cc'} =~ /\\bgcc/i;\n\n\n=item os_flavor\n\nWe're Netware in addition to being Windows.\n\n=cut\n\nsub os_flavor {\n    my $self = shift;\n    return ($self->SUPER::os_flavor, 'Netware');\n}\n\n=item init_platform\n\nAdd Netware macros.\n\nLIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL,\nNLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION\n\n\n=item platform_constants\n\nAdd Netware macros initialized above to the Makefile.\n\n=cut\n\nsub init_platform {\n    my($self) = shift;\n\n    # To get Win32's setup.\n    $self->SUPER::init_platform;\n\n    # incpath is copied to makefile var INCLUDE in constants sub, here just\n    # make it empty\n    my $libpth = $Config{'libpth'};\n    $libpth =~ s( )(;);\n    $self->{'LIBPTH'} = $libpth;\n\n    $self->{'BASE_IMPORT'} = $Config{'base_import'};\n\n    # Additional import file specified from Makefile.pl\n    if($self->{'base_import'}) {\n        $self->{'BASE_IMPORT'} .= ', ' . $self->{'base_import'};\n    }\n\n    $self->{'NLM_VERSION'} = $Config{'nlm_version'};\n    $self->{'MPKTOOL'}\t= $Config{'mpktool'};\n    $self->{'TOOLPATH'}\t= $Config{'toolpath'};\n\n    (my $boot = $self->{'NAME'}) =~ s/:/_/g;\n    $self->{'BOOT_SYMBOL'}=$boot;\n\n    # If the final binary name is greater than 8 chars,\n    # truncate it here.\n    if(length($self->{'BASEEXT'}) > 8) {\n        $self->{'NLM_SHORT_NAME'} = substr($self->{'BASEEXT'},0,8);\n    }\n\n    # Get the include path and replace the spaces with ;\n    # Copy this to makefile as INCLUDE = d:\\...;d:\\;\n    ($self->{INCLUDE} = $Config{'incpath'}) =~ s/([ ]*)-I/;/g;\n\n    # Set the path to CodeWarrior binaries which might not have been set in\n    # any other place\n    $self->{PATH} = '$(PATH);$(TOOLPATH)';\n\n    $self->{MM_NW5_VERSION} = $VERSION;\n}\n\nsub platform_constants {\n    my($self) = shift;\n    my $make_frag = '';\n\n    # Setup Win32's constants.\n    $make_frag .= $self->SUPER::platform_constants;\n\n    foreach my $macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL\n                          TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH\n                          MM_NW5_VERSION\n                      ))\n    {\n        next unless defined $self->{$macro};\n        $make_frag .= \"$macro = $self->{$macro}\\n\";\n    }\n\n    return $make_frag;\n}\n\n=item static_lib_pure_cmd\n\nDefines how to run the archive utility\n\n=cut\n\nsub static_lib_pure_cmd {\n    my ($self, $src) = @_;\n    $src =~ s/(\\$\\(\\w+)(\\))/$1:^\"+\"$2/g if $BORLAND;\n    sprintf qq{\\t\\$(AR) %s\\n}, ($BORLAND ? '$@ ' . $src\n                          : ($GCC ? '-ru $@ ' . $src\n                                  : '-type library -o $@ ' . $src));\n}\n\n=item dynamic_lib\n\nOverride of utility methods for OS-specific work.\n\n=cut\n\nsub xs_make_dynamic_lib {\n    my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;\n    my @m;\n    # Taking care of long names like FileHandle, ByteLoader, SDBM_File etc\n    if ($to =~ /^\\$/) {\n        if ($self->{NLM_SHORT_NAME}) {\n            # deal with shortnames\n            my $newto = q{$(INST_AUTODIR)\\\\$(NLM_SHORT_NAME).$(DLEXT)};\n            push @m, \"$to: $newto\\n\\n\";\n            $to = $newto;\n        }\n    } else {\n        my ($v, $d, $f) = File::Spec->splitpath($to);\n        # relies on $f having a literal \".\" in it, unlike for $(OBJ_EXT)\n        if ($f =~ /[^\\.]{9}\\./) {\n            # 9+ chars before '.', need to shorten\n            $f = substr $f, 0, 8;\n        }\n        my $newto = File::Spec->catpath($v, $d, $f);\n        push @m, \"$to: $newto\\n\\n\";\n        $to = $newto;\n    }\n    # bits below should be in dlsyms, not here\n    #                                   1    2      3       4\n    push @m, _sprintf562 <<'MAKE_FRAG', $to, $from, $todir, $exportlist;\n# Create xdc data for an MT safe NLM in case of mpk build\n%1$s: %2$s $(MYEXTLIB) $(BOOTSTRAP) %3$s$(DFSEP).exists\n\t$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > %4$s\n\t$(NOECHO) $(ECHO) $(BASE_IMPORT) >> %4$s\n\t$(NOECHO) $(ECHO) Import @$(PERL_INC)\\perl.imp >> %4$s\nMAKE_FRAG\n    if ( $self->{CCFLAGS} =~ m/ -DMPK_ON /) {\n        (my $xdc = $exportlist) =~ s#def\\z#xdc#;\n        $xdc = '$(BASEEXT).xdc';\n        push @m, sprintf <<'MAKE_FRAG', $xdc, $exportlist;\n\t$(MPKTOOL) $(XDCFLAGS) %s\n\t$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> %s\nMAKE_FRAG\n    }\n    # Reconstruct the X.Y.Z version.\n    my $version = join '.', map { sprintf \"%d\", $_ }\n                              $] =~ /(\\d)\\.(\\d{3})(\\d{2})/;\n    push @m, sprintf <<'EOF', $from, $version, $to, $exportlist;\n\t$(LD) $(LDFLAGS) %s -desc \"Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)\" -nlmversion $(NLM_VERSION) -o %s $(MYEXTLIB) $(PERL_INC)\\Main.lib -commandfile %s\n\t$(CHMOD) 755 $@\nEOF\n    join '', @m;\n}\n\n1;\n__END__\n\n=back\n\n=cut\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_OS2.pm": "package ExtUtils::MM_OS2;\n\nuse strict;\n\nuse ExtUtils::MakeMaker qw(neatvalue);\nuse File::Spec;\n\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\nrequire ExtUtils::MM_Any;\nrequire ExtUtils::MM_Unix;\nour @ISA = qw(ExtUtils::MM_Any ExtUtils::MM_Unix);\n\n=pod\n\n=head1 NAME\n\nExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker\n\n=head1 SYNOPSIS\n\n use ExtUtils::MM_OS2; # Done internally by ExtUtils::MakeMaker if needed\n\n=head1 DESCRIPTION\n\nSee ExtUtils::MM_Unix for a documentation of the methods provided\nthere. This package overrides the implementation of these methods, not\nthe semantics.\n\n=head1 METHODS\n\n=over 4\n\n=item init_dist\n\nDefine TO_UNIX to convert OS2 linefeeds to Unix style.\n\n=cut\n\nsub init_dist {\n    my($self) = @_;\n\n    $self->{TO_UNIX} ||= <<'MAKE_TEXT';\n$(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip\nMAKE_TEXT\n\n    $self->SUPER::init_dist;\n}\n\nsub dlsyms {\n    my($self,%attribs) = @_;\n    if ($self->{IMPORTS} && %{$self->{IMPORTS}}) {\n\t# Make import files (needed for static build)\n\t-d 'tmp_imp' or mkdir 'tmp_imp', 0777 or die \"Can't mkdir tmp_imp\";\n\topen my $imp, '>', 'tmpimp.imp' or die \"Can't open tmpimp.imp\";\n\tforeach my $name (sort keys %{$self->{IMPORTS}}) {\n\t    my $exp = $self->{IMPORTS}->{$name};\n\t    my ($lib, $id) = ($exp =~ /(.*)\\.(.*)/) or die \"Malformed IMPORT `$exp'\";\n\t    print $imp \"$name $lib $id ?\\n\";\n\t}\n\tclose $imp or die \"Can't close tmpimp.imp\";\n\t# print \"emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp\\n\";\n\tsystem \"emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp\"\n\t    and die \"Cannot make import library: $!, \\$?=$?\";\n\t# May be running under miniperl, so have no glob...\n\teval { unlink <tmp_imp/*>; 1 } or system \"rm tmp_imp/*\";\n\tsystem \"cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}\"\n\t    and die \"Cannot extract import objects: $!, \\$?=$?\";\n    }\n    return '' if $self->{SKIPHASH}{'dynamic'};\n    $self->xs_dlsyms_iterator(\\%attribs);\n}\n\nsub xs_dlsyms_ext {\n    '.def';\n}\n\nsub xs_dlsyms_extra {\n    join '', map { qq{, \"$_\" => \"\\$($_)\"} } qw(VERSION DISTNAME INSTALLDIRS);\n}\n\nsub static_lib_pure_cmd {\n    my($self) = @_;\n    my $old = $self->SUPER::static_lib_pure_cmd;\n    return $old unless $self->{IMPORTS} && %{$self->{IMPORTS}};\n    $old . <<'EOC';\n\t$(AR) $(AR_STATIC_ARGS) \"$@\" tmp_imp/*\n\t$(RANLIB) \"$@\"\nEOC\n}\n\nsub replace_manpage_separator {\n    my($self,$man) = @_;\n    $man =~ s,/+,.,g;\n    $man;\n}\n\nsub maybe_command {\n    my($self,$file) = @_;\n    $file =~ s,[/\\\\]+,/,g;\n    return $file if -x $file && ! -d _;\n    return \"$file.exe\" if -x \"$file.exe\" && ! -d _;\n    return \"$file.cmd\" if -x \"$file.cmd\" && ! -d _;\n    return;\n}\n\n=item init_linker\n\n=cut\n\nsub init_linker {\n    my $self = shift;\n\n    $self->{PERL_ARCHIVE} = \"\\$(PERL_INC)/libperl\\$(LIB_EXT)\";\n\n    $self->{PERL_ARCHIVEDEP} ||= '';\n    $self->{PERL_ARCHIVE_AFTER} = $OS2::is_aout\n      ? ''\n      : '$(PERL_INC)/libperl_override$(LIB_EXT)';\n    $self->{EXPORT_LIST} = '$(BASEEXT).def';\n}\n\n=item os_flavor\n\nOS/2 is OS/2\n\n=cut\n\nsub os_flavor {\n    return('OS/2');\n}\n\n=back\n\n=cut\n\n1;\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/lib/ExtUtils/MM_VMS.pm": "package ExtUtils::MM_VMS;\n\nuse strict;\n\nuse ExtUtils::MakeMaker::Config;\nrequire Exporter;\n\nBEGIN {\n    # so we can compile the thing on non-VMS platforms.\n    if( $^O eq 'VMS' ) {\n        require VMS::Filespec;\n        VMS::Filespec->import;\n    }\n}\n\nuse File::Basename;\n\nour $VERSION = '7.24';\n$VERSION = eval $VERSION;\n\nrequire ExtUtils::MM_Any;\nrequire ExtUtils::MM_Unix;\nour @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );\n\nuse ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);\nour $Revision = $ExtUtils::MakeMaker::Revision;\n\n\n=head1 NAME\n\nExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker\n\n=head1 SYNOPSIS\n\n  Do not use this directly.\n  Instead, use ExtUtils::MM and it will figure out which MM_*\n  class to use for you.\n\n=head1 DESCRIPTION\n\nSee ExtUtils::MM_Unix for a documentation of the methods provided\nthere. This package overrides the implementation of these methods, not\nthe semantics.\n\n=head2 Methods always loaded\n\n=over 4\n\n=item wraplist\n\nConverts a list into a string wrapped at approximately 80 columns.\n\n=cut\n\nsub wraplist {\n    my($self) = shift;\n    my($line,$hlen) = ('',0);\n\n    foreach my $word (@_) {\n      # Perl bug -- seems to occasionally insert extra elements when\n      # traversing array (scalar(@array) doesn't show them, but\n      # foreach(@array) does) (5.00307)\n      next unless $word =~ /\\w/;\n      $line .= ' ' if length($line);\n      if ($hlen > 80) { $line .= \"\\\\\\n\\t\"; $hlen = 0; }\n      $line .= $word;\n      $hlen += length($word) + 2;\n    }\n    $line;\n}\n\n\n# This isn't really an override.  It's just here because ExtUtils::MM_VMS\n# appears in @MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()\n# in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just\n# mimic inheritance here and hand off to ExtUtils::Liblist::Kid.\n# XXX This hackery will die soon. --Schwern\nsub ext {\n    require ExtUtils::Liblist::Kid;\n    goto &ExtUtils::Liblist::Kid::ext;\n}\n\n=back\n\n=head2 Methods\n\nThose methods which override default MM_Unix methods are marked\n\"(override)\", while methods unique to MM_VMS are marked \"(specific)\".\nFor overridden methods, documentation is limited to an explanation\nof why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix\ndocumentation for more details.\n\n=over 4\n\n=item guess_name (override)\n\nTry to determine name of extension being built.  We begin with the name\nof the current directory.  Since VMS filenames are case-insensitive,\nhowever, we look for a F<.pm> file whose name matches that of the current\ndirectory (presumably the 'main' F<.pm> file for this extension), and try\nto find a C<package> statement from which to obtain the Mixed::Case\npackage name.\n\n=cut\n\nsub guess_name {\n    my($self) = @_;\n    my($defname,$defpm,@pm,%xs);\n    local *PM;\n\n    $defname = basename(fileify($ENV{'DEFAULT'}));\n    $defname =~ s![\\d\\-_]*\\.dir.*$!!;  # Clip off .dir;1 suffix, and package version\n    $defpm = $defname;\n    # Fallback in case for some reason a user has copied the files for an\n    # extension into a working directory whose name doesn't reflect the\n    # extension's name.  We'll use the name of a unique .pm file, or the\n    # first .pm file with a matching .xs file.\n    if (not -e \"${defpm}.pm\") {\n      @pm = glob('*.pm');\n      s/.pm$// for @pm;\n      if (@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }\n      elsif (@pm) {\n        %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic\n        if (keys %xs) {\n            foreach my $pm (@pm) {\n                $defpm = $pm, last if exists $xs{$pm};\n            }\n        }\n      }\n    }\n    if (open(my $pm, '<', \"${defpm}.pm\")){\n        while (<$pm>) {\n            if (/^\\s*package\\s+([^;]+)/i) {\n                $defname = $1;\n                last;\n            }\n        }\n        print \"Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\\n\\t\",\n                     \"defaulting package name to $defname\\n\"\n            if eof($pm);\n        close $pm;\n    }\n    else {\n        print \"Warning (non-fatal): Couldn't find ${defpm}.pm;\\n\\t\",\n                     \"defaulting package name to $defname\\n\";\n    }\n    $defname =~ s#[\\d.\\-_]+$##;\n    $defname;\n}\n\n=item find_perl (override)\n\nUse VMS file specification syntax and CLI commands to find and\ninvoke Perl images.\n\n=cut\n\nsub find_perl {\n    my($self, $ver, $names, $dirs, $trace) = @_;\n    my($vmsfile,@sdirs,@snames,@cand);\n    my($rslt);\n    my($inabs) = 0;\n    local *TCF;\n\n    if( $self->{PERL_CORE} ) {\n        # Check in relative directories first, so we pick up the current\n        # version of Perl if we're running MakeMaker as part of the main build.\n        @sdirs = sort { my($absa) = $self->file_name_is_absolute($a);\n                        my($absb) = $self->file_name_is_absolute($b);\n                        if ($absa && $absb) { return $a cmp $b }\n                        else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }\n                      } @$dirs;\n        # Check miniperl before perl, and check names likely to contain\n        # version numbers before \"generic\" names, so we pick up an\n        # executable that's less likely to be from an old installation.\n        @snames = sort { my($ba) = $a =~ m!([^:>\\]/]+)$!;  # basename\n                         my($bb) = $b =~ m!([^:>\\]/]+)$!;\n                         my($ahasdir) = (length($a) - length($ba) > 0);\n                         my($bhasdir) = (length($b) - length($bb) > 0);\n                         if    ($ahasdir and not $bhasdir) { return 1; }\n                         elsif ($bhasdir and not $ahasdir) { return -1; }\n                         else { $bb =~ /\\d/ <=> $ba =~ /\\d/\n                                  or substr($ba,0,1) cmp substr($bb,0,1)\n                                  or length($bb) <=> length($ba) } } @$names;\n    }\n    else {\n        @sdirs  = @$dirs;\n        @snames = @$names;\n    }\n\n    # Image names containing Perl version use '_' instead of '.' under VMS\n    s/\\.(\\d+)$/_$1/ for @snames;\n    if ($trace >= 2){\n        print \"Looking for perl $ver by these names:\\n\";\n        print \"\\t@snames,\\n\";\n        print \"in these dirs:\\n\";\n        print \"\\t@sdirs\\n\";\n    }\n    foreach my $dir (@sdirs){\n        next unless defined $dir; # $self->{PERL_SRC} may be undefined\n        $inabs++ if $self->file_name_is_absolute($dir);\n        if ($inabs == 1) {\n            # We've covered relative dirs; everything else is an absolute\n            # dir (probably an installed location).  First, we'll try\n            # potential command names, to see whether we can avoid a long\n            # MCR expression.\n            foreach my $name (@snames) {\n                push(@cand,$name) if $name =~ /^[\\w\\-\\$]+$/;\n            }\n            $inabs++; # Should happen above in next $dir, but just in case...\n        }\n        foreach my $name (@snames){\n            push @cand, ($name !~ m![/:>\\]]!) ? $self->catfile($dir,$name)\n                                              : $self->fixpath($name,0);\n        }\n    }\n    foreach my $name (@cand) {\n        print \"Checking $name\\n\" if $trace >= 2;\n        # If it looks like a potential command, try it without the MCR\n        if ($name =~ /^[\\w\\-\\$]+$/) {\n            open(my $tcf, \">\", \"temp_mmvms.com\")\n                or die('unable to open temp file');\n            print $tcf \"\\$ set message/nofacil/nosever/noident/notext\\n\";\n            print $tcf \"\\$ $name -e \\\"require $ver; print \\\"\\\"VER_OK\\\\n\\\"\\\"\\\"\\n\";\n            close $tcf;\n            $rslt = `\\@temp_mmvms.com` ;\n            unlink('temp_mmvms.com');\n            if ($rslt =~ /VER_OK/) {\n                print \"Using PERL=$name\\n\" if $trace;\n                return $name;\n            }\n        }\n        next unless $vmsfile = $self->maybe_command($name);\n        $vmsfile =~ s/;[\\d\\-]*$//;  # Clip off version number; we can use a newer version as well\n        print \"Executing $vmsfile\\n\" if ($trace >= 2);\n        open(my $tcf, '>', \"temp_mmvms.com\")\n                or die('unable to open temp file');\n        print $tcf \"\\$ set message/nofacil/nosever/noident/notext\\n\";\n        print $tcf \"\\$ mcr $vmsfile -e \\\"require $ver; print \\\"\\\"VER_OK\\\\n\\\"\\\"\\\" \\n\";\n        close $tcf;\n        $rslt = `\\@temp_mmvms.com`;\n        unlink('temp_mmvms.com');\n        if ($rslt =~ /VER_OK/) {\n            print \"Using PERL=MCR $vmsfile\\n\" if $trace;\n            return \"MCR $vmsfile\";\n        }\n    }\n    print \"Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\\n\";\n    0; # false and not empty\n}\n\n=item _fixin_replace_shebang (override)\n\nHelper routine for MM->fixin(), overridden because there's no such thing as an\nactual shebang line that will be interpreted by the shell, so we just prepend\n$Config{startperl} and preserve the shebang line argument for any switches it\nmay contain.\n\n=cut\n\nsub _fixin_replace_shebang {\n    my ( $self, $file, $line ) = @_;\n\n    my ( undef, $arg ) = split ' ', $line, 2;\n\n    return $Config{startperl} . \"\\n\" . $Config{sharpbang} . \"perl $arg\\n\";\n}\n\n=item maybe_command (override)\n\nFollows VMS naming conventions for executable files.\nIf the name passed in doesn't exactly match an executable file,\nappends F<.Exe> (or equivalent) to check for executable image, and F<.Com>\nto check for DCL procedure.  If this fails, checks directories in DCL$PATH\nand finally F<Sys$System:> for an executable file having the name specified,\nwith or without the F<.Exe>-equivalent suffix.\n\n=cut\n\nsub maybe_command {\n    my($self,$file) = @_;\n    return $file if -x $file && ! -d _;\n    my(@dirs) = ('');\n    my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');\n\n    if ($file !~ m![/:>\\]]!) {\n        for (my $i = 0; defined $ENV{\"DCL\\$PATH;$i\"}; $i++) {\n            my $dir = $ENV{\"DCL\\$PATH;$i\"};\n            $dir .= ':' unless $dir =~ m%[\\]:]$%;\n            push(@dirs,$dir);\n        }\n        push(@dirs,'Sys$System:');\n        foreach my $dir (@dirs) {\n            my $sysfile = \"$dir$file\";\n            foreach my $ext (@exts) {\n                return $file if -x \"$sysfile$ext\" && ! -d _;\n            }\n        }\n    }\n    return 0;\n}\n\n\n=item pasthru (override)\n\nThe list of macro definitions to be passed through must be specified using\nthe /MACRO qualifier and must not add another /DEFINE qualifier.  We prepend\nour own comma here to the contents of $(PASTHRU_DEFINE) because it is often\nempty and a comma always present in CCFLAGS would generate a missing\nqualifier value error.\n\n=cut\n\nsub pasthru {\n    my($self) = shift;\n    my $pasthru = $self->SUPER::pasthru;\n    $pasthru =~ s|(PASTHRU\\s*=\\s*)|$1/MACRO=(|;\n    $pasthru =~ s|\\n\\z|)\\n|m;\n    $pasthru =~ s|/defi?n?e?=\\(?([^\\),]+)\\)?|,$1|ig;\n\n    return $pasthru;\n}\n\n\n=item pm_to_blib (override)\n\nVMS wants a dot in every file so we can't have one called 'pm_to_blib',\nit becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when\nyou have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.\n\nSo in VMS its pm_to_blib.ts.\n\n=cut\n\nsub pm_to_blib {\n    my $self = shift;\n\n    my $make = $self->SUPER::pm_to_blib;\n\n    $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;\n    $make =~ s{\\$\\(TOUCH\\) pm_to_blib}{\\$(TOUCH) pm_to_blib.ts};\n\n    $make = <<'MAKE' . $make;\n# Dummy target to match Unix target name; we use pm_to_blib.ts as\n# timestamp file to avoid repeated invocations under VMS\npm_to_blib : pm_to_blib.ts\n\t$(NOECHO) $(NOOP)\n\nMAKE\n\n    return $make;\n}\n\n\n=item perl_script (override)\n\nIf name passed in doesn't specify a readable file, appends F<.com> or\nF<.pl> and tries again, since it's customary to have file types on all files\nunder VMS.\n\n=cut\n\nsub perl_script {\n    my($self,$file) = @_;\n    return $file if -r $file && ! -d _;\n    return \"$file.com\" if -r \"$file.com\";\n    return \"$file.pl\" if -r \"$file.pl\";\n    return '';\n}\n\n\n=item replace_manpage_separator\n\nUse as separator a character which is legal in a VMS-syntax file name.\n\n=cut\n\nsub replace_manpage_separator {\n    my($self,$man) = @_;\n    $man = unixify($man);\n    $man =~ s#/+#__#g;\n    $man;\n}\n\n=item init_DEST\n\n(override) Because of the difficulty concatenating VMS filepaths we\nmust pre-expand the DEST* variables.\n\n=cut\n\nsub init_DEST {\n    my $self = shift;\n\n    $self->SUPER::init_DEST;\n\n    # Expand DEST variables.\n    foreach my $var ($self->installvars) {\n        my $destvar = 'DESTINSTALL'.$var;\n        $self->{$destvar} = $self->eliminate_macros($self->{$destvar});\n    }\n}\n\n\n=item init_DIRFILESEP\n\nNo separator between a directory path and a filename on VMS.\n\n=cut\n\nsub init_DIRFILESEP {\n    my($self) = shift;\n\n    $self->{DIRFILESEP} = '';\n    return 1;\n}\n\n\n=item init_main (override)\n\n\n=cut\n\nsub init_main {\n    my($self) = shift;\n\n    $self->SUPER::init_main;\n\n    $self->{DEFINE} ||= '';\n    if ($self->{DEFINE} ne '') {\n        my(@terms) = split(/\\s+/,$self->{DEFINE});\n        my(@defs,@udefs);\n        foreach my $def (@terms) {\n            next unless $def;\n            my $targ = \\@defs;\n            if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition\n                $targ = \\@udefs if $1 eq 'U';\n                $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''\n                $def =~ s/^'(.*)'$/$1/;   # from entire term or argument\n            }\n            if ($def =~ /=/) {\n                $def =~ s/\"/\"\"/g;  # Protect existing \" from DCL\n                $def = qq[\"$def\"]; # and quote to prevent parsing of =\n            }\n            push @$targ, $def;\n        }\n\n        $self->{DEFINE} = '';\n        if (@defs)  {\n            $self->{DEFINE}  = '/Define=(' . join(',',@defs)  . ')';\n        }\n        if (@udefs) {\n            $self->{DEFINE} .= '/Undef=('  . join(',',@udefs) . ')';\n        }\n    }\n}\n\n=item init_tools (override)\n\nProvide VMS-specific forms of various utility commands.\n\nSets DEV_NULL to nothing because I don't know how to do it on VMS.\n\nChanges EQUALIZE_TIMESTAMP to set revision date of target file to\none second later than source file, since MMK interprets precisely\nequal revision dates for a source and target file as a sign that the\ntarget needs to be updated.\n\n=cut\n\nsub init_tools {\n    my($self) = @_;\n\n    $self->{NOOP}               = 'Continue';\n    $self->{NOECHO}             ||= '@ ';\n\n    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';\n    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};\n    $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';\n    $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');\n#\n#   If an extension is not specified, then MMS/MMK assumes an\n#   an extension of .MMS.  If there really is no extension,\n#   then a trailing \".\" needs to be appended to specify a\n#   a null extension.\n#\n    $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\\./;\n    $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\\./;\n    $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\\./;\n    $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\\./;\n\n    $self->{MACROSTART}         ||= '/Macro=(';\n    $self->{MACROEND}           ||= ')';\n    $self->{USEMAKEFILE}        ||= '/Descrip=';\n\n    $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we \"open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])\"';\n\n    $self->{MOD_INSTALL} ||=\n      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);\ninstall([ from_to => {split('\\|', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);\nCODE\n\n    $self->{UMASK_NULL} = '! ';\n\n    $self->SUPER::init_tools;\n\n    # Use the default shell\n    $self->{SHELL}    ||= 'Posix';\n\n    # Redirection on VMS goes before the command, not after as on Unix.\n    # $(DEV_NULL) is used once and its not worth going nuts over making\n    # it work.  However, Unix's DEV_NULL is quite wrong for VMS.\n    $self->{DEV_NULL}   = '';\n\n    return;\n}\n\n=item init_platform (override)\n\nAdd PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.\n\nMM_VMS_REVISION is for backwards compatibility before MM_VMS had a\n$VERSION.\n\n=cut\n\nsub init_platform {\n    my($self) = shift;\n\n    $self->{MM_VMS_REVISION} = $Revision;\n    $self->{MM_VMS_VERSION}  = $VERSION;\n    $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')\n      if $self->{PERL_SRC};\n}\n\n\n=item platform_constants\n\n=cut\n\nsub platform_constants {\n    my($self) = shift;\n    my $make_frag = '';\n\n    foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))\n    {\n        next unless defined $self->{$macro};\n        $make_frag .= \"$macro = $self->{$macro}\\n\";\n    }\n\n    return $make_frag;\n}\n\n\n=item init_VERSION (override)\n\nOverride the *DEFINE_VERSION macros with VMS semantics.  Translate the\nMAKEMAKER filepath to VMS style.\n\n=cut\n\nsub init_VERSION {\n    my $self = shift;\n\n    $self->SUPER::init_VERSION;\n\n    $self->{DEFINE_VERSION}    = '\"$(VERSION_MACRO)=\"\"$(VERSION)\"\"\"';\n    $self->{XS_DEFINE_VERSION} = '\"$(XS_VERSION_MACRO)=\"\"$(XS_VERSION)\"\"\"';\n    $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});\n}\n\n\n=item constants (override)\n\nFixes up numerous file and directory macros to insure VMS syntax\nregardless of input syntax.  Also makes lists of files\ncomma-separated.\n\n=cut\n\nsub constants {\n    my($self) = @_;\n\n    # Be kind about case for pollution\n    for (@ARGV) { $_ = uc($_) if /POLLUTE/i; }\n\n    # Cleanup paths for directories in MMS macros.\n    foreach my $macro ( qw [\n            INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB\n            PERL_LIB PERL_ARCHLIB\n            PERL_INC PERL_SRC ],\n                        (map { 'INSTALL'.$_ } $self->installvars)\n                      )\n    {\n        next unless defined $self->{$macro};\n        next if $macro =~ /MAN/ && $self->{$macro} eq 'none';\n        $self->{$macro} = $self->fixpath($self->{$macro},1);\n    }\n\n    # Cleanup paths for files in MMS macros.\n    foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD\n                           MAKE_APERL_FILE MYEXTLIB] )\n    {\n        next unless defined $self->{$macro};\n        $self->{$macro} = $self->fixpath($self->{$macro},0);\n    }\n\n    # Fixup files for MMS macros\n    # XXX is this list complete?\n    for my $macro (qw/\n                   FULLEXT VERSION_FROM\n\t      /\t) {\n        next unless defined $self->{$macro};\n        $self->{$macro} = $self->fixpath($self->{$macro},0);\n    }\n\n\n    for my $macro (qw/\n                   OBJECT LDFROM\n\t      /\t) {\n        next unless defined $self->{$macro};\n\n        # Must expand macros before splitting on unescaped whitespace.\n        $self->{$macro} = $self->eliminate_macros($self->{$macro});\n        if ($self->{$macro} =~ /(?<!\\^)\\s/) {\n            $self->{$macro} =~ s/(\\\\)?\\n+\\s+/ /g;\n            $self->{$macro} = $self->wraplist(\n                map $self->fixpath($_,0), split /,?(?<!\\^)\\s+/, $self->{$macro}\n            );\n        }\n        else {\n            $self->{$macro} = $self->fixpath($self->{$macro},0);\n        }\n    }\n\n    for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {\n        # Where is the space coming from? --jhi\n        next unless $self ne \" \" && defined $self->{$macro};\n        my %tmp = ();\n        for my $key (keys %{$self->{$macro}}) {\n            $tmp{$self->fixpath($key,0)} =\n                                     $self->fixpath($self->{$macro}{$key},0);\n        }\n        $self->{$macro} = \\%tmp;\n    }\n\n    for my $macro (qw/ C O_FILES H /) {\n        next unless defined $self->{$macro};\n        my @tmp = ();\n        for my $val (@{$self->{$macro}}) {\n            push(@tmp,$self->fixpath($val,0));\n        }\n        $self->{$macro} = \\@tmp;\n    }\n\n    # mms/k does not define a $(MAKE) macro.\n    $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';\n\n    return $self->SUPER::constants;\n}\n\n\n=item special_targets\n\nClear the default .SUFFIXES and put in our own list.\n\n=cut\n\nsub special_targets {\n    my $self = shift;\n\n    my $make_frag .= <<'MAKE_FRAG';\n.SUFFIXES :\n.SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs\n\nMAKE_FRAG\n\n    return $make_frag;\n}\n\n=item cflags (override)\n\nBypass shell script and produce qualifiers for CC directly (but warn\nuser if a shell script for this extension exists).  Fold multiple\n/Defines into one, since some C compilers pay attention to only one\ninstance of this qualifier on the command line.\n\n=cut\n\nsub cflags {\n    my($self,$libperl) = @_;\n    my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};\n    my($definestr,$undefstr,$flagoptstr) = ('','','');\n    my($incstr) = '/Include=($(PERL_INC)';\n    my($name,$sys,@m);\n\n    ( $name = $self->{NAME} . \"_cflags\" ) =~ s/:/_/g ;\n    print \"Unix shell script \".$Config{\"$self->{'BASEEXT'}_cflags\"}.\n         \" required to modify CC command for $self->{'BASEEXT'}\\n\"\n    if ($Config{$name});\n\n    if ($quals =~ / -[DIUOg]/) {\n\twhile ($quals =~ / -([Og])(\\d*)\\b/) {\n\t    my($type,$lvl) = ($1,$2);\n\t    $quals =~ s/ -$type$lvl\\b\\s*//;\n\t    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }\n\t    else { $flagoptstr = '/Optimize' . (defined($lvl) ? \"=$lvl\" : ''); }\n\t}\n\twhile ($quals =~ / -([DIU])(\\S+)/) {\n\t    my($type,$def) = ($1,$2);\n\t    $quals =~ s/ -$type$def\\s*//;\n\t    $def =~ s/\"/\"\"/g;\n\t    if    ($type eq 'D') { $definestr .= qq[\"$def\",]; }\n\t    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }\n\t    else                 { $undefstr  .= qq[\"$def\",]; }\n\t}\n    }\n    if (length $quals and $quals !~ m!/!) {\n\twarn \"MM_VMS: Ignoring unrecognized CCFLAGS elements \\\"$quals\\\"\\n\";\n\t$quals = '';\n    }\n    $definestr .= q[\"PERL_POLLUTE\",] if $self->{POLLUTE};\n    if (length $definestr) { chop($definestr); $quals .= \"/Define=($definestr)\"; }\n    if (length $undefstr)  { chop($undefstr);  $quals .= \"/Undef=($undefstr)\";   }\n    # Deal with $self->{DEFINE} here since some C compilers pay attention\n    # to only one /Define clause on command line, so we have to\n    # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}\n    # ($self->{DEFINE} has already been VMSified in constants() above)\n    if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }\n    for my $type (qw(Def Undef)) {\n\tmy(@terms);\n\twhile ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {\n\t\tmy $term = $1;\n\t\t$term =~ s:^\\((.+)\\)$:$1:;\n\t\tpush @terms, $term;\n\t}\n\tif ($type eq 'Def') {\n\t    push @terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];\n\t}\n\tif (@terms) {\n\t    $quals =~ s:/${type}i?n?e?=[^/]+::ig;\n            # PASTHRU_DEFINE will have its own comma\n\t    $quals .= \"/${type}ine=(\" . join(',',@terms) . ($type eq 'Def' ? '$(PASTHRU_DEFINE)' : '') . ')';\n\t}\n    }\n\n    $libperl or $libperl = $self->{LIBPERL_A} || \"libperl.olb\";\n\n    # Likewise with $self->{INC} and /Include\n    if ($self->{'INC'}) {\n\tmy(@includes) = split(/\\s+/,$self->{INC});\n\tforeach (@includes) {\n\t    s/^-I//;\n\t    $incstr .= ','.$self->fixpath($_,1);\n\t}\n    }\n    $quals .= \"$incstr)\";\n#    $quals =~ s/,,/,/g; $quals =~ s/\\(,/(/g;\n    $self->{CCFLAGS} = $quals;\n\n    $self->{PERLTYPE} ||= '';\n\n    $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};\n    if ($self->{OPTIMIZE} !~ m!/!) {\n\tif    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }\n\telsif ($self->{OPTIMIZE} =~ /-O(\\d*)/) {\n\t    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? \"=$1\" : '');\n\t}\n\telse {\n\t    warn \"MM_VMS: Can't parse OPTIMIZE \\\"$self->{OPTIMIZE}\\\"; using default\\n\" if length $self->{OPTIMIZE};\n\t    $self->{OPTIMIZE} = '/Optimize';\n\t}\n    }\n\n    return $self->{CFLAGS} = qq{\nCCFLAGS = $self->{CCFLAGS}\nOPTIMIZE = $self->{OPTIMIZE}\nPERLTYPE = $self->{PERLTYPE}\n};\n}\n\n=item const_cccmd (override)\n\nAdds directives to point C preprocessor to the right place when\nhandling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC\ncommand line a bit differently than MM_Unix method.\n\n=cut\n\nsub const_cccmd {\n    my($self,$libperl) = @_;\n    my(@m);\n\n    return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};\n    return '' unless $self->needs_linking();\n    if ($Config{'vms_cc_type'} eq 'gcc') {\n        push @m,'\n.FIRST\n\t',$self->{NOECHO},'If F$TrnLnm(\"Sys\").eqs.\"\" Then Define/NoLog SYS GNU_CC_Include:[VMS]';\n    }\n    elsif ($Config{'vms_cc_type'} eq 'vaxc') {\n        push @m,'\n.FIRST\n\t',$self->{NOECHO},'If F$TrnLnm(\"Sys\").eqs.\"\" .and. F$TrnLnm(\"VAXC$Include\").eqs.\"\" Then Define/NoLog SYS Sys$Library\n\t',$self->{NOECHO},'If F$TrnLnm(\"Sys\").eqs.\"\" .and. F$TrnLnm(\"VAXC$Include\").nes.\"\" Then Define/NoLog SYS VAXC$Include';\n    }\n    else {\n        push @m,'\n.FIRST\n\t',$self->{NOECHO},'If F$TrnLnm(\"Sys\").eqs.\"\" .and. F$TrnLnm(\"DECC$System_Include\").eqs.\"\" Then Define/NoLog SYS ',\n\t\t($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'\n\t',$self->{NOECHO},'If F$TrnLnm(\"Sys\").eqs.\"\" .and. F$TrnLnm(\"DECC$System_Include\").nes.\"\" Then Define/NoLog SYS DECC$System_Include';\n    }\n\n    push(@m, \"\\n\\nCCCMD = $Config{'cc'} \\$(CCFLAGS)\\$(OPTIMIZE)\\n\");\n\n    $self->{CONST_CCCMD} = join('',@m);\n}\n\n\n=item tools_other (override)\n\nThrow in some dubious extra macros for Makefile args.\n\nAlso keep around the old $(SAY) macro in case somebody's using it.\n\n=cut\n\nsub tools_other {\n    my($self) = @_;\n\n    # XXX Are these necessary?  Does anyone override them?  They're longer\n    # than just typing the literal string.\n    my $extra_tools = <<'EXTRA_TOOLS';\n\n# Just in case anyone is using the old macro.\nUSEMACROS = $(MACROSTART)\nSAY = $(ECHO)\n\nEXTRA_TOOLS\n\n    return $self->SUPER::tools_other . $extra_tools;\n}\n\n=item init_dist (override)\n\nVMSish defaults for some values.\n\n  macro         description                     default\n\n  ZIPFLAGS      flags to pass to ZIP            -Vu\n\n  COMPRESS      compression command to          gzip\n                use for tarfiles\n  SUFFIX        suffix to put on                -gz\n                compressed files\n\n  SHAR          shar command to use             vms_share\n\n  DIST_DEFAULT  default target to use to        tardist\n                create a distribution\n\n  DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)\n                VERSION for the name\n\n=cut\n\nsub init_dist {\n    my($self) = @_;\n    $self->{ZIPFLAGS}     ||= '-Vu';\n    $self->{COMPRESS}     ||= 'gzip';\n    $self->{SUFFIX}       ||= '-gz';\n    $self->{SHAR}         ||= 'vms_share';\n    $self->{DIST_DEFAULT} ||= 'zipdist';\n\n    $self->SUPER::init_dist;\n\n    $self->{DISTVNAME} = \"$self->{DISTNAME}-$self->{VERSION_SYM}\"\n      unless $self->{ARGS}{DISTVNAME};\n\n    return;\n}\n\n=item c_o (override)\n\nUse VMS syntax on command line.  In particular, $(DEFINE) and\n$(PERL_INC) have been pulled into $(CCCMD).  Also use MM[SK] macros.\n\n=cut\n\nsub c_o {\n    my($self) = @_;\n    return '' unless $self->needs_linking();\n    '\n.c$(OBJ_EXT) :\n\t$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)\n\n.cpp$(OBJ_EXT) :\n\t$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)\n\n.cxx$(OBJ_EXT) :\n\t$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)\n\n';\n}\n\n=item xs_c (override)\n\nUse MM[SK] macros.\n\n=cut\n\nsub xs_c {\n    my($self) = @_;\n    return '' unless $self->needs_linking();\n    '\n.xs.c :\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc\n\t$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c\n';\n}\n\n=item xs_o (override)\n\nUse MM[SK] macros, and VMS command line for C compiler.\n\n=cut\n\nsub xs_o {\n    my ($self) = @_;\n    return '' unless $self->needs_linking();\n    my $frag = '\n.xs$(OBJ_EXT) :\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc\n\t$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c\n\t$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)\n';\n    if ($self->{XSMULTI}) {\n\tfor my $ext ($self->_xs_list_basenames) {\n\t    my $version = $self->parse_version(\"$ext.pm\");\n\t    my $ccflags = $self->{CCFLAGS};\n\t    $ccflags =~ s/\\$\\(DEFINE_VERSION\\)/\\\"VERSION_MACRO=\\\\\"\\\"$version\\\\\"\\\"/;\n\t    $ccflags =~ s/\\$\\(XS_DEFINE_VERSION\\)/\\\"XS_VERSION_MACRO=\\\\\"\\\"$version\\\\\"\\\"/;\n\t    $self->_xsbuild_replace_macro($ccflags, 'xs', $ext, 'INC');\n\t    $self->_xsbuild_replace_macro($ccflags, 'xs', $ext, 'DEFINE');\n\n\t    $frag .= _sprintf562 <<'EOF', $ext, $ccflags;\n\n%1$s$(OBJ_EXT) : %1$s.xs\n\t$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs > $(MMS$TARGET_NAME).xsc\n\t$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c\n\t$(CC)%2$s$(OPTIMIZE) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)\nEOF\n\t}\n    }\n    $frag;\n}\n\n=item _xsbuild_replace_macro (override)\n\nThere is no simple replacement possible since a qualifier and all its\nsubqualifiers must be considered together, so we use our own utility\nroutine for the replacement.\n\n=cut\n\nsub _xsbuild_replace_macro {\n    my ($self, undef, $xstype, $ext, $varname) = @_;\n    my $value = $self->_xsbuild_value($xstype, $ext, $varname);\n    return unless defined $value;\n    $_[1] = _vms_replace_qualifier($self, $_[1], $value, $varname);\n}\n\n=item _xsbuild_value (override)\n\nConvert the extension spec to Unix format, as that's what will\nmatch what's in the XSBUILD data structure.\n\n=cut\n\nsub _xsbuild_value {\n    my ($self, $xstype, $ext, $varname) = @_;\n    $ext = unixify($ext);\n    return $self->SUPER::_xsbuild_value($xstype, $ext, $varname);\n}\n\nsub _vms_replace_qualifier {\n    my ($self, $flags, $newflag, $macro) = @_;\n    my $qual_type;\n    my $type_suffix;\n    my $quote_subquals = 0;\n    my @subquals_new = split /\\s+/, $newflag;\n\n    if ($macro eq 'DEFINE') {\n        $qual_type = 'Def';\n        $type_suffix = 'ine';\n        map { $_ =~ s/^-D// } @subquals_new;\n        $quote_subquals = 1;\n    }\n    elsif ($macro eq 'INC') {\n        $qual_type = 'Inc';\n        $type_suffix = 'lude';\n        map { $_ =~ s/^-I//; $_ = $self->fixpath($_) } @subquals_new;\n    }\n\n    my @subquals = ();\n    while ($flags =~ m:/${qual_type}\\S{0,4}=([^/]+):ig) {\n        my $term = $1;\n        $term =~ s/\\\"//g;\n        $term =~ s:^\\((.+)\\)$:$1:;\n        push @subquals, split /,/, $term;\n    }\n    for my $new (@subquals_new) {\n        my ($sq_new, $sqval_new) = split /=/, $new;\n        my $replaced_old = 0;\n        for my $old (@subquals) {\n            my ($sq, $sqval) = split /=/, $old;\n            if ($sq_new eq $sq) {\n                $old = $sq_new;\n                $old .= '=' . $sqval_new if defined($sqval_new) and length($sqval_new);\n                $replaced_old = 1;\n                last;\n            }\n        }\n        push @subquals, $new unless $replaced_old;\n    }\n\n    if (@subquals) {\n        $flags =~ s:/${qual_type}\\S{0,4}=[^/]+::ig;\n        # add quotes if requested but not for unexpanded macros\n        map { $_ = qq/\"$_\"/ if $_ !~ m/^\\$\\(/ } @subquals if $quote_subquals;\n        $flags .= \"/${qual_type}$type_suffix=(\" . join(',',@subquals) . ')';\n    }\n\n    return $flags;\n}\n\n\nsub xs_dlsyms_ext {\n    '.opt';\n}\n\n=item dlsyms (override)\n\nCreate VMS linker options files specifying universal symbols for this\nextension's shareable image(s), and listing other shareable images or\nlibraries to which it should be linked.\n\n=cut\n\nsub dlsyms {\n    my ($self, %attribs) = @_;\n    return '' unless $self->needs_linking;\n    $self->xs_dlsyms_iterator;\n}\n\nsub xs_make_dlsyms {\n    my ($self, $attribs, $target, $dep, $name, $dlbase, $funcs, $funclist, $imports, $vars, $extra) = @_;\n    my @m;\n    my $instloc;\n    if ($self->{XSMULTI}) {\n\tmy ($v, $d, $f) = File::Spec->splitpath($target);\n\tmy @d = File::Spec->splitdir($d);\n\tshift @d if $d[0] eq 'lib';\n\t$instloc = $self->catfile('$(INST_ARCHLIB)', 'auto', @d, $f);\n\tpush @m,\"\\ndynamic :: $instloc\\n\\t\\$(NOECHO) \\$(NOOP)\\n\"\n\t  unless $self->{SKIPHASH}{'dynamic'};\n\tpush @m,\"\\nstatic :: $instloc\\n\\t\\$(NOECHO) \\$(NOOP)\\n\"\n\t  unless $self->{SKIPHASH}{'static'};\n\tpush @m, \"\\n\", sprintf <<'EOF', $instloc, $target;\n%s : %s\n\t$(CP) $(MMS$SOURCE) $(MMS$TARGET)\nEOF\n    }\n    else {\n\tpush @m,\"\\ndynamic :: \\$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\\n\\t\\$(NOECHO) \\$(NOOP)\\n\"\n\t  unless $self->{SKIPHASH}{'dynamic'};\n\tpush @m,\"\\nstatic :: \\$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\\n\\t\\$(NOECHO) \\$(NOOP)\\n\"\n\t  unless $self->{SKIPHASH}{'static'};\n\tpush @m, \"\\n\", sprintf <<'EOF', $target;\n$(INST_ARCHAUTODIR)$(BASEEXT).opt : %s\n\t$(CP) $(MMS$SOURCE) $(MMS$TARGET)\nEOF\n    }\n    push @m,\n     \"\\n$target : $dep\\n\\t\",\n     q!$(PERLRUN) -MExtUtils::Mksymlists -e \"Mksymlists('NAME'=>'!, $name,\n     q!', 'DLBASE' => '!,$dlbase,\n     q!', 'DL_FUNCS' => !,neatvalue($funcs),\n     q!, 'FUNCLIST' => !,neatvalue($funclist),\n     q!, 'IMPORTS' => !,neatvalue($imports),\n     q!, 'DL_VARS' => !, neatvalue($vars);\n    push @m, $extra if defined $extra;\n    push @m, qq!);\"\\n\\t!;\n    # Can't use dlbase as it's been through mod2fname.\n    my $olb_base = basename($target, '.opt');\n    if ($self->{XSMULTI}) {\n        # We've been passed everything but the kitchen sink -- and the location of the\n        # static library we're using to build the dynamic library -- so concoct that\n        # location from what we do have.\n        my $olb_dir = $self->catdir(dirname($instloc), $olb_base);\n        push @m, qq!\\$(PERL) -e \"print \"\"${olb_dir}${olb_base}\\$(LIB_EXT)/Include=!;\n        push @m, ($Config{d_vms_case_sensitive_symbols} ? uc($olb_base) : $olb_base);\n        push @m, '\\n' . $olb_dir . $olb_base . '$(LIB_EXT)/Library\\n\"\";\" >>$(MMS$TARGET)',\"\\n\";\n    }\n    else {\n        push @m, qq!\\$(PERL) -e \"print \"\"\\$(INST_ARCHAUTODIR)${olb_base}\\$(LIB_EXT)/Include=!;\n        if ($self->{OBJECT} =~ /\\bBASEEXT\\b/ or\n            $self->{OBJECT} =~ /\\b$self->{BASEEXT}\\b/i) {\n            push @m, ($Config{d_vms_case_sensitive_symbols}\n\t              ? uc($self->{BASEEXT}) :'$(BASEEXT)');\n        }\n        else {  # We don't have a \"main\" object file, so pull 'em all in\n            # Upcase module names if linker is being case-sensitive\n            my($upcase) = $Config{d_vms_case_sensitive_symbols};\n            my(@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});\n            for (@omods) {\n                s/\\.[^.]*$//;         # Trim off file type\n                s[\\$\\(\\w+_EXT\\)][];   # even as a macro\n                s/.*[:>\\/\\]]//;       # Trim off dir spec\n                $_ = uc if $upcase;\n            };\n            my(@lines);\n            my $tmp = shift @omods;\n            foreach my $elt (@omods) {\n                $tmp .= \",$elt\";\n                if (length($tmp) > 80) { push @lines, $tmp;  $tmp = ''; }\n            }\n            push @lines, $tmp;\n            push @m, '(', join( qq[, -\\\\n\\\\t\"\";\" >>\\$(MMS\\$TARGET)\\n\\t\\$(PERL) -e \"print \"\"], @lines),')';\n        }\n        push @m, '\\n$(INST_ARCHAUTODIR)' . $olb_base . '$(LIB_EXT)/Library\\n\"\";\" >>$(MMS$TARGET)',\"\\n\";\n    }\n    if (length $self->{LDLOADLIBS}) {\n        my($line) = '';\n        foreach my $lib (split ' ', $self->{LDLOADLIBS}) {\n            $lib =~ s%\\$%\\\\\\$%g;  # Escape '$' in VMS filespecs\n            if (length($line) + length($lib) > 160) {\n                push @m, \"\\t\\$(PERL) -e \\\"print qq{$line}\\\" >>\\$(MMS\\$TARGET)\\n\";\n                $line = $lib . '\\n';\n            }\n            else { $line .= $lib . '\\n'; }\n        }\n        push @m, \"\\t\\$(PERL) -e \\\"print qq{$line}\\\" >>\\$(MMS\\$TARGET)\\n\" if $line;\n    }\n    join '', @m;\n}\n\n\n=item xs_obj_opt\n\nOverride to fixup -o flags.\n\n=cut\n\nsub xs_obj_opt {\n    my ($self, $output_file) = @_;\n    \"/OBJECT=$output_file\";\n}\n\n=item dynamic_lib (override)\n\nUse VMS Link command.\n\n=cut\n\nsub xs_dynamic_lib_macros {\n    my ($self, $attribs) = @_;\n    my $otherldflags = $attribs->{OTHERLDFLAGS} || \"\";\n    my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || \"\";\n    sprintf <<'EOF', $otherldflags, $inst_dynamic_dep;\n# This section creates the dynamically loadable objects from relevant\n# objects and possibly $(MYEXTLIB).\nOTHERLDFLAGS = %s\nINST_DYNAMIC_DEP = %s\nEOF\n}\n\nsub xs_make_dynamic_lib {\n    my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;\n    my $shr = $Config{'dbgprefix'} . 'PerlShr';\n    $exportlist =~ s/.def$/.opt/;  # it's a linker options file\n    #                    1    2       3            4     5\n    _sprintf562 <<'EOF', $to, $todir, $exportlist, $shr, \"$shr Sys\\$Share:$shr.$Config{'dlext'}\";\n%1$s : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt %2$s$(DFSEP).exists %3$s $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)\n\tIf F$TrnLNm(\"%4$s\").eqs.\"\" Then Define/NoLog/User %5$s\n\tLink $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) %3$s/Option,$(PERL_INC)perlshr_attr.opt/Option\nEOF\n}\n\n=item xs_make_static_lib (override)\n\nUse VMS commands to manipulate object library.\n\n=cut\n\nsub xs_make_static_lib {\n    my ($self, $object, $to, $todir) = @_;\n\n    my @objects;\n    if ($self->{XSMULTI}) {\n        # The extension name should be the main object file name minus file type.\n        my $lib = $object;\n        $lib =~ s/\\$\\(OBJ_EXT\\)\\z//;\n        my $override = $self->_xsbuild_value('xs', $lib, 'OBJECT');\n        $object = $override if defined $override;\n        @objects = map { $self->fixpath($_,0) } split /(?<!\\^)\\s+/, $object;\n    }\n    else {\n        push @objects, $object;\n    }\n\n    my @m;\n    for my $obj (@objects) {\n        push(@m, sprintf \"\\n%s : %s\\$(DFSEP).exists\", $obj, $todir);\n    }\n    push(@m, sprintf \"\\n\\n%s : %s \\$(MYEXTLIB)\\n\", $to, (join ' ', @objects));\n\n    # If this extension has its own library (eg SDBM_File)\n    # then copy that to $(INST_STATIC) and add $(OBJECT) into it.\n    push(@m, \"\\t\",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',\"\\n\") if $self->{MYEXTLIB};\n\n    push(@m,\"\\t\",'If F$Search(\"$(MMS$TARGET)\").eqs.\"\" Then Library/Object/Create $(MMS$TARGET)',\"\\n\");\n\n    # if there was a library to copy, then we can't use MMS$SOURCE_LIST,\n    # 'cause it's a library and you can't stick them in other libraries.\n    # In that case, we use $OBJECT instead and hope for the best\n    if ($self->{MYEXTLIB}) {\n        for my $obj (@objects) {\n            push(@m,\"\\t\",'Library/Object/Replace $(MMS$TARGET) ' . $obj,\"\\n\");\n        }\n    }\n    else {\n      push(@m,\"\\t\",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',\"\\n\");\n    }\n\n    push @m, \"\\t\\$(NOECHO) \\$(PERL) -e 1 >\\$(INST_ARCHAUTODIR)extralibs.ld\\n\";\n    foreach my $lib (split ' ', $self->{EXTRALIBS}) {\n      push(@m,\"\\t\",'$(NOECHO) $(PERL) -e \"print qq{',$lib,'\\n}\" >>$(INST_ARCHAUTODIR)extralibs.ld',\"\\n\");\n    }\n    join('',@m);\n}\n\n\n=item extra_clean_files\n\nClean up some OS specific files.  Plus the temp file used to shorten\na lot of commands.  And the name mangler database.\n\n=cut\n\nsub extra_clean_files {\n    return qw(\n              *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso\n              .MM_Tmp cxx_repository\n             );\n}\n\n\n=item zipfile_target\n\n=item tarfile_target\n\n=item shdist_target\n\nSyntax for invoking shar, tar and zip differs from that for Unix.\n\n=cut\n\nsub zipfile_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\n$(DISTVNAME).zip : distdir\n\t$(PREOP)\n\t$(ZIP) \"$(ZIPFLAGS)\" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;\n\t$(RM_RF) $(DISTVNAME)\n\t$(POSTOP)\nMAKE_FRAG\n}\n\nsub tarfile_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\n$(DISTVNAME).tar$(SUFFIX) : distdir\n\t$(PREOP)\n\t$(TO_UNIX)\n        $(TAR) \"$(TARFLAGS)\" $(DISTVNAME).tar [.$(DISTVNAME)...]\n\t$(RM_RF) $(DISTVNAME)\n\t$(COMPRESS) $(DISTVNAME).tar\n\t$(POSTOP)\nMAKE_FRAG\n}\n\nsub shdist_target {\n    my($self) = shift;\n\n    return <<'MAKE_FRAG';\nshdist : distdir\n\t$(PREOP)\n\t$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share\n\t$(RM_RF) $(DISTVNAME)\n\t$(POSTOP)\nMAKE_FRAG\n}\n\n\n# --- Test and Installation Sections ---\n\n=item install (override)\n\nWork around DCL's 255 character limit several times,and use\nVMS-style command line quoting in a few cases.\n\n=cut\n\nsub install {\n    my($self, %attribs) = @_;\n    my(@m);\n\n    push @m, q[\ninstall :: all pure_install doc_install\n\t$(NOECHO) $(NOOP)\n\ninstall_perl :: all pure_perl_install doc_perl_install\n\t$(NOECHO) $(NOOP)\n\ninstall_site :: all pure_site_install doc_site_install\n\t$(NOECHO) $(NOOP)\n\ninstall_vendor :: all pure_vendor_install doc_vendor_install\n\t$(NOECHO) $(NOOP)\n\npure_install :: pure_$(INSTALLDIRS)_install\n\t$(NOECHO) $(NOOP)\n\ndoc_install :: doc_$(INSTALLDIRS)_install\n        $(NOECHO) $(NOOP)\n\npure__install : pure_site_install\n\t$(NOECHO) $(ECHO) \"INSTALLDIRS not defined, defaulting to INSTALLDIRS=site\"\n\ndoc__install : doc_site_install\n\t$(NOECHO) $(ECHO) \"INSTALLDIRS not defined, defaulting to INSTALLDIRS=site\"\n\n# This hack brought to you by DCL's 255-character command line limit\npure_perl_install ::\n];\n    push @m,\nq[\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'read|'.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').'|'\" >.MM_tmp\n\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'write|'.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').'|'\" >>.MM_tmp\n] unless $self->{NO_PACKLIST};\n\n    push @m,\nq[\t$(NOECHO) $(ECHO_N) \"$(INST_LIB)|$(DESTINSTALLPRIVLIB)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_ARCHLIB)|$(DESTINSTALLARCHLIB)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_BIN)|$(DESTINSTALLBIN)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) \" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN3DIR)|$(DESTINSTALLMAN3DIR)\" >>.MM_tmp\n\t$(NOECHO) $(MOD_INSTALL) <.MM_tmp\n\t$(NOECHO) $(RM_F) .MM_tmp\n\t$(NOECHO) $(WARN_IF_OLD_PACKLIST) \"].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[\"\n\n# Likewise\npure_site_install ::\n];\n    push @m,\nq[\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'read|'.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').'|'\" >.MM_tmp\n\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'write|'.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').'|'\" >>.MM_tmp\n] unless $self->{NO_PACKLIST};\n\n    push @m,\nq[\t$(NOECHO) $(ECHO_N) \"$(INST_LIB)|$(DESTINSTALLSITELIB)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_ARCHLIB)|$(DESTINSTALLSITEARCH)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_BIN)|$(DESTINSTALLSITEBIN)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN1DIR)|$(DESTINSTALLSITEMAN1DIR)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN3DIR)|$(DESTINSTALLSITEMAN3DIR)\" >>.MM_tmp\n\t$(NOECHO) $(MOD_INSTALL) <.MM_tmp\n\t$(NOECHO) $(RM_F) .MM_tmp\n\t$(NOECHO) $(WARN_IF_OLD_PACKLIST) \"].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[\"\n\npure_vendor_install ::\n];\n    push @m,\nq[\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'read|'.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').'|'\" >.MM_tmp\n\t$(NOECHO) $(PERLRUN) \"-MFile::Spec\" -e \"print 'write|'.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').'|'\" >>.MM_tmp\n] unless $self->{NO_PACKLIST};\n\n    push @m,\nq[\t$(NOECHO) $(ECHO_N) \"$(INST_LIB)|$(DESTINSTALLVENDORLIB)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_ARCHLIB)|$(DESTINSTALLVENDORARCH)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_BIN)|$(DESTINSTALLVENDORBIN)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN1DIR)|$(DESTINSTALLVENDORMAN1DIR)|\" >>.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"$(INST_MAN3DIR)|$(DESTINSTALLVENDORMAN3DIR)\" >>.MM_tmp\n\t$(NOECHO) $(MOD_INSTALL) <.MM_tmp\n\t$(NOECHO) $(RM_F) .MM_tmp\n\n];\n\n    push @m, q[\n# Ditto\ndoc_perl_install ::\n\t$(NOECHO) $(NOOP)\n\n# And again\ndoc_site_install ::\n\t$(NOECHO) $(NOOP)\n\ndoc_vendor_install ::\n\t$(NOECHO) $(NOOP)\n\n] if $self->{NO_PERLLOCAL};\n\n    push @m, q[\n# Ditto\ndoc_perl_install ::\n\t$(NOECHO) $(ECHO) \"Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q[\"\n\t$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)\n\t$(NOECHO) $(ECHO_N) \"installed into|$(INSTALLPRIVLIB)|\" >.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) \" >>.MM_tmp\n\t$(NOECHO) $(DOC_INSTALL) \"Module\" \"$(NAME)\" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[\n\t$(NOECHO) $(RM_F) .MM_tmp\n\n# And again\ndoc_site_install ::\n\t$(NOECHO) $(ECHO) \"Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q[\"\n\t$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)\n\t$(NOECHO) $(ECHO_N) \"installed into|$(INSTALLSITELIB)|\" >.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) \" >>.MM_tmp\n\t$(NOECHO) $(DOC_INSTALL) \"Module\" \"$(NAME)\" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[\n\t$(NOECHO) $(RM_F) .MM_tmp\n\ndoc_vendor_install ::\n\t$(NOECHO) $(ECHO) \"Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q[\"\n\t$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)\n\t$(NOECHO) $(ECHO_N) \"installed into|$(INSTALLVENDORLIB)|\" >.MM_tmp\n\t$(NOECHO) $(ECHO_N) \"LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) \" >>.MM_tmp\n\t$(NOECHO) $(DOC_INSTALL) \"Module\" \"$(NAME)\" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[\n\t$(NOECHO) $(RM_F) .MM_tmp\n\n] unless $self->{NO_PERLLOCAL};\n\n    push @m, q[\nuninstall :: uninstall_from_$(INSTALLDIRS)dirs\n\t$(NOECHO) $(NOOP)\n\nuninstall_from_perldirs ::\n\t$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[\n\nuninstall_from_sitedirs ::\n\t$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[\n\nuninstall_from_vendordirs ::\n\t$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{VENDORARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[\n];\n\n    join('',@m);\n}\n\n=item perldepend (override)\n\nUse VMS-style syntax for files; it's cheaper to just do it directly here\nthan to have the MM_Unix method call C<catfile> repeatedly.  Also, if\nwe have to rebuild Config.pm, use MM[SK] to do it.\n\n=cut\n\nsub perldepend {\n    my($self) = @_;\n    my(@m);\n\n    if ($self->{OBJECT}) {\n        # Need to add an object file dependency on the perl headers.\n        # this is very important for XS modules in perl.git development.\n\n        push @m, $self->_perl_header_files_fragment(\"\"); # empty separator on VMS as its in the $(PERL_INC)\n    }\n\n    if ($self->{PERL_SRC}) {\n\tmy(@macros);\n\tmy($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';\n\tpush(@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';\n\tpush(@macros,'DECC=1')    if $Config{'vms_cc_type'} eq 'decc';\n\tpush(@macros,'GNUC=1')    if $Config{'vms_cc_type'} eq 'gcc';\n\tpush(@macros,'SOCKET=1')  if $Config{'d_has_sockets'};\n\tpush(@macros,qq[\"CC=$Config{'cc'}\"])  if $Config{'cc'} =~ m!/!;\n\t$mmsquals .= '$(USEMACROS)' . join(',',@macros) . '$(MACROEND)' if @macros;\n\tpush(@m,q[\n# Check for unpropagated config.sh changes. Should never happen.\n# We do NOT just update config.h because that is not sufficient.\n# An out of date config.h is not fatal but complains loudly!\n$(PERL_INC)config.h : $(PERL_SRC)config.sh\n\t$(NOOP)\n\n$(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh\n\t$(NOECHO) Write Sys$Error \"$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl\"\n\tolddef = F$Environment(\"Default\")\n\tSet Default $(PERL_SRC)\n\t$(MMS)],$mmsquals,);\n\tif ($self->{PERL_ARCHLIB} =~ m|\\[-| && $self->{PERL_SRC} =~ m|(\\[-+)|) {\n\t    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));\n\t    $target =~ s/\\Q$prefix/[/;\n\t    push(@m,\" $target\");\n\t}\n\telse { push(@m,' $(MMS$TARGET)'); }\n\tpush(@m,q[\n\tSet Default 'olddef'\n]);\n    }\n\n    push(@m, join(\" \", map($self->fixpath($_,0),sort values %{$self->{XS}})).\" : \\$(XSUBPPDEPS)\\n\")\n      if %{$self->{XS}};\n\n    join('',@m);\n}\n\n\n=item makeaperl (override)\n\nUndertake to build a new set of Perl images using VMS commands.  Since\nVMS does dynamic loading, it's not necessary to statically link each\nextension into the Perl image, so this isn't the normal build path.\nConsequently, it hasn't really been tested, and may well be incomplete.\n\n=cut\n\nour %olbs;  # needs to be localized\n\nsub makeaperl {\n    my($self, %attribs) = @_;\n    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) =\n      @attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};\n    my(@m);\n    push @m, \"\n# --- MakeMaker makeaperl section ---\nMAP_TARGET    = $target\n\";\n    return join '', @m if $self->{PARENT};\n\n    my($dir) = join \":\", @{$self->{DIR}};\n\n    unless ($self->{MAKEAPERL}) {\n\tpush @m, q{\n$(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)\n\t$(NOECHO) $(ECHO) \"Writing \"\"$(MMS$TARGET)\"\" for this $(MAP_TARGET)\"\n\t$(NOECHO) $(PERLRUNINST) \\\n\t\tMakefile.PL DIR=}, $dir, q{ \\\n\t\tFIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \\\n\t\tMAKEAPERL=1 NORECURS=1 };\n\n\tpush @m, map(q[ \\\\\\n\\t\\t\"$_\"], @ARGV),q{\n\n$(MAP_TARGET) :: $(MAKE_APERL_FILE)\n\t$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)\n};\n\tpush @m, \"\\n\";\n\n\treturn join '', @m;\n    }\n\n\n    my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);\n    local($_);\n\n    # The front matter of the linkcommand...\n    $linkcmd = join ' ', $Config{'ld'},\n\t    grep($_, @Config{qw(large split ldflags ccdlflags)});\n    $linkcmd =~ s/\\s+/ /g;\n\n    # Which *.olb files could we make use of...\n    local(%olbs);       # XXX can this be lexical?\n    $olbs{$self->{INST_ARCHAUTODIR}} = \"$self->{BASEEXT}\\$(LIB_EXT)\";\n    require File::Find;\n    File::Find::find(sub {\n\treturn unless m/\\Q$self->{LIB_EXT}\\E$/;\n\treturn if m/^libperl/;\n\n\tif( exists $self->{INCLUDE_EXT} ){\n\t\tmy $found = 0;\n\n\t\t(my $xx = $File::Find::name) =~ s,.*?/auto/,,;\n\t\t$xx =~ s,/?$_,,;\n\t\t$xx =~ s,/,::,g;\n\n\t\t# Throw away anything not explicitly marked for inclusion.\n\t\t# DynaLoader is implied.\n\t\tforeach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){\n\t\t\tif( $xx eq $incl ){\n\t\t\t\t$found++;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\treturn unless $found;\n\t}\n\telsif( exists $self->{EXCLUDE_EXT} ){\n\t\t(my $xx = $File::Find::name) =~ s,.*?/auto/,,;\n\t\t$xx =~ s,/?$_,,;\n\t\t$xx =~ s,/,::,g;\n\n\t\t# Throw away anything explicitly marked for exclusion\n\t\tforeach my $excl (@{$self->{EXCLUDE_EXT}}){\n\t\t\treturn if( $xx eq $excl );\n\t\t}\n\t}\n\n\t$olbs{$ENV{DEFAULT}} = $_;\n    }, grep( -d $_, @{$searchdirs || []}));\n\n    # We trust that what has been handed in as argument will be buildable\n    $static = [] unless $static;\n    @olbs{@{$static}} = (1) x @{$static};\n\n    $extra = [] unless $extra && ref $extra eq 'ARRAY';\n    # Sort the object libraries in inverse order of\n    # filespec length to try to insure that dependent extensions\n    # will appear before their parents, so the linker will\n    # search the parent library to resolve references.\n    # (e.g. Intuit::DWIM will precede Intuit, so unresolved\n    # references from [.intuit.dwim]dwim.obj can be found\n    # in [.intuit]intuit.olb).\n    for (sort { length($a) <=> length($b) || $a cmp $b } keys %olbs) {\n\tnext unless $olbs{$_} =~ /\\Q$self->{LIB_EXT}\\E$/;\n\tmy($dir) = $self->fixpath($_,1);\n\tmy($extralibs) = $dir . \"extralibs.ld\";\n\tmy($extopt) = $dir . $olbs{$_};\n\t$extopt =~ s/$self->{LIB_EXT}$/.opt/;\n\tpush @optlibs, \"$dir$olbs{$_}\";\n\t# Get external libraries this extension will need\n\tif (-f $extralibs ) {\n\t    my %seenthis;\n\t    open my $list, \"<\", $extralibs or warn $!,next;\n\t    while (<$list>) {\n\t\tchomp;\n\t\t# Include a library in the link only once, unless it's mentioned\n\t\t# multiple times within a single extension's options file, in which\n\t\t# case we assume the builder needed to search it again later in the\n\t\t# link.\n\t\tmy $skip = exists($libseen{$_}) && !exists($seenthis{$_});\n\t\t$libseen{$_}++;  $seenthis{$_}++;\n\t\tnext if $skip;\n\t\tpush @$extra,$_;\n\t    }\n\t}\n\t# Get full name of extension for ExtUtils::Miniperl\n\tif (-f $extopt) {\n\t    open my $opt, '<', $extopt or die $!;\n\t    while (<$opt>) {\n\t\tnext unless /(?:UNIVERSAL|VECTOR)=boot_([\\w_]+)/;\n\t\tmy $pkg = $1;\n\t\t$pkg =~ s#__*#::#g;\n\t\tpush @staticpkgs,$pkg;\n\t    }\n\t}\n    }\n    # Place all of the external libraries after all of the Perl extension\n    # libraries in the final link, in order to maximize the opportunity\n    # for XS code from multiple extensions to resolve symbols against the\n    # same external library while only including that library once.\n    push @optlibs, @$extra;\n\n    $target = \"Perl$Config{'exe_ext'}\" unless $target;\n    my $shrtarget;\n    ($shrtarget,$targdir) = fileparse($target);\n    $shrtarget =~ s/^([^.]*)/$1Shr/;\n    $shrtarget = $targdir . $shrtarget;\n    $target = \"Perlshr.$Config{'dlext'}\" unless $target;\n    $tmpdir = \"[]\" unless $tmpdir;\n    $tmpdir = $self->fixpath($tmpdir,1);\n    if (@optlibs) { $extralist = join(' ',@optlibs); }\n    else          { $extralist = ''; }\n    # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)\n    # that's what we're building here).\n    push @optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];\n    if ($libperl) {\n\tunless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {\n\t    print \"Warning: $libperl not found\\n\";\n\t    undef $libperl;\n\t}\n    }\n    unless ($libperl) {\n\tif (defined $self->{PERL_SRC}) {\n\t    $libperl = $self->catfile($self->{PERL_SRC},\"libperl$self->{LIB_EXT}\");\n\t} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',\"libperl$self->{LIB_EXT}\")) ) {\n\t} else {\n\t    print \"Warning: $libperl not found\n    If you're going to build a static perl binary, make sure perl is installed\n    otherwise ignore this warning\\n\";\n\t}\n    }\n    $libperldir = $self->fixpath((fileparse($libperl))[1],1);\n\n    push @m, '\n# Fill in the target you want to produce if it\\'s not perl\nMAP_TARGET    = ',$self->fixpath($target,0),'\nMAP_SHRTARGET = ',$self->fixpath($shrtarget,0),\"\nMAP_LINKCMD   = $linkcmd\nMAP_PERLINC   = \", $perlinc ? map('\"$_\" ',@{$perlinc}) : '',\"\nMAP_EXTRA     = $extralist\nMAP_LIBPERL = \",$self->fixpath($libperl,0),'\n';\n\n\n    push @m,\"\\n${tmpdir}Makeaperl.Opt : \\$(MAP_EXTRA)\\n\";\n    foreach (@optlibs) {\n\tpush @m,'\t$(NOECHO) $(PERL) -e \"print q{',$_,'}\" >>$(MMS$TARGET)',\"\\n\";\n    }\n    push @m,\"\\n${tmpdir}PerlShr.Opt :\\n\\t\";\n    push @m,'$(NOECHO) $(PERL) -e \"print q{$(MAP_SHRTARGET)}\" >$(MMS$TARGET)',\"\\n\";\n\n    push @m,'\n$(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',\"${libperldir}Perlshr_Attr.Opt\",'\n\t$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',\"${libperldir}Perlshr_Attr.Opt/Option\",'\n$(MAP_TARGET) : $(MAP_SHRTARGET) ',\"${tmpdir}perlmain\\$(OBJ_EXT) ${tmpdir}PerlShr.Opt\",'\n\t$(MAP_LINKCMD) ',\"${tmpdir}perlmain\\$(OBJ_EXT)\",', PerlShr.Opt/Option\n\t$(NOECHO) $(ECHO) \"To install the new \"\"$(MAP_TARGET)\"\" binary, say\"\n\t$(NOECHO) $(ECHO) \"    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)\"\n\t$(NOECHO) $(ECHO) \"To remove the intermediate files, say\n\t$(NOECHO) $(ECHO) \"    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean\"\n';\n    push @m,\"\\n${tmpdir}perlmain.c : \\$(FIRST_MAKEFILE)\\n\\t\\$(NOECHO) \\$(PERL) -e 1 >${tmpdir}Writemain.tmp\\n\";\n    push @m, \"# More from the 255-char line length limit\\n\";\n    foreach (@staticpkgs) {\n\tpush @m,'\t$(NOECHO) $(PERL) -e \"print q{',$_,qq[}\" >>${tmpdir}Writemain.tmp\\n];\n    }\n\n    push @m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;\n\t$(NOECHO) $(PERL) $(MAP_PERLINC) -ane \"use ExtUtils::Miniperl; writemain(@F)\" %sWritemain.tmp >$(MMS$TARGET)\n\t$(NOECHO) $(RM_F) %sWritemain.tmp\nMAKE_FRAG\n\n    push @m, q[\n# Still more from the 255-char line length limit\ndoc_inst_perl :\n\t$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)\n\t$(NOECHO) $(ECHO) \"Perl binary $(MAP_TARGET)|\" >.MM_tmp\n\t$(NOECHO) $(ECHO) \"MAP_STATIC|$(MAP_STATIC)|\" >>.MM_tmp\n\t$(NOECHO) $(PERL) -pl040 -e \" \" ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp\n\t$(NOECHO) $(ECHO) -e \"MAP_LIBPERL|$(MAP_LIBPERL)|\" >>.MM_tmp\n\t$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[\n\t$(NOECHO) $(RM_F) .MM_tmp\n];\n\n    push @m, \"\ninst_perl : pure_inst_perl doc_inst_perl\n\t\\$(NOECHO) \\$(NOOP)\n\npure_inst_perl : \\$(MAP_TARGET)\n\t$self->{CP} \\$(MAP_SHRTARGET) \",$self->fixpath($Config{'installbin'},1),\"\n\t$self->{CP} \\$(MAP_TARGET) \",$self->fixpath($Config{'installbin'},1),\"\n\nclean :: map_clean\n\t\\$(NOECHO) \\$(NOOP)\n\nmap_clean :\n\t\\$(RM_F) ${tmpdir}perlmain\\$(OBJ_EXT) ${tmpdir}perlmain.c \\$(FIRST_MAKEFILE)\n\t\\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \\$(MAP_TARGET)\n\";\n\n    join '', @m;\n}\n\n\n# --- Output postprocessing section ---\n\n=item maketext_filter (override)\n\nEnsure that colons marking targets are preceded by space, in order\nto distinguish the target delimiter from a colon appearing as\npart of a filespec.\n\n=cut\n\nsub maketext_filter {\n    my($self, $text) = @_;\n\n    $text =~ s/^([^\\s:=]+)(:+\\s)/$1 $2/mg;\n    return $text;\n}\n\n=item prefixify (override)\n\nprefixifying on VMS is simple.  Each should simply be:\n\n    perl_root:[some.dir]\n\nwhich can just be converted to:\n\n    volume:[your.prefix.some.dir]\n\notherwise you get the default layout.\n\nIn effect, your search prefix is ignored and $Config{vms_prefix} is\nused instead.\n\n=cut\n\nsub prefixify {\n    my($self, $var, $sprefix, $rprefix, $default) = @_;\n\n    # Translate $(PERLPREFIX) to a real path.\n    $rprefix = $self->eliminate_macros($rprefix);\n    $rprefix = vmspath($rprefix) if $rprefix;\n    $sprefix = vmspath($sprefix) if $sprefix;\n\n    $default = vmsify($default)\n      unless $default =~ /\\[.*\\]/;\n\n    (my $var_no_install = $var) =~ s/^install//;\n    my $path = $self->{uc $var} ||\n               $ExtUtils::MM_Unix::Config_Override{lc $var} ||\n               $Config{lc $var} || $Config{lc $var_no_install};\n\n    if( !$path ) {\n        warn \"  no Config found for $var.\\n\" if $Verbose >= 2;\n        $path = $self->_prefixify_default($rprefix, $default);\n    }\n    elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {\n        # do nothing if there's no prefix or if its relative\n    }\n    elsif( $sprefix eq $rprefix ) {\n        warn \"  no new prefix.\\n\" if $Verbose >= 2;\n    }\n    else {\n\n        warn \"  prefixify $var => $path\\n\"     if $Verbose >= 2;\n        warn \"    from $sprefix to $rprefix\\n\" if $Verbose >= 2;\n\n        my($path_vol, $path_dirs) = $self->splitpath( $path );\n        if( $path_vol eq $Config{vms_prefix}.':' ) {\n            warn \"  $Config{vms_prefix}: seen\\n\" if $Verbose >= 2;\n\n            $path_dirs =~ s{^\\[}{\\[.} unless $path_dirs =~ m{^\\[\\.};\n            $path = $self->_catprefix($rprefix, $path_dirs);\n        }\n        else {\n            $path = $self->_prefixify_default($rprefix, $default);\n        }\n    }\n\n    print \"    now $path\\n\" if $Verbose >= 2;\n    return $self->{uc $var} = $path;\n}\n\n\nsub _prefixify_default {\n    my($self, $rprefix, $default) = @_;\n\n    warn \"  cannot prefix, using default.\\n\" if $Verbose >= 2;\n\n    if( !$default ) {\n        warn \"No default!\\n\" if $Verbose >= 1;\n        return;\n    }\n    if( !$rprefix ) {\n        warn \"No replacement prefix!\\n\" if $Verbose >= 1;\n        return '';\n    }\n\n    return $self->_catprefix($rprefix, $default);\n}\n\nsub _catprefix {\n    my($self, $rprefix, $default) = @_;\n\n    my($rvol, $rdirs) = $self->splitpath($rprefix);\n    if( $rvol ) {\n        return $self->catpath($rvol,\n                                   $self->catdir($rdirs, $default),\n                                   ''\n                                  )\n    }\n    else {\n        return $self->catdir($rdirs, $default);\n    }\n}\n\n\n=item cd\n\n=cut\n\nsub cd {\n    my($self, $dir, @cmds) = @_;\n\n    $dir = vmspath($dir);\n\n    my $cmd = join \"\\n\\t\", map \"$_\", @cmds;\n\n    # No leading tab makes it look right when embedded\n    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;\nstartdir = F$Environment(\"Default\")\n\tSet Default %s\n\t%s\n\tSet Default 'startdir'\nMAKE_FRAG\n\n    # No trailing newline makes this easier to embed\n    chomp $make_frag;\n\n    return $make_frag;\n}\n\n\n=item oneliner\n\n=cut\n\nsub oneliner {\n    my($self, $cmd, $switches) = @_;\n    $switches = [] unless defined $switches;\n\n    # Strip leading and trailing newlines\n    $cmd =~ s{^\\n+}{};\n    $cmd =~ s{\\n+$}{};\n\n    my @cmds = split /\\n/, $cmd;\n    $cmd = join \" \\n\\t  -e \", map $self->quote_literal($_), @cmds;\n    $cmd = $self->escape_newlines($cmd);\n\n    # Switches must be quoted else they will be lowercased.\n    $switches = join ' ', map { qq{\"$_\"} } @$switches;\n\n    return qq{\\$(ABSPERLRUN) $switches -e $cmd \"--\"};\n}\n\n\n=item B<echo>\n\nperl trips up on \"<foo>\" thinking it's an input redirect.  So we use the\nnative Write command instead.  Besides, it's faster.\n\n=cut\n\nsub echo {\n    my($self, $text, $file, $opts) = @_;\n\n    # Compatibility with old options\n    if( !ref $opts ) {\n        my $append = $opts;\n        $opts = { append => $append || 0 };\n    }\n    my $opencmd = $opts->{append} ? 'Open/Append' : 'Open/Write';\n\n    $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};\n\n    my $ql_opts = { allow_variables => $opts->{allow_variables} };\n\n    my @cmds = (\"\\$(NOECHO) $opencmd MMECHOFILE $file \");\n    push @cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_, $ql_opts) }\n                split /\\n/, $text;\n    push @cmds, '$(NOECHO) Close MMECHOFILE';\n    return @cmds;\n}\n\n\n=item quote_literal\n\n=cut\n\nsub quote_literal {\n    my($self, $text, $opts) = @_;\n    $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};\n\n    # I believe this is all we should need.\n    $text =~ s{\"}{\"\"}g;\n\n    $text = $opts->{allow_variables}\n      ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);\n\n    return qq{\"$text\"};\n}\n\n=item escape_dollarsigns\n\nQuote, don't escape.\n\n=cut\n\nsub escape_dollarsigns {\n    my($self, $text) = @_;\n\n    # Quote dollar signs which are not starting a variable\n    $text =~ s{\\$ (?!\\() }{\"\\$\"}gx;\n\n    return $text;\n}\n\n\n=item escape_all_dollarsigns\n\nQuote, don't escape.\n\n=cut\n\nsub escape_all_dollarsigns {\n    my($self, $text) = @_;\n\n    # Quote dollar signs\n    $text =~ s{\\$}{\"\\$\\\"}gx;\n\n    return $text;\n}\n\n=item escape_newlines\n\n=cut\n\nsub escape_newlines {\n    my($self, $text) = @_;\n\n    $text =~ s{\\n}{-\\n}g;\n\n    return $text;\n}\n\n=item max_exec_len\n\n256 characters.\n\n=cut\n\nsub max_exec_len {\n    my $self = shift;\n\n    return $self->{_MAX_EXEC_LEN} ||= 256;\n}\n\n=item init_linker\n\n=cut\n\nsub init_linker {\n    my $self = shift;\n    $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';\n\n    my $shr = $Config{dbgprefix} . 'PERLSHR';\n    if ($self->{PERL_SRC}) {\n        $self->{PERL_ARCHIVE} ||=\n          $self->catfile($self->{PERL_SRC}, \"$shr.$Config{'dlext'}\");\n    }\n    else {\n        $self->{PERL_ARCHIVE} ||=\n          $ENV{$shr} ? $ENV{$shr} : \"Sys\\$Share:$shr.$Config{'dlext'}\";\n    }\n\n    $self->{PERL_ARCHIVEDEP} ||= '';\n    $self->{PERL_ARCHIVE_AFTER} ||= '';\n}\n\n\n=item catdir (override)\n\n=item catfile (override)\n\nEliminate the macros in the output to the MMS/MMK file.\n\n(File::Spec::VMS used to do this for us, but it's being removed)\n\n=cut\n\nsub catdir {\n    my $self = shift;\n\n    # Process the macros on VMS MMS/MMK\n    my @args = map { m{\\$\\(} ? $self->eliminate_macros($_) : $_  } @_;\n\n    my $dir = $self->SUPER::catdir(@args);\n\n    # Fix up the directory and force it to VMS format.\n    $dir = $self->fixpath($dir, 1);\n\n    return $dir;\n}\n\nsub catfile {\n    my $self = shift;\n\n    # Process the macros on VMS MMS/MMK\n    my @args = map { m{\\$\\(} ? $self->eliminate_macros($_) : $_  } @_;\n\n    my $file = $self->SUPER::catfile(@args);\n\n    $file = vmsify($file);\n\n    return $file\n}\n\n\n=item eliminate_macros\n\nExpands MM[KS]/Make macros in a text string, using the contents of\nidentically named elements of C<%$self>, and returns the result\nas a file specification in Unix syntax.\n\nNOTE:  This is the canonical version of the method.  The version in\nFile::Spec::VMS is deprecated.\n\n=cut\n\nsub eliminate_macros {\n    my($self,$path) = @_;\n    return '' unless $path;\n    $self = {} unless ref $self;\n\n    my($npath) = unixify($path);\n    # sometimes unixify will return a string with an off-by-one trailing null\n    $npath =~ s{\\0$}{};\n\n    my($complex) = 0;\n    my($head,$macro,$tail);\n\n    # perform m##g in scalar context so it acts as an iterator\n    while ($npath =~ m#(.*?)\\$\\((\\S+?)\\)(.*)#gs) {\n        if (defined $self->{$2}) {\n            ($head,$macro,$tail) = ($1,$2,$3);\n            if (ref $self->{$macro}) {\n                if (ref $self->{$macro} eq 'ARRAY') {\n                    $macro = join ' ', @{$self->{$macro}};\n                }\n                else {\n                    print \"Note: can't expand macro \\$($macro) containing \",ref($self->{$macro}),\n                          \"\\n\\t(using MMK-specific deferred substitutuon; MMS will break)\\n\";\n                    $macro = \"\\cB$macro\\cB\";\n                    $complex = 1;\n                }\n            }\n            else {\n                $macro = $self->{$macro};\n                # Don't unixify if there is unescaped whitespace\n                $macro = unixify($macro) unless ($macro =~ /(?<!\\^)\\s/);\n                $macro =~ s#/\\Z(?!\\n)##;\n            }\n            $npath = \"$head$macro$tail\";\n        }\n    }\n    if ($complex) { $npath =~ s#\\cB(.*?)\\cB#\\${$1}#gs; }\n    $npath;\n}\n\n=item fixpath\n\n   my $path = $mm->fixpath($path);\n   my $path = $mm->fixpath($path, $is_dir);\n\nCatchall routine to clean up problem MM[SK]/Make macros.  Expands macros\nin any directory specification, in order to avoid juxtaposing two\nVMS-syntax directories when MM[SK] is run.  Also expands expressions which\nare all macro, so that we can tell how long the expansion is, and avoid\noverrunning DCL's command buffer when MM[KS] is running.\n\nfixpath() checks to see whether the result matches the name of a\ndirectory in the current default directory and returns a directory or\nfile specification accordingly.  C<$is_dir> can be set to true to\nforce fixpath() to consider the path to be a directory or false to force\nit to be a file.\n\nNOTE:  This is the canonical version of the method.  The version in\nFile::Spec::VMS is deprecated.\n\n=cut\n\nsub fixpath {\n    my($self,$path,$force_path) = @_;\n    return '' unless $path;\n    $self = bless {}, $self unless ref $self;\n    my($fixedpath,$prefix,$name);\n\n    if ($path =~ m#^\\$\\([^\\)]+\\)\\Z(?!\\n)#s || $path =~ m#[/:>\\]]#) {\n        if ($force_path or $path =~ /(?:DIR\\)|\\])\\Z(?!\\n)/) {\n            $fixedpath = vmspath($self->eliminate_macros($path));\n        }\n        else {\n            $fixedpath = vmsify($self->eliminate_macros($path));\n        }\n    }\n    elsif ((($prefix,$name) = ($path =~ m#^\\$\\(([^\\)]+)\\)(.+)#s)) && $self->{$prefix}) {\n        my($vmspre) = $self->eliminate_macros(\"\\$($prefix)\");\n        # is it a dir or just a name?\n        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\\Z(?!\\n)/) ? vmspath($vmspre) : '';\n        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;\n        $fixedpath = vmspath($fixedpath) if $force_path;\n    }\n    else {\n        $fixedpath = $path;\n        $fixedpath = vmspath($fixedpath) if $force_path;\n    }\n    # No hints, so we try to guess\n    if (!defined($force_path) and $fixedpath !~ /[:>(.\\]]/) {\n        $fixedpath = vmspath($fixedpath) if -d $fixedpath;\n    }\n\n    # Trim off root dirname if it's had other dirs inserted in front of it.\n    $fixedpath =~ s/\\.000000([\\]>])/$1/;\n    # Special case for VMS absolute directory specs: these will have had device\n    # prepended during trip through Unix syntax in eliminate_macros(), since\n    # Unix syntax has no way to express \"absolute from the top of this device's\n    # directory tree\".\n    if ($path =~ /^[\\[>][^.\\-]/) { $fixedpath =~ s/^[^\\[<]+//; }\n\n    return $fixedpath;\n}\n\n\n=item os_flavor\n\nVMS is VMS.\n\n=cut\n\nsub os_flavor {\n    return('VMS');\n}\n\n\n=item is_make_type (override)\n\nNone of the make types being checked for is viable on VMS,\nplus our $self->{MAKE} is an unexpanded (and unexpandable)\nmacro whose value is known only to the make utility itself.\n\n=cut\n\nsub is_make_type {\n    my($self, $type) = @_;\n    return 0;\n}\n\n\n=item make_type (override)\n\nReturns a suitable string describing the type of makefile being written.\n\n=cut\n\nsub make_type { \"$Config{make}-style\"; }\n\n\n=back\n\n\n=head1 AUTHOR\n\nOriginal author Charles Bailey F<bailey@newman.upenn.edu>\n\nMaintained by Michael G Schwern F<schwern@pobox.com>\n\nSee L<ExtUtils::MakeMaker> for patching and contact information.\n\n\n=cut\n\n1;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/t/MM_OS2.t": "#!/usr/bin/perl -w\n\nBEGIN {\n    unshift @INC, 't/lib';\n}\nchdir 't';\n\nuse strict;\nuse Test::More;\nif ($^O =~ /os2/i) {\n\tplan( tests => 32 );\n} else {\n\tplan( skip_all => \"This is not OS/2\" );\n}\n\n# for dlsyms, overridden in tests\nBEGIN {\n\tpackage ExtUtils::MM_OS2;\n\tuse subs 'system', 'unlink';\n}\n\n# for maybe_command\nuse File::Spec;\n\nuse_ok( 'ExtUtils::MM_OS2' );\nok( grep( 'ExtUtils::MM_OS2',  @MM::ISA),\n\t'ExtUtils::MM_OS2 should be parent of MM' );\n\n# dlsyms\nmy $mm = bless({\n\tSKIPHASH => {\n\t\tdynamic => 1\n\t},\n\tNAME => 'foo:bar::',\n}, 'ExtUtils::MM_OS2');\n\nis( $mm->dlsyms(), '',\n\t'dlsyms() should return nothing with dynamic flag set' );\n\n$mm->{BASEEXT} = 'baseext';\ndelete $mm->{SKIPHASH};\nmy $res = $mm->dlsyms();\nlike( $res, qr/baseext\\.def: Makefile/,\n\t'... without flag, should return make targets' );\nlike( $res, qr/\"DL_FUNCS\" => \\{  \\}/,\n\t'... should provide empty hash refs where necessary' );\nlike( $res, qr/\"DL_VARS\" => \\[]/, '... and empty array refs too' );\n\n$mm->{FUNCLIST} = 'funclist';\n$res = $mm->dlsyms( IMPORTS => 'imports' );\nlike( $res, qr/\"FUNCLIST\" => .+funclist/,\n\t'... should pick up values from object' );\nlike( $res, qr/\"IMPORTS\" => .+imports/, '... and allow parameter options too' );\n\nmy $can_write;\n{\n\tlocal *OUT;\n\t$can_write = open(OUT, '>tmp_imp');\n}\n\nSKIP: {\n\tskip(\"Cannot write test files: $!\", 7) unless $can_write;\n\n\t$mm->{IMPORTS} = { foo => 'bar' };\n\n\tlocal $@;\n\teval { $mm->dlsyms() };\n\tlike( $@, qr/Can.t mkdir tmp_imp/,\n\t\t'... should die if directory cannot be made' );\n\n\tunlink('tmp_imp') or skip(\"Cannot remove test file: $!\", 9);\n\teval { $mm->dlsyms() };\n\tlike( $@, qr/Malformed IMPORT/, 'should die from malformed import symbols');\n\n\t$mm->{IMPORTS} = { foo => 'bar.baz' };\n\n\tmy @sysfail = ( 1, 0, 1 );\n\tmy ($sysargs, $unlinked);\n\n\t*ExtUtils::MM_OS2::system = sub {\n\t\t$sysargs = shift;\n\t\treturn shift @sysfail;\n\t};\n\n\t*ExtUtils::MM_OS2::unlink = sub {\n\t\t$unlinked++;\n\t};\n\n\teval { $mm->dlsyms() };\n\n\tlike( $sysargs, qr/^emximp/, '... should try to call system() though' );\n\tlike( $@, qr/Cannot make import library/,\n\t\t'... should die if emximp syscall fails' );\n\n\t# sysfail is 0 now, call emximp call should succeed\n\teval { $mm->dlsyms() };\n\tis( $unlinked, 1, '... should attempt to unlink temp files' );\n\tlike( $@, qr/Cannot extract import/,\n\t\t'... should die if other syscall fails' );\n\n\t# make both syscalls succeed\n\t@sysfail = (0, 0);\n\tlocal $@;\n\teval { $mm->dlsyms() };\n\tis( $@, '', '... should not die if both syscalls succeed' );\n}\n\n# static_lib\n{\n\tmy $called = 0;\n\n\t# avoid \"used only once\"\n\tlocal *ExtUtils::MM_Unix::static_lib;\n\t*ExtUtils::MM_Unix::static_lib = sub {\n\t\t$called++;\n\t\treturn \"\\n\\ncalled static_lib\\n\\nline2\\nline3\\n\\nline4\";\n\t};\n\n\tmy $args = bless({ IMPORTS => {}, }, 'MM');\n\n\t# without IMPORTS as a populated hash, there will be no extra data\n\tmy $ret = ExtUtils::MM_OS2::static_lib( $args );\n\tis( $called, 1, 'static_lib() should call parent method' );\n\tlike( $ret, qr/^called static_lib/m,\n\t\t'... should return parent data unless IMPORTS exists' );\n\n\t$args->{IMPORTS} = { foo => 1};\n\t$ret = ExtUtils::MM_OS2::static_lib( $args );\n\tis( $called, 2, '... should call parent method if extra imports passed' );\n\tlike( $ret, qr/^called static_lib\\n\\t\\$\\(AR\\) \\$\\(AR_STATIC_ARGS\\)/m,\n\t\t'... should append make tags to first line from parent method' );\n\tlike( $ret, qr/\\$@\\n\\n\\nline2\\nline3\\n\\nline4/m,\n\t\t'... should include remaining data from parent method' );\n\n}\n\n# replace_manpage_separator\nmy $sep = '//a///b//c/de';\nis( ExtUtils::MM_OS2->replace_manpage_separator($sep), '.a.b.c.de',\n\t'replace_manpage_separator() should turn multiple slashes into periods' );\n\n# maybe_command\n{\n\tlocal *DIR;\n\tmy ($dir, $noext, $exe, $cmd);\n\tmy $found = 0;\n\n\tmy ($curdir, $updir) = (File::Spec->curdir, File::Spec->updir);\n\n\t# we need:\n\t#\t1) a directory\n\t#\t2) an executable file with no extension\n\t# \t3) an executable file with the .exe extension\n\t# \t4) an executable file with the .cmd extension\n\t# we assume there will be one somewhere in the path\n\t# in addition, we need them to be unique enough they do not trip\n\t# an earlier file test in maybe_command().  Portability.\n\n\tforeach my $path (split(/:/, $ENV{PATH})) {\n\t\topendir(DIR, $path) or next;\n\t\twhile (defined(my $file = readdir(DIR))) {\n\t\t\tnext if $file eq $curdir or $file eq $updir;\n\t\t\t$file = File::Spec->catfile($path, $file);\n\t\t\tunless (defined $dir) {\n\t\t\t\tif (-d $file) {\n\t\t\t\t\tnext if ( -x $file . '.exe' or -x $file . '.cmd' );\n\n\t\t\t\t\t$dir = $file;\n\t\t\t\t\t$found++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (-x $file) {\n\t\t\t\tmy $ext;\n\t\t\t\tif ($file =~ s/\\.(exe|cmd)\\z//) {\n\t\t\t\t\t$ext = $1;\n\n\t\t\t\t\t# skip executable files with names too similar\n\t\t\t\t\tnext if -x $file;\n\t\t\t\t\t$file .= '.' . $ext;\n\n\t\t\t\t} else {\n\t\t\t\t\tunless (defined $noext) {\n\t\t\t\t\t\t$noext = $file;\n\t\t\t\t\t\t$found++;\n\t\t\t\t\t}\n\t\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t\tunless (defined $exe) {\n\t\t\t\t\tif ($ext eq 'exe') {\n\t\t\t\t\t\t$exe = $file;\n\t\t\t\t\t\t$found++;\n\t\t\t\t\t\tnext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunless (defined $cmd) {\n\t\t\t\t\tif ($ext eq 'cmd') {\n\t\t\t\t\t\t$cmd = $file;\n\t\t\t\t\t\t$found++;\n\t\t\t\t\t\tnext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast if $found == 4;\n\t\t}\n\t\tlast if $found == 4;\n\t}\n\n\tSKIP: {\n\t\tskip('No appropriate directory found', 1) unless defined $dir;\n\t\tis( ExtUtils::MM_OS2->maybe_command( $dir ), undef,\n\t\t\t'maybe_command() should ignore directories' );\n\t}\n\n\tSKIP: {\n\t\tskip('No non-exension command found', 1) unless defined $noext;\n\t\tis( ExtUtils::MM_OS2->maybe_command( $noext ), $noext,\n\t\t\t'maybe_command() should find executable lacking file extension' );\n\t}\n\n\tSKIP: {\n\t\tskip('No .exe command found', 1) unless defined $exe;\n\t\t(my $noexe = $exe) =~ s/\\.exe\\z//;\n\t\tis( ExtUtils::MM_OS2->maybe_command( $noexe ), $exe,\n\t\t\t'maybe_command() should find .exe file lacking extension' );\n\t}\n\n\tSKIP: {\n\t\tskip('No .cmd command found', 1) unless defined $cmd;\n\t\t(my $nocmd = $cmd) =~ s/\\.cmd\\z//;\n\t\tis( ExtUtils::MM_OS2->maybe_command( $nocmd ), $cmd,\n\t\t\t'maybe_command() should find .cmd file lacking extension' );\n\t}\n}\n\n# file_name_is_absolute\nok( ExtUtils::MM_OS2->file_name_is_absolute( 's:/' ),\n\t'file_name_is_absolute() should be true for paths with volume and slash' );\nok( ExtUtils::MM_OS2->file_name_is_absolute( '\\foo' ),\n\t'... and for paths with leading slash but no volume' );\nok( ! ExtUtils::MM_OS2->file_name_is_absolute( 'arduk' ),\n\t'... but not for paths with no leading slash or volume' );\n\n\n$mm->init_linker;\n\n# PERL_ARCHIVE\nis( $mm->{PERL_ARCHIVE}, '$(PERL_INC)/libperl$(LIB_EXT)', 'PERL_ARCHIVE' );\n\n# PERL_ARCHIVE_AFTER\n{\n\tmy $aout = 0;\n\tlocal *OS2::is_aout;\n\t*OS2::is_aout = \\$aout;\n\n        $mm->init_linker;\n\tisnt( $mm->{PERL_ARCHIVE_AFTER}, '',\n\t\t'PERL_ARCHIVE_AFTER should be empty without $is_aout set' );\n\t$aout = 1;\n\tis( $mm->{PERL_ARCHIVE_AFTER},\n            '$(PERL_INC)/libperl_override$(LIB_EXT)',\n\t\t'... and has libperl_override if it is set' );\n}\n\n# EXPORT_LIST\nis( $mm->{EXPORT_LIST}, '$(BASEEXT).def',\n\t'EXPORT_LIST should add .def to BASEEXT member' );\n\nEND {\n\tuse File::Path;\n\trmtree('tmp_imp') if -e 'tmp_imp';\n\tunlink 'tmpimp.imp';\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/t/MM_Unix.t": "#!/usr/bin/perl -w\n\nBEGIN {\n    unshift @INC, 't/lib';\n}\nchdir 't';\n\nBEGIN {\n    use Test::More;\n\n    if( $^O =~ /^VMS|os2|MacOS|MSWin32|cygwin|beos|netware$/i ) {\n        plan skip_all => 'Non-Unix platform';\n    }\n    else {\n        plan tests => 110;\n    }\n}\n\nBEGIN { use_ok( 'ExtUtils::MM_Unix' ); }\n\nuse strict;\nuse File::Spec;\n\nmy $class = 'ExtUtils::MM_Unix';\n\n# only one of the following can be true\n# test should be removed if MM_Unix ever stops handling other OS than Unix\nmy $os =  ($ExtUtils::MM_Unix::Is{OS2}   || 0)\n        + ($ExtUtils::MM_Unix::Is{Win32} || 0)\n        + ($ExtUtils::MM_Unix::Is{Dos}   || 0)\n        + ($ExtUtils::MM_Unix::Is{VMS}   || 0);\ncmp_ok ( $os, '<=', 1,  'There can be only one (or none)');\n\nis($ExtUtils::MM_Unix::VERSION, $ExtUtils::MakeMaker::VERSION, 'MM_Unix has a $VERSION');\n\n# when the following calls like canonpath, catdir etc are replaced by\n# File::Spec calls, the test's become a bit pointless\n\nforeach ( qw( xx/ ./xx/ xx/././xx xx///xx) ) {\n    is ($class->canonpath($_), File::Spec->canonpath($_), \"canonpath $_\");\n}\n\nis ($class->catdir('xx','xx'), File::Spec->catdir('xx','xx'),\n     'catdir(xx, xx) => xx/xx');\nis ($class->catfile('xx','xx','yy'), File::Spec->catfile('xx','xx','yy'),\n     'catfile(xx, xx) => xx/xx');\n\nis ($class->file_name_is_absolute('Bombdadil'),\n    File::Spec->file_name_is_absolute('Bombdadil'),\n     'file_name_is_absolute()');\n\nis ($class->path(), File::Spec->path(), 'path() same as File::Spec->path()');\n\nforeach (qw/updir curdir rootdir/)\n  {\n  is ($class->$_(), File::Spec->$_(), $_ );\n  }\n\nforeach ( qw /\n  c_o\n  clean\n  const_cccmd\n  const_config\n  const_loadlibs\n  constants\n  depend\n  dist\n  dist_basics\n  dist_ci\n  dist_core\n  distdir\n  dist_test\n  dlsyms\n  dynamic\n  dynamic_bs\n  dynamic_lib\n  exescan\n  extliblist\n  find_perl\n  fixin\n  force\n  guess_name\n  init_dirscan\n  init_main\n  init_others\n  install\n  installbin\n  linkext\n  lsdir\n  macro\n  makeaperl\n  makefile\n  manifypods\n  needs_linking\n  pasthru\n  perldepend\n  pm_to_blib\n  ppd\n  prefixify\n  processPL\n  realclean\n  static\n  static_lib\n  staticmake\n  subdir_x\n  subdirs\n  test\n  test_via_harness\n  test_via_script\n  tool_autosplit\n  tool_xsubpp\n  tools_other\n  top_targets\n  writedoc\n  xs_c\n  xs_cpp\n  xs_o\n  / )\n  {\n      can_ok($class, $_);\n  }\n\n###############################################################################\n# some more detailed tests for the methods above\n\nok ( join (' ', $class->dist_basics()), 'distclean :: realclean distcheck');\n\n###############################################################################\n# has_link_code tests\n\nmy $t = bless { NAME => \"Foo\" }, $class;\n$t->{HAS_LINK_CODE} = 1;\nis ($t->has_link_code(),1,'has_link_code'); is ($t->{HAS_LINK_CODE},1);\n\n$t->{HAS_LINK_CODE} = 0;\nis ($t->has_link_code(),0); is ($t->{HAS_LINK_CODE},0);\n\ndelete $t->{HAS_LINK_CODE}; delete $t->{OBJECT};\nis ($t->has_link_code(),0); is ($t->{HAS_LINK_CODE},0);\n\ndelete $t->{HAS_LINK_CODE}; $t->{OBJECT} = 1;\nis ($t->has_link_code(),1); is ($t->{HAS_LINK_CODE},1);\n\ndelete $t->{HAS_LINK_CODE}; delete $t->{OBJECT}; $t->{MYEXTLIB} = 1;\nis ($t->has_link_code(),1); is ($t->{HAS_LINK_CODE},1);\n\ndelete $t->{HAS_LINK_CODE}; delete $t->{MYEXTLIB}; $t->{C} = [ 'Gloin' ];\nis ($t->has_link_code(),1); is ($t->{HAS_LINK_CODE},1);\n\n###############################################################################\n# libscan\n\nis ($t->libscan('foo/RCS/bar'),     '', 'libscan on RCS');\nis ($t->libscan('CVS/bar/car'),     '', 'libscan on CVS');\nis ($t->libscan('SCCS'),            '', 'libscan on SCCS');\nis ($t->libscan('.svn/something'),  '', 'libscan on Subversion');\nis ($t->libscan('foo/b~r'),         'foo/b~r',    'libscan on file with ~');\nis ($t->libscan('foo/RCS.pm'),      'foo/RCS.pm', 'libscan on file with RCS');\n\nis ($t->libscan('Fatty'), 'Fatty', 'libscan on something not a VC file' );\n\n###############################################################################\n# maybe_command\n\nopen(FILE, \">command\"); print FILE \"foo\"; close FILE;\nSKIP: {\n    skip(\"no separate execute mode on VOS\", 2) if $^O eq \"vos\";\n\n    ok !$t->maybe_command('command') ,\"non executable file isn't a command\";\n\n    chmod 0755, \"command\";\n    ok ($t->maybe_command('command'),        \"executable file is a command\");\n}\nunlink \"command\";\n\n\n###############################################################################\n# perl_script (on unix any ordinary, readable file)\n\nmy $self_name = 'MM_Unix.t';\nis ($t->perl_script($self_name),$self_name, 'we pass as a perl_script()');\n\n###############################################################################\n# PERM_RW and PERM_RWX\n\n$t->init_PERM;\nis ($t->{PERM_RW},'644', 'PERM_RW is 644');\nis ($t->{PERM_RWX},'755', 'PERM_RWX is 755');\nis ($t->{PERM_DIR},'755', 'PERM_DIR is 755');\n\n\n###############################################################################\n# post_constants, postamble, post_initialize\n\nforeach (qw/ post_constants postamble post_initialize/) {\n  is ($t->$_(),'', \"$_() is an empty string\");\n}\n\n###############################################################################\n# replace_manpage_separator\n\nis ($t->replace_manpage_separator('Foo/Bar'),'Foo::Bar','manpage_separator');\n\n###############################################################################\n\n$t->init_linker;\nforeach (qw/ EXPORT_LIST PERL_ARCHIVE PERL_ARCHIVE_AFTER /)\n{\n    ok( exists $t->{$_}, \"$_ was defined\" );\n    is( $t->{$_}, '', \"$_ is empty on Unix\");\n}\n\n\n{\n    $t->{CCFLAGS} = '-DMY_THING';\n    $t->{LIBPERL_A} = 'libperl.a';\n    $t->{LIB_EXT}   = '.a';\n    local $t->{NEEDS_LINKING} = 1;\n    $t->cflags();\n\n    # Brief bug where CCFLAGS was being blown away\n    like( $t->{CCFLAGS}, qr/\\-DMY_THING/,    'cflags retains CCFLAGS' );\n}\n\n{\n    my @targv = (\"var=don't forget about spaces and single quotes\");\n    local @ARGV = @targv;\n    my $t = bless { NAME => \"Foo\", FULLPERL => $0, DIR => [] }, $class;\n    $t->makeaperl( TARGET => \"Tgt\" );\n    is_deeply( \\@ARGV, \\@targv, 'ARGV is not polluted by makeaperl' );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-perl-extutils-makemaker-7.24-sppekn3s63rkzf4musxrnkrgsph27kf4/spack-src/t/MM_VMS.t": "#!/usr/bin/perl -w\n\nBEGIN {\n    unshift @INC, 't/lib';\n}\nchdir 't';\n\nBEGIN {\n    @Methods = (qw(wraplist\n                   rootdir\n                   ext\n                   guess_name\n                   find_perl\n                   path\n                   maybe_command\n                   perl_script\n                   file_name_is_absolute\n                   replace_manpage_separator\n                   init_others\n                   constants\n                   cflags\n                   const_cccmd\n                   pm_to_blib\n                   tool_autosplit\n                   tool_xsubpp\n                   tools_other\n                   dist\n                   c_o\n                   xs_c\n                   xs_o\n                   top_targets\n                   dlsyms\n                   dynamic_lib\n                   dynamic_bs\n                   static_lib\n                   manifypods\n                   processPL\n                   installbin\n                   subdir_x\n                   clean\n                   realclean\n                   dist_basics\n                   dist_core\n                   distdir\n                   dist_test\n                   install\n                   perldepend\n                   makefile\n                   test\n                   test_via_harness\n                   test_via_script\n                   makeaperl\n                  ));\n}\n\nBEGIN {\n    use Test::More;\n    if ($^O eq 'VMS') {\n        plan( tests => @Methods + 1 );\n    }\n    else {\n        plan( skip_all => \"This is not VMS\" );\n    }\n}\n\nuse_ok( 'ExtUtils::MM_VMS' );\n\nforeach my $meth (@Methods) {\n    can_ok( 'ExtUtils::MM_VMS', $meth);\n}\n"
    },
    "skipped": [],
    "total_files": 161
}