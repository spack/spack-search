{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/config/PETSc/Configure.py": "import config.base\n\nimport os\nimport sys\nimport re\nimport cPickle\n\n# The sorted() builtin is not available with python-2.3\ntry: sorted\nexcept NameError:\n  def sorted(lst):\n    lst.sort()\n    return lst\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = 'PETSC'\n    self.substPrefix  = 'PETSC'\n    self.installed = 0 # 1 indicates that Configure itself has already compiled and installed PETSc\n    return\n\n  def __str2__(self):\n    desc = []\n    if not self.installed:\n      desc.append('xxx=========================================================================xxx')\n      if self.make.getMakeMacro('MAKE_IS_GNUMAKE'):\n        build_type = 'gnumake build'\n      elif self.getMakeMacro('PETSC_BUILD_USING_CMAKE'):\n        build_type = 'cmake build'\n      else:\n        build_type = 'legacy build'\n      desc.append(' Configure stage complete. Now build PETSc libraries with (%s):' % build_type)\n      desc.append('   make PETSC_DIR='+self.petscdir.dir+' PETSC_ARCH='+self.arch.arch+' all')\n      desc.append('xxx=========================================================================xxx')\n    else:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Installation complete. You do not need to run make to compile or install the software')\n      desc.append('xxx=========================================================================xxx')\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n    help.addArgument('PETSc',  '-prefix=<dir>',                   nargs.Arg(None, '', 'Specifiy location to install PETSc (eg. /usr/local)'))\n    help.addArgument('PETSc',  '-with-prefetch=<bool>',           nargs.ArgBool(None, 1,'Enable checking for prefetch instructions'))\n    help.addArgument('Windows','-with-windows-graphics=<bool>',   nargs.ArgBool(None, 1,'Enable check for Windows Graphics'))\n    help.addArgument('PETSc', '-with-default-arch=<bool>',        nargs.ArgBool(None, 1, 'Allow using the last configured arch without setting PETSC_ARCH'))\n    help.addArgument('PETSc','-with-single-library=<bool>',       nargs.ArgBool(None, 1,'Put all PETSc code into the single -lpetsc library'))\n    help.addArgument('PETSc', '-with-ios=<bool>',              nargs.ArgBool(None, 0, 'Build an iPhone/iPad version of PETSc library'))\n    help.addArgument('PETSc', '-with-xsdk-defaults', nargs.ArgBool(None, 0, 'Set the following as defaults for the xSDK standard: --enable-debug=1, --enable-shared=1, --with-precision=double, --with-index-size=32, locate blas/lapack automatically'))\n    help.addArgument('PETSc', '-known-has-attribute-aligned=<bool>',nargs.ArgBool(None, None, 'Indicates __attribute((aligned(16)) directive works (the usual test will be skipped)'))\n    help.addArgument('PETSc','-with-viewfromoptions=<bool>',      nargs.ArgBool(None, 1,'Support XXXSetFromOptions() calls, for calls with many small solvers turn this off'))\n\n    return\n\n  def registerPythonFile(self,filename,directory):\n    ''' Add a python file to the framework and registers its headerprefix, ... externalpackagedir\n        directory is the directory where the file relative to the BuildSystem or config path in python notation with . '''\n    (utilityName, ext) = os.path.splitext(filename)\n    if not utilityName.startswith('.') and not utilityName.startswith('#') and ext == '.py' and not utilityName == '__init__':\n      if directory: directory = directory+'.'\n      utilityObj                             = self.framework.require(directory+utilityName, self)\n      utilityObj.headerPrefix                = self.headerPrefix\n      utilityObj.archProvider                = self.arch\n      utilityObj.languageProvider            = self.languages\n      utilityObj.installDirProvider          = self.installdir\n      utilityObj.externalPackagesDirProvider = self.externalpackagesdir\n      utilityObj.precisionProvider           = self.scalartypes\n      utilityObj.indexProvider               = self.indexTypes\n      setattr(self, utilityName.lower(), utilityObj)\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.programs      = framework.require('config.programs',           self)\n    self.setCompilers  = framework.require('config.setCompilers',       self)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.arch          = framework.require('PETSc.options.arch',        self.setCompilers)\n    self.petscdir      = framework.require('PETSc.options.petscdir',    self.arch)\n    self.installdir    = framework.require('PETSc.options.installDir',  self)\n    self.scalartypes   = framework.require('PETSc.options.scalarTypes', self)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self)\n    self.languages     = framework.require('PETSc.options.languages',   self.setCompilers)\n    self.debugging     = framework.require('PETSc.options.debugging',   self.compilers)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self.compilers)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.types         = framework.require('config.types',              self)\n    self.headers       = framework.require('config.headers',            self)\n    self.functions     = framework.require('config.functions',          self)\n    self.libraries     = framework.require('config.libraries',          self)\n    self.atomics       = framework.require('config.atomics',            self)\n    self.make          = framework.require('config.packages.make',      self)\n    self.blasLapack    = framework.require('config.packages.BlasLapack',self)\n    self.cmake         = framework.require('config.packages.cmake',self)\n    self.externalpackagesdir = framework.require('PETSc.options.externalpackagesdir',self)\n    self.mpi           = framework.require('config.packages.MPI',self)\n\n    for utility in os.listdir(os.path.join('config','PETSc','options')):\n      self.registerPythonFile(utility,'PETSc.options')\n\n    for utility in os.listdir(os.path.join('config','BuildSystem','config','utilities')):\n      self.registerPythonFile(utility,'config.utilities')\n\n    for package in os.listdir(os.path.join('config', 'BuildSystem', 'config', 'packages')):\n      self.registerPythonFile(package,'config.packages')\n\n    # Force blaslapack and opencl to depend on scalarType so precision is set before BlasLapack is built\n    framework.require('PETSc.options.scalarTypes', self.f2cblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.fblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.blaslapack)\n    framework.require('PETSc.options.scalarTypes', self.opencl)\n    framework.require('PETSc.Regression', self)\n\n    self.programs.headerPrefix   = self.headerPrefix\n    self.compilers.headerPrefix  = self.headerPrefix\n    self.types.headerPrefix      = self.headerPrefix\n    self.headers.headerPrefix    = self.headerPrefix\n    self.functions.headerPrefix  = self.headerPrefix\n    self.libraries.headerPrefix  = self.headerPrefix\n\n    # Look for any user provided --download-xxx=directory packages\n    for arg in sys.argv:\n      if arg.startswith('--download-') and arg.find('=') > -1:\n        pname = arg[11:arg.find('=')]\n        if not hasattr(self,pname):\n          dname = os.path.dirname(arg[arg.find('=')+1:])\n          if os.path.isdir(dname) and not os.path.isfile(os.path.join(dname,pname+'.py')):\n            self.framework.logPrint('User is registering a new package: '+arg)\n            sys.path.append(dname)\n            self.registerPythonFile(pname+'.py','')\n\n    # test for a variety of basic headers and functions\n    headersC = map(lambda name: name+'.h', ['setjmp','dos', 'endian', 'fcntl', 'float', 'io', 'limits', 'malloc', 'pwd', 'search', 'strings',\n                                            'unistd', 'sys/sysinfo', 'machine/endian', 'sys/param', 'sys/procfs', 'sys/resource',\n                                            'sys/systeminfo', 'sys/times', 'sys/utsname','string', 'stdlib',\n                                            'sys/socket','sys/wait','netinet/in','netdb','Direct','time','Ws2tcpip','sys/types',\n                                            'WindowsX', 'cxxabi','float','ieeefp','stdint','sched','pthread','mathimf','inttypes'])\n    functions = ['access', '_access', 'clock', 'drand48', 'getcwd', '_getcwd', 'getdomainname', 'gethostname',\n                 'gettimeofday', 'getwd', 'memalign', 'memmove', 'mkstemp', 'popen', 'PXFGETARG', 'rand', 'getpagesize',\n                 'readlink', 'realpath',  'sigaction', 'signal', 'sigset', 'usleep', 'sleep', '_sleep', 'socket',\n                 'times', 'gethostbyname', 'uname','snprintf','_snprintf','lseek','_lseek','time','fork','stricmp',\n                 'strcasecmp', 'bzero', 'dlopen', 'dlsym', 'dlclose', 'dlerror','get_nprocs','sysctlbyname',\n                 '_set_output_format','_mkdir']\n    libraries1 = [(['socket', 'nsl'], 'socket'), (['fpe'], 'handle_sigfpes')]\n    self.headers.headers.extend(headersC)\n    self.functions.functions.extend(functions)\n    self.libraries.libraries.extend(libraries1)\n\n    return\n\n  def DumpPkgconfig(self):\n    ''' Create a pkg-config file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig'))\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig','PETSc.pc'),'w')\n    if self.framework.argDB['prefix']:\n      fd.write('prefix='+self.installdir.dir+'\\n')\n      fd.write('exec_prefix=${prefix}\\n')\n      fd.write('includedir=${prefix}/include\\n')\n    else:\n      fd.write('prefix='+self.petscdir.dir+'\\n')\n      fd.write('exec_prefix=${prefix}\\n')\n      fd.write('includedir=${prefix}/include\\n')\n    fd.write('libdir='+os.path.join(self.installdir.dir,'lib')+'\\n')\n\n    self.setCompilers.pushLanguage('C')\n    fd.write('ccompiler='+self.setCompilers.getCompiler()+'\\n')\n    fd.write('cflags_extra=\"'+self.setCompilers.getCompilerFlags().strip()+'\"\\n')\n    fd.write('cflags_dep=\"'+self.compilers.dependenciesGenerationFlag.get('C','')+'\"\\n')\n    fd.write('ldflag_rpath=\"'+self.setCompilers.CSharedLinkerFlag+'\"\\n')\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'C++'):\n      self.setCompilers.pushLanguage('C++')\n      fd.write('cxxcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('cxxflags_extra=\"'+self.setCompilers.getCompilerFlags().strip()+'\"\\n')\n      self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('fcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('fflags_extra=\"'+self.setCompilers.getCompilerFlags().strip()+'\"\\n')\n      self.setCompilers.popLanguage()\n\n    fd.write('\\n')\n    fd.write('Name: PETSc\\n')\n    fd.write('Description: Library to solve ODEs and algebraic equations\\n')\n    fd.write('Version: %s\\n' % self.petscdir.version)\n    fd.write('Cflags: ' + self.setCompilers.CPPFLAGS + ' ' + self.PETSC_CC_INCLUDES + '\\n')\n    fd.write('Libs: '+self.libraries.toStringNoDupes(['-L${libdir}', self.petsclib], with_rpath=False)+'\\n')\n    # Remove RPATH flags from library list.  User can add them using\n    # pkg-config --variable=ldflag_rpath and pkg-config --libs-only-L\n    lflags = self.packagelibs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split()\n    fd.write('Libs.private: '+self.libraries.toStringNoDupes([f for f in lflags if not f.startswith(self.setCompilers.CSharedLinkerFlag)], with_rpath=False)+'\\n')\n\n    fd.close()\n    return\n\n  def DumpModule(self):\n    ''' Create a module file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules'))\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc'))\n    if self.framework.argDB['prefix']:\n      installdir  = self.installdir.dir\n      installarch = ''\n      installpath = os.path.join(installdir,'bin')\n    else:\n      installdir  = self.petscdir.dir\n      installarch = self.arch.arch\n      installpath = os.path.join(installdir,installarch,'bin')+':'+os.path.join(installdir,'bin')\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc',self.petscdir.version),'w')\n    fd.write('''\\\n#%%Module\n\nproc ModulesHelp { } {\n    puts stderr \"This module sets the path and environment variables for petsc-%s\"\n    puts stderr \"     see http://www.mcs.anl.gov/petsc/ for more information      \"\n    puts stderr \"\"\n}\nmodule-whatis \"PETSc - Portable, Extensible Toolkit for Scientific Computation\"\n\nset petsc_dir   %s\nset petsc_arch  %s\n\nsetenv PETSC_ARCH $petsc_arch\nsetenv PETSC_DIR $petsc_dir\nprepend-path PATH %s\n''' % (self.petscdir.version, installdir, installarch, installpath))\n    fd.close()\n    return\n\n  def Dump(self):\n    ''' Actually put the values into the configuration files '''\n    # eventually everything between -- should be gone\n    if self.mpi.usingMPIUni:\n      #\n      # Remove any MPI/MPICH include files that may have been put here by previous runs of ./configure\n      self.executeShellCommand('rm -rf  '+os.path.join(self.petscdir.dir,self.arch.arch,'include','mpi*')+' '+os.path.join(self.petscdir.dir,self.arch.arch,'include','opa*'), log = self.log)\n\n#-----------------------------------------------------------------------------------------------------\n\n    # Sometimes we need C compiler, even if built with C++\n    self.setCompilers.pushLanguage('C')\n    self.addMakeMacro('CC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n\n    # And sometimes we need a C++ compiler even when PETSc is built with C\n    if hasattr(self.compilers, 'CXX'):\n      self.setCompilers.pushLanguage('Cxx')\n      self.addMakeMacro('CXX_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # C preprocessor values\n    self.addMakeMacro('CPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n    # compiler values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    self.addMakeMacro('PCC',self.setCompilers.getCompiler())\n    self.addMakeMacro('PCC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n    # .o or .obj\n    self.addMakeMacro('CC_SUFFIX','o')\n\n    # executable linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    pcc_linker = self.setCompilers.getLinker()\n    self.addMakeMacro('PCC_LINKER',pcc_linker)\n    self.addMakeMacro('PCC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n    self.setCompilers.popLanguage()\n    # '' for Unix, .exe for Windows\n    self.addMakeMacro('CC_LINKER_SUFFIX','')\n\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      # need FPPFLAGS in config/setCompilers\n      self.addDefine('HAVE_FORTRAN','1')\n      self.addMakeMacro('FPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n      # compiler values\n      self.addMakeMacro('FC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n      # .o or .obj\n      self.addMakeMacro('FC_SUFFIX','o')\n\n      # executable linker values\n      self.setCompilers.pushLanguage('FC')\n      # Cannot have NAG f90 as the linker - so use pcc_linker as fc_linker\n      fc_linker = self.setCompilers.getLinker()\n      if config.setCompilers.Configure.isNAG(fc_linker, self.log):\n        self.addMakeMacro('FC_LINKER',pcc_linker)\n      else:\n        self.addMakeMacro('FC_LINKER',fc_linker)\n      self.addMakeMacro('FC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      # apple requires this shared library linker flag on SOME versions of the os\n      if self.setCompilers.getLinkerFlags().find('-Wl,-commons,use_dylibs') > -1:\n        self.addMakeMacro('DARWIN_COMMONS_USE_DYLIBS',' -Wl,-commons,use_dylibs ')\n      self.setCompilers.popLanguage()\n\n      # F90 Modules\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_FLAG', self.setCompilers.fortranModuleIncludeFlag)\n      else: # for non-f90 compilers like g77\n        self.addMakeMacro('FC_MODULE_FLAG', '-I')\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_OUTPUT_FLAG', self.setCompilers.fortranModuleOutputFlag)\n    else:\n      self.addMakeMacro('FC','')\n\n    if hasattr(self.compilers, 'CUDAC'):\n      self.setCompilers.pushLanguage('CUDA')\n      self.addMakeMacro('CUDAC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # shared library linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    # need to fix BuildSystem to collect these separately\n    self.addMakeMacro('SL_LINKER',self.setCompilers.getLinker())\n    self.addMakeMacro('SL_LINKER_FLAGS','${PCC_LINKER_FLAGS}')\n    self.setCompilers.popLanguage()\n    # One of 'a', 'so', 'lib', 'dll', 'dylib' (perhaps others also?) depending on the library generator and architecture\n    # Note: . is not included in this macro, consistent with AR_LIB_SUFFIX\n    if self.setCompilers.sharedLibraryExt == self.setCompilers.AR_LIB_SUFFIX:\n      self.addMakeMacro('SL_LINKER_SUFFIX', '')\n      self.addDefine('SLSUFFIX','\"\"')\n    else:\n      self.addMakeMacro('SL_LINKER_SUFFIX', self.setCompilers.sharedLibraryExt)\n      self.addDefine('SLSUFFIX','\"'+self.setCompilers.sharedLibraryExt+'\"')\n\n    self.addMakeMacro('SL_LINKER_LIBS','${PETSC_EXTERNAL_LIB_BASIC}')\n\n#-----------------------------------------------------------------------------------------------------\n\n    # CONLY or CPP. We should change the PETSc makefiles to do this better\n    if self.languages.clanguage == 'C': lang = 'CONLY'\n    else: lang = 'CXXONLY'\n    self.addMakeMacro('PETSC_LANGUAGE',lang)\n\n    # real or complex\n    self.addMakeMacro('PETSC_SCALAR',self.scalartypes.scalartype)\n    # double or float\n    self.addMakeMacro('PETSC_PRECISION',self.scalartypes.precision)\n\n    if self.framework.argDB['with-batch']:\n      self.addMakeMacro('PETSC_WITH_BATCH','1')\n\n    # Test for compiler-specific macros that need to be defined.\n    if self.setCompilers.isCrayVector('CC', self.log):\n      self.addDefine('HAVE_CRAY_VECTOR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    if self.functions.haveFunction('gethostbyname') and self.functions.haveFunction('socket') and self.headers.haveHeader('netinet/in.h'):\n      self.addDefine('USE_SOCKET_VIEWER','1')\n      if self.checkCompile('#include <sys/socket.h>','setsockopt(0,SOL_SOCKET,SO_REUSEADDR,0,0)'):\n        self.addDefine('HAVE_SO_REUSEADDR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    # print include and lib for makefiles\n    self.framework.packages.reverse()\n    includes = [os.path.join(self.petscdir.dir,'include'),os.path.join(self.petscdir.dir,self.arch.arch,'include')]\n    libs = []\n    for i in self.framework.packages:\n      if i.useddirectly:\n        self.addDefine('HAVE_'+i.PACKAGE.replace('-','_'), 1)  # ONLY list package if it is used directly by PETSc (and not only by another package)\n      if not isinstance(i.lib, list):\n        i.lib = [i.lib]\n      if i.linkedbypetsc: libs.extend(i.lib)\n      self.addMakeMacro(i.PACKAGE.replace('-','_')+'_LIB', self.libraries.toStringNoDupes(i.lib))\n      if hasattr(i,'include'):\n        if not isinstance(i.include,list):\n          i.include = [i.include]\n        includes.extend(i.include)\n        self.addMakeMacro(i.PACKAGE.replace('-','_')+'_INCLUDE',self.headers.toStringNoDupes(i.include))\n    self.packagelibs = libs\n    if self.framework.argDB['with-single-library']:\n      self.petsclib = '-lpetsc'\n    else:\n      self.petsclib = '-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys'\n    self.alllibs = self.libraries.toStringNoDupes(['-L'+os.path.join(self.petscdir.dir,self.arch.arch,'lib'), self.petsclib]+libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs)+' '+self.compilers.LIBS\n    self.PETSC_EXTERNAL_LIB_BASIC = self.libraries.toStringNoDupes(libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split())\n    if self.framework.argDB['prefix'] and self.setCompilers.CSharedLinkerFlag not in ['-L']:\n      lib_basic = self.PETSC_EXTERNAL_LIB_BASIC.replace(self.setCompilers.CSharedLinkerFlag+os.path.join(self.petscdir.dir,self.arch.arch,'lib'),self.setCompilers.CSharedLinkerFlag+os.path.join(self.installdir.dir,'lib'))\n    else:\n      lib_basic = self.PETSC_EXTERNAL_LIB_BASIC\n    self.addMakeMacro('PETSC_EXTERNAL_LIB_BASIC',lib_basic)\n    self.allincludes = self.headers.toStringNoDupes(includes)\n    self.addMakeMacro('PETSC_CC_INCLUDES',self.allincludes)\n    self.PETSC_CC_INCLUDES = self.allincludes\n    if hasattr(self.compilers, 'FC'):\n      if self.compilers.fortranIsF90:\n        self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(includes,includes))\n      else:\n        self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(includes))\n\n    self.addMakeMacro('DESTDIR',self.installdir.dir)\n    self.addDefine('LIB_DIR','\"'+os.path.join(self.installdir.dir,'lib')+'\"')\n\n    if self.framework.argDB['with-single-library']:\n      # overrides the values set in conf/variables\n      self.addMakeMacro('LIBNAME','${INSTALL_LIB_DIR}/libpetsc.${AR_LIB_SUFFIX}')\n      self.addMakeMacro('SHLIBS','libpetsc')\n      self.addMakeMacro('PETSC_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_KSP_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TS_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TAO_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_WITH_EXTERNAL_LIB',self.alllibs)\n      self.addDefine('USE_SINGLE_LIBRARY', '1')\n      if self.sharedlibraries.useShared:\n        self.addMakeMacro('PETSC_SYS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n      else:\n        self.addMakeMacro('PETSC_SYS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${PETSC_WITH_EXTERNAL_LIB}')\n\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib'))\n\n    # add a makefile entry for configure options\n    self.addMakeMacro('CONFIGURE_OPTIONS', self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"'))\n    return\n\n  def dumpConfigInfo(self):\n    import time\n    fd = file(os.path.join(self.arch.arch,'include','petscconfiginfo.h'),'w')\n    fd.write('static const char *petscconfigureoptions = \"'+self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"')+'\";\\n')\n    fd.close()\n    return\n\n  def dumpMachineInfo(self):\n    import platform\n    import time\n    import script\n    def escape(s):\n      return s.replace('\"',r'\\\"').replace(r'\\ ',r'\\\\ ')\n    fd = file(os.path.join(self.arch.arch,'include','petscmachineinfo.h'),'w')\n    fd.write('static const char *petscmachineinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"-----------------------------------------\\\\n\\\"\\n')\n    fd.write('\\\"Libraries compiled on %s on %s \\\\n\\\"\\n' % (time.ctime(time.time()), platform.node()))\n    fd.write('\\\"Machine characteristics: %s\\\\n\\\"\\n' % (platform.platform()))\n    fd.write('\\\"Using PETSc directory: %s\\\\n\\\"\\n' % (escape(self.petscdir.dir)))\n    fd.write('\\\"Using PETSc arch: %s\\\\n\\\"\\n' % (escape(self.arch.arch)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C compiler: %s %s ${COPTFLAGS} ${CFLAGS}\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran compiler: %s %s ${FOPTFLAGS} ${FFLAGS} %s\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags()), escape(self.setCompilers.CPPFLAGS)))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerflagsinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"Using include paths: %s %s %s\\\\n\\\"\\n' % ('-I'+escape(os.path.join(self.petscdir.dir, self.arch.arch, 'include')), '-I'+escape(os.path.join(self.petscdir.dir, 'include')), escape(self.PETSC_CC_INCLUDES)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsclinkerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"Using libraries: %s%s -L%s %s %s\\\\n\\\"\\n' % (escape(self.setCompilers.CSharedLinkerFlag), escape(os.path.join(self.petscdir.dir, self.arch.arch, 'lib')), escape(os.path.join(self.petscdir.dir, self.arch.arch, 'lib')), escape(self.petsclib), escape(self.PETSC_EXTERNAL_LIB_BASIC)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.close()\n    return\n\n  def dumpCMakeConfig(self):\n    '''\n    Writes configuration-specific values to ${PETSC_ARCH}/lib/petsc/conf/PETScBuildInternal.cmake.\n    This file is private to PETSc and should not be included by third parties\n    (a suitable file can be produced later by CMake, but this is not it).\n    '''\n    def cmakeset(fd,key,val=True):\n      if val == True: val = 'YES'\n      if val == False: val = 'NO'\n      fd.write('set (' + key + ' ' + val + ')\\n')\n    def ensurelist(a):\n      if isinstance(a,list):\n        return a\n      else:\n        return [a]\n    def libpath(lib):\n      'Returns a search path if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-L'): return lib[2:]\n      if lib.startswith('-R'): return lib[2:]\n      if lib.startswith('-Wl,-rpath,'):\n        # This case occurs when an external package needs a specific system library that is normally provided by the compiler.\n        # In other words, the -L path is builtin to the wrapper or compiler, here we provide it so that CMake can locate the\n        # corresponding library.\n        return lib[len('-Wl,-rpath,'):]\n      if lib.startswith('-'): return ''\n      return os.path.dirname(lib)\n    def cleanlib(lib):\n      'Returns a library name if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-l'):  return lib[2:]\n      if lib.startswith('-Wl') or lib.startswith('-L'): return ''\n      lib = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): return lib[3:]\n      return lib\n    def nub(lst):\n      'Return a list containing the first occurrence of each unique element'\n      unique = []\n      for elem in lst:\n        if elem not in unique and elem != '':\n          unique.append(elem)\n      return unique\n    try: reversed # reversed was added in Python-2.4\n    except NameError:\n      def reversed(lst): return lst[::-1]\n    def nublast(lst):\n      'Return a list containing the last occurrence of each unique entry in a list'\n      return reversed(nub(reversed(lst)))\n    def cmakeexpand(varname):\n      return r'\"${' + varname + r'}\"'\n    def uniqextend(lst,new):\n      for x in ensurelist(new):\n        if x not in lst:\n          lst.append(x)\n    def notstandardinclude(path):\n      return path not in '/usr/include'.split() # /usr/local/include is not automatically included on FreeBSD\n    def writeMacroDefinitions(fd):\n      if self.mpi.usingMPIUni:\n        cmakeset(fd,'PETSC_HAVE_MPIUNI')\n      for pkg in self.framework.packages:\n        if pkg.useddirectly:\n          cmakeset(fd,'PETSC_HAVE_' + pkg.PACKAGE.replace('-','_'))\n        for pair in pkg.defines.items():\n          if pair[0].startswith('HAVE_') and pair[1]:\n            cmakeset(fd, self.framework.getFullDefineName(pkg, pair[0]), pair[1])\n      for name,val in self.functions.defines.items():\n        cmakeset(fd,'PETSC_'+name,val)\n      for dct in [self.defines, self.libraryoptions.defines]:\n        for k,v in dct.items():\n          if k.startswith('USE_'):\n            cmakeset(fd,'PETSC_' + k, v)\n      cmakeset(fd,'PETSC_USE_COMPLEX', self.scalartypes.scalartype == 'complex')\n      cmakeset(fd,'PETSC_USE_REAL_' + self.scalartypes.precision.upper())\n      cmakeset(fd,'PETSC_CLANGUAGE_'+self.languages.clanguage)\n      if hasattr(self.compilers, 'FC'):\n        cmakeset(fd,'PETSC_HAVE_FORTRAN')\n        if self.compilers.fortranIsF90:\n          cmakeset(fd,'PETSC_USING_F90')\n        if self.compilers.fortranIsF2003:\n          cmakeset(fd,'PETSC_USING_F2003')\n      if hasattr(self.compilers, 'CXX'):\n        cmakeset(fd,'PETSC_HAVE_CXX')\n      if self.sharedlibraries.useShared:\n        cmakeset(fd,'BUILD_SHARED_LIBS')\n    def writeBuildFlags(fd):\n      def extendby(lib):\n        libs = ensurelist(lib)\n        lib_paths.extend(map(libpath,libs))\n        lib_libs.extend(map(cleanlib,libs))\n      lib_paths = []\n      lib_libs  = []\n      includes  = []\n      libvars   = []\n      for pkg in self.framework.packages:\n        if pkg.linkedbypetsc:\n          extendby(pkg.lib)\n          uniqextend(includes,pkg.include)\n      extendby(self.libraries.math)\n      extendby(self.libraries.rt)\n      extendby(self.compilers.flibs)\n      extendby(self.compilers.cxxlibs)\n      extendby(self.compilers.LIBS.split())\n      for libname in nublast(lib_libs):\n        libvar = 'PETSC_' + libname.upper() + '_LIB'\n        addpath = ''\n        for lpath in nublast(lib_paths):\n          addpath += '\"' + str(lpath) + '\" '\n        fd.write('find_library (' + libvar + ' ' + libname + ' HINTS ' + addpath + ')\\n')\n        libvars.append(libvar)\n      fd.write('mark_as_advanced (' + ' '.join(libvars) + ')\\n')\n      fd.write('set (PETSC_PACKAGE_LIBS ' + ' '.join(map(cmakeexpand,libvars)) + ')\\n')\n      includes = filter(notstandardinclude,includes)\n      fd.write('set (PETSC_PACKAGE_INCLUDES ' + ' '.join(map(lambda i: '\"'+i+'\"',includes)) + ')\\n')\n    fd = open(os.path.join(self.arch.arch,'lib','petsc','conf','PETScBuildInternal.cmake'), 'w')\n    writeMacroDefinitions(fd)\n    writeBuildFlags(fd)\n    fd.close()\n    return\n\n  def dumpCMakeLists(self):\n    import sys\n    if sys.version_info >= (2,4):\n      import cmakegen\n      try:\n        cmakegen.main(self.petscdir.dir, log=self.framework.log)\n      except (OSError), e:\n        self.framework.logPrint('Generating CMakeLists.txt failed:\\n' + str(e))\n    else:\n      self.framework.logPrint('Skipping cmakegen due to old python version: ' +str(sys.version_info) )\n\n  def cmakeBoot(self):\n    import sys\n    self.cmakeboot_success = False\n    if sys.version_info >= (2,4) and hasattr(self.cmake,'cmake'):\n      oldRead = self.argDB.readonly\n      self.argDB.readonly = True\n      try:\n        import cmakeboot\n        self.cmakeboot_success = cmakeboot.main(petscdir=self.petscdir.dir,petscarch=self.arch.arch,argDB=self.argDB,framework=self.framework,log=self.framework.log)\n      except (OSError), e:\n        self.framework.logPrint('Booting CMake in PETSC_ARCH failed:\\n' + str(e))\n      except (ImportError, KeyError), e:\n        self.framework.logPrint('Importing cmakeboot failed:\\n' + str(e))\n      self.argDB.readonly = oldRead\n      if self.cmakeboot_success:\n        if hasattr(self.compilers, 'FC') and self.compilers.fortranIsF90 and not self.setCompilers.fortranModuleOutputFlag:\n          self.framework.logPrint('CMake configured successfully, but could not be used by default because of missing fortranModuleOutputFlag\\n')\n        else:\n          self.framework.logPrint('CMake configured successfully, using as default build\\n')\n          self.addMakeMacro('PETSC_BUILD_USING_CMAKE',1)\n      else:\n        self.framework.logPrint('CMake configuration was unsuccessful\\n')\n    else:\n      self.framework.logPrint('Skipping cmakeboot due to old python version: ' +str(sys.version_info) )\n    return\n\n  def configurePrefetch(self):\n    '''Sees if there are any prefetch functions supported'''\n    if config.setCompilers.Configure.isSolaris(self.log) or self.framework.argDB['with-ios'] or not self.framework.argDB['with-prefetch']:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch((const char*)v,_MM_HINT_NTA);\\n'):\n      # The Intel Intrinsics manual [1] specifies the prototype\n      #\n      #   void _mm_prefetch(char const *a, int sel);\n      #\n      # but other vendors seem to insist on using subtly different\n      # prototypes, including void* for the pointer, and an enum for\n      # sel.  These are both reasonable changes, but negatively impact\n      # portability.\n      #\n      # [1] http://software.intel.com/file/6373\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const char*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch(v,_MM_HINT_NTA);\\n'):\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const void*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('', 'void *v = 0;__builtin_prefetch(v,0,0);\\n'):\n      # From GCC docs: void __builtin_prefetch(const void *addr,int rw,int locality)\n      #\n      #   The value of rw is a compile-time constant one or zero; one\n      #   means that the prefetch is preparing for a write to the memory\n      #   address and zero, the default, means that the prefetch is\n      #   preparing for a read. The value locality must be a compile-time\n      #   constant integer between zero and three. A value of zero means\n      #   that the data has no temporal locality, so it need not be left\n      #   in the cache after the access. A value of three means that the\n      #   data has a high degree of temporal locality and should be left\n      #   in all levels of cache possible. Values of one and two mean,\n      #   respectively, a low or moderate degree of temporal locality.\n      #\n      # Here we adopt Intel's x86/x86-64 naming scheme for the locality\n      # hints.  Using macros for these values in necessary since some\n      # compilers require an enum.\n      self.addDefine('Prefetch(a,b,c)', '__builtin_prefetch((a),(b),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '0')\n      self.addDefine('PREFETCH_HINT_T0',  '3')\n      self.addDefine('PREFETCH_HINT_T1',  '2')\n      self.addDefine('PREFETCH_HINT_T2',  '1')\n    else:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n    self.popLanguage()\n\n  def configureAtoll(self):\n    '''Checks if atoll exists'''\n    if self.checkLink('#define _POSIX_C_SOURCE 200112L\\n#include <stdlib.h>','long v = atoll(\"25\")') or self.checkLink ('#include <stdlib.h>','long v = atoll(\"25\")'):\n       self.addDefine('HAVE_ATOLL', '1')\n\n  def configureUnused(self):\n    '''Sees if __attribute((unused)) is supported'''\n    if self.framework.argDB['with-ios']:\n      self.addDefine('UNUSED', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('__attribute((unused)) static int myfunc(__attribute((unused)) void *name){ return 1;}', 'int i = 0;\\nint j = myfunc(&i);\\ntypedef void* atype;\\n__attribute((unused))  atype a;\\n'):\n      self.addDefine('UNUSED', '__attribute((unused))')\n    else:\n      self.addDefine('UNUSED', ' ')\n    self.popLanguage()\n\n  def configureIsatty(self):\n    '''Check if the Unix C function isatty() works correctly\n       Actually just assumes it does not work correctly on batch systems'''\n    if not self.framework.argDB['with-batch']:\n      self.addDefine('USE_ISATTY',1)\n\n  def configureDeprecated(self):\n    '''Check if __attribute((deprecated)) is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    ## Recent versions of gcc and clang support __attribute((deprecated(\"string argument\"))), which is very useful, but\n    ## Intel has conspired to make a supremely environment-sensitive compiler.  The Intel compiler looks at the gcc\n    ## executable in the environment to determine the language compatibility that it should attempt to emulate.  Some\n    ## important Cray installations have built PETSc using the Intel compiler, but with a newer gcc module loaded (e.g.,\n    ## 4.7).  Thus at PETSc configure time, the Intel compiler decides to support the string argument, but the gcc\n    ## found in the default user environment is older and does not support the argument.  If GCC and Intel were cool\n    ## like Clang and supported __has_attribute, we could avoid configure tests entirely, but they don't.  And that is\n    ## why we can't have nice things.\n    #\n    # if self.checkCompile(\"\"\"__attribute((deprecated(\"Why you shouldn't use myfunc\"))) static int myfunc(void) { return 1;}\"\"\", ''):\n    #   self.addDefine('DEPRECATED(why)', '__attribute((deprecated(why)))')\n    if self.checkCompile(\"\"\"__attribute((deprecated)) static int myfunc(void) { return 1;}\"\"\", ''):\n      self.addDefine('DEPRECATED(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED(why)', ' ')\n    self.popLanguage()\n\n  def configureAlign(self):\n    '''Check if __attribute(align) is supported'''\n    filename = 'conftestalign'\n    includes = '''\n#include <sys/types.h>\n#if STDC_HEADERS\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#endif\\n'''\n    body     = '''\nstruct mystruct {int myint;} __attribute((aligned(16)));\nFILE *f = fopen(\"'''+filename+'''\", \"w\");\nif (!f) exit(1);\nfprintf(f, \"%lu\\\\n\", (unsigned long)sizeof(struct mystruct));\n'''\n    if 'known-has-attribute-aligned' in self.argDB:\n      if self.argDB['known-has-attribute-aligned']:\n        size = 16\n      else:\n        size = -3\n    elif not self.argDB['with-batch']:\n      self.pushLanguage(self.languages.clanguage)\n      try:\n        if self.checkRun(includes, body) and os.path.exists(filename):\n          f    = file(filename)\n          size = int(f.read())\n          f.close()\n          os.remove(filename)\n        else:\n          size = -4\n      except:\n        size = -1\n        self.framework.logPrint('Error checking attribute(aligned)')\n      self.popLanguage()\n    else:\n      self.framework.addBatchInclude(['#include <stdlib.h>', '#include <stdio.h>', '#include <sys/types.h>','struct mystruct {int myint;} __attribute((aligned(16)));'])\n      self.framework.addBatchBody('fprintf(output, \"  \\'--known-has-attribute-aligned=%d\\',\\\\n\", sizeof(struct mystruct)==16);')\n      size = -2\n    if size == 16:\n      self.addDefine('ATTRIBUTEALIGNED(size)', '__attribute((aligned (size)))')\n      self.addDefine('HAVE_ATTRIBUTEALIGNED', 1)\n    else:\n      self.framework.logPrint('incorrect alignment. Found alignment:'+ str(size))\n      self.addDefine('ATTRIBUTEALIGNED(size)', ' ')\n    return\n\n  def configureExpect(self):\n    '''Sees if the __builtin_expect directive is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('', 'if (__builtin_expect(0,1)) return 1;'):\n      self.addDefine('HAVE_BUILTIN_EXPECT', 1)\n    self.popLanguage()\n\n  def configureFunctionName(self):\n    '''Sees if the compiler supports __func__ or a variant.  Falls back\n    on __FUNCT__ which PETSc source defines, but most users do not, thus\n    stack traces through user code are better when the compiler's\n    variant is used.'''\n    def getFunctionName(lang):\n      name = '__FUNCT__'\n      self.pushLanguage(lang)\n      if self.checkLink('', \"if (__func__[0] != 'm') return 1;\"):\n        name = '__func__'\n      elif self.checkLink('', \"if (__FUNCTION__[0] != 'm') return 1;\"):\n        name = '__FUNCTION__'\n      self.popLanguage()\n      return name\n    langs = []\n\n    self.addDefine('FUNCTION_NAME_C', getFunctionName('C'))\n    if hasattr(self.compilers, 'CXX'):\n      self.addDefine('FUNCTION_NAME_CXX', getFunctionName('Cxx'))\n    else:\n      self.addDefine('FUNCTION_NAME_CXX', '__FUNCT__')\n\n  def configureIntptrt(self):\n    '''Determine what to use for uintptr_t'''\n    def staticAssertSizeMatchesVoidStar(inc,typename):\n      # The declaration is an error if either array size is negative.\n      # It should be okay to use an int that is too large, but it would be very unlikely for this to be the case\n      return self.checkCompile(inc, ('#define STATIC_ASSERT(cond) char negative_length_if_false[2*(!!(cond))-1]\\n'\n                                     + 'STATIC_ASSERT(sizeof(void*) == sizeof(%s));'%typename))\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile('#include <stdint.h>', 'int x; uintptr_t i = (uintptr_t)&x;'):\n      self.addDefine('UINTPTR_T', 'uintptr_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long long'):\n      self.addDefine('UINTPTR_T', 'unsigned long long')\n    elif staticAssertSizeMatchesVoidStar('#include <stdlib.h>','size_t') or staticAssertSizeMatchesVoidStar('#include <string.h>', 'size_t'):\n      self.addDefine('UINTPTR_T', 'size_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long'):\n      self.addDefine('UINTPTR_T', 'unsigned long')\n    elif staticAssertSizeMatchesVoidStar('','unsigned'):\n      self.addDefine('UINTPTR_T', 'unsigned')\n    else:\n      raise RuntimeError('Could not find any unsigned integer type matching void*')\n    self.popLanguage()\n\n  def configureRTLDDefault(self):\n    if self.checkCompile('#include <dlfcn.h>\\n void *ptr =  RTLD_DEFAULT;'):\n      self.addDefine('RTLD_DEFAULT','1')\n    return\n\n  def configureSolaris(self):\n    '''Solaris specific stuff'''\n    if os.path.isdir(os.path.join('/usr','ucblib')):\n      try:\n        flag = getattr(self.setCompilers, self.language[-1]+'SharedLinkerFlag')\n      except AttributeError:\n        flag = None\n      if flag is None:\n        self.compilers.LIBS += ' -L/usr/ucblib'\n      else:\n        self.compilers.LIBS += ' '+flag+'/usr/ucblib'\n    return\n\n  def configureLinux(self):\n    '''Linux specific stuff'''\n    # TODO: Test for this by mallocing an odd number of floats and checking the address\n    self.addDefine('HAVE_DOUBLE_ALIGN_MALLOC', 1)\n    return\n\n  def configureWin32(self):\n    '''Win32 non-cygwin specific stuff'''\n    kernel32=0\n    if self.libraries.add('Kernel32.lib','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    elif self.libraries.add('kernel32','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    if kernel32:\n      if self.framework.argDB['with-windows-graphics']:\n        self.addDefine('USE_WINDOWS_GRAPHICS',1)\n      if self.checkLink('#include <Windows.h>','LoadLibrary(0)'):\n        self.addDefine('HAVE_LOADLIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetProcAddress(0,0)'):\n        self.addDefine('HAVE_GETPROCADDRESS',1)\n      if self.checkLink('#include <Windows.h>','FreeLibrary(0)'):\n        self.addDefine('HAVE_FREELIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetLastError()'):\n        self.addDefine('HAVE_GETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>','SetLastError(0)'):\n        self.addDefine('HAVE_SETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>\\n','QueryPerformanceCounter(0);\\n'):\n        self.addDefine('USE_MICROSOFT_TIME',1)\n    if self.libraries.add('Advapi32.lib','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n    elif self.libraries.add('advapi32','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n\n    if not self.libraries.add('User32.lib','GetDC',prototype='#include <Windows.h>',call='GetDC(0);'):\n      self.libraries.add('user32','GetDC',prototype='#include <Windows.h>',call='GetDC(0);')\n    if not self.libraries.add('Gdi32.lib','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);'):\n      self.libraries.add('gdi32','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);')\n\n    self.types.check('int32_t', 'int')\n    if not self.checkCompile('#include <sys/types.h>\\n','uid_t u;\\n'):\n      self.addTypedef('int', 'uid_t')\n      self.addTypedef('int', 'gid_t')\n    if not self.checkLink('#if defined(PETSC_HAVE_UNISTD_H)\\n#include <unistd.h>\\n#endif\\n','int a=R_OK;\\n'):\n      self.framework.addDefine('R_OK', '04')\n      self.framework.addDefine('W_OK', '02')\n      self.framework.addDefine('X_OK', '01')\n    if not self.checkLink('#include <sys/stat.h>\\n','int a=0;\\nif (S_ISDIR(a)){}\\n'):\n      self.framework.addDefine('S_ISREG(a)', '(((a)&_S_IFMT) == _S_IFREG)')\n      self.framework.addDefine('S_ISDIR(a)', '(((a)&_S_IFMT) == _S_IFDIR)')\n    if self.checkCompile('#include <Windows.h>\\n','LARGE_INTEGER a;\\nDWORD b=a.u.HighPart;\\n'):\n      self.addDefine('HAVE_LARGE_INTEGER_U',1)\n\n    # Windows requires a Binary file creation flag when creating/opening binary files.  Is a better test in order?\n    if self.checkCompile('#include <Windows.h>\\n#include <fcntl.h>\\n', 'int flags = O_BINARY;'):\n      self.addDefine('HAVE_O_BINARY',1)\n\n    if self.compilers.CC.find('win32fe') >= 0:\n      self.addDefine('PATH_SEPARATOR','\\';\\'')\n      self.addDefine('DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('CANNOT_START_DEBUGGER',1)\n      (petscdir,error,status) = self.executeShellCommand('cygpath -w '+self.petscdir.dir, log = self.log)\n      self.addDefine('DIR','\"'+petscdir.replace('\\\\','\\\\\\\\')+'\"')\n    else:\n      self.addDefine('PATH_SEPARATOR','\\':\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('DIR', '\"'+self.petscdir.dir+'\"')\n\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureCygwinBrokenPipe(self):\n    '''Cygwin version <= 1.7.18 had issues with pipes and long commands invoked from gnu-make\n    http://cygwin.com/ml/cygwin/2013-05/msg00340.html '''\n    if config.setCompilers.Configure.isCygwin(self.log):\n      import platform\n      import re\n      r=re.compile(\"([0-9]+).([0-9]+).([0-9]+)\")\n      m=r.match(platform.release())\n      major=int(m.group(1))\n      minor=int(m.group(2))\n      subminor=int(m.group(3))\n      if ((major < 1) or (major == 1 and minor < 7) or (major == 1 and minor == 7 and subminor <= 18)):\n        self.addMakeMacro('PETSC_CYGWIN_BROKEN_PIPE','1')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureDefaultArch(self):\n    conffile = os.path.join('lib','petsc','conf', 'petscvariables')\n    if self.framework.argDB['with-default-arch']:\n      fd = file(conffile, 'w')\n      fd.write('PETSC_ARCH='+self.arch.arch+'\\n')\n      fd.write('PETSC_DIR='+self.petscdir.dir+'\\n')\n      fd.write('include '+os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','petscvariables')+'\\n')\n      fd.close()\n      self.framework.actions.addArgument('PETSc', 'Build', 'Set default architecture to '+self.arch.arch+' in '+conffile)\n    elif os.path.isfile(conffile):\n      try:\n        os.unlink(conffile)\n      except:\n        raise RuntimeError('Unable to remove file '+conffile+'. Did a different user create it?')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureScript(self):\n    '''Output a script in the conf directory which will reproduce the configuration'''\n    import nargs\n    import sys\n    scriptName = os.path.join(self.arch.arch,'lib','petsc','conf', 'reconfigure-'+self.arch.arch+'.py')\n    args = dict([(nargs.Arg.parseArgument(arg)[0], arg) for arg in self.framework.clArgs])\n    if 'with-clean' in args:\n      del args['with-clean']\n    if 'configModules' in args:\n      if nargs.Arg.parseArgument(args['configModules'])[1] == 'PETSc.Configure':\n        del args['configModules']\n    if 'optionsModule' in args:\n      if nargs.Arg.parseArgument(args['optionsModule'])[1] == 'config.compilerOptions':\n        del args['optionsModule']\n    if not 'PETSC_ARCH' in args:\n      args['PETSC_ARCH'] = 'PETSC_ARCH='+str(self.arch.arch)\n    f = file(scriptName, 'w')\n    f.write('#!'+sys.executable+'\\n')\n    f.write('if __name__ == \\'__main__\\':\\n')\n    f.write('  import sys\\n')\n    f.write('  import os\\n')\n    f.write('  sys.path.insert(0, os.path.abspath(\\'config\\'))\\n')\n    f.write('  import configure\\n')\n    # pretty print repr(args.values())\n    f.write('  configure_options = [\\n')\n    for itm in sorted(args.values()):\n      f.write('    \\''+str(itm)+'\\',\\n')\n    f.write('  ]\\n')\n    f.write('  configure.petsc_configure(configure_options)\\n')\n    f.close()\n    try:\n      os.chmod(scriptName, 0775)\n    except OSError, e:\n      self.framework.logPrint('Unable to make reconfigure script executable:\\n'+str(e))\n    self.framework.actions.addArgument('PETSc', 'File creation', 'Created '+scriptName+' for automatic reconfiguration')\n    return\n\n  def configureInstall(self):\n    '''Setup the directories for installation'''\n    if self.framework.argDB['prefix']:\n      self.addMakeRule('shared_install','',['-@echo \"Now to install the libraries do:\"',\\\n                                              '-@echo \"'+self.installdir.installSudo+'make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} install\"',\\\n                                              '-@echo \"=========================================\"'])\n    else:\n      self.addMakeRule('shared_install','',['-@echo \"Now to check if the libraries are working do:\"',\\\n                                              '-@echo \"make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} test\"',\\\n                                              '-@echo \"=========================================\"'])\n      return\n\n  def configureGCOV(self):\n    if self.framework.argDB['with-gcov']:\n      self.addDefine('USE_GCOV','1')\n    return\n\n  def configureFortranFlush(self):\n    if hasattr(self.compilers, 'FC'):\n      for baseName in ['flush','flush_']:\n        if self.libraries.check('', baseName, otherLibs = self.compilers.flibs, fortranMangle = 1):\n          self.addDefine('HAVE_'+baseName.upper(), 1)\n          return\n\n  def configureViewFromOptions(self):\n    if not self.framework.argDB['with-viewfromoptions']:\n      self.addDefine('SKIP_VIEWFROMOPTIONS',1)\n\n  def postProcessPackages(self):\n    postPackages=[]\n    for i in self.framework.packages:\n      if hasattr(i,'postProcess'): postPackages.append(i)\n    if postPackages:\n      # ctetgen needs petsc conf files. so attempt to create them early\n      self.framework.dumpConfFiles()\n      # tacky fix for dependency of Aluimia on Pflotran; requested via petsc-dev Matt provide a correct fix\n      for i in postPackages:\n        if i.name.upper() in ['PFLOTRAN']:\n          i.postProcess()\n          postPackages.remove(i)\n      for i in postPackages: i.postProcess()\n      for i in postPackages:\n        if i.installedpetsc:\n          self.installed = 1\n          break\n    return\n\n  def configure(self):\n    if not os.path.samefile(self.petscdir.dir, os.getcwd()):\n      raise RuntimeError('Wrong PETSC_DIR option specified: '+str(self.petscdir.dir) + '\\n  Configure invoked in: '+os.path.realpath(os.getcwd()))\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],self.petscdir.dir):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR!')\n    if self.framework.argDB['prefix'] and self.framework.argDB['prefix'].find(' ') > -1:\n      raise RuntimeError('Your --prefix '+self.framework.argDB['prefix']+' has spaces in it; this is not allowed.\\n Use a --prefix that does not have spaces in it')\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],os.path.join(self.petscdir.dir,self.arch.arch)):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR/PETSC_ARCH!')\n    self.framework.header          = os.path.join(self.arch.arch,'include','petscconf.h')\n    self.framework.cHeader         = os.path.join(self.arch.arch,'include','petscfix.h')\n    self.framework.makeMacroHeader = os.path.join(self.arch.arch,'lib','petsc','conf','petscvariables')\n    self.framework.makeRuleHeader  = os.path.join(self.arch.arch,'lib','petsc','conf','petscrules')\n    if self.libraries.math is None:\n      raise RuntimeError('PETSc requires a functional math library. Please send configure.log to petsc-maint@mcs.anl.gov.')\n    if self.languages.clanguage == 'Cxx' and not hasattr(self.compilers, 'CXX'):\n      raise RuntimeError('Cannot set C language to C++ without a functional C++ compiler.')\n    self.executeTest(self.configureRTLDDefault)\n    self.executeTest(self.configurePrefetch)\n    self.executeTest(self.configureUnused)\n    self.executeTest(self.configureDeprecated)\n    self.executeTest(self.configureIsatty)\n    self.executeTest(self.configureExpect);\n    self.executeTest(self.configureAlign);\n    self.executeTest(self.configureFunctionName);\n    self.executeTest(self.configureIntptrt);\n    self.executeTest(self.configureSolaris)\n    self.executeTest(self.configureLinux)\n    self.executeTest(self.configureWin32)\n    self.executeTest(self.configureCygwinBrokenPipe)\n    self.executeTest(self.configureDefaultArch)\n    self.executeTest(self.configureScript)\n    self.executeTest(self.configureInstall)\n    self.executeTest(self.configureGCOV)\n    self.executeTest(self.configureFortranFlush)\n    self.executeTest(self.configureAtoll)\n    self.executeTest(self.configureViewFromOptions)\n    # dummy rules, always needed except for remote builds\n    self.addMakeRule('remote','')\n    self.addMakeRule('remoteclean','')\n\n    self.Dump()\n    self.dumpConfigInfo()\n    self.dumpMachineInfo()\n    self.dumpCMakeConfig()\n    self.dumpCMakeLists()\n    # need to save the current state of BuildSystem so that postProcess() packages can read it in and perhaps run make install\n    self.framework.storeSubstitutions(self.framework.argDB)\n    self.framework.argDB['configureCache'] = cPickle.dumps(self.framework)\n    self.framework.argDB.save(force = True)\n    self.cmakeBoot()\n    self.DumpPkgconfig()\n    self.DumpModule()\n    self.postProcessPackages()\n    self.framework.log.write('================================================================================\\n')\n    self.logClear()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/config/BuildSystem/config/libraries.py": "import config.base\n\nimport os\nimport re\n\ntry:\n  enumerate([0, 1])\nexcept NameError:\n  def enumerate(l):\n    return zip(range(len(l)), l)\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework, libraries = []):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.libraries    = libraries\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilers    = framework.require('config.compilers',    self)\n    self.headers      = framework.require('config.headers',      self)\n    return\n\n  def getLibArgumentList(self, library, with_rpath=True):\n    '''Return the proper link line argument for the given filename library as a list of options\n      - If the path is empty, return it unchanged\n      - If starts with - then return unchanged\n      - If the path ends in \".lib\" return it unchanged\n      - If the path is absolute and the filename is \"lib\"<name>, return -L<dir> -l<name> (optionally including rpath flag)\n      - If the filename is \"lib\"<name>, return -l<name>\n      - If the path ends in \".so\" return it unchanged\n      - If the path is absolute, return it unchanged\n      - Otherwise return -l<library>'''\n    if not library:\n      return []\n    if library.startswith('${CC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.startswith('${FC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.lstrip()[0] == '-':\n      return [library]\n    if len(library) > 3 and library[-4:] == '.lib':\n      return [library.replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')]\n    if os.path.basename(library).startswith('lib'):\n      name = self.getLibName(library)\n      if ((len(library) > 2 and library[1] == ':') or os.path.isabs(library)):\n        flagName  = self.language[-1]+'SharedLinkerFlag'\n        flagSubst = self.language[-1].upper()+'_LINKER_SLFLAG'\n        dirname   = os.path.dirname(library).replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')\n        if dirname.startswith('/Applications/Xcode.app') or dirname.startswith('/Library/Developer/CommandLineTools/usr/lib'): with_rpath = None\n        if with_rpath:\n          if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n            return [getattr(self.setCompilers, flagName)+dirname,'-L'+dirname,'-l'+name]\n          if flagSubst in self.argDB:\n            return [self.argDB[flagSubst]+dirname,'-L'+dirname,'-l'+name]\n        return ['-L'+dirname,' -l'+name]\n      else:\n        return ['-l'+name]\n    if os.path.splitext(library)[1] == '.so':\n      return [library]\n    if os.path.isabs(library):\n      return [library]\n    return ['-l'+library]\n\n  def getLibArgument(self, library):\n    '''Same as getLibArgumentList - except it returns a string instead of list.'''\n    return  ' '.join(self.getLibArgumentList(library))\n\n  def getLibName(library):\n    if os.path.basename(library).startswith('lib'):\n      return os.path.splitext(os.path.basename(library))[0][3:]\n    return library\n  getLibName = staticmethod(getLibName)\n\n  def getDefineName(self, library):\n    return 'HAVE_LIB'+self.getLibName(library).upper().replace('-','_').replace('=','_').replace('+','_').replace('.', '_').replace('/','_')\n\n  def haveLib(self, library):\n    return self.getDefineName(library) in self.defines\n\n  def add(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName AND adds it to $LIBS\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(libName, list): libName = [libName]\n    if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle):\n      self.logPrint('Adding '+str(libName)+' to LIBS')\n      # Note: this MUST be setCompilers since it can happen before dispatch names is made\n      self.setCompilers.LIBS = self.toString(libName)+' '+self.setCompilers.LIBS\n      return 1\n    return 0\n\n  def toString(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    return ' '.join(newlibs)\n\n  def toStringNoDupes(self,libs,with_rpath=True):\n    '''Converts a list of libraries to a string suitable for a linker, removes duplicates'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib, with_rpath)\n    libs = newlibs\n    newldflags = []\n    newlibs = []\n    frame = 0\n    for j in libs:\n      # do not remove duplicate non-consecutive -l, because there is a tiny chance that order may matter\n      if frame:\n        newlibs.append(j)\n        frame = 0\n        continue\n      if j in newldflags: continue\n      if newlibs and j == newlibs[-1]: continue\n      if j.startswith('-l'):\n        newlibs.append(j)\n      elif j == '-framework':\n        newlibs.append(j)\n        frame = 1\n      else:\n        newldflags.append(j)\n    return ' '.join(newldflags + newlibs)\n\n  def getShortLibName(self,lib):\n    '''returns the short name for the library. Valid names are foo -lfoo or libfoo.[a,so,lib]'''\n    if lib.startswith('-l'):\n      libname = lib[2:]\n      return libname\n    if lib.startswith('-'): # must be some compiler options - not a library\n      return ''\n    if lib.endswith('.a') or lib.endswith('.so') or lib.endswith('.lib'):\n      libname = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): libname = libname[3:]\n      return libname\n    # no match - assuming the given name is already in short notation\n    return lib\n\n  def check(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0, cxxMangle = 0, cxxLink = 0, examineOutput=lambda ret,out,err:None):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(funcs,list): funcs = [funcs]\n    if not isinstance(libName, list): libName = [libName]\n    def genPreamble(f, funcName):\n      # Construct prototype\n      if self.language[-1] == 'FC':\n        return ''\n      if prototype:\n        if isinstance(prototype, str):\n          pre = prototype\n        else:\n          pre = prototype[f]\n      else:\n        # We use char because int might match the return type of a gcc2 builtin and its argument prototype would still apply.\n        pre = 'char '+funcName+'();'\n      # Capture the function call in a static function so that any local variables are isolated from\n      # calls to other library functions.\n      return pre + '\\nstatic void _check_%s() { %s }' % (funcName, genCall(f, funcName, pre=True))\n    def genCall(f, funcName, pre=False):\n      if self.language[-1] != 'FC' and not pre:\n        return '_check_' + fname + '();'\n      # Construct function call\n      if call:\n        if isinstance(call, str):\n          body = call\n        else:\n          body = call[f]\n      else:\n        body = funcName+'()'\n      if self.language[-1] != 'FC':\n        body += ';'\n      return body\n    # Handle Fortran mangling\n    if fortranMangle:\n      funcs = map(self.compilers.mangleFortranFunction, funcs)\n    if not funcs:\n      self.logPrint('No functions to check for in library '+str(libName)+' '+str(otherLibs))\n      return True\n    self.logPrint('Checking for functions ['+' '.join(funcs)+'] in library '+str(libName)+' '+str(otherLibs))\n    if self.language[-1] == 'FC':\n      includes = ''\n    else:\n      includes = '/* Override any gcc2 internal prototype to avoid an error. */\\n'\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n'''\n    includes += '\\n'.join([genPreamble(f, fname) for f, fname in enumerate(funcs)])\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\n}\n#endif\n'''\n    body = '\\n'.join([genCall(f, fname) for f, fname in enumerate(funcs)])\n    # Setup link line\n    oldLibs = self.setCompilers.LIBS\n    if libDir:\n      if not isinstance(libDir, list): libDir = [libDir]\n      for dir in libDir:\n        self.setCompilers.LIBS += ' -L'+dir\n    # new libs may/will depend on system libs so list new libs first!\n    # Matt, do not change this without talking to me\n    if libName and otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(libName+otherLibs) +' '+ self.setCompilers.LIBS\n    elif otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(otherLibs) +' '+ self.setCompilers.LIBS\n    elif libName:\n      self.setCompilers.LIBS = ' '+self.toString(libName) +' '+ self.setCompilers.LIBS\n    if cxxMangle: compileLang = 'Cxx'\n    else:         compileLang = self.language[-1]\n    if cxxLink: linklang = 'Cxx'\n    else: linklang = self.language[-1]\n    self.pushLanguage(compileLang)\n    found = 0\n    if self.checkLink(includes, body, linkLanguage=linklang, examineOutput=examineOutput):\n      found = 1\n      # add to list of found libraries\n      if libName:\n        for lib in libName:\n          shortlib = self.getShortLibName(lib)\n          if shortlib: self.addDefine(self.getDefineName(shortlib), 1)\n    self.setCompilers.LIBS = oldLibs\n    self.popLanguage()\n    return found\n\n  def checkClassify(self, libName, funcs, libDir=None, otherLibs=[], prototype='', call='', fortranMangle=0, cxxMangle=0, cxxLink=0):\n    '''Recursive decompose to rapidly classify functions as found or missing'''\n    import config\n    def functional(funcs):\n      named = config.NamedInStderr(funcs)\n      if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle, cxxMangle, cxxLink):\n        return True\n      else:\n        return named.named\n    found, missing = config.classify(funcs, functional)\n    return found, missing\n\n  def checkMath(self):\n    '''Check for sin() in libm, the math library'''\n    self.math = None\n    funcs = ['sin', 'floor', 'log10', 'pow']\n    prototypes = ['double sin(double);', 'double floor(double);', 'double log10(double);', 'double pow(double, double);']\n    calls = ['double x = 0,y; y = sin(x);\\n', 'double x = 0,y; y = floor(x);\\n', 'double x = 0,y; y = log10(x);\\n', 'double x = 0,y ; y = pow(x, x);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Math functions are linked in by default')\n      self.math = []\n    elif self.check('m', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using libm for the math library')\n      self.math = ['libm.a']\n    else:\n      self.logPrint('Warning: No math library found')\n    return\n\n  def checkMathErf(self):\n    '''Check for erf() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['erf'], prototype = ['double erf(double);'], call = ['double x = 0,y; y = erf(x);\\n']):\n      self.logPrint('erf() found')\n      self.addDefine('HAVE_ERF', 1)\n    else:\n      self.logPrint('Warning: erf() not found')\n    return\n\n  def checkMathTgamma(self):\n    '''Check for tgama() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['tgamma'], prototype = ['double tgamma(double);'], call = ['double x = 0,y; y = tgamma(x);\\n']):\n      self.logPrint('tgamma() found')\n      self.addDefine('HAVE_TGAMMA', 1)\n    else:\n      self.logPrint('Warning: tgamma() not found')\n    return\n\n  def checkMathFenv(self):\n    '''Checks if <fenv.h> can be used with FE_DFL_ENV'''\n    if not self.math is None and self.check(self.math, ['fesetenv'], prototype = ['#include <fenv.h>'], call = ['fesetenv(FE_DFL_ENV);']):\n      self.addDefine('HAVE_FENV_H', 1)\n    else:\n      self.logPrint('Warning: <fenv.h> with FE_DFL_ENV not found')\n    return\n\n  def checkMathLog2(self):\n    '''Check for log2() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['log2'], prototype = ['double log2(double);'], call = ['double x = 1,y; y = log2(x);\\n']):\n      self.logPrint('log2() found')\n      self.addDefine('HAVE_LOG2', 1)\n    else:\n      self.logPrint('Warning: log2() not found')\n    return\n\n  def checkCompression(self):\n    '''Check for libz, the compression library'''\n    self.compression = None\n    funcs = ['compress', 'uncompress']\n    prototypes = ['int   compress(char *dest, unsigned long *destLen, const char *source, unsigned long sourceLen);',\n                  'int uncompress(char *dest, unsigned long *destLen, const char *source, unsigned long sourceLen);']\n    calls = ['char *dest = 0; const char *source = 0; unsigned long destLen = 0, sourceLen = 0; int ret = 0; ret =   compress(dest, &destLen, source, sourceLen);\\n',\n             'char *dest = 0; const char *source = 0; unsigned long destLen = 0, sourceLen = 0; int ret = 0; ret = uncompress(dest, &destLen, source, sourceLen);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Compression functions are linked in by default')\n      self.compression = []\n    elif self.check('z', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using libz for the compression library')\n      self.compression = ['libz.a']\n    elif self.check('zlib.lib', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using zlib.lib for the compression library')\n      self.compression = ['zlib.lib']\n    else:\n      self.logPrint('Warning: No compression library found')\n    return\n\n  def checkRealtime(self):\n    '''Check for presence of clock_gettime() in realtime library (POSIX Realtime extensions)'''\n    self.rt = None\n    funcs = ['clock_gettime']\n    prototypes = ['#include <time.h>']\n    calls = ['struct timespec tp; clock_gettime(CLOCK_REALTIME,&tp);']\n    if self.check('', funcs, prototype=prototypes, call=calls):\n      self.logPrint('realtime functions are linked in by default')\n      self.rt = []\n    elif self.check('rt', funcs, prototype=prototypes, call=calls):\n      self.logPrint('Using librt for the realtime library')\n      self.rt = ['librt.a']\n    else:\n      self.logPrint('Warning: No realtime library found')\n    return\n\n  def checkDynamic(self):\n    '''Check for the header and libraries necessary for dynamic library manipulation'''\n    if 'with-dynamic-loading' in self.argDB and not self.argDB['with-dynamic-loading']: return\n    self.check(['dl'], 'dlopen')\n    self.headers.check('dlfcn.h')\n    return\n\n  def checkShared(self, includes, initFunction, checkFunction, finiFunction = None, checkLink = None, libraries = [], initArgs = '&argc, &argv', boolType = 'int', noCheckArg = 0, defaultArg = '', executor = None):\n    '''Determine whether a library is shared\n       - initFunction(int *argc, char *argv[]) is called to initialize some static data\n       - checkFunction(int *check) is called to verify that the static data wer set properly\n       - finiFunction() is called to finalize the data, and may be omitted\n       - checkLink may be given as ana alternative to the one in base.Configure'''\n    isShared = 0\n    if checkLink is None:\n      checkLink = self.checkLink\n      configObj = self\n    else:\n      if hasattr(checkLink, 'im_self'):\n        configObj = checkLink.im_self\n      else:\n        configObj = self\n\n    # Fix these flags\n    oldFlags = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '+self.toString(libraries)+' '+self.setCompilers.LIBS\n\n    # Make a library which calls initFunction(), and returns checkFunction()\n    lib1Name = os.path.join(self.tmpDir, 'lib1.'+self.setCompilers.sharedLibraryExt)\n    if noCheckArg:\n      checkCode = 'isInitialized = '+checkFunction+'();'\n    else:\n      checkCode = checkFunction+'(&isInitialized);'\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint init(int argc,  char *argv[]) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s(%s);\n  %s\n  return (int) isInitialized;\n''' % (boolType, initFunction, initArgs, checkCode)\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib1Name)\n\n    # Make a library which calls checkFunction()\n    lib2Name = os.path.join(self.tmpDir, 'lib2.'+self.setCompilers.sharedLibraryExt)\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint checkInit(void) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s\n''' % (boolType, checkCode)\n    if finiFunction:\n      body += '  if (isInitialized) '+finiFunction+'();\\n'\n    body += '  return (int) isInitialized;\\n'\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n      return 0\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib2Name)\n\n    self.setCompilers.LIBS = oldFlags\n\n    # Make an executable that dynamically loads and calls both libraries\n    #   If the check returns true in the second library, the static data was shared\n    guard = self.headers.getDefineName('dlfcn.h')\n    if self.headers.headerPrefix:\n      guard = self.headers.headerPrefix+'_'+guard\n    defaultIncludes = '''\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef %s\n#include <dlfcn.h>\n#endif\n    ''' % guard\n    body = '''\n  int   argc    = 1;\n  char *argv[2] = {(char *) \"conftest\", NULL};\n  void *lib;\n  int (*init)(int, char **);\n  int (*checkInit)(void);\n\n  lib = dlopen(\"'''+lib1Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib1.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  init = (int (*)(int, char **)) dlsym(lib, \"init\");\n  if (!init) {\n    fprintf(stderr, \"Could not find initialization function\\\\n\");\n    exit(1);\n  }\n  if (!(*init)(argc, argv)) {\n    fprintf(stderr, \"Could not initialize library\\\\n\");\n    exit(1);\n  }\n  lib = dlopen(\"'''+lib2Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib2.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  checkInit = (int (*)(void)) dlsym(lib, \"checkInit\");\n  if (!checkInit) {\n    fprintf(stderr, \"Could not find initialization check function\\\\n\");\n    exit(1);\n  }\n  if (!(*checkInit)()) {\n    fprintf(stderr, \"Did not link with shared library\\\\n\");\n    exit(2);\n  }\n  '''\n    oldLibs = self.setCompilers.LIBS\n    if self.haveLib('dl'):\n      self.setCompilers.LIBS += ' -ldl'\n    if self.checkRun(defaultIncludes, body, defaultArg = defaultArg, executor = executor):\n      isShared = 1\n    self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(lib1Name) and self.framework.doCleanup: os.remove(lib1Name)\n    if os.path.isfile(lib2Name) and self.framework.doCleanup: os.remove(lib2Name)\n    if isShared:\n      self.logPrint('Library was shared')\n    else:\n      self.logPrint('Library was not shared')\n    return isShared\n\n  def isBGL(self):\n    '''Returns true if compiler is IBM cross compiler for BGL'''\n    if not hasattr(self, '_isBGL'):\n      self.logPrint('**********Checking if running on BGL/IBM detected')\n      if (self.check('', 'bgl_perfctr_void') or self.check('','ADIOI_BGL_Open')) and self.check('', '_xlqadd'):\n        self.logPrint('*********BGL/IBM detected')\n        self._isBGL = 1\n      else:\n        self.logPrint('*********BGL/IBM test failure')\n        self._isBGL = 0\n    return self._isBGL\n\n  def configure(self):\n    map(lambda args: self.executeTest(self.check, list(args)), self.libraries)\n    self.executeTest(self.checkMath)\n    self.executeTest(self.checkMathErf)\n    self.executeTest(self.checkMathTgamma)\n    self.executeTest(self.checkMathFenv)\n    self.executeTest(self.checkMathLog2)\n    self.executeTest(self.checkCompression)\n    self.executeTest(self.checkRealtime)\n    self.executeTest(self.checkDynamic)\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/config/BuildSystem/config/setCompilers.py": "from __future__ import generators\nimport config.base\nimport config\n\nimport os\n\n# not sure how to handle this with 'self' so its outside the class\ndef noCheck(command, status, output, error):\n  return\n\ntry:\n  any\nexcept NameError:\n  def any(lst):\n    return reduce(lambda x,y:x or y,lst,False)\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.usedMPICompilers = 0\n    self.mainLanguage = 'C'\n    return\n\n  def __str__(self):\n    desc = ['Compilers:']\n    if hasattr(self, 'CC'):\n      self.pushLanguage('C')\n      desc.append('  C Compiler:         '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C Linker:           '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CUDAC'):\n      self.pushLanguage('CUDA')\n      desc.append('  CUDA Compiler:      '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  CUDA Linker:        '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CXX'):\n      self.pushLanguage('Cxx')\n      desc.append('  C++ Compiler:       '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C++ Linker:         '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'FC'):\n      self.pushLanguage('FC')\n      desc.append('  Fortran Compiler:   '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  Fortran Linker:     '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    desc.append('Linkers:')\n    if hasattr(self, 'staticLinker'):\n      desc.append('  Static linker:   '+self.getSharedLinker()+' '+self.AR_FLAGS)\n    elif hasattr(self, 'sharedLinker'):\n      desc.append('  Shared linker:   '+self.getSharedLinker()+' '+self.getSharedLinkerFlags())\n    if hasattr(self, 'dynamicLinker'):\n      desc.append('  Dynamic linker:   '+self.getDynamicLinker()+' '+self.getDynamicLinkerFlags())\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-cpp=<prog>', nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPP=<prog>',            nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C preprocessor options'))\n    help.addArgument('Compilers', '-with-cc=<prog>',  nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CC=<prog>',             nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CFLAGS=<string>',       nargs.Arg(None, None, 'Specify the C compiler options'))\n    help.addArgument('Compilers', '-CC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the C linker flags'))\n\n    help.addArgument('Compilers', '-CXXCPP=<prog>',          nargs.Arg(None, None, 'Specify the C++ preprocessor'))\n    help.addArgument('Compilers', '-CXXCPPFLAGS=<string>',  nargs.Arg(None, None, 'Specify the C++ preprocessor options'))\n    help.addArgument('Compilers', '-with-cxx=<prog>', nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXX=<prog>',            nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXXFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C++ compiler options, also passed to linker'))\n    help.addArgument('Compilers', '-CXX_CXXFLAGS=<string>', nargs.Arg(None, '',   'Specify the C++ compiler-only options, not passed to linker'))\n    help.addArgument('Compilers', '-CXX_LINKER_FLAGS=<string>',       nargs.Arg(None, [], 'Specify the C++ linker flags'))\n\n    help.addArgument('Compilers', '-with-fc=<prog>',  nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FC=<prog>',             nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FFLAGS=<string>',       nargs.Arg(None, None, 'Specify the Fortran compiler options'))\n    help.addArgument('Compilers', '-FC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the FC linker flags'))\n\n    help.addArgument('Compilers', '-with-gnu-compilers=<bool>',      nargs.ArgBool(None, 1, 'Try to use GNU compilers'))\n    help.addArgument('Compilers', '-with-vendor-compilers=<vendor as string>', nargs.Arg(None, '', 'Try to use vendor compilers (no argument all vendors, 0 no vendors)'))\n\n    help.addArgument('Compilers', '-with-large-file-io=<bool>', nargs.ArgBool(None, 0, 'Allow IO with files greater then 2 GB'))\n\n    help.addArgument('Compilers', '-CUDAPP=<prog>',        nargs.Arg(None, None, 'Specify the CUDA preprocessor'))\n    help.addArgument('Compilers', '-CUDAPPFLAGS=<string>', nargs.Arg(None, None, 'Specify the CUDA preprocessor options'))\n    help.addArgument('Compilers', '-CUDAC=<prog>',         nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAFLAGS=<string>',   nargs.Arg(None, None, 'Specify the CUDA compiler options'))\n    help.addArgument('Compilers', '-CUDAC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the CUDA linker flags'))\n\n##    help.addArgument('Compilers', '-LD=<prog>',              nargs.Arg(None, None, 'Specify the executable linker'))\n##    help.addArgument('Compilers', '-CC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for C only'))\n##    help.addArgument('Compilers', '-CXX_LD=<prog>',          nargs.Arg(None, None, 'Specify the linker for C++ only'))\n##    help.addArgument('Compilers', '-FC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for Fortran only'))\n    help.addArgument('Compilers', '-with-shared-ld=<prog>',  nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LD_SHARED=<prog>',       nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LDFLAGS=<string>',       nargs.Arg(None, '',   'Specify the linker options'))\n    help.addArgument('Compilers', '-with-ar=<prog>',                nargs.Arg(None, None,   'Specify the archiver'))\n    help.addArgument('Compilers', '-AR=<prog>',                     nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-AR_FLAGS=<string>',               nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-with-ranlib=<prog>',            nargs.Arg(None, None,   'Specify ranlib'))\n    help.addArgument('Compilers', '-with-pic=<bool>',               nargs.ArgBool(None, 0, 'Compile with -fPIC or equivalent flag if possible'))\n    help.addArgument('Compilers', '-sharedLibraryFlags=<string>',     nargs.Arg(None, [], 'Specify the shared library flags'))\n    help.addArgument('Compilers', '-dynamicLibraryFlags=<string>',    nargs.Arg(None, [], 'Specify the dynamic library flags'))\n    help.addArgument('Compilers', '-LIBS=<string>',          nargs.Arg(None, None, 'Specify extra libraries for all links'))\n    help.addArgument('Compilers', '-with-environment-variables=<bool>',nargs.ArgBool(None, 0, 'Use compiler variables found in environment'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.headers = framework.require('config.headers', None)\n    self.libraries = framework.require('config.libraries', None)\n    return\n\n  def isNAG(compiler, log):\n    '''Returns true if the compiler is a NAG F90 compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('NAGWare Fortran') >= 0 or output.find('The Numerical Algorithms Group Ltd') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isNAG = staticmethod(isNAG)\n\n  def isGNU(compiler, log):\n    '''Returns true if the compiler is a GNU compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      return (any([s in output for s in ['www.gnu.org',\n                                         'bugzilla.redhat.com',\n                                         'gcc.gnu.org',\n                                         'gcc version',\n                                         '-print-libgcc-file-name',\n                                         'passed on to the various sub-processes invoked by gcc',\n                                         'passed on to the various sub-processes invoked by cc',\n                                         'passed on to the various sub-processes invoked by gfortran',\n                                         'passed on to the various sub-processes invoked by g++',\n                                         'passed on to the various sub-processes invoked by c++',\n                                         ]])\n              and not any([s in output for s in ['Intel(R)',\n                                                 'Unrecognised option --help passed to ld', # NAG f95 compiler\n                                                 ]]))\n    except RuntimeError:\n      pass\n    return 0\n  isGNU = staticmethod(config.memoize(isGNU))\n\n  def isClang(compiler, log):\n    '''Returns true if the compiler is a Clang/LLVM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      return any([s in output for s in ['Emit Clang AST']])\n    except RuntimeError:\n      pass\n    return 0\n  isClang = staticmethod(isClang)\n\n  def isGfortran45x(compiler, log):\n    '''returns true if the compiler is gfortran-4.5.x'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.5.\\d+|4.6.0 20100703)', output):\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran45x = staticmethod(isGfortran45x)\n\n  def isGfortran46plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.6.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,6):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran46plus = staticmethod(isGfortran46plus)\n\n  def isGfortran47plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.7.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,7):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran47plus = staticmethod(isGfortran47plus)\n\n  def isG95(compiler, log):\n    '''Returns true if the compiler is g95'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('http://www.g95.org') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isG95 = staticmethod(isG95)\n\n  def isCompaqF90(compiler, log):\n    '''Returns true if the compiler is Compaq f90'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('Compaq Visual Fortran') >= 0 or output.find('Digital Visual Fortran') >=0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCompaqF90 = staticmethod(isCompaqF90)\n\n  def isSun(compiler, log):\n    '''Returns true if the compiler is a Sun/Oracle compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find(' Sun ') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSun = staticmethod(isSun)\n\n  def isIBM(compiler, log):\n    '''Returns true if the compiler is a IBM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -qversion', log = log)\n      output = output + error\n      if 'IBM XL' in output:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIBM = staticmethod(isIBM)\n\n  def isIntel(compiler, log):\n    '''Returns true if the compiler is a Intel compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help', log = log)\n      output = output + error\n      if output.find('Intel Corporation') >= 0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIntel = staticmethod(isIntel)\n\n  def isCray(compiler, log):\n    '''Returns true if the compiler is a Cray compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V', log = log)\n      output = output + error\n      if output.find('Cray Standard C') >= 0 or output.find('Cray C++') >= 0 or output.find('Cray Fortran') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCray = staticmethod(isCray)\n\n  def isCrayVector(compiler, log):\n    '''Returns true if the compiler is a Cray compiler for a Cray Vector system'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -VV', log = log)\n      output = output + error\n      if not status and output.find('x86') >= 0:\n        return 0\n      elif not status:\n        return 1\n      else:\n        return 0\n    except RuntimeError:\n      pass\n    return 0\n  isCrayVector = staticmethod(isCrayVector)\n\n\n  def isPGI(compiler, log):\n    '''Returns true if the compiler is a PGI compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('The Portland Group') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isPGI = staticmethod(isPGI)\n\n  def isSolarisAR(ar, log):\n    '''Returns true AR is solaris'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('Software Generation Utilities') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSolarisAR = staticmethod(isSolarisAR)\n\n  def isAIXAR(ar, log):\n    '''Returns true AR is AIX'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('[-X{32|64|32_64|d64|any}]') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isAIXAR = staticmethod(isAIXAR)\n\n\n  def isLinux(log):\n    '''Returns true if system is linux'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('linux') >= 0:\n      return 1\n    else:\n      return 0\n  isLinux = staticmethod(isLinux)\n\n  def isCygwin(log):\n    '''Returns true if system is cygwin'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('cygwin') >= 0:\n      return 1\n    else:\n      return 0\n  isCygwin = staticmethod(isCygwin)\n\n  def isSolaris(log):\n    '''Returns true if system is solaris'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('sunos') >= 0:\n      return 1\n    else:\n      return 0\n  isSolaris = staticmethod(isSolaris)\n\n  def isDarwin(log):\n    '''Returns true if system is Darwin/MacOSX'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'darwin'\n    return 0\n  isDarwin = staticmethod(isDarwin)\n\n  def isFreeBSD(log):\n    '''Returns true if system is FreeBSD'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'freebsd'\n    return 0\n  isFreeBSD = staticmethod(isFreeBSD)\n\n  def isWindows(compiler, log):\n    '''Returns true if the compiler is a Windows compiler'''\n    if compiler in ['icl', 'cl', 'bcc32', 'ifl', 'df']:\n      return 1\n    if compiler in ['ifort','f90'] and Configure.isCygwin(log):\n      return 1\n    if compiler in ['lib', 'tlib']:\n      return 1\n    return 0\n  isWindows = staticmethod(isWindows)\n\n  def addLdPath(path):\n    import os\n    if 'LD_LIBRARY_PATH' in os.environ:\n      ldPath=os.environ['LD_LIBRARY_PATH']\n    else:\n      ldPath=''\n    if ldPath == '': ldPath = path\n    else: ldPath += ':' + path\n    os.environ['LD_LIBRARY_PATH'] = ldPath\n    return\n  addLdPath = staticmethod(addLdPath)\n\n  def useMPICompilers(self):\n    if ('with-cc' in self.argDB and self.argDB['with-cc'] != '0') or 'CC' in self.argDB:\n      return 0\n    if ('with-cxx' in self.argDB and self.argDB['with-cxx'] != '0') or 'CXX' in self.argDB:\n      return 0\n    if ('with-fc' in self.argDB and self.argDB['with-fc'] != '0') or 'FC' in self.argDB:\n      return 0\n    if self.argDB['download-mpich'] or self.argDB['download-openmpi']:\n      return 0\n    if 'with-mpi' in self.argDB and self.argDB['with-mpi'] and self.argDB['with-mpi-compilers']:\n      return 1\n    return 0\n\n  def checkVendor(self):\n    '''Determine the compiler vendor'''\n    self.vendor = self.argDB['with-vendor-compilers']\n    if self.argDB['with-vendor-compilers'] == 'no' or self.argDB['with-vendor-compilers'] == 'false':\n      self.vendor = None\n    if self.argDB['with-vendor-compilers'] == '1' or self.argDB['with-vendor-compilers'] == 'yes' or self.argDB['with-vendor-compilers'] == 'true':\n      self.vendor = ''\n    self.logPrint('Compiler vendor is \"'+str(self.vendor)+'\"')\n    return\n\n  def checkInitialFlags(self):\n    '''Initialize the compiler and linker flags'''\n    for language in ['C', 'CUDA', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      for flagsArg in [self.getCompilerFlagsName(language), self.getCompilerFlagsName(language, 1), self.getLinkerFlagsName(language)]:\n        if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n        else: setattr(self, flagsArg, '')\n        self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n      self.popLanguage()\n    for flagsArg in ['CPPFLAGS', 'CUDAPPFLAGS', 'CXXCPPFLAGS', 'CC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS','sharedLibraryFlags', 'dynamicLibraryFlags']:\n      if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n      else: setattr(self, flagsArg, '')\n      self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    if 'LIBS' in self.argDB:\n      self.LIBS = self.argDB['LIBS']\n    else:\n      self.LIBS = ''\n    return\n\n  def checkCompiler(self, language):\n    '''Check that the given compiler is functional, and if not raise an exception'''\n    self.pushLanguage(language)\n    if not self.checkCompile():\n      msg = 'Cannot compile '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if language == 'CUDA': # do not check CUDA linker since it is never used (and is broken on Mac with -m64)\n      self.popLanguage()\n      return\n    if not self.checkLink():\n      msg = 'Cannot compile/link '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    oldlibs = self.LIBS\n    self.LIBS += ' -lpetsc-ufod4vtr9mqHvKIQiVAm'\n    if self.checkLink():\n      msg = language + ' compiler ' + self.getCompiler()+ ''' is broken! It is returning a zero error when the linking failed! Either\n 1) switch to another compiler suite or\n 2) report this entire error message to your compiler/linker suite vendor and ask for fix for this issue.'''\n      self.popLanguage()\n      self.LIBS = oldlibs\n      raise RuntimeError(msg)\n    self.LIBS = oldlibs\n    if not self.argDB['with-batch']:\n      if not self.checkRun():\n        msg = 'Cannot run executables created with '+language+'. If this machine uses a batch system \\nto submit jobs you will need to configure using ./configure with the additional option  --with-batch.\\n Otherwise there is problem with the compilers. Can you compile and run code with your compiler \\''+ self.getCompiler()+'\\'?\\n'\n        if self.isIntel(self.getCompiler(), self.log):\n          msg = msg + 'See http://www.mcs.anl.gov/petsc/documentation/faq.html#libimf'\n        self.popLanguage()\n        raise OSError(msg)\n    self.popLanguage()\n    return\n\n  def generateCCompilerGuesses(self):\n    '''Determine the C compiler using CC, then --with-cc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CC'):\n      yield self.CC\n    elif self.argDB.has_key('with-cc'):\n      if self.isWindows(self.argDB['with-cc'], self.log):\n        yield 'win32fe '+self.argDB['with-cc']\n      else:\n        yield self.argDB['with-cc']\n      raise RuntimeError('C compiler you provided with -with-cc='+self.argDB['with-cc']+' does not work.'+'\\n'+self.mesg)\n    elif self.argDB.has_key('CC'):\n      if self.isWindows(self.argDB['CC'], self.log):\n        yield 'win32fe '+self.argDB['CC']\n      else:\n        yield self.argDB['CC']\n      raise RuntimeError('C compiler you provided with -CC='+self.argDB['CC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('MPI compiler wrappers in '+self.argDB['with-mpi-dir']+'/bin do not work. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicc', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpicc'\n        if Configure.isGNU('hcc', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'hcc'\n        if not Configure.isGNU('mpicc', self.log) and (not self.vendor is None):\n          yield 'mpicc'\n        if not Configure.isGNU('hcc', self.log) and (not self.vendor is None):\n          yield 'hcc'\n        if not self.vendor is None:\n          yield 'mpcc_r'\n          yield 'mpcc'\n          yield 'mpxlc'\n        self.usedMPICompilers = 0\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc', self.log):\n          yield 'cc'\n      if not self.vendor is None:\n        if not vendor and not Configure.isGNU('cc', self.log):\n          yield 'cc'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'kai' or not vendor:\n          yield 'kcc'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlc'\n        if vendor == 'intel' or not vendor:\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgcc'\n        if vendor == 'solaris' or not vendor:\n          if not Configure.isGNU('cc', self.log):\n            yield 'cc'\n      # duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc', self.log):\n          yield 'cc'\n    return\n\n  def checkCCompiler(self):\n    '''Locate a functional C compiler'''\n    if 'with-cc' in self.argDB and self.argDB['with-cc'] == '0':\n      raise RuntimeError('A functional C compiler is necessary for configure, cannot use --with-cc=0')\n    self.mesg = ''\n    for compiler in self.generateCCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CC'):\n          self.checkCompiler('C')\n          break\n      except RuntimeError, e:\n        import os\n        self.mesg = str(e)\n        self.logPrint('Error testing C compiler: '+str(e))\n        if os.path.basename(self.CC) == 'mpicc':\n          self.logPrint(' MPI installation '+str(self.CC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('CC')\n        del self.CC\n    if not hasattr(self, 'CC'):\n      raise RuntimeError('Could not locate a functional C compiler')\n    return\n\n  def generateCPreprocessorGuesses(self):\n    '''Determines the C preprocessor from CPP, then --with-cpp, then the C compiler'''\n    if 'with-cpp' in self.argDB:\n      yield self.argDB['with-cpp']\n    elif 'CPP' in self.argDB:\n      yield self.argDB['CPP']\n    else:\n      yield self.CC+' -E'\n      yield self.CC+' --use cpp32'\n    return\n\n  def checkCPreprocessor(self):\n    '''Locate a functional C preprocessor'''\n    for compiler in self.generateCPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CPP'):\n          self.pushLanguage('C')\n          if not self.checkPreprocess('#include <stdlib.h>\\n'):\n            raise RuntimeError('Cannot preprocess C with '+self.CPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError, e:\n        self.popLanguage()\n    raise RuntimeError('Cannot find a C preprocessor')\n    return\n\n  def generateCUDACompilerGuesses(self):\n    import os\n    '''Determine the CUDA compiler using CUDAC, then --with-cudac, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CUDAC'):\n      yield self.CUDAC\n    elif self.argDB.has_key('with-cudac'):\n      yield self.argDB['with-cudac']\n      raise RuntimeError('CUDA compiler you provided with -with-cudac='+self.argDB['with-cudac']+' does not work.'+'\\n'+self.mesg)\n    elif self.argDB.has_key('CUDAC'):\n      yield self.argDB['CUDAC']\n      raise RuntimeError('CUDA compiler you provided with -CUDAC='+self.argDB['CUDAC']+' does not work.'+'\\n'+self.mesg)\n    elif self.argDB.has_key('with-cuda-dir'):\n      import os\n      nvccPath = os.path.join(self.argDB['with-cuda-dir'], 'bin','nvcc')\n      yield nvccPath\n    else:\n      vendor = self.vendor\n      if not self.vendor is None:\n        if vendor == 'nvidia' or not vendor:\n          yield 'nvcc'\n      yield 'nvcc'\n      yield os.path.join('/Developer','NVIDIA','CUDA-6.5','bin','nvcc')\n      yield os.path.join('/usr','local','cuda','bin','nvcc')\n    return\n\n  def checkCUDACompiler(self):\n    '''Locate a functional CUDA compiler'''\n    if not self.framework.clArgDB.has_key('with-cuda') or self.argDB['with-cuda'] == '0':\n      if 'CUDAC' in self.argDB:\n        del self.argDB['CUDAC']\n      return\n    self.mesg = ''\n    for compiler in self.generateCUDACompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAC'):\n          self.checkCompiler('CUDA')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.CUDAC+' --version', log = self.log)\n          compilerVersion = compilerVersion[0]\n          compilerVersion = compilerVersion.split()\n          i = 0\n          for word in compilerVersion:\n            i = i+1\n            if word == 'release':\n              break\n          self.compilerVersionCUDA = compilerVersion[i].strip(',')\n          break\n      except RuntimeError, e:\n        self.mesg = str(e)\n        self.logPrint('Error testing CUDA compiler: '+str(e))\n        self.delMakeMacro('CUDAC')\n        del self.CUDAC\n    return\n\n  def generateCUDAPreprocessorGuesses(self):\n    '''Determines the CUDA preprocessor from --with-cudacpp, then CUDAPP, then the CUDA compiler'''\n    if 'with-cudacpp' in self.argDB:\n      yield self.argDB['with-cudacpp']\n    elif 'CUDAPP' in self.argDB:\n      yield self.argDB['CUDAPP']\n    else:\n      if hasattr(self, 'CUDAC'):\n        yield self.CUDAC+' -arch=sm_20 -E'\n    return\n\n  def checkCUDAPreprocessor(self):\n    '''Locate a functional CUDA preprocessor'''\n    for compiler in self.generateCUDAPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAPP'):\n          self.pushLanguage('CUDA')\n          if not self.checkPreprocess('#include <stdlib.h>\\n__global__ void testFunction() {return;};'):\n            raise RuntimeError('Cannot preprocess CUDA with '+self.CUDAPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError, e:\n        self.popLanguage()\n    return\n\n  def generateCxxCompilerGuesses(self):\n    '''Determine the Cxx compiler using CXX, then --with-cxx, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'CXX'):\n      yield self.CXX\n    elif self.argDB.has_key('with-c++'):\n      raise RuntimeError('Keyword --with-c++ is WRONG, use --with-cxx')\n    if self.argDB.has_key('with-CC'):\n      raise RuntimeError('Keyword --with-CC is WRONG, use --with-cxx')\n\n    if self.argDB.has_key('with-cxx'):\n      if self.argDB['with-cxx'] == 'gcc': raise RuntimeError('Cannot use C compiler gcc as the C++ compiler passed in with --with-cxx')\n      if self.isWindows(self.argDB['with-cxx'], self.log):\n        yield 'win32fe '+self.argDB['with-cxx']\n      else:\n        yield self.argDB['with-cxx']\n      raise RuntimeError('C++ compiler you provided with -with-cxx='+self.argDB['with-cxx']+' does not work.'+'\\n'+self.mesg)\n    elif self.argDB.has_key('CXX'):\n      if self.isWindows(self.argDB['CXX'], self.log):\n        yield 'win32fe '+self.argDB['CXX']\n      else:\n        yield self.argDB['CXX']\n      raise RuntimeError('C++ compiler you provided with -CXX='+self.argDB['CXX']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicxx')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcp')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpic++')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiCC')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpCC_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('bin/<mpiCC,mpicxx,hcp,mpCC_r> you provided with -with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicxx', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpicxx'\n        if not Configure.isGNU('mpicxx', self.log) and (not self.vendor is None):\n          yield 'mpicxx'\n        if Configure.isGNU('mpiCC', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpiCC'\n        if not Configure.isGNU('mpiCC', self.log) and (not self.vendor is None):\n          yield 'mpiCC'\n        if Configure.isGNU('mpic++', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpic++'\n        if not Configure.isGNU('mpic++', self.log) and (not self.vendor is None):\n          yield 'mpic++'\n        if not self.vendor is None:\n          yield 'mpCC_r'\n          yield 'mpCC'\n        self.usedMPICompilers = 0\n      #attempt to match c++ compiler with c compiler\n      if self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe cl'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe icl'\n      elif self.CC == 'clang':\n        yield 'clang++'\n      elif self.CC == 'icc':\n        yield 'icpc'\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++', self.log):\n          yield 'c++'\n      if not self.vendor is None:\n        if not vendor:\n          if not Configure.isGNU('c++', self.log):\n            yield 'c++'\n          if not Configure.isGNU('CC', self.log):\n            yield 'CC'\n          yield 'cxx'\n          yield 'cc++'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlC'\n        if vendor == 'intel' or not vendor:\n          yield 'icpc'\n          yield 'ccpc'\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgCC'\n        if vendor == 'solaris':\n          yield 'CC'\n      #duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++', self.log):\n          yield 'c++'\n    return\n\n  def checkCxxCompiler(self):\n    '''Locate a functional Cxx compiler'''\n    if 'with-cxx' in self.argDB and self.argDB['with-cxx'] == '0':\n      if 'CXX' in self.argDB:\n        del self.argDB['CXX']\n      return\n    self.mesg = ''\n    for compiler in self.generateCxxCompilerGuesses():\n      # Determine an acceptable extensions for the C++ compiler\n      for ext in ['.cc', '.cpp', '.C']:\n        self.framework.getCompilerObject('Cxx').sourceExtension = ext\n        try:\n          if self.getExecutable(compiler, resultName = 'CXX'):\n            self.checkCompiler('Cxx')\n            break\n        except RuntimeError, e:\n          import os\n          self.mesg = str(e)\n          self.logPrint('Error testing C++ compiler: '+str(e))\n          if os.path.basename(self.CXX) in ['mpicxx', 'mpiCC']:\n            self.logPrint('  MPI installation '+str(self.CXX)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n          self.delMakeMacro('CXX')\n          del self.CXX\n      if hasattr(self, 'CXX'):\n        break\n    return\n\n  def generateCxxPreprocessorGuesses(self):\n    '''Determines the Cxx preprocessor from CXXCPP, then --with-cxxcpp, then the Cxx compiler'''\n    if 'with-cxxcpp' in self.argDB:\n      yield self.argDB['with-cxxcpp']\n    elif 'CXXCPP' in self.argDB:\n      yield self.argDB['CXXCPP']\n    else:\n      yield self.CXX+' -E'\n      yield self.CXX+' --use cpp32'\n    return\n\n  def checkCxxPreprocessor(self):\n    '''Locate a functional Cxx preprocessor'''\n    if not hasattr(self, 'CXX'):\n      return\n    for compiler in self.generateCxxPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CXXCPP'):\n          self.pushLanguage('Cxx')\n          if not self.checkPreprocess('#include <cstdlib>\\n'):\n            raise RuntimeError('Cannot preprocess Cxx with '+self.CXXCPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError, e:\n        import os\n\n        if os.path.basename(self.CXXCPP) in ['mpicxx', 'mpiCC']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('CCCPP')\n        del self.CXXCPP\n    return\n\n  def generateFortranCompilerGuesses(self):\n    '''Determine the Fortran compiler using FC, then --with-fc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'FC'):\n      yield self.FC\n    elif self.argDB.has_key('with-fc'):\n      if self.isWindows(self.argDB['with-fc'], self.log):\n        yield 'win32fe '+self.argDB['with-fc']\n      else:\n        yield self.argDB['with-fc']\n      raise RuntimeError('Fortran compiler you provided with --with-fc='+self.argDB['with-fc']+' does not work.'+'\\n'+self.mesg)\n    elif self.argDB.has_key('FC'):\n      if self.isWindows(self.argDB['FC'], self.log):\n        yield 'win32fe '+self.argDB['FC']\n      else:\n        yield self.argDB['FC']\n      yield self.argDB['FC']\n      raise RuntimeError('Fortran compiler you provided with -FC='+self.argDB['FC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif77')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf95_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf90_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf77')\n      self.usedMPICompilers = 0\n      if os.path.isfile(os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')) or os.path.isfile((os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif77'))):\n        raise RuntimeError('bin/mpif90[f77] you provided with --with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work.\\nRun with --with-fc=0 if you wish to use this MPI and disable Fortran. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpif90', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpif90'\n        if not Configure.isGNU('mpif90', self.log) and (not self.vendor is None):\n          yield 'mpif90'\n        if Configure.isGNU('mpif77', self.log) and self.argDB['with-gnu-compilers']:\n          yield 'mpif77'\n        if not Configure.isGNU('mpif77', self.log) and (not self.vendor is None):\n          yield 'mpif77'\n        if not self.vendor is None:\n          yield 'mpxlf_r'\n          yield 'mpxlf'\n          yield 'mpf90'\n          yield 'mpf77'\n        self.usedMPICompilers = 0\n      #attempt to match fortran compiler with c compiler\n      if self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe f90'\n        yield 'win32fe ifc'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe ifc'\n      elif self.CC == 'icc':\n        yield 'ifort'\n      vendor = self.vendor\n      if (not vendor) and self.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77', self.log):\n          yield 'f77'\n      if not self.vendor is None:\n        if vendor == 'ibm' or not vendor:\n          yield 'xlf'\n          yield 'xlf90'\n        if not vendor or vendor in ['absoft', 'cray', 'dec', 'hp', 'sgi']:\n          yield 'f90'\n        if vendor == 'lahaye' or not vendor:\n          yield 'lf95'\n        if vendor == 'intel' or not vendor:\n          yield 'win32fe ifort'\n          yield 'win32fe ifl'\n          yield 'ifort'\n          yield 'ifc'\n          yield 'efc'\n        if vendor == 'portland' or not vendor:\n          yield 'pgf90'\n          yield 'pgf77'\n        if vendor == 'solaris' or not vendor:\n          yield 'f95'\n          yield 'f90'\n          if not Configure.isGNU('f77', self.log):\n            yield 'f77'\n      #duplicate code\n      if self.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77', self.log):\n          yield 'f77'\n    return\n\n  def checkFortranCompiler(self):\n    '''Locate a functional Fortran compiler'''\n    if 'with-fc' in self.argDB and self.argDB['with-fc'] == '0':\n      if 'FC' in self.argDB:\n        del self.argDB['FC']\n      return\n    self.mesg = ''\n    for compiler in self.generateFortranCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FC'):\n          self.checkCompiler('FC')\n          break\n      except RuntimeError, e:\n        self.mesg = str(e)\n        self.logPrint('Error testing Fortran compiler: '+str(e))\n        if os.path.basename(self.FC) in ['mpif90', 'mpif77']:\n          self.logPrint(' MPI installation '+str(self.FC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('FC')\n        del self.FC\n    return\n\n  def checkFortranComments(self):\n    '''Make sure fortran comment \"!\" works'''\n    self.pushLanguage('FC')\n    if not self.checkCompile('! comment'):\n      raise RuntimeError(self.getCompiler()+' cannot process fortran comments.')\n    self.logPrint('Fortran comments can use ! in column 1')\n    self.popLanguage()\n    return\n\n  def containsInvalidFlag(self, output):\n    '''If the output contains evidence that an invalid flag was used, return True'''\n    if (output.find('Unrecognized command line option') >= 0 or output.find('Unrecognised command line option') >= 0 or\n        output.find('unrecognized command line option') >= 0 or output.find('unrecognized option') >= 0 or output.find('unrecognised option') >= 0 or\n        output.find('not recognized') >= 0 or output.find('not recognised') >= 0 or\n        output.find('unknown option') >= 0 or output.find('unknown flag') >= 0 or output.find('Unknown switch') >= 0 or\n        output.find('ignoring option') >= 0 or output.find('ignored') >= 0 or\n        output.find('argument unused') >= 0 or\n        # When checking for the existence of 'attribute'\n        output.find('is unsupported and will be skipped') >= 0 or\n        output.find('illegal option') >= 0 or output.find('Invalid option') >= 0 or\n        (output.find('bad ') >= 0 and output.find(' option') >= 0) or\n        output.find('linker input file unused because linking not done') >= 0 or\n        output.find('PETSc Error') >= 0 or\n        output.find('Unbekannte Option') >= 0 or\n        output.find('no se reconoce la opci') >= 0) or output.find('non reconnue') >= 0:\n      return 1\n    return 0\n\n  def checkCompilerFlag(self, flag, includes = '', body = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, error, status) = self.outputCompile(includes, body)\n    output += error\n    valid   = 1\n    # Please comment each entry and provide an example line\n    if status:\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to nonzero status from link')\n    # Lahaye F95\n    if output.find('Invalid suboption') >= 0:\n      valid = 0\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to \\n'+output)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def insertCompilerFlag(self, flag, compilerOnly):\n    '''DANGEROUS: Put in the compiler flag without checking'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n    self.log.write('Added '+self.language[-1]+' compiler flag '+flag+'\\n')\n    return\n\n  def addCompilerFlag(self, flag, includes = '', body = '', extraflags = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkCompilerFlag(flag+' '+extraflags, includes, body, compilerOnly):\n      self.insertCompilerFlag(flag, compilerOnly)\n      return\n    raise RuntimeError('Bad compiler flag: '+flag)\n\n  def generatePICGuesses(self):\n    yield ''\n    if self.language[-1] == 'CUDA':\n      yield '-Xcompiler -fPIC'\n    elif config.setCompilers.Configure.isGNU(self.getCompiler(), self.log):\n      yield '-fPIC'\n    else:\n      yield '-PIC'\n      yield '-fPIC'\n      yield '-KPIC'\n      yield '-qpic'\n    return\n\n  def checkPIC(self):\n    '''Determine the PIC option for each compiler'''\n    self.usePIC = 0\n    useSharedLibraries = 'with-shared-libraries' in self.argDB and self.argDB['with-shared-libraries']\n    myLanguage = self.language[-1]\n    if not self.argDB['with-pic'] and not useSharedLibraries:\n      self.logPrint(\"Skip checking PIC options on user request\")\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      self.pushLanguage(language)\n      if language in ['C','Cxx','CUDA']:\n        includeLine = '#include<stdio.h>\\nvoid foo(void){fprintf(stdout,\"hello\");\\nreturn;}\\nvoid bar(void){foo();}\\n'\n      else:\n        includeLine = '      function foo(a)\\n      real:: a,x,bar\\n      common /xx/ x\\n      x=a\\n      foo = bar(x)\\n      end\\n'\n      compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n      oldCompilerFlags = getattr(self, compilerFlagsArg)\n      for testFlag in self.generatePICGuesses():\n        self.logPrint('Trying '+language+' compiler flag '+testFlag)\n        acceptedPIC = 1\n        try:\n          self.addCompilerFlag(testFlag, compilerOnly = 1)\n          acceptedPIC = self.checkLink(includes = includeLine, codeBegin = '', codeEnd = '', cleanup = 1, shared = 1, linkLanguage = myLanguage)\n        except RuntimeError:\n          acceptedPIC = 0\n        if not acceptedPIC:\n          self.logPrint('Rejected '+language+' compiler flag '+testFlag+' because shared linker cannot handle it')\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n          continue\n        self.logPrint('Accepted '+language+' compiler flag '+testFlag)\n        self.isPIC = 1\n        break\n      self.popLanguage()\n    return\n\n  def checkLargeFileIO(self):\n    # check for large file support with 64bit offset\n    if not self.argDB['with-large-file-io']:\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      if self.checkCompile('#include <unistd.h>','#ifndef _LFS64_LARGEFILE \\n#error no largefile defines \\n#endif'):\n        try:\n          self.addCompilerFlag('-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64',compilerOnly=1)\n        except RuntimeError, e:\n          self.logPrint('Error adding ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      else:\n        self.logPrint('Rejected ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      self.popLanguage()\n    return\n\n  def getArchiverFlags(self, archiver):\n    prog = os.path.basename(archiver).split(' ')[0]\n    flag = ''\n    if 'AR_FLAGS' in self.argDB:\n      flag = self.argDB['AR_FLAGS']\n    elif prog.endswith('ar'):\n      flag = 'cr'\n    elif prog == 'win32fe':\n      args = os.path.basename(archiver).split(' ')\n      if 'lib' in args:\n        flag = '-a'\n      elif 'tlib' in args:\n        flag = '-a -P512'\n    if prog.endswith('ar') and not (self.isSolarisAR(prog, self.log) or self.isAIXAR(prog, self.log)):\n      self.FAST_AR_FLAGS = 'Scq'\n    else:\n      self.FAST_AR_FLAGS = flag\n    self.framework.addMakeMacro('FAST_AR_FLAGS',self.FAST_AR_FLAGS )\n    return flag\n\n  def generateArchiverGuesses(self):\n    defaultAr = None\n    if 'with-ar' in self.argDB:\n      if self.isWindows(self.argDB['with-ar'], self.log):\n        defaultAr = 'win32fe '+self.argDB['with-ar']\n      else:\n        defaultAr = self.argDB['with-ar']\n    envAr = None\n    if 'AR' in self.argDB:\n      if self.isWindows(self.argDB['AR'], self.log):\n        envAr = 'win32fe '+self.argDB['AR']\n      else:\n        envAr = self.argDB['AR']\n    defaultRanlib = None\n    if 'with-ranlib' in self.argDB:\n      defaultRanlib = self.argDB['with-ranlib']\n    envRanlib = None\n    if 'RANLIB' in self.argDB:\n      envRanlib = self.argDB['RANLIB']\n    if defaultAr and defaultRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),defaultRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if defaultAr and envRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),envRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if envAr and defaultRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),defaultRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if envAr and envRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),envRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if defaultAr:\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'ranlib')\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'true')\n      raise RuntimeError('You set a value for --with-ar='+defaultAr+'\", but '+defaultAr+' cannot be used\\n')\n    if envAr:\n      yield (envAr,self.getArchiverFlags(envAr),'ranlib')\n      yield (envAr,self.getArchiverFlags(envAr),'true')\n      raise RuntimeError('You set a value for -AR=\"'+envAr+'\" (perhaps in your environment), but '+envAr+' cannot be used\\n')\n    if defaultRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),defaultRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),defaultRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),defaultRanlib)\n      raise RuntimeError('You set --with-ranlib=\"'+defaultRanlib+'\", but '+defaultRanlib+' cannot be used\\n')\n    if envRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),envRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),envRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),envRanlib)\n      raise RuntimeError('You set -RANLIB=\"'+envRanlib+'\" (perhaps in your environment), but '+defaultRanlib+' cannot be used\\n')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar',self.getArchiverFlags('ar'),'true')\n    # IBM with 64 bit pointers\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'true')\n    yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),'true')\n    yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),'true')\n    return\n\n  def checkArchiver(self):\n    '''Check that the archiver exists and can make a library usable by the compiler'''\n    objName    = os.path.join(self.tmpDir, 'conf1.o')\n    arcUnix    = os.path.join(self.tmpDir, 'libconf1.a')\n    arcWindows = os.path.join(self.tmpDir, 'libconf1.lib')\n    def checkArchive(command, status, output, error):\n      if error or status:\n        self.logError('archiver', status, output, error)\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('Archiver is not functional')\n      return\n    def checkRanlib(command, status, output, error):\n      if error or status:\n        self.logError('ranlib', status, output, error)\n        if os.path.isfile(arcUnix):\n          os.remove(arcUnix)\n        raise RuntimeError('Ranlib is not functional with your archiver.  Try --with-ranlib=true if ranlib is unnecessary.')\n      return\n    oldLibs = self.LIBS\n    self.pushLanguage('C')\n    for (archiver, arflags, ranlib) in self.generateArchiverGuesses():\n      if not self.checkCompile('', 'int foo(int a) {\\n  return a+1;\\n}\\n\\n', cleanup = 0, codeBegin = '', codeEnd = ''):\n        raise RuntimeError('Compiler is not functional')\n      if os.path.isfile(objName):\n        os.remove(objName)\n      os.rename(self.compilerObj, objName)\n      if self.getExecutable(archiver, getFullPath = 1, resultName = 'AR'):\n        if self.getExecutable(ranlib, getFullPath = 1, resultName = 'RANLIB'):\n          arext = 'a'\n          try:\n            (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+arflags+' '+arcUnix+' '+objName, checkCommand = checkArchive, log = self.log)\n            (output, error, status) = config.base.Configure.executeShellCommand(self.RANLIB+' '+arcUnix, checkCommand = checkRanlib, log = self.log)\n          except RuntimeError, e:\n            self.logPrint(str(e))\n            continue\n          self.LIBS = '-L'+self.tmpDir+' -lconf1 ' + oldLibs\n          success =  self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n          os.rename(arcUnix, arcWindows)\n          if not success:\n            arext = 'lib'\n            success = self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n            os.remove(arcWindows)\n            if success:\n              break\n          else:\n            os.remove(arcWindows)\n            break\n    else:\n      if os.path.isfile(objName):\n        os.remove(objName)\n      self.LIBS = oldLibs\n      self.popLanguage()\n      raise RuntimeError('Could not find a suitable archiver.  Use --with-ar to specify an archiver.')\n    self.AR_FLAGS      = arflags\n    self.AR_LIB_SUFFIX = arext\n    self.framework.addMakeMacro('AR_FLAGS', self.AR_FLAGS)\n    self.addMakeMacro('AR_LIB_SUFFIX', self.AR_LIB_SUFFIX)\n    os.remove(objName)\n    self.LIBS = oldLibs\n    self.popLanguage()\n    return\n\n  def setStaticLinker(self):\n    language = self.language[-1]\n    return self.framework.setSharedLinkerObject(language, self.framework.getLanguageModule(language).StaticLinker(self.argDB))\n\n  def generateSharedLinkerGuesses(self):\n    if not self.argDB['with-shared-libraries']:\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n      raise RuntimeError('Archiver failed static link check')\n    if 'with-shared-ld' in self.argDB:\n      yield (self.argDB['with-shared-ld'], [], 'so')\n    if 'LD_SHARED' in self.argDB:\n      yield (self.argDB['LD_SHARED'], [], 'so')\n    if Configure.isDarwin(self.log):\n      if 'with-shared-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], '-no_compact_unwind', 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      # C++ compiler default\n      yield (self.CXX, ['-shared'], 'so')\n      yield (self.CXX, ['-dynamic'], 'so')\n    # C compiler default\n    yield (self.CC, ['-shared'], 'so')\n    yield (self.CC, ['-dynamic'], 'so')\n    yield (self.CC, ['-qmkshrobj'], 'so')\n    yield (self.CC, ['-shared'], 'dll')\n    # Solaris default\n    if Configure.isSolaris(self.log):\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-G'], 'so')\n      yield (self.CC, ['-G'], 'so')\n    # If user does not explicitly enable shared-libraries - disable shared libraries and default to static linker\n    if not 'with-shared-libraries' in self.framework.clArgDB:\n      self.argDB['with-shared-libraries'] = 0\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n    raise RuntimeError('Exhausted all shared linker guesses. Could not determine how to create a shared library!')\n\n  def checkSharedLinker(self):\n    '''Check that the linker can produce shared libraries'''\n    self.sharedLibraries = 0\n    self.staticLibraries = 0\n    for linker, flags, ext in self.generateSharedLinkerGuesses():\n      self.logPrint('Checking shared linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'LD_SHARED'):\n        for picFlag in self.generatePICGuesses():\n          self.logPrint('Trying '+self.language[-1]+' compiler flag '+picFlag)\n          compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n          oldCompilerFlags = getattr(self, compilerFlagsArg)\n          accepted = 1\n          try:\n            self.addCompilerFlag(picFlag,compilerOnly=1)\n          except RuntimeError:\n            accepted = 0\n          if accepted:\n            goodFlags = filter(self.checkLinkerFlag, flags)\n            testMethod = 'foo'\n            self.sharedLinker = self.LD_SHARED\n            self.sharedLibraryFlags = goodFlags\n            self.sharedLibraryExt = ext\n            # using printf appears to correctly identify non-pic code on X86_64\n            if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {fprintf(stdout,\"hello\");\\nreturn 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 1):\n              oldLib  = self.linkerObj\n              oldLibs = self.LIBS\n              self.LIBS += ' -L'+self.tmpDir+' -lconftest'\n              accepted = self.checkLink(includes = 'int foo(void);', body = 'int ret = foo();\\nif(ret);')\n              os.remove(oldLib)\n              self.LIBS = oldLibs\n              if accepted:\n                self.sharedLibraries = 1\n                self.logPrint('Using shared linker '+self.sharedLinker+' with flags '+str(self.sharedLibraryFlags)+' and library extension '+self.sharedLibraryExt)\n                break\n          self.logPrint('Rejected '+self.language[-1]+' compiler flag '+picFlag+' because it was not compatible with shared linker '+linker+' using flags '+str(flags))\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        if self.sharedLibraries: break\n        self.delMakeMacro('LD_SHARED')\n        del self.LD_SHARED\n        del self.sharedLinker\n    return\n\n  def checkLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag'''\n    flagsArg = self.getLinkerFlagsArg()\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, status) = self.outputLink('', '')\n    valid = 1\n    if status:\n      valid = 0\n      self.logPrint('Rejecting linker flag '+flag+' due to nonzero status from link')\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting '+self.language[-1]+' linker flag '+flag+' due to \\n'+output)\n    if valid:\n      self.logPrint('Valid '+self.language[-1]+' linker flag '+flag)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def addLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkLinkerFlag(flag):\n      flagsArg = self.getLinkerFlagsArg()\n      setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n      return\n    raise RuntimeError('Bad linker flag: '+flag)\n\n  def checkLinkerMac(self):\n    '''Tests some Apple Mac specific linker flags'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Wl,-multiply_defined,suppress', '-Wl,-multiply_defined -Wl,suppress', '-Wl,-commons,use_dylibs', '-Wl,-search_paths_first', '-Wl,-no_compact_unwind']:\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n\t  linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n\t  val.append(testFlag)\n\t  setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkSharedLinkerPaths(self):\n    '''Determine the shared linker path options\n       - IRIX: -rpath\n       - Linux, OSF: -Wl,-rpath,\n       - Solaris: -R\n       - FreeBSD: -Wl,-R,'''\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      flag = '-L'\n      self.pushLanguage(language)\n      # test '-R' before '-rpath' as sun compilers [c,fortran] don't give proper errors with wrong options.\n      if not Configure.isDarwin(self.log):\n        testFlags = ['-Wl,-rpath,', '-R','-rpath ' , '-Wl,-R,']\n      else:\n        testFlags = ['-Wl,-rpath,']\n      # test '-R' before '-Wl,-rpath' for SUN compilers [as cc on linux accepts -Wl,-rpath, but  f90 & CC do not.\n      if self.isSun(self.framework.getCompiler(), self.log):\n        testFlags.insert(0,'-R')\n      for testFlag in testFlags:\n        self.logPrint('Trying '+language+' linker flag '+testFlag)\n        if self.checkLinkerFlag(testFlag+os.path.abspath(os.getcwd())):\n          flag = testFlag\n          break\n        else:\n          self.logPrint('Rejected '+language+' linker flag '+testFlag)\n      self.popLanguage()\n      setattr(self, language+'SharedLinkerFlag', flag)\n    return\n\n  def checkLibC(self):\n    '''Test whether we need to explicitly include libc in shared linking\n       - Mac OSX requires an explicit reference to libc for shared linking'''\n    self.explicitLibc = None\n    if self.staticLibraries:\n      return\n    tmpCompilerDefines   = self.compilerDefines\n    self.compilerDefines = ''\n    code = '#include <stdlib.h> \\nint foo(void) {void *chunk = malloc(31); free(chunk); return 0;}\\n'\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking does not require an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      return\n    oldLibs = self.LIBS\n    self.LIBS += '-lc '\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking requires an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      self.explicitLibc = ['libc.so']\n      return\n    self.LIBS = oldLibs\n    self.compilerDefines = tmpCompilerDefines\n    self.logPrint('*** WARNING *** Shared linking may not function on this architecture')\n    self.staticLibrary=1\n    self.sharedLibrary=0\n\n  def generateDynamicLinkerGuesses(self):\n    if 'with-dynamic-ld' in self.argDB:\n      yield (self.argDB['with-dynamic-ld'], [], 'so')\n    # Mac OSX\n    if Configure.isDarwin(self.log):\n      if 'with-dynamic-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      #yield ('libtool', ['-noprebind','-dynamic','-single_module','-flat_namespace -undefined warning','-multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n#        yield (\"g++\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n#      yield (\"gcc\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n    # Shared default\n    if hasattr(self, 'sharedLinker'):\n      yield (self.sharedLinker, self.sharedLibraryFlags, 'so')\n    # C++ Compiler default\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      yield (self.CXX, ['-shared'], 'so')\n    # C Compiler default\n    yield (self.CC, ['-shared'], 'so')\n    self.logPrint('Unable to find working dynamic linker')\n\n  def checkDynamicLinker(self):\n    '''Check that the linker can dynamicaly load shared libraries'''\n    self.dynamicLibraries = 0\n    self.headers.saveLog()\n    if not self.headers.check('dlfcn.h'):\n      self.logWrite(self.headers.restoreLog())\n      self.logPrint('Dynamic loading disabled since dlfcn.h was missing')\n      return\n    self.logWrite(self.headers.restoreLog())\n    self.libraries.saveLog()\n    if not self.libraries.add('dl', ['dlopen', 'dlsym', 'dlclose']):\n      if not self.libraries.check('', ['dlopen', 'dlsym', 'dlclose']):\n        self.logWrite(self.libraries.restoreLog())\n        self.logPrint('Dynamic linking disabled since functions dlopen(), dlsym(), and dlclose() were not found')\n        return\n    self.logWrite(self.libraries.restoreLog())\n    for linker, flags, ext in self.generateDynamicLinkerGuesses():\n      self.logPrint('Checking dynamic linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'dynamicLinker'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = filter(self.checkLinkerFlag, flags)\n        self.dynamicLibraryFlags = goodFlags\n        self.dynamicLibraryExt = ext\n        testMethod = 'foo'\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"test\");return 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 'dynamic'):\n          oldLib  = self.linkerObj\n          code = '''\nvoid *handle = dlopen(\"%s\", 0);\nint (*foo)(void) = (int (*)(void)) dlsym(handle, \"foo\");\n\nif (!foo) {\n  printf(\"Could not load symbol\\\\n\");\n  return -1;\n}\nif ((*foo)()) {\n  printf(\"Invalid return from foo()\\\\n\");\n  return -1;\n}\nif (dlclose(handle)) {\n  printf(\"Could not close library\\\\n\");\n  return -1;\n}\n''' % oldLib\n          if self.checkLink(includes = '#include<dlfcn.h>', body = code):\n            os.remove(oldLib)\n            self.dynamicLibraries = 1\n            self.logPrint('Using dynamic linker '+self.dynamicLinker+' with flags '+str(self.dynamicLibraryFlags)+' and library extension '+self.dynamicLibraryExt)\n            break\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        del self.dynamicLinker\n    return\n\n  def output(self):\n    '''Output module data as defines and substitutions'''\n    if hasattr(self, 'CC'):\n      self.addSubstitution('CC', self.CC)\n      self.addSubstitution('CFLAGS', self.CFLAGS)\n      self.addMakeMacro('CC_LINKER_SLFLAG', self.CSharedLinkerFlag)\n    if hasattr(self, 'CPP'):\n      self.addSubstitution('CPP', self.CPP)\n      self.addSubstitution('CPPFLAGS', self.CPPFLAGS)\n    if hasattr(self, 'CUDAC'):\n      self.addSubstitution('CUDAC', self.CUDAC)\n      self.addSubstitution('CUDAFLAGS', self.CUDAFLAGS)\n    if hasattr(self, 'CUDAPP'):\n      self.addSubstitution('CUDAPP', self.CUDAPP)\n      self.addSubstitution('CUDAPPFLAGS', self.CUDAPPFLAGS)\n    if hasattr(self, 'CXX'):\n      self.addSubstitution('CXX', self.CXX)\n      self.addSubstitution('CXX_CXXFLAGS', self.CXX_CXXFLAGS)\n      self.addSubstitution('CXXFLAGS', self.CXXFLAGS)\n      self.addSubstitution('CXX_LINKER_SLFLAG', self.CxxSharedLinkerFlag)\n    else:\n      self.addSubstitution('CXX', '')\n    if hasattr(self, 'CXXCPP'):\n      self.addSubstitution('CXXCPP', self.CXXCPP)\n      self.addSubstitution('CXXCPPFLAGS', self.CXXCPPFLAGS)\n    if hasattr(self, 'FC'):\n      self.addSubstitution('FC', self.FC)\n      self.addSubstitution('FFLAGS', self.FFLAGS)\n      self.addMakeMacro('FC_LINKER_SLFLAG', self.FCSharedLinkerFlag)\n    else:\n      self.addSubstitution('FC', '')\n    self.addSubstitution('LDFLAGS', self.LDFLAGS)\n    self.addSubstitution('LIBS', self.LIBS)\n    if hasattr(self, 'sharedLibraryFlags'):\n      self.addSubstitution('SHARED_LIBRARY_FLAG', ' '.join(self.sharedLibraryFlags))\n    else:\n      self.addSubstitution('SHARED_LIBRARY_FLAG','')\n    return\n\n  def updateMPICompilers(self, mpicc, mpicxx, mpifc):\n    '''Reset compilers by an external module aka MPI'''\n    self.CC = mpicc\n    self.delMakeMacro(\"CC\")\n\n    if hasattr(self, 'CXX'):\n      self.CXX = mpicxx\n      self.delMakeMacro(\"CXX\")\n\n    if hasattr(self, 'FC'):\n      self.FC = mpifc\n      self.delMakeMacro(\"FC\")\n\n    self.configure()\n    self.usedMPICompilers=1\n    return\n\n  def checkMPICompilerOverride(self):\n    '''Check if --with-mpi-dir is used along with CC CXX or FC compiler options.\n    This usually prevents mpi compilers from being used - so issue a warning'''\n\n    if 'with-mpi-dir' in self.argDB and self.argDB['with-mpi-compilers']:\n      optcplrs = [(['with-cc','CC'],['mpicc','mpcc','hcc','mpcc_r']),\n              (['with-fc','FC'],['mpif90','mpif77','mpxlf95_r','mpxlf90_r','mpxlf_r','mpf90','mpf77']),\n              (['with-cxx','CXX'],['mpicxx','hcp','mpic++','mpiCC','mpCC_r'])]\n      for opts,cplrs in optcplrs:\n        for opt in opts:\n          if (opt in self.argDB  and self.argDB[opt] != '0'):\n            # check if corresponding mpi wrapper exists\n            for cplr in cplrs:\n              mpicplr = os.path.join(self.argDB['with-mpi-dir'], 'bin', cplr)\n              if os.path.exists(mpicplr):\n                msg = '--'+opt+'='+self.argDB[opt]+' is specified with --with-mpi-dir='+self.argDB['with-mpi-dir']+'. However '+mpicplr+' exists and should be the prefered compiler! Suggest not specifying --'+opt+' option so that configure can use '+ mpicplr +' instead.'\n                raise RuntimeError(msg)\n    return\n\n  def requireMpiLdPath(self):\n    '''OpenMPI wrappers require LD_LIBRARY_PATH set'''\n    if 'with-mpi-dir' in self.argDB:\n      libdir = os.path.join(self.argDB['with-mpi-dir'], 'lib')\n      if os.path.exists(os.path.join(libdir,'libopen-rte.so')):\n        Configure.addLdPath(libdir)\n        self.logPrint('Adding to LD_LIBRARY_PATH '+libdir)\n    return\n\n  def printEnvVariables(self):\n    buf = '**** printenv ****'\n    for key,val in os.environ.iteritems():\n      buf += '\\n'+str(key)+'='+str(val)\n    self.logPrint(buf)\n    return\n\n  def resetEnvCompilers(self):\n    ignoreEnvCompilers = ['CC','CXX','FC','F77','F90']\n    for envVal in ignoreEnvCompilers:\n      if envVal in os.environ:\n        if self.framework.clArgDB.has_key(envVal) or self.framework.clArgDB.has_key('with-'+envVal.lower()):\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables ******')\n        elif self.framework.argDB['with-xsdk-defaults'] and not self.framework.clArgDB.has_key('with-environment-variables'):\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n because --with-xsdk-defaults was selected. Add --disable-environment-variables \\n to NOT use the environmental variables ******')\n\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n\n    ignoreEnv = ['CFLAGS','CXXFLAGS','FCFLAGS','FFLAGS','F90FLAGS','CPP','CPPFLAGS','CXXCPP','CXXCPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n    for envVal in ignoreEnv:\n      if envVal in os.environ:\n        if self.framework.clArgDB.has_key(envVal):\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables******')\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n    return\n\n\n  def checkEnvCompilers(self):\n    if self.framework.clArgDB.has_key('with-environment-variables') or self.framework.clArgDB.has_key('with-xsdk-defaults'):\n      envVarChecklist = ['CC','CFLAGS','CXX','CXXFLAGS','FC','FCFLAGS','F77','FFLAGS','F90','F90FLAGS','CPP','CPPFLAGS','CXXCPP','CXXCPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n      for ev in envVarChecklist:\n        if ev in os.environ:\n          self.argDB[ev] = os.environ[ev]\n\n    # abort if FCFLAGS and FFLAGS both set, but to different values\n    if self.argDB.has_key('FFLAGS') and self.argDB.has_key('FCFLAGS'):\n      if self.argDB['FCFLAGS'] != self.argDB['FFLAGS']:\n        raise RuntimeError('FCFLAGS and FFLAGS are both set, but with different values (FCFLAGS=%s, FFLAGS=%s)'%(self.argDB['FCFLAGS'],self.argDB['FFLAGS']))\n    return\n\n  def checkIntoShared(self,symbol,lib):\n    '''Check that a given library can be linked into a shared library'''\n    import sys\n    if not self.checkCompile(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}'):\n      raise RuntimeError('Unable to compile test file with symbol: '+symbol)\n    oldLibs = self.LIBS\n    self.LIBS = self.libraries.toStringNoDupes(lib) + ' '+self.LIBS\n    ret = self.checkLink(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}',shared =1)\n    self.LIBS = oldLibs\n    return ret\n\n  def configure(self):\n    self.executeTest(self.printEnvVariables)\n    self.executeTest(self.resetEnvCompilers)\n    self.executeTest(self.checkEnvCompilers)\n    self.executeTest(self.checkMPICompilerOverride)\n    self.executeTest(self.requireMpiLdPath)\n    self.executeTest(self.checkVendor)\n    self.executeTest(self.checkInitialFlags)\n    self.executeTest(self.checkCCompiler)\n    self.executeTest(self.checkCPreprocessor)\n    self.executeTest(self.checkCUDACompiler)\n    self.executeTest(self.checkCUDAPreprocessor)\n    self.executeTest(self.checkCxxCompiler)\n    if hasattr(self, 'CXX'):\n      self.executeTest(self.checkCxxPreprocessor)\n    self.executeTest(self.checkFortranCompiler)\n    if hasattr(self, 'FC'):\n      self.executeTest(self.checkFortranComments)\n    self.executeTest(self.checkLargeFileIO)\n    self.executeTest(self.checkArchiver)\n    self.executeTest(self.checkSharedLinker)\n    if Configure.isDarwin(self.log):\n      self.executeTest(self.checkLinkerMac)\n    self.executeTest(self.checkPIC)\n    self.executeTest(self.checkSharedLinkerPaths)\n    self.executeTest(self.checkLibC)\n    self.executeTest(self.checkDynamicLinker)\n    self.executeTest(self.output)\n    return\n\n  def no_configure(self):\n    if self.staticLibraries:\n      self.setStaticLinker()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/sys/dll/dlimpl.c.html": "<center><a href=\"dlimpl.c\">Actual source code: dlimpl.c</a></center><br>\n\n<html>\n<head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/sys/dll/dlimpl.c.html\" />\n<title></title>\n<meta name=\"generator\" content=\"c2html 0.9.4\">\n<meta name=\"date\" content=\"2017-04-24T13:52:54+00:00\">\n</head>\n\n<body bgcolor=\"#FFFFFF\">\n   <div id=\"version\" align=right><b>petsc-3.7.6 2017-04-24</b></div>\n   <div id=\"bugreport\" align=right><a href=\"mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.7.6 v3.7.6 src/sys/dll/dlimpl.c.html \"><small>Report Typos and Errors</small></a></div>\n<pre width=\"80\">\n<a name=\"line2\">  2: </a><font color=\"#B22222\">/*</font>\n<a name=\"line3\">  3: </a><font color=\"#B22222\">   Low-level routines for managing dynamic link libraries (DLLs).</font>\n<a name=\"line4\">  4: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line6\">  6: </a><font color=\"#A020F0\">#include &lt;petsc/private/petscimpl.h&gt;</font>\n<a name=\"line7\">  7: </a><font color=\"#A020F0\">#include &lt;petscvalgrind.h&gt;</font>\n\n<a name=\"line9\">  9: </a><font color=\"#B22222\">/* XXX Should be done better !!!*/</font>\n<a name=\"line10\"> 10: </a><font color=\"#A020F0\">#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line11\"> 11: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_WINDOWS_H</font></strong>\n<a name=\"line12\"> 12: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_DLFCN_H</font></strong>\n<a name=\"line13\"> 13: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line15\"> 15: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line16\"> 16: </a><font color=\"#A020F0\">#include &lt;windows.h&gt;</font>\n<a name=\"line17\"> 17: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line18\"> 18: </a><font color=\"#A020F0\">#include &lt;dlfcn.h&gt;</font>\n<a name=\"line19\"> 19: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line21\"> 21: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line22\"> 22: </a><font color=\"#4169E1\">typedef HMODULE dlhandle_t;</font>\n<a name=\"line23\"> 23: </a><font color=\"#4169E1\">typedef FARPROC dlsymbol_t;</font>\n<a name=\"line24\"> 24: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line25\"> 25: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line26\"> 26: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line27\"> 27: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line28\"> 28: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line29\"> 29: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line30\"> 30: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line34\"> 34: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line35\"> 35: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a> - opens dynamic library</font>\n\n<a name=\"line37\"> 37: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line39\"> 39: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line40\"> 40: </a><font color=\"#B22222\">+    name - name of library</font>\n<a name=\"line41\"> 41: </a><font color=\"#B22222\">-    mode - options on how to open library</font>\n\n<a name=\"line43\"> 43: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line44\"> 44: </a><font color=\"#B22222\">.    handle</font>\n\n<a name=\"line46\"> 46: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line48\"> 48: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line49\"> 49: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLOpen\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>(const char name[],PetscDLMode mode,PetscDLHandle *handle)</font></strong>\n<a name=\"line50\"> 50: </a>{\n<a name=\"line51\"> 51: </a>  PETSC_UNUSED int dlflags1,dlflags2; <font color=\"#B22222\">/* There are some preprocessor paths where these variables are set, but not used */</font>\n<a name=\"line52\"> 52: </a>  dlhandle_t       dlhandle;\n\n\n<a name=\"line58\"> 58: </a>  dlflags1 = 0;\n<a name=\"line59\"> 59: </a>  dlflags2 = 0;\n<a name=\"line60\"> 60: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line61\"> 61: </a>  *handle  = (PetscDLHandle) 0;\n\n<a name=\"line63\"> 63: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line64\"> 64: </a><font color=\"#B22222\">     --- LoadLibrary ---</font>\n<a name=\"line65\"> 65: </a><font color=\"#B22222\">  */</font>\n<a name=\"line66\"> 66: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H) &amp;&amp; defined(PETSC_HAVE_LOADLIBRARY)</font>\n<a name=\"line67\"> 67: </a>  dlhandle = LoadLibrary(name);\n<a name=\"line68\"> 68: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line69\"> 69: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line71\"> 71: </a>    DWORD          erc;\n<a name=\"line72\"> 72: </a>    char           *buff = NULL;\n<a name=\"line73\"> 73: </a>    erc = GetLastError();\n<a name=\"line74\"> 74: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n<a name=\"line75\"> 75: </a>                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line76\"> 76: </a>    <a href=\"../../../docs/manualpages/Sys/PetscError.html#PetscError\">PetscError</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,__LINE__,__FUNCT__,__FILE__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n<a name=\"line77\"> 77: </a>                      <font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,buff);\n<a name=\"line78\"> 78: </a>    LocalFree(buff);\n<a name=\"line79\"> 79: </a>    <a href=\"../../../docs/manualpages/Sys/PetscFunctionReturn.html#PetscFunctionReturn\">PetscFunctionReturn</a>(ierr);\n<a name=\"line80\"> 80: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line81\"> 81: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line82\"> 82: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line83\"> 83: </a>  }\n\n<a name=\"line85\"> 85: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line86\"> 86: </a><font color=\"#B22222\">     --- dlopen ---</font>\n<a name=\"line87\"> 87: </a><font color=\"#B22222\">  */</font>\n<a name=\"line88\"> 88: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H) &amp;&amp; defined(PETSC_HAVE_DLOPEN)</font>\n<a name=\"line89\"> 89: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line90\"> 90: </a><font color=\"#B22222\">      Mode indicates symbols required by symbol loaded with dlsym()</font>\n<a name=\"line91\"> 91: </a><font color=\"#B22222\">     are only loaded when required (not all together) also indicates</font>\n<a name=\"line92\"> 92: </a><font color=\"#B22222\">     symbols required can be contained in other libraries also opened</font>\n<a name=\"line93\"> 93: </a><font color=\"#B22222\">     with dlopen()</font>\n<a name=\"line94\"> 94: </a><font color=\"#B22222\">  */</font>\n<a name=\"line95\"> 95: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line96\"> 96: </a>  dlflags1 = RTLD_LAZY;\n<a name=\"line97\"> 97: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line98\"> 98: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line99\"> 99: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n<a name=\"line100\">100: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line101\">101: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line102\">102: </a>  dlflags2 = RTLD_GLOBAL;\n<a name=\"line103\">103: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line104\">104: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line105\">105: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n<a name=\"line106\">106: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line107\">107: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line108\">108: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line109\">109: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line110\">110: </a>  dlhandle = dlopen(name,dlflags1|dlflags2);\n<a name=\"line111\">111: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line112\">112: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line113\">113: </a>    const char *errmsg = dlerror();\n<a name=\"line114\">114: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line115\">115: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line116\">116: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line117\">117: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\"</font>,name,errmsg);\n<a name=\"line118\">118: </a>  }\n\n<a name=\"line120\">120: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line121\">121: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line122\">122: </a><font color=\"#B22222\">  */</font>\n<a name=\"line123\">123: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line124\">124: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line125\">125: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line127\">127: </a>  *handle = (PetscDLHandle) dlhandle;\n<a name=\"line128\">128: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line129\">129: </a>}\n\n\n<a name=\"line134\">134: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line135\">135: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a> -  closes a dynamic library</font>\n\n<a name=\"line137\">137: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line139\">139: </a><font color=\"#B22222\">  Input Parameter:</font>\n<a name=\"line140\">140: </a><font color=\"#B22222\">.   handle - the handle for the library obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>()</font>\n\n<a name=\"line142\">142: </a><font color=\"#B22222\">  Level: developer</font>\n<a name=\"line143\">143: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line144\">144: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLClose\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a>(PetscDLHandle *handle)</font></strong>\n<a name=\"line145\">145: </a>{\n\n\n<a name=\"line150\">150: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line151\">151: </a><font color=\"#B22222\">     --- FreeLibrary ---</font>\n<a name=\"line152\">152: </a><font color=\"#B22222\">  */</font>\n<a name=\"line153\">153: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line154\">154: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_FREELIBRARY)</font>\n<a name=\"line155\">155: </a>  <font color=\"#4169E1\">if</font> (FreeLibrary((dlhandle_t)*handle) == 0) {\n<a name=\"line156\">156: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line157\">157: </a>    char  *buff = NULL;\n<a name=\"line158\">158: </a>    DWORD erc   = GetLastError();\n<a name=\"line159\">159: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line160\">160: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,buff);\n<a name=\"line161\">161: </a>    LocalFree(buff);\n<a name=\"line162\">162: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line163\">163: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line164\">164: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line165\">165: </a>  }\n<a name=\"line166\">166: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_FREELIBRARY */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line168\">168: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line169\">169: </a><font color=\"#B22222\">     --- dclose ---</font>\n<a name=\"line170\">170: </a><font color=\"#B22222\">  */</font>\n<a name=\"line171\">171: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line172\">172: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLCLOSE)</font>\n<a name=\"line173\">173: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line174\">174: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line175\">175: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line176\">176: </a>  <font color=\"#4169E1\">if</font> (dlclose((dlhandle_t)*handle) &lt; 0) {\n<a name=\"line177\">177: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line178\">178: </a>    const char *errmsg = dlerror();\n<a name=\"line179\">179: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line180\">180: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line181\">181: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line182\">182: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\"</font>, errmsg);\n<a name=\"line183\">183: </a>  }\n<a name=\"line184\">184: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_DLCLOSE */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line186\">186: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line187\">187: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line188\">188: </a><font color=\"#B22222\">  */</font>\n<a name=\"line189\">189: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line190\">190: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line191\">191: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line193\">193: </a>  *handle = NULL;\n<a name=\"line194\">194: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line195\">195: </a>}\n\n<a name=\"line199\">199: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line200\">200: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a> - finds a symbol in a dynamic library</font>\n\n<a name=\"line202\">202: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line204\">204: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line205\">205: </a><font color=\"#B22222\">+   handle - obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>() or NULL</font>\n<a name=\"line206\">206: </a><font color=\"#B22222\">-   symbol - name of symbol</font>\n\n<a name=\"line208\">208: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line209\">209: </a><font color=\"#B22222\">.   value - pointer to the function, NULL if not found</font>\n\n<a name=\"line211\">211: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line213\">213: </a><font color=\"#B22222\">  Notes:</font>\n<a name=\"line214\">214: </a><font color=\"#B22222\">   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.</font>\n<a name=\"line215\">215: </a><font color=\"#B22222\">   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like</font>\n<a name=\"line216\">216: </a><font color=\"#B22222\">   systems this requires platform-specific linker flags.</font>\n\n<a name=\"line218\">218: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line219\">219: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLSym\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a>(PetscDLHandle handle,const char symbol[],void **value)</font></strong>\n<a name=\"line220\">220: </a>{\n<a name=\"line221\">221: </a>  PETSC_UNUSED dlhandle_t dlhandle;\n<a name=\"line222\">222: </a>  dlsymbol_t              dlsymbol;\n\n\n<a name=\"line227\">227: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line228\">228: </a>  dlsymbol = (dlsymbol_t) 0;\n<a name=\"line229\">229: </a>  *value   = (void*) 0;\n\n<a name=\"line231\">231: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line232\">232: </a><font color=\"#B22222\">     --- GetProcAddress ---</font>\n<a name=\"line233\">233: </a><font color=\"#B22222\">  */</font>\n<a name=\"line234\">234: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line235\">235: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETPROCADDRESS)</font>\n<a name=\"line236\">236: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line237\">237: </a>  <font color=\"#4169E1\">else</font> dlhandle = (dlhandle_t) GetCurrentProcess();\n<a name=\"line238\">238: </a>  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n<a name=\"line239\">239: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_SETLASTERROR)</font>\n<a name=\"line240\">240: </a>  SetLastError((DWORD)0); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line241\">241: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line242\">242: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_GETPROCADDRESS */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line244\">244: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line245\">245: </a><font color=\"#B22222\">     --- dlsym ---</font>\n<a name=\"line246\">246: </a><font color=\"#B22222\">  */</font>\n<a name=\"line247\">247: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line248\">248: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLSYM)</font>\n<a name=\"line249\">249: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line250\">250: </a>  <font color=\"#4169E1\">else</font> {\n\n<a name=\"line252\">252: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLOPEN) &amp;&amp; defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line253\">253: </a>    <font color=\"#B22222\">/* Attempt to retrieve the main executable's dlhandle. */</font>\n<a name=\"line254\">254: </a>    { int dlflags1 = 0, dlflags2 = 0;\n<a name=\"line255\">255: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line256\">256: </a>      dlflags1 = RTLD_LAZY;\n<a name=\"line257\">257: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line258\">258: </a>      <font color=\"#4169E1\">if</font> (!dlflags1) {\n<a name=\"line259\">259: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line260\">260: </a>        dlflags1 = RTLD_NOW;\n<a name=\"line261\">261: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line262\">262: </a>      }\n<a name=\"line263\">263: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line264\">264: </a>      dlflags2 = RTLD_LOCAL;\n<a name=\"line265\">265: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line266\">266: </a>      <font color=\"#4169E1\">if</font> (!dlflags2) {\n<a name=\"line267\">267: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line268\">268: </a>        dlflags2 = RTLD_GLOBAL;\n<a name=\"line269\">269: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line270\">270: </a>      }\n<a name=\"line271\">271: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line272\">272: </a>      <font color=\"#4169E1\">if</font> (!(PETSC_RUNNING_ON_VALGRIND)) {\n<a name=\"line273\">273: </a>        dlerror(); <font color=\"#B22222\">/* clear any previous error; valgrind does not like this */</font>\n<a name=\"line274\">274: </a>      }\n<a name=\"line275\">275: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line276\">276: </a>      <font color=\"#B22222\">/* Attempt to open the main executable as a dynamic library. */</font>\n<a name=\"line277\">277: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTDL_DEFAULT)</font>\n<a name=\"line278\">278: </a>      dlhandle = RTLD_DEFAULT;\n<a name=\"line279\">279: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line280\">280: </a>      dlhandle = dlopen(0, dlflags1|dlflags2);\n<a name=\"line281\">281: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line282\">282: </a>      { const char *e = (const char*) dlerror();\n<a name=\"line283\">283: </a>        <font color=\"#4169E1\">if</font> (e) <a href=\"../../../docs/manualpages/Sys/SETERRQ1.html#SETERRQ1\">SETERRQ1</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>, PETSC_ERR_ARG_WRONG, <font color=\"#666666\">\"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\"</font>, e);\n<a name=\"line284\">284: </a>      }\n<a name=\"line285\">285: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line286\">286: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line287\">287: </a>    }\n<a name=\"line288\">288: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line289\">289: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* PETSC_HAVE_DLOPEN &amp;&amp; PETSC_HAVE_DYNAMIC_LIBRARIES */</font><font color=\"#A020F0\"></font>\n<a name=\"line290\">290: </a>  }\n<a name=\"line291\">291: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line292\">292: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line293\">293: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line294\">294: </a>  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n<a name=\"line295\">295: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line296\">296: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line297\">297: </a><font color=\"#B22222\">  */</font>\n<a name=\"line298\">298: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line299\">299: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line300\">300: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line302\">302: </a>  *value = *((void**)&amp;dlsymbol);\n\n<a name=\"line304\">304: </a><font color=\"#A020F0\">#if defined(PETSC_SERIALIZE_FUNCTIONS)</font>\n<a name=\"line305\">305: </a>  <font color=\"#4169E1\">if</font> (*value) {\n<a name=\"line307\">307: </a>    PetscFPTAdd(*value,symbol);\n<a name=\"line308\">308: </a>  }\n<a name=\"line309\">309: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line310\">310: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line311\">311: </a>}\n</pre>\n</body>\n\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/sys/dll/dlimpl.c": "\n/*\n   Low-level routines for managing dynamic link libraries (DLLs).\n*/\n\n#include <petsc/private/petscimpl.h>\n#include <petscvalgrind.h>\n\n/* XXX Should be done better !!!*/\n#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n#undef PETSC_HAVE_WINDOWS_H\n#undef PETSC_HAVE_DLFCN_H\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\n#include <windows.h>\n#elif defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\ntypedef HMODULE dlhandle_t;\ntypedef FARPROC dlsymbol_t;\n#elif defined(PETSC_HAVE_DLFCN_H)\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#else\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#endif\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLOpen\"\n/*@C\n   PetscDLOpen - opens dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+    name - name of library\n-    mode - options on how to open library\n\n   Output Parameter:\n.    handle\n\n   Level: developer\n\n@*/\nPetscErrorCode  PetscDLOpen(const char name[],PetscDLMode mode,PetscDLHandle *handle)\n{\n  PETSC_UNUSED int dlflags1,dlflags2; /* There are some preprocessor paths where these variables are set, but not used */\n  dlhandle_t       dlhandle;\n\n  PetscFunctionBegin;\n  PetscValidCharPointer(name,1);\n  PetscValidPointer(handle,3);\n\n  dlflags1 = 0;\n  dlflags2 = 0;\n  dlhandle = (dlhandle_t) 0;\n  *handle  = (PetscDLHandle) 0;\n\n  /*\n     --- LoadLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H) && defined(PETSC_HAVE_LOADLIBRARY)\n  dlhandle = LoadLibrary(name);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    PetscErrorCode ierr;\n    DWORD          erc;\n    char           *buff = NULL;\n    erc = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    ierr = PetscError(PETSC_COMM_SELF,__LINE__,__FUNCT__,__FILE__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n                      \"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,buff);\n    LocalFree(buff);\n    PetscFunctionReturn(ierr);\n#else\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,\"unavailable\");\n#endif\n  }\n\n  /*\n     --- dlopen ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H) && defined(PETSC_HAVE_DLOPEN)\n  /*\n      Mode indicates symbols required by symbol loaded with dlsym()\n     are only loaded when required (not all together) also indicates\n     symbols required can be contained in other libraries also opened\n     with dlopen()\n  */\n#if defined(PETSC_HAVE_RTLD_LAZY)\n  dlflags1 = RTLD_LAZY;\n#endif\n#if defined(PETSC_HAVE_RTLD_NOW)\n  if (mode & PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n#endif\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n  dlflags2 = RTLD_GLOBAL;\n#endif\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n  if (mode & PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n#endif\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlhandle = dlopen(name,dlflags1|dlflags2);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\",name,errmsg);\n  }\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = (PetscDLHandle) dlhandle;\n  PetscFunctionReturn(0);\n}\n\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLClose\"\n/*@C\n   PetscDLClose -  closes a dynamic library\n\n   Not Collective\n\n  Input Parameter:\n.   handle - the handle for the library obtained with PetscDLOpen()\n\n  Level: developer\n@*/\nPetscErrorCode  PetscDLClose(PetscDLHandle *handle)\n{\n\n  PetscFunctionBegin;\n  PetscValidPointer(handle,1);\n\n  /*\n     --- FreeLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_FREELIBRARY)\n  if (FreeLibrary((dlhandle_t)*handle) == 0) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    char  *buff = NULL;\n    DWORD erc   = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",buff);\n    LocalFree(buff);\n#else\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",\"unavailable\");\n#endif\n  }\n#endif /* !PETSC_HAVE_FREELIBRARY */\n\n  /*\n     --- dclose ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLCLOSE)\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  if (dlclose((dlhandle_t)*handle) < 0) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\", errmsg);\n  }\n#endif /* !PETSC_HAVE_DLCLOSE */\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = NULL;\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLSym\"\n/*@C\n   PetscDLSym - finds a symbol in a dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+   handle - obtained with PetscDLOpen() or NULL\n-   symbol - name of symbol\n\n   Output Parameter:\n.   value - pointer to the function, NULL if not found\n\n   Level: developer\n\n  Notes:\n   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.\n   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like\n   systems this requires platform-specific linker flags.\n\n@*/\nPetscErrorCode  PetscDLSym(PetscDLHandle handle,const char symbol[],void **value)\n{\n  PETSC_UNUSED dlhandle_t dlhandle;\n  dlsymbol_t              dlsymbol;\n\n  PetscValidCharPointer(symbol,2);\n  PetscValidPointer(value,3);\n\n  dlhandle = (dlhandle_t) 0;\n  dlsymbol = (dlsymbol_t) 0;\n  *value   = (void*) 0;\n\n  /*\n     --- GetProcAddress ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_GETPROCADDRESS)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else dlhandle = (dlhandle_t) GetCurrentProcess();\n  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n#if defined(PETSC_HAVE_SETLASTERROR)\n  SetLastError((DWORD)0); /* clear any previous error */\n#endif\n#endif /* !PETSC_HAVE_GETPROCADDRESS */\n\n  /*\n     --- dlsym ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLSYM)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else {\n\n#if defined(PETSC_HAVE_DLOPEN) && defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n    /* Attempt to retrieve the main executable's dlhandle. */\n    { int dlflags1 = 0, dlflags2 = 0;\n#if defined(PETSC_HAVE_RTLD_LAZY)\n      dlflags1 = RTLD_LAZY;\n#endif\n      if (!dlflags1) {\n#if defined(PETSC_HAVE_RTLD_NOW)\n        dlflags1 = RTLD_NOW;\n#endif\n      }\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n      dlflags2 = RTLD_LOCAL;\n#endif\n      if (!dlflags2) {\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n        dlflags2 = RTLD_GLOBAL;\n#endif\n      }\n#if defined(PETSC_HAVE_DLERROR)\n      if (!(PETSC_RUNNING_ON_VALGRIND)) {\n        dlerror(); /* clear any previous error; valgrind does not like this */\n      }\n#endif\n      /* Attempt to open the main executable as a dynamic library. */\n#if defined(PETSC_HAVE_RTDL_DEFAULT)\n      dlhandle = RTLD_DEFAULT;\n#else\n      dlhandle = dlopen(0, dlflags1|dlflags2);\n#if defined(PETSC_HAVE_DLERROR)\n      { const char *e = (const char*) dlerror();\n        if (e) SETERRQ1(PETSC_COMM_SELF, PETSC_ERR_ARG_WRONG, \"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\", e);\n      }\n#endif\n#endif\n    }\n#endif\n#endif /* PETSC_HAVE_DLOPEN && PETSC_HAVE_DYNAMIC_LIBRARIES */\n  }\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *value = *((void**)&dlsymbol);\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  if (*value) {\n    PetscErrorCode ierr;\n    ierr = PetscFPTAdd(*value,symbol);CHKERRQ(ierr);\n  }\n#endif\n  return(0);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/bin/win32fe/win32fe.exe",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/bin/win32fe/win32feutils.dll",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/systems/Apple/iOS/examples/Basic/Default-568h@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ksp/pc/impls/kaczmarz/kaczmarz.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/mat/color/impls/jp/jp.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/interface/ts.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/examples/tutorials/ex11.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/examples/tutorials/ex34.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/examples/tutorials/power_grid/PDF_eqs_power_grid.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/Ybus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/X.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/saws/images/transition.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/saws/images/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/square_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/2Dgrd.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/simpleblock-100.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/grid_c.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/Rect-tri3.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/sevenside.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/sevenside-quad-15.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/annulus-20.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/sevenside-quad.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/squaremotor-30.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/share/petsc/datafiles/meshes/cube_5tets.cas",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/tutorials/jbearing.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/tutorials/rosenbrock.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/tutorials/minsurf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/docs/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/docs/developers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.7.6-w2rkeuvlznr2mgjf7b72g6pykoyncei2/spack-src/docs/tao_manual.pdf"
    ],
    "total_files": 11881
}