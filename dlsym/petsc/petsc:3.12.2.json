{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/config/PETSc/Configure.py": "import config.base\n\nimport os\nimport sys\nimport re\nimport pickle\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = 'PETSC'\n    self.substPrefix  = 'PETSC'\n    self.installed = 0 # 1 indicates that Configure itself has already compiled and installed PETSc\n    return\n\n  def __str2__(self):\n    desc = []\n    if not self.installed:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Configure stage complete. Now build PETSc libraries with:')\n      desc.append('   make PETSC_DIR='+self.petscdir.dir+' PETSC_ARCH='+self.arch.arch+' all')\n      desc.append('xxx=========================================================================xxx')\n    else:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Installation complete. You do not need to run make to compile or install the software')\n      desc.append('xxx=========================================================================xxx')\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n    help.addArgument('PETSc',  '-prefix=<dir>',                   nargs.Arg(None, '', 'Specifiy location to install PETSc (eg. /usr/local)'))\n    help.addArgument('PETSc',  '-with-prefetch=<bool>',           nargs.ArgBool(None, 1,'Enable checking for prefetch instructions'))\n    help.addArgument('Windows','-with-windows-graphics=<bool>',   nargs.ArgBool(None, 1,'Enable check for Windows Graphics'))\n    help.addArgument('PETSc', '-with-default-arch=<bool>',        nargs.ArgBool(None, 1, 'Allow using the last configured arch without setting PETSC_ARCH'))\n    help.addArgument('PETSc','-with-single-library=<bool>',       nargs.ArgBool(None, 1,'Put all PETSc code into the single -lpetsc library'))\n    help.addArgument('PETSc','-with-fortran-bindings=<bool>',     nargs.ArgBool(None, 1,'Build PETSc fortran bindings in the library and corresponding module files'))\n    help.addArgument('PETSc', '-with-ios=<bool>',              nargs.ArgBool(None, 0, 'Build an iPhone/iPad version of PETSc library'))\n    help.addArgument('PETSc', '-with-xsdk-defaults', nargs.ArgBool(None, 0, 'Set the following as defaults for the xSDK standard: --enable-debug=1, --enable-shared=1, --with-precision=double, --with-index-size=32, locate blas/lapack automatically'))\n    help.addArgument('PETSc', '-with-display=<x11display>',       nargs.Arg(None, '', 'Specifiy DISPLAY env variable for use with matlab test)'))\n    help.addArgument('PETSc', '-with-package-scripts=<pyscripts>',nargs.ArgFileList(None,None,'Specify configure package scripts for user provided packages'))\n    return\n\n  def registerPythonFile(self,filename,directory):\n    ''' Add a python file to the framework and registers its headerprefix, ... externalpackagedir\n        directory is the directory where the file relative to the BuildSystem or config path in python notation with . '''\n    (utilityName, ext) = os.path.splitext(filename)\n    if not utilityName.startswith('.') and not utilityName.startswith('#') and ext == '.py' and not utilityName == '__init__':\n      if directory: directory = directory+'.'\n      utilityObj                             = self.framework.require(directory+utilityName, self)\n      utilityObj.headerPrefix                = self.headerPrefix\n      utilityObj.archProvider                = self.arch\n      utilityObj.languageProvider            = self.languages\n      utilityObj.installDirProvider          = self.installdir\n      utilityObj.externalPackagesDirProvider = self.externalpackagesdir\n      utilityObj.precisionProvider           = self.scalartypes\n      utilityObj.indexProvider               = self.indexTypes\n      setattr(self, utilityName.lower(), utilityObj)\n      return utilityObj\n    return None\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.programs      = framework.require('config.programs',           self)\n    self.setCompilers  = framework.require('config.setCompilers',       self)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.arch          = framework.require('PETSc.options.arch',        self.setCompilers)\n    self.petscdir      = framework.require('PETSc.options.petscdir',    self.arch)\n    self.installdir    = framework.require('PETSc.options.installDir',  self)\n    self.scalartypes   = framework.require('PETSc.options.scalarTypes', self)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self)\n    self.languages     = framework.require('PETSc.options.languages',   self.setCompilers)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self.compilers)\n    self.types         = framework.require('config.types',              self)\n    self.headers       = framework.require('config.headers',            self)\n    self.functions     = framework.require('config.functions',          self)\n    self.libraries     = framework.require('config.libraries',          self)\n    self.atomics       = framework.require('config.atomics',            self)\n    self.make          = framework.require('config.packages.make',      self)\n    self.blasLapack    = framework.require('config.packages.BlasLapack',self)\n    self.mpi           = framework.require('config.packages.MPI',       self)\n    self.fortran       = framework.require('config.compilersFortran',   self)\n    self.externalpackagesdir = framework.require('PETSc.options.externalpackagesdir',self)\n\n    for utility in sorted(os.listdir(os.path.join('config','PETSc','options'))):\n      self.registerPythonFile(utility,'PETSc.options')\n\n    for utility in sorted(os.listdir(os.path.join('config','BuildSystem','config','utilities'))):\n      self.registerPythonFile(utility,'config.utilities')\n\n    for package in sorted(os.listdir(os.path.join('config', 'BuildSystem', 'config', 'packages'))):\n      obj = self.registerPythonFile(package,'config.packages')\n      if obj:\n        obj.archProvider                = self.framework.requireModule(obj.archProvider, obj)\n        obj.languageProvider            = self.framework.requireModule(obj.languageProvider, obj)\n        obj.installDirProvider          = self.framework.requireModule(obj.installDirProvider, obj)\n        obj.externalPackagesDirProvider = self.framework.requireModule(obj.externalPackagesDirProvider, obj)\n        obj.precisionProvider           = self.framework.requireModule(obj.precisionProvider, obj)\n        obj.indexProvider               = self.framework.requireModule(obj.indexProvider, obj)\n\n    # Force blaslapack and opencl to depend on scalarType so precision is set before BlasLapack is built\n    framework.require('PETSc.options.scalarTypes', self.f2cblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.fblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.blaslapack)\n    framework.require('PETSc.options.scalarTypes', self.opencl)\n\n    self.programs.headerPrefix   = self.headerPrefix\n    self.compilers.headerPrefix  = self.headerPrefix\n    self.fortran.headerPrefix    = self.headerPrefix\n    self.types.headerPrefix      = self.headerPrefix\n    self.headers.headerPrefix    = self.headerPrefix\n    self.functions.headerPrefix  = self.headerPrefix\n    self.libraries.headerPrefix  = self.headerPrefix\n\n    # Register user provided package scripts\n    if 'with-package-scripts' in self.framework.argDB:\n      for script in self.framework.argDB['with-package-scripts']:\n        if os.path.splitext(script)[1] != '.py':\n          raise RuntimeError('Only python scripts compatible with configure package script format should be specified! Invalid option -with-package-scripts='+script)\n        self.framework.logPrint('User is registering a new package script: '+script)\n        dname,fname = os.path.split(script)\n        if dname: sys.path.append(dname)\n        self.registerPythonFile(fname,'')\n\n    # test for a variety of basic headers and functions\n    headersC = map(lambda name: name+'.h', ['setjmp','dos', 'fcntl', 'float', 'io',  'malloc', 'pwd',  'strings',\n                                            'unistd', 'sys/sysinfo', 'machine/endian', 'sys/param', 'sys/procfs', 'sys/resource',\n                                            'sys/systeminfo', 'sys/times', 'sys/utsname',\n                                            'sys/socket','sys/wait','netinet/in','netdb','Direct','time','Ws2tcpip','sys/types',\n                                            'WindowsX', 'float','ieeefp','stdint','pthread','inttypes','immintrin','zmmintrin'])\n    functions = ['access', '_access', 'clock', 'drand48', 'getcwd', '_getcwd', 'getdomainname', 'gethostname',\n                 'getwd', 'memalign', 'popen', 'PXFGETARG', 'rand', 'getpagesize',\n                 'readlink', 'realpath',  'usleep', 'sleep', '_sleep',\n                 'uname','snprintf','_snprintf','lseek','_lseek','time','fork','stricmp',\n                 'strcasecmp', 'bzero', 'dlopen', 'dlsym', 'dlclose', 'dlerror',\n                 '_set_output_format','_mkdir','socket','gethostbyname']\n    libraries = [(['fpe'], 'handle_sigfpes')]\n    librariessock = [(['socket', 'nsl'], 'socket')]\n    self.headers.headers.extend(headersC)\n    self.functions.functions.extend(functions)\n    self.libraries.libraries.extend(libraries)\n    if not hasattr(self,'socket'):\n      self.libraries.libraries.extend(librariessock)\n    return\n\n  def DumpPkgconfig(self):\n    ''' Create a pkg-config file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig'))\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig','PETSc.pc'),'w')\n    cflags_inc = ['-I${includedir}']\n    if self.framework.argDB['prefix']:\n      fd.write('prefix='+self.installdir.dir+'\\n')\n    else:\n      fd.write('prefix='+os.path.join(self.petscdir.dir, self.arch.arch)+'\\n')\n      cflags_inc.append('-I' + os.path.join(self.petscdir.dir, 'include'))\n    fd.write('exec_prefix=${prefix}\\n')\n    fd.write('includedir=${prefix}/include\\n')\n    fd.write('libdir=${prefix}/lib\\n')\n\n    self.setCompilers.pushLanguage('C')\n    fd.write('ccompiler='+self.setCompilers.getCompiler()+'\\n')\n    fd.write('cflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n    fd.write('cflags_dep='+self.compilers.dependenciesGenerationFlag.get('C','')+'\\n')\n    fd.write('ldflag_rpath='+self.setCompilers.CSharedLinkerFlag+'\\n')\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'CXX'):\n      self.setCompilers.pushLanguage('C++')\n      fd.write('cxxcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('cxxflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('fcompiler='+self.setCompilers.getCompiler()+'\\n')\n      fd.write('fflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      self.setCompilers.popLanguage()\n\n    fd.write('\\n')\n    fd.write('Name: PETSc\\n')\n    fd.write('Description: Library to solve ODEs and algebraic equations\\n')\n    fd.write('Version: %s\\n' % self.petscdir.version)\n    fd.write('Cflags: ' + ' '.join([self.setCompilers.CPPFLAGS] + cflags_inc) + '\\n')\n    fd.write('Libs: '+self.libraries.toStringNoDupes(['-L${libdir}', self.petsclib], with_rpath=False)+'\\n')\n    # Remove RPATH flags from library list.  User can add them using\n    # pkg-config --variable=ldflag_rpath and pkg-config --libs-only-L\n    fd.write('Libs.private: '+self.libraries.toStringNoDupes([f for f in self.packagelibs+self.complibs if not f.startswith(self.setCompilers.CSharedLinkerFlag)], with_rpath=False)+'\\n')\n\n    fd.close()\n    return\n\n  def DumpModule(self):\n    ''' Create a module file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules'))\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc'))\n    if self.framework.argDB['prefix']:\n      installdir  = self.installdir.dir\n      installarch = ''\n      installpath = os.path.join(installdir,'bin')\n    else:\n      installdir  = self.petscdir.dir\n      installarch = self.arch.arch\n      installpath = os.path.join(installdir,installarch,'bin')+':'+os.path.join(installdir,'bin')\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc',self.petscdir.version),'w')\n    fd.write('''\\\n#%%Module\n\nproc ModulesHelp { } {\n    puts stderr \"This module sets the path and environment variables for petsc-%s\"\n    puts stderr \"     see https://www.mcs.anl.gov/petsc/ for more information      \"\n    puts stderr \"\"\n}\nmodule-whatis \"PETSc - Portable, Extensible Toolkit for Scientific Computation\"\n\nset petsc_dir   \"%s\"\nset petsc_arch  \"%s\"\n\nsetenv PETSC_ARCH \"$petsc_arch\"\nsetenv PETSC_DIR \"$petsc_dir\"\nprepend-path PATH \"%s\"\n''' % (self.petscdir.version, installdir, installarch, installpath))\n    fd.close()\n    return\n\n  def Dump(self):\n    ''' Actually put the values into the configuration files '''\n    # eventually everything between -- should be gone\n    if self.mpi.usingMPIUni:\n      #\n      # Remove any MPI/MPICH include files that may have been put here by previous runs of ./configure\n      self.executeShellCommand('rm -rf  '+os.path.join(self.petscdir.dir,self.arch.arch,'include','mpi*')+' '+os.path.join(self.petscdir.dir,self.arch.arch,'include','opa*'), log = self.log)\n\n    self.setCompilers.pushLanguage('C')\n    compiler = self.setCompilers.getCompiler()\n    if compiler.endswith('mpicc') or compiler.endswith('mpiicc'):\n      try:\n        output   = self.executeShellCommand(compiler + ' -show', log = self.log)[0]\n        compiler = output.split(' ')[0]\n        self.addDefine('MPICC_SHOW','\"'+output.strip().replace('\\n','\\\\\\\\n')+'\"')\n      except:\n        self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    else:\n      self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    self.setCompilers.popLanguage()\n#-----------------------------------------------------------------------------------------------------\n\n    # Sometimes we need C compiler, even if built with C++\n    self.setCompilers.pushLanguage('C')\n    self.addMakeMacro('CC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n\n    # And sometimes we need a C++ compiler even when PETSc is built with C\n    if hasattr(self.compilers, 'CXX'):\n      self.setCompilers.pushLanguage('Cxx')\n      self.addDefine('HAVE_CXX','1')\n      self.addMakeMacro('CXXPP_FLAGS',self.setCompilers.CXXPPFLAGS)\n      self.addMakeMacro('CXX_FLAGS',self.setCompilers.getCompilerFlags())\n      cxx_linker = self.setCompilers.getLinker()\n      self.addMakeMacro('CXX_LINKER',cxx_linker)\n      self.addMakeMacro('CXX_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      self.setCompilers.popLanguage()\n\n    # C preprocessor values\n    self.addMakeMacro('CPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n    # compiler values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    self.addMakeMacro('PCC',self.setCompilers.getCompiler())\n    self.addMakeMacro('PCC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.addMakeMacro('PCPP_FLAGS',getattr(self.setCompilers,self.languages.clanguage.upper()+'PPFLAGS'))\n    self.addMakeMacro('PFLAGS','${'+self.languages.clanguage.upper()+'FLAGS}')\n    self.addMakeMacro('PPPFLAGS','${'+self.languages.clanguage.upper()+'PPFLAGS}')\n    # ugly work-around for python3 distutils parse_makefile() issue with the above 2 lines\n    self.addMakeMacro('PY_'+self.languages.clanguage.upper()+'FLAGS','')\n    self.addMakeMacro('PY_'+self.languages.clanguage.upper()+'PPFLAGS','')\n    self.setCompilers.popLanguage()\n    # .o or .obj\n    self.addMakeMacro('CC_SUFFIX','o')\n\n    # executable linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    pcc_linker = self.setCompilers.getLinker()\n    self.addMakeMacro('PCC_LINKER',pcc_linker)\n    self.addMakeMacro('PCC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n    self.setCompilers.popLanguage()\n    # '' for Unix, .exe for Windows\n    self.addMakeMacro('CC_LINKER_SUFFIX','')\n\n    if hasattr(self.compilers, 'FC'):\n      if self.framework.argDB['with-fortran-bindings']:\n        self.addDefine('HAVE_FORTRAN','1')\n      self.setCompilers.pushLanguage('FC')\n      # need FPPFLAGS in config/setCompilers\n      self.addMakeMacro('FPP_FLAGS',self.setCompilers.FPPFLAGS)\n\n      # compiler values\n      self.addMakeMacro('FC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n      # .o or .obj\n      self.addMakeMacro('FC_SUFFIX','o')\n\n      # executable linker values\n      self.setCompilers.pushLanguage('FC')\n      self.addMakeMacro('FC_LINKER',self.setCompilers.getLinker())\n      self.addMakeMacro('FC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      # apple requires this shared library linker flag on SOME versions of the os\n      if self.setCompilers.getLinkerFlags().find('-Wl,-commons,use_dylibs') > -1:\n        self.addMakeMacro('DARWIN_COMMONS_USE_DYLIBS',' -Wl,-commons,use_dylibs ')\n      self.setCompilers.popLanguage()\n\n      # F90 Modules\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_FLAG', self.setCompilers.fortranModuleIncludeFlag)\n      else: # for non-f90 compilers like g77\n        self.addMakeMacro('FC_MODULE_FLAG', '-I')\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_OUTPUT_FLAG', self.setCompilers.fortranModuleOutputFlag)\n    else:\n      self.addMakeMacro('FC','')\n\n    if hasattr(self.compilers, 'CUDAC'):\n      self.setCompilers.pushLanguage('CUDA')\n      self.addMakeMacro('CUDAC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # shared library linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    # need to fix BuildSystem to collect these separately\n    self.addMakeMacro('SL_LINKER',self.setCompilers.getLinker())\n    self.addMakeMacro('SL_LINKER_FLAGS','${PCC_LINKER_FLAGS}')\n    self.setCompilers.popLanguage()\n    # One of 'a', 'so', 'lib', 'dll', 'dylib' (perhaps others also?) depending on the library generator and architecture\n    # Note: . is not included in this macro, consistent with AR_LIB_SUFFIX\n    if self.setCompilers.sharedLibraryExt == self.setCompilers.AR_LIB_SUFFIX:\n      self.addMakeMacro('SL_LINKER_SUFFIX', '')\n      self.addDefine('SLSUFFIX','\"\"')\n    else:\n      self.addMakeMacro('SL_LINKER_SUFFIX', self.setCompilers.sharedLibraryExt)\n      self.addDefine('SLSUFFIX','\"'+self.setCompilers.sharedLibraryExt+'\"')\n\n    self.addMakeMacro('SL_LINKER_LIBS','${PETSC_EXTERNAL_LIB_BASIC}')\n\n#-----------------------------------------------------------------------------------------------------\n\n    # CONLY or CPP. We should change the PETSc makefiles to do this better\n    if self.languages.clanguage == 'C': lang = 'CONLY'\n    else: lang = 'CXXONLY'\n    self.addMakeMacro('PETSC_LANGUAGE',lang)\n\n    # real or complex\n    self.addMakeMacro('PETSC_SCALAR',self.scalartypes.scalartype)\n    # double or float\n    self.addMakeMacro('PETSC_PRECISION',self.scalartypes.precision)\n\n    if self.framework.argDB['with-batch']:\n      self.addMakeMacro('PETSC_WITH_BATCH','1')\n\n    # Test for compiler-specific macros that need to be defined.\n    if self.setCompilers.isCrayVector('CC', self.log):\n      self.addDefine('HAVE_CRAY_VECTOR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    if self.functions.haveFunction('gethostbyname') and self.functions.haveFunction('socket') and self.headers.haveHeader('netinet/in.h'):\n      self.addDefine('USE_SOCKET_VIEWER','1')\n      if self.checkCompile('#include <sys/socket.h>','setsockopt(0,SOL_SOCKET,SO_REUSEADDR,0,0)'):\n        self.addDefine('HAVE_SO_REUSEADDR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    # print include and lib for makefiles\n    self.framework.packages.reverse()\n    petscincludes = [os.path.join(self.petscdir.dir,'include'),os.path.join(self.petscdir.dir,self.arch.arch,'include')]\n    petscincludes_install = [os.path.join(self.installdir.dir, 'include')] if self.framework.argDB['prefix'] else petscincludes\n    includes = []\n    self.packagelibs = []\n    for i in self.framework.packages:\n      if not i.required:\n        self.addDefine('HAVE_'+i.PACKAGE.replace('-','_'), 1)  # ONLY list package if it is used directly by PETSc (and not only by another package)\n      if not isinstance(i.lib, list):\n        i.lib = [i.lib]\n      if i.linkedbypetsc: self.packagelibs.extend(i.lib)\n      self.addMakeMacro(i.PACKAGE.replace('-','_')+'_LIB', self.libraries.toStringNoDupes(i.lib))\n      if hasattr(i,'include'):\n        if not isinstance(i.include,list):\n          i.include = [i.include]\n        includes.extend(i.include)\n        self.addMakeMacro(i.PACKAGE.replace('-','_')+'_INCLUDE',self.headers.toStringNoDupes(i.include))\n    if self.framework.argDB['with-single-library']:\n      self.petsclib = '-lpetsc'\n    else:\n      self.petsclib = '-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys'\n    self.complibs = self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split()\n    self.PETSC_WITH_EXTERNAL_LIB = self.libraries.toStringNoDupes(['-L${PETSC_DIR}/${PETSC_ARCH}/lib', self.petsclib]+self.packagelibs+self.complibs)\n    self.PETSC_EXTERNAL_LIB_BASIC = self.libraries.toStringNoDupes(self.packagelibs+self.complibs)\n\n    self.addMakeMacro('PETSC_EXTERNAL_LIB_BASIC',self.PETSC_EXTERNAL_LIB_BASIC)\n    allincludes = petscincludes + includes\n    allincludes_install = petscincludes_install + includes\n    self.PETSC_CC_INCLUDES = self.headers.toStringNoDupes(allincludes)\n    self.PETSC_CC_INCLUDES_INSTALL = self.headers.toStringNoDupes(allincludes_install)\n    self.addMakeMacro('PETSC_CC_INCLUDES',self.PETSC_CC_INCLUDES)\n    self.addMakeMacro('PETSC_CC_INCLUDES_INSTALL', self.PETSC_CC_INCLUDES_INSTALL)\n    if hasattr(self.compilers, 'FC'):\n      def modinc(includes):\n        return includes if self.fortran.fortranIsF90 else []\n      self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(allincludes,modinc(allincludes)))\n      self.addMakeMacro('PETSC_FC_INCLUDES_INSTALL',self.headers.toStringNoDupes(allincludes_install,modinc(allincludes_install)))\n\n    self.addDefine('LIB_DIR','\"'+os.path.join(self.installdir.dir,'lib')+'\"')\n\n    if self.framework.argDB['with-single-library']:\n      # overrides the values set in conf/variables\n      self.addMakeMacro('LIBNAME','${INSTALL_LIB_DIR}/libpetsc.${AR_LIB_SUFFIX}')\n      self.addMakeMacro('SHLIBS','libpetsc')\n      self.addMakeMacro('PETSC_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_KSP_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TS_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TAO_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_WITH_EXTERNAL_LIB',self.PETSC_WITH_EXTERNAL_LIB)\n      self.addDefine('USE_SINGLE_LIBRARY', '1')\n      if self.sharedlibraries.useShared:\n        self.addMakeMacro('PETSC_SYS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n      else:\n        self.addMakeMacro('PETSC_SYS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${PETSC_WITH_EXTERNAL_LIB}')\n\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib'))\n\n# add a makefile endtry for display\n    if self.framework.argDB['with-display']:\n      self.addMakeMacro('DISPLAY',self.framework.argDB['with-display'])\n\n    # add a makefile entry for configure options\n    self.addMakeMacro('CONFIGURE_OPTIONS', self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"'))\n    return\n\n  def dumpConfigInfo(self):\n    import time\n    fd = open(os.path.join(self.arch.arch,'include','petscconfiginfo.h'),'w')\n    fd.write('static const char *petscconfigureoptions = \"'+self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"')+'\";\\n')\n    fd.close()\n    return\n\n  def dumpMachineInfo(self):\n    import platform\n    import datetime\n    import time\n    import script\n    def escape(s):\n      return s.replace('\"',r'\\\"').replace(r'\\ ',r'\\\\ ')\n    fd = open(os.path.join(self.arch.arch,'include','petscmachineinfo.h'),'w')\n    fd.write('static const char *petscmachineinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"-----------------------------------------\\\\n\\\"\\n')\n    buildhost = platform.node()\n    if os.environ.get('SOURCE_DATE_EPOCH'):\n      buildhost = \"reproducible\"\n    buildtime = datetime.datetime.utcfromtimestamp(int(os.environ.get('SOURCE_DATE_EPOCH', time.time())))\n    fd.write('\\\"Libraries compiled on %s on %s \\\\n\\\"\\n' % (buildtime, buildhost))\n    fd.write('\\\"Machine characteristics: %s\\\\n\\\"\\n' % (platform.platform()))\n    fd.write('\\\"Using PETSc directory: %s\\\\n\\\"\\n' % (escape(self.installdir.petscDir)))\n    fd.write('\\\"Using PETSc arch: %s\\\\n\\\"\\n' % (escape(self.installdir.petscArch)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C compiler: %s %s \\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran compiler: %s %s  %s\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags()), escape(self.setCompilers.CPPFLAGS)))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerflagsinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"Using include paths: %s\\\\n\\\"\\n' % (escape(self.PETSC_CC_INCLUDES_INSTALL.replace('${PETSC_DIR}', self.installdir.petscDir))))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsclinkerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"Using libraries: %s%s -L%s %s %s\\\\n\\\"\\n' % (escape(self.setCompilers.CSharedLinkerFlag), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(self.petsclib), escape(self.PETSC_EXTERNAL_LIB_BASIC)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.close()\n    return\n\n  def configurePrefetch(self):\n    '''Sees if there are any prefetch functions supported'''\n    if config.setCompilers.Configure.isSolaris(self.log) or self.framework.argDB['with-ios'] or not self.framework.argDB['with-prefetch']:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch((const char*)v,_MM_HINT_NTA);\\n'):\n      # The Intel Intrinsics manual [1] specifies the prototype\n      #\n      #   void _mm_prefetch(char const *a, int sel);\n      #\n      # but other vendors seem to insist on using subtly different\n      # prototypes, including void* for the pointer, and an enum for\n      # sel.  These are both reasonable changes, but negatively impact\n      # portability.\n      #\n      # [1] https://software.intel.com/file/6373\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const char*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch(v,_MM_HINT_NTA);\\n'):\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const void*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('', 'void *v = 0;__builtin_prefetch(v,0,0);\\n'):\n      # From GCC docs: void __builtin_prefetch(const void *addr,int rw,int locality)\n      #\n      #   The value of rw is a compile-time constant one or zero; one\n      #   means that the prefetch is preparing for a write to the memory\n      #   address and zero, the default, means that the prefetch is\n      #   preparing for a read. The value locality must be a compile-time\n      #   constant integer between zero and three. A value of zero means\n      #   that the data has no temporal locality, so it need not be left\n      #   in the cache after the access. A value of three means that the\n      #   data has a high degree of temporal locality and should be left\n      #   in all levels of cache possible. Values of one and two mean,\n      #   respectively, a low or moderate degree of temporal locality.\n      #\n      # Here we adopt Intel's x86/x86-64 naming scheme for the locality\n      # hints.  Using macros for these values in necessary since some\n      # compilers require an enum.\n      self.addDefine('Prefetch(a,b,c)', '__builtin_prefetch((a),(b),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '0')\n      self.addDefine('PREFETCH_HINT_T0',  '3')\n      self.addDefine('PREFETCH_HINT_T1',  '2')\n      self.addDefine('PREFETCH_HINT_T2',  '1')\n    else:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n    self.popLanguage()\n\n  def configureAtoll(self):\n    '''Checks if atoll exists'''\n    if self.checkLink('#define _POSIX_C_SOURCE 200112L\\n#include <stdlib.h>','long v = atoll(\"25\")') or self.checkLink ('#include <stdlib.h>','long v = atoll(\"25\")'):\n       self.addDefine('HAVE_ATOLL', '1')\n\n  def configureUnused(self):\n    '''Sees if __attribute((unused)) is supported'''\n    if self.framework.argDB['with-ios']:\n      self.addDefine('UNUSED', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('__attribute((unused)) static int myfunc(__attribute((unused)) void *name){ return 1;}', 'int i = 0;\\nint j = myfunc(&i);\\ntypedef void* atype;\\n__attribute((unused))  atype a;\\n'):\n      self.addDefine('UNUSED', '__attribute((unused))')\n    else:\n      self.addDefine('UNUSED', ' ')\n    self.popLanguage()\n\n  def configureIsatty(self):\n    '''Check if the Unix C function isatty() works correctly\n       Actually just assumes it does not work correctly on batch systems'''\n    if not self.framework.argDB['with-batch']:\n      self.addDefine('USE_ISATTY',1)\n\n  def configureDeprecated(self):\n    '''Check if __attribute((deprecated)) is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    ## Recent versions of gcc and clang support __attribute((deprecated(\"string argument\"))), which is very useful, but\n    ## Intel has conspired to make a supremely environment-sensitive compiler.  The Intel compiler looks at the gcc\n    ## executable in the environment to determine the language compatibility that it should attempt to emulate.  Some\n    ## important Cray installations have built PETSc using the Intel compiler, but with a newer gcc module loaded (e.g.,\n    ## 4.7).  Thus at PETSc configure time, the Intel compiler decides to support the string argument, but the gcc\n    ## found in the default user environment is older and does not support the argument.  If GCC and Intel were cool\n    ## like Clang and supported __has_attribute, we could avoid configure tests entirely, but they don't.  And that is\n    ## why we can't have nice things.\n    #\n    # if self.checkCompile(\"\"\"__attribute((deprecated(\"Why you shouldn't use myfunc\"))) static int myfunc(void) { return 1;}\"\"\", ''):\n    #   self.addDefine('DEPRECATED_FUNCTION(why)', '__attribute((deprecated(why)))')\n    #   self.addDefine('DEPRECATED_TYPEDEF(why)', '__attribute((deprecated(why)))')\n    if self.checkCompile(\"\"\"__attribute((deprecated)) static int myfunc(void) { return 1;}\"\"\", ''):\n      self.addDefine('DEPRECATED_FUNCTION(why)', '__attribute((deprecated))')\n      self.addDefine('DEPRECATED_TYPEDEF(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED_FUNCTION(why)', ' ')\n      self.addDefine('DEPRECATED_TYPEDEF(why)', ' ')\n    if self.checkCompile(\"\"\"enum E {oldval __attribute((deprecated)), newval };\"\"\", ''):\n      self.addDefine('DEPRECATED_ENUM(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED_ENUM(why)', ' ')\n    # I was unable to make a CPP macro that takes the old and new values as seperate arguments and builds the message needed by _Pragma\n    # hence the deprecation message is handled as it is\n    if self.checkCompile('#define TEST _Pragma(\"GCC warning \\\"Testing _Pragma\\\"\") value'):\n      self.addDefine('DEPRECATED_MACRO(why)', '_Pragma(why)')\n    else:\n      self.addDefine('DEPRECATED_MACRO(why)', ' ')\n    self.popLanguage()\n\n  def configureAlign(self):\n    '''Check if __attribute(aligned) is supported'''\n    code = '''\\\nstruct mystruct {int myint;} __attribute((aligned(16)));\nchar assert_aligned[(sizeof(struct mystruct)==16)*2-1];\n'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile(code):\n      self.addDefine('ATTRIBUTEALIGNED(size)', '__attribute((aligned(size)))')\n      self.addDefine('HAVE_ATTRIBUTEALIGNED', 1)\n    else:\n      self.framework.logPrint('Incorrect attribute(aligned)')\n      self.addDefine('ATTRIBUTEALIGNED(size)', ' ')\n    self.popLanguage()\n    return\n\n  def configureExpect(self):\n    '''Sees if the __builtin_expect directive is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('', 'if (__builtin_expect(0,1)) return 1;'):\n      self.addDefine('HAVE_BUILTIN_EXPECT', 1)\n    self.popLanguage()\n\n  def configureFunctionName(self):\n    '''Sees if the compiler supports __func__ or a variant.'''\n    def getFunctionName(lang):\n      name = '\"unknown\"'\n      self.pushLanguage(lang)\n      for fname in ['__func__','__FUNCTION__','__extension__ __func__']:\n        code = \"if (\"+fname+\"[0] != 'm') return 1;\"\n        if self.checkCompile('',code) and self.checkLink('',code):\n          name = fname\n          break\n      self.popLanguage()\n      return name\n    langs = []\n\n    self.addDefine('FUNCTION_NAME_C', getFunctionName('C'))\n    if hasattr(self.compilers, 'CXX'):\n      self.addDefine('FUNCTION_NAME_CXX', getFunctionName('Cxx'))\n\n  def configureIntptrt(self):\n    '''Determine what to use for uintptr_t'''\n    def staticAssertSizeMatchesVoidStar(inc,typename):\n      # The declaration is an error if either array size is negative.\n      # It should be okay to use an int that is too large, but it would be very unlikely for this to be the case\n      return self.checkCompile(inc, ('#define STATIC_ASSERT(cond) char negative_length_if_false[2*(!!(cond))-1]\\n'\n                                     + 'STATIC_ASSERT(sizeof(void*) == sizeof(%s));'%typename))\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile('#include <stdint.h>', 'int x; uintptr_t i = (uintptr_t)&x;'):\n      self.addDefine('UINTPTR_T', 'uintptr_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long long'):\n      self.addDefine('UINTPTR_T', 'unsigned long long')\n    elif staticAssertSizeMatchesVoidStar('#include <stdlib.h>','size_t') or staticAssertSizeMatchesVoidStar('#include <string.h>', 'size_t'):\n      self.addDefine('UINTPTR_T', 'size_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long'):\n      self.addDefine('UINTPTR_T', 'unsigned long')\n    elif staticAssertSizeMatchesVoidStar('','unsigned'):\n      self.addDefine('UINTPTR_T', 'unsigned')\n    else:\n      raise RuntimeError('Could not find any unsigned integer type matching void*')\n    self.popLanguage()\n\n  def configureRTLDDefault(self):\n    if self.checkCompile('#include <dlfcn.h>\\n void *ptr =  RTLD_DEFAULT;'):\n      self.addDefine('RTLD_DEFAULT','1')\n    return\n\n  def configureSolaris(self):\n    '''Solaris specific stuff'''\n    if os.path.isdir(os.path.join('/usr','ucblib')):\n      try:\n        flag = getattr(self.setCompilers, self.language[-1]+'SharedLinkerFlag')\n      except AttributeError:\n        flag = None\n      if flag is None:\n        self.compilers.LIBS += ' -L/usr/ucblib'\n      else:\n        self.compilers.LIBS += ' '+flag+'/usr/ucblib'\n    return\n\n  def configureLinux(self):\n    '''Linux specific stuff'''\n    # TODO: Test for this by mallocing an odd number of floats and checking the address\n    self.addDefine('HAVE_DOUBLE_ALIGN_MALLOC', 1)\n    return\n\n  def configureWin32(self):\n    '''Win32 non-cygwin specific stuff'''\n    kernel32=0\n    if self.libraries.add('Kernel32.lib','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    elif self.libraries.add('kernel32','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    if kernel32:\n      if self.framework.argDB['with-windows-graphics']:\n        self.addDefine('USE_WINDOWS_GRAPHICS',1)\n      if self.checkLink('#include <Windows.h>','LoadLibrary(0)'):\n        self.addDefine('HAVE_LOADLIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetProcAddress(0,0)'):\n        self.addDefine('HAVE_GETPROCADDRESS',1)\n      if self.checkLink('#include <Windows.h>','FreeLibrary(0)'):\n        self.addDefine('HAVE_FREELIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetLastError()'):\n        self.addDefine('HAVE_GETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>','SetLastError(0)'):\n        self.addDefine('HAVE_SETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>\\n','QueryPerformanceCounter(0);\\n'):\n        self.addDefine('USE_MICROSOFT_TIME',1)\n    if self.libraries.add('Advapi32.lib','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n    elif self.libraries.add('advapi32','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n\n    if not self.libraries.add('User32.lib','GetDC',prototype='#include <Windows.h>',call='GetDC(0);'):\n      self.libraries.add('user32','GetDC',prototype='#include <Windows.h>',call='GetDC(0);')\n    if not self.libraries.add('Gdi32.lib','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);'):\n      self.libraries.add('gdi32','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);')\n\n    self.types.check('int32_t', 'int')\n    if not self.checkCompile('#include <sys/types.h>\\n','uid_t u;\\n'):\n      self.addTypedef('int', 'uid_t')\n      self.addTypedef('int', 'gid_t')\n    if not self.checkLink('#if defined(PETSC_HAVE_UNISTD_H)\\n#include <unistd.h>\\n#endif\\n','int a=R_OK;\\n'):\n      self.framework.addDefine('R_OK', '04')\n      self.framework.addDefine('W_OK', '02')\n      self.framework.addDefine('X_OK', '01')\n    if not self.checkLink('#include <sys/stat.h>\\n','int a=0;\\nif (S_ISDIR(a)){}\\n'):\n      self.framework.addDefine('S_ISREG(a)', '(((a)&_S_IFMT) == _S_IFREG)')\n      self.framework.addDefine('S_ISDIR(a)', '(((a)&_S_IFMT) == _S_IFDIR)')\n    if self.checkCompile('#include <Windows.h>\\n','LARGE_INTEGER a;\\nDWORD b=a.u.HighPart;\\n'):\n      self.addDefine('HAVE_LARGE_INTEGER_U',1)\n\n    # Windows requires a Binary file creation flag when creating/opening binary files.  Is a better test in order?\n    if self.checkCompile('#include <Windows.h>\\n#include <fcntl.h>\\n', 'int flags = O_BINARY;'):\n      self.addDefine('HAVE_O_BINARY',1)\n\n    if self.compilers.CC.find('win32fe') >= 0:\n      self.addDefine('HAVE_WINDOWS_COMPILERS',1)\n      self.addDefine('DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('CANNOT_START_DEBUGGER',1)\n      (petscdir,error,status) = self.executeShellCommand('cygpath -w '+self.installdir.petscDir, log = self.log)\n      self.addDefine('DIR','\"'+petscdir.replace('\\\\','\\\\\\\\')+'\"')\n      (petscdir,error,status) = self.executeShellCommand('cygpath -m '+self.installdir.petscDir, log = self.log)\n      self.addMakeMacro('wPETSC_DIR',petscdir)\n    else:\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('DIR','\"'+self.installdir.petscDir+'\"')\n      self.addMakeMacro('wPETSC_DIR',self.installdir.petscDir)\n    self.addDefine('ARCH','\"'+self.installdir.petscArch+'\"')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureCygwinBrokenPipe(self):\n    '''Cygwin version <= 1.7.18 had issues with pipes and long commands invoked from gnu-make\n    http://cygwin.com/ml/cygwin/2013-05/msg00340.html '''\n    if config.setCompilers.Configure.isCygwin(self.log):\n      import platform\n      import re\n      r=re.compile(\"([0-9]+).([0-9]+).([0-9]+)\")\n      m=r.match(platform.release())\n      major=int(m.group(1))\n      minor=int(m.group(2))\n      subminor=int(m.group(3))\n      if ((major < 1) or (major == 1 and minor < 7) or (major == 1 and minor == 7 and subminor <= 18)):\n        self.addMakeMacro('PETSC_CYGWIN_BROKEN_PIPE','1')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureDefaultArch(self):\n    conffile = os.path.join('lib','petsc','conf', 'petscvariables')\n    if self.framework.argDB['with-default-arch']:\n      fd = open(conffile, 'w')\n      fd.write('PETSC_ARCH='+self.arch.arch+'\\n')\n      fd.write('PETSC_DIR='+self.petscdir.dir+'\\n')\n      fd.write('include '+os.path.join('$(PETSC_DIR)','$(PETSC_ARCH)','lib','petsc','conf','petscvariables')+'\\n')\n      fd.close()\n      self.framework.actions.addArgument('PETSc', 'Build', 'Set default architecture to '+self.arch.arch+' in '+conffile)\n    elif os.path.isfile(conffile):\n      try:\n        os.unlink(conffile)\n      except:\n        raise RuntimeError('Unable to remove file '+conffile+'. Did a different user create it?')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureScript(self):\n    '''Output a script in the conf directory which will reproduce the configuration'''\n    import nargs\n    import sys\n    scriptName = os.path.join(self.arch.arch,'lib','petsc','conf', 'reconfigure-'+self.arch.arch+'.py')\n    args = dict([(nargs.Arg.parseArgument(arg)[0], arg) for arg in self.framework.clArgs])\n    if 'with-clean' in args:\n      del args['with-clean']\n    if 'force' in args:\n      del args['force']\n    if 'configModules' in args:\n      if nargs.Arg.parseArgument(args['configModules'])[1] == 'PETSc.Configure':\n        del args['configModules']\n    if 'optionsModule' in args:\n      if nargs.Arg.parseArgument(args['optionsModule'])[1] == 'config.compilerOptions':\n        del args['optionsModule']\n    if not 'PETSC_ARCH' in args:\n      args['PETSC_ARCH'] = 'PETSC_ARCH='+str(self.arch.arch)\n    f = open(scriptName, 'w')\n    f.write('#!'+sys.executable+'\\n')\n    f.write('if __name__ == \\'__main__\\':\\n')\n    f.write('  import sys\\n')\n    f.write('  import os\\n')\n    f.write('  sys.path.insert(0, os.path.abspath(\\'config\\'))\\n')\n    f.write('  import configure\\n')\n    # pretty print repr(args.values())\n    f.write('  configure_options = [\\n')\n    for itm in sorted(args.values()):\n      f.write('    \\''+str(itm)+'\\',\\n')\n    f.write('  ]\\n')\n    f.write('  configure.petsc_configure(configure_options)\\n')\n    f.close()\n    try:\n      os.chmod(scriptName, 0o775)\n    except OSError as e:\n      self.framework.logPrint('Unable to make reconfigure script executable:\\n'+str(e))\n    self.framework.actions.addArgument('PETSc', 'File creation', 'Created '+scriptName+' for automatic reconfiguration')\n    return\n\n  def configureInstall(self):\n    '''Setup the directories for installation'''\n    if self.framework.argDB['prefix']:\n      self.addMakeRule('print_mesg_after_build','',['-@echo \"Now to install the libraries do:\"',\\\n                                              '-@echo \"'+self.installdir.installSudo+'make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} install\"',\\\n                                              '-@echo \"=========================================\"'])\n    else:\n      self.addMakeRule('print_mesg_after_build','',['-@echo \"Now to check if the libraries are working do:\"',\\\n                                              '-@echo \"make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} check\"',\\\n                                              '-@echo \"=========================================\"'])\n      return\n\n  def configureGCOV(self):\n    if self.framework.argDB['with-gcov']:\n      self.addDefine('USE_GCOV','1')\n    return\n\n  def postProcessPackages(self):\n    postPackages=[]\n    for i in self.framework.packages:\n      if hasattr(i,'postProcess'): postPackages.append(i)\n    if postPackages:\n      # ctetgen needs petsc conf files. so attempt to create them early\n      self.framework.dumpConfFiles()\n      # tacky fix for dependency of Aluimia on Pflotran; requested via petsc-dev Matt provide a correct fix\n      for i in postPackages:\n        if i.name.upper() in ['PFLOTRAN']:\n          i.postProcess()\n          postPackages.remove(i)\n      for i in postPackages: i.postProcess()\n      for i in postPackages:\n        if i.installedpetsc:\n          self.installed = 1\n          break\n    return\n\n  def configure(self):\n    if 'package-prefix-hash' in self.argDB:\n      # turn off prefix if it was only used to for installing external packages.\n      self.framework.argDB['prefix'] = ''\n      self.dir = os.path.abspath(os.path.join(self.petscdir.dir, self.arch.arch))\n      self.installdir.dir = self.dir\n      self.installdir.petscDir = self.petscdir.dir\n      self.petscDir = self.petscdir.dir\n      self.petscArch = self.arch.arch\n      self.addMakeMacro('PREFIXDIR',self.dir)\n      self.confDir = os.path.abspath(os.path.join(self.petscdir.dir, self.arch.arch))\n\n    if not os.path.samefile(self.petscdir.dir, os.getcwd()):\n      raise RuntimeError('Wrong PETSC_DIR option specified: '+str(self.petscdir.dir) + '\\n  Configure invoked in: '+os.path.realpath(os.getcwd()))\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],self.petscdir.dir):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR!')\n    if self.framework.argDB['prefix'] and self.framework.argDB['prefix'].find(' ') > -1:\n      raise RuntimeError('Your --prefix '+self.framework.argDB['prefix']+' has spaces in it; this is not allowed.\\n Use a --prefix that does not have spaces in it')\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],os.path.join(self.petscdir.dir,self.arch.arch)):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR/PETSC_ARCH!')\n    self.framework.header          = os.path.join(self.arch.arch,'include','petscconf.h')\n    self.framework.cHeader         = os.path.join(self.arch.arch,'include','petscfix.h')\n    self.framework.pkgheader       = os.path.join(self.arch.arch,'include','petscpkg_version.h')\n    self.framework.makeMacroHeader = os.path.join(self.arch.arch,'lib','petsc','conf','petscvariables')\n    self.framework.makeRuleHeader  = os.path.join(self.arch.arch,'lib','petsc','conf','petscrules')\n    if self.libraries.math is None:\n      raise RuntimeError('PETSc requires a functional math library. Please send configure.log to petsc-maint@mcs.anl.gov.')\n    if self.languages.clanguage == 'Cxx' and not hasattr(self.compilers, 'CXX'):\n      raise RuntimeError('Cannot set C language to C++ without a functional C++ compiler.')\n    self.executeTest(self.configureRTLDDefault)\n    self.executeTest(self.configurePrefetch)\n    self.executeTest(self.configureUnused)\n    self.executeTest(self.configureDeprecated)\n    self.executeTest(self.configureIsatty)\n    self.executeTest(self.configureExpect);\n    self.executeTest(self.configureAlign);\n    self.executeTest(self.configureFunctionName);\n    self.executeTest(self.configureIntptrt);\n    self.executeTest(self.configureSolaris)\n    self.executeTest(self.configureLinux)\n    self.executeTest(self.configureWin32)\n    self.executeTest(self.configureCygwinBrokenPipe)\n    self.executeTest(self.configureDefaultArch)\n    self.executeTest(self.configureScript)\n    self.executeTest(self.configureInstall)\n    self.executeTest(self.configureGCOV)\n    self.executeTest(self.configureAtoll)\n\n    self.Dump()\n    self.dumpConfigInfo()\n    self.dumpMachineInfo()\n    # need to save the current state of BuildSystem so that postProcess() packages can read it in and perhaps run make install\n    self.framework.storeSubstitutions(self.framework.argDB)\n    self.framework.argDB['configureCache'] = pickle.dumps(self.framework)\n    self.framework.argDB.save(force = True)\n    self.DumpPkgconfig()\n    self.DumpModule()\n    self.postProcessPackages()\n    self.framework.log.write('================================================================================\\n')\n    self.logClear()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/config/BuildSystem/config/libraries.py": "import config.base\n\nimport os\nimport re\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework, libraries = []):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.libraries    = libraries\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilers    = framework.require('config.compilers',    self)\n    self.headers      = framework.require('config.headers',      self)\n    return\n\n  def getLibArgumentList(self, library, with_rpath=True):\n    '''Return the proper link line argument for the given filename library as a list of options\n      - If the path is empty, return it unchanged\n      - If starts with - then return unchanged\n      - If the path ends in \".lib\" return it unchanged\n      - If the path is absolute and the filename is \"lib\"<name>, return -L<dir> -l<name> (optionally including rpath flag)\n      - If the filename is \"lib\"<name>, return -l<name>\n      - If the path ends in \".so\" return it unchanged\n      - If the path ends in \".o\" return it unchanged\n      - If the path is absolute, return it unchanged\n      - Otherwise return -l<library>'''\n    if not library:\n      return []\n    if library.startswith('${CC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.startswith('${FC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.lstrip()[0] == '-':\n      return [library]\n    if len(library) > 3 and library[-4:] == '.lib':\n      return [library.replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')]\n    if os.path.basename(library).startswith('lib'):\n      name = self.getLibName(library)\n      if ((len(library) > 2 and library[1] == ':') or os.path.isabs(library)):\n        flagName  = self.language[-1]+'SharedLinkerFlag'\n        flagSubst = self.language[-1].upper()+'_LINKER_SLFLAG'\n        dirname   = os.path.dirname(library).replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')\n        if dirname in ['/usr/lib','/lib','/usr/lib64','/lib64']:\n          return [library]\n        if with_rpath:\n          if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n            return [getattr(self.setCompilers, flagName)+dirname,'-L'+dirname,'-l'+name]\n          if flagSubst in self.argDB:\n            return [self.argDB[flagSubst]+dirname,'-L'+dirname,'-l'+name]\n        return ['-L'+dirname,'-l'+name]\n      else:\n        return ['-l'+name]\n    if os.path.splitext(library)[1] == '.so' or os.path.splitext(library)[1] == '.o':\n      return [library]\n    if os.path.isabs(library):\n      return [library]\n    return ['-l'+library]\n\n  def getLibArgument(self, library):\n    '''Same as getLibArgumentList - except it returns a string instead of list.'''\n    return  ' '.join(self.getLibArgumentList(library))\n\n  def getLibName(library):\n    if os.path.basename(library).startswith('lib'):\n      return os.path.splitext(os.path.basename(library))[0][3:]\n    return library\n  getLibName = staticmethod(getLibName)\n\n  def getDefineName(self, library):\n    return 'HAVE_LIB'+self.getLibName(library).upper().replace('-','_').replace('=','_').replace('+','_').replace('.', '_').replace('/','_')\n\n  def getDefineNameFunc(self, funcName):\n    return 'HAVE_'+ funcName.upper()\n\n  def haveLib(self, library):\n    return self.getDefineName(library) in self.defines\n\n  def add(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName AND adds it to $LIBS\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(libName, list): libName = [libName]\n    if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle):\n      self.logPrint('Adding '+str(libName)+' to LIBS')\n      # Note: this MUST be setCompilers since it can happen before dispatch names is made\n      self.setCompilers.LIBS = self.toString(libName)+' '+self.setCompilers.LIBS\n      return 1\n    return 0\n\n  def toString(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    return ' '.join(newlibs)\n\n  def toStringNoDupes(self,libs,with_rpath=True):\n    '''Converts a list of libraries to a string suitable for a linker, removes duplicates'''\n    '''Moves the flags that can be moved to the beginning of the string but always leaves the libraries and other items that must remain in the same order'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib, with_rpath)\n    libs = newlibs\n    newldflags = []\n    newlibs = []\n    frame = 0\n    dupflags = ['-L']\n    flagName  = self.language[-1]+'SharedLinkerFlag'\n    if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n      dupflags.append(getattr(self.setCompilers, flagName))\n    for j in libs:\n      # remove duplicate -L, -Wl,-rpath options - and only consecutive -l options\n      if j in newldflags and any([j.startswith(flg) for flg in dupflags]): continue\n      if newlibs and j == newlibs[-1]: continue\n      if j.startswith('-l') or j.endswith('.lib') or j.endswith('.a') or j.endswith('.o') or j == '-Wl,-Bstatic' or j == '-Wl,-Bdynamic' or j == '-Wl,--start-group' or j == '-Wl,--end-group':\n        newlibs.append(j)\n      else:\n        newldflags.append(j)\n    liblist = ' '.join(newldflags + newlibs)\n    return liblist\n\n  def getShortLibName(self,lib):\n    '''returns the short name for the library. Valid names are foo -lfoo or libfoo.[a,so,lib]'''\n    if lib.startswith('-l'):\n      libname = lib[2:]\n      return libname\n    if lib.startswith('-'): # must be some compiler options - not a library\n      return ''\n    if lib.endswith('.a') or lib.endswith('.so') or lib.endswith('.lib'):\n      libname = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): libname = libname[3:]\n      return libname\n    # no match - assuming the given name is already in short notation\n    return lib\n\n  def check(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0, cxxMangle = 0, cxxLink = 0, functionDefine = 0, examineOutput=lambda ret,out,err:None):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(funcs,list): funcs = [funcs]\n    if not isinstance(libName, list): libName = [libName]\n    def genPreamble(f, funcName):\n      # Construct prototype\n      if self.language[-1] == 'FC':\n        return ''\n      if prototype:\n        if isinstance(prototype, str):\n          pre = prototype\n        else:\n          pre = prototype[f]\n      else:\n        # We use char because int might match the return type of a gcc2 builtin and its argument prototype would still apply.\n        pre = 'char '+funcName+'();'\n      # Capture the function call in a static function so that any local variables are isolated from\n      # calls to other library functions.\n      return pre + '\\nstatic void _check_%s() { %s }' % (funcName, genCall(f, funcName, pre=True))\n    def genCall(f, funcName, pre=False):\n      if self.language[-1] != 'FC' and not pre:\n        return '_check_' + funcName + '();'\n      # Construct function call\n      if call:\n        if isinstance(call, str):\n          body = call\n        else:\n          body = call[f]\n      else:\n        body = funcName+'()'\n      if self.language[-1] != 'FC':\n        body += ';'\n      return body\n    # Handle Fortran mangling\n    if fortranMangle:\n      funcs = list(map(self.compilers.mangleFortranFunction, funcs))\n    if not funcs:\n      self.logPrint('No functions to check for in library '+str(libName)+' '+str(otherLibs))\n      return True\n    self.logPrint('Checking for functions ['+' '.join(funcs)+'] in library '+str(libName)+' '+str(otherLibs))\n    if self.language[-1] == 'FC':\n      includes = ''\n    else:\n      includes = '/* Override any gcc2 internal prototype to avoid an error. */\\n'\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n'''\n    includes += '\\n'.join([genPreamble(f, fname) for f, fname in enumerate(funcs)])\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\n}\n#endif\n'''\n    body = '\\n'.join([genCall(f, fname) for f, fname in enumerate(funcs)])\n    # Setup link line\n    oldLibs = self.setCompilers.LIBS\n    if libDir:\n      if not isinstance(libDir, list): libDir = [libDir]\n      for dir in libDir:\n        self.setCompilers.LIBS += ' -L'+dir\n    # new libs may/will depend on system libs so list new libs first!\n    # Matt, do not change this without talking to me\n    if libName and otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(libName+otherLibs) +' '+ self.setCompilers.LIBS\n    elif otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(otherLibs) +' '+ self.setCompilers.LIBS\n    elif libName:\n      self.setCompilers.LIBS = ' '+self.toString(libName) +' '+ self.setCompilers.LIBS\n    if cxxMangle: compileLang = 'Cxx'\n    else:         compileLang = self.language[-1]\n    if cxxLink: linklang = 'Cxx'\n    else: linklang = self.language[-1]\n    self.pushLanguage(compileLang)\n    found = 0\n    if self.checkLink(includes, body, linkLanguage=linklang, examineOutput=examineOutput):\n      found = 1\n      # define the symbol as found\n      if functionDefine: [self.addDefine(self.getDefineNameFunc(fname), 1) for f, fname in enumerate(funcs)]\n      # add to list of found libraries\n      elif libName:\n        for lib in libName:\n          shortlib = self.getShortLibName(lib)\n          if shortlib: self.addDefine(self.getDefineName(shortlib), 1)\n    self.setCompilers.LIBS = oldLibs\n    self.popLanguage()\n    return found\n\n  def checkClassify(self, libName, funcs, libDir=None, otherLibs=[], prototype='', call='', fortranMangle=0, cxxMangle=0, cxxLink=0):\n    '''Recursive decompose to rapidly classify functions as found or missing'''\n    import config\n    def functional(funcs):\n      named = config.NamedInStderr(funcs)\n      if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle, cxxMangle, cxxLink):\n        return True\n      else:\n        return named.named\n    found, missing = config.classify(funcs, functional)\n    return found, missing\n\n  def checkMath(self):\n    '''Check for sin() in libm, the math library'''\n    self.math = None\n    funcs = ['sin', 'floor', 'log10', 'pow']\n    prototypes = ['#include <stdio.h>\\ndouble sin(double);',\n                  '#include <stdio.h>\\ndouble floor(double);',\n                  '#include <stdio.h>\\ndouble log10(double);',\n                  '#include <stdio.h>\\ndouble pow(double, double);']\n    calls = ['double x,y; scanf(\"%lf\",&x); y = sin(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = floor(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = log10(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = pow(x,x); printf(\"%f\",y);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.math = []\n    elif self.check('m', funcs, prototype = prototypes, call = calls):\n      self.math = ['libm.a']\n    self.logPrint('CheckMath: using math library '+str(self.math))\n    return\n\n  def checkMathErf(self):\n    '''Check for erf() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['erf'], prototype = ['#include <math.h>'], call = ['double (*checkErf)(double) = erf;double x = 0,y; y = (*checkErf)(x)']):\n      self.logPrint('erf() found')\n      self.addDefine('HAVE_ERF', 1)\n    else:\n      self.logPrint('Warning: erf() not found')\n    return\n\n  def checkMathTgamma(self):\n    '''Check for tgamma() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['tgamma'], prototype = ['#include <math.h>'], call = ['double (*checkTgamma)(double) = tgamma;double x = 0,y; y = (*checkTgamma)(x)']):\n      self.logPrint('tgamma() found')\n      self.addDefine('HAVE_TGAMMA', 1)\n    else:\n      self.logPrint('Warning: tgamma() not found')\n    return\n\n  def checkMathFenv(self):\n    '''Checks if <fenv.h> can be used with FE_DFL_ENV'''\n    if not self.math is None and self.check(self.math, ['fesetenv'], prototype = ['#include <fenv.h>'], call = ['fesetenv(FE_DFL_ENV);']):\n      self.addDefine('HAVE_FENV_H', 1)\n    else:\n      self.logPrint('Warning: <fenv.h> with FE_DFL_ENV not found')\n    return\n\n  def checkMathLog2(self):\n    '''Check for log2() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['log2'], prototype = ['#include <math.h>'], call = ['double (*checkLog2)(double) = log2; double x = 2.5, y = (*checkLog2)(x)']):\n      self.logPrint('log2() found')\n      self.addDefine('HAVE_LOG2', 1)\n    else:\n      self.logPrint('Warning: log2() not found')\n    return\n\n  def checkRealtime(self):\n    '''Check for presence of clock_gettime() in realtime library (POSIX Realtime extensions)'''\n    self.rt = None\n    funcs = ['clock_gettime']\n    prototypes = ['#include <time.h>']\n    calls = ['struct timespec tp; clock_gettime(CLOCK_REALTIME,&tp);']\n    if self.check('', funcs, prototype=prototypes, call=calls):\n      self.logPrint('realtime functions are linked in by default')\n      self.rt = []\n    elif self.check('rt', funcs, prototype=prototypes, call=calls):\n      self.logPrint('Using librt for the realtime library')\n      self.rt = ['librt.a']\n    else:\n      self.logPrint('Warning: No realtime library found')\n    return\n\n  def checkDynamic(self):\n    '''Check for the header and libraries necessary for dynamic library manipulation'''\n    if 'with-dynamic-loading' in self.argDB and not self.argDB['with-dynamic-loading']: return\n    self.check(['dl'], 'dlopen')\n    self.headers.check('dlfcn.h')\n    return\n\n  def checkShared(self, includes, initFunction, checkFunction, finiFunction = None, checkLink = None, libraries = [], initArgs = '&argc, &argv', boolType = 'int', noCheckArg = 0, defaultArg = '', executor = None, timeout = 15):\n    '''Determine whether a library is shared\n       - initFunction(int *argc, char *argv[]) is called to initialize some static data\n       - checkFunction(int *check) is called to verify that the static data wer set properly\n       - finiFunction() is called to finalize the data, and may be omitted\n       - checkLink may be given as ana alternative to the one in base.Configure'''\n    isShared = 0\n    if checkLink is None:\n      checkLink = self.checkLink\n      configObj = self\n    else:\n      if hasattr(checkLink, '__self__'):\n        configObj = checkLink.__self__\n      else:\n        configObj = self\n\n    # Fix these flags\n    oldFlags = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '+self.toString(libraries)+' '+self.setCompilers.LIBS\n\n    # Make a library which calls initFunction(), and returns checkFunction()\n    lib1Name = os.path.join(self.tmpDir, 'lib1.'+self.setCompilers.sharedLibraryExt)\n    if noCheckArg:\n      checkCode = 'isInitialized = '+checkFunction+'();'\n    else:\n      checkCode = checkFunction+'(&isInitialized);'\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint init(int argc,  char *argv[]) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s(%s);\n  %s\n  return (int) isInitialized;\n''' % (boolType, initFunction, initArgs, checkCode)\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib1Name)\n\n    # Make a library which calls checkFunction()\n    lib2Name = os.path.join(self.tmpDir, 'lib2.'+self.setCompilers.sharedLibraryExt)\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint checkInit(void) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s\n''' % (boolType, checkCode)\n    if finiFunction:\n      body += '  if (isInitialized) '+finiFunction+'();\\n'\n    body += '  return (int) isInitialized;\\n'\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n      return 0\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib2Name)\n\n    self.setCompilers.LIBS = oldFlags\n\n    # Make an executable that dynamically loads and calls both libraries\n    #   If the check returns true in the second library, the static data was shared\n    guard = self.headers.getDefineName('dlfcn.h')\n    if self.headers.headerPrefix:\n      guard = self.headers.headerPrefix+'_'+guard\n    defaultIncludes = '''\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef %s\n#include <dlfcn.h>\n#endif\n    ''' % guard\n    body = '''\n  int   argc    = 1;\n  char *argv[2] = {(char *) \"conftest\", NULL};\n  void *lib;\n  int (*init)(int, char **);\n  int (*checkInit)(void);\n\n  lib = dlopen(\"'''+lib1Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib1.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  init = (int (*)(int, char **)) dlsym(lib, \"init\");\n  if (!init) {\n    fprintf(stderr, \"Could not find initialization function\\\\n\");\n    exit(1);\n  }\n  if (!(*init)(argc, argv)) {\n    fprintf(stderr, \"Could not initialize library\\\\n\");\n    exit(1);\n  }\n  lib = dlopen(\"'''+lib2Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib2.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  checkInit = (int (*)(void)) dlsym(lib, \"checkInit\");\n  if (!checkInit) {\n    fprintf(stderr, \"Could not find initialization check function\\\\n\");\n    exit(1);\n  }\n  if (!(*checkInit)()) {\n    fprintf(stderr, \"Did not link with shared library\\\\n\");\n    exit(2);\n  }\n  '''\n    oldLibs = self.setCompilers.LIBS\n    if self.haveLib('dl'):\n      self.setCompilers.LIBS += ' -ldl'\n    isShared = 0\n    try:\n      isShared = self.checkRun(defaultIncludes, body, defaultArg = defaultArg, executor = executor, timeout = timeout)\n    except RuntimeError as e:\n      if executor and str(e).find('Runaway process exceeded time limit') > -1:\n        raise RuntimeError('Timeout: Unable to run MPI program with '+executor+'\\n\\\n    (1) make sure this is the correct program to run MPI jobs\\n\\\n    (2) your network may be misconfigured; see https://www.mcs.anl.gov/petsc/documentation/faq.html#PetscOptionsInsertFile\\n')\n\n    self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(lib1Name) and self.framework.doCleanup: os.remove(lib1Name)\n    if os.path.isfile(lib2Name) and self.framework.doCleanup: os.remove(lib2Name)\n    if isShared:\n      self.logPrint('Library was shared')\n    else:\n      self.logPrint('Library was not shared')\n    return isShared\n\n  def isBGL(self):\n    '''Returns true if compiler is IBM cross compiler for BGL'''\n    if not hasattr(self, '_isBGL'):\n      self.logPrint('**********Checking if running on BGL/IBM detected')\n      if (self.check('', 'bgl_perfctr_void') or self.check('','ADIOI_BGL_Open')) and self.check('', '_xlqadd'):\n        self.logPrint('*********BGL/IBM detected')\n        self._isBGL = 1\n      else:\n        self.logPrint('*********BGL/IBM test failure')\n        self._isBGL = 0\n    return self._isBGL\n\n  def configure(self):\n    list(map(lambda args: self.executeTest(self.check, list(args)), self.libraries))\n    self.executeTest(self.checkMath)\n    self.executeTest(self.checkMathErf)\n    self.executeTest(self.checkMathTgamma)\n    self.executeTest(self.checkMathFenv)\n    self.executeTest(self.checkMathLog2)\n    self.executeTest(self.checkRealtime)\n    self.executeTest(self.checkDynamic)\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/config/BuildSystem/config/setCompilers.py": "from __future__ import generators\nimport config.base\nimport config\n\nimport os\nfrom functools import reduce\n\n# not sure how to handle this with 'self' so its outside the class\ndef noCheck(command, status, output, error):\n  return\n\ntry:\n  any\nexcept NameError:\n  def any(lst):\n    return reduce(lambda x,y:x or y,lst,False)\n\ndef _picTestIncludes(export=''):\n  return '\\n'.join(['#include <stdio.h>',\n                    'int (*fprintf_ptr)(FILE*,const char*,...) = fprintf;',\n                    'void '+export+' foo(void){',\n                    '  fprintf_ptr(stdout,\"hello\");',\n                    '  return;',\n                    '}',\n                    'void bar(void){foo();}\\n'])\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.usedMPICompilers = 0\n    self.mainLanguage = 'C'\n    return\n\n  def __str__(self):\n    self.compilerflags = self.framework.getChild('config.compilerFlags')\n    desc = ['Compilers:']\n    if hasattr(self, 'CC'):\n      self.pushLanguage('C')\n      desc.append('  C Compiler:         '+self.getCompiler()+' '+self.getCompilerFlags())\n      if self.compilerflags.version['C']: desc.append('    Version: '+self.compilerflags.version['C'])\n      if not self.getLinker() == self.getCompiler(): desc.append('  C Linker:           '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CUDAC'):\n      self.pushLanguage('CUDA')\n      desc.append('  CUDA Compiler:      '+self.getCompiler()+' '+self.getCompilerFlags())\n      if self.compilerflags.version['CUDA']: desc.append('    Version: '+self.compilerflags.version['CUDA'])\n      if not self.getLinker() == self.getCompiler(): desc.append('  CUDA Linker:        '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CXX'):\n      self.pushLanguage('Cxx')\n      desc.append('  C++ Compiler:       '+self.getCompiler()+' '+self.getCompilerFlags())\n      if self.compilerflags.version['Cxx']: desc.append('    Version: '+self.compilerflags.version['Cxx'])\n      if not self.getLinker() == self.getCompiler(): desc.append('  C++ Linker:         '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'FC'):\n      self.pushLanguage('FC')\n      desc.append('  Fortran Compiler:   '+self.getCompiler()+' '+self.getCompilerFlags())\n      if self.compilerflags.version['FC']: desc.append('    Version: '+self.compilerflags.version['FC'])\n      if not self.getLinker() == self.getCompiler(): desc.append('  Fortran Linker:     '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    desc.append('Linkers:')\n    if hasattr(self, 'staticLinker'):\n      desc.append('  Static linker:   '+self.getSharedLinker()+' '+self.AR_FLAGS)\n    elif hasattr(self, 'sharedLinker'):\n      desc.append('  Shared linker:   '+self.getSharedLinker()+' '+self.getSharedLinkerFlags())\n    if hasattr(self, 'dynamicLinker'):\n      desc.append('  Dynamic linker:   '+self.getDynamicLinker()+' '+self.getDynamicLinkerFlags())\n      desc.append('  Libraries linked against:   '+self.LIBS)\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-cpp=<prog>', nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPP=<prog>',            nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C only (not used for C++ or FC) preprocessor options'))\n    help.addArgument('Compilers', '-with-cc=<prog>',  nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CC=<prog>',             nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CFLAGS=<string>',       nargs.Arg(None, None, 'Specify the C compiler options'))\n    help.addArgument('Compilers', '-CC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the C linker flags'))\n\n    help.addArgument('Compilers', '-CXXPP=<prog>',          nargs.Arg(None, None, 'Specify the C++ preprocessor'))\n    help.addArgument('Compilers', '-CXXPPFLAGS=<string>',   nargs.Arg(None, None, 'Specify the C++ preprocessor options'))\n    help.addArgument('Compilers', '-with-cxx=<prog>', nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXX=<prog>',            nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXXFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C++ compiler options, also passed to linker'))\n    help.addArgument('Compilers', '-CXX_CXXFLAGS=<string>', nargs.Arg(None, '',   'Specify the C++ compiler-only options, not passed to linker'))\n    help.addArgument('Compilers', '-CXX_LINKER_FLAGS=<string>',       nargs.Arg(None, [], 'Specify the C++ linker flags'))\n\n    help.addArgument('Compilers', '-FPP=<prog>',            nargs.Arg(None, None, 'Specify the Fortran preprocessor'))\n    help.addArgument('Compilers', '-FPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the Fortran preprocessor options'))\n    help.addArgument('Compilers', '-with-fc=<prog>',  nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FC=<prog>',             nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FFLAGS=<string>',       nargs.Arg(None, None, 'Specify the Fortran compiler options'))\n    help.addArgument('Compilers', '-FC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the FC linker flags'))\n\n    help.addArgument('Compilers', '-with-large-file-io=<bool>', nargs.ArgBool(None, 0, 'Allow IO with files greater then 2 GB'))\n\n    help.addArgument('Compilers', '-CUDAPP=<prog>',        nargs.Arg(None, None, 'Specify the CUDA preprocessor'))\n    help.addArgument('Compilers', '-CUDAPPFLAGS=<string>', nargs.Arg(None, '-Wno-deprecated-gpu-targets', 'Specify the CUDA preprocessor options'))\n    help.addArgument('Compilers', '-with-cudac=<prog>',    nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAC=<prog>',         nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAFLAGS=<string>',   nargs.Arg(None, None, 'Specify the CUDA compiler options'))\n    help.addArgument('Compilers', '-CUDAC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the CUDA linker flags'))\n\n##    help.addArgument('Compilers', '-LD=<prog>',              nargs.Arg(None, None, 'Specify the executable linker'))\n##    help.addArgument('Compilers', '-CC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for C only'))\n##    help.addArgument('Compilers', '-CXX_LD=<prog>',          nargs.Arg(None, None, 'Specify the linker for C++ only'))\n##    help.addArgument('Compilers', '-FC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for Fortran only'))\n    help.addArgument('Compilers', '-with-shared-ld=<prog>',  nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LD_SHARED=<prog>',       nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LDFLAGS=<string>',       nargs.Arg(None, '',   'Specify the linker options'))\n    help.addArgument('Compilers', '-with-ar=<prog>',                nargs.Arg(None, None,   'Specify the archiver'))\n    help.addArgument('Compilers', '-AR=<prog>',                     nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-AR_FLAGS=<string>',               nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-with-ranlib=<prog>',            nargs.Arg(None, None,   'Specify ranlib'))\n    help.addArgument('Compilers', '-with-pic=<bool>',               nargs.ArgBool(None, 0, 'Compile with -fPIC or equivalent flag if possible'))\n    help.addArgument('Compilers', '-sharedLibraryFlags=<string>',     nargs.Arg(None, [], 'Specify the shared library flags'))\n    help.addArgument('Compilers', '-dynamicLibraryFlags=<string>',    nargs.Arg(None, [], 'Specify the dynamic library flags'))\n    help.addArgument('Compilers', '-LIBS=<string>',          nargs.Arg(None, None, 'Specify extra libraries for all links'))\n    help.addArgument('Compilers', '-with-environment-variables=<bool>',nargs.ArgBool(None, 0, 'Use compiler variables found in environment'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.languages = framework.require('PETSc.options.languages', self)\n    self.libraries = self.framework.getChild('config.libraries')\n    self.headers   = self.framework.getChild('config.headers')    \n    return\n\n  def isNAG(compiler, log):\n    '''Returns true if the compiler is a NAG F90 compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('NAGWare Fortran') >= 0 or output.find('The Numerical Algorithms Group Ltd') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isNAG = staticmethod(isNAG)\n\n  def isGNU(compiler, log):\n    '''Returns true if the compiler is a GNU compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20 ', log = log)\n      output = output + error\n      return (any([s in output for s in ['www.gnu.org',\n                                         'bugzilla.redhat.com',\n                                         'gcc.gnu.org',\n                                         'gcc version',\n                                         '-print-libgcc-file-name',\n                                         'passed on to the various sub-processes invoked by gcc',\n                                         'passed on to the various sub-processes invoked by cc',\n                                         'passed on to the various sub-processes invoked by gfortran',\n                                         'passed on to the various sub-processes invoked by g++',\n                                         'passed on to the various sub-processes invoked by c++',\n                                         ]])\n              and not any([s in output for s in ['Intel(R)',\n                                                 'Unrecognised option --help passed to ld', # NAG f95 compiler\n                                                 ]]))\n    except RuntimeError:\n      pass\n    return 0\n  isGNU = staticmethod(config.memoize(isGNU))\n\n  def isClang(compiler, log):\n    '''Returns true if the compiler is a Clang/LLVM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 500', log = log, logOutputflg = False)\n      output = output + error\n      return any([s in output for s in ['Emit Clang AST']])\n    except RuntimeError:\n      pass\n    return 0\n  isClang = staticmethod(isClang)\n\n  def isGfortran45x(compiler, log):\n    '''returns true if the compiler is gfortran-4.5.x'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.5.\\d+|4.6.0 20100703)', output):\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran45x = staticmethod(isGfortran45x)\n\n  def isGfortran46plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.6.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,6):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran46plus = staticmethod(isGfortran46plus)\n\n  def isGfortran47plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.7.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,7):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran47plus = staticmethod(isGfortran47plus)\n\n\n  def isGfortran8plus(compiler, log):\n    '''returns true if the compiler is gfortran-8 or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (8,0):\n          return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran8plus = staticmethod(isGfortran8plus)\n\n  def isG95(compiler, log):\n    '''Returns true if the compiler is g95'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('http://www.g95.org') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isG95 = staticmethod(isG95)\n\n  def isCompaqF90(compiler, log):\n    '''Returns true if the compiler is Compaq f90'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('Compaq Visual Fortran') >= 0 or output.find('Digital Visual Fortran') >=0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCompaqF90 = staticmethod(isCompaqF90)\n\n  def isSun(compiler, log):\n    '''Returns true if the compiler is a Sun/Oracle compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find(' Sun ') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSun = staticmethod(isSun)\n\n  def isIBM(compiler, log):\n    '''Returns true if the compiler is a IBM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -qversion', log = log)\n      output = output + error\n      if 'IBM XL' in output:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIBM = staticmethod(isIBM)\n\n  def isIntel(compiler, log):\n    '''Returns true if the compiler is a Intel compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Intel Corporation') >= 0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIntel = staticmethod(isIntel)\n\n  def isCray(compiler, log):\n    '''Returns true if the compiler is a Cray compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V', log = log)\n      output = output + error\n      if output.find('Cray Standard C') >= 0 or output.find('Cray C++') >= 0 or output.find('Cray Fortran') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCray = staticmethod(isCray)\n\n  def isCrayVector(compiler, log):\n    '''Returns true if the compiler is a Cray compiler for a Cray Vector system'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -VV', log = log)\n      output = output + error\n      if not status and output.find('x86') >= 0:\n        return 0\n      elif not status:\n        return 1\n      else:\n        return 0\n    except RuntimeError:\n      pass\n    return 0\n  isCrayVector = staticmethod(isCrayVector)\n\n\n  def isPGI(compiler, log):\n    '''Returns true if the compiler is a PGI compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('The Portland Group') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isPGI = staticmethod(isPGI)\n\n  def isSolarisAR(ar, log):\n    '''Returns true AR is solaris'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('Software Generation Utilities') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSolarisAR = staticmethod(isSolarisAR)\n\n  def isAIXAR(ar, log):\n    '''Returns true AR is AIX'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('[-X{32|64|32_64|d64|any}]') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isAIXAR = staticmethod(isAIXAR)\n\n\n  def isLinux(log):\n    '''Returns true if system is linux'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('linux') >= 0:\n      return 1\n    else:\n      return 0\n  isLinux = staticmethod(isLinux)\n\n  def isCygwin(log):\n    '''Returns true if system is cygwin'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('cygwin') >= 0:\n      return 1\n    else:\n      return 0\n  isCygwin = staticmethod(isCygwin)\n\n  def isSolaris(log):\n    '''Returns true if system is solaris'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('sunos') >= 0:\n      return 1\n    else:\n      return 0\n  isSolaris = staticmethod(isSolaris)\n\n  def isDarwin(log):\n    '''Returns true if system is Darwin/MacOSX'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'darwin'\n    return 0\n  isDarwin = staticmethod(isDarwin)\n\n  def isDarwinCatalina(log):\n    '''Returns true if system is Darwin/MacOSX Version Catalina or higher'''\n    import platform\n    if platform.system() != 'Darwin': return 0\n    v = tuple([int(a) for a in platform.mac_ver()[0].split('.')])\n    if v < (10,15,0): return 0\n    return 1\n  isDarwinCatalina = staticmethod(isDarwinCatalina)\n\n  def isFreeBSD(log):\n    '''Returns true if system is FreeBSD'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      return output.lower().strip() == 'freebsd'\n    return 0\n  isFreeBSD = staticmethod(isFreeBSD)\n\n  def isWindows(compiler, log):\n    '''Returns true if the compiler is a Windows compiler'''\n    if compiler in ['icl', 'cl', 'bcc32', 'ifl', 'df']:\n      return 1\n    if compiler in ['ifort','f90'] and Configure.isCygwin(log):\n      return 1\n    if compiler in ['lib', 'tlib']:\n      return 1\n    return 0\n  isWindows = staticmethod(isWindows)\n\n  def addLdPath(path):\n    if 'LD_LIBRARY_PATH' in os.environ:\n      ldPath=os.environ['LD_LIBRARY_PATH']\n    else:\n      ldPath=''\n    if ldPath == '': ldPath = path\n    else: ldPath += ':' + path\n    os.environ['LD_LIBRARY_PATH'] = ldPath\n    return\n  addLdPath = staticmethod(addLdPath)\n\n  def useMPICompilers(self):\n    if ('with-cc' in self.argDB and self.argDB['with-cc'] != '0') or 'CC' in self.argDB:\n      return 0\n    if ('with-cxx' in self.argDB and self.argDB['with-cxx'] != '0') or 'CXX' in self.argDB:\n      return 0\n    if ('with-fc' in self.argDB and self.argDB['with-fc'] != '0') or 'FC' in self.argDB:\n      return 0\n    if self.argDB['download-mpich'] or self.argDB['download-openmpi']:\n      return 0\n    if 'with-mpi' in self.argDB and self.argDB['with-mpi'] and self.argDB['with-mpi-compilers']:\n      return 1\n    return 0\n\n  def checkInitialFlags(self):\n    '''Initialize the compiler and linker flags'''\n    for language in ['C', 'CUDA', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      for flagsArg in [config.base.Configure.getCompilerFlagsName(language), config.base.Configure.getCompilerFlagsName(language, 1), config.base.Configure.getLinkerFlagsName(language)]:\n        if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n        else: setattr(self, flagsArg, '')\n        self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n      self.popLanguage()\n    for flagsArg in ['CPPFLAGS', 'FPPFLAGS', 'CUDAPPFLAGS', 'CXXPPFLAGS', 'CC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS','sharedLibraryFlags', 'dynamicLibraryFlags']:\n      if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n      else: setattr(self, flagsArg, '')\n      self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    if 'LIBS' in self.argDB:\n      self.LIBS = self.argDB['LIBS']\n    else:\n      self.LIBS = ''\n    return\n\n  def checkCompiler(self, language, linkLanguage=None,includes = '', body = '', cleanup = 1, codeBegin = None, codeEnd = None):\n    '''Check that the given compiler is functional, and if not raise an exception'''\n    self.pushLanguage(language)\n    if not self.checkCompile(includes, body, cleanup, codeBegin, codeEnd):\n      msg = 'Cannot compile '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if language == 'CUDA': # do not check CUDA linker since it is never used (and is broken on Mac with -m64)\n      self.popLanguage()\n      return\n    if not self.checkLink(linkLanguage=linkLanguage,includes=includes,body=body):\n      msg = 'Cannot compile/link '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    oldlibs = self.LIBS\n    self.LIBS += ' -lpetsc-ufod4vtr9mqHvKIQiVAm'\n    if self.checkLink(linkLanguage=linkLanguage):\n      msg = language + ' compiler ' + self.getCompiler()+ ''' is broken! It is returning a zero error when the linking failed! Either\n 1) switch to another compiler suite or\n 2) report this entire error message to your compiler/linker suite vendor and ask for fix for this issue.'''\n      self.popLanguage()\n      self.LIBS = oldlibs\n      raise RuntimeError(msg)\n    self.LIBS = oldlibs\n    if not self.argDB['with-batch']:\n      if not self.checkRun(linkLanguage=linkLanguage):\n        msg = 'Cannot run executables created with '+language+'. If this machine uses a batch system \\nto submit jobs you will need to configure using ./configure with the additional option  --with-batch.\\n Otherwise there is problem with the compilers. Can you compile and run code with your compiler \\''+ self.getCompiler()+'\\'?\\n'\n        if self.isIntel(self.getCompiler(), self.log):\n          msg = msg + 'See https://www.mcs.anl.gov/petsc/documentation/faq.html#libimf'\n        self.popLanguage()\n        raise OSError(msg)\n    self.popLanguage()\n    return\n\n  def crayCrossCompiler(self,compiler):\n    import script\n    '''For Cray Intel KNL systems returns the underlying compiler line used by the wrapper compiler if is for KNL systems'''\n    '''This removes all the KNL specific options allowing the generated binary to run on the front-end'''\n    '''This is needed by some build systems include HDF5 that insist on running compiled programs during the configure and'''\n    '''make process. This does not work for the Cray compiler module, only intel and gcc'''\n\n    (output,error,status) = self.executeShellCommand(compiler+' -craype-verbose',checkCommand = script.Script.passCheckCommand,log=self.log)\n    output = output.split()\n    if output[0].strip().startswith('driver'): return ''\n    newoutput = [output[0]]\n    cross = 0\n    for i in output[1:-1]:\n      if i.find('mic') > -1 or i.find('knl') > -1 or i.find('KNL') > -1:\n        cross = 1\n        continue\n      if i.startswith('-L') or i.startswith('-l') or i.startswith('-Wl'):\n        continue\n      newoutput.append(i)\n    if cross:\n      return ' '.join(newoutput)\n    return ''\n\n  def crayCrossLIBS(self,compiler):\n    import script\n    '''For Cray Intel KNL systems returns the underlying linker options used by the wrapper compiler if is for KNL systems'''\n    (output,error,status) = self.executeShellCommand(compiler+' -craype-verbose',checkCommand = script.Script.passCheckCommand,log=self.log)\n    output = output.split()\n    newoutput = []\n    cross = 0\n    for i in output[1:-1]:\n      if i.find('mic') > -1 or i.find('knl') > -1 or i.find('KNL') > -1:\n        cross = 1\n        continue\n      if i.find('darshan') > -1:\n        cross = 1\n        continue\n      if i.find('static') > -1:\n        continue\n      if i.startswith('-I') or i.startswith('-D'):\n        continue\n      # the math libraries are not needed by external packages and cause errors in HDF5 with libgfortran.so.4 => not found\n      if i.startswith('-lsci_gnu'):\n        continue\n      newoutput.append(i)\n    if cross:\n      return ' '.join(newoutput)\n    return ''\n\n  def generateCCompilerGuesses(self):\n    '''Determine the C compiler '''\n    if hasattr(self, 'CC'):\n      yield self.CC\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-cc' in self.argDB:\n      if self.isWindows(self.argDB['with-cc'], self.log):\n        yield 'win32fe '+self.argDB['with-cc']\n      else:\n        yield self.argDB['with-cc']\n      raise RuntimeError('C compiler you provided with -with-cc='+self.argDB['with-cc']+' does not work.'+'\\n'+self.mesg)\n    elif 'CC' in self.argDB:\n      if self.isWindows(self.argDB['CC'], self.log):\n        yield 'win32fe '+self.argDB['CC']\n      else:\n        yield self.argDB['CC']\n      raise RuntimeError('C compiler you provided with -CC='+self.argDB['CC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('MPI compiler wrappers in '+self.argDB['with-mpi-dir']+'/bin do not work. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers() and 'with-mpi-dir' in self.argDB:\n      # if it gets here these means that self.argDB['with-mpi-dir']/bin does not exist so we should not search for MPI compilers\n      # that is we are turning off the self.useMPICompilers()\n        self.logPrintBox('***** WARNING: '+os.path.join(self.argDB['with-mpi-dir'], 'bin')+ ' dir does not exist!\\n Skipping check for MPI compilers due to potentially incorrect --with-mpi-dir option.\\n Suggest using --with-cc=/path/to/mpicc option instead ******')\n\n        self.argDB['with-mpi-compilers'] = 0\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_cc = self.crayCrossCompiler('cc')\n          if cross_cc:\n            self.cross_cc = cross_cc\n            self.log.write('Cray system using C cross compiler:'+cross_cc+'\\n')\n            self.cross_LIBS = self.crayCrossLIBS('cc')\n            self.log.write('Cray system using C cross LIBS:'+self.cross_LIBS+'\\n')\n          yield 'cc'\n          if cross_cc:\n            delattr(self, 'cross_cc')\n            delattr(self, 'cross_LIBS')\n        yield 'mpicc'\n        yield 'mpiicc'\n        yield 'mpcc_r'\n        yield 'mpcc'\n        yield 'mpxlc'\n        yield 'hcc'\n        self.usedMPICompilers = 0\n      yield 'gcc'\n      yield 'clang'\n      yield 'icc'\n      yield 'cc'\n      yield 'xlc'\n      yield 'win32fe icl'\n      yield 'win32fe cl'\n      yield 'pgcc'\n      yield 'win32fe bcc32'\n    return\n\n  def checkCCompiler(self):\n    '''Locate a functional C compiler'''\n    if 'with-cc' in self.argDB and self.argDB['with-cc'] == '0':\n      raise RuntimeError('A functional C compiler is necessary for configure, cannot use --with-cc=0')\n    self.mesg = ''\n    for compiler in self.generateCCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CC'):\n          self.checkCompiler('C')\n          break\n      except RuntimeError as e:\n        import os\n        self.mesg = str(e)\n        self.logPrint('Error testing C compiler: '+str(e))\n        if os.path.basename(self.CC) == 'mpicc':\n          self.logPrint(' MPI installation '+str(self.CC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('CC')\n        del self.CC\n    if not hasattr(self, 'CC'):\n      raise RuntimeError('Could not locate a functional C compiler')\n    try:\n      self.executeShellCommand(self.CC+' --version', log = self.log)\n    except:\n      pass\n    return\n\n  def generateCPreprocessorGuesses(self):\n    '''Determines the C preprocessor from CPP, then --with-cpp, then the C compiler'''\n    if 'with-cpp' in self.argDB:\n      yield self.argDB['with-cpp']\n    elif 'CPP' in self.argDB:\n      yield self.argDB['CPP']\n    else:\n      yield self.CC+' -E'\n      yield self.CC+' --use cpp32'\n    return\n\n  def checkCPreprocessor(self):\n    '''Locate a functional C preprocessor'''\n    for compiler in self.generateCPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CPP'):\n          self.pushLanguage('C')\n          if not self.checkPreprocess('#include <stdlib.h>\\n'):\n            raise RuntimeError('Cannot preprocess C with '+self.CPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    raise RuntimeError('Cannot find a C preprocessor')\n    return\n\n  def generateCUDACompilerGuesses(self):\n    import os\n    '''Determine the CUDA compiler using CUDAC, then --with-cudac\n       - Any given category can be excluded'''\n    if hasattr(self, 'CUDAC'):\n      yield self.CUDAC\n      raise RuntimeError('Error: '+self.mesg)\n    elif 'with-cudac' in self.argDB:\n      yield self.argDB['with-cudac']\n      raise RuntimeError('CUDA compiler you provided with -with-cudac='+self.argDB['with-cudac']+' does not work.'+'\\n'+self.mesg)\n    elif 'CUDAC' in self.argDB:\n      yield self.argDB['CUDAC']\n      raise RuntimeError('CUDA compiler you provided with -CUDAC='+self.argDB['CUDAC']+' does not work.'+'\\n'+self.mesg)\n    elif 'with-cuda-dir' in self.argDB:\n      import os\n      nvccPath = os.path.join(self.argDB['with-cuda-dir'], 'bin','nvcc')\n      yield nvccPath\n    else:\n      yield 'nvcc'\n      yield os.path.join('/Developer','NVIDIA','CUDA-6.5','bin','nvcc')\n      yield os.path.join('/usr','local','cuda','bin','nvcc')\n    return\n\n  def checkCUDACompiler(self):\n    '''Locate a functional CUDA compiler'''\n    if ('with-cudac' in self.argDB and self.argDB['with-cudac'] == '0'):\n      if 'CUDAC' in self.argDB:\n        del self.argDB['CUDAC']\n      return\n    self.mesg = ''\n    for compiler in self.generateCUDACompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAC'):\n          self.checkCompiler('CUDA')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.CUDAC+' --version', log = self.log)\n          compilerVersion = compilerVersion[0]\n          compilerVersion = compilerVersion.split()\n          i = 0\n          for word in compilerVersion:\n            i = i+1\n            if word == 'release':\n              break\n          self.compilerVersionCUDA = compilerVersion[i].strip(',')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing CUDA compiler: '+str(e))\n        self.delMakeMacro('CUDAC')\n        del self.CUDAC\n    return\n\n  def generateCUDAPreprocessorGuesses(self):\n    '''Determines the CUDA preprocessor from --with-cudacpp, then CUDAPP, then the CUDA compiler'''\n    if 'with-cudacpp' in self.argDB:\n      yield self.argDB['with-cudacpp']\n    elif 'CUDAPP' in self.argDB:\n      yield self.argDB['CUDAPP']\n    else:\n      if hasattr(self, 'CUDAC'):\n        yield self.CUDAC+' -E'\n    return\n\n  def checkCUDAPreprocessor(self):\n    '''Locate a functional CUDA preprocessor'''\n    for compiler in self.generateCUDAPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAPP'):\n          self.pushLanguage('CUDA')\n          if not self.checkPreprocess('#include <stdlib.h>\\n__global__ void testFunction() {return;};'):\n            raise RuntimeError('Cannot preprocess CUDA with '+self.CUDAPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    return\n\n  def generateCxxCompilerGuesses(self):\n    '''Determine the Cxx compiler'''\n    import os\n\n    if hasattr(self, 'CXX'):\n      yield self.CXX\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-c++' in self.argDB:\n      raise RuntimeError('Keyword --with-c++ is WRONG, use --with-cxx')\n    if 'with-CC' in self.argDB:\n      raise RuntimeError('Keyword --with-CC is WRONG, use --with-cxx')\n\n    if 'with-cxx' in self.argDB:\n      if self.argDB['with-cxx'] == 'gcc': raise RuntimeError('Cannot use C compiler gcc as the C++ compiler passed in with --with-cxx')\n      if self.isWindows(self.argDB['with-cxx'], self.log):\n        yield 'win32fe '+self.argDB['with-cxx']\n      else:\n        yield self.argDB['with-cxx']\n      raise RuntimeError('C++ compiler you provided with -with-cxx='+self.argDB['with-cxx']+' does not work.'+'\\n'+self.mesg)\n    elif 'CXX' in self.argDB:\n      if self.isWindows(self.argDB['CXX'], self.log):\n        yield 'win32fe '+self.argDB['CXX']\n      else:\n        yield self.argDB['CXX']\n      raise RuntimeError('C++ compiler you provided with -CXX='+self.argDB['CXX']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiicpc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicxx')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcp')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpic++')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiCC')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpCC_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('bin/<mpiCC,mpicxx,hcp,mpCC_r> you provided with -with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_CC = self.crayCrossCompiler('CC')\n          if cross_CC:\n            self.cross_CC = cross_CC\n            self.log.write('Cray system using C++ cross compiler:'+cross_CC+'\\n')\n          yield 'CC'\n          if cross_CC: delattr(self, 'cross_CC')\n        yield 'mpicxx'\n        yield 'mpiicpc'\n        yield 'mpCC_r'\n        yield 'mpiCC'\n        yield 'mpic++'\n        yield 'mpCC'\n        yield 'mpxlC'\n        self.usedMPICompilers = 0\n      #attempt to match c++ compiler with c compiler\n      if self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe cl'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe icl'\n      elif self.CC == 'gcc':\n        yield 'g++'\n      elif self.CC == 'clang':\n        yield 'clang++'\n      elif self.CC == 'icc':\n        yield 'icpc'\n      elif self.CC == 'xlc':\n        yield 'xlC'\n      yield 'g++'\n      yield 'clang++'\n      yield 'c++'\n      yield 'icpc'\n      yield 'CC'\n      yield 'cxx'\n      yield 'cc++'\n      yield 'xlC'\n      yield 'ccpc'\n      yield 'win32fe icl'\n      yield 'win32fe cl'\n      yield 'pgCC'\n      yield 'CC'\n      yield 'win32fe bcc32'\n    return\n\n  def checkCxxCompiler(self):\n    '''Locate a functional Cxx compiler'''\n    if 'with-cxx' in self.argDB and self.argDB['with-cxx'] == '0':\n      if 'CXX' in self.argDB:\n        del self.argDB['CXX']\n      return\n    self.mesg = ''\n    for compiler in self.generateCxxCompilerGuesses():\n      # Determine an acceptable extensions for the C++ compiler\n      for ext in ['.cc', '.cpp', '.C']:\n        self.framework.getCompilerObject('Cxx').sourceExtension = ext\n        try:\n          if self.getExecutable(compiler, resultName = 'CXX'):\n            self.checkCompiler('Cxx')\n            break\n        except RuntimeError as e:\n          import os\n          self.mesg = str(e)\n          self.logPrint('Error testing C++ compiler: '+str(e))\n          if os.path.basename(self.CXX) in ['mpicxx', 'mpiCC']:\n            self.logPrint('  MPI installation '+str(self.CXX)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n          self.delMakeMacro('CXX')\n          del self.CXX\n      if hasattr(self, 'CXX'):\n        try:\n          self.executeShellCommand(self.CXX+' --version', log = self.log)\n        except:\n          pass\n        break\n    return\n\n  def generateCxxPreprocessorGuesses(self):\n    '''Determines the Cxx preprocessor from CXXPP, then --with-cxxpp, then the Cxx compiler'''\n    if 'with-cxxpp' in self.argDB:\n      yield self.argDB['with-cxxpp']\n    elif 'CXXPP' in self.argDB:\n      yield self.argDB['CXXPP']\n    else:\n      yield self.CXX+' -E'\n      yield self.CXX+' --use cpp32'\n    return\n\n  def checkCxxPreprocessor(self):\n    '''Locate a functional Cxx preprocessor'''\n    if not hasattr(self, 'CXX'):\n      return\n    for compiler in self.generateCxxPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CXXPP'):\n          self.pushLanguage('Cxx')\n          if not self.checkPreprocess('#include <cstdlib>\\n'):\n            raise RuntimeError('Cannot preprocess Cxx with '+self.CXXPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError as e:\n        import os\n\n        if os.path.basename(self.CXXPP) in ['mpicxx', 'mpiCC']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('CXXPP')\n        del self.CXXPP\n    return\n\n  def generateFortranCompilerGuesses(self):\n    '''Determine the Fortran compiler'''\n    import os\n\n    if hasattr(self, 'FC'):\n      yield self.FC\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-fc' in self.argDB:\n      if self.isWindows(self.argDB['with-fc'], self.log):\n        yield 'win32fe '+self.argDB['with-fc']\n      else:\n        yield self.argDB['with-fc']\n      raise RuntimeError('Fortran compiler you provided with --with-fc='+self.argDB['with-fc']+' does not work.'+'\\n'+self.mesg)\n    elif 'FC' in self.argDB:\n      if self.isWindows(self.argDB['FC'], self.log):\n        yield 'win32fe '+self.argDB['FC']\n      else:\n        yield self.argDB['FC']\n      yield self.argDB['FC']\n      raise RuntimeError('Fortran compiler you provided with -FC='+self.argDB['FC']+' does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiifort')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf95_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf90_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf_r')\n      self.usedMPICompilers = 0\n      if os.path.isfile(os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')):\n        raise RuntimeError('bin/mpif90 you provided with --with-mpi-dir='+self.argDB['with-mpi-dir']+' does not work.\\nRun with --with-fc=0 if you wish to use this MPI and disable Fortran. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_fc = self.crayCrossCompiler('ftn')\n          if cross_fc:\n            self.cross_fc = cross_fc\n            self.log.write('Cray system using Fortran cross compiler:'+cross_fc+'\\n')\n          yield 'ftn'\n          if cross_fc: delattr(self, 'cross_fc')\n        yield 'mpif90'\n        yield 'mpiifort'\n        yield 'mpxlf_r'\n        yield 'mpxlf'\n        yield 'mpf90'\n        self.usedMPICompilers = 0\n      #attempt to match fortran compiler with c compiler\n      if self.CC == 'gcc':\n        yield 'gfortran'\n      elif self.CC == 'clang':\n        yield 'gfortran'\n      elif self.CC == 'icc':\n        yield 'ifort'\n      elif self.CC == 'xlc':\n        yield 'xlf90'\n        yield 'xlf'\n      elif self.CC.find('win32fe cl') >= 0:\n        yield 'win32fe f90'\n        yield 'win32fe ifc'\n      elif self.CC.find('win32fe icl') >= 0:\n        yield 'win32fe ifc'\n      yield 'gfortran'\n      yield 'g95'\n      yield 'xlf90'\n      yield 'xlf'\n      yield 'f90'\n      yield 'lf95'\n      yield 'win32fe ifort'\n      yield 'win32fe ifl'\n      yield 'ifort'\n      yield 'ifc'\n      yield 'pgf90'\n      yield 'f95'\n      yield 'f90'\n    return\n\n  def checkFortranCompiler(self):\n    '''Locate a functional Fortran compiler'''\n    if 'with-fc' in self.argDB and self.argDB['with-fc'] == '0':\n      if 'FC' in self.argDB:\n        del self.argDB['FC']\n      return\n    self.mesg = ''\n    for compiler in self.generateFortranCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FC'):\n          self.checkCompiler('FC')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing Fortran compiler: '+str(e))\n        if os.path.basename(self.FC) in ['mpif90']:\n          self.logPrint(' MPI installation '+str(self.FC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('FC')\n        del self.FC\n    if hasattr(self, 'FC'):\n      try:\n        self.executeShellCommand(self.FC+' --version', log = self.log)\n      except:\n        pass\n    return\n\n  def generateFortranPreprocessorGuesses(self):\n    '''Determines the Fortran preprocessor from FPP, then --with-fpp, then the Fortran compiler'''\n    if 'with-fpp' in self.argDB:\n      yield self.argDB['with-fpp']\n    elif 'FPP' in self.argDB:\n      yield self.argDB['FPP']\n    else:\n      yield self.FC+' -E'\n      yield self.FC+' --use cpp32'\n    return\n\n  def checkFortranPreprocessor(self):\n    '''Locate a functional Fortran preprocessor'''\n    if not hasattr(self, 'FC'):\n      return\n    for compiler in self.generateFortranPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FPP'):\n          self.pushLanguage('FC')\n          if not self.checkPreprocess('#define foo 10\\n'):\n            raise RuntimeError('Cannot preprocess Fortran with '+self.FPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError as e:\n        import os\n\n        if os.path.basename(self.FPP) in ['mpif90']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('FPP')\n        del self.FPP\n    return\n\n\n  def checkFortranComments(self):\n    '''Make sure fortran comment \"!\" works'''\n    self.pushLanguage('FC')\n    if not self.checkCompile('! comment'):\n      raise RuntimeError(self.getCompiler()+' cannot process fortran comments.')\n    self.logPrint('Fortran comments can use ! in column 1')\n    self.popLanguage()\n    return\n\n  def containsInvalidFlag(self, output):\n    '''If the output contains evidence that an invalid flag was used, return True'''\n    if (output.find('Unrecognized command line option') >= 0 or output.find('Unrecognised command line option') >= 0 or\n        output.find('unrecognized command line option') >= 0 or output.find('unrecognized option') >= 0 or output.find('unrecognised option') >= 0 or\n        output.find('not recognized') >= 0 or output.find('not recognised') >= 0 or\n        output.find('unknown option') >= 0 or output.find('unknown flag') >= 0 or output.find('Unknown switch') >= 0 or\n        output.find('ignoring option') >= 0 or output.find('ignored') >= 0 or\n        output.find('argument unused') >= 0 or output.find('not supported') >= 0 or\n        # When checking for the existence of 'attribute'\n        output.find('is unsupported and will be skipped') >= 0 or\n        output.find('illegal option') >= 0 or output.find('Invalid option') >= 0 or\n        (output.find('bad ') >= 0 and output.find(' option') >= 0) or\n        output.find('linker input file unused because linking not done') >= 0 or\n        output.find('PETSc Error') >= 0 or\n        output.find('Unbekannte Option') >= 0 or\n        output.find('warning: // comments are not allowed in this language') >= 0 or\n        output.find('no se reconoce la opci') >= 0) or output.find('non reconnue') >= 0:\n      return 1\n    return 0\n\n  def checkCompilerFlag(self, flag, includes = '', body = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, error, status) = self.outputCompile(includes, body)\n    output += error\n    valid   = 1\n    setattr(self, flagsArg, oldFlags)\n    # Please comment each entry and provide an example line\n    if status:\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to nonzero status from link')\n    # Lahaye F95\n    if output.find('Invalid suboption') >= 0:\n      valid = 0\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to \\n'+output)\n    return valid\n\n  def insertCompilerFlag(self, flag, compilerOnly):\n    '''DANGEROUS: Put in the compiler flag without checking'''\n    if not flag: return\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n    self.log.write('Added '+self.language[-1]+' compiler flag '+flag+'\\n')\n    return\n\n  def addCompilerFlag(self, flag, includes = '', body = '', extraflags = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkCompilerFlag(flag+' '+extraflags, includes, body, compilerOnly):\n      self.insertCompilerFlag(flag, compilerOnly)\n      return\n    raise RuntimeError('Bad compiler flag: '+flag)\n\n  def generatePICGuesses(self):\n    yield ''\n    if self.language[-1] == 'CUDA':\n      yield '-Xcompiler -fPIC'\n    elif config.setCompilers.Configure.isGNU(self.getCompiler(), self.log):\n      yield '-fPIC'\n    else:\n      yield '-PIC'\n      yield '-fPIC'\n      yield '-KPIC'\n      yield '-qpic'\n    return\n\n  def checkPIC(self):\n    '''Determine the PIC option for each compiler'''\n    self.usePIC = 0\n    useSharedLibraries = 'with-shared-libraries' in self.argDB and self.argDB['with-shared-libraries']\n    myLanguage = self.language[-1]\n    if not self.argDB['with-pic'] and not useSharedLibraries:\n      self.logPrint(\"Skip checking PIC options on user request\")\n      return\n    if self.argDB['with-pic'] and not useSharedLibraries:\n      # this is a flaw in configure; it is a legitimate use case where PETSc is built with PIC flags but not shared libraries\n      # to fix it the capability to build shared libraries must be enabled in configure if --with-pic=true even if shared libraries are off and this\n      # test must use that capability instead of using the default shared library build in that case which is static libraries\n      raise RuntimeError(\"Cannot determine compiler PIC flags if shared libraries is turned off\\nEither run using --with-shared-libraries or --with-pic=0 and supply the compiler PIC flag via CFLAGS, CXXXFLAGS, and FCFLAGS\\n\")\n    if self.sharedLibraries and self.mainLanguage == 'C': languages = []\n    else: languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      self.pushLanguage(language)\n      if language in ['C','Cxx','CUDA']:\n        includeLine = _picTestIncludes()\n      else:\n        includeLine = '      function foo(a)\\n      real:: a,x,bar\\n      common /xx/ x\\n      x=a\\n      foo = bar(x)\\n      end\\n'\n      compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n      oldCompilerFlags = getattr(self, compilerFlagsArg)\n      for testFlag in self.generatePICGuesses():\n        if testFlag:\n          self.logPrint('Trying '+language+' compiler flag '+testFlag+' for PIC code')\n        else:\n          self.logPrint('Trying '+language+' for PIC code without any compiler flag')\n        acceptedPIC = 1\n        try:\n          self.addCompilerFlag(testFlag, compilerOnly = 1)\n          acceptedPIC = self.checkLink(includes = includeLine, body = None, codeBegin = '', codeEnd = '', cleanup = 1, shared = 1, linkLanguage = myLanguage)\n        except RuntimeError:\n          acceptedPIC = 0\n        if not acceptedPIC:\n          self.logPrint('Rejected '+language+' compiler flag '+testFlag+' because shared linker cannot handle it')\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n          continue\n        if testFlag:\n          self.logPrint('Accepted '+language+' compiler flag '+testFlag+' for PIC code')\n        else:\n          self.logPrint('Accepted '+language+' PIC code without compiler flag')\n        self.isPIC = 1\n        break\n      self.popLanguage()\n    return\n\n  def checkLargeFileIO(self):\n    # check for large file support with 64bit offset\n    if not self.argDB['with-large-file-io']:\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      if self.checkCompile('#include <unistd.h>','#ifndef _LFS64_LARGEFILE \\n#error no largefile defines \\n#endif'):\n        try:\n          self.addCompilerFlag('-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64',compilerOnly=1)\n        except RuntimeError as e:\n          self.logPrint('Error adding ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      else:\n        self.logPrint('Rejected ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      self.popLanguage()\n    return\n\n  def getArchiverFlags(self, archiver):\n    prog = os.path.basename(archiver).split(' ')[0]\n    flag = ''\n    if 'AR_FLAGS' in self.argDB:\n      flag = self.argDB['AR_FLAGS']\n    elif prog.endswith('ar'):\n      flag = 'cr'\n    elif prog == 'win32fe':\n      args = os.path.basename(archiver).split(' ')\n      if 'lib' in args:\n        flag = '-a'\n      elif 'tlib' in args:\n        flag = '-a -P512'\n    if prog.endswith('ar') and not (self.isSolarisAR(prog, self.log) or self.isAIXAR(prog, self.log)):\n      self.FAST_AR_FLAGS = 'Scq'\n    else:\n      self.FAST_AR_FLAGS = flag\n    self.framework.addMakeMacro('FAST_AR_FLAGS',self.FAST_AR_FLAGS )\n    return flag\n\n  def generateArchiverGuesses(self):\n    defaultAr = None\n    if 'with-ar' in self.argDB:\n      if self.isWindows(self.argDB['with-ar'], self.log):\n        defaultAr = 'win32fe '+self.argDB['with-ar']\n      else:\n        defaultAr = self.argDB['with-ar']\n    envAr = None\n    if 'AR' in self.argDB:\n      if self.isWindows(self.argDB['AR'], self.log):\n        envAr = 'win32fe '+self.argDB['AR']\n      else:\n        envAr = self.argDB['AR']\n    defaultRanlib = None\n    if 'with-ranlib' in self.argDB:\n      defaultRanlib = self.argDB['with-ranlib']\n    envRanlib = None\n    if 'RANLIB' in self.argDB:\n      envRanlib = self.argDB['RANLIB']\n    if defaultAr and defaultRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),defaultRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if defaultAr and envRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),envRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if envAr and defaultRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),defaultRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if envAr and envRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),envRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if defaultAr:\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'ranlib')\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'true')\n      raise RuntimeError('You set a value for --with-ar='+defaultAr+'\", but '+defaultAr+' cannot be used\\n')\n    if envAr:\n      yield (envAr,self.getArchiverFlags(envAr),'ranlib')\n      yield (envAr,self.getArchiverFlags(envAr),'true')\n      raise RuntimeError('You set a value for -AR=\"'+envAr+'\" (perhaps in your environment), but '+envAr+' cannot be used\\n')\n    if defaultRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),defaultRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),defaultRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),defaultRanlib)\n      raise RuntimeError('You set --with-ranlib=\"'+defaultRanlib+'\", but '+defaultRanlib+' cannot be used\\n')\n    if envRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),envRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),envRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),envRanlib)\n      raise RuntimeError('You set -RANLIB=\"'+envRanlib+'\" (perhaps in your environment), but '+defaultRanlib+' cannot be used\\n')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar',self.getArchiverFlags('ar'),'true')\n    # IBM with 64 bit pointers\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'true')\n    yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),'true')\n    yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),'true')\n    return\n\n  def checkArchiver(self):\n    '''Check that the archiver exists and can make a library usable by the compiler'''\n    objName    = os.path.join(self.tmpDir, 'conf1.o')\n    arcUnix    = os.path.join(self.tmpDir, 'libconf1.a')\n    arcWindows = os.path.join(self.tmpDir, 'libconf1.lib')\n    def checkArchive(command, status, output, error):\n      if error or status:\n        self.logError('archiver', status, output, error)\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('Archiver is not functional')\n      return\n    def checkRanlib(command, status, output, error):\n      if error or status:\n        self.logError('ranlib', status, output, error)\n        if os.path.isfile(arcUnix):\n          os.remove(arcUnix)\n        raise RuntimeError('Ranlib is not functional with your archiver.  Try --with-ranlib=true if ranlib is unnecessary.')\n      return\n    oldLibs = self.LIBS\n    self.pushLanguage('C')\n    for (archiver, arflags, ranlib) in self.generateArchiverGuesses():\n      if not self.checkCompile('', 'int foo(int a) {\\n  return a+1;\\n}\\n\\n', cleanup = 0, codeBegin = '', codeEnd = ''):\n        raise RuntimeError('Compiler is not functional')\n      if os.path.isfile(objName):\n        os.remove(objName)\n      os.rename(self.compilerObj, objName)\n      if self.getExecutable(archiver, getFullPath = 1, resultName = 'AR'):\n        if self.getExecutable(ranlib, getFullPath = 1, resultName = 'RANLIB'):\n          arext = 'a'\n          try:\n            (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+arflags+' '+arcUnix+' '+objName, checkCommand = checkArchive, log = self.log)\n            (output, error, status) = config.base.Configure.executeShellCommand(self.RANLIB+' '+arcUnix, checkCommand = checkRanlib, log = self.log)\n          except RuntimeError as e:\n            self.logPrint(str(e))\n            continue\n          self.LIBS = '-L'+self.tmpDir+' -lconf1 ' + oldLibs\n          success =  self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n          os.rename(arcUnix, arcWindows)\n          if not success:\n            arext = 'lib'\n            success = self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n            os.remove(arcWindows)\n            if success:\n              break\n          else:\n            os.remove(arcWindows)\n            break\n    else:\n      if os.path.isfile(objName):\n        os.remove(objName)\n      self.LIBS = oldLibs\n      self.popLanguage()\n      raise RuntimeError('Could not find a suitable archiver.  Use --with-ar to specify an archiver.')\n    self.AR_FLAGS      = arflags\n    self.AR_LIB_SUFFIX = arext\n    self.framework.addMakeMacro('AR_FLAGS', self.AR_FLAGS)\n    self.addMakeMacro('AR_LIB_SUFFIX', self.AR_LIB_SUFFIX)\n    os.remove(objName)\n    self.LIBS = oldLibs\n    self.popLanguage()\n    return\n\n  def setStaticLinker(self):\n    language = self.language[-1]\n    return self.framework.setSharedLinkerObject(language, self.framework.getLanguageModule(language).StaticLinker(self.argDB))\n\n  def generateSharedLinkerGuesses(self):\n    if not self.argDB['with-shared-libraries']:\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n      raise RuntimeError('Archiver failed static link check')\n    if 'with-shared-ld' in self.argDB:\n      yield (self.argDB['with-shared-ld'], [], 'so')\n    if 'LD_SHARED' in self.argDB:\n      yield (self.argDB['LD_SHARED'], [], 'so')\n    if Configure.isDarwin(self.log):\n      if 'with-shared-ld' in self.argDB:\n        yield (self.argDB['with-shared-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      # C++ compiler default\n      yield (self.CXX, ['-shared'], 'so')\n      yield (self.CXX, ['-dynamic'], 'so')\n    # C compiler default\n    yield (self.CC, ['-shared'], 'so')\n    yield (self.CC, ['-dynamic'], 'so')\n    yield (self.CC, ['-qmkshrobj'], 'so')\n    yield (self.CC, ['-shared'], 'dll')\n    # Windows default\n    if self.CC.find('win32fe') >=0:\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-LD'], 'dll')\n      yield (self.CC, ['-LD'], 'dll')\n    # Solaris default\n    if Configure.isSolaris(self.log):\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-G'], 'so')\n      yield (self.CC, ['-G'], 'so')\n    # If user does not explicitly enable shared-libraries - disable shared libraries and default to static linker\n    if not 'with-shared-libraries' in self.framework.clArgDB:\n      self.argDB['with-shared-libraries'] = 0\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n    raise RuntimeError('Exhausted all shared linker guesses. Could not determine how to create a shared library!')\n\n  def checkSharedLinker(self):\n    '''Check that the linker can produce shared libraries'''\n    self.sharedLibraries = 0\n    self.staticLibraries = 0\n    for linker, flags, ext in self.generateSharedLinkerGuesses():\n      self.logPrint('Checking shared linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'LD_SHARED'):\n        for picFlag in self.generatePICGuesses():\n          self.logPrint('Trying '+self.language[-1]+' compiler flag '+picFlag)\n          compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n          oldCompilerFlags = getattr(self, compilerFlagsArg)\n          accepted = 1\n          try:\n            self.addCompilerFlag(picFlag,compilerOnly=1)\n          except RuntimeError:\n            accepted = 0\n          if accepted:\n            goodFlags = list(filter(self.checkLinkerFlag, flags))\n            self.sharedLinker = self.LD_SHARED\n            self.sharedLibraryFlags = goodFlags\n            self.sharedLibraryExt = ext\n            if ext == 'dll':\n              dllexport = '__declspec(dllexport) '\n              dllimport = '__declspec(dllimport) '\n            else:\n              dllexport = ''\n              dllimport = ''\n            # using printf appears to correctly identify non-pic code on X86_64\n            if self.checkLink(includes = _picTestIncludes(dllexport), codeBegin = '', codeEnd = '', cleanup = 0, shared = 1):\n              oldLib  = self.linkerObj\n              oldLibs = self.LIBS\n              self.LIBS += ' -L'+self.tmpDir+' -lconftest'\n              accepted = self.checkLink(includes = dllimport+'int foo(void);', body = 'int ret = foo();\\nif (ret) {}\\n')\n              os.remove(oldLib)\n              self.LIBS = oldLibs\n              if accepted:\n                self.sharedLibraries = 1\n                self.logPrint('Using shared linker '+self.sharedLinker+' with flags '+str(self.sharedLibraryFlags)+' and library extension '+self.sharedLibraryExt)\n                break\n          self.logPrint('Rejected '+self.language[-1]+' compiler flag '+picFlag+' because it was not compatible with shared linker '+linker+' using flags '+str(flags))\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        if self.sharedLibraries: break\n        self.delMakeMacro('LD_SHARED')\n        del self.LD_SHARED\n        del self.sharedLinker\n    return\n\n  def checkLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag'''\n    flagsArg = self.getLinkerFlagsArg()\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, status) = self.outputLink('', '')\n    valid = 1\n    if status:\n      valid = 0\n      self.logPrint('Rejecting linker flag '+flag+' due to nonzero status from link')\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting '+self.language[-1]+' linker flag '+flag+' due to \\n'+output)\n    if valid:\n      self.logPrint('Valid '+self.language[-1]+' linker flag '+flag)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def addLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkLinkerFlag(flag):\n      flagsArg = self.getLinkerFlagsArg()\n      setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n      return\n    raise RuntimeError('Bad linker flag: '+flag)\n\n  def checkLinkerMac(self):\n    '''Tests some Apple Mac specific linker flags'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Wl,-multiply_defined,suppress', '-Wl,-multiply_defined -Wl,suppress', '-Wl,-commons,use_dylibs', '-Wl,-search_paths_first', '-Wl,-no_compact_unwind']:\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n          linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n          val.append(testFlag)\n          setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkLinkerWindows(self):\n    '''Turns off linker warning about unknown .o files extension'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Qwd10161']:  #Warning for Intel icl,  there appear to be no way to remove warnings with Microsoft cl\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n          linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n          val.append(testFlag)\n          setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkSharedLinkerPaths(self):\n    '''Determine the shared linker path options\n       - IRIX: -rpath\n       - Linux, OSF: -Wl,-rpath,\n       - Solaris: -R\n       - FreeBSD: -Wl,-R,'''\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      flag = '-L'\n      self.pushLanguage(language)\n      # test '-R' before '-rpath' as sun compilers [c,fortran] don't give proper errors with wrong options.\n      if not Configure.isDarwin(self.log):\n        testFlags = ['-Wl,-rpath,', '-R','-rpath ' , '-Wl,-R,']\n      else:\n        testFlags = ['-Wl,-rpath,']\n      # test '-R' before '-Wl,-rpath' for SUN compilers [as cc on linux accepts -Wl,-rpath, but  f90 & CC do not.\n      if self.isSun(self.framework.getCompiler(), self.log):\n        testFlags.insert(0,'-R')\n      for testFlag in testFlags:\n        self.logPrint('Trying '+language+' linker flag '+testFlag)\n        if self.checkLinkerFlag(testFlag+os.path.abspath(os.getcwd())):\n          flag = testFlag\n          break\n        else:\n          self.logPrint('Rejected '+language+' linker flag '+testFlag)\n      self.popLanguage()\n      setattr(self, language+'SharedLinkerFlag', flag)\n    return\n\n  def checkLibC(self):\n    '''Test whether we need to explicitly include libc in shared linking\n       - Mac OSX requires an explicit reference to libc for shared linking'''\n    self.explicitLibc = None\n    if self.staticLibraries:\n      return\n    tmpCompilerDefines   = self.compilerDefines\n    self.compilerDefines = ''\n    code = '#include <stdlib.h> \\nint foo(void) {void *chunk = malloc(31); free(chunk); return 0;}\\n'\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking does not require an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      return\n    oldLibs = self.LIBS\n    self.LIBS += '-lc '\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking requires an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      self.explicitLibc = ['libc.so']\n      return\n    self.LIBS = oldLibs\n    self.compilerDefines = tmpCompilerDefines\n    self.logPrint('*** WARNING *** Shared linking may not function on this architecture')\n    self.staticLibrary=1\n    self.sharedLibrary=0\n\n  def generateDynamicLinkerGuesses(self):\n    if 'with-dynamic-ld' in self.argDB:\n      yield (self.argDB['with-dynamic-ld'], [], 'so')\n    # Mac OSX\n    if Configure.isDarwin(self.log):\n      if 'with-dynamic-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n    # Shared default\n    if hasattr(self, 'sharedLinker'):\n      yield (self.sharedLinker, self.sharedLibraryFlags, 'so')\n    # C++ Compiler default\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      yield (self.CXX, ['-shared'], 'so')\n    # C Compiler default\n    yield (self.CC, ['-shared'], 'so')\n    self.logPrint('Unable to find working dynamic linker')\n\n  def checkDynamicLinker(self):\n    '''Check that the linker can dynamicaly load shared libraries'''\n    self.dynamicLibraries = 0\n    if not self.headers.check('dlfcn.h'):\n      self.logPrint('Dynamic loading disabled since dlfcn.h was missing')\n      return\n    self.libraries.saveLog()\n    if not self.libraries.add('dl', ['dlopen', 'dlsym', 'dlclose']):\n      if not self.libraries.check('', ['dlopen', 'dlsym', 'dlclose']):\n        self.logWrite(self.libraries.restoreLog())\n        self.logPrint('Dynamic linking disabled since functions dlopen(), dlsym(), and dlclose() were not found')\n        return\n    self.logWrite(self.libraries.restoreLog())\n    for linker, flags, ext in self.generateDynamicLinkerGuesses():\n      self.logPrint('Checking dynamic linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'dynamicLinker'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = list(filter(self.checkLinkerFlag, flags))\n        self.dynamicLibraryFlags = goodFlags\n        self.dynamicLibraryExt = ext\n        testMethod = 'foo'\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"test\");return 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 'dynamic'):\n          oldLib  = self.linkerObj\n          code = '''\nvoid *handle = dlopen(\"%s\", 0);\nint (*foo)(void) = (int (*)(void)) dlsym(handle, \"foo\");\n\nif (!foo) {\n  printf(\"Could not load symbol\\\\n\");\n  return -1;\n}\nif ((*foo)()) {\n  printf(\"Invalid return from foo()\\\\n\");\n  return -1;\n}\nif (dlclose(handle)) {\n  printf(\"Could not close library\\\\n\");\n  return -1;\n}\n''' % oldLib\n          if self.checkLink(includes = '#include <dlfcn.h>\\n#include <stdio.h>', body = code):\n            self.dynamicLibraries = 1\n            self.logPrint('Using dynamic linker '+self.dynamicLinker+' with flags '+str(self.dynamicLibraryFlags)+' and library extension '+self.dynamicLibraryExt)\n            os.remove(oldLib)\n            break\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        del self.dynamicLinker\n    return\n\n  def output(self):\n    '''Output module data as defines and substitutions'''\n    if hasattr(self, 'CC'):\n      self.addSubstitution('CC', self.CC)\n      self.addSubstitution('CFLAGS', self.CFLAGS)\n      self.addMakeMacro('CC_LINKER_SLFLAG', self.CSharedLinkerFlag)\n    if hasattr(self, 'CPP'):\n      self.addSubstitution('CPP', self.CPP)\n      self.addSubstitution('CPPFLAGS', self.CPPFLAGS)\n    if hasattr(self, 'CUDAC'):\n      self.addSubstitution('CUDAC', self.CUDAC)\n      self.addSubstitution('CUDAFLAGS', self.CUDAFLAGS)\n    if hasattr(self, 'CUDAPP'):\n      self.addSubstitution('CUDAPP', self.CUDAPP)\n      self.addSubstitution('CUDAPPFLAGS', self.CUDAPPFLAGS)\n    if hasattr(self, 'CXX'):\n      self.addSubstitution('CXX', self.CXX)\n      self.addSubstitution('CXX_CXXFLAGS', self.CXX_CXXFLAGS)\n      self.addSubstitution('CXXFLAGS', self.CXXFLAGS)\n      self.addSubstitution('CXX_LINKER_SLFLAG', self.CxxSharedLinkerFlag)\n    else:\n      self.addSubstitution('CXX', '')\n    if hasattr(self, 'CXXPP'):\n      self.addSubstitution('CXXPP', self.CXXPP)\n      self.addSubstitution('CXXPPFLAGS', self.CXXPPFLAGS)\n    if hasattr(self, 'FC'):\n      self.addSubstitution('FC', self.FC)\n      self.addSubstitution('FFLAGS', self.FFLAGS)\n      self.addMakeMacro('FC_LINKER_SLFLAG', self.FCSharedLinkerFlag)\n    else:\n      self.addSubstitution('FC', '')\n    self.addSubstitution('LDFLAGS', self.LDFLAGS)\n    if hasattr(self, 'FPP'):\n      self.addSubstitution('FPP', self.FPP)\n      self.addSubstitution('FPPFLAGS', self.FPPFLAGS)\n    self.addSubstitution('LIBS', self.LIBS)\n    if hasattr(self, 'sharedLibraryFlags'):\n      self.addSubstitution('SHARED_LIBRARY_FLAG', ' '.join(self.sharedLibraryFlags))\n    else:\n      self.addSubstitution('SHARED_LIBRARY_FLAG','')\n    return\n\n  def updateMPICompilers(self, mpicc, mpicxx, mpifc):\n    '''Reset compilers by an external module aka MPI'''\n    self.CC = mpicc\n    self.delMakeMacro(\"CC\")\n\n    if hasattr(self, 'CXX'):\n      self.CXX = mpicxx\n      self.delMakeMacro(\"CXX\")\n\n    if hasattr(self, 'FC'):\n      self.FC = mpifc\n      self.delMakeMacro(\"FC\")\n\n    self.configure()\n    self.usedMPICompilers=1\n    return\n\n  def checkMPICompilerOverride(self):\n    '''Check if --with-mpi-dir is used along with CC CXX or FC compiler options.\n    This usually prevents mpi compilers from being used - so issue a warning'''\n\n    if 'with-mpi-dir' in self.argDB and self.argDB['with-mpi-compilers']:\n      optcplrs = [(['with-cc','CC'],['mpiicc','mpicc','mpcc','hcc','mpcc_r']),\n              (['with-fc','FC'],['mpiifort','mpif90','mpxlf95_r','mpxlf90_r','mpxlf_r','mpf90']),\n              (['with-cxx','CXX'],['mpiicpc','mpicxx','hcp','mpic++','mpiCC','mpCC_r'])]\n      for opts,cplrs in optcplrs:\n        for opt in opts:\n          if (opt in self.argDB  and self.argDB[opt] != '0'):\n            # check if corresponding mpi wrapper exists\n            for cplr in cplrs:\n              for mpicplr in [os.path.join(self.argDB['with-mpi-dir'], 'bin', cplr),os.path.join(self.argDB['with-mpi-dir'], 'intel64', 'bin', cplr)]:\n                if os.path.exists(mpicplr):\n                  msg = '--'+opt+'='+self.argDB[opt]+' is specified along with --with-mpi-dir='+self.argDB['with-mpi-dir']+' which implies using '+mpicplr+'.\\n\\\n  configure is confused and does not know which compiler to select and use! Please specify either [mpi] compilers or --with-mpi-dir - but not both!\\n\\\n  In most cases, specifying --with-mpi-dir - and not explicitly listing compilers could be preferable.'\n                  raise RuntimeError(msg)\n    return\n\n  def requireMpiLdPath(self):\n    '''OpenMPI wrappers require LD_LIBRARY_PATH set'''\n    if 'with-mpi-dir' in self.argDB:\n      libdir = os.path.join(self.argDB['with-mpi-dir'], 'lib')\n      if os.path.exists(os.path.join(libdir,'libopen-rte.so')):\n        Configure.addLdPath(libdir)\n        self.logPrint('Adding to LD_LIBRARY_PATH '+libdir)\n    return\n\n  def printEnvVariables(self):\n    buf = '**** printenv ****'\n    for key,val in os.environ.items():\n      buf += '\\n'+str(key)+'='+str(val)\n    self.logPrint(buf)\n    return\n\n  def resetEnvCompilers(self):\n    ignoreEnvCompilers = ['CC','CXX','FC','F77','F90']\n    for envVal in ignoreEnvCompilers:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB or 'with-'+envVal.lower() in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables ******')\n        elif self.framework.argDB['with-xsdk-defaults'] and 'with-environment-variables' not in self.framework.clArgDB:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n because --with-xsdk-defaults was selected. Add --disable-environment-variables \\n to NOT use the environmental variables ******')\n\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n\n    ignoreEnv = ['CFLAGS','CXXFLAGS','FCFLAGS','FFLAGS','F90FLAGS','CPP','CPPFLAGS','CXXPP','CXXPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n    for envVal in ignoreEnv:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables******')\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n    return\n\n\n  def checkEnvCompilers(self):\n    if 'with-environment-variables' in self.framework.clArgDB or 'with-xsdk-defaults' in self.framework.clArgDB:\n      envVarChecklist = ['CC','CFLAGS','CXX','CXXFLAGS','FC','FCFLAGS','F77','FFLAGS','F90','F90FLAGS','CPP','CPPFLAGS','CXXPP','CXXPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n      for ev in envVarChecklist:\n        if ev in os.environ:\n          self.argDB[ev] = os.environ[ev]\n\n    # abort if FCFLAGS and FFLAGS both set, but to different values\n    if 'FFLAGS' in self.argDB and 'FCFLAGS' in self.argDB:\n      if self.argDB['FCFLAGS'] != self.argDB['FFLAGS']:\n        raise RuntimeError('FCFLAGS and FFLAGS are both set, but with different values (FCFLAGS=%s, FFLAGS=%s)'%(self.argDB['FCFLAGS'],self.argDB['FFLAGS']))\n    return\n\n  def checkIntoShared(self,symbol,lib):\n    '''Check that a given library can be linked into a shared library'''\n    import sys\n    if not self.checkCompile(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}'):\n      raise RuntimeError('Unable to compile test file with symbol: '+symbol)\n    oldLibs = self.LIBS\n    self.LIBS = self.libraries.toStringNoDupes(lib) + ' '+self.LIBS\n    ret = self.checkLink(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}',shared =1)\n    self.LIBS = oldLibs\n    return ret\n\n  def configure(self):\n    self.mainLanguage = self.languages.clanguage\n    self.executeTest(self.printEnvVariables)\n    self.executeTest(self.resetEnvCompilers)\n    self.executeTest(self.checkEnvCompilers)\n    self.executeTest(self.checkMPICompilerOverride)\n    self.executeTest(self.requireMpiLdPath)\n    self.executeTest(self.checkInitialFlags)\n    self.executeTest(self.checkCCompiler)\n    self.executeTest(self.checkCPreprocessor)\n    self.executeTest(self.checkCUDACompiler)\n    self.executeTest(self.checkCUDAPreprocessor)\n    self.executeTest(self.checkCxxCompiler)\n    if hasattr(self, 'CXX'):\n      self.executeTest(self.checkCxxPreprocessor)\n    self.executeTest(self.checkFortranCompiler)\n    if hasattr(self, 'FC'):\n      self.executeTest(self.checkFortranPreprocessor)\n      self.executeTest(self.checkFortranComments)\n    self.executeTest(self.checkLargeFileIO)\n    self.executeTest(self.checkArchiver)\n    self.executeTest(self.checkSharedLinker)\n    if Configure.isDarwin(self.log):\n      self.executeTest(self.checkLinkerMac)\n    if Configure.isCygwin(self.log):\n      self.executeTest(self.checkLinkerWindows)\n    self.executeTest(self.checkPIC)\n    self.executeTest(self.checkSharedLinkerPaths)\n    self.executeTest(self.checkLibC)\n    self.executeTest(self.checkDynamicLinker)\n    self.executeTest(self.output)\n    return\n\n  def no_configure(self):\n    if self.staticLibraries:\n      self.setStaticLinker()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/config/BuildSystem/config/packages/MPI.py": "#!/usr/bin/env python\nfrom __future__ import generators\nimport config.base\nimport config.package\nimport os\nfrom stat import *\n\ndef noCheck(command, status, output, error):\n  ''' Do no check result'''\n  return\n\nclass Configure(config.package.Package):\n  def __init__(self, framework):\n    config.package.Package.__init__(self, framework)\n    self.minversion         = '2'\n    self.versionname        = 'MPI_VERSION'\n    self.functions          = ['MPI_Init', 'MPI_Comm_create']\n    self.includes           = ['mpi.h']\n    liblist_mpich         = [['fmpich2.lib','fmpich2g.lib','fmpich2s.lib','mpi.lib'],\n                             ['fmpich2.lib','fmpich2g.lib','mpi.lib'],['fmpich2.lib','mpich2.lib'],\n                             ['libfmpich2g.a','libmpi.a'],['libfmpich.a','libmpich.a', 'libpmpich.a'],\n                             ['libmpich.a', 'libpmpich.a'],\n                             ['libfmpich.a','libmpich.a', 'libpmpich.a', 'libmpich.a', 'libpmpich.a', 'libpmpich.a'],\n                             ['libmpich.a', 'libpmpich.a', 'libmpich.a', 'libpmpich.a', 'libpmpich.a'],\n                             ['libmpich.a','librt.a','libaio.a','libsnl.a','libpthread.a'],\n                             ['libmpich.a','libssl.a','libuuid.a','libpthread.a','librt.a','libdl.a'],\n                             ['libmpich.a','libnsl.a','libsocket.a','librt.a','libnsl.a','libsocket.a'],\n                             ['libmpich.a','libgm.a','libpthread.a']]\n    liblist_lam           = [['liblamf77mpi.a','libmpi++.a','libmpi.a','liblam.a'],\n                             ['liblammpi++.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','liblamf77mpi.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','liblamf90mpi.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','libmpi.a','liblam.a'],\n                             ['liblammpi++.a','libmpi.a','liblam.a'],\n                             ['libmpi.a','liblam.a']]\n    liblist_msmpi         = [[os.path.join('amd64','msmpifec.lib'),os.path.join('amd64','msmpi.lib')],\n                             [os.path.join('i386','msmpifec.lib'),os.path.join('i386','msmpi.lib')]]\n    liblist_other         = [['libmpich.a','libpthread.a'],['libmpi++.a','libmpi.a']]\n    liblist_single        = [['libmpi.a'],['libmpich.a'],['mpi.lib'],['mpich2.lib'],['mpich.lib'],\n                             [os.path.join('amd64','msmpi.lib')],[os.path.join('i386','msmpi.lib')]]\n    self.liblist          = liblist_mpich + liblist_lam + liblist_msmpi + liblist_other + liblist_single\n    # defaults to --with-mpi=yes\n    self.required         = 1\n    self.complex          = 1\n    self.isPOE            = 0\n    self.usingMPIUni      = 0\n    self.shared           = 0\n    # local state\n    self.commf2c          = 0\n    self.commc2f          = 0\n    self.needBatchMPI     = 1\n    self.alternativedownload = 'mpich'\n    # support MPI-3 process shared memory\n    self.support_mpi3_shm = 0\n    # support MPI-3 non-blocking collectives\n    self.support_mpi3_nbc = 0\n    self.mpi_pkg_version  = ''\n    return\n\n  def setupHelp(self, help):\n    config.package.Package.setupHelp(self,help)\n    import nargs\n    help.addArgument('MPI', '-with-mpiexec=<prog>',                              nargs.Arg(None, None, 'The utility used to launch MPI jobs. (should support \"-n <np>\" option)'))\n    help.addArgument('MPI', '-with-mpi-compilers=<bool>',                        nargs.ArgBool(None, 1, 'Try to use the MPI compilers, e.g. mpicc'))\n    help.addArgument('MPI', '-known-mpi-shared-libraries=<bool>',                nargs.ArgBool(None, None, 'Indicates the MPI libraries are shared (the usual test will be skipped)'))\n    return\n\n  def setupDependencies(self, framework):\n    config.package.Package.setupDependencies(self, framework)\n    self.mpich   = framework.require('config.packages.MPICH', self)\n    self.openmpi = framework.require('config.packages.OpenMPI', self)\n    return\n\n  def __str__(self):\n    output  = config.package.Package.__str__(self)\n    if output and self.mpiexec: output  += '  Mpiexec: '+self.mpiexec.replace(' -n 1','')+'\\n'\n    return output+self.mpi_pkg_version\n\n  def generateLibList(self, directory):\n    if self.setCompilers.usedMPICompilers:\n      self.liblist = []\n      self.libdir  = []\n    return config.package.Package.generateLibList(self,directory)\n\n  # search many obscure locations for MPI\n  def getSearchDirectories(self):\n    import re\n    if self.mpich.found:\n      yield (self.mpich.installDir)\n      raise RuntimeError('--download-mpich libraries cannot be used')\n    if self.openmpi.found:\n      yield (self.openmpi.installDir)\n      raise RuntimeError('--download-openmpi libraries cannot be used')\n\n    yield ''\n    # Try configure package directories\n    dirExp = re.compile(r'mpi(ch)?(-.*)?')\n    for packageDir in self.argDB['with-packages-search-path']:\n      packageDir = os.path.abspath(packageDir)\n      if not os.path.isdir(packageDir):\n        raise RuntimeError('Invalid package directory: '+packageDir)\n      for f in os.listdir(packageDir):\n        dir = os.path.join(packageDir, f)\n        if not os.path.isdir(dir):\n          continue\n        if not dirExp.match(f):\n          continue\n        yield (dir)\n    # Try SUSE location\n    yield (os.path.abspath(os.path.join('/opt', 'mpich')))\n    # Try IBM\n    self.isPOE = 1\n    dir = os.path.abspath(os.path.join('/usr', 'lpp', 'ppe.poe'))\n    yield (os.path.abspath(os.path.join('/usr', 'lpp', 'ppe.poe')))\n    self.isPOE = 0\n    # Try /usr/local\n    yield (os.path.abspath(os.path.join('/usr', 'local')))\n    # Try /usr/local/*mpich*\n    if os.path.isdir(dir):\n      ls = os.listdir(dir)\n      for dir in ls:\n        if dir.find('mpich') >= 0:\n          dir = os.path.join('/usr','local',dir)\n          if os.path.isdir(dir):\n            yield (dir)\n    # Try ~/mpich*\n    homedir = os.getenv('HOME')\n    if homedir:\n      ls = os.listdir(homedir)\n      for dir in ls:\n        if dir.find('mpich') >= 0:\n          dir = os.path.join(homedir,dir)\n          if os.path.isdir(dir):\n            yield (dir)\n    # Try MSMPI/MPICH install locations under Windows\n    # ex: /cygdrive/c/Program Files/Microsoft HPC Pack 2008 SDK\n    for root in ['/',os.path.join('/','cygdrive')]:\n      for drive in ['c']:\n        for programFiles in ['Program Files','Program Files (x86)']:\n          for packageDir in ['Microsoft HPC Pack 2008 SDK','Microsoft Compute Cluster Pack','MPICH2','MPICH',os.path.join('MPICH','SDK.gcc'),os.path.join('MPICH','SDK')]:\n            yield(os.path.join(root,drive,programFiles,packageDir))\n    return\n\n  def checkSharedLibrary_ThisIsBroken(self):\n  # TODO: Fix this routine, currently\n  #       * the visibility flag is passed to the compiling/linking so the symbols are not visable to the loader and the test fails (this is easily fixed)\n  #       * even with that fixed the dlsym() is unable to locate the checkInit symbol in the library even though nm shows it is there; I am not sure the cause\n    '''Sets flag indicating if MPI libraries are shared or not and\n    determines if MPI libraries CANNOT be used by shared libraries'''\n    if self.argDB['with-batch']:\n      if self.argDB['with-shared-libraries']:\n        if not 'known-mpi-shared-libraries' in self.argDB:\n          self.logPrintBox('***** WARNING: Cannot verify that MPI is a shared library - in\\n\\\nbatch-mode! If MPI is a static library but linked into multiple shared\\n\\\nlibraries that the application uses, sometimes compiles work -\\n\\\nbut one might get run-time errors. If you know that the MPI library is\\n\\\nshared - run with --known-mpi-shared-libraries=1 option to remove this\\n\\\nwarning message *****')\n        elif not self.argDB['known-mpi-shared-libraries']:\n          raise RuntimeError('Provided MPI library is flagged as static library! If its linked\\n\\\ninto multipe shared libraries that an application uses, sometimes\\n\\\ncompiles go through - but one might get run-time errors.  Either\\n\\\nreconfigure PETSc with --with-shared-libraries=0 or provide MPI with\\n\\\nshared libraries and run with --known-mpi-shared-libraries=1')\n      return\n    self.shared = self.libraries.checkShared('#include <mpi.h>\\n','MPI_Init','MPI_Initialized','MPI_Finalize',checkLink = self.checkPackageLink,libraries = self.lib, defaultArg = 'known-mpi-shared-libraries', executor = self.mpiexec)\n\n    # TODO: Turn this on once shared library checks are working again\n    #if self.argDB['with-shared-libraries'] and not self.shared:\n    #  self.logPrint('MPI libraries cannot be used with shared libraries')\n    #  raise RuntimeError('Shared libraries cannot be built using MPI provided.\\nEither reconfigure with --with-shared-libraries=0 or rebuild MPI with shared library support')\n    return\n\n  def configureMPIEXEC(self):\n    '''Checking for location of mpiexec'''\n    if self.argDB['with-batch']:\n      if 'with-mpiexec' in self.argDB:\n        self.logPrintBox('--with-mpiexec is ignored since --with-batch is provided; one cannot run generated executables on the compile server')\n      self.mpiexec = 'Not_appropriate_for_batch_systems_You_must_use_your_batch_system_to_submit_MPI_jobs_speak_with_your_local_sys_admin'\n      self.addMakeMacro('MPIEXEC', self.mpiexec)\n      return\n    self.mpiexec = None\n    if 'with-mpiexec' in self.argDB:\n      self.argDB['with-mpiexec'] = os.path.expanduser(self.argDB['with-mpiexec'])\n      if not self.getExecutable(self.argDB['with-mpiexec'], resultName = 'mpiexec'):\n        raise RuntimeError('Invalid mpiexec specified: '+str(self.argDB['with-mpiexec']))\n      self.mpiexec = self.argDB['with-mpiexec']\n    elif self.isPOE:\n      self.mpiexec = os.path.abspath(os.path.join('bin', 'mpiexec.poe'))\n    else:\n      mpiexecs = ['mpiexec', 'mpirun', 'mprun']\n      path    = []\n      if 'with-mpi-dir' in self.argDB:\n        path.append(os.path.join(os.path.abspath(self.argDB['with-mpi-dir']), 'bin'))\n        # MPICH-NT-1.2.5 installs MPIRun.exe in mpich/mpd/bin\n        path.append(os.path.join(os.path.abspath(self.argDB['with-mpi-dir']), 'mpd','bin'))\n      for inc in self.include:\n        path.append(os.path.join(os.path.dirname(inc), 'bin'))\n        # MPICH-NT-1.2.5 installs MPIRun.exe in mpich/SDK/include/../../mpd/bin\n        path.append(os.path.join(os.path.dirname(os.path.dirname(inc)),'mpd','bin'))\n      for lib in self.lib:\n        path.append(os.path.join(os.path.dirname(os.path.dirname(lib)), 'bin'))\n      self.pushLanguage('C')\n      if os.path.basename(self.getCompiler()) == 'mpicc' and os.path.dirname(self.getCompiler()):\n        path.append(os.path.dirname(self.getCompiler()))\n      self.popLanguage()\n      if not self.getExecutable(mpiexecs, path = path, useDefaultPath = 1, resultName = 'mpiexec',setMakeMacro=0):\n        if not self.getExecutable('/bin/false', path = [], useDefaultPath = 0, resultName = 'mpiexec',setMakeMacro=0):\n          raise RuntimeError('Could not locate MPIEXEC - please specify --with-mpiexec option')\n      # Support for spaces and () in executable names; also needs to handle optional arguments at the end\n      # TODO: This support for spaces and () should be moved to core BuildSystem\n      self.mpiexec = self.mpiexec.replace(' ', '\\\\ ').replace('(', '\\\\(').replace(')', '\\\\)').replace('\\ -',' -')\n      if (hasattr(self, 'ompi_major_version') and int(self.ompi_major_version) >= 3):\n        (out, err, ret) = Configure.executeShellCommand(self.mpiexec+' -help all', checkCommand = noCheck, timeout = 10, log = self.log)\n        if out.find('--oversubscribe') >=0:\n          self.mpiexec = self.mpiexec + ' --oversubscribe'\n\n    # using mpiexec environmental variables make sure mpiexec matches the MPI libraries and save the variables for testing in PetscInitialize()\n    # the variable HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE is not currently used. PetscInitialize() can check the existence of the environmental variable to\n    # determine if the program has been started with the correct mpiexec (will only be set for parallel runs so not clear how to check appropriately)\n    (out, err, ret) = Configure.executeShellCommand(self.mpiexec+' -n 1 printenv', checkCommand = noCheck, timeout = 10, log = self.log)\n    if ret:\n      self.logWrite('Unable to run '+self.mpiexec+' with option \"-n 1 printenv\"\\nThis could be ok, some MPI implementations such as SGI produce a non-zero status with non-MPI programs\\n'+out+err)\n    else:\n      if out.find('MPIR_CVAR_CH3') > -1:\n        if hasattr(self,'ompi_major_version'): raise RuntimeError(\"Your libraries are from OpenMPI but it appears your mpiexec is from MPICH\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'MPIR_CVAR_CH3')\n      elif  out.find('MPIR_CVAR_CH3') > -1:\n        if hasattr(self,'ompi_major_version'): raise RuntimeError(\"Your libraries are from OpenMPI but it appears your mpiexec is from MPICH\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'MPICH')\n      elif out.find('OMPI_COMM_WORLD_SIZE') > -1:\n        if hasattr(self,'mpich_numversion'): raise RuntimeError(\"Your libraries are from MPICH but it appears your mpiexec is from OpenMPI\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'OMP')\n\n    self.addMakeMacro('MPIEXEC', self.mpiexec)\n    self.mpiexec = self.mpiexec + ' -n 1'\n\n    # check that mpiexec runs an MPI program correctly\n    includes = '#include <mpi.h>'\n    body = 'MPI_Init(0,0);\\nMPI_Finalize();\\n'\n    try:\n      ok = self.checkRun(includes, body, executor = self.mpiexec, timeout = 20)\n      if not ok: raise RuntimeError('Unable to run MPI program with '+self.mpiexec+' make sure this is the correct program to run MPI jobs')\n    except RuntimeError as e:\n      if str(e).find('Runaway process exceeded time limit') > -1:\n        raise RuntimeError('Timeout: Unable to run MPI program with '+self.mpiexec+'\\n\\\n    (1) make sure this is the correct program to run MPI jobs\\n\\\n    (2) your network may be misconfigured; see https://www.mcs.anl.gov/petsc/documentation/faq.html#PetscOptionsInsertFile\\n')\n\n\n\n  def configureMPI2(self):\n    '''Check for functions added to the interface in MPI-2'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    self.framework.saveLog()\n    if self.checkLink('#include <mpi.h>\\n', 'int flag;if (MPI_Finalized(&flag));\\n'):\n      self.haveFinalized = 1\n      self.addDefine('HAVE_MPI_FINALIZED', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Allreduce(MPI_IN_PLACE,0, 1, MPI_INT, MPI_SUM, MPI_COMM_SELF));\\n'):\n      self.haveInPlace = 1\n      self.addDefine('HAVE_MPI_IN_PLACE', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'int count=2; int blocklens[2]={0,1}; MPI_Aint indices[2]={0,1}; MPI_Datatype old_types[2]={0,1}; MPI_Datatype *newtype = 0;\\n \\\n                                             if (MPI_Type_create_struct(count, blocklens, indices, old_types, newtype));\\n'):\n      self.haveTypeCreateStruct = 1\n    else:\n      self.haveTypeCreateStruct = 0\n      self.framework.addDefine('MPI_Type_create_struct(count,lens,displs,types,newtype)', 'MPI_Type_struct((count),(lens),(displs),(types),(newtype))')\n    if self.checkLink('#include <mpi.h>\\n', 'MPI_Comm_errhandler_fn * p_err_fun = 0; MPI_Errhandler * p_errhandler = 0; if (MPI_Comm_create_errhandler(p_err_fun,p_errhandler));\\n'):\n      self.haveCommCreateErrhandler = 1\n    else:\n      self.haveCommCreateErrhandler = 0\n      self.framework.addDefine('MPI_Comm_create_errhandler(p_err_fun,p_errhandler)', 'MPI_Errhandler_create((p_err_fun),(p_errhandler))')\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Comm_set_errhandler(MPI_COMM_WORLD,MPI_ERRORS_RETURN));\\n'):\n      self.haveCommSetErrhandler = 1\n    else:\n      self.haveCommSetErrhandler = 0\n      self.framework.addDefine('MPI_Comm_set_errhandler(comm,p_errhandler)', 'MPI_Errhandler_set((comm),(p_errhandler))')\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Reduce_local(0, 0, 0, MPI_INT, MPI_SUM));'):\n      self.haveReduceLocal = 1\n      self.addDefine('HAVE_MPI_REDUCE_LOCAL',1)\n    if self.checkLink('#include <mpi.h>\\n', 'char version[MPI_MAX_LIBRARY_VERSION_STRING];int verlen;if (MPI_Get_library_version(version,&verlen));\\n'):\n      self.addDefine('HAVE_MPI_GET_LIBRARY_VERSION', 1)\n    # Even MPI_Win_create is in MPI 2.0, we do this test to supress MPIUNI, which does not support MPI one-sided.\n    if self.checkLink('#include <mpi.h>\\n', 'int base[100]; MPI_Win win; if (MPI_Win_create(base,100,4,MPI_INFO_NULL,MPI_COMM_WORLD,&win));\\n'):\n      self.addDefine('HAVE_MPI_WIN_CREATE', 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    self.logWrite(self.framework.restoreLog())\n    return\n\n  def configureMPI3(self):\n    '''Check for functions added to the interface in MPI-3'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    self.framework.saveLog()\n    # Skip buggy MPICH versions\n    if (hasattr(self, 'mpich_numversion') and int(self.mpich_numversion) > 30004300) or not hasattr(self, 'mpich_numversion'):\n      if self.checkLink('#include <mpi.h>\\n',\n                      'MPI_Comm scomm; MPI_Aint size=128; int disp_unit=8,*baseptr; MPI_Win win;\\n\\\n                       if (MPI_Comm_split_type(MPI_COMM_WORLD, MPI_COMM_TYPE_SHARED, 0, MPI_INFO_NULL, &scomm));\\n\\\n                       if (MPI_Win_allocate_shared(size,disp_unit,MPI_INFO_NULL,MPI_COMM_WORLD,&baseptr,&win));\\n\\\n                       if (MPI_Win_shared_query(win,0,&size,&disp_unit,&baseptr));\\n'):\n        self.addDefine('HAVE_MPI_PROCESS_SHARED_MEMORY', 1)\n        self.support_mpi3_shm = 1\n    if self.checkLink('#include <mpi.h>\\n',\n                      'int send=0,recv,counts[2]={1,1},displs[2]={1,2}; MPI_Request req;\\n\\\n                       if (MPI_Iscatter(&send,1,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iscatterv(&send,counts,displs,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Igather(&send,1,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Igatherv(&send,1,MPI_INT,&recv,counts,displs,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iallgather(&send,1,MPI_INT,&recv,1,MPI_INT,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iallgatherv(&send,1,MPI_INT,&recv,counts,displs,MPI_INT,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Ialltoall(&send,1,MPI_INT,&recv,1,MPI_INT,MPI_COMM_WORLD,&req));\\n'):\n      self.addDefine('HAVE_MPI_NONBLOCKING_COLLECTIVES', 1)\n      self.support_mpi3_nbc = 1\n    if self.checkLink('#include <mpi.h>\\n',\n                      'MPI_Comm distcomm; \\n\\\n                       MPI_Request req; \\n\\\n                       if (MPI_Dist_graph_create_adjacent(MPI_COMM_WORLD,0,0,MPI_WEIGHTS_EMPTY,0,0,MPI_WEIGHTS_EMPTY,MPI_INFO_NULL,0,&distcomm));\\n\\\n                       if (MPI_Neighbor_alltoallv(0,0,0,MPI_INT,0,0,0,MPI_INT,distcomm));\\n\\\n                       if (MPI_Ineighbor_alltoallv(0,0,0,MPI_INT,0,0,0,MPI_INT,distcomm,&req));\\n'):\n      self.addDefine('HAVE_MPI_NEIGHBORHOOD_COLLECTIVES',1)\n    if hasattr(self, 'ompi_major_version'):\n      openmpi_cuda_test = '#include<mpi.h>\\n #include <mpi-ext.h>\\n #if defined(MPIX_CUDA_AWARE_SUPPORT) && MPIX_CUDA_AWARE_SUPPORT\\n #else\\n #error This OpenMPI is not CUDA-aware\\n #endif\\n'\n      if self.checkCompile(openmpi_cuda_test):\n        self.addDefine('HAVE_MPI_GPU_AWARE', 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    self.logWrite(self.framework.restoreLog())\n    return\n\n  def configureMPITypes(self):\n    '''Checking for MPI Datatype handles'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    mpitypes = [('MPI_LONG_DOUBLE', 'long-double'), ('MPI_INT64_T', 'int64_t')]\n    if self.getDefaultLanguage() == 'C': mpitypes.extend([('MPI_C_DOUBLE_COMPLEX', 'c-double-complex')])\n    for datatype, name in mpitypes:\n      includes = '#include <stdlib.h>\\n#include <mpi.h>\\n'\n      body     = 'int size;\\nint ierr;\\nMPI_Init(0,0);\\nierr = MPI_Type_size('+datatype+', &size);\\nif(ierr || (size == 0)) exit(1);\\nMPI_Finalize();\\n'\n      if self.checkCompile(includes, body):\n        if 'known-mpi-'+name in self.argDB:\n          if int(self.argDB['known-mpi-'+name]):\n            self.addDefine('HAVE_'+datatype, 1)\n        elif not self.argDB['with-batch']:\n          self.pushLanguage('C')\n          if self.checkRun(includes, body, defaultArg = 'known-mpi-'+name):\n            self.addDefine('HAVE_'+datatype, 1)\n          self.popLanguage()\n        else:\n         self.logPrintBox('***** WARNING: Cannot determine if '+datatype+' works on your system\\n\\\nin batch-mode! Assuming it does work. Run with --known-mpi-'+name+'=0\\n\\\nif you know it does not work (very unlikely). Run with --known-mpi-'+name+'=1\\n\\\nto remove this warning message *****')\n         self.addDefine('HAVE_'+datatype, 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    return\n\n  def alternateConfigureLibrary(self):\n    '''Setup MPIUNI, our uniprocessor version of MPI'''\n    self.addDefine('HAVE_MPIUNI', 1)\n    self.addMakeMacro('MPI_IS_MPIUNI', 1)\n    self.framework.packages.append(self)\n    self.mpiexec = '${PETSC_DIR}/lib/petsc/bin/petsc-mpiexec.uni'\n    self.addMakeMacro('MPIEXEC','${PETSC_DIR}/lib/petsc/bin/petsc-mpiexec.uni')\n    self.addDefine('HAVE_MPI_IN_PLACE', 1)\n    self.addDefine('HAVE_MPI_TYPE_DUP', 1)\n    self.addDefine('HAVE_MPI_TYPE_GET_ENVELOPE', 1)\n    self.framework.saveLog()\n    self.framework.addDefine('MPI_Type_create_struct(count,lens,displs,types,newtype)', 'MPI_Type_struct((count),(lens),(displs),(types),(newtype))')\n    self.framework.addDefine('MPI_Comm_create_errhandler(p_err_fun,p_errhandler)', 'MPI_Errhandler_create((p_err_fun),(p_errhandler))')\n    self.framework.addDefine('MPI_Comm_set_errhandler(comm,p_errhandler)', 'MPI_Errhandler_set((comm),(p_errhandler))')\n    self.logWrite(self.framework.restoreLog())\n    if self.getDefaultLanguage == 'C': self.addDefine('HAVE_MPI_C_DOUBLE_COMPLEX', 1)\n    self.commf2c = 1\n    self.commc2f = 1\n    self.usingMPIUni = 1\n    self.version = 'PETSc MPIUNI uniprocessor MPI replacement'\n    self.executeTest(self.PetscArchMPICheck)\n    return\n\n  def checkDownload(self):\n    '''Check if we should download MPICH or OpenMPI'''\n    if 'download-mpi' in self.argDB and self.argDB['download-mpi']:\n      raise RuntimeError('Option --download-mpi does not exist! Use --download-mpich or --download-openmpi instead.')\n    if self.argDB['download-mpich'] and self.argDB['download-openmpi']:\n      raise RuntimeError('Cannot install more than one of OpenMPI or  MPICH for a single configuration. \\nUse different PETSC_ARCH if you want to be able to switch between two')\n    return None\n\n  def SGIMPICheck(self):\n    '''Returns true if SGI MPI is used'''\n    if self.libraries.check(self.lib, 'MPI_SGI_barrier') :\n      self.logPrint('SGI MPI detected - defining MISSING_SIGTERM')\n      self.addDefine('MISSING_SIGTERM', 1)\n      return 1\n    else:\n      self.logPrint('SGI MPI test failure')\n      return 0\n\n  def CxxMPICheck(self):\n    '''Make sure C++ can compile and link'''\n    if not hasattr(self.compilers, 'CXX'):\n      return 0\n    self.libraries.pushLanguage('Cxx')\n    oldFlags = self.compilers.CXXPPFLAGS\n    self.compilers.CXXPPFLAGS += ' '+self.headers.toString(self.include)\n    self.log.write('Checking for header mpi.h\\n')\n    # check if MPI_Finalize from c++ exists\n    self.log.write('Checking for C++ MPI_Finalize()\\n')\n    if not self.libraries.check(self.lib, 'MPI_Finalize', prototype = '#include <mpi.h>', call = 'int ierr;\\nierr = MPI_Finalize();', cxxMangle = 1):\n      raise RuntimeError('C++ error! MPI_Finalize() could not be located!')\n    self.compilers.CXXPPFLAGS = oldFlags\n    self.libraries.popLanguage()\n    return\n\n  def FortranMPICheck(self):\n    '''Make sure fortran include [mpif.h] and library symbols are found'''\n    if not hasattr(self.compilers, 'FC'):\n      return 0\n    # Fortran compiler is being used - so make sure mpif.h exists\n    self.libraries.pushLanguage('FC')\n    oldFlags = self.compilers.FPPFLAGS\n    self.compilers.FPPFLAGS += ' '+self.headers.toString(self.include)\n    # check if mpi_init form fortran works\n    self.log.write('Checking for fortran mpi_init()\\n')\n    if not self.libraries.check(self.lib,'', call = '#include \"mpif.h\"\\n       integer ierr\\n       call mpi_init(ierr)'):\n      raise RuntimeError('Fortran error! mpi_init() could not be located!')\n    # check if mpi.mod exists\n    if self.fortran.fortranIsF90:\n      self.log.write('Checking for mpi.mod\\n')\n      if self.libraries.check(self.lib,'', call = '       use mpi\\n       integer ierr,rank\\n       call mpi_init(ierr)\\n       call mpi_comm_rank(MPI_COMM_WORLD,rank,ierr)\\n'):\n        self.havef90module = 1\n        self.addDefine('HAVE_MPI_F90MODULE', 1)\n    self.compilers.FPPFLAGS = oldFlags\n    self.libraries.popLanguage()\n    return 0\n\n  def configureIO(self):\n    '''Check for the functions in MPI/IO\n       - Define HAVE_MPIIO if they are present\n       - Some older MPI 1 implementations are missing these'''\n    # MSWIN has buggy MPI IO\n    if 'HAVE_LIBMSMPI' in self.defines: return\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    if not self.checkLink('#include <mpi.h>\\n', '''MPI_Aint lb, extent;\\nif (MPI_Type_get_extent(MPI_INT, &lb, &extent));\\n\n                                                 MPI_File fh;\\nvoid *buf;\\nMPI_Status status;\\nif (MPI_File_write_all(fh, buf, 1, MPI_INT, &status));\\n\n                                                 if (MPI_File_read_all(fh, buf, 1, MPI_INT, &status));\\n\n                                                 MPI_Offset disp;\\nMPI_Info info;\\nif (MPI_File_set_view(fh, disp, MPI_INT, MPI_INT, \"\", info));\\n\n                                                 if (MPI_File_open(MPI_COMM_SELF, \"\", 0, info, &fh));\\n\n                                                 if (MPI_File_close(&fh));\\n'''):\n      self.compilers.LIBS = oldLibs\n      self.compilers.CPPFLAGS = oldFlags\n      return\n    self.addDefine('HAVE_MPIIO', 1)\n    self.compilers.LIBS = oldLibs\n    self.compilers.CPPFLAGS = oldFlags\n    return\n\n  def checkMPICHorOpenMPI(self):\n    '''Determine if MPICH_NUMVERSION or OMPI_MAJOR_VERSION exist in mpi.h\n       Used for consistency checking of MPI installation at compile time'''\n    import re\n    HASHLINESPACE = ' *(?:\\n#.*\\n *)*'\n    oldFlags = self.compilers.CPPFLAGS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n\n    MPI_VER = ''\n    # I_MPI_NUMVERSION is broken on Windows and only has a value of 0 so test also for the named version\n    MPICHPKG = 'I_MPI'\n    mpich_test = '#include <mpi.h>\\nconst char *mpich_ver = '+MPICHPKG+'_VERSION;\\n'\n    if self.checkCompile(mpich_test):\n      buf = self.outputPreprocess(mpich_test)\n      try:\n        mpich_numversion = re.compile('\\nconst char *mpich_ver ='+HASHLINESPACE+'\"([\\.0-9]+)\"'+HASHLINESPACE+';').search(buf).group(1)\n        self.addDefine('HAVE_'+MPICHPKG+'_VERSION',mpich_numversion)\n        MPI_VER  = '  '+MPICHPKG+'_VERSION: '+mpich_numversion\n      except:\n        self.logPrint('Unable to parse '+MPICHPKG+' version from header. Probably a buggy preprocessor')\n    for mpichpkg in ['i_mpi','mvapich2','mpich']:\n      MPICHPKG = mpichpkg.upper()\n      mpich_test = '#include <mpi.h>\\nint mpich_ver = '+MPICHPKG+'_NUMVERSION;\\n'\n      if self.checkCompile(mpich_test):\n        buf = self.outputPreprocess(mpich_test)\n        try:\n          mpich_numversion = re.compile('\\nint mpich_ver ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n          self.addDefine('HAVE_'+MPICHPKG+'_NUMVERSION',mpich_numversion)\n          MPI_VER += '  '+MPICHPKG+'_NUMVERSION: '+mpich_numversion\n          if mpichpkg == 'mpich': self.mpich_numversion = mpich_numversion\n        except:\n          self.logPrint('Unable to parse '+MPICHPKG+' version from header. Probably a buggy preprocessor')\n    if MPI_VER:\n      self.compilers.CPPFLAGS = oldFlags\n      self.mpi_pkg_version = MPI_VER+'\\n'\n      return\n    openmpi_test = '#include <mpi.h>\\nint ompi_major = OMPI_MAJOR_VERSION;\\nint ompi_minor = OMPI_MINOR_VERSION;\\nint ompi_release = OMPI_RELEASE_VERSION;\\n'\n    if self.checkCompile(openmpi_test):\n      buf = self.outputPreprocess(openmpi_test)\n      ompi_major_version = ompi_minor_version = ompi_release_version = 'unknown'\n      try:\n        ompi_major_version = re.compile('\\nint ompi_major ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        ompi_minor_version = re.compile('\\nint ompi_minor ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        ompi_release_version = re.compile('\\nint ompi_release ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        self.addDefine('HAVE_OMPI_MAJOR_VERSION',ompi_major_version)\n        self.addDefine('HAVE_OMPI_MINOR_VERSION',ompi_minor_version)\n        self.addDefine('HAVE_OMPI_RELEASE_VERSION',ompi_release_version)\n        self.ompi_major_version = ompi_major_version\n        self.mpi_pkg_version = '  OMPI_VERSION: '+ompi_major_version+'.'+ompi_minor_version+'.'+ompi_release_version+'\\n'\n      except:\n        self.logPrint('Unable to parse OpenMPI version from header. Probably a buggy preprocessor')\n    self.compilers.CPPFLAGS = oldFlags\n    return\n\n  def findMPIInc(self):\n    '''Find MPI include paths from \"mpicc -show\" and use with CUDAC_FLAGS'''\n    if not hasattr(self.compilers, 'CUDAC'): return\n    import re\n    output = ''\n    try:\n      output   = self.executeShellCommand(self.compilers.CC + ' -show', log = self.log)[0]\n      compiler = output.split(' ')[0]\n    except:\n      pass\n    argIter = iter(output.split())\n    try:\n      while 1:\n        arg = next(argIter)\n        self.logPrint( 'Checking arg '+arg, 4, 'compilers')\n        m = re.match(r'^-I.*$', arg)\n        if m:\n          self.logPrint('Found include option: '+arg, 4, 'compilers')\n          self.setCompilers.pushLanguage('CUDA')\n          self.setCompilers.addCompilerFlag(arg)\n          self.setCompilers.popLanguage()\n          continue\n    except StopIteration:\n      pass\n    return\n\n  def log_print_mpi_h_line(self,buf):\n    for line in buf.splitlines():\n      if 'mpi.h' in line:\n        self.log.write('mpi_h_line:\\n'+line+'\\n')\n        return\n    self.log.write('mpi.h not found in buf')\n    return\n\n  def PetscArchMPICheck(self):\n    import os\n    '''Makes sure incompatable mpi.h is not in the PETSC_ARCH/include directory'''\n    build_mpi_h_dir = os.path.join(self.petscdir.dir,self.arch,'include')\n    build_mpi_h = os.path.join(build_mpi_h_dir,'mpi.h')\n    if os.path.isfile(build_mpi_h):\n      self.log.write('mpi.h found in build dir! Checking if its a bad copy.\\n')\n      if self.usingMPIUni:\n        raise RuntimeError('There is a copy of mpi.h in '+build_mpi_h_dir+' that will conflict with --with-mpi=0 build. do:\\nrm -rf '+self.arch+' and run ./configure again\\n')\n      oldFlags = self.compilers.CPPFLAGS\n      mpi_h_test = '#include <mpi.h>'\n      # check self.include\n      self.compilers.CPPFLAGS = oldFlags+' '+self.headers.toString(self.include)\n      buf1 = self.outputPreprocess(mpi_h_test)\n      self.log_print_mpi_h_line(buf1)\n      # check build_mpi_h_dir and self.include\n      self.compilers.CPPFLAGS = oldFlags+' '+self.headers.getIncludeArgument(build_mpi_h_dir)+' '+self.headers.toString(self.include)\n      buf2 = self.outputPreprocess(mpi_h_test)\n      self.log_print_mpi_h_line(buf2)\n      if buf1 != buf2:\n        raise RuntimeError('There is a copy of mpi.h in '+build_mpi_h_dir+' that is not compatible with your MPI, do:\\nrm -rf '+self.arch+' and run ./configure again\\n')\n      self.compilers.CPPFLAGS = oldFlags\n    return\n\n\n  def configureLibrary(self):\n    import platform\n    '''Calls the regular package configureLibrary and then does an additional test needed by MPI'''\n    if 'with-'+self.package+'-shared' in self.argDB:\n      self.argDB['with-'+self.package] = 1\n    config.package.Package.configureLibrary(self)\n    self.executeTest(self.checkMPICHorOpenMPI)\n    if any(x in platform.processor() for x in ['i386','x86','i86pc']) and config.setCompilers.Configure.isSolaris(self.log) and hasattr(self, 'mpich_numversion') and int(self.mpich_numversion) >= 30301300:\n      # this is only needed if MPICH/HWLOC were compiled with optimization\n      self.logWrite('Setting environmental variable to work around buggy HWLOC\\nhttps://github.com/open-mpi/hwloc/issues/290\\n')\n      os.environ['HWLOC_COMPONENTS'] = '-x86'\n      self.addDefine('HAVE_HWLOC_SOLARIS_BUG',1)\n      self.logPrintBox('***** WARNING: This MPI implementation may have a bug in it that causes programs to hang.\\n\\\nYou may need to set the environmental variable HWLOC_COMPONENTS to -x86 to prevent such hangs. warning message *****')\n    self.executeTest(self.configureMPI2)\n    self.executeTest(self.configureMPI3) #depends on checkMPICHorOpenMPI for self.mpich_numversion\n    self.executeTest(self.configureMPITypes)\n    self.executeTest(self.SGIMPICheck)\n    self.executeTest(self.CxxMPICheck)\n    self.executeTest(self.FortranMPICheck)\n    self.executeTest(self.configureIO)\n    self.executeTest(self.findMPIInc)\n    self.executeTest(self.PetscArchMPICheck)\n    self.executeTest(self.configureMPIEXEC)\n    funcs = '''MPI_Type_get_envelope  MPI_Type_dup MPI_Init_thread MPI_Iallreduce MPI_Ibarrier MPI_Finalized MPI_Exscan MPI_Reduce_scatter MPI_Reduce_scatter_block'''.split()\n    found, missing = self.libraries.checkClassify(self.dlib, funcs)\n    for f in found:\n      self.addDefine('HAVE_' + f.upper(),1)\n    for f in ['MPIX_Iallreduce', 'MPIX_Ibarrier']: # Unlikely to be found\n      if self.libraries.check(self.dlib, f):\n        self.addDefine('HAVE_' + f.upper(),1)\n\n    oldFlags = self.compilers.CPPFLAGS # Disgusting save and restore\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    for combiner in ['MPI_COMBINER_DUP', 'MPI_COMBINER_CONTIGUOUS', 'MPI_COMBINER_NAMED']:\n      if self.checkCompile('#include <mpi.h>', 'int combiner = %s;' % (combiner,)):\n        self.addDefine('HAVE_' + combiner,1)\n    self.compilers.CPPFLAGS = oldFlags\n\n    if hasattr(self,'mpich_numversion'):\n      if self.libraries.check(self.dlib, \"MPIDI_CH3I_sock_set\"):\n        self.addDefine('HAVE_MPICH_CH3_SOCK', 1)\n      if self.libraries.check(self.dlib, \"MPIDI_CH3I_sock_fixed_nbc_progress\"):\n        # Indicates that this bug was fixed: http://trac.mpich.org/projects/mpich/ticket/1785\n        self.addDefine('HAVE_MPICH_CH3_SOCK_FIXED_NBC_PROGRESS', 1)\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/sys/dll/dlimpl.c.html": "<center><a href=\"dlimpl.c\">Actual source code: dlimpl.c</a></center><br>\n\n<html>\n<head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/sys/dll/dlimpl.c.html\" />\n<title></title>\n<meta name=\"generator\" content=\"c2html 0.9.4\">\n<meta name=\"date\" content=\"2019-11-22T19:08:31+00:00\">\n</head>\n\n<body bgcolor=\"#FFFFFF\">\n   <div id=\"version\" align=right><b>petsc-3.12.2 2019-11-22</b></div>\n   <div id=\"bugreport\" align=right><a href=\"mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.12.2 v3.12.2 src/sys/dll/dlimpl.c.html \"><small>Report Typos and Errors</small></a></div>\n<pre width=\"80\">\n\n<a name=\"line2\">  2: </a><font color=\"#B22222\">/*</font>\n<a name=\"line3\">  3: </a><font color=\"#B22222\">   Low-level routines for managing dynamic link libraries (DLLs).</font>\n<a name=\"line4\">  4: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line6\">  6: </a> #include <A href=\"../../../include/petsc/private/petscimpl.h.html\">&lt;petsc/private/petscimpl.h&gt;</A>\n<a name=\"line7\">  7: </a> #include <A href=\"../../../include/petscvalgrind.h.html\">&lt;petscvalgrind.h&gt;</A>\n\n<a name=\"line9\">  9: </a><font color=\"#B22222\">/* XXX Should be done better !!!*/</font>\n<a name=\"line10\"> 10: </a><font color=\"#A020F0\">#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line11\"> 11: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_WINDOWS_H</font></strong>\n<a name=\"line12\"> 12: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_DLFCN_H</font></strong>\n<a name=\"line13\"> 13: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line15\"> 15: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line16\"> 16: </a><font color=\"#A020F0\">#include &lt;windows.h&gt;</font>\n<a name=\"line17\"> 17: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line18\"> 18: </a><font color=\"#A020F0\">#include &lt;dlfcn.h&gt;</font>\n<a name=\"line19\"> 19: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line21\"> 21: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line22\"> 22: </a><font color=\"#4169E1\">typedef HMODULE dlhandle_t;</font>\n<a name=\"line23\"> 23: </a><font color=\"#4169E1\">typedef FARPROC dlsymbol_t;</font>\n<a name=\"line24\"> 24: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line25\"> 25: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line26\"> 26: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line27\"> 27: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line28\"> 28: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line29\"> 29: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line30\"> 30: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line32\"> 32: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line33\"> 33: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a> - opens dynamic library</font>\n\n<a name=\"line35\"> 35: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line37\"> 37: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line38\"> 38: </a><font color=\"#B22222\">+    name - name of library</font>\n<a name=\"line39\"> 39: </a><font color=\"#B22222\">-    mode - options on how to open library</font>\n\n<a name=\"line41\"> 41: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line42\"> 42: </a><font color=\"#B22222\">.    handle</font>\n\n<a name=\"line44\"> 44: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line46\"> 46: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line47\"> 47: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLOpen\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>(const char name[],PetscDLMode mode,PetscDLHandle *handle)</font></strong>\n<a name=\"line48\"> 48: </a>{\n<a name=\"line49\"> 49: </a>  PETSC_UNUSED int dlflags1,dlflags2; <font color=\"#B22222\">/* There are some preprocessor paths where these variables are set, but not used */</font>\n<a name=\"line50\"> 50: </a>  dlhandle_t       dlhandle;\n\n\n<a name=\"line56\"> 56: </a>  dlflags1 = 0;\n<a name=\"line57\"> 57: </a>  dlflags2 = 0;\n<a name=\"line58\"> 58: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line59\"> 59: </a>  *handle  = (PetscDLHandle) 0;\n\n<a name=\"line61\"> 61: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line62\"> 62: </a><font color=\"#B22222\">     --- LoadLibrary ---</font>\n<a name=\"line63\"> 63: </a><font color=\"#B22222\">  */</font>\n<a name=\"line64\"> 64: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H) &amp;&amp; defined(PETSC_HAVE_LOADLIBRARY)</font>\n<a name=\"line65\"> 65: </a>  dlhandle = LoadLibrary(name);\n<a name=\"line66\"> 66: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line67\"> 67: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line69\"> 69: </a>    DWORD          erc;\n<a name=\"line70\"> 70: </a>    char           *buff = NULL;\n<a name=\"line71\"> 71: </a>    erc = GetLastError();\n<a name=\"line72\"> 72: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n<a name=\"line73\"> 73: </a>                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line74\"> 74: </a>    <a href=\"../../../docs/manualpages/Sys/PetscError.html#PetscError\">PetscError</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,__LINE__,PETSC_FUNCTION_NAME,__FILE__,PETSC_ERR_FILE_OPEN,<a href=\"../../../docs/manualpages/Sys/PetscErrorType.html#PetscErrorType\">PETSC_ERROR_REPEAT</a>,\n<a name=\"line75\"> 75: </a>                      <font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,buff);\n<a name=\"line76\"> 76: </a>    LocalFree(buff);\n<a name=\"line77\"> 77: </a>    <a href=\"../../../docs/manualpages/Sys/PetscFunctionReturn.html#PetscFunctionReturn\">PetscFunctionReturn</a>(ierr);\n<a name=\"line78\"> 78: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line79\"> 79: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line80\"> 80: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line81\"> 81: </a>  }\n\n<a name=\"line83\"> 83: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line84\"> 84: </a><font color=\"#B22222\">     --- dlopen ---</font>\n<a name=\"line85\"> 85: </a><font color=\"#B22222\">  */</font>\n<a name=\"line86\"> 86: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H) &amp;&amp; defined(PETSC_HAVE_DLOPEN)</font>\n<a name=\"line87\"> 87: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line88\"> 88: </a><font color=\"#B22222\">      Mode indicates symbols required by symbol loaded with dlsym()</font>\n<a name=\"line89\"> 89: </a><font color=\"#B22222\">     are only loaded when required (not all together) also indicates</font>\n<a name=\"line90\"> 90: </a><font color=\"#B22222\">     symbols required can be contained in other libraries also opened</font>\n<a name=\"line91\"> 91: </a><font color=\"#B22222\">     with dlopen()</font>\n<a name=\"line92\"> 92: </a><font color=\"#B22222\">  */</font>\n<a name=\"line93\"> 93: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line94\"> 94: </a>  dlflags1 = RTLD_LAZY;\n<a name=\"line95\"> 95: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line96\"> 96: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line97\"> 97: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n<a name=\"line98\"> 98: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line99\"> 99: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line100\">100: </a>  dlflags2 = RTLD_GLOBAL;\n<a name=\"line101\">101: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line102\">102: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line103\">103: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n<a name=\"line104\">104: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line105\">105: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line106\">106: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line107\">107: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line108\">108: </a>  dlhandle = dlopen(name,dlflags1|dlflags2);\n<a name=\"line109\">109: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line110\">110: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line111\">111: </a>    const char *errmsg = dlerror();\n<a name=\"line112\">112: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line113\">113: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line114\">114: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line115\">115: </a>    <a href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\"</font>,name,errmsg);\n<a name=\"line116\">116: </a>  }\n\n<a name=\"line118\">118: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line119\">119: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line120\">120: </a><font color=\"#B22222\">  */</font>\n<a name=\"line121\">121: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line122\">122: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line123\">123: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line125\">125: </a>  *handle = (PetscDLHandle) dlhandle;\n<a name=\"line126\">126: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line127\">127: </a>}\n\n\n<a name=\"line130\">130: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line131\">131: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a> -  closes a dynamic library</font>\n\n<a name=\"line133\">133: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line135\">135: </a><font color=\"#B22222\">  Input Parameter:</font>\n<a name=\"line136\">136: </a><font color=\"#B22222\">.   handle - the handle for the library obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>()</font>\n\n<a name=\"line138\">138: </a><font color=\"#B22222\">  Level: developer</font>\n<a name=\"line139\">139: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line140\">140: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLClose\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</a>(PetscDLHandle *handle)</font></strong>\n<a name=\"line141\">141: </a>{\n\n\n<a name=\"line146\">146: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line147\">147: </a><font color=\"#B22222\">     --- FreeLibrary ---</font>\n<a name=\"line148\">148: </a><font color=\"#B22222\">  */</font>\n<a name=\"line149\">149: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line150\">150: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_FREELIBRARY)</font>\n<a name=\"line151\">151: </a>  <font color=\"#4169E1\">if</font> (FreeLibrary((dlhandle_t)*handle) == 0) {\n<a name=\"line152\">152: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line153\">153: </a>    char  *buff = NULL;\n<a name=\"line154\">154: </a>    DWORD erc   = GetLastError();\n<a name=\"line155\">155: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line156\">156: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,buff);\n<a name=\"line157\">157: </a>    LocalFree(buff);\n<a name=\"line158\">158: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line159\">159: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line160\">160: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line161\">161: </a>  }\n<a name=\"line162\">162: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_FREELIBRARY */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line164\">164: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line165\">165: </a><font color=\"#B22222\">     --- dclose ---</font>\n<a name=\"line166\">166: </a><font color=\"#B22222\">  */</font>\n<a name=\"line167\">167: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line168\">168: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLCLOSE)</font>\n<a name=\"line169\">169: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line170\">170: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line171\">171: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line172\">172: </a>  <font color=\"#4169E1\">if</font> (dlclose((dlhandle_t)*handle) &lt; 0) {\n<a name=\"line173\">173: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line174\">174: </a>    const char *errmsg = dlerror();\n<a name=\"line175\">175: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line176\">176: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line177\">177: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line178\">178: </a>    <a href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</a>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\"</font>, errmsg);\n<a name=\"line179\">179: </a>  }\n<a name=\"line180\">180: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_DLCLOSE */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line182\">182: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line183\">183: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line184\">184: </a><font color=\"#B22222\">  */</font>\n<a name=\"line185\">185: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line186\">186: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line187\">187: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line189\">189: </a>  *handle = NULL;\n<a name=\"line190\">190: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line191\">191: </a>}\n\n<a name=\"line193\">193: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line194\">194: </a><font color=\"#B22222\">   <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a> - finds a symbol in a dynamic library</font>\n\n<a name=\"line196\">196: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line198\">198: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line199\">199: </a><font color=\"#B22222\">+   handle - obtained with <a href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</a>() or NULL</font>\n<a name=\"line200\">200: </a><font color=\"#B22222\">-   symbol - name of symbol</font>\n\n<a name=\"line202\">202: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line203\">203: </a><font color=\"#B22222\">.   value - pointer to the function, NULL if not found</font>\n\n<a name=\"line205\">205: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line207\">207: </a><font color=\"#B22222\">  Notes:</font>\n<a name=\"line208\">208: </a><font color=\"#B22222\">   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.</font>\n<a name=\"line209\">209: </a><font color=\"#B22222\">   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like</font>\n<a name=\"line210\">210: </a><font color=\"#B22222\">   systems this requires platform-specific linker flags.</font>\n\n<a name=\"line212\">212: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line213\">213: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLSym\"></a><a href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>  <a href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a>(PetscDLHandle handle,const char symbol[],void **value)</font></strong>\n<a name=\"line214\">214: </a>{\n<a name=\"line215\">215: </a>  PETSC_UNUSED dlhandle_t dlhandle;\n<a name=\"line216\">216: </a>  dlsymbol_t              dlsymbol;\n\n\n<a name=\"line221\">221: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line222\">222: </a>  dlsymbol = (dlsymbol_t) 0;\n<a name=\"line223\">223: </a>  *value   = (void*) 0;\n\n<a name=\"line225\">225: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line226\">226: </a><font color=\"#B22222\">     --- GetProcAddress ---</font>\n<a name=\"line227\">227: </a><font color=\"#B22222\">  */</font>\n<a name=\"line228\">228: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line229\">229: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETPROCADDRESS)</font>\n<a name=\"line230\">230: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line231\">231: </a>  <font color=\"#4169E1\">else</font> dlhandle = (dlhandle_t) GetCurrentProcess();\n<a name=\"line232\">232: </a>  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n<a name=\"line233\">233: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_SETLASTERROR)</font>\n<a name=\"line234\">234: </a>  SetLastError((DWORD)0); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line235\">235: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line236\">236: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_GETPROCADDRESS */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line238\">238: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line239\">239: </a><font color=\"#B22222\">     --- dlsym ---</font>\n<a name=\"line240\">240: </a><font color=\"#B22222\">  */</font>\n<a name=\"line241\">241: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line242\">242: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLSYM)</font>\n<a name=\"line243\">243: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line244\">244: </a>  <font color=\"#4169E1\">else</font> {\n\n<a name=\"line246\">246: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLOPEN) &amp;&amp; defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line247\">247: </a>    <font color=\"#B22222\">/* Attempt to retrieve the main executable's dlhandle. */</font>\n<a name=\"line248\">248: </a>    { int dlflags1 = 0, dlflags2 = 0;\n<a name=\"line249\">249: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line250\">250: </a>      dlflags1 = RTLD_LAZY;\n<a name=\"line251\">251: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line252\">252: </a>      <font color=\"#4169E1\">if</font> (!dlflags1) {\n<a name=\"line253\">253: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line254\">254: </a>        dlflags1 = RTLD_NOW;\n<a name=\"line255\">255: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line256\">256: </a>      }\n<a name=\"line257\">257: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line258\">258: </a>      dlflags2 = RTLD_LOCAL;\n<a name=\"line259\">259: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line260\">260: </a>      <font color=\"#4169E1\">if</font> (!dlflags2) {\n<a name=\"line261\">261: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line262\">262: </a>        dlflags2 = RTLD_GLOBAL;\n<a name=\"line263\">263: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line264\">264: </a>      }\n<a name=\"line265\">265: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line266\">266: </a>      <font color=\"#4169E1\">if</font> (!(PETSC_RUNNING_ON_VALGRIND)) {\n<a name=\"line267\">267: </a>        dlerror(); <font color=\"#B22222\">/* clear any previous error; valgrind does not like this */</font>\n<a name=\"line268\">268: </a>      }\n<a name=\"line269\">269: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line270\">270: </a>      <font color=\"#B22222\">/* Attempt to open the main executable as a dynamic library. */</font>\n<a name=\"line271\">271: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTDL_DEFAULT)</font>\n<a name=\"line272\">272: </a>      dlhandle = RTLD_DEFAULT;\n<a name=\"line273\">273: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line274\">274: </a>      dlhandle = dlopen(0, dlflags1|dlflags2);\n<a name=\"line275\">275: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line276\">276: </a>      { const char *e = (const char*) dlerror();\n<a name=\"line277\">277: </a>        <font color=\"#4169E1\">if</font> (e) <a href=\"../../../docs/manualpages/Sys/SETERRQ1.html#SETERRQ1\">SETERRQ1</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>, PETSC_ERR_ARG_WRONG, <font color=\"#666666\">\"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\"</font>, e);\n<a name=\"line278\">278: </a>      }\n<a name=\"line279\">279: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line280\">280: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line281\">281: </a>    }\n<a name=\"line282\">282: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line283\">283: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* PETSC_HAVE_DLOPEN &amp;&amp; PETSC_HAVE_DYNAMIC_LIBRARIES */</font><font color=\"#A020F0\"></font>\n<a name=\"line284\">284: </a>  }\n<a name=\"line285\">285: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line286\">286: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line287\">287: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line288\">288: </a>  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n<a name=\"line289\">289: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line290\">290: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line291\">291: </a><font color=\"#B22222\">  */</font>\n<a name=\"line292\">292: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line293\">293: </a>  <a href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</a>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line294\">294: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line296\">296: </a>  *value = *((void**)&amp;dlsymbol);\n\n<a name=\"line298\">298: </a><font color=\"#A020F0\">#if defined(PETSC_SERIALIZE_FUNCTIONS)</font>\n<a name=\"line299\">299: </a>  <font color=\"#4169E1\">if</font> (*value) {\n<a name=\"line301\">301: </a>    PetscFPTAdd(*value,symbol);\n<a name=\"line302\">302: </a>  }\n<a name=\"line303\">303: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line304\">304: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line305\">305: </a>}\n</pre>\n</body>\n\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/sys/dll/dlimpl.c": "\n/*\n   Low-level routines for managing dynamic link libraries (DLLs).\n*/\n\n#include <petsc/private/petscimpl.h>\n#include <petscvalgrind.h>\n\n/* XXX Should be done better !!!*/\n#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n#undef PETSC_HAVE_WINDOWS_H\n#undef PETSC_HAVE_DLFCN_H\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\n#include <windows.h>\n#elif defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\ntypedef HMODULE dlhandle_t;\ntypedef FARPROC dlsymbol_t;\n#elif defined(PETSC_HAVE_DLFCN_H)\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#else\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#endif\n\n/*@C\n   PetscDLOpen - opens dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+    name - name of library\n-    mode - options on how to open library\n\n   Output Parameter:\n.    handle\n\n   Level: developer\n\n@*/\nPetscErrorCode  PetscDLOpen(const char name[],PetscDLMode mode,PetscDLHandle *handle)\n{\n  PETSC_UNUSED int dlflags1,dlflags2; /* There are some preprocessor paths where these variables are set, but not used */\n  dlhandle_t       dlhandle;\n\n  PetscFunctionBegin;\n  PetscValidCharPointer(name,1);\n  PetscValidPointer(handle,3);\n\n  dlflags1 = 0;\n  dlflags2 = 0;\n  dlhandle = (dlhandle_t) 0;\n  *handle  = (PetscDLHandle) 0;\n\n  /*\n     --- LoadLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H) && defined(PETSC_HAVE_LOADLIBRARY)\n  dlhandle = LoadLibrary(name);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    PetscErrorCode ierr;\n    DWORD          erc;\n    char           *buff = NULL;\n    erc = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    ierr = PetscError(PETSC_COMM_SELF,__LINE__,PETSC_FUNCTION_NAME,__FILE__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n                      \"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,buff);\n    LocalFree(buff);\n    PetscFunctionReturn(ierr);\n#else\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,\"unavailable\");\n#endif\n  }\n\n  /*\n     --- dlopen ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H) && defined(PETSC_HAVE_DLOPEN)\n  /*\n      Mode indicates symbols required by symbol loaded with dlsym()\n     are only loaded when required (not all together) also indicates\n     symbols required can be contained in other libraries also opened\n     with dlopen()\n  */\n#if defined(PETSC_HAVE_RTLD_LAZY)\n  dlflags1 = RTLD_LAZY;\n#endif\n#if defined(PETSC_HAVE_RTLD_NOW)\n  if (mode & PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n#endif\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n  dlflags2 = RTLD_GLOBAL;\n#endif\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n  if (mode & PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n#endif\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlhandle = dlopen(name,dlflags1|dlflags2);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\",name,errmsg);\n  }\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = (PetscDLHandle) dlhandle;\n  PetscFunctionReturn(0);\n}\n\n\n/*@C\n   PetscDLClose -  closes a dynamic library\n\n   Not Collective\n\n  Input Parameter:\n.   handle - the handle for the library obtained with PetscDLOpen()\n\n  Level: developer\n@*/\nPetscErrorCode  PetscDLClose(PetscDLHandle *handle)\n{\n\n  PetscFunctionBegin;\n  PetscValidPointer(handle,1);\n\n  /*\n     --- FreeLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_FREELIBRARY)\n  if (FreeLibrary((dlhandle_t)*handle) == 0) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    char  *buff = NULL;\n    DWORD erc   = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",buff);\n    LocalFree(buff);\n#else\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",\"unavailable\");\n#endif\n  }\n#endif /* !PETSC_HAVE_FREELIBRARY */\n\n  /*\n     --- dclose ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLCLOSE)\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  if (dlclose((dlhandle_t)*handle) < 0) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\", errmsg);\n  }\n#endif /* !PETSC_HAVE_DLCLOSE */\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = NULL;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscDLSym - finds a symbol in a dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+   handle - obtained with PetscDLOpen() or NULL\n-   symbol - name of symbol\n\n   Output Parameter:\n.   value - pointer to the function, NULL if not found\n\n   Level: developer\n\n  Notes:\n   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.\n   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like\n   systems this requires platform-specific linker flags.\n\n@*/\nPetscErrorCode  PetscDLSym(PetscDLHandle handle,const char symbol[],void **value)\n{\n  PETSC_UNUSED dlhandle_t dlhandle;\n  dlsymbol_t              dlsymbol;\n\n  PetscValidCharPointer(symbol,2);\n  PetscValidPointer(value,3);\n\n  dlhandle = (dlhandle_t) 0;\n  dlsymbol = (dlsymbol_t) 0;\n  *value   = (void*) 0;\n\n  /*\n     --- GetProcAddress ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_GETPROCADDRESS)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else dlhandle = (dlhandle_t) GetCurrentProcess();\n  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n#if defined(PETSC_HAVE_SETLASTERROR)\n  SetLastError((DWORD)0); /* clear any previous error */\n#endif\n#endif /* !PETSC_HAVE_GETPROCADDRESS */\n\n  /*\n     --- dlsym ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLSYM)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else {\n\n#if defined(PETSC_HAVE_DLOPEN) && defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n    /* Attempt to retrieve the main executable's dlhandle. */\n    { int dlflags1 = 0, dlflags2 = 0;\n#if defined(PETSC_HAVE_RTLD_LAZY)\n      dlflags1 = RTLD_LAZY;\n#endif\n      if (!dlflags1) {\n#if defined(PETSC_HAVE_RTLD_NOW)\n        dlflags1 = RTLD_NOW;\n#endif\n      }\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n      dlflags2 = RTLD_LOCAL;\n#endif\n      if (!dlflags2) {\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n        dlflags2 = RTLD_GLOBAL;\n#endif\n      }\n#if defined(PETSC_HAVE_DLERROR)\n      if (!(PETSC_RUNNING_ON_VALGRIND)) {\n        dlerror(); /* clear any previous error; valgrind does not like this */\n      }\n#endif\n      /* Attempt to open the main executable as a dynamic library. */\n#if defined(PETSC_HAVE_RTDL_DEFAULT)\n      dlhandle = RTLD_DEFAULT;\n#else\n      dlhandle = dlopen(0, dlflags1|dlflags2);\n#if defined(PETSC_HAVE_DLERROR)\n      { const char *e = (const char*) dlerror();\n        if (e) SETERRQ1(PETSC_COMM_SELF, PETSC_ERR_ARG_WRONG, \"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\", e);\n      }\n#endif\n#endif\n    }\n#endif\n#endif /* PETSC_HAVE_DLOPEN && PETSC_HAVE_DYNAMIC_LIBRARIES */\n  }\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *value = *((void**)&dlsymbol);\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  if (*value) {\n    PetscErrorCode ierr;\n    ierr = PetscFPTAdd(*value,symbol);CHKERRQ(ierr);\n  }\n#endif\n  return(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/advection-diffusion-reaction/ex1.c": "\nstatic char help[] = \"Nonlinear Reaction Problem from Chemistry.\\n\";\n\n/*F\n\n     This directory contains examples based on the PDES/ODES given in the book\n      Numerical Solution of Time-Dependent Advection-Diffusion-Reaction Equations by\n      W. Hundsdorf and J.G. Verwer\n\n     Page 3, Section 1.1 Nonlinear Reaction Problems from Chemistry\n\n\\begin{eqnarray}\n                 {U_1}_t  - k U_1 U_2  & = & 0 \\\\\n                 {U_2}_t  - k U_1 U_2 & = & 0 \\\\\n                 {U_3}_t  - k U_1 U_2 & = & 0\n\\end{eqnarray}\n\n     Helpful runtime monitoring options:\n         -ts_view                  -  prints information about the solver being used\n         -ts_monitor               -  prints the progess of the solver\n         -ts_adapt_monitor         -  prints the progress of the time-step adaptor\n         -ts_monitor_lg_timestep   -  plots the size of each timestep (at each time-step)\n         -ts_monitor_lg_solution   -  plots each component of the solution as a function of time (at each timestep)\n         -ts_monitor_lg_error      -  plots each component of the error in the solution as a function of time (at each timestep)\n         -draw_pause -2            -  hold the plots a the end of the solution process, enter a mouse press in each window to end the process\n\n         -ts_monitor_lg_timestep -1  -  plots the size of each timestep (at the end of the solution process)\n         -ts_monitor_lg_solution -1  -  plots each component of the solution as a function of time (at the end of the solution process)\n         -ts_monitor_lg_error -1     -  plots each component of the error in the solution as a function of time (at the end of the solution process)\n         -lg_use_markers false       -  do NOT show the data points on the plots\n         -draw_save                  -  save the timestep and solution plot as a .Gif image file\n\nF*/\n\n/*\n      Project: Generate a nicely formated HTML page using\n         1) the HTML version of the source code and text in this file, use make html to generate the file ex1.c.html\n         2) the images (Draw_XXX_0_0.Gif Draw_YYY_0_0.Gif Draw_ZZZ_1_0.Gif) and\n         3) the text output (output.txt) generated by running the following commands.\n         4) <iframe src=\"generated_topics.html\" scrolling=\"no\" frameborder=\"0\"  width=600 height=300></iframe>\n\n      rm -rf *.Gif\n      ./ex1 -ts_monitor_lg_error -1 -ts_monitor_lg_solution -1   -draw_pause -2 -ts_max_steps 100 -ts_monitor_lg_timestep -1 -draw_save -draw_virtual -ts_monitor -ts_adapt_monitor -ts_view  > output.txt\n\n      For example something like\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n    <title>PETSc Example -- Nonlinear Reaction Problem from Chemistry</title>\n  </head>\n  <body>\n  <iframe src=\"ex1.c.html\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=400></iframe>\n  <img alt=\"\" src=\"Draw_0x84000000_0_0.Gif\"/><img alt=\"\" src=\"Draw_0x84000001_0_0.Gif\"/><img alt=\"\" src=\"Draw_0x84000001_1_0.Gif\"/>\n  <iframe src=\"output.txt\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=1000></iframe>\n  </body>\n</html>\n\n*/\n\n/*\n   Include \"petscts.h\" so that we can use TS solvers.  Note that this\n   file automatically includes:\n     petscsys.h       - base PETSc routines   petscvec.h - vectors\n     petscmat.h - matrices\n     petscis.h     - index sets            petscksp.h - Krylov subspace methods\n     petscviewer.h - viewers               petscpc.h  - preconditioners\n     petscksp.h   - linear solvers\n*/\n\n#include <petscts.h>\n\ntypedef struct {\n  PetscScalar k;\n  Vec         initialsolution;\n} AppCtx;\n\nPetscErrorCode IFunctionView(AppCtx *ctx,PetscViewer v)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscViewerBinaryWrite(v,&ctx->k,1,PETSC_SCALAR,PETSC_FALSE);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\nPetscErrorCode IFunctionLoad(AppCtx **ctx,PetscViewer v)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscNew(ctx);CHKERRQ(ierr);\n  ierr = PetscViewerBinaryRead(v,&(*ctx)->k,1,NULL,PETSC_SCALAR);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the ODE passed to the ODE solver\n*/\nPetscErrorCode IFunction(TS ts,PetscReal t,Vec U,Vec Udot,Vec F,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  PetscScalar       *f;\n  const PetscScalar *u,*udot;\n\n  PetscFunctionBegin;\n  /*  The next three lines allow us to access the entries of the vectors directly */\n  ierr = VecGetArrayRead(U,&u);CHKERRQ(ierr);\n  ierr = VecGetArrayRead(Udot,&udot);CHKERRQ(ierr);\n  ierr = VecGetArray(F,&f);CHKERRQ(ierr);\n  f[0] = udot[0] + ctx->k*u[0]*u[1];\n  f[1] = udot[1] + ctx->k*u[0]*u[1];\n  f[2] = udot[2] - ctx->k*u[0]*u[1];\n  ierr = VecRestoreArrayRead(U,&u);CHKERRQ(ierr);\n  ierr = VecRestoreArrayRead(Udot,&udot);CHKERRQ(ierr);\n  ierr = VecRestoreArray(F,&f);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the Jacobian of the ODE passed to the ODE solver. See TSSetIJacobian() for the meaning of a and the Jacobian.\n*/\nPetscErrorCode IJacobian(TS ts,PetscReal t,Vec U,Vec Udot,PetscReal a,Mat A,Mat B,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  PetscInt          rowcol[] = {0,1,2};\n  PetscScalar       J[3][3];\n  const PetscScalar *u,*udot;\n\n  PetscFunctionBegin;\n  ierr    = VecGetArrayRead(U,&u);CHKERRQ(ierr);\n  ierr    = VecGetArrayRead(Udot,&udot);CHKERRQ(ierr);\n  J[0][0] = a + ctx->k*u[1];   J[0][1] = ctx->k*u[0];       J[0][2] = 0.0;\n  J[1][0] = ctx->k*u[1];       J[1][1] = a + ctx->k*u[0];   J[1][2] = 0.0;\n  J[2][0] = -ctx->k*u[1];      J[2][1] = -ctx->k*u[0];      J[2][2] = a;\n  ierr    = MatSetValues(B,3,rowcol,3,rowcol,&J[0][0],INSERT_VALUES);CHKERRQ(ierr);\n  ierr    = VecRestoreArrayRead(U,&u);CHKERRQ(ierr);\n  ierr    = VecRestoreArrayRead(Udot,&udot);CHKERRQ(ierr);\n\n  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  if (A != B) {\n    ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n    ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  }\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the exact (analytic) solution to the ODE\n*/\nstatic PetscErrorCode Solution(TS ts,PetscReal t,Vec U,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  const PetscScalar *uinit;\n  PetscScalar       *u,d0,q;\n\n  PetscFunctionBegin;\n  ierr = VecGetArrayRead(ctx->initialsolution,&uinit);CHKERRQ(ierr);\n  ierr = VecGetArray(U,&u);CHKERRQ(ierr);\n  d0   = uinit[0] - uinit[1];\n  if (d0 == 0.0) q = ctx->k*t;\n  else q = (1.0 - PetscExpScalar(-ctx->k*t*d0))/d0;\n  u[0] = uinit[0]/(1.0 + uinit[1]*q);\n  u[1] = u[0] - d0;\n  u[2] = uinit[1] + uinit[2] - u[1];\n  ierr = VecRestoreArray(U,&u);CHKERRQ(ierr);\n  ierr = VecRestoreArrayRead(ctx->initialsolution,&uinit);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\nint main(int argc,char **argv)\n{\n  TS             ts;            /* ODE integrator */\n  Vec            U;             /* solution will be stored here */\n  Mat            A;             /* Jacobian matrix */\n  PetscErrorCode ierr;\n  PetscMPIInt    size;\n  PetscInt       n = 3;\n  AppCtx         ctx;\n  PetscScalar    *u;\n  const char     * const names[] = {\"U1\",\"U2\",\"U3\",NULL};\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Initialize program\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = PetscInitialize(&argc,&argv,(char*)0,help);if (ierr) return ierr;\n  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRQ(ierr);\n  if (size > 1) SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_SUP,\"Only for sequential runs\");\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Create necessary matrix and vectors\n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);\n  ierr = MatSetSizes(A,n,n,PETSC_DETERMINE,PETSC_DETERMINE);CHKERRQ(ierr);\n  ierr = MatSetFromOptions(A);CHKERRQ(ierr);\n  ierr = MatSetUp(A);CHKERRQ(ierr);\n\n  ierr = MatCreateVecs(A,&U,NULL);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Set runtime options\n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ctx.k = .9;\n  ierr  = PetscOptionsGetScalar(NULL,NULL,\"-k\",&ctx.k,NULL);CHKERRQ(ierr);\n  ierr  = VecDuplicate(U,&ctx.initialsolution);CHKERRQ(ierr);\n  ierr  = VecGetArray(ctx.initialsolution,&u);CHKERRQ(ierr);\n  u[0]  = 1;\n  u[1]  = .7;\n  u[2]  = 0;\n  ierr  = VecRestoreArray(ctx.initialsolution,&u);CHKERRQ(ierr);\n  ierr  = PetscOptionsGetVec(NULL,NULL,\"-initial\",ctx.initialsolution,NULL);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Create timestepping solver context\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSCreate(PETSC_COMM_WORLD,&ts);CHKERRQ(ierr);\n  ierr = TSSetProblemType(ts,TS_NONLINEAR);CHKERRQ(ierr);\n  ierr = TSSetType(ts,TSROSW);CHKERRQ(ierr);\n  ierr = TSSetIFunction(ts,NULL,(TSIFunction) IFunction,&ctx);CHKERRQ(ierr);\n  ierr = TSSetIJacobian(ts,A,A,(TSIJacobian)IJacobian,&ctx);CHKERRQ(ierr);\n  ierr = TSSetSolutionFunction(ts,(TSSolutionFunction)Solution,&ctx);CHKERRQ(ierr);\n\n  {\n    DM   dm;\n    void *ptr;\n    ierr = TSGetDM(ts,&dm);CHKERRQ(ierr);\n    ierr = PetscDLSym(NULL,\"IFunctionView\",&ptr);CHKERRQ(ierr);\n    ierr = PetscDLSym(NULL,\"IFunctionLoad\",&ptr);CHKERRQ(ierr);\n    ierr = DMTSSetIFunctionSerialize(dm,(PetscErrorCode (*)(void*,PetscViewer))IFunctionView,(PetscErrorCode (*)(void**,PetscViewer))IFunctionLoad);CHKERRQ(ierr);\n    ierr = DMTSSetIJacobianSerialize(dm,(PetscErrorCode (*)(void*,PetscViewer))IFunctionView,(PetscErrorCode (*)(void**,PetscViewer))IFunctionLoad);CHKERRQ(ierr);\n  }\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Set initial conditions\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = Solution(ts,0,U,&ctx);CHKERRQ(ierr);\n  ierr = TSSetSolution(ts,U);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Set solver options\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSSetTimeStep(ts,.001);CHKERRQ(ierr);\n  ierr = TSSetMaxSteps(ts,1000);CHKERRQ(ierr);\n  ierr = TSSetMaxTime(ts,20.0);CHKERRQ(ierr);\n  ierr = TSSetExactFinalTime(ts,TS_EXACTFINALTIME_STEPOVER);CHKERRQ(ierr);\n  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);\n  ierr = TSMonitorLGSetVariableNames(ts,names);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Solve nonlinear system\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSSolve(ts,U);CHKERRQ(ierr);\n\n  ierr = TSView(ts,PETSC_VIEWER_BINARY_WORLD);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Free work space.  All PETSc objects should be destroyed when they are no longer needed.\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = VecDestroy(&ctx.initialsolution);CHKERRQ(ierr);\n  ierr = MatDestroy(&A);CHKERRQ(ierr);\n  ierr = VecDestroy(&U);CHKERRQ(ierr);\n  ierr = TSDestroy(&ts);CHKERRQ(ierr);\n\n  ierr = PetscFinalize();\n  return ierr;\n}\n\n\n/*TEST\n\n   test:\n     args: -ts_view\n     requires: dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)\n\n   test:\n     suffix: 2\n     args: -ts_monitor_lg_error -ts_monitor_lg_solution  -ts_view\n     requires: x\n     output_file: output/ex1_1.out\n     requires: dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)\n\nTEST*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/advection-diffusion-reaction/ex1.c.html": "<center><a href=\"ex1.c\">Actual source code: ex1.c</a></center><br>\n\n<html>\n<head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/ts/examples/tutorials/advection-diffusion-reaction/ex1.c.html\" />\n<title></title>\n<meta name=\"generator\" content=\"c2html 0.9.4\">\n<meta name=\"date\" content=\"2019-11-22T20:09:40+00:00\">\n</head>\n\n<body bgcolor=\"#FFFFFF\">\n   <div id=\"version\" align=right><b>petsc-3.12.2 2019-11-22</b></div>\n   <div id=\"bugreport\" align=right><a href=\"mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.12.2 v3.12.2 src/ts/examples/tutorials/advection-diffusion-reaction/ex1.c.html \"><small>Report Typos and Errors</small></a></div>\n<pre width=\"80\">\n\n<a name=\"line2\">  2: </a>static char help[] = <font color=\"#666666\">\"Nonlinear Reaction Problem from Chemistry.\\n\"</font>;\n\n</pre><script type=\"text/x-mathjax-config\">\n                   MathJax.Hub.Config({\n                       tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n                   });\n                 </script>\n                 <script type=\"text/javascript\"\n                      src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n                 </script><BR>\n\n     This directory contains examples based on the PDES/ODES given in the book<BR>\n\n      Numerical Solution of Time-Dependent Advection-Diffusion-Reaction Equations by<BR>\n\n      W. Hundsdorf and J.G. Verwer<BR>\n\n<BR>\n\n     Page 3, Section 1.1 Nonlinear Reaction Problems from Chemistry<BR>\n\n<BR>\n\n\\begin{eqnarray}<BR>\n\n                 {U_1}_t  - k U_1 U_2  &amp; = &amp; 0 \\\\<BR>\n\n                 {U_2}_t  - k U_1 U_2 &amp; = &amp; 0 \\\\<BR>\n\n                 {U_3}_t  - k U_1 U_2 &amp; = &amp; 0<BR>\n\n\\end{eqnarray}<BR>\n\n<BR>\n\n     Helpful runtime monitoring options:<BR>\n\n         -ts_view                  -  prints information about the solver being used<BR>\n\n         -ts_monitor               -  prints the progess of the solver<BR>\n\n         -ts_adapt_monitor         -  prints the progress of the time-step adaptor<BR>\n\n         -ts_monitor_lg_timestep   -  plots the size of each timestep (at each time-step)<BR>\n\n         -ts_monitor_lg_solution   -  plots each component of the solution as a function of time (at each timestep)<BR>\n\n         -ts_monitor_lg_error      -  plots each component of the error in the solution as a function of time (at each timestep)<BR>\n\n         -draw_pause -2            -  hold the plots a the end of the solution process, enter a mouse press in each window to end the process<BR>\n\n<BR>\n\n         -ts_monitor_lg_timestep -1  -  plots the size of each timestep (at the end of the solution process)<BR>\n\n         -ts_monitor_lg_solution -1  -  plots each component of the solution as a function of time (at the end of the solution process)<BR>\n\n         -ts_monitor_lg_error -1     -  plots each component of the error in the solution as a function of time (at the end of the solution process)<BR>\n\n         -lg_use_markers false       -  do NOT show the data points on the plots<BR>\n\n         -draw_save                  -  save the timestep and solution plot as a .Gif image file<BR>\n\n<BR>\n\n<pre width=\"80\">\n<a name=\"line35\"> 35: </a><font color=\"#B22222\">/*</font>\n<a name=\"line36\"> 36: </a><font color=\"#B22222\">      Project: Generate a nicely formated HTML page using</font>\n<a name=\"line37\"> 37: </a><font color=\"#B22222\">         1) the HTML version of the source code and text in this file, use make html to generate the file ex1.c.html</font>\n<a name=\"line38\"> 38: </a><font color=\"#B22222\">         2) the images (Draw_XXX_0_0.Gif Draw_YYY_0_0.Gif Draw_ZZZ_1_0.Gif) and</font>\n<a name=\"line39\"> 39: </a><font color=\"#B22222\">         3) the text output (output.txt) generated by running the following commands.</font>\n<a name=\"line40\"> 40: </a><font color=\"#B22222\">         4) &lt;iframe src=\"generated_topics.html\" scrolling=\"no\" frameborder=\"0\"  width=600 height=300&gt;&lt;/iframe&gt;</font>\n\n<a name=\"line42\"> 42: </a><font color=\"#B22222\">      rm -rf *.Gif</font>\n<a name=\"line43\"> 43: </a><font color=\"#B22222\">      ./ex1 -ts_monitor_lg_error -1 -ts_monitor_lg_solution -1   -draw_pause -2 -ts_max_steps 100 -ts_monitor_lg_timestep -1 -draw_save -draw_virtual -ts_monitor -ts_adapt_monitor -ts_view  &gt; output.txt</font>\n\n<a name=\"line45\"> 45: </a><font color=\"#B22222\">      For example something like</font>\n<a name=\"line46\"> 46: </a><font color=\"#B22222\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;</font>\n<a name=\"line47\"> 47: </a><font color=\"#B22222\">&lt;html&gt;</font>\n<a name=\"line48\"> 48: </a><font color=\"#B22222\">  &lt;head&gt;</font>\n<a name=\"line49\"> 49: </a><font color=\"#B22222\">    &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;</font>\n<a name=\"line50\"> 50: </a><font color=\"#B22222\">    &lt;title&gt;PETSc Example -- Nonlinear Reaction Problem from Chemistry&lt;/title&gt;</font>\n<a name=\"line51\"> 51: </a><font color=\"#B22222\">  &lt;/head&gt;</font>\n<a name=\"line52\"> 52: </a><font color=\"#B22222\">  &lt;body&gt;</font>\n<a name=\"line53\"> 53: </a><font color=\"#B22222\">  &lt;iframe src=\"ex1.c.html\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=400&gt;&lt;/iframe&gt;</font>\n<a name=\"line54\"> 54: </a><font color=\"#B22222\">  &lt;img alt=\"\" src=\"Draw_0x84000000_0_0.Gif\"/&gt;&lt;img alt=\"\" src=\"Draw_0x84000001_0_0.Gif\"/&gt;&lt;img alt=\"\" src=\"Draw_0x84000001_1_0.Gif\"/&gt;</font>\n<a name=\"line55\"> 55: </a><font color=\"#B22222\">  &lt;iframe src=\"output.txt\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=1000&gt;&lt;/iframe&gt;</font>\n<a name=\"line56\"> 56: </a><font color=\"#B22222\">  &lt;/body&gt;</font>\n<a name=\"line57\"> 57: </a><font color=\"#B22222\">&lt;/html&gt;</font>\n\n<a name=\"line59\"> 59: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line61\"> 61: </a><font color=\"#B22222\">/*</font>\n<a name=\"line62\"> 62: </a><font color=\"#B22222\">   Include \"petscts.h\" so that we can use <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TS.html#TS\">TS</a> solvers.  Note that this</font>\n<a name=\"line63\"> 63: </a><font color=\"#B22222\">   file automatically includes:</font>\n<a name=\"line64\"> 64: </a><font color=\"#B22222\">     petscsys.h       - base PETSc routines   petscvec.h - vectors</font>\n<a name=\"line65\"> 65: </a><font color=\"#B22222\">     petscmat.h - matrices</font>\n<a name=\"line66\"> 66: </a><font color=\"#B22222\">     petscis.h     - index sets            petscksp.h - Krylov subspace methods</font>\n<a name=\"line67\"> 67: </a><font color=\"#B22222\">     petscviewer.h - viewers               petscpc.h  - preconditioners</font>\n<a name=\"line68\"> 68: </a><font color=\"#B22222\">     petscksp.h   - linear solvers</font>\n<a name=\"line69\"> 69: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line71\"> 71: </a><font color=\"#A020F0\">#include &lt;petscts.h&gt;</font>\n\n<a name=\"line73\"> 73: </a><font color=\"#4169E1\">typedef</font> <font color=\"#4169E1\">struct</font> {\n<a name=\"line74\"> 74: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a> k;\n<a name=\"line75\"> 75: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a>         initialsolution;\n<a name=\"line76\"> 76: </a>} AppCtx;\n\n<a name=\"line78\"> 78: </a><strong><font color=\"#4169E1\"><a name=\"IFunctionView\"></a><a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> IFunctionView(AppCtx *ctx,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a> v)</font></strong>\n<a name=\"line79\"> 79: </a>{\n\n<a name=\"line83\"> 83: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewerBinaryWrite.html#PetscViewerBinaryWrite\">PetscViewerBinaryWrite</a>(v,&amp;ctx-&gt;k,1,PETSC_SCALAR,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_FALSE.html#PETSC_FALSE\">PETSC_FALSE</a>);\n<a name=\"line84\"> 84: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line85\"> 85: </a>}\n\n<a name=\"line87\"> 87: </a><strong><font color=\"#4169E1\"><a name=\"IFunctionLoad\"></a><a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> IFunctionLoad(AppCtx **ctx,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a> v)</font></strong>\n<a name=\"line88\"> 88: </a>{\n\n<a name=\"line92\"> 92: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscNew.html#PetscNew\">PetscNew</a>(ctx);\n<a name=\"line93\"> 93: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewerBinaryRead.html#PetscViewerBinaryRead\">PetscViewerBinaryRead</a>(v,&amp;(*ctx)-&gt;k,1,NULL,PETSC_SCALAR);\n<a name=\"line94\"> 94: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line95\"> 95: </a>}\n\n<a name=\"line97\"> 97: </a><font color=\"#B22222\">/*</font>\n<a name=\"line98\"> 98: </a><font color=\"#B22222\">     Defines the ODE passed to the ODE solver</font>\n<a name=\"line99\"> 99: </a><font color=\"#B22222\">*/</font>\n<a name=\"line100\">100: </a><strong><font color=\"#4169E1\"><a name=\"IFunction\"></a><a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> IFunction(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TS.html#TS\">TS</a> ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscReal.html#PetscReal\">PetscReal</a> t,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> U,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> Udot,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> F,AppCtx *ctx)</font></strong>\n<a name=\"line101\">101: </a>{\n<a name=\"line102\">102: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>    ierr;\n<a name=\"line103\">103: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a>       *f;\n<a name=\"line104\">104: </a>  const <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a> *u,*udot;\n\n<a name=\"line107\">107: </a>  <font color=\"#B22222\">/*  The next three lines allow us to access the entries of the vectors directly */</font>\n<a name=\"line108\">108: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArrayRead.html#VecGetArrayRead\">VecGetArrayRead</a>(U,&amp;u);\n<a name=\"line109\">109: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArrayRead.html#VecGetArrayRead\">VecGetArrayRead</a>(Udot,&amp;udot);\n<a name=\"line110\">110: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArray.html#VecGetArray\">VecGetArray</a>(F,&amp;f);\n<a name=\"line111\">111: </a>  f[0] = udot[0] + ctx-&gt;k*u[0]*u[1];\n<a name=\"line112\">112: </a>  f[1] = udot[1] + ctx-&gt;k*u[0]*u[1];\n<a name=\"line113\">113: </a>  f[2] = udot[2] - ctx-&gt;k*u[0]*u[1];\n<a name=\"line114\">114: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArrayRead.html#VecRestoreArrayRead\">VecRestoreArrayRead</a>(U,&amp;u);\n<a name=\"line115\">115: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArrayRead.html#VecRestoreArrayRead\">VecRestoreArrayRead</a>(Udot,&amp;udot);\n<a name=\"line116\">116: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArray.html#VecRestoreArray\">VecRestoreArray</a>(F,&amp;f);\n<a name=\"line117\">117: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line118\">118: </a>}\n\n<a name=\"line120\">120: </a><font color=\"#B22222\">/*</font>\n<a name=\"line121\">121: </a><font color=\"#B22222\">     Defines the Jacobian of the ODE passed to the ODE solver. See <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetIJacobian.html#TSSetIJacobian\">TSSetIJacobian</a>() for the meaning of a and the Jacobian.</font>\n<a name=\"line122\">122: </a><font color=\"#B22222\">*/</font>\n<a name=\"line123\">123: </a><strong><font color=\"#4169E1\"><a name=\"IJacobian\"></a><a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> IJacobian(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TS.html#TS\">TS</a> ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscReal.html#PetscReal\">PetscReal</a> t,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> U,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> Udot,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscReal.html#PetscReal\">PetscReal</a> a,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/Mat.html#Mat\">Mat</a> A,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/Mat.html#Mat\">Mat</a> B,AppCtx *ctx)</font></strong>\n<a name=\"line124\">124: </a>{\n<a name=\"line125\">125: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>    ierr;\n<a name=\"line126\">126: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscInt.html#PetscInt\">PetscInt</a>          rowcol[] = {0,1,2};\n<a name=\"line127\">127: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a>       J[3][3];\n<a name=\"line128\">128: </a>  const <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a> *u,*udot;\n\n<a name=\"line131\">131: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArrayRead.html#VecGetArrayRead\">VecGetArrayRead</a>(U,&amp;u);\n<a name=\"line132\">132: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArrayRead.html#VecGetArrayRead\">VecGetArrayRead</a>(Udot,&amp;udot);\n<a name=\"line133\">133: </a>  J[0][0] = a + ctx-&gt;k*u[1];   J[0][1] = ctx-&gt;k*u[0];       J[0][2] = 0.0;\n<a name=\"line134\">134: </a>  J[1][0] = ctx-&gt;k*u[1];       J[1][1] = a + ctx-&gt;k*u[0];   J[1][2] = 0.0;\n<a name=\"line135\">135: </a>  J[2][0] = -ctx-&gt;k*u[1];      J[2][1] = -ctx-&gt;k*u[0];      J[2][2] = a;\n<a name=\"line136\">136: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatSetValues.html#MatSetValues\">MatSetValues</a>(B,3,rowcol,3,rowcol,&amp;J[0][0],<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/INSERT_VALUES.html#INSERT_VALUES\">INSERT_VALUES</a>);\n<a name=\"line137\">137: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArrayRead.html#VecRestoreArrayRead\">VecRestoreArrayRead</a>(U,&amp;u);\n<a name=\"line138\">138: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArrayRead.html#VecRestoreArrayRead\">VecRestoreArrayRead</a>(Udot,&amp;udot);\n\n<a name=\"line140\">140: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyBegin.html#MatAssemblyBegin\">MatAssemblyBegin</a>(A,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyType.html#MatAssemblyType\">MAT_FINAL_ASSEMBLY</a>);\n<a name=\"line141\">141: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyEnd.html#MatAssemblyEnd\">MatAssemblyEnd</a>(A,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyType.html#MatAssemblyType\">MAT_FINAL_ASSEMBLY</a>);\n<a name=\"line142\">142: </a>  <font color=\"#4169E1\">if</font> (A != B) {\n<a name=\"line143\">143: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyBegin.html#MatAssemblyBegin\">MatAssemblyBegin</a>(B,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyType.html#MatAssemblyType\">MAT_FINAL_ASSEMBLY</a>);\n<a name=\"line144\">144: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyEnd.html#MatAssemblyEnd\">MatAssemblyEnd</a>(B,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatAssemblyType.html#MatAssemblyType\">MAT_FINAL_ASSEMBLY</a>);\n<a name=\"line145\">145: </a>  }\n<a name=\"line146\">146: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line147\">147: </a>}\n\n<a name=\"line149\">149: </a><font color=\"#B22222\">/*</font>\n<a name=\"line150\">150: </a><font color=\"#B22222\">     Defines the exact (analytic) solution to the ODE</font>\n<a name=\"line151\">151: </a><font color=\"#B22222\">*/</font>\n<a name=\"line152\">152: </a><strong><font color=\"#4169E1\"><a name=\"Solution\"></a>static <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> Solution(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TS.html#TS\">TS</a> ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscReal.html#PetscReal\">PetscReal</a> t,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a> U,AppCtx *ctx)</font></strong>\n<a name=\"line153\">153: </a>{\n<a name=\"line154\">154: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a>    ierr;\n<a name=\"line155\">155: </a>  const <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a> *uinit;\n<a name=\"line156\">156: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a>       *u,d0,q;\n\n<a name=\"line159\">159: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArrayRead.html#VecGetArrayRead\">VecGetArrayRead</a>(ctx-&gt;initialsolution,&amp;uinit);\n<a name=\"line160\">160: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArray.html#VecGetArray\">VecGetArray</a>(U,&amp;u);\n<a name=\"line161\">161: </a>  d0   = uinit[0] - uinit[1];\n<a name=\"line162\">162: </a>  <font color=\"#4169E1\">if</font> (d0 == 0.0) q = ctx-&gt;k*t;\n<a name=\"line163\">163: </a>  <font color=\"#4169E1\">else</font> q = (1.0 - PetscExpScalar(-ctx-&gt;k*t*d0))/d0;\n<a name=\"line164\">164: </a>  u[0] = uinit[0]/(1.0 + uinit[1]*q);\n<a name=\"line165\">165: </a>  u[1] = u[0] - d0;\n<a name=\"line166\">166: </a>  u[2] = uinit[1] + uinit[2] - u[1];\n<a name=\"line167\">167: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArray.html#VecRestoreArray\">VecRestoreArray</a>(U,&amp;u);\n<a name=\"line168\">168: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArrayRead.html#VecRestoreArrayRead\">VecRestoreArrayRead</a>(ctx-&gt;initialsolution,&amp;uinit);\n<a name=\"line169\">169: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line170\">170: </a>}\n\n<a name=\"line172\">172: </a><strong><font color=\"#4169E1\"><a name=\"main\"></a>int main(int argc,char **argv)</font></strong>\n<a name=\"line173\">173: </a>{\n<a name=\"line174\">174: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TS.html#TS\">TS</a>             ts;            <font color=\"#B22222\">/* ODE integrator */</font>\n<a name=\"line175\">175: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/Vec.html#Vec\">Vec</a>            U;             <font color=\"#B22222\">/* solution will be stored here */</font>\n<a name=\"line176\">176: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/Mat.html#Mat\">Mat</a>            A;             <font color=\"#B22222\">/* Jacobian matrix */</font>\n<a name=\"line178\">178: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscMPIInt.html#PetscMPIInt\">PetscMPIInt</a>    size;\n<a name=\"line179\">179: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscInt.html#PetscInt\">PetscInt</a>       n = 3;\n<a name=\"line180\">180: </a>  AppCtx         ctx;\n<a name=\"line181\">181: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscScalar.html#PetscScalar\">PetscScalar</a>    *u;\n<a name=\"line182\">182: </a>  const char     * const names[] = {<font color=\"#666666\">\"U1\"</font>,<font color=\"#666666\">\"U2\"</font>,<font color=\"#666666\">\"U3\"</font>,NULL};\n\n<a name=\"line184\">184: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line185\">185: </a><font color=\"#B22222\">     Initialize program</font>\n<a name=\"line186\">186: </a><font color=\"#B22222\">     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line187\">187: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscInitialize.html#PetscInitialize\">PetscInitialize</a>(&amp;argc,&amp;argv,(char*)0,help);<font color=\"#4169E1\">if</font> (ierr) <font color=\"#4169E1\">return</font> ierr;\n<a name=\"line188\">188: </a>  <a href=\"http://www.mpich.org/static/docs/latest/www3/MPI_Comm_size.html#MPI_Comm_size\">MPI_Comm_size</a>(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_COMM_WORLD.html#PETSC_COMM_WORLD\">PETSC_COMM_WORLD</a>,&amp;size);\n<a name=\"line189\">189: </a>  <font color=\"#4169E1\">if</font> (size &gt; 1) <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</a>(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_COMM_WORLD.html#PETSC_COMM_WORLD\">PETSC_COMM_WORLD</a>,PETSC_ERR_SUP,<font color=\"#666666\">\"Only for sequential runs\"</font>);\n\n<a name=\"line191\">191: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line192\">192: </a><font color=\"#B22222\">    Create necessary matrix and vectors</font>\n<a name=\"line193\">193: </a><font color=\"#B22222\">    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line194\">194: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatCreate.html#MatCreate\">MatCreate</a>(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_COMM_WORLD.html#PETSC_COMM_WORLD\">PETSC_COMM_WORLD</a>,&amp;A);\n<a name=\"line195\">195: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatSetSizes.html#MatSetSizes\">MatSetSizes</a>(A,n,n,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_DETERMINE.html#PETSC_DETERMINE\">PETSC_DETERMINE</a>,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_DETERMINE.html#PETSC_DETERMINE\">PETSC_DETERMINE</a>);\n<a name=\"line196\">196: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatSetFromOptions.html#MatSetFromOptions\">MatSetFromOptions</a>(A);\n<a name=\"line197\">197: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatSetUp.html#MatSetUp\">MatSetUp</a>(A);\n\n<a name=\"line199\">199: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatCreateVecs.html#MatCreateVecs\">MatCreateVecs</a>(A,&amp;U,NULL);\n\n<a name=\"line201\">201: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line202\">202: </a><font color=\"#B22222\">    Set runtime options</font>\n<a name=\"line203\">203: </a><font color=\"#B22222\">    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line204\">204: </a>  ctx.k = .9;\n<a name=\"line205\">205: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscOptionsGetScalar.html#PetscOptionsGetScalar\">PetscOptionsGetScalar</a>(NULL,NULL,<font color=\"#666666\">\"-k\"</font>,&amp;ctx.k,NULL);\n<a name=\"line206\">206: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecDuplicate.html#VecDuplicate\">VecDuplicate</a>(U,&amp;ctx.initialsolution);\n<a name=\"line207\">207: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecGetArray.html#VecGetArray\">VecGetArray</a>(ctx.initialsolution,&amp;u);\n<a name=\"line208\">208: </a>  u[0]  = 1;\n<a name=\"line209\">209: </a>  u[1]  = .7;\n<a name=\"line210\">210: </a>  u[2]  = 0;\n<a name=\"line211\">211: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecRestoreArray.html#VecRestoreArray\">VecRestoreArray</a>(ctx.initialsolution,&amp;u);\n<a name=\"line212\">212: </a>  PetscOptionsGetVec(NULL,NULL,<font color=\"#666666\">\"-initial\"</font>,ctx.initialsolution,NULL);\n\n<a name=\"line214\">214: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line215\">215: </a><font color=\"#B22222\">     Create timestepping solver context</font>\n<a name=\"line216\">216: </a><font color=\"#B22222\">     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line217\">217: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSCreate.html#TSCreate\">TSCreate</a>(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PETSC_COMM_WORLD.html#PETSC_COMM_WORLD\">PETSC_COMM_WORLD</a>,&amp;ts);\n<a name=\"line218\">218: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetProblemType.html#TSSetProblemType\">TSSetProblemType</a>(ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSProblemType.html#TSProblemType\">TS_NONLINEAR</a>);\n<a name=\"line219\">219: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetType.html#TSSetType\">TSSetType</a>(ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSROSW.html#TSROSW\">TSROSW</a>);\n<a name=\"line220\">220: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetIFunction.html#TSSetIFunction\">TSSetIFunction</a>(ts,NULL,(TSIFunction) IFunction,&amp;ctx);\n<a name=\"line221\">221: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetIJacobian.html#TSSetIJacobian\">TSSetIJacobian</a>(ts,A,A,(TSIJacobian)IJacobian,&amp;ctx);\n<a name=\"line222\">222: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetSolutionFunction.html#TSSetSolutionFunction\">TSSetSolutionFunction</a>(ts,(TSSolutionFunction)Solution,&amp;ctx);\n\n<a name=\"line224\">224: </a>  {\n<a name=\"line225\">225: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/DM/DM.html#DM\">DM</a>   dm;\n<a name=\"line226\">226: </a>    void *ptr;\n<a name=\"line227\">227: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSGetDM.html#TSGetDM\">TSGetDM</a>(ts,&amp;dm);\n<a name=\"line228\">228: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a>(NULL,<font color=\"#666666\">\"IFunctionView\"</font>,&amp;ptr);\n<a name=\"line229\">229: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</a>(NULL,<font color=\"#666666\">\"IFunctionLoad\"</font>,&amp;ptr);\n<a name=\"line230\">230: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/DMTSSetIFunctionSerialize.html#DMTSSetIFunctionSerialize\">DMTSSetIFunctionSerialize</a>(dm,(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> (*)(void*,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a>))IFunctionView,(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> (*)(void**,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a>))IFunctionLoad);\n<a name=\"line231\">231: </a>    <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/DMTSSetIJacobianSerialize.html#DMTSSetIJacobianSerialize\">DMTSSetIJacobianSerialize</a>(dm,(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> (*)(void*,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a>))IFunctionView,(<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</a> (*)(void**,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PetscViewer.html#PetscViewer\">PetscViewer</a>))IFunctionLoad);\n<a name=\"line232\">232: </a>  }\n\n<a name=\"line234\">234: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line235\">235: </a><font color=\"#B22222\">     Set initial conditions</font>\n<a name=\"line236\">236: </a><font color=\"#B22222\">   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line237\">237: </a>  Solution(ts,0,U,&amp;ctx);\n<a name=\"line238\">238: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetSolution.html#TSSetSolution\">TSSetSolution</a>(ts,U);\n\n<a name=\"line240\">240: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line241\">241: </a><font color=\"#B22222\">     Set solver options</font>\n<a name=\"line242\">242: </a><font color=\"#B22222\">   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line243\">243: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetTimeStep.html#TSSetTimeStep\">TSSetTimeStep</a>(ts,.001);\n<a name=\"line244\">244: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetMaxSteps.html#TSSetMaxSteps\">TSSetMaxSteps</a>(ts,1000);\n<a name=\"line245\">245: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetMaxTime.html#TSSetMaxTime\">TSSetMaxTime</a>(ts,20.0);\n<a name=\"line246\">246: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetExactFinalTime.html#TSSetExactFinalTime\">TSSetExactFinalTime</a>(ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSExactFinalTimeOption.html#TSExactFinalTimeOption\">TS_EXACTFINALTIME_STEPOVER</a>);\n<a name=\"line247\">247: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSetFromOptions.html#TSSetFromOptions\">TSSetFromOptions</a>(ts);\n<a name=\"line248\">248: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSMonitorLGSetVariableNames.html#TSMonitorLGSetVariableNames\">TSMonitorLGSetVariableNames</a>(ts,names);\n\n<a name=\"line250\">250: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line251\">251: </a><font color=\"#B22222\">     Solve nonlinear system</font>\n<a name=\"line252\">252: </a><font color=\"#B22222\">     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line253\">253: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSSolve.html#TSSolve\">TSSolve</a>(ts,U);\n\n<a name=\"line255\">255: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSView.html#TSView\">TSView</a>(ts,<a href=\"../../../..-diffusion-reaction/../docs/manualpages/Viewer/PETSC_VIEWER_BINARY_WORLD.html#PETSC_VIEWER_BINARY_WORLD\">PETSC_VIEWER_BINARY_WORLD</a>);\n\n<a name=\"line257\">257: </a>  <font color=\"#B22222\">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</font>\n<a name=\"line258\">258: </a><font color=\"#B22222\">     Free work space.  All PETSc objects should be destroyed when they are no longer needed.</font>\n<a name=\"line259\">259: </a><font color=\"#B22222\">   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</font>\n<a name=\"line260\">260: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecDestroy.html#VecDestroy\">VecDestroy</a>(&amp;ctx.initialsolution);\n<a name=\"line261\">261: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Mat/MatDestroy.html#MatDestroy\">MatDestroy</a>(&amp;A);\n<a name=\"line262\">262: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Vec/VecDestroy.html#VecDestroy\">VecDestroy</a>(&amp;U);\n<a name=\"line263\">263: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/TS/TSDestroy.html#TSDestroy\">TSDestroy</a>(&amp;ts);\n\n<a name=\"line265\">265: </a>  <a href=\"../../../..-diffusion-reaction/../docs/manualpages/Sys/PetscFinalize.html#PetscFinalize\">PetscFinalize</a>();\n<a name=\"line266\">266: </a>  <font color=\"#4169E1\">return</font> ierr;\n<a name=\"line267\">267: </a>}\n\n\n<a name=\"line270\">270: </a><font color=\"#B22222\">/*TEST</font>\n\n<a name=\"line272\">272: </a><font color=\"#B22222\">   test:</font>\n<a name=\"line273\">273: </a><font color=\"#B22222\">     args: -ts_view</font>\n<a name=\"line274\">274: </a><font color=\"#B22222\">     requires: dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n\n<a name=\"line276\">276: </a><font color=\"#B22222\">   test:</font>\n<a name=\"line277\">277: </a><font color=\"#B22222\">     suffix: 2</font>\n<a name=\"line278\">278: </a><font color=\"#B22222\">     args: -ts_monitor_lg_error -ts_monitor_lg_solution  -ts_view</font>\n<a name=\"line279\">279: </a><font color=\"#B22222\">     requires: x</font>\n<a name=\"line280\">280: </a><font color=\"#B22222\">     output_file: output/ex1_1.out</font>\n<a name=\"line281\">281: </a><font color=\"#B22222\">     requires: dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n\n<a name=\"line283\">283: </a><font color=\"#B22222\">TEST*/</font>\n</pre>\n</body>\n\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/systems/Apple/iOS/examples/Basic/Default-568h@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ksp/ksp/impls/cg/stcg/stcg.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ksp/ksp/impls/cg/pipecgrr/pipecgrr.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ksp/ksp/examples/tutorials/data/ex35_mesh.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ksp/pc/impls/deflation/deflation.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/tao/bound/impls/bncg/bncg.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/sys/objects/pinit.c.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/dm/impls/moab/dmmbfem.cxx.html",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/dm/impls/moab/examples/tests/input/ex3_in.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/chem_meth_ethanol.inp",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/power_grid/PDF_eqs_power_grid.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/Ybus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/X.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/lib/petsc/bin/win32fe/win32fe.exe",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/lib/petsc/bin/win32fe/win32feutils.dll",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/saws/images/transition.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/saws/images/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/surfacesphere_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/barycentricallyrefinedcube.h5",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/square_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/square.med",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/FourSquareT-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/FourBrickTet-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary-32.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/2Dgrd.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/square_bin_physnames.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/simpleblock-100.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary-64.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/TwoQuads.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/grid_c.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/Rect-tri3.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/FourSquareQ-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/square_periodic_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/tut21.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/horse.ply.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/sevenside.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/sevenside-quad-15.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/annulus-20.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary.msh2",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/FourBrickHex-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/sevenside-quad.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary.msh4",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/FourSquareH-large.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/mesh-3d-box-innersphere_bin.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/squaremotor-30.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/hybrid_hexwedge.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/cylinder.med",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.h5",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/cube_5tets.cas",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/meshes/hybrid_hexwedge.msh",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/matrices/tiny_system_with_x0.mat",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/share/petsc/datafiles/matrices/tiny_system_with_x0_complex.mat",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/docs/intro.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/docs/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/docs/developers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.12.2-ffgc2zufbuhymuewxhfnulmlehayijf5/spack-src/docs/tao_manual.pdf"
    ],
    "total_files": 16469
}