{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/bin/julia/PETSc.jl": "#\n#   Allows the PETSc dynamic library to be used from Julia. (http::/julialang.org)\n#     PETSc must be configured with --with-shared-libraries\n#     You can build with or without MPI, but cannot run on more than one process\n#\n#  Load the PETSc dynamic library\n#\nPETSC_DIR = getenv(\"PETSC_DIR\");\nPETSC_ARCH = getenv(\"PETSC_ARCH\");\nif (length(PETSC_DIR) == 0)\n  disp(\"Must have environmental variable PETSC_DIR set\")\nend\nif (length(PETSC_ARCH) == 0)\n  disp(\"Must have environmental variable PETSC_ARCH set\")\nend\nlibpetsclocation = strcat(PETSC_DIR, \"/\", PETSC_ARCH, \"/lib/\", \"libpetsc\")\nlibpetsc = dlopen(libpetsclocation)\n\n# -------------------------------------\nfunction echodemo(filename)\n  f = open(filename)\n  h = readall(f)\n  close(f)\n  pos = 0\n  while (pos <= length(h))\n    (ex,pos)=parse(h,pos)\n    str = string(ex.args)\n    if _jl_have_color\n      print(\"\\033[1m\\033[30m\")\n    end\n    #  the next line doesn't work right for multiple line commands like for loops\n    println(str[2:strlen(str)-1])\n    if _jl_have_color\n      print(_jl_answer_color())\n      println(\" \") # force a color change, otherwise answer color is not used\n    end\n    e = eval(ex)\n    println(\" \")\n  end\nend\n\n# -------------------------------------\n\nPETSC_INSERT_VALUES = 1;\nPETSC_ADD_VALUES    = 2;\nPETSC_COPY_VALUES   = 0;\n\nPETSC_NORM_1         = 0;\nPETSC_NORM_2         = 1;\nPETSC_NORM_FROBENIUS = 2;\nPETSC_NORM_INFINITY  = 3;\nPETSC_NORM_MAX       = PETSC_NORM_INFINITY;\n\n\n# -------------------------------------\n#    These are the Julia interface methods for all the visible PETSc functions. Julia datatypes for PETSc objects simply contain the C pointer to the\n#    underlying PETSc object.\n#\n# -------------------------------------\nfunction PetscInitialize()\n  PetscInitialize([])\nend\n\nfunction PetscInitialize(args)\n  PetscInitialize(args,\"\",\"\")\nend\n\nfunction PetscInitialize(args,filename,help)\n  # argument list starts with program name\n  args = [\"julia\",args];\n  #\n  #   If the user forgot to PetscFinalize() we do it for them, before restarting PETSc\n  #\n  init = 0;\n  err = ccall(dlsym(libpetsc,:PetscInitialized),Int32,(Ptr{Int32},),&init);\n  if (init != 0)\n    gc() # call garbage collection to force all PETSc objects be destroy that are queued up for destruction\n    err = ccall(dlsym(libpetsc,:PetscFinalize),Int32,());if (err != 0) return err; end\n  end\n  arr = Array(ByteString, length(args))\n  for i = 1:length(args)\n    arr[i] = cstring(args[i])\n  end\n  ptrs = _jl_pre_exec(arr)\n  err = ccall(dlsym(libpetsc, :PetscInitializeNoPointers),Int32,(Int32,Ptr{Ptr{Uint8}},Ptr{Uint8},Ptr{Uint8}), length(ptrs), ptrs,cstring(filename),cstring(help));\n  return err\nend\n\nfunction PetscFinalize()\n  gc() # call garbage collection to force all PETSc objects be destroy that are queued up for destruction\n  return ccall(dlsym(libpetsc,:PetscFinalize),Int32,());\nend\n\nfunction PETSC_COMM_SELF()\n  comm = Array(Int64, 1)\n  err = ccall(dlsym(libpetsc, :PetscGetPETSC_COMM_SELF),Int32,(Ptr{Int64},),comm);\n  return comm[1]\nend\n\n# -------------------------------------\n#\nabstract PetscObject\n\nfunction PetscView(obj::PetscObject)\n  PetscView(obj,0)\nend\n\ntype PetscIS <: PetscObject\n  pobj::Int64\n  function PetscIS()\n    comm = PETSC_COMM_SELF();\n    is = Array(Int64,1)\n    err = ccall(dlsym(libpetsc, :ISCreate),Int32,(Int64,Ptr{Int64}),comm,is);if (err != 0) return err;end\n    is = new(is[1])\n    finalizer(is,PetscDestroy)\n    # does not seem to be called immediately when is is no longer visible, is it called later during garbage collection?\n    return is\n  end\nend\n\n  function PetscDestroy(is::PetscIS)\n    if (is.pobj != 0) then\n      err = ccall(dlsym(libpetsc, :ISDestroy),Int32,(Ptr{Int64},), &is.pobj);\n    end\n    is.pobj = 0\n    return 0\n  end\n\n  function PetscIS(indices::Array{Int64})\n    is = PetscIS()\n    err = ccall(dlsym(libpetsc, :ISSetType),Int32,(Int64,Ptr{Uint8}), is.pobj,cstring(\"general\"));\n    err = ccall(dlsym(libpetsc, :ISGeneralSetIndices),Int32,(Int64,Int32,Ptr{Int32},Int32),is.pobj,length(indices),convert(Array{Int32},indices),PETSC_COPY_VALUES)\n    return is\n  end\n\n  function PetscISSetType(vec::PetscIS,name)\n    err = ccall(dlsym(libpetsc, :ISSetType),Int32,(Int64,Ptr{Uint8}), vec.pobj,cstring(name));\n  end\n\n  function PetscView(obj::PetscIS,viewer)\n   err = ccall(dlsym(libpetsc, :ISView),Int32,(Int64,Int64),obj.pobj,0);\n  end\n\n  function PetscISGetSize(obj::PetscIS)\n    n = Array(Int32,1)\n    err = ccall(dlsym(libpetsc, :ISGetSize),Int32,(Int64,Ptr{Int32}), obj.pobj,n);\n    return n[1]\n  end\n\n  function PetscISGetIndices(obj::PetscIS)\n    len = PetscISGetSize(obj)\n    indices = Array(Int32,len);\n    err = ccall(dlsym(libpetsc,:ISGetIndicesCopy),Int32,(Int64,Ptr{Int32}),obj.pobj,indices);\n    indices = indices + 1\n    return indices\n  end\n\n# -------------------------------------\n#\ntype PetscVec <: PetscObject\n  pobj::Int64\n  function PetscVec()\n    comm = PETSC_COMM_SELF();\n    vec = Array(Int64,1)\n    err = ccall(dlsym(libpetsc, :VecCreate),Int32,(Int64,Ptr{Int64}),comm,vec);\n    vec = new(vec[1])\n    finalizer(vec,PetscDestroy)\n    # does not seem to be called immediately when vec is no longer visible, is it called later during garbage collection?\n    return vec\n  end\nend\n\n  function PetscDestroy(vec::PetscVec)\n    if (vec.pobj != 0)\n      err = ccall(dlsym(libpetsc, :VecDestroy),Int32,(Ptr{Int64},), &vec.pobj);\n    end\n    vec.pobj = 0\n  end\n\n  function PetscVecSetType(vec::PetscVec,name)\n    err = ccall(dlsym(libpetsc, :VecSetType),Int32,(Int64,Ptr{Uint8}), vec.pobj,cstring(name));\n  end\n\n  function PetscVec(array::Array{Float64})\n    vec = PetscVec()\n    err = ccall(dlsym(libpetsc, :VecSetType),Int32,(Int64,Ptr{Uint8}), vec.pobj,cstring(\"seq\"));\n    err = ccall(dlsym(libpetsc, :VecSetSizes),Int32,(Int64,Int32,Int32), vec.pobj,length(array),length(array));\n    # want a 32 bit int array so build it ourselves\n    idx = Array(Int32,length(array));\n    for i=1:length(array);  idx[i] = i-1;  end\n    err = ccall(dlsym(libpetsc, :VecSetValues), Int32,(Int64,Int32,Ptr{Int32},Ptr{Float64},Int32), vec.pobj,length(idx),idx,array,PETSC_INSERT_VALUES);\n    err = ccall(dlsym(libpetsc, :VecAssemblyBegin),Int32,(Int64,), vec.pobj);\n    err = ccall(dlsym(libpetsc, :VecAssemblyEnd),Int32,(Int64,), vec.pobj);\n    return vec\n  end\n\n  function PetscVecSetValues(vec::PetscVec,idx::Array{Int64},array::Array{Float64},flag::Int)\n    idx = idx - 1\n    err = ccall(dlsym(libpetsc, :VecSetValues), Int32,(Int64,Int32,Ptr{Int32},Ptr{Float64},Int32), vec.pobj,length(idx),convert(Array{Int32},idx),array,flag);\n    idx = idx + 1\n    return err\n  end\n  function PetscVecSetValues(vec::PetscVec,idx::Array{Int64},array::Array{Float64})\n    PetscVecSetValues(vec,idx,array,PETSC_INSERT_VALUES)\n  end\n  function PetscVecSetValues(vec::PetscVec,array::Array{Float64})\n    idx = Array(Int64,length(array))\n    for i=1:length(array);  idx[i] = i-1;  end\n    PetscVecSetValues(vec,idx,array,PETSC_INSERT_VALUES)\n  end\n\n  function PetscVecAssemblyBegin(obj::PetscVec)\n    err = ccall(dlsym(libpetsc, :VecAssemblyBegin),Int32,(Int64,), obj.pobj);\n  end\n\n  function PetscVecAssemblyEnd(obj::PetscVec)\n    err = ccall(dlsym(libpetsc, :VecAssemblyEnd),Int32,(Int64,), obj.pobj);\n  end\n\n  function PetscVecSetSizes(vec::PetscVec,n::Int,N::Int)\n    err = ccall(dlsym(libpetsc, :VecSetSizes),Int32,(Int64,Int32,Int32), vec.pobj,n,N);\n  end\n\n  function PetscView(obj::PetscVec,viewer)\n    err = ccall(dlsym(libpetsc, :VecView),Int32,(Int64,Int64),obj.pobj,0);\n  end\n\n  function PetscVecGetSize(obj::PetscVec)\n    n = Array(Int32,1)\n    err = ccall(dlsym(libpetsc, :VecGetSize),Int32,(Int64,Ptr{Int32}), obj.pobj,n);\n    return n[1]\n  end\n\n  function PetscVecNorm(obj::PetscVec,normtype::Int)\n    n = Array(Float64,1)\n    err = ccall(dlsym(libpetsc, :VecNorm),Int32,(Int64,Int32,Ptr{Int32}), obj.pobj,normtype, n);\n    return n[1]\n  end\n  function PetscVecNorm(obj::PetscVec)\n    return PetscVecNorm(obj,PETSC_NORM_2)\n  end\n\n# -------------------------------------\ntype PetscMat <: PetscObject\n  pobj::Int64\n  function PetscMat()\n    comm = PETSC_COMM_SELF();\n    vec = Array(Int64,1)\n    err = ccall(dlsym(libpetsc, :MatCreate),Int32,(Int64,Ptr{Int64}),comm,vec);\n    vec = new(vec[1])\n    finalizer(vec,PetscDestroy)\n    # does not seem to be called immediately when vec is no longer visible, is it called later during garbage collection?\n    return vec\n  end\nend\n\n  function PetscDestroy(vec::PetscMat)\n    if (vec.pobj != 0)\n      err = ccall(dlsym(libpetsc, :MatDestroy),Int32,(Ptr{Int64},), &vec.pobj);\n    end\n    vec.pobj = 0\n  end\n\n  function PetscMatSetType(vec::PetscMat,name)\n    err = ccall(dlsym(libpetsc, :MatSetType),Int32,(Int64,Ptr{Uint8}), vec.pobj,cstring(name));\n  end\n\n  function PetscSetUp(vec::PetscMat)\n    err = ccall(dlsym(libpetsc, :MatSetUp),Int32,(Int64,), vec.pobj);\n  end\n\n  PETSC_MAT_FLUSH_ASSEMBLY = 1;\n  PETSC_MAT_FINAL_ASSEMBLY = 0\n\n  function PetscMatSetValues(vec::PetscMat,idi::Array{Int64},idj::Array{Int64},array::Array{Float64},flag::Int)\n    idi = idi - 1\n    idj = idj - 1\n    err = ccall(dlsym(libpetsc, :MatSetValues), Int32,(Int64,Int32,Ptr{Int32},Int32,Ptr{Int32},Ptr{Float64},Int32), vec.pobj,length(idi),convert(Array{Int32},idi),length(idi),convert(Array{Int32},idj),array,flag);\n    idi = idi + 1\n    idj = idj + 1\n    return err\n  end\n\n  function PetscMatAssemblyBegin(obj::PetscMat,flg::Int)\n    err = ccall(dlsym(libpetsc, :MatAssemblyBegin),Int32,(Int64,Int32), obj.pobj,flg);\n  end\n  function PetscMatAssemblyBegin(obj::PetscMat)\n    return PetscMatAssemblyBegin(obj,PETSC_MAT_FINAL_ASSEMBLY);\n  end\n\n  function PetscMatAssemblyEnd(obj::PetscMat,flg::Int)\n    err = ccall(dlsym(libpetsc, :MatAssemblyEnd),Int32,(Int64,Int32), obj.pobj,flg);\n  end\n  function PetscMatAssemblyEnd(obj::PetscMat)\n    return PetscMatAssemblyEnd(obj,PETSC_MAT_FINAL_ASSEMBLY);\n  end\n\n  function PetscMatSetSizes(vec::PetscMat,m::Int,n::Int,M::Int,N::Int)\n    err = ccall(dlsym(libpetsc, :MatSetSizes),Int32,(Int64,Int32,Int32,Int32,Int32), vec.pobj,m,n,M,N);\n  end\n\n  function PetscView(obj::PetscMat,viewer)\n    err = ccall(dlsym(libpetsc, :MatView),Int32,(Int64,Int64),obj.pobj,0);\n  end\n\n  function PetscMatGetSize(obj::PetscMat)\n    m = Array(Int32,1)\n    n = Array(Int32,1)\n    err = ccall(dlsym(libpetsc, :MatGetSize),Int32,(Int64,Ptr{Int32},Ptr{Int32}), obj.pobj,m,n);\n    return (m[1],n[1])\n  end",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/config/PETSc/Configure.py": "import config.base\n\nimport os\nimport re\n\n# The sorted() builtin is not available with python-2.3\ntry: sorted\nexcept NameError:\n  def sorted(lst):\n    lst.sort()\n    return lst\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = 'PETSC'\n    self.substPrefix  = 'PETSC'\n    return\n\n  def __str2__(self):\n    desc = []\n    desc.append('xxx=========================================================================xxx')\n    if self.getMakeMacro('PETSC_BUILD_USING_CMAKE'):\n      build_type = 'cmake build'\n    else:\n      build_type = 'legacy build'\n    desc.append(' Configure stage complete. Now build PETSc libraries with (%s):' % build_type)\n    desc.append('   make PETSC_DIR='+self.petscdir.dir+' PETSC_ARCH='+self.arch.arch+' all')\n    desc.append(' or (experimental with python):')\n    desc.append('   PETSC_DIR='+self.petscdir.dir+' PETSC_ARCH='+self.arch.arch+' ./config/builder.py')\n    desc.append('xxx=========================================================================xxx')\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n    help.addArgument('PETSc',  '-prefix=<dir>',                  nargs.Arg(None, '', 'Specifiy location to install PETSc (eg. /usr/local)'))\n    help.addArgument('Windows','-with-windows-graphics=<bool>',   nargs.ArgBool(None, 1,'Enable check for Windows Graphics'))\n    help.addArgument('PETSc', '-with-default-arch=<bool>',        nargs.ArgBool(None, 1, 'Allow using the last configured arch without setting PETSC_ARCH'))\n    help.addArgument('PETSc','-with-single-library=<bool>',       nargs.ArgBool(None, 1,'Put all PETSc code into the single -lpetsc library'))\n    help.addArgument('PETSc', '-with-ios=<bool>',              nargs.ArgBool(None, 0, 'Build an iPhone/iPad version of PETSc library'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers  = framework.require('config.setCompilers',       self)\n    self.arch          = framework.require('PETSc.utilities.arch',      self.setCompilers)\n    self.petscdir      = framework.require('PETSc.utilities.petscdir',  self.setCompilers)\n    self.languages     = framework.require('PETSc.utilities.languages', self.setCompilers)\n    self.debugging     = framework.require('PETSc.utilities.debugging', self.setCompilers)\n    self.CHUD          = framework.require('PETSc.utilities.CHUD',      self)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.types         = framework.require('config.types',              self)\n    self.headers       = framework.require('config.headers',            self)\n    self.functions     = framework.require('config.functions',          self)\n    self.libraries     = framework.require('config.libraries',          self)\n    self.atomics       = framework.require('config.atomics',            self)\n    self.blasLapack    = framework.require('config.packages.BlasLapack',self)\n    if os.path.isdir(os.path.join('config', 'PETSc')):\n      for d in ['utilities', 'packages']:\n        for utility in os.listdir(os.path.join('config', 'PETSc', d)):\n          (utilityName, ext) = os.path.splitext(utility)\n          if not utilityName.startswith('.') and not utilityName.startswith('#') and ext == '.py' and not utilityName == '__init__':\n            utilityObj                    = self.framework.require('PETSc.'+d+'.'+utilityName, self)\n            utilityObj.headerPrefix       = self.headerPrefix\n            utilityObj.archProvider       = self.arch\n            utilityObj.languageProvider   = self.languages\n            utilityObj.installDirProvider = self.petscdir\n            setattr(self, utilityName.lower(), utilityObj)\n\n    for package in config.packages.all:\n      if not package == 'PETSc':\n        packageObj                    = framework.require('config.packages.'+package, self)\n        packageObj.archProvider       = self.arch\n        packageObj.languageProvider   = self.languages\n        packageObj.installDirProvider = self.petscdir\n        setattr(self, package.lower(), packageObj)\n    # Force blaslapack to depend on scalarType so precision is set before BlasLapack is built\n    framework.require('PETSc.utilities.scalarTypes', self.f2cblaslapack)\n    self.f2cblaslapack.precisionProvider = self.scalartypes\n    framework.require('PETSc.utilities.scalarTypes', self.blaslapack)\n    self.blaslapack.precisionProvider = self.scalartypes\n\n    self.compilers.headerPrefix  = self.headerPrefix\n    self.types.headerPrefix      = self.headerPrefix\n    self.headers.headerPrefix    = self.headerPrefix\n    self.functions.headerPrefix  = self.headerPrefix\n    self.libraries.headerPrefix  = self.headerPrefix\n    self.blaslapack.headerPrefix = self.headerPrefix\n    self.mpi.headerPrefix        = self.headerPrefix\n    headersC = map(lambda name: name+'.h', ['setjmp','dos', 'endian', 'fcntl', 'float', 'io', 'limits', 'malloc', 'pwd', 'search', 'strings',\n                                            'unistd', 'sys/sysinfo', 'machine/endian', 'sys/param', 'sys/procfs', 'sys/resource',\n                                            'sys/systeminfo', 'sys/times', 'sys/utsname','string', 'stdlib','memory',\n                                            'sys/socket','sys/wait','netinet/in','netdb','Direct','time','Ws2tcpip','sys/types',\n                                            'WindowsX', 'cxxabi','float','ieeefp','stdint','sched','pthread','mathimf'])\n    functions = ['access', '_access', 'clock', 'drand48', 'getcwd', '_getcwd', 'getdomainname', 'gethostname',\n                 'gettimeofday', 'getwd', 'memalign', 'memmove', 'mkstemp', 'popen', 'PXFGETARG', 'rand', 'getpagesize',\n                 'readlink', 'realpath',  'sigaction', 'signal', 'sigset', 'usleep', 'sleep', '_sleep', 'socket',\n                 'times', 'gethostbyname', 'uname','snprintf','_snprintf','lseek','_lseek','time','fork','stricmp',\n                 'strcasecmp', 'bzero', 'dlopen', 'dlsym', 'dlclose', 'dlerror','get_nprocs','sysctlbyname',\n                 '_intel_fast_memcpy','_intel_fast_memset']\n    libraries1 = [(['socket', 'nsl'], 'socket'), (['fpe'], 'handle_sigfpes')]\n    self.headers.headers.extend(headersC)\n    self.functions.functions.extend(functions)\n    self.libraries.libraries.extend(libraries1)\n\n    return\n\n  def DumpPkgconfig(self):\n    ''' Create a pkg-config file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig'))\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig','PETSc.pc'),'w')\n    if self.framework.argDB['prefix']:\n      installdir = self.framework.argDB['prefix']\n      fd.write('prefix='+installdir+'\\n')\n      fd.write('exec_prefix=${prefix}\\n')\n      fd.write('includedir=${prefix}/include\\n')\n      fd.write('libdir='+os.path.join(installdir,'lib')+'\\n')\n    else:\n      fd.write('prefix='+self.petscdir.dir+'\\n')\n      fd.write('exec_prefix=${prefix}\\n')\n      fd.write('includedir=${prefix}/include\\n')\n      fd.write('libdir='+os.path.join(self.petscdir.dir,self.arch.arch,'lib')+'\\n')\n\n    self.setCompilers.pushLanguage('C')\n    fd.write('ccompiler='+self.setCompilers.getCompiler()+'\\n')\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'C++'):\n      self.setCompilers.pushLanguage('C++')\n      fd.write('cxxcompiler='+self.setCompilers.getCompiler()+'\\n')\n      self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('fcompiler='+self.setCompilers.getCompiler()+'\\n')\n      self.setCompilers.popLanguage()\n    fd.write('blaslapacklibs='+self.libraries.toStringNoDupes(self.blaslapack.lib)+'\\n')\n\n    fd.write('\\n')\n    fd.write('Name: PETSc\\n')\n    fd.write('Description: Library to solve ODEs and algebraic equations\\n')\n    fd.write('Version: %s\\n' % self.petscdir.version)\n\n    fd.write('Cflags: '+self.allincludes+'\\n')\n\n    plibs = self.libraries.toStringNoDupes(['-L'+os.path.join(self.petscdir.dir,self.arch.arch,'lib'),' -lpetsc'])\n    if self.framework.argDB['prefix']:\n      fd.write('Libs: '+plibs.replace(os.path.join(self.petscdir.dir,self.arch.arch),self.framework.argDB['prefix'])+'\\n')\n    else:\n      fd.write('Libs: '+plibs+'\\n')\n    fd.write('Libs.private: '+' '.join(self.packagelibs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split(' ')))\n\n    fd.close()\n    return\n\n  def DumpModule(self):\n    ''' Create a module file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','modules')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','modules'))\n    if self.framework.argDB['prefix']:\n      installdir  = self.framework.argDB['prefix']\n      installarch = ''\n      installpath = os.path.join(installdir,'bin')\n      fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','modules',self.petscdir.version),'w')\n    else:\n      installdir  = self.petscdir.dir\n      installarch = self.arch.arch\n      installpath = os.path.join(installdir,installarch,'bin')+':'+os.path.join(installdir,'bin')\n      fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','modules',self.petscdir.version+'-'+self.arch.arch),'w')\n    fd.write('''\\\n#%%Module\n\nproc ModulesHelp { } {\n    puts stderr \"This module sets the path and environment variables for petsc-%s\"\n    puts stderr \"     see http://www.mcs.anl.gov/petsc/ for more information      \"\n    puts stderr \"\"\n}\nmodule-whatis \"PETSc - Portable, Extensible Toolkit for Scientific Computation\"\n\nset petsc_dir   %s\nset petsc_arch  %s\n\nsetenv PETSC_ARCH $petsc_arch\nsetenv PETSC_DIR $petsc_dir\nprepend-path PATH %s\n''' % (self.petscdir.version, installdir, installarch, installpath))\n    fd.close()\n    return\n\n  def Dump(self):\n    ''' Actually put the values into the configuration files '''\n    # eventually everything between -- should be gone\n#-----------------------------------------------------------------------------------------------------\n\n    # Sometimes we need C compiler, even if built with C++\n    self.setCompilers.pushLanguage('C')\n    self.addMakeMacro('CC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n\n    # C preprocessor values\n    self.addMakeMacro('CPP_FLAGS',self.setCompilers.CPPFLAGS+self.CHUD.CPPFLAGS)\n\n    # compiler values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    self.addMakeMacro('PCC',self.setCompilers.getCompiler())\n    self.addMakeMacro('PCC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n    # .o or .obj\n    self.addMakeMacro('CC_SUFFIX','o')\n\n    # executable linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    pcc_linker = self.setCompilers.getLinker()\n    self.addMakeMacro('PCC_LINKER',pcc_linker)\n    self.addMakeMacro('PCC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n    self.setCompilers.popLanguage()\n    # '' for Unix, .exe for Windows\n    self.addMakeMacro('CC_LINKER_SUFFIX','')\n\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      # need FPPFLAGS in config/setCompilers\n      self.addDefine('HAVE_FORTRAN','1')\n      self.addMakeMacro('FPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n      # compiler values\n      self.addMakeMacro('FC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n      # .o or .obj\n      self.addMakeMacro('FC_SUFFIX','o')\n\n      # executable linker values\n      self.setCompilers.pushLanguage('FC')\n      # Cannot have NAG f90 as the linker - so use pcc_linker as fc_linker\n      fc_linker = self.setCompilers.getLinker()\n      if config.setCompilers.Configure.isNAG(fc_linker):\n        self.addMakeMacro('FC_LINKER',pcc_linker)\n      else:\n        self.addMakeMacro('FC_LINKER',fc_linker)\n      self.addMakeMacro('FC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      # apple requires this shared library linker flag on SOME versions of the os\n      if self.setCompilers.getLinkerFlags().find('-Wl,-commons,use_dylibs') > -1:\n        self.addMakeMacro('DARWIN_COMMONS_USE_DYLIBS',' -Wl,-commons,use_dylibs ')\n      self.setCompilers.popLanguage()\n\n      # F90 Modules\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_FLAG', self.setCompilers.fortranModuleIncludeFlag)\n      else: # for non-f90 compilers like g77\n        self.addMakeMacro('FC_MODULE_FLAG', '-I')\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_OUTPUT_FLAG', self.setCompilers.fortranModuleOutputFlag)\n    else:\n      self.addMakeMacro('FC','')\n\n    if hasattr(self.compilers, 'CUDAC'):\n      self.setCompilers.pushLanguage('CUDA')\n      self.addMakeMacro('CUDAC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # shared library linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    # need to fix BuildSystem to collect these separately\n    self.addMakeMacro('SL_LINKER',self.setCompilers.getLinker())\n    self.addMakeMacro('SL_LINKER_FLAGS','${PCC_LINKER_FLAGS}')\n    self.setCompilers.popLanguage()\n    # One of 'a', 'so', 'lib', 'dll', 'dylib' (perhaps others also?) depending on the library generator and architecture\n    # Note: . is not included in this macro, consistent with AR_LIB_SUFFIX\n    if self.setCompilers.sharedLibraryExt == self.setCompilers.AR_LIB_SUFFIX:\n      self.addMakeMacro('SL_LINKER_SUFFIX', '')\n      self.addDefine('SLSUFFIX','\"\"')\n    else:\n      self.addMakeMacro('SL_LINKER_SUFFIX', self.setCompilers.sharedLibraryExt)\n      self.addDefine('SLSUFFIX','\"'+self.setCompilers.sharedLibraryExt+'\"')\n\n    self.addMakeMacro('SL_LINKER_LIBS','${PETSC_EXTERNAL_LIB_BASIC}')\n\n#-----------------------------------------------------------------------------------------------------\n\n    # CONLY or CPP. We should change the PETSc makefiles to do this better\n    if self.languages.clanguage == 'C': lang = 'CONLY'\n    else: lang = 'CXXONLY'\n    self.addMakeMacro('PETSC_LANGUAGE',lang)\n\n    # real or complex\n    self.addMakeMacro('PETSC_SCALAR',self.scalartypes.scalartype)\n    # double or float\n    self.addMakeMacro('PETSC_PRECISION',self.scalartypes.precision)\n\n    if self.framework.argDB['with-batch']:\n      self.addMakeMacro('PETSC_WITH_BATCH','1')\n\n    # Test for compiler-specific macros that need to be defined.\n    if self.setCompilers.isCrayVector('CC'):\n      self.addDefine('HAVE_CRAY_VECTOR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    if self.functions.haveFunction('gethostbyname') and self.functions.haveFunction('socket') and self.headers.haveHeader('netinet/in.h'):\n      self.addDefine('USE_SOCKET_VIEWER','1')\n      if self.checkCompile('#include <sys/socket.h>','setsockopt(0,SOL_SOCKET,SO_REUSEADDR,0,0)'):\n        self.addDefine('HAVE_SO_REUSEADDR','1')\n\n#-----------------------------------------------------------------------------------------------------\n    # print include and lib for makefiles\n    self.framework.packages.reverse()\n    includes = [os.path.join(self.petscdir.dir,'include'),os.path.join(self.petscdir.dir,self.arch.arch,'include')]\n    libs = []\n    for i in self.framework.packages:\n      if i.useddirectly:\n        self.addDefine('HAVE_'+i.PACKAGE.replace('-','_'), 1)  # ONLY list package if it is used directly by PETSc (and not only by another package)\n      if not isinstance(i.lib, list):\n        i.lib = [i.lib]\n      libs.extend(i.lib)\n      self.addMakeMacro(i.PACKAGE.replace('-','_')+'_LIB', self.libraries.toStringNoDupes(i.lib))\n      if hasattr(i,'include'):\n        if not isinstance(i.include,list):\n          i.include = [i.include]\n        includes.extend(i.include)\n        self.addMakeMacro(i.PACKAGE.replace('-','_')+'_INCLUDE',self.headers.toStringNoDupes(i.include))\n    self.packagelibs = libs\n    if self.framework.argDB['with-single-library']:\n      self.alllibs = self.libraries.toStringNoDupes(['-L'+os.path.join(self.petscdir.dir,self.arch.arch,'lib'),' -lpetsc']+libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split(' '))+self.CHUD.LIBS\n      self.addMakeMacro('PETSC_WITH_EXTERNAL_LIB',self.alllibs)\n    else:\n      self.alllibs = self.libraries.toStringNoDupes(['-L'+os.path.join(self.petscdir.dir,self.arch.arch,'lib'),'-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys']+libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split(' '))+self.CHUD.LIBS\n    self.addMakeMacro('PETSC_EXTERNAL_LIB_BASIC',self.libraries.toStringNoDupes(libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split(' '))+self.CHUD.LIBS)\n    self.PETSC_EXTERNAL_LIB_BASIC = self.libraries.toStringNoDupes(libs+self.libraries.math+self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split(' '))+self.CHUD.LIBS\n    self.allincludes = self.headers.toStringNoDupes(includes)\n    self.addMakeMacro('PETSC_CC_INCLUDES',self.allincludes)\n    self.PETSC_CC_INCLUDES = self.allincludes\n    if hasattr(self.compilers, 'FC'):\n      if self.compilers.fortranIsF90:\n        self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(includes,includes))\n      else:\n        self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(includes))\n\n    self.addMakeMacro('DESTDIR',self.installdir)\n    self.addDefine('LIB_DIR','\"'+os.path.join(self.installdir,'lib')+'\"')\n\n    if self.framework.argDB['with-single-library']:\n      # overrides the values set in conf/variables\n      self.addMakeMacro('LIBNAME','${INSTALL_LIB_DIR}/libpetsc.${AR_LIB_SUFFIX}')\n      self.addMakeMacro('SHLIBS','libpetsc')\n      self.addMakeMacro('PETSC_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_KSP_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TS_LIB_BASIC','-lpetsc')\n      self.addDefine('USE_SINGLE_LIBRARY', '1')\n      if self.sharedlibraries.useShared:\n        self.addMakeMacro('PETSC_SYS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n      else:\n        self.addMakeMacro('PETSC_SYS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${PETSC_WITH_EXTERNAL_LIB}')\n\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib'))\n\n    # add a makefile entry for configure options\n    self.addMakeMacro('CONFIGURE_OPTIONS', self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"'))\n    return\n\n  def dumpConfigInfo(self):\n    import time\n    fd = file(os.path.join(self.arch.arch,'include','petscconfiginfo.h'),'w')\n    fd.write('static const char *petscconfigureruntime = \"'+time.ctime(time.time())+'\";\\n')\n    fd.write('static const char *petscconfigureoptions = \"'+self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"')+'\";\\n')\n    fd.close()\n    return\n\n  def dumpMachineInfo(self):\n    import platform\n    import time\n    import script\n    def escape(s):\n      return s.replace('\"',r'\\\"').replace(r'\\ ',r'\\\\ ')\n    fd = file(os.path.join(self.arch.arch,'include','petscmachineinfo.h'),'w')\n    fd.write('static const char *petscmachineinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"-----------------------------------------\\\\n\\\"\\n')\n    fd.write('\\\"Libraries compiled on %s on %s \\\\n\\\"\\n' % (time.ctime(time.time()), platform.node()))\n    fd.write('\\\"Machine characteristics: %s\\\\n\\\"\\n' % (platform.platform()))\n    fd.write('\\\"Using PETSc directory: %s\\\\n\\\"\\n' % (escape(self.petscdir.dir)))\n    fd.write('\\\"Using PETSc arch: %s\\\\n\\\"\\n' % (escape(self.arch.arch)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C compiler: %s %s ${COPTFLAGS} ${CFLAGS}\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran compiler: %s %s ${FOPTFLAGS} ${FFLAGS} %s\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags()), escape(self.setCompilers.CPPFLAGS)))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerflagsinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"Using include paths: %s %s %s\\\\n\\\"\\n' % ('-I'+escape(os.path.join(self.petscdir.dir, self.arch.arch, 'include')), '-I'+escape(os.path.join(self.petscdir.dir, 'include')), escape(self.PETSC_CC_INCLUDES)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsclinkerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n      self.setCompilers.popLanguage()\n    if self.framework.argDB['with-single-library']:\n      petsclib = '-lpetsc'\n    else:\n      petsclib = '-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys'\n    fd.write('\\\"Using libraries: %s%s -L%s %s %s\\\\n\\\"\\n' % (escape(self.setCompilers.CSharedLinkerFlag), escape(os.path.join(self.petscdir.dir, self.arch.arch, 'lib')), escape(os.path.join(self.petscdir.dir, self.arch.arch, 'lib')), escape(petsclib), escape(self.PETSC_EXTERNAL_LIB_BASIC)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.close()\n    return\n\n  def dumpCMakeConfig(self):\n    '''\n    Writes configuration-specific values to ${PETSC_ARCH}/conf/PETScConfig.cmake.\n    This file is private to PETSc and should not be included by third parties\n    (a suitable file can be produced later by CMake, but this is not it).\n    '''\n    def cmakeset(fd,key,val=True):\n      if val == True: val = 'YES'\n      if val == False: val = 'NO'\n      fd.write('set (' + key + ' ' + val + ')\\n')\n    def ensurelist(a):\n      if isinstance(a,list):\n        return a\n      else:\n        return [a]\n    def libpath(lib):\n      'Returns a search path if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-L'): return lib[2:]\n      if lib.startswith('-R'): return lib[2:]\n      if lib.startswith('-Wl,-rpath,'):\n        # This case occurs when an external package needs a specific system library that is normally provided by the compiler.\n        # In other words, the -L path is builtin to the wrapper or compiler, here we provide it so that CMake can locate the\n        # corresponding library.\n        return lib[len('-Wl,-rpath,'):]\n      if lib.startswith('-'): return ''\n      return os.path.dirname(lib)\n    def cleanlib(lib):\n      'Returns a library name if that is what this item provides, else \"\" which will be cleaned out later'\n      if not isinstance(lib,str): return ''\n      if lib.startswith('-l'):  return lib[2:]\n      if lib.startswith('-Wl') or lib.startswith('-L'): return ''\n      lib = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): return lib[3:]\n      return lib\n    def nub(lst):\n      'Return a list containing the first occurrence of each unique element'\n      unique = []\n      for elem in lst:\n        if elem not in unique and elem != '':\n          unique.append(elem)\n      return unique\n    try: reversed # reversed was added in Python-2.4\n    except NameError:\n      def reversed(lst): return lst[::-1]\n    def nublast(lst):\n      'Return a list containing the last occurrence of each unique entry in a list'\n      return reversed(nub(reversed(lst)))\n    def cmakeexpand(varname):\n      return r'\"${' + varname + r'}\"'\n    def uniqextend(lst,new):\n      for x in ensurelist(new):\n        if x not in lst:\n          lst.append(x)\n    def notstandardinclude(path):\n      return path not in '/usr/include'.split() # /usr/local/include is not automatically included on FreeBSD\n    def writeMacroDefinitions(fd):\n      if self.mpi.usingMPIUni:\n        cmakeset(fd,'PETSC_HAVE_MPIUNI')\n      for pkg in self.framework.packages:\n        if pkg.useddirectly:\n          cmakeset(fd,'PETSC_HAVE_' + pkg.PACKAGE.replace('-','_'))\n        for pair in pkg.defines.items():\n          if pair[0].startswith('HAVE_') and pair[1]:\n            cmakeset(fd, self.framework.getFullDefineName(pkg, pair[0]), pair[1])\n      for name,val in self.functions.defines.items():\n        cmakeset(fd,'PETSC_'+name,val)\n      for dct in [self.defines, self.libraryoptions.defines]:\n        for k,v in dct.items():\n          if k.startswith('USE_'):\n            cmakeset(fd,'PETSC_' + k, v)\n      cmakeset(fd,'PETSC_USE_COMPLEX', self.scalartypes.scalartype == 'complex')\n      cmakeset(fd,'PETSC_USE_REAL_' + self.scalartypes.precision.upper())\n      cmakeset(fd,'PETSC_CLANGUAGE_'+self.languages.clanguage)\n      if hasattr(self.compilers, 'FC'):\n        cmakeset(fd,'PETSC_HAVE_FORTRAN')\n        if self.compilers.fortranIsF90:\n          cmakeset(fd,'PETSC_USING_F90')\n        if self.compilers.fortranIsF2003:\n          cmakeset(fd,'PETSC_USING_F2003')\n      if hasattr(self.compilers, 'CXX'):\n        cmakeset(fd,'PETSC_HAVE_CXX')\n      if self.sharedlibraries.useShared:\n        cmakeset(fd,'BUILD_SHARED_LIBS')\n    def writeBuildFlags(fd):\n      def extendby(lib):\n        libs = ensurelist(lib)\n        lib_paths.extend(map(libpath,libs))\n        lib_libs.extend(map(cleanlib,libs))\n      lib_paths = []\n      lib_libs  = []\n      includes  = []\n      libvars   = []\n      for pkg in self.framework.packages:\n        extendby(pkg.lib)\n        uniqextend(includes,pkg.include)\n      extendby(self.libraries.math)\n      extendby(self.libraries.rt)\n      extendby(self.compilers.flibs)\n      extendby(self.compilers.cxxlibs)\n      extendby(self.compilers.LIBS.split())\n      for libname in nublast(lib_libs):\n        libvar = 'PETSC_' + libname.upper() + '_LIB'\n        addpath = ''\n        for lpath in nublast(lib_paths):\n          addpath += '\"' + str(lpath) + '\" '\n        fd.write('find_library (' + libvar + ' ' + libname + ' HINTS ' + addpath + ')\\n')\n        libvars.append(libvar)\n      fd.write('mark_as_advanced (' + ' '.join(libvars) + ')\\n')\n      fd.write('set (PETSC_PACKAGE_LIBS ' + ' '.join(map(cmakeexpand,libvars)) + ')\\n')\n      includes = filter(notstandardinclude,includes)\n      fd.write('set (PETSC_PACKAGE_INCLUDES ' + ' '.join(map(lambda i: '\"'+i+'\"',includes)) + ')\\n')\n    fd = open(os.path.join(self.arch.arch,'conf','PETScConfig.cmake'), 'w')\n    writeMacroDefinitions(fd)\n    writeBuildFlags(fd)\n    fd.close()\n    return\n\n  def dumpCMakeLists(self):\n    import sys\n    if sys.version_info >= (2,4):\n      import cmakegen\n      try:\n        cmakegen.main(self.petscdir.dir, log=self.framework.log)\n      except (OSError), e:\n        self.framework.logPrint('Generating CMakeLists.txt failed:\\n' + str(e))\n    else:\n      self.framework.logPrint('Skipping cmakegen due to old python version: ' +str(sys.version_info) )\n\n  def cmakeBoot(self):\n    import sys\n    self.cmakeboot_success = False\n    if sys.version_info >= (2,4) and hasattr(self.cmake,'cmake'):\n      try:\n        import cmakeboot\n        self.cmakeboot_success = cmakeboot.main(petscdir=self.petscdir.dir,petscarch=self.arch.arch,argDB=self.argDB,framework=self.framework,log=self.framework.log)\n      except (OSError), e:\n        self.framework.logPrint('Booting CMake in PETSC_ARCH failed:\\n' + str(e))\n      except (ImportError, KeyError), e:\n        self.framework.logPrint('Importing cmakeboot failed:\\n' + str(e))\n      if self.cmakeboot_success:\n        if hasattr(self.compilers, 'FC') and self.compilers.fortranIsF90 and not self.setCompilers.fortranModuleOutputFlag:\n          self.framework.logPrint('CMake configured successfully, but could not be used by default because of missing fortranModuleOutputFlag\\n')\n        else:\n          self.framework.logPrint('CMake configured successfully, using as default build\\n')\n          self.addMakeMacro('PETSC_BUILD_USING_CMAKE',1)\n      else:\n        self.framework.logPrint('CMake configuration was unsuccessful\\n')\n    else:\n      self.framework.logPrint('Skipping cmakeboot due to old python version: ' +str(sys.version_info) )\n    return\n\n  def configurePrefetch(self):\n    '''Sees if there are any prefetch functions supported'''\n    if config.setCompilers.Configure.isSolaris() or self.framework.argDB['with-ios']:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch((const char*)v,_MM_HINT_NTA);\\n'):\n      # The Intel Intrinsics manual [1] specifies the prototype\n      #\n      #   void _mm_prefetch(char const *a, int sel);\n      #\n      # but other vendors seem to insist on using subtly different\n      # prototypes, including void* for the pointer, and an enum for\n      # sel.  These are both reasonable changes, but negatively impact\n      # portability.\n      #\n      # [1] http://software.intel.com/file/6373\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const char*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch(v,_MM_HINT_NTA);\\n'):\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const void*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('', 'void *v = 0;__builtin_prefetch(v,0,0);\\n'):\n      # From GCC docs: void __builtin_prefetch(const void *addr,int rw,int locality)\n      #\n      #   The value of rw is a compile-time constant one or zero; one\n      #   means that the prefetch is preparing for a write to the memory\n      #   address and zero, the default, means that the prefetch is\n      #   preparing for a read. The value locality must be a compile-time\n      #   constant integer between zero and three. A value of zero means\n      #   that the data has no temporal locality, so it need not be left\n      #   in the cache after the access. A value of three means that the\n      #   data has a high degree of temporal locality and should be left\n      #   in all levels of cache possible. Values of one and two mean,\n      #   respectively, a low or moderate degree of temporal locality.\n      #\n      # Here we adopt Intel's x86/x86-64 naming scheme for the locality\n      # hints.  Using macros for these values in necessary since some\n      # compilers require an enum.\n      self.addDefine('Prefetch(a,b,c)', '__builtin_prefetch((a),(b),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '0')\n      self.addDefine('PREFETCH_HINT_T0',  '3')\n      self.addDefine('PREFETCH_HINT_T1',  '2')\n      self.addDefine('PREFETCH_HINT_T2',  '1')\n    else:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n    self.popLanguage()\n\n  def configureFeatureTestMacros(self):\n    '''Checks if certain feature test macros are support'''\n    if self.checkCompile('#define _POSIX_C_SOURCE 200112L\\n#include <sysctl.h>',''):\n       self.addDefine('_POSIX_C_SOURCE_200112L', '1')\n    if self.checkCompile('#define _BSD_SOURCE\\n#include<stdlib.h>',''):\n       self.addDefine('_BSD_SOURCE', '1')\n    if self.checkCompile('#define _GNU_SOURCE\\n#include <sched.h>','cpu_set_t mset;\\nCPU_ZERO(&mset);'):\n       self.addDefine('_GNU_SOURCE', '1')\n\n  def configureAtoll(self):\n    '''Checks if atoll exists'''\n    if self.checkLink('#define _POSIX_C_SOURCE 200112L\\n#include <stdlib.h>','long v = atoll(\"25\")') or self.checkLink ('#include <stdlib.h>','long v = atoll(\"25\")'):\n       self.addDefine('HAVE_ATOLL', '1')\n\n  def configureUnused(self):\n    '''Sees if __attribute((unused)) is supported'''\n    if self.framework.argDB['with-ios']:\n      self.addDefine('UNUSED', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('__attribute((unused)) static int myfunc(__attribute((unused)) void *name){ return 1;}', 'int i = 0;\\nint j = myfunc(&i);\\ntypedef void* atype;\\n__attribute((unused))  atype a;\\n'):\n      self.addDefine('UNUSED', '__attribute((unused))')\n    else:\n      self.addDefine('UNUSED', ' ')\n    self.popLanguage()\n\n  def configureDeprecated(self):\n    '''Check if __attribute((deprecated)) is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    ## Recent versions of gcc and clang support __attribute((deprecated(\"string argument\"))), which is very useful, but\n    ## Intel has conspired to make a supremely environment-sensitive compiler.  The Intel compiler looks at the gcc\n    ## executable in the environment to determine the language compatibility that it should attempt to emulate.  Some\n    ## important Cray installations have built PETSc using the Intel compiler, but with a newer gcc module loaded (e.g.,\n    ## 4.7).  Thus at PETSc configure time, the Intel compiler decides to support the string argument, but the the gcc\n    ## found in the default user environment is older and does not support the argument.  If GCC and Intel were cool\n    ## like Clang and supported __has_attribute, we could avoid configure tests entirely, but they don't.  And that is\n    ## why we can't have nice things.\n    #\n    # if self.checkCompile(\"\"\"__attribute((deprecated(\"Why you shouldn't use myfunc\"))) static int myfunc(void) { return 1;}\"\"\", ''):\n    #   self.addDefine('DEPRECATED(why)', '__attribute((deprecated(why)))')\n    if self.checkCompile(\"\"\"__attribute((deprecated)) static int myfunc(void) { return 1;}\"\"\", ''):\n      self.addDefine('DEPRECATED(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED(why)', ' ')\n    self.popLanguage()\n\n  def configureExpect(self):\n    '''Sees if the __builtin_expect directive is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('', 'if (__builtin_expect(0,1)) return 1;'):\n      self.addDefine('HAVE_BUILTIN_EXPECT', 1)\n    self.popLanguage()\n\n  def configureFunctionName(self):\n    '''Sees if the compiler supports __func__ or a variant.  Falls back\n    on __FUNCT__ which PETSc source defines, but most users do not, thus\n    stack traces through user code are better when the compiler's\n    variant is used.'''\n    def getFunctionName(lang):\n      name = '__FUNCT__'\n      self.pushLanguage(lang)\n      if self.checkLink('', \"if (__func__[0] != 'm') return 1;\"):\n        name = '__func__'\n      elif self.checkLink('', \"if (__FUNCTION__[0] != 'm') return 1;\"):\n        name = '__FUNCTION__'\n      self.popLanguage()\n      return name\n    langs = []\n\n    self.addDefine('FUNCTION_NAME_C', getFunctionName('C'))\n    if hasattr(self.compilers, 'CXX'):\n      self.addDefine('FUNCTION_NAME_CXX', getFunctionName('Cxx'))\n    else:\n      self.addDefine('FUNCTION_NAME_CXX', '__FUNCT__')\n\n  def configureIntptrt(self):\n    '''Determine what to use for uintptr_t'''\n    def staticAssertSizeMatchesVoidStar(inc,typename):\n      # The declaration is an error if either array size is negative.\n      # It should be okay to use an int that is too large, but it would be very unlikely for this to be the case\n      return self.checkCompile(inc, ('#define STATIC_ASSERT(cond) char negative_length_if_false[2*(!!(cond))-1]\\n'\n                                     + 'STATIC_ASSERT(sizeof(void*) == sizeof(%s));'%typename))\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile('#include <stdint.h>', 'int x; uintptr_t i = (uintptr_t)&x;'):\n      self.addDefine('UINTPTR_T', 'uintptr_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long long'):\n      self.addDefine('UINTPTR_T', 'unsigned long long')\n    elif staticAssertSizeMatchesVoidStar('#include <stdlib.h>','size_t') or staticAssertSizeMatchesVoidStar('#include <string.h>', 'size_t'):\n      self.addDefine('UINTPTR_T', 'size_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long'):\n      self.addDefine('UINTPTR_T', 'unsigned long')\n    elif staticAssertSizeMatchesVoidStar('','unsigned'):\n      self.addDefine('UINTPTR_T', 'unsigned')\n    else:\n      raise RuntimeError('Could not find any unsigned integer type matching void*')\n    self.popLanguage()\n\n  def configureRTLDDefault(self):\n    if self.checkCompile('#include <dlfcn.h>\\n void *ptr =  RTLD_DEFAULT;'):\n      self.addDefine('RTLD_DEFAULT','1')\n    return\n\n  def configureSolaris(self):\n    '''Solaris specific stuff'''\n    if os.path.isdir(os.path.join('/usr','ucblib')):\n      try:\n        flag = getattr(self.setCompilers, self.language[-1]+'SharedLinkerFlag')\n      except AttributeError:\n        flag = None\n      if flag is None:\n        self.compilers.LIBS += ' -L/usr/ucblib'\n      else:\n        self.compilers.LIBS += ' '+flag+'/usr/ucblib'\n    return\n\n  def configureLinux(self):\n    '''Linux specific stuff'''\n    # TODO: Test for this by mallocing an odd number of floats and checking the address\n    self.addDefine('HAVE_DOUBLE_ALIGN_MALLOC', 1)\n    return\n\n  def configureWin32(self):\n    '''Win32 non-cygwin specific stuff'''\n    kernel32=0\n    if self.libraries.add('Kernel32.lib','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    elif self.libraries.add('kernel32','GetComputerName',prototype='#include <Windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    if kernel32:\n      if self.framework.argDB['with-windows-graphics']:\n        self.addDefine('USE_WINDOWS_GRAPHICS',1)\n      if self.checkLink('#include <Windows.h>','LoadLibrary(0)'):\n        self.addDefine('HAVE_LOADLIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetProcAddress(0,0)'):\n        self.addDefine('HAVE_GETPROCADDRESS',1)\n      if self.checkLink('#include <Windows.h>','FreeLibrary(0)'):\n        self.addDefine('HAVE_FREELIBRARY',1)\n      if self.checkLink('#include <Windows.h>','GetLastError()'):\n        self.addDefine('HAVE_GETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>','SetLastError(0)'):\n        self.addDefine('HAVE_SETLASTERROR',1)\n      if self.checkLink('#include <Windows.h>\\n','QueryPerformanceCounter(0);\\n'):\n        self.addDefine('USE_MICROSOFT_TIME',1)\n    if self.libraries.add('Advapi32.lib','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n    elif self.libraries.add('advapi32','GetUserName',prototype='#include <Windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n\n    if not self.libraries.add('User32.lib','GetDC',prototype='#include <Windows.h>',call='GetDC(0);'):\n      self.libraries.add('user32','GetDC',prototype='#include <Windows.h>',call='GetDC(0);')\n    if not self.libraries.add('Gdi32.lib','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);'):\n      self.libraries.add('gdi32','CreateCompatibleDC',prototype='#include <Windows.h>',call='CreateCompatibleDC(0);')\n\n    self.types.check('int32_t', 'int')\n    if not self.checkCompile('#include <sys/types.h>\\n','uid_t u;\\n'):\n      self.addTypedef('int', 'uid_t')\n      self.addTypedef('int', 'gid_t')\n    if not self.checkLink('#if defined(PETSC_HAVE_UNISTD_H)\\n#include <unistd.h>\\n#endif\\n','int a=R_OK;\\n'):\n      self.framework.addDefine('R_OK', '04')\n      self.framework.addDefine('W_OK', '02')\n      self.framework.addDefine('X_OK', '01')\n    if not self.checkLink('#include <sys/stat.h>\\n','int a=0;\\nif (S_ISDIR(a)){}\\n'):\n      self.framework.addDefine('S_ISREG(a)', '(((a)&_S_IFMT) == _S_IFREG)')\n      self.framework.addDefine('S_ISDIR(a)', '(((a)&_S_IFMT) == _S_IFDIR)')\n    if self.checkCompile('#include <Windows.h>\\n','LARGE_INTEGER a;\\nDWORD b=a.u.HighPart;\\n'):\n      self.addDefine('HAVE_LARGE_INTEGER_U',1)\n\n    # Windows requires a Binary file creation flag when creating/opening binary files.  Is a better test in order?\n    if self.checkCompile('#include <Windows.h>\\n#include <fcntl.h>\\n', 'int flags = O_BINARY;'):\n      self.addDefine('HAVE_O_BINARY',1)\n\n    if self.compilers.CC.find('win32fe') >= 0:\n      self.addDefine('PATH_SEPARATOR','\\';\\'')\n      self.addDefine('DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('CANNOT_START_DEBUGGER',1)\n    else:\n      self.addDefine('PATH_SEPARATOR','\\':\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('DIR_SEPARATOR','\\'/\\'')\n\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureDefaultArch(self):\n    conffile = os.path.join('conf', 'petscvariables')\n    if self.framework.argDB['with-default-arch']:\n      fd = file(conffile, 'w')\n      fd.write('PETSC_ARCH='+self.arch.arch+'\\n')\n      fd.write('PETSC_DIR='+self.petscdir.dir+'\\n')\n      fd.write('include '+os.path.join(self.petscdir.dir,self.arch.arch,'conf','petscvariables')+'\\n')\n      fd.close()\n      self.framework.actions.addArgument('PETSc', 'Build', 'Set default architecture to '+self.arch.arch+' in '+conffile)\n    elif os.path.isfile(conffile):\n      try:\n        os.unlink(conffile)\n      except:\n        raise RuntimeError('Unable to remove file '+conffile+'. Did a different user create it?')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureScript(self):\n    '''Output a script in the conf directory which will reproduce the configuration'''\n    import nargs\n    import sys\n    scriptName = os.path.join(self.arch.arch,'conf', 'reconfigure-'+self.arch.arch+'.py')\n    args = dict([(nargs.Arg.parseArgument(arg)[0], arg) for arg in self.framework.clArgs])\n    if 'configModules' in args:\n      if nargs.Arg.parseArgument(args['configModules'])[1] == 'PETSc.Configure':\n        del args['configModules']\n    if 'optionsModule' in args:\n      if nargs.Arg.parseArgument(args['optionsModule'])[1] == 'PETSc.compilerOptions':\n        del args['optionsModule']\n    if not 'PETSC_ARCH' in args:\n      args['PETSC_ARCH'] = 'PETSC_ARCH='+str(self.arch.arch)\n    f = file(scriptName, 'w')\n    f.write('#!'+sys.executable+'\\n')\n    f.write('if __name__ == \\'__main__\\':\\n')\n    f.write('  import sys\\n')\n    f.write('  import os\\n')\n    f.write('  sys.path.insert(0, os.path.abspath(\\'config\\'))\\n')\n    f.write('  import configure\\n')\n    # pretty print repr(args.values())\n    f.write('  configure_options = [\\n')\n    for itm in sorted(args.values()):\n      f.write('    \\''+str(itm)+'\\',\\n')\n    f.write('  ]\\n')\n    f.write('  configure.petsc_configure(configure_options)\\n')\n    f.close()\n    try:\n      os.chmod(scriptName, 0775)\n    except OSError, e:\n      self.framework.logPrint('Unable to make reconfigure script executable:\\n'+str(e))\n    self.framework.actions.addArgument('PETSc', 'File creation', 'Created '+scriptName+' for automatic reconfiguration')\n    return\n\n  def configureInstall(self):\n    '''Setup the directories for installation'''\n    if self.framework.argDB['prefix']:\n      self.installdir = self.framework.argDB['prefix']\n      self.addMakeRule('shared_install','',['-@echo \"Now to install the libraries do:\"',\\\n                                              '-@echo \"make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} install\"',\\\n                                              '-@echo \"=========================================\"'])\n    else:\n      self.installdir = os.path.join(self.petscdir.dir,self.arch.arch)\n      self.addMakeRule('shared_install','',['-@echo \"Now to check if the libraries are working do:\"',\\\n                                              '-@echo \"make PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} test\"',\\\n                                              '-@echo \"=========================================\"'])\n      return\n\n  def configureGCOV(self):\n    if self.framework.argDB['with-gcov']:\n      self.addDefine('USE_GCOV','1')\n    return\n\n  def configureFortranFlush(self):\n    if hasattr(self.compilers, 'FC'):\n      for baseName in ['flush','flush_']:\n        if self.libraries.check('', baseName, otherLibs = self.compilers.flibs, fortranMangle = 1):\n          self.addDefine('HAVE_'+baseName.upper(), 1)\n          return\n\n  def postProcessPackages(self):\n    postPackages=[]\n    for i in self.framework.packages:\n      if hasattr(i,'postProcess'): postPackages.append(i)\n    if postPackages:\n      # ctetgen needs petsc conf files. so attempt to create them early\n      self.framework.dumpConfFiles()\n      for i in postPackages: i.postProcess()\n    return\n\n  def configure(self):\n    if not os.path.samefile(self.petscdir.dir, os.getcwd()):\n      raise RuntimeError('Wrong PETSC_DIR option specified: '+str(self.petscdir.dir) + '\\n  Configure invoked in: '+os.path.realpath(os.getcwd()))\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],self.petscdir.dir):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR!')\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],os.path.join(self.petscdir.dir,self.arch.arch)):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR/PETSC_ARCH!')\n    self.framework.header          = os.path.join(self.arch.arch,'include','petscconf.h')\n    self.framework.cHeader         = os.path.join(self.arch.arch,'include','petscfix.h')\n    self.framework.makeMacroHeader = os.path.join(self.arch.arch,'conf','petscvariables')\n    self.framework.makeRuleHeader  = os.path.join(self.arch.arch,'conf','petscrules')\n    if self.libraries.math is None:\n      raise RuntimeError('PETSc requires a functional math library. Please send configure.log to petsc-maint@mcs.anl.gov.')\n    if self.languages.clanguage == 'Cxx' and not hasattr(self.compilers, 'CXX'):\n      raise RuntimeError('Cannot set C language to C++ without a functional C++ compiler.')\n    self.executeTest(self.configureRTLDDefault)\n    self.executeTest(self.configurePrefetch)\n    self.executeTest(self.configureUnused)\n    self.executeTest(self.configureDeprecated)\n    self.executeTest(self.configureExpect);\n    self.executeTest(self.configureFunctionName);\n    self.executeTest(self.configureIntptrt);\n    self.executeTest(self.configureSolaris)\n    self.executeTest(self.configureLinux)\n    self.executeTest(self.configureWin32)\n    self.executeTest(self.configureDefaultArch)\n    self.executeTest(self.configureScript)\n    self.executeTest(self.configureInstall)\n    self.executeTest(self.configureGCOV)\n    self.executeTest(self.configureFortranFlush)\n    self.executeTest(self.configureFeatureTestMacros)\n    self.executeTest(self.configureAtoll)\n    # dummy rules, always needed except for remote builds\n    self.addMakeRule('remote','')\n    self.addMakeRule('remoteclean','')\n\n    self.Dump()\n    self.dumpConfigInfo()\n    self.dumpMachineInfo()\n    self.postProcessPackages()\n    self.dumpCMakeConfig()\n    self.dumpCMakeLists()\n    self.cmakeBoot()\n    self.DumpPkgconfig()\n    self.DumpModule()\n    self.framework.log.write('================================================================================\\n')\n    self.logClear()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/config/BuildSystem/config/libraries.py": "import config.base\n\nimport os\nimport re\n\ntry:\n  enumerate([0, 1])\nexcept NameError:\n  def enumerate(l):\n    return zip(range(len(l)), l)\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework, libraries = []):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.libraries    = libraries\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilers    = framework.require('config.compilers',    self)\n    self.headers      = framework.require('config.headers',      self)\n    return\n\n  def getLibArgumentList(self, library):\n    '''Return the proper link line argument for the given filename library as a list of options\n      - If the path is empty, return it unchanged\n      - If starts with - then return unchanged\n      - If the path ends in \".lib\" return it unchanged\n      - If the path is absolute and the filename is \"lib\"<name>, return -L<dir> -l<name>\n      - If the filename is \"lib\"<name>, return -l<name>\n      - If the path ends in \".so\" return it unchanged\n      - If the path is absolute, return it unchanged\n      - Otherwise return -l<library>'''\n    if not library:\n      return []\n    if library.startswith('${CC_LINKER_SLFLAG}'):\n      return [library]\n    if library.startswith('${FC_LINKER_SLFLAG}'):\n      return [library]\n    if library.lstrip()[0] == '-':\n      return [library]\n    if len(library) > 3 and library[-4:] == '.lib':\n      return [library.replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')]\n    if os.path.basename(library).startswith('lib'):\n      name = self.getLibName(library)\n      if ((len(library) > 2 and library[1] == ':') or os.path.isabs(library)):\n        flagName  = self.language[-1]+'SharedLinkerFlag'\n        flagSubst = self.language[-1].upper()+'_LINKER_SLFLAG'\n        dirname   = os.path.dirname(library).replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')\n        if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n          return [getattr(self.setCompilers, flagName)+dirname,'-L'+dirname,'-l'+name]\n        if flagSubst in self.framework.argDB:\n          return [self.framework.argDB[flagSubst]+dirname,'-L'+dirname,'-l'+name]\n        else:\n          return ['-L'+dirname,' -l'+name]\n      else:\n        return ['-l'+name]\n    if os.path.splitext(library)[1] == '.so':\n      return [library]\n    if os.path.isabs(library):\n      return [library]\n    return ['-l'+library]\n\n  def getLibArgument(self, library):\n    '''Same as getLibArgumentList - except it returns a string instead of list.'''\n    return  ' '.join(self.getLibArgumentList(library))\n\n  def getLibName(library):\n    if os.path.basename(library).startswith('lib'):\n      return os.path.splitext(os.path.basename(library))[0][3:]\n    return library\n  getLibName = staticmethod(getLibName)\n\n  def getDefineName(self, library):\n    return 'HAVE_LIB'+self.getLibName(library).upper().replace('-','_').replace('=','_').replace('+','_').replace('.', '_').replace('/','_')\n\n  def haveLib(self, library):\n    return self.getDefineName(library) in self.defines\n\n  def add(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName AND adds it to $LIBS\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(libName, list): libName = [libName]\n    if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle):\n      self.logPrint('Adding '+str(libName)+' to LIBS')\n      # Note: this MUST be setCompilers since it can happen before dispatch names is made\n      self.setCompilers.LIBS = self.toString(libName)+' '+self.setCompilers.LIBS\n      return 1\n    return 0\n\n  def toString(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    return ' '.join(newlibs)\n\n  def toStringNoDupes(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker, removes duplicates'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    libs = newlibs\n    newlibs = []\n    for j in libs:\n      # do not remove duplicate -l, because there is a tiny chance that order may matter\n      if j in newlibs and not ( j.startswith('-l') or j == '-framework') : continue\n      newlibs.append(j)\n    return ' '.join(newlibs)\n\n  def getShortLibName(self,lib):\n    '''returns the short name for the library. Valid names are foo -lfoo or libfoo.[a,so,lib]'''\n    if lib.startswith('-l'):\n      libname = lib[2:]\n      return libname\n    if lib.startswith('-'): # must be some compiler options - not a library\n      return ''\n    if lib.endswith('.a') or lib.endswith('.so') or lib.endswith('.lib'):\n      libname = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): libname = libname[3:]\n      return libname\n    # no match - assuming the given name is already in short notation\n    return lib\n\n  def check(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0, cxxMangle = 0, cxxLink = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(funcs,list): funcs = [funcs]\n    if not isinstance(libName, list): libName = [libName]\n    for f, funcName in enumerate(funcs):\n      # Handle Fortran mangling\n      if fortranMangle:\n        funcName = self.compilers.mangleFortranFunction(funcName)\n      self.framework.logPrint('Checking for function '+str(funcName)+' in library '+str(libName)+' '+str(otherLibs))\n      if self.language[-1] == 'FC':\n        includes = ''\n      else:\n        includes = '/* Override any gcc2 internal prototype to avoid an error. */\\n'\n      # Handle C++ mangling\n      if self.language[-1] == 'Cxx' and not cxxMangle:\n        includes += '''\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n'''\n      # Construct prototype\n      if not self.language[-1] == 'FC':\n        if prototype:\n          if isinstance(prototype, str):\n            includes += prototype\n          else:\n            includes += prototype[f]\n        else:\n          # We use char because int might match the return type of a gcc2 builtin and its argument prototype would still apply.\n          includes += 'char '+funcName+'();\\n'\n      # Handle C++ mangling\n      if self.language[-1] == 'Cxx' and not cxxMangle:\n        includes += '''\n#ifdef __cplusplus\n}\n#endif\n'''\n      # Construct function call\n      if call:\n        if isinstance(call, str):\n          body = call\n        else:\n          body = call[f]\n      else:\n        body = funcName+'()\\n'\n      # Setup link line\n      oldLibs = self.setCompilers.LIBS\n      if libDir:\n        if not isinstance(libDir, list): libDir = [libDir]\n        for dir in libDir:\n          self.setCompilers.LIBS += ' -L'+dir\n      # new libs may/will depend on system libs so list new libs first!\n      # Matt, do not change this without talking to me\n      if libName and otherLibs:\n        self.setCompilers.LIBS = ' '+self.toString(libName+otherLibs) +' '+ self.setCompilers.LIBS\n      elif otherLibs:\n        self.setCompilers.LIBS = ' '+self.toString(otherLibs) +' '+ self.setCompilers.LIBS\n      elif libName:\n        self.setCompilers.LIBS = ' '+self.toString(libName) +' '+ self.setCompilers.LIBS\n      if cxxMangle: compileLang = 'Cxx'\n      else:         compileLang = self.language[-1]\n      if cxxLink: linklang = 'Cxx'\n      else: linklang = self.language[-1]\n      self.pushLanguage(compileLang)\n      found = 0\n      if self.checkLink(includes, body, linkLanguage=linklang):\n        found = 1\n        # add to list of found libraries\n        if libName:\n          for lib in libName:\n            shortlib = self.getShortLibName(lib)\n            if shortlib: self.addDefine(self.getDefineName(shortlib), 1)\n      self.setCompilers.LIBS = oldLibs\n      self.popLanguage()\n      if not found: return 0\n    return 1\n\n  def checkMath(self):\n    '''Check for sin() in libm, the math library'''\n    self.math = None\n    funcs = ['sin', 'floor', 'log10', 'pow']\n    prototypes = ['double sin(double);', 'double floor(double);', 'double log10(double);', 'double pow(double, double);']\n    calls = ['double x = 0,y; y = sin(x);\\n', 'double x = 0,y; y = floor(x);\\n', 'double x = 0,y; y = log10(x);\\n', 'double x = 0,y ; y = pow(x, x);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Math functions are linked in by default')\n      self.math = []\n    elif self.check('m', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using libm for the math library')\n      self.math = ['libm.a']\n    else:\n      self.logPrint('Warning: No math library found')\n    return\n\n  def checkMathErf(self):\n    '''Check for erf() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['erf'], prototype = ['double erf(double);'], call = ['double x = 0,y; y = erf(x);\\n']):\n      self.logPrint('erf() found')\n      self.addDefine('HAVE_ERF', 1)\n    else:\n      self.logPrint('Warning: erf() not found')\n    return\n\n  def checkMathTgamma(self):\n    '''Check for tgama() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['tgamma'], prototype = ['double tgamma(double);'], call = ['double x = 0,y; y = tgamma(x);\\n']):\n      self.logPrint('tgamma() found')\n      self.addDefine('HAVE_TGAMMA', 1)\n    else:\n      self.logPrint('Warning: tgamma() not found')\n    return\n\n  def checkMathFenv(self):\n    '''Checks if <fenv.h> can be used with FE_DFL_ENV'''\n    if not self.math is None and self.check(self.math, ['fesetenv'], prototype = ['#include <fenv.h>'], call = ['fesetenv(FE_DFL_ENV);']):\n      self.addDefine('HAVE_FENV_H', 1)\n    else:\n      self.logPrint('Warning: <fenv.h> with FE_DFL_ENV not found')\n    return\n\n  def checkCompression(self):\n    '''Check for libz, the compression library'''\n    self.compression = None\n    funcs = ['compress', 'uncompress']\n    prototypes = ['int   compress(char *dest, unsigned long *destLen, const char *source, unsigned long sourceLen);',\n                  'int uncompress(char *dest, unsigned long *destLen, const char *source, unsigned long sourceLen);']\n    calls = ['char *dest = 0; const char *source = 0; unsigned long destLen = 0, sourceLen = 0; int ret = 0; ret =   compress(dest, &destLen, source, sourceLen);\\n',\n             'char *dest = 0; const char *source = 0; unsigned long destLen = 0, sourceLen = 0; int ret = 0; ret = uncompress(dest, &destLen, source, sourceLen);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Compression functions are linked in by default')\n      self.compression = []\n    elif self.check('z', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using libz for the compression library')\n      self.compression = ['libz.a']\n    elif self.check('zlib.lib', funcs, prototype = prototypes, call = calls):\n      self.logPrint('Using zlib.lib for the compression library')\n      self.compression = ['zlib.lib']\n    else:\n      self.logPrint('Warning: No compression library found')\n    return\n\n  def checkRealtime(self):\n    '''Check for presence of clock_gettime() in realtime library (POSIX Realtime extensions)'''\n    self.rt = None\n    funcs = ['clock_gettime']\n    prototypes = ['#include <time.h>']\n    calls = ['struct timespec tp; clock_gettime(CLOCK_REALTIME,&tp);']\n    if self.check('', funcs, prototype=prototypes, call=calls):\n      self.logPrint('realtime functions are linked in by default')\n      self.rt = []\n    elif self.check('rt', funcs, prototype=prototypes, call=calls):\n      self.logPrint('Using librt for the realtime library')\n      self.rt = ['librt.a']\n    else:\n      self.logPrint('Warning: No realtime library found')\n    return\n\n  def checkDynamic(self):\n    '''Check for the header and libraries necessary for dynamic library manipulation'''\n    if 'with-dynamic-loading' in self.framework.argDB and not self.framework.argDB['with-dynamic-loading']: return\n    self.check(['dl'], 'dlopen')\n    self.headers.check('dlfcn.h')\n    return\n\n  def checkShared(self, includes, initFunction, checkFunction, finiFunction = None, checkLink = None, libraries = [], initArgs = '&argc, &argv', boolType = 'int', noCheckArg = 0, defaultArg = '', executor = None):\n    '''Determine whether a library is shared\n       - initFunction(int *argc, char *argv[]) is called to initialize some static data\n       - checkFunction(int *check) is called to verify that the static data wer set properly\n       - finiFunction() is called to finalize the data, and may be omitted\n       - checkLink may be given as ana alternative to the one in base.Configure'''\n    isShared = 0\n    if checkLink is None:\n      checkLink = self.checkLink\n      configObj = self\n    else:\n      if hasattr(checkLink, 'im_self'):\n        configObj = checkLink.im_self\n      else:\n        configObj = self\n\n    # Fix these flags\n    oldFlags = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '+self.toString(libraries)+' '+self.setCompilers.LIBS\n\n    # Make a library which calls initFunction(), and returns checkFunction()\n    lib1Name = os.path.join(self.tmpDir, 'lib1.'+self.setCompilers.sharedLibraryExt)\n    if noCheckArg:\n      checkCode = 'isInitialized = '+checkFunction+'();'\n    else:\n      checkCode = checkFunction+'(&isInitialized);'\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint init(int argc,  char *argv[]) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s(%s);\n  %s\n  return (int) isInitialized;\n''' % (boolType, initFunction, initArgs, checkCode)\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib1Name)\n\n    # Make a library which calls checkFunction()\n    lib2Name = os.path.join(self.tmpDir, 'lib2.'+self.setCompilers.sharedLibraryExt)\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint checkInit(void) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s\n''' % (boolType, checkCode)\n    if finiFunction:\n      body += '  if (isInitialized) '+finiFunction+'();\\n'\n    body += '  return (int) isInitialized;\\n'\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n      return 0\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib2Name)\n\n    self.setCompilers.LIBS = oldFlags\n\n    # Make an executable that dynamically loads and calls both libraries\n    #   If the check returns true in the second library, the static data was shared\n    guard = self.headers.getDefineName('dlfcn.h')\n    if self.headers.headerPrefix:\n      guard = self.headers.headerPrefix+'_'+guard\n    defaultIncludes = '''\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef %s\n#include <dlfcn.h>\n#endif\n    ''' % guard\n    body = '''\n  int   argc    = 1;\n  char *argv[2] = {(char *) \"conftest\", NULL};\n  void *lib;\n  int (*init)(int, char **);\n  int (*checkInit)(void);\n\n  lib = dlopen(\"'''+lib1Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib1.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  init = (int (*)(int, char **)) dlsym(lib, \"init\");\n  if (!init) {\n    fprintf(stderr, \"Could not find initialization function\\\\n\");\n    exit(1);\n  }\n  if (!(*init)(argc, argv)) {\n    fprintf(stderr, \"Could not initialize library\\\\n\");\n    exit(1);\n  }\n  lib = dlopen(\"'''+lib2Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib2.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  checkInit = (int (*)(void)) dlsym(lib, \"checkInit\");\n  if (!checkInit) {\n    fprintf(stderr, \"Could not find initialization check function\\\\n\");\n    exit(1);\n  }\n  if (!(*checkInit)()) {\n    fprintf(stderr, \"Did not link with shared library\\\\n\");\n    exit(2);\n  }\n  '''\n    oldLibs = self.setCompilers.LIBS\n    if self.haveLib('dl'):\n      self.setCompilers.LIBS += ' -ldl'\n    if self.checkRun(defaultIncludes, body, defaultArg = defaultArg, executor = executor):\n      isShared = 1\n    self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(lib1Name) and self.framework.doCleanup: os.remove(lib1Name)\n    if os.path.isfile(lib2Name) and self.framework.doCleanup: os.remove(lib2Name)\n    if isShared:\n      self.framework.logPrint('Library was shared')\n    else:\n      self.framework.logPrint('Library was not shared')\n    return isShared\n\n  def configure(self):\n    map(lambda args: self.executeTest(self.check, list(args)), self.libraries)\n    self.executeTest(self.checkMath)\n    self.executeTest(self.checkMathErf)\n    self.executeTest(self.checkMathTgamma)\n    self.executeTest(self.checkMathFenv)\n    self.executeTest(self.checkCompression)\n    self.executeTest(self.checkRealtime)\n    self.executeTest(self.checkDynamic)\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/config/BuildSystem/config/setCompilers.py": "from __future__ import generators\nimport config.base\n\nimport os\n\n# not sure how to handle this with 'self' so its outside the class\ndef noCheck(command, status, output, error):\n  return\n\ntry:\n  any\nexcept NameError:\n  def any(lst):\n    return reduce(lambda x,y:x or y,lst,False)\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.usedMPICompilers = 0\n    self.mainLanguage = 'C'\n    return\n\n  def __str__(self):\n    desc = ['Compilers:']\n    if hasattr(self, 'CC'):\n      self.pushLanguage('C')\n      desc.append('  C Compiler:         '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C Linker:           '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CUDAC'):\n      self.pushLanguage('CUDA')\n      desc.append('  CUDA Compiler:      '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  CUDA Linker:        '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'CXX'):\n      self.pushLanguage('Cxx')\n      desc.append('  C++ Compiler:       '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  C++ Linker:         '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    if hasattr(self, 'FC'):\n      self.pushLanguage('FC')\n      desc.append('  Fortran Compiler:   '+self.getCompiler()+' '+self.getCompilerFlags())\n      if not self.getLinker() == self.getCompiler(): desc.append('  Fortran Linker:     '+self.getLinker()+' '+self.getLinkerFlags())\n      self.popLanguage()\n    desc.append('Linkers:')\n    if hasattr(self, 'staticLinker'):\n      desc.append('  Static linker:   '+self.getSharedLinker()+' '+self.AR_FLAGS)\n    elif hasattr(self, 'sharedLinker'):\n      desc.append('  Shared linker:   '+self.getSharedLinker()+' '+self.getSharedLinkerFlags())\n    if hasattr(self, 'dynamicLinker'):\n      desc.append('  Dynamic linker:   '+self.getDynamicLinker()+' '+self.getDynamicLinkerFlags())\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-cpp=<prog>', nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPP=<prog>',            nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C preprocessor options'))\n    help.addArgument('Compilers', '-with-cc=<prog>',  nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CC=<prog>',             nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CFLAGS=<string>',       nargs.Arg(None, None, 'Specify the C compiler options'))\n    help.addArgument('Compilers', '-CC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the C linker flags'))\n\n    help.addArgument('Compilers', '-CXXPP=<prog>',          nargs.Arg(None, None, 'Specify the C++ preprocessor'))\n    help.addArgument('Compilers', '-CXXCPPFLAGS=<string>',  nargs.Arg(None, None, 'Specify the C++ preprocessor options'))\n    help.addArgument('Compilers', '-with-cxx=<prog>', nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXX=<prog>',            nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXXFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C++ compiler options, also passed to linker'))\n    help.addArgument('Compilers', '-CXX_CXXFLAGS=<string>', nargs.Arg(None, '',   'Specify the C++ compiler-only options, not passed to linker'))\n    help.addArgument('Compilers', '-CXX_LINKER_FLAGS=<string>',       nargs.Arg(None, [], 'Specify the C++ linker flags'))\n\n    help.addArgument('Compilers', '-with-fc=<prog>',  nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FC=<prog>',             nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FFLAGS=<string>',       nargs.Arg(None, None, 'Specify the Fortran compiler options'))\n    help.addArgument('Compilers', '-FC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the FC linker flags'))\n\n    help.addArgument('Compilers', '-with-gnu-compilers=<bool>',      nargs.ArgBool(None, 1, 'Try to use GNU compilers'))\n    help.addArgument('Compilers', '-with-vendor-compilers=<vendor as string>', nargs.Arg(None, '', 'Try to use vendor compilers (no argument all vendors, 0 no vendors)'))\n\n    help.addArgument('Compilers', '-with-large-file-io=<bool>', nargs.ArgBool(None, 0, 'Allow IO with files greater then 2 GB'))\n\n    help.addArgument('Compilers', '-CUDAPP=<prog>',        nargs.Arg(None, None, 'Specify the CUDA preprocessor'))\n    help.addArgument('Compilers', '-CUDAPPFLAGS=<string>', nargs.Arg(None, None, 'Specify the CUDA preprocessor options'))\n    help.addArgument('Compilers', '-CUDAC=<prog>',         nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAFLAGS=<string>',   nargs.Arg(None, None, 'Specify the CUDA compiler options'))\n    help.addArgument('Compilers', '-CUDAC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the CUDA linker flags'))\n\n##    help.addArgument('Compilers', '-LD=<prog>',              nargs.Arg(None, None, 'Specify the executable linker'))\n##    help.addArgument('Compilers', '-CC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for C only'))\n##    help.addArgument('Compilers', '-CXX_LD=<prog>',          nargs.Arg(None, None, 'Specify the linker for C++ only'))\n##    help.addArgument('Compilers', '-FC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for Fortran only'))\n    help.addArgument('Compilers', '-with-shared-ld=<prog>',  nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LD_SHARED=<prog>',       nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LDFLAGS=<string>',       nargs.Arg(None, '',   'Specify the linker options'))\n    help.addArgument('Compilers', '-with-ar=<prog>',                nargs.Arg(None, None,   'Specify the archiver'))\n    help.addArgument('Compilers', '-AR=<prog>',                     nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-AR_FLAGS=<string>',               nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-with-ranlib=<prog>',            nargs.Arg(None, None,   'Specify ranlib'))\n    help.addArgument('Compilers', '-with-pic=<bool>',               nargs.ArgBool(None, 0, 'Compile with -fPIC or equivalent flag if possible'))\n    help.addArgument('Compilers', '-sharedLibraryFlags=<string>',     nargs.Arg(None, [], 'Specify the shared library flags'))\n    help.addArgument('Compilers', '-dynamicLibraryFlags=<string>',    nargs.Arg(None, [], 'Specify the dynamic library flags'))\n    help.addArgument('Compilers', '-LIBS=<string>',          nargs.Arg(None, None, 'Specify extra libraries for all links'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.headers = framework.require('config.headers', None)\n    self.libraries = framework.require('config.libraries', None)\n    return\n\n  def isNAG(compiler):\n    '''Returns true if the compiler is a NAG F90 compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck)\n      output = output + error\n      if output.find('NAGWare Fortran') >= 0 or output.find('The Numerical Algorithms Group Ltd') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isNAG = staticmethod(isNAG)\n\n  def isGNU(compiler):\n    '''Returns true if the compiler is a GNU compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help')\n      output = output + error\n      return (any([s in output for s in ['www.gnu.org',\n                                         'bugzilla.redhat.com',\n                                         'gcc.gnu.org',\n                                         'gcc version',\n                                         '-print-libgcc-file-name',\n                                         'passed on to the various sub-processes invoked by gcc',\n                                         'passed on to the various sub-processes invoked by cc',\n                                         'passed on to the various sub-processes invoked by gfortran',\n                                         'passed on to the various sub-processes invoked by g++',\n                                         'passed on to the various sub-processes invoked by c++',\n                                         ]])\n              and not any([s in output for s in ['Intel(R)',\n                                                 'Unrecognised option --help passed to ld', # NAG f95 compiler\n                                                 ]]))\n    except RuntimeError:\n      pass\n    return 0\n  isGNU = staticmethod(isGNU)\n\n  def isClang(compiler):\n    '''Returns true if the compiler is a Clang/LLVM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help')\n      output = output + error\n      return any([s in output for s in ['Emit Clang AST']])\n    except RuntimeError:\n      pass\n    return 0\n  isClang = staticmethod(isClang)\n\n  def isGfortran45x(compiler):\n    '''returns true if the compiler is gfortran-4.5.x'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version')\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.5.\\d+|4.6.0 20100703)', output):\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran45x = staticmethod(isGfortran45x)\n\n  def isGfortran46plus(compiler):\n    '''returns true if the compiler is gfortran-4.6.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version')\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.([6789]|\\d{2,}).\\d+)', output):\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isGfortran46plus = staticmethod(isGfortran46plus)\n\n\n  def isG95(compiler):\n    '''Returns true if the compiler is g95'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help')\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('http://www.g95.org') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isG95 = staticmethod(isG95)\n\n  def isCompaqF90(compiler):\n    '''Returns true if the compiler is Compaq f90'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help')\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('Compaq Visual Fortran') >= 0 or output.find('Digital Visual Fortran') >=0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCompaqF90 = staticmethod(isCompaqF90)\n\n  def isSun(compiler):\n    '''Returns true if the compiler is a Sun/Oracle compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck)\n      output = output + error\n      if output.find(' Sun ') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSun = staticmethod(isSun)\n\n  def isIBM(compiler):\n    '''Returns true if the compiler is a IBM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -flags')\n      output = output + error\n      #\n      # Do not know what to look for for IBM compilers\n      #\n      return 0\n    except RuntimeError:\n      pass\n    return 0\n  isIBM = staticmethod(isIBM)\n\n  def isIntel(compiler):\n    '''Returns true if the compiler is a Intel compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help')\n      output = output + error\n      if output.find('Intel Corporation') >= 0 :\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isIntel = staticmethod(isIntel)\n\n  def isCray(compiler):\n    '''Returns true if the compiler is a Cray compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V')\n      output = output + error\n      if output.find('Cray Standard C') >= 0 or output.find('Cray C++') >= 0 or output.find('Cray Fortran') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isCray = staticmethod(isCray)\n\n  def isCrayVector(compiler):\n    '''Returns true if the compiler is a Cray compiler for a Cray Vector system'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -VV')\n      output = output + error\n      if not status and output.find('x86') >= 0:\n        return 0\n      elif not status:\n        return 1\n      else:\n        return 0\n    except RuntimeError:\n      pass\n    return 0\n  isCrayVector = staticmethod(isCrayVector)\n\n\n  def isPGI(compiler):\n    '''Returns true if the compiler is a PGI compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck)\n      output = output + error\n      if output.find('The Portland Group') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isPGI = staticmethod(isPGI)\n\n  def isSolarisAR(ar):\n    '''Returns true AR is solaris'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck)\n      output = output + error\n      if output.find('Software Generation Utilities') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isSolarisAR = staticmethod(isSolarisAR)\n\n  def isAIXAR(ar):\n    '''Returns true AR is AIX'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck)\n      output = output + error\n      if output.find('[-X{32|64|32_64|d64|any}]') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n    return 0\n  isAIXAR = staticmethod(isAIXAR)\n\n\n  def isLinux():\n    '''Returns true if system is linux'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s')\n    if not status and output.lower().strip().find('linux') >= 0:\n      return 1\n    else:\n      return 0\n  isLinux = staticmethod(isLinux)\n\n  def isCygwin():\n    '''Returns true if system is cygwin'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s')\n    if not status and output.lower().strip().find('cygwin') >= 0:\n      return 1\n    else:\n      return 0\n  isCygwin = staticmethod(isCygwin)\n\n  def isSolaris():\n    '''Returns true if system is solaris'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s')\n    if not status and output.lower().strip().find('sunos') >= 0:\n      return 1\n    else:\n      return 0\n  isSolaris = staticmethod(isSolaris)\n\n  def isDarwin():\n    '''Returns true if system is Darwin/MacOSX'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s')\n    if not status:\n      return output.lower().strip() == 'darwin'\n    return 0\n  isDarwin = staticmethod(isDarwin)\n\n  def isFreeBSD():\n    '''Returns true if system is FreeBSD'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s')\n    if not status:\n      return output.lower().strip() == 'freebsd'\n    return 0\n  isFreeBSD = staticmethod(isFreeBSD)\n\n  def isWindows(compiler):\n    '''Returns true if the compiler is a Windows compiler'''\n    if compiler in ['icl', 'cl', 'bcc32', 'ifl', 'df']:\n      return 1\n    if compiler in ['ifort','f90'] and Configure.isCygwin():\n      return 1\n    if compiler in ['lib', 'tlib']:\n      return 1\n    return 0\n  isWindows = staticmethod(isWindows)\n\n  def addLdPath(path):\n    import os\n    if 'LD_LIBRARY_PATH' in os.environ:\n      ldPath=os.environ['LD_LIBRARY_PATH']\n    else:\n      ldPath=''\n    if ldPath == '': ldPath = path\n    else: ldPath += ':' + path\n    os.environ['LD_LIBRARY_PATH'] = ldPath\n    return\n  addLdPath = staticmethod(addLdPath)\n\n  def useMPICompilers(self):\n    if ('with-cc' in self.argDB and self.argDB['with-cc'] != '0') or 'CC' in self.argDB:\n      return 0\n    if ('with-cxx' in self.argDB and self.argDB['with-cxx'] != '0') or 'CXX' in self.argDB:\n      return 0\n    if ('with-fc' in self.argDB and self.argDB['with-fc'] != '0') or 'FC' in self.argDB:\n      return 0\n    if self.argDB['download-mpich'] or self.argDB['download-openmpi']:\n      return 0\n    if 'with-mpi' in self.argDB and self.argDB['with-mpi'] and self.argDB['with-mpi-compilers']:\n      return 1\n    return 0\n\n  def checkVendor(self):\n    '''Determine the compiler vendor'''\n    self.vendor = self.framework.argDB['with-vendor-compilers']\n    if self.framework.argDB['with-vendor-compilers'] == 'no' or self.framework.argDB['with-vendor-compilers'] == 'false':\n      self.vendor = None\n    if self.framework.argDB['with-vendor-compilers'] == '1' or self.framework.argDB['with-vendor-compilers'] == 'yes' or self.framework.argDB['with-vendor-compilers'] == 'true':\n      self.vendor = ''\n    self.logPrint('Compiler vendor is \"'+str(self.vendor)+'\"')\n    return\n\n  def checkInitialFlags(self):\n    '''Initialize the compiler and linker flags'''\n    for language in ['C', 'CUDA', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      for flagsArg in [self.getCompilerFlagsName(language), self.getCompilerFlagsName(language, 1), self.getLinkerFlagsName(language)]:\n        if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n        else: setattr(self, flagsArg, '')\n        self.framework.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n      self.popLanguage()\n    for flagsArg in ['CPPFLAGS', 'CUDAPPFLAGS', 'CXXCPPFLAGS', 'CC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS','sharedLibraryFlags', 'dynamicLibraryFlags']:\n      if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n      else: setattr(self, flagsArg, '')\n      self.framework.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    if 'LIBS' in self.argDB:\n      self.LIBS = self.argDB['LIBS']\n    else:\n      self.LIBS = ''\n    return\n\n  def checkCompiler(self, language):\n    '''Check that the given compiler is functional, and if not raise an exception'''\n    self.pushLanguage(language)\n    if not self.checkCompile():\n      msg = 'Cannot compile '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if language == 'CUDA': # do not check CUDA linker since it is never used (and is broken on Mac with -m64)\n      self.popLanguage()\n      return\n    if not self.checkLink():\n      msg = 'Cannot compile/link '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if not self.framework.argDB['with-batch']:\n      if not self.checkRun():\n        msg = 'Cannot run executables created with '+language+'. If this machine uses a batch system \\nto submit jobs you will need to configure using ./configure with the additional option  --with-batch.\\n Otherwise there is problem with the compilers. Can you compile and run code with your C/C++ (and maybe Fortran) compilers?\\n'\n        if self.isIntel(self.getCompiler()):\n          msg = msg + 'See http://www.mcs.anl.gov/petsc/documentation/faq.html#libimf'\n        self.popLanguage()\n        raise OSError(msg)\n    self.popLanguage()\n    return\n\n  def generateCCompilerGuesses(self):\n    '''Determine the C compiler using CC, then --with-cc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CC'):\n      yield self.CC\n    elif self.framework.argDB.has_key('with-cc'):\n      if self.isWindows(self.framework.argDB['with-cc']):\n        yield 'win32fe '+self.framework.argDB['with-cc']\n      else:\n        yield self.framework.argDB['with-cc']\n      raise RuntimeError('C compiler you provided with -with-cc='+self.framework.argDB['with-cc']+' does not work')\n    elif self.framework.argDB.has_key('CC'):\n      if self.isWindows(self.framework.argDB['CC']):\n        yield 'win32fe '+self.framework.argDB['CC']\n      else:\n        yield self.framework.argDB['CC']\n      raise RuntimeError('C compiler you provided with -CC='+self.framework.argDB['CC']+' does not work')\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpicc')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpcc')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'hcc')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpcc_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('MPI compiler wrappers in '+self.framework.argDB['with-mpi-dir']+'/bin do not work. See http://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicc') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpicc'\n        if Configure.isGNU('hcc') and self.framework.argDB['with-gnu-compilers']:\n          yield 'hcc'\n        if not Configure.isGNU('mpicc') and (not self.vendor is None):\n          yield 'mpicc'\n        if not Configure.isGNU('hcc') and (not self.vendor is None):\n          yield 'hcc'\n        if not self.vendor is None:\n          yield 'mpcc_r'\n          yield 'mpcc'\n          yield 'mpxlc'\n        self.usedMPICompilers = 0\n      vendor = self.vendor\n      if (not vendor) and self.framework.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc'):\n          yield 'cc'\n      if not self.vendor is None:\n        if not vendor and not Configure.isGNU('cc'):\n          yield 'cc'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'kai' or not vendor:\n          yield 'kcc'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlc'\n        if vendor == 'intel' or not vendor:\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgcc'\n        if vendor == 'solaris' or not vendor:\n          if not Configure.isGNU('cc'):\n            yield 'cc'\n      # duplicate code\n      if self.framework.argDB['with-gnu-compilers']:\n        yield 'gcc'\n        if Configure.isGNU('cc'):\n          yield 'cc'\n    return\n\n  def checkCCompiler(self):\n    '''Locate a functional C compiler'''\n    if 'with-cc' in self.framework.argDB and self.framework.argDB['with-cc'] == '0':\n      raise RuntimeError('A functional C compiler is necessary for configure, cannot use --with-cc=0')\n    for compiler in self.generateCCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CC'):\n          self.checkCompiler('C')\n          break\n      except RuntimeError, e:\n        import os\n\n        import sys,traceback\n        traceback.print_tb(sys.exc_info()[2])\n        self.logPrint('Error testing C compiler: '+str(e))\n        if os.path.basename(self.CC) == 'mpicc':\n          self.framework.logPrint(' MPI installation '+str(self.CC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('CC')\n        del self.CC\n    if not hasattr(self, 'CC'):\n      raise RuntimeError('Could not locate a functional C compiler')\n    return\n\n  def generateCPreprocessorGuesses(self):\n    '''Determines the C preprocessor from CPP, then --with-cpp, then the C compiler'''\n    if 'with-cpp' in self.framework.argDB:\n      yield self.framework.argDB['with-cpp']\n    elif 'CPP' in self.framework.argDB:\n      yield self.framework.argDB['CPP']\n    else:\n      yield self.CC+' -E'\n      yield self.CC+' --use cpp32'\n      yield 'gcc -E'\n    return\n\n  def checkCPreprocessor(self):\n    '''Locate a functional C preprocessor'''\n    for compiler in self.generateCPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CPP'):\n          self.pushLanguage('C')\n          if not self.checkPreprocess('#include <stdlib.h>\\n'):\n            raise RuntimeError('Cannot preprocess C with '+self.CPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError, e:\n        self.popLanguage()\n    raise RuntimeError('Cannot find a C preprocessor')\n    return\n\n  def generateCUDACompilerGuesses(self):\n    '''Determine the CUDA compiler using CUDAC, then --with-cudac, then vendors\n       - Any given category can be excluded'''\n    if hasattr(self, 'CUDAC'):\n      yield self.CUDAC\n    elif self.framework.argDB.has_key('with-cudac'):\n      yield self.framework.argDB['with-cudac']\n      raise RuntimeError('CUDA compiler you provided with -with-cudac='+self.framework.argDB['with-cudac']+' does not work')\n    elif self.framework.argDB.has_key('CUDAC'):\n      yield self.framework.argDB['CUDAC']\n      raise RuntimeError('CUDA compiler you provided with -CUDAC='+self.framework.argDB['CUDAC']+' does not work')\n    else:\n      vendor = self.vendor\n      if not self.vendor is None:\n        if vendor == 'nvidia' or not vendor:\n          yield 'nvcc'\n      yield 'nvcc'\n    return\n\n  def checkCUDACompiler(self):\n    '''Locate a functional CUDA compiler'''\n    if 'with-cudac' in self.framework.argDB and self.framework.argDB['with-cudac'] == '0':\n      if 'CUDAC' in self.framework.argDB:\n        del self.framework.argDB['CUDAC']\n      return\n    for compiler in self.generateCUDACompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAC'):\n          self.checkCompiler('CUDA')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.CUDAC+' --version')\n          compilerVersion = compilerVersion[0]\n          compilerVersion = compilerVersion.split()\n          i = 0\n          for word in compilerVersion:\n            i = i+1\n            if word == 'release':\n              break\n          self.compilerVersionCUDA = compilerVersion[i].strip(',')\n          break\n      except RuntimeError, e:\n        self.logPrint('Error testing CUDA compiler: '+str(e))\n        self.delMakeMacro('CUDAC')\n        del self.CUDAC\n    return\n\n  def generateCUDAPreprocessorGuesses(self):\n    '''Determines the CUDA preprocessor from --with-cudacpp, then CUDAPP, then the CUDA compiler'''\n    if 'with-cudacpp' in self.framework.argDB:\n      yield self.framework.argDB['with-cudacpp']\n    elif 'CUDAPP' in self.framework.argDB:\n      yield self.framework.argDB['CUDAPP']\n    else:\n      if hasattr(self, 'CUDAC'):\n        yield self.CUDAC+' -E'\n    return\n\n  def checkCUDAPreprocessor(self):\n    '''Locate a functional CUDA preprocessor'''\n    for compiler in self.generateCUDAPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAPP'):\n          self.pushLanguage('CUDA')\n          if not self.checkPreprocess('#include <stdlib.h>\\n__global__ void testFunction() {return;};'):\n            raise RuntimeError('Cannot preprocess CUDA with '+self.CUDAPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError, e:\n        self.popLanguage()\n    return\n\n  def generateCxxCompilerGuesses(self):\n    '''Determine the Cxx compiler using CXX, then --with-cxx, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'CXX'):\n      yield self.CXX\n    elif self.framework.argDB.has_key('with-c++'):\n      raise RuntimeError('Keyword --with-c++ is WRONG, use --with-cxx')\n    if self.framework.argDB.has_key('with-CC'):\n      raise RuntimeError('Keyword --with-CC is WRONG, use --with-cxx')\n\n    if self.framework.argDB.has_key('with-cxx'):\n      if self.framework.argDB['with-cxx'] == 'gcc': raise RuntimeError('Cannot use C compiler gcc as the C++ compiler passed in with --with-cxx')\n      if self.isWindows(self.framework.argDB['with-cxx']):\n        yield 'win32fe '+self.framework.argDB['with-cxx']\n      else:\n        yield self.framework.argDB['with-cxx']\n      raise RuntimeError('C++ compiler you provided with -with-cxx='+self.framework.argDB['with-cxx']+' does not work')\n    elif self.framework.argDB.has_key('CXX'):\n      if self.isWindows(self.framework.argDB['CXX']):\n        yield 'win32fe '+self.framework.argDB['CXX']\n      else:\n        yield self.framework.argDB['CXX']\n      raise RuntimeError('C++ compiler you provided with -CXX='+self.framework.argDB['CXX']+' does not work')\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpicxx')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'hcp')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpic++')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpiCC')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpCC_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('bin/<mpiCC,mpicxx,hcp,mpCC_r> you provided with -with-mpi-dir='+self.framework.argDB['with-mpi-dir']+' does not work')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpicxx') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpicxx'\n        if not Configure.isGNU('mpicxx') and (not self.vendor is None):\n          yield 'mpicxx'\n        if Configure.isGNU('mpiCC') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpiCC'\n        if not Configure.isGNU('mpiCC') and (not self.vendor is None):\n          yield 'mpiCC'\n        if Configure.isGNU('mpic++') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpic++'\n        if not Configure.isGNU('mpic++') and (not self.vendor is None):\n          yield 'mpic++'\n        if not self.vendor is None:\n          yield 'mpCC_r'\n          yield 'mpCC'\n        self.usedMPICompilers = 0\n      vendor = self.vendor\n      if (not vendor) and self.framework.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++'):\n          yield 'c++'\n      if not self.vendor is None:\n        if not vendor:\n          if not Configure.isGNU('c++'):\n            yield 'c++'\n          if not Configure.isGNU('CC'):\n            yield 'CC'\n          yield 'cxx'\n          yield 'cc++'\n        if vendor == 'borland' or not vendor:\n          yield 'win32fe bcc32'\n        if vendor == 'ibm' or not vendor:\n          yield 'xlC'\n        if vendor == 'intel' or not vendor:\n          yield 'icpc'\n          yield 'ccpc'\n          yield 'icc'\n          yield 'ecc'\n          yield 'win32fe icl'\n        if vendor == 'microsoft' or not vendor:\n          yield 'win32fe cl'\n        if vendor == 'portland' or not vendor:\n          yield 'pgCC'\n        if vendor == 'solaris':\n          yield 'CC'\n      #duplicate code\n      if self.framework.argDB['with-gnu-compilers']:\n        yield 'g++'\n        if Configure.isGNU('c++'):\n          yield 'c++'\n    return\n\n  def checkCxxCompiler(self):\n    '''Locate a functional Cxx compiler'''\n    if 'with-cxx' in self.framework.argDB and self.framework.argDB['with-cxx'] == '0':\n      if 'CXX' in self.framework.argDB:\n        del self.framework.argDB['CXX']\n      return\n    for compiler in self.generateCxxCompilerGuesses():\n      # Determine an acceptable extensions for the C++ compiler\n      for ext in ['.cc', '.cpp', '.C']:\n        self.framework.getCompilerObject('Cxx').sourceExtension = ext\n        try:\n          if self.getExecutable(compiler, resultName = 'CXX'):\n            self.checkCompiler('Cxx')\n            break\n        except RuntimeError, e:\n          import os\n\n          self.logPrint('Error testing C++ compiler: '+str(e))\n          if os.path.basename(self.CXX) in ['mpicxx', 'mpiCC']:\n            self.logPrint('  MPI installation '+str(self.CXX)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n          self.delMakeMacro('CXX')\n          del self.CXX\n      if hasattr(self, 'CXX'):\n        break\n    return\n\n  def generateCxxPreprocessorGuesses(self):\n    '''Determines the Cxx preprocessor from CXXCPP, then --with-cxxcpp, then the Cxx compiler'''\n    if 'with-cxxcpp' in self.framework.argDB:\n      yield self.framework.argDB['with-cxxcpp']\n    elif 'CXXCPP' in self.framework.argDB:\n      yield self.framework.argDB['CXXCPP']\n    else:\n      yield self.CXX+' -E'\n      yield self.CXX+' --use cpp32'\n      yield 'g++ -E'\n    return\n\n  def checkCxxPreprocessor(self):\n    '''Locate a functional Cxx preprocessor'''\n    if not hasattr(self, 'CXX'):\n      return\n    for compiler in self.generateCxxPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CXXCPP'):\n          self.pushLanguage('Cxx')\n          if not self.checkPreprocess('#include <cstdlib>\\n'):\n            raise RuntimeError('Cannot preprocess Cxx with '+self.CXXCPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError, e:\n        import os\n\n        if os.path.basename(self.CXXCPP) in ['mpicxx', 'mpiCC']:\n          self.framework.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('CCCPP')\n        del self.CXXCPP\n    return\n\n  def generateFortranCompilerGuesses(self):\n    '''Determine the Fortran compiler using FC, then --with-fc, then MPI, then GNU, then vendors\n       - Any given category can be excluded'''\n    import os\n\n    if hasattr(self, 'FC'):\n      yield self.FC\n    elif self.framework.argDB.has_key('with-fc'):\n      if self.isWindows(self.framework.argDB['with-fc']):\n        yield 'win32fe '+self.framework.argDB['with-fc']\n      else:\n        yield self.framework.argDB['with-fc']\n      raise RuntimeError('Fortran compiler you provided with --with-fc='+self.framework.argDB['with-fc']+' does not work')\n    elif self.framework.argDB.has_key('FC'):\n      if self.isWindows(self.framework.argDB['FC']):\n        yield 'win32fe '+self.framework.argDB['FC']\n      else:\n        yield self.framework.argDB['FC']\n      yield self.framework.argDB['FC']\n      raise RuntimeError('Fortran compiler you provided with -FC='+self.framework.argDB['FC']+' does not work')\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpif90')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpif77')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpxlf95_r')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpxlf90_r')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpxlf_r')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpf90')\n      yield os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpf77')\n      self.usedMPICompilers = 0\n      if os.path.isfile(os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpif90')) or os.path.isfile((os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', 'mpif77'))):\n        raise RuntimeError('bin/mpif90[f77] you provided with --with-mpi-dir='+self.framework.argDB['with-mpi-dir']+' does not work\\nRun with --with-fc=0 if you wish to use this MPI and disable Fortran')\n    else:\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        if Configure.isGNU('mpif90') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpif90'\n        if not Configure.isGNU('mpif90') and (not self.vendor is None):\n          yield 'mpif90'\n        if Configure.isGNU('mpif77') and self.framework.argDB['with-gnu-compilers']:\n          yield 'mpif77'\n        if not Configure.isGNU('mpif77') and (not self.vendor is None):\n          yield 'mpif77'\n        if not self.vendor is None:\n          yield 'mpxlf_r'\n          yield 'mpxlf'\n          yield 'mpf90'\n          yield 'mpf77'\n        self.usedMPICompilers = 0\n      vendor = self.vendor\n      if (not vendor) and self.framework.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77'):\n          yield 'f77'\n      if not self.vendor is None:\n        if vendor == 'ibm' or not vendor:\n          yield 'xlf'\n          yield 'xlf90'\n        if not vendor or vendor in ['absoft', 'cray', 'dec', 'hp', 'sgi']:\n          yield 'f90'\n        if vendor == 'lahaye' or not vendor:\n          yield 'lf95'\n        if vendor == 'intel' or not vendor:\n          yield 'win32fe ifort'\n          yield 'win32fe ifl'\n          yield 'ifort'\n          yield 'ifc'\n          yield 'efc'\n        if vendor == 'portland' or not vendor:\n          yield 'pgf90'\n          yield 'pgf77'\n        if vendor == 'solaris' or not vendor:\n          yield 'f95'\n          yield 'f90'\n          if not Configure.isGNU('f77'):\n            yield 'f77'\n      #duplicate code\n      if self.framework.argDB['with-gnu-compilers']:\n        yield 'gfortran'\n        yield 'g95'\n        yield 'g77'\n        if Configure.isGNU('f77'):\n          yield 'f77'\n    return\n\n  def checkFortranCompiler(self):\n    '''Locate a functional Fortran compiler'''\n    if 'with-fc' in self.framework.argDB and self.framework.argDB['with-fc'] == '0':\n      if 'FC' in self.framework.argDB:\n        del self.framework.argDB['FC']\n      return\n    for compiler in self.generateFortranCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FC'):\n          self.checkCompiler('FC')\n          break\n      except RuntimeError, e:\n        self.logPrint('Error testing Fortran compiler: '+str(e))\n        if os.path.basename(self.FC) in ['mpif90', 'mpif77']:\n          self.framework.logPrint(' MPI installation '+str(self.FC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('FC')\n        del self.FC\n    return\n\n  def checkFortranComments(self):\n    '''Make sure fortran comment \"!\" works'''\n    self.pushLanguage('FC')\n    if not self.checkCompile('! comment'):\n      raise RuntimeError(self.getCompiler()+' cannot process fortran comments.')\n    self.framework.logPrint('Fortran comments can use ! in column 1')\n    self.popLanguage()\n    return\n\n  def containsInvalidFlag(self, output):\n    '''If the output contains evidence that an invalid flag was used, return True'''\n    if (output.find('Unrecognized command line option') >= 0 or output.find('Unrecognised command line option') >= 0 or\n        output.find('unrecognized command line option') >= 0 or output.find('unrecognized option') >= 0 or output.find('unrecognised option') >= 0 or\n        output.find('not recognized') >= 0 or output.find('not recognised') >= 0 or\n        output.find('unknown option') >= 0 or output.find('unknown flag') >= 0 or output.find('Unknown switch') >= 0 or\n        output.find('ignoring option') >= 0 or output.find('ignored') >= 0 or\n        output.find('argument unused') >= 0 or\n        # When checking for the existence of 'attribute'\n        output.find('is unsupported and will be skipped') >= 0 or\n        output.find('illegal option') >= 0 or output.find('Invalid option') >= 0 or\n        (output.find('bad ') >= 0 and output.find(' option') >= 0) or\n        output.find('linker input file unused because linking not done') >= 0 or\n        output.find('PETSc Error') >= 0 or\n        output.find('Unbekannte Option') >= 0 or\n        output.find('no se reconoce la opci') >= 0) or output.find('non reconnue') >= 0:\n      return 1\n    return 0\n\n  def checkCompilerFlag(self, flag, includes = '', body = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, error, status) = self.outputCompile(includes, body)\n    output += error\n    valid   = 1\n    # Please comment each entry and provide an example line\n    if status:\n      valid = 0\n      self.framework.logPrint('Rejecting compiler flag '+flag+' due to nonzero status from link')\n    # Lahaye F95\n    if output.find('Invalid suboption') >= 0:\n      valid = 0\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.framework.logPrint('Rejecting compiler flag '+flag+' due to \\n'+output)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def insertCompilerFlag(self, flag, compilerOnly):\n    '''DANGEROUS: Put in the compiler flag without checking'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n    self.framework.log.write('Added '+self.language[-1]+' compiler flag '+flag+'\\n')\n    return\n\n  def addCompilerFlag(self, flag, includes = '', body = '', extraflags = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkCompilerFlag(flag+' '+extraflags, includes, body, compilerOnly):\n      self.insertCompilerFlag(flag, compilerOnly)\n      return\n    raise RuntimeError('Bad compiler flag: '+flag)\n\n  def checkPIC(self):\n    '''Determine the PIC option for each compiler\n       - There needs to be a test that checks that the functionality is actually working'''\n    self.usePIC = 0\n    useSharedLibraries = 'with-shared-libraries' in self.framework.argDB and self.framework.argDB['with-shared-libraries']\n    useDynamicLoading  = 'with-dynamic-loading'  in self.framework.argDB and self.framework.argDB['with-dynamic-loading']\n    if not self.framework.argDB['with-pic'] and not useSharedLibraries and not useDynamicLoading:\n      self.framework.logPrint(\"Skip checking PIC options on user request\")\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      #different compilers are sensitive to the order of testing these flags. So separete out GCC test.\n      if config.setCompilers.Configure.isGNU(self.getCompiler()): testFlags = ['-fPIC']\n      else: testFlags = ['-PIC', '-fPIC', '-KPIC','-qpic']\n      for testFlag in testFlags:\n        try:\n          self.framework.logPrint('Trying '+language+' compiler flag '+testFlag)\n          if not self.checkLinkerFlag(testFlag):\n            self.framework.logPrint('Rejected '+language+' compiler flag '+testFlag+' because linker cannot handle it')\n            continue\n          self.framework.logPrint('Adding '+language+' compiler flag '+testFlag)\n          self.addCompilerFlag(testFlag, compilerOnly = 1)\n          self.isPIC = 1\n          break\n        except RuntimeError:\n          self.framework.logPrint('Rejected '+language+' compiler flag '+testFlag)\n      self.popLanguage()\n    return\n\n  def checkLargeFileIO(self):\n    # check for large file support with 64bit offset\n    if not self.framework.argDB['with-large-file-io']:\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      if self.checkCompile('#include <unistd.h>','#ifndef _LFS64_LARGEFILE \\n#error no largefile defines \\n#endif'):\n        try:\n          self.addCompilerFlag('-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64',compilerOnly=1)\n        except RuntimeError, e:\n          self.logPrint('Error adding ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      else:\n        self.logPrint('Rejected ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      self.popLanguage()\n    return\n\n  def getArchiverFlags(self, archiver):\n    prog = os.path.basename(archiver).split(' ')[0]\n    flag = ''\n    if 'AR_FLAGS' in self.framework.argDB:\n      flag = self.framework.argDB['AR_FLAGS']\n    elif prog.endswith('ar'):\n      flag = 'cr'\n    elif prog == 'win32fe':\n      args = os.path.basename(archiver).split(' ')\n      if 'lib' in args:\n        flag = '-a'\n      elif 'tlib' in args:\n        flag = '-a -P512'\n    if prog.endswith('ar') and not (self.isSolarisAR(prog) or self.isAIXAR(prog)):\n      self.FAST_AR_FLAGS = 'Scq'\n    else:\n      self.FAST_AR_FLAGS = flag\n    self.framework.addMakeMacro('FAST_AR_FLAGS',self.FAST_AR_FLAGS )\n    return flag\n\n  def generateArchiverGuesses(self):\n    defaultAr = None\n    if 'with-ar' in self.framework.argDB:\n      if self.isWindows(self.framework.argDB['with-ar']):\n        defaultAr = 'win32fe '+self.framework.argDB['with-ar']\n      else:\n        defaultAr = self.framework.argDB['with-ar']\n    envAr = None\n    if 'AR' in self.framework.argDB:\n      if self.isWindows(self.framework.argDB['AR']):\n        envAr = 'win32fe '+self.framework.argDB['AR']\n      else:\n        envAr = self.framework.argDB['AR']\n    defaultRanlib = None\n    if 'with-ranlib' in self.framework.argDB:\n      defaultRanlib = self.framework.argDB['with-ranlib']\n    envRanlib = None\n    if 'RANLIB' in self.framework.argDB:\n      envRanlib = self.framework.argDB['RANLIB']\n    if defaultAr and defaultRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),defaultRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if defaultAr and envRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),envRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if envAr and defaultRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),defaultRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if envAr and envRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),envRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if defaultAr:\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'ranlib')\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'true')\n      raise RuntimeError('You set a value for --with-ar='+defaultAr+'\", but '+defaultAr+' cannot be used\\n')\n    if envAr:\n      yield (envAr,self.getArchiverFlags(envAr),'ranlib')\n      yield (envAr,self.getArchiverFlags(envAr),'true')\n      raise RuntimeError('You set a value for -AR=\"'+envAr+'\" (perhaps in your environment), but '+envAr+' cannot be used\\n')\n    if defaultRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),defaultRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),defaultRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),defaultRanlib)\n      raise RuntimeError('You set --with-ranlib=\"'+defaultRanlib+'\", but '+defaultRanlib+' cannot be used\\n')\n    if envRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),envRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),envRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),envRanlib)\n      raise RuntimeError('You set -RANLIB=\"'+envRanlib+'\" (perhaps in your environment), but '+defaultRanlib+' cannot be used\\n')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar',self.getArchiverFlags('ar'),'true')\n    # IBM with 64 bit pointers\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'true')\n    yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),'true')\n    yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),'true')\n    return\n\n  def checkArchiver(self):\n    '''Check that the archiver exists and can make a library usable by the compiler'''\n    objName    = os.path.join(self.tmpDir, 'conf1.o')\n    arcUnix    = os.path.join(self.tmpDir, 'libconf1.a')\n    arcWindows = os.path.join(self.tmpDir, 'libconf1.lib')\n    def checkArchive(command, status, output, error):\n      if error or status:\n        self.framework.logPrint('Possible ERROR while running archiver: '+output)\n        if status: self.framework.logPrint('ret = '+str(status))\n        if error: self.framework.logPrint('error message = {'+error+'}')\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('Archiver is not functional')\n      return\n    def checkRanlib(command, status, output, error):\n      if error or status:\n        self.framework.logPrint('Possible ERROR while running ranlib: '+output)\n        if status: self.framework.logPrint('ret = '+str(status))\n        if error: self.framework.logPrint('error message = {'+error+'}')\n        if os.path.isfile(arcUnix):\n          os.remove(arcUnix)\n        raise RuntimeError('Ranlib is not functional with your archiver.  Try --with-ranlib=true if ranlib is unnecessary.')\n      return\n    oldLibs = self.LIBS\n    self.pushLanguage('C')\n    for (archiver, arflags, ranlib) in self.generateArchiverGuesses():\n      if not self.checkCompile('', 'int foo(int a) {\\n  return a+1;\\n}\\n\\n', cleanup = 0, codeBegin = '', codeEnd = ''):\n        raise RuntimeError('Compiler is not functional')\n      if os.path.isfile(objName):\n        os.remove(objName)\n      os.rename(self.compilerObj, objName)\n      if self.getExecutable(archiver, getFullPath = 1, resultName = 'AR'):\n        if self.getExecutable(ranlib, getFullPath = 1, resultName = 'RANLIB'):\n          arext = 'a'\n          try:\n            (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+arflags+' '+arcUnix+' '+objName, checkCommand = checkArchive, log = self.framework.log)\n            (output, error, status) = config.base.Configure.executeShellCommand(self.RANLIB+' '+arcUnix, checkCommand = checkRanlib, log = self.framework.log)\n          except RuntimeError, e:\n            self.logPrint(str(e))\n            continue\n          self.LIBS = '-L'+self.tmpDir+' -lconf1 ' + oldLibs\n          success =  self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n          os.rename(arcUnix, arcWindows)\n          if not success:\n            arext = 'lib'\n            success = self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n            os.remove(arcWindows)\n            if success:\n              break\n          else:\n            os.remove(arcWindows)\n            break\n    else:\n      if os.path.isfile(objName):\n        os.remove(objName)\n      self.LIBS = oldLibs\n      self.popLanguage()\n      raise RuntimeError('Could not find a suitable archiver.  Use --with-ar to specify an archiver.')\n    self.AR_FLAGS      = arflags\n    self.AR_LIB_SUFFIX = arext\n    self.framework.addMakeMacro('AR_FLAGS', self.AR_FLAGS)\n    self.addMakeMacro('AR_LIB_SUFFIX', self.AR_LIB_SUFFIX)\n    os.remove(objName)\n    self.LIBS = oldLibs\n    self.popLanguage()\n    return\n\n  def setStaticLinker(self):\n    language = self.language[-1]\n    return self.framework.setSharedLinkerObject(language, self.framework.getLanguageModule(language).StaticLinker(self.framework.argDB))\n\n  def generateSharedLinkerGuesses(self):\n    useSharedLibraries = 'with-shared-libraries' in self.framework.argDB and self.framework.argDB['with-shared-libraries']\n    useDynamicLoading  = 'with-dynamic-loading'  in self.framework.argDB and self.framework.argDB['with-dynamic-loading']\n    if not self.framework.argDB['with-pic'] and not useSharedLibraries and not useDynamicLoading:\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n      raise RuntimeError('Archiver failed static link check')\n    if 'with-shared-ld' in self.framework.argDB:\n      yield (self.framework.argDB['with-shared-ld'], [], 'so')\n    if 'LD_SHARED' in self.framework.argDB:\n      yield (self.framework.argDB['LD_SHARED'], [], 'so')\n    if Configure.isDarwin():\n      if 'with-shared-ld' in self.framework.argDB:\n        yield (self.framework.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      #yield ('libtool', ['-noprebind','-dynamic','-single_module','-flat_namespace -undefined warning','-multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n#        yield (\"g++\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n#      yield (\"gcc\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      # C++ compiler default\n      yield (self.CXX, ['-shared'], 'so')\n      yield (self.CXX, ['-dynamic'], 'so')\n    # C compiler default\n    yield (self.CC, ['-shared'], 'so')\n    yield (self.CC, ['-dynamic'], 'so')\n    yield (self.CC, ['-qmkshrobj'], 'so')\n    # Solaris default\n    if Configure.isSolaris():\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-G'], 'so')\n      yield (self.CC, ['-G'], 'so')\n    # Default to static linker\n    self.setStaticLinker()\n    self.staticLinker = self.AR\n    self.staticLibraries = 1\n    self.LDFLAGS = ''\n    yield (self.AR, [], self.AR_LIB_SUFFIX)\n    raise RuntimeError('Archiver failed static link check')\n\n  def checkSharedLinker(self):\n    '''Check that the linker can produce shared libraries'''\n    self.sharedLibraries = 0\n    self.staticLibraries = 0\n    for linker, flags, ext in self.generateSharedLinkerGuesses():\n      self.logPrint('Checking shared linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'LD_SHARED'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = filter(self.checkLinkerFlag, flags)\n        testMethod = 'foo'\n        self.sharedLinker = self.LD_SHARED\n        self.sharedLibraryFlags = goodFlags\n        self.sharedLibraryExt = ext\n        # using printf appears to correctly identify non-pic code on X86_64\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"hello\");\\nreturn 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 1):\n          oldLib  = self.linkerObj\n          oldLibs = self.LIBS\n          self.LIBS += ' -L'+self.tmpDir+' -lconftest'\n          if self.checkLink(includes = 'int foo(void);', body = 'int ret = foo();\\nif(ret);'):\n            os.remove(oldLib)\n            self.LIBS = oldLibs\n            self.sharedLibraries = 1\n            self.logPrint('Using shared linker '+self.sharedLinker+' with flags '+str(self.sharedLibraryFlags)+' and library extension '+self.sharedLibraryExt)\n            break\n          os.remove(oldLib)\n          self.LIBS = oldLibs\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        self.delMakeMacro('LD_SHARED')\n        del self.LD_SHARED\n        del self.sharedLinker\n    return\n\n  def checkLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag'''\n    flagsArg = self.getLinkerFlagsArg()\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, status) = self.outputLink('', '')\n    valid = 1\n    if status:\n      valid = 0\n      self.framework.logPrint('Rejecting linker flag '+flag+' due to nonzero status from link')\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.framework.logPrint('Rejecting '+self.language[-1]+' linker flag '+flag+' due to \\n'+output)\n    if valid:\n      self.framework.logPrint('Valid '+self.language[-1]+' linker flag '+flag)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def addLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkLinkerFlag(flag):\n      flagsArg = self.getLinkerFlagsArg()\n      setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n      return\n    raise RuntimeError('Bad linker flag: '+flag)\n\n  def checkLinkerMac(self):\n    '''Tests some Apple Mac specific linker flags'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Wl,-multiply_defined,suppress', '-Wl,-multiply_defined -Wl,suppress', '-Wl,-commons,use_dylibs', '-Wl,-search_paths_first']:\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n\t  linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n\t  val.append(testFlag)\n\t  setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkSharedLinkerPaths(self):\n    '''Determine the shared linker path options\n       - IRIX: -rpath\n       - Linux, OSF: -Wl,-rpath,\n       - Solaris: -R\n       - FreeBSD: -Wl,-R,'''\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    for language in languages:\n      flag = '-L'\n      self.pushLanguage(language)\n      # test '-R' before '-rpath' as sun compilers [c,fortran] don't give proper errors with wrong options.\n      if not Configure.isDarwin():\n        testFlags = ['-Wl,-rpath,', '-R','-rpath ' , '-Wl,-R,']\n      else:\n        testFlags = []\n      # test '-R' before '-Wl,-rpath' for SUN compilers [as cc on linux accepts -Wl,-rpath, but  f90 & CC do not.\n      if self.isSun(self.framework.getCompiler()):\n        testFlags.insert(0,'-R')\n      for testFlag in testFlags:\n        self.framework.logPrint('Trying '+language+' linker flag '+testFlag)\n        if self.checkLinkerFlag(testFlag+os.path.abspath(os.getcwd())):\n          flag = testFlag\n          break\n        else:\n          self.framework.logPrint('Rejected '+language+' linker flag '+testFlag)\n      self.popLanguage()\n      setattr(self, language+'SharedLinkerFlag', flag)\n    return\n\n  def checkLibC(self):\n    '''Test whether we need to explicitly include libc in shared linking\n       - Mac OSX requires an explicit reference to libc for shared linking'''\n    self.explicitLibc = None\n    if self.staticLibraries:\n      return\n    tmpCompilerDefines   = self.compilerDefines\n    self.compilerDefines = ''\n    code = '#include <stdlib.h> \\nint foo(void) {void *chunk = malloc(31); free(chunk); return 0;}\\n'\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking does not require an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      return\n    oldLibs = self.LIBS\n    self.LIBS += '-lc '\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking requires an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      self.explicitLibc = ['libc.so']\n      return\n    self.LIBS = oldLibs\n    self.compilerDefines = tmpCompilerDefines\n    self.logPrint('*** WARNING *** Shared linking may not function on this architecture')\n    self.staticLibrary=1\n    self.sharedLibrary=0\n\n  def generateDynamicLinkerGuesses(self):\n    if 'with-dynamic-ld' in self.framework.argDB:\n      yield (self.framework.argDB['with-dynamic-ld'], [], 'so')\n    # Mac OSX\n    if Configure.isDarwin():\n      if 'with-dynamic-ld' in self.framework.argDB:\n        yield (self.framework.argDB['with-dynamic-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      #yield ('libtool', ['-noprebind','-dynamic','-single_module','-flat_namespace -undefined warning','-multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n#        yield (\"g++\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n#      yield (\"gcc\", ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress'], 'dylib')\n    # Shared default\n    if hasattr(self, 'sharedLinker'):\n      yield (self.sharedLinker, self.sharedLibraryFlags, 'so')\n    # C++ Compiler default\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      yield (self.CXX, ['-shared'], 'so')\n    # C Compiler default\n    yield (self.CC, ['-shared'], 'so')\n    self.logPrint('Unable to find working dynamic linker')\n\n  def checkDynamicLinker(self):\n    '''Check that the linker can dynamicaly load shared libraries'''\n    self.dynamicLibraries = 0\n    if not self.headers.check('dlfcn.h'):\n      self.logPrint('Dynamic loading disabled since dlfcn.h was missing')\n      return\n    if not self.libraries.add('dl', ['dlopen', 'dlsym', 'dlclose']):\n      if not self.libraries.check('', ['dlopen', 'dlsym', 'dlclose']):\n        self.logPrint('Dynamic linking disabled since functions dlopen(), dlsym(), and dlclose() were not found')\n        return\n    for linker, flags, ext in self.generateDynamicLinkerGuesses():\n      self.logPrint('Checking dynamic linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'dynamicLinker'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = filter(self.checkLinkerFlag, flags)\n        self.dynamicLibraryFlags = goodFlags\n        self.dynamicLibraryExt = ext\n        testMethod = 'foo'\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"test\");return 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 'dynamic'):\n          oldLib  = self.linkerObj\n          code = '''\nvoid *handle = dlopen(\"%s\", 0);\nint (*foo)(void) = (int (*)(void)) dlsym(handle, \"foo\");\n\nif (!foo) {\n  printf(\"Could not load symbol\\\\n\");\n  return -1;\n}\nif ((*foo)()) {\n  printf(\"Invalid return from foo()\\\\n\");\n  return -1;\n}\nif (dlclose(handle)) {\n  printf(\"Could not close library\\\\n\");\n  return -1;\n}\n''' % oldLib\n          if self.checkLink(includes = '#include<dlfcn.h>', body = code):\n            os.remove(oldLib)\n            self.dynamicLibraries = 1\n            self.logPrint('Using dynamic linker '+self.dynamicLinker+' with flags '+str(self.dynamicLibraryFlags)+' and library extension '+self.dynamicLibraryExt)\n            break\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        del self.dynamicLinker\n    return\n\n  def output(self):\n    '''Output module data as defines and substitutions'''\n    if hasattr(self, 'CC'):\n      self.addSubstitution('CC', self.CC)\n      self.addSubstitution('CFLAGS', self.CFLAGS)\n      self.addMakeMacro('CC_LINKER_SLFLAG', self.CSharedLinkerFlag)\n    if hasattr(self, 'CPP'):\n      self.addSubstitution('CPP', self.CPP)\n      self.addSubstitution('CPPFLAGS', self.CPPFLAGS)\n    if hasattr(self, 'CUDAC'):\n      self.addSubstitution('CUDAC', self.CUDAC)\n      self.addSubstitution('CUDAFLAGS', self.CUDAFLAGS)\n    if hasattr(self, 'CUDAPP'):\n      self.addSubstitution('CUDAPP', self.CUDAPP)\n      self.addSubstitution('CUDAPPFLAGS', self.CUDAPPFLAGS)\n    if hasattr(self, 'CXX'):\n      self.addSubstitution('CXX', self.CXX)\n      self.addSubstitution('CXX_CXXFLAGS', self.CXX_CXXFLAGS)\n      self.addSubstitution('CXXFLAGS', self.CXXFLAGS)\n      self.addSubstitution('CXX_LINKER_SLFLAG', self.CxxSharedLinkerFlag)\n    else:\n      self.addSubstitution('CXX', '')\n    if hasattr(self, 'CXXCPP'):\n      self.addSubstitution('CXXCPP', self.CXXCPP)\n      self.addSubstitution('CXXCPPFLAGS', self.CXXCPPFLAGS)\n    if hasattr(self, 'FC'):\n      self.addSubstitution('FC', self.FC)\n      self.addSubstitution('FFLAGS', self.FFLAGS)\n      self.addMakeMacro('FC_LINKER_SLFLAG', self.FCSharedLinkerFlag)\n    else:\n      self.addSubstitution('FC', '')\n    self.addSubstitution('LDFLAGS', self.LDFLAGS)\n    self.addSubstitution('LIBS', self.LIBS)\n    if hasattr(self, 'sharedLibraryFlags'):\n      self.addSubstitution('SHARED_LIBRARY_FLAG', ' '.join(self.sharedLibraryFlags))\n    else:\n      self.addSubstitution('SHARED_LIBRARY_FLAG','')\n    return\n\n  def updateMPICompilers(self, mpicc, mpicxx, mpifc):\n    '''Reset compilers by an external module aka MPI'''\n    self.CC = mpicc\n    self.delMakeMacro(\"CC\")\n\n    if hasattr(self, 'CXX'):\n      self.CXX = mpicxx\n      self.delMakeMacro(\"CXX\")\n\n    if hasattr(self, 'FC'):\n      self.FC = mpifc\n      self.delMakeMacro(\"FC\")\n\n    self.configure()\n    self.usedMPICompilers=1\n    return\n\n  def checkMPICompilerOverride(self):\n    '''Check if --with-mpi-dir is used along with CC CXX or FC compiler options.\n    This usually prevents mpi compilers from being used - so issue a warning'''\n\n    if 'with-mpi-dir' in self.argDB and self.argDB['with-mpi-compilers']:\n      optcplrs = [(['with-cc','CC'],['mpicc','mpcc','hcc','mpcc_r']),\n              (['with-fc','FC'],['mpif90','mpif77','mpxlf95_r','mpxlf90_r','mpxlf_r','mpf90','mpf77']),\n              (['with-cxx','CXX'],['mpicxx','hcp','mpic++','mpiCC','mpCC_r'])]\n      for opts,cplrs in optcplrs:\n        for opt in opts:\n          if (opt in self.argDB  and self.argDB[opt] != '0'):\n            # check if corresponding mpi wrapper exists\n            for cplr in cplrs:\n              mpicplr = os.path.join(self.framework.argDB['with-mpi-dir'], 'bin', cplr)\n              if os.path.exists(mpicplr):\n                msg = '--'+opt+'='+self.argDB[opt]+' is specified with --with-mpi-dir='+self.framework.argDB['with-mpi-dir']+'. However '+mpicplr+' exists and should be the prefered compiler! Suggest not specifying --'+opt+' option so that configure can use '+ mpicplr +' instead.'\n                raise RuntimeError(msg)\n    return\n\n  def requireMpiLdPath(self):\n    '''OpenMPI wrappers require LD_LIBRARY_PATH set'''\n    if 'with-mpi-dir' in self.argDB:\n      libdir = os.path.join(self.argDB['with-mpi-dir'], 'lib')\n      if os.path.exists(os.path.join(libdir,'libopen-rte.so')):\n        Configure.addLdPath(libdir)\n        self.logPrint('Adding to LD_LIBRARY_PATH '+libdir)\n    return\n\n  def printEnvVariables(self):\n    buf = '**** printenv ****'\n    for key,val in os.environ.iteritems():\n      buf += '\\n'+str(key)+'='+str(val)\n    self.logPrint(buf)\n    return\n\n  def resetEnvCompilers(self):\n    ignoreEnv = ['CC','CFLAGS','CXX','CXXFLAGS','FC','FCFLAGS','F77','FFLAGS',\n                 'F90','F90FLAGS','CPP','CPPFLAGS','CXXCPP','CXXCPPFLAGS',\n                 'LDFLAGS','LIBS','MPI_DIR','RM']\n    for envVal in ignoreEnv:\n      if envVal in os.environ:\n        self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n        del os.environ[envVal]\n    return\n\n  def configure(self):\n    self.executeTest(self.printEnvVariables)\n    self.executeTest(self.resetEnvCompilers)\n    self.executeTest(self.checkMPICompilerOverride)\n    self.executeTest(self.requireMpiLdPath)\n    self.executeTest(self.checkVendor)\n    self.executeTest(self.checkInitialFlags)\n    self.executeTest(self.checkCCompiler)\n    self.executeTest(self.checkCPreprocessor)\n    self.executeTest(self.checkCUDACompiler)\n    self.executeTest(self.checkCUDAPreprocessor)\n    self.executeTest(self.checkCxxCompiler)\n    if hasattr(self, 'CXX'):\n      self.executeTest(self.checkCxxPreprocessor)\n    self.executeTest(self.checkFortranCompiler)\n    if hasattr(self, 'FC'):\n      self.executeTest(self.checkFortranComments)\n    self.executeTest(self.checkPIC)\n    self.executeTest(self.checkLargeFileIO)\n    self.executeTest(self.checkArchiver)\n    self.executeTest(self.checkSharedLinker)\n    if Configure.isDarwin():\n      self.executeTest(self.checkLinkerMac)\n    self.executeTest(self.checkSharedLinkerPaths)\n    self.executeTest(self.checkLibC)\n    self.executeTest(self.checkDynamicLinker)\n    self.executeTest(self.output)\n    return\n\n  def no_configure(self):\n    if self.staticLibraries:\n      self.setStaticLinker()\n    return\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/sys/webserver/webserve.c": "\n#include <petscsys.h>\n#include <sys/stat.h>\n#if defined(PETSC_HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(PETSC_NEED_CLOSE_PROTO)\nPETSC_EXTERN int close(int);\n#endif\nPETSC_INTERN PetscErrorCode PetscSocketEstablish(int,int*);\nPETSC_INTERN PetscErrorCode PetscSocketListen(int,int*);\n\n/*\n      Implements a crude webserver allowing the snooping on running application codes.\n\n     Developer Notes: Most of this code, including the webserver, perhaps, belongs properly in the AMS with perhaps a few hooks\n      for application/libraries like PETSc to interact with it.\n*/\n#include <pthread.h>\n#include <time.h>\n#define PROTOCOL   \"HTTP/1.1\"\n#define RFC1123FMT \"%a, %d %b %Y %H:%M:%S GMT\"\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebSendHeader\"\nPetscErrorCode PetscWebSendHeader(FILE *f, int status, const char *title, const char *extra, const char *mime, int length)\n{\n  time_t now;\n  char   timebuf[128];\n\n  PetscFunctionBegin;\n  fprintf(f, \"%s %d %s\\r\\n\", PROTOCOL, status, title);\n  fprintf(f, \"Server: %s\\r\\n\", \"petscserver/1.0\");\n  now = time(NULL);\n  strftime(timebuf, sizeof(timebuf), RFC1123FMT, gmtime(&now));\n  fprintf(f, \"Date: %s\\r\\n\", timebuf);\n  if (extra) fprintf(f, \"%s\\r\\n\", extra);\n  if (mime) fprintf(f, \"Content-Type: %s\\r\\n\", mime);\n  if (length >= 0) fprintf(f, \"Content-Length: %d\\r\\n\", length);\n  fprintf(f, \"Connection: close\\r\\n\");\n  fprintf(f, \"\\r\\n\");\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebSendFooter\"\nPetscErrorCode PetscWebSendFooter(FILE *fd)\n{\n  PetscFunctionBegin;\n  fprintf(fd, \"</BODY></HTML>\\r\\n\");\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebSendError\"\nPetscErrorCode PetscWebSendError(FILE *f, int status, const char *title, const char *extra, const char *text)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscWebSendHeader(f, status, title, extra, \"text/html\", -1);CHKERRQ(ierr);\n  fprintf(f, \"<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\\r\\n\", status, title);\n  fprintf(f, \"<BODY><H4>%d %s</H4>\\r\\n\", status, title);\n  fprintf(f, \"%s\\r\\n\", text);\n  ierr = PetscWebSendFooter(f);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#include <petscviewerams.h>\n#undef __FUNCT__\n#define __FUNCT__ \"PetscAMSObjectsDisplayList\"\n/*\n    Displays all the PETSc objects published with AMS in a simple HTML list\n\n    Does NOT use Javascript or JSON-RPC\n*/\nstatic PetscErrorCode PetscAMSObjectsDisplayList(FILE *fd)\n{\n  PetscErrorCode     ierr;\n  char               host[256],**comm_list,**mem_list,**fld_list;\n  AMS_Comm           ams;\n  PetscInt           i = 0,j;\n  AMS_Memory_type    mtype;\n  AMS_Data_type      dtype;\n  AMS_Shared_type    stype;\n  AMS_Reduction_type rtype;\n  AMS_Memory         memory;\n  int                len;\n  void               *addr;\n  PetscBool          stack;\n\n  ierr = PetscGetHostName(host,256);CHKERRQ(ierr);\n  ierr = AMS_Connect(host, -1, &comm_list);\n  ierr = PetscWebSendHeader(fd, 200, \"OK\", NULL, \"text/html\", -1);CHKERRQ(ierr);\n  if (!comm_list || !comm_list[0]) fprintf(fd, \"AMS Communicator not running</p>\\r\\n\");\n  else {\n    ierr = AMS_Comm_attach(comm_list[0],&ams);\n    ierr = AMS_Comm_get_memory_list(ams,&mem_list);\n    if (!mem_list[0]) fprintf(fd, \"AMS Communicator %s has no published memories</p>\\r\\n\",comm_list[0]);\n    else {\n      fprintf(fd, \"<HTML><HEAD><TITLE>Petsc Application Server</TITLE></HEAD>\\r\\n<BODY>\");\n      fprintf(fd,\"<ul>\\r\\n\");\n      while (mem_list[i]) {\n        ierr = PetscStrcmp(mem_list[i],\"Stack\",&stack);CHKERRQ(ierr);\n        if (stack) {i++; continue;}\n        fprintf(fd,\"<li> %s</li>\\r\\n\",mem_list[i]);\n        ierr = AMS_Memory_attach(ams,mem_list[i],&memory,NULL);\n        ierr = AMS_Memory_get_field_list(memory, &fld_list);\n        j    = 0;\n        fprintf(fd,\"<ul>\\r\\n\");\n        while (fld_list[j]) {\n          fprintf(fd,\"<li> %s\",fld_list[j]);\n          ierr = AMS_Memory_get_field_info(memory, fld_list[j], &addr, &len, &dtype, &mtype, &stype, &rtype);\n          if (len == 1) {\n            if (dtype == AMS_INT)         fprintf(fd,\" %d\",*(int*)addr);\n            else if (dtype == AMS_STRING) fprintf(fd,\" %s\",*(char**)addr);\n          }\n          fprintf(fd,\"</li>\\r\\n\");\n          j++;\n        }\n        fprintf(fd,\"</ul>\\r\\n\");\n        i++;\n      }\n      fprintf(fd,\"</ul>\\r\\n\");\n    }\n  }\n  ierr = PetscWebSendFooter(fd);CHKERRQ(ierr);\n  ierr = AMS_Disconnect();\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscAMSObjectsDisplayTree\"\n/*\n    Displays all the PETSc objects published with AMS in very crude HTML 5 graphics\n\n    Does NOT use Javascript or JSON-RPC\n*/\nstatic PetscErrorCode PetscAMSObjectsDisplayTree(FILE *fd)\n{\n  PetscErrorCode     ierr;\n  char               host[256],**comm_list,**mem_list,**fld_list;\n  AMS_Comm           ams;\n  PetscInt           i = 0,j;\n  AMS_Memory_type    mtype;\n  AMS_Data_type      dtype;\n  AMS_Shared_type    stype;\n  AMS_Reduction_type rtype;\n  AMS_Memory         memory;\n  int                len;\n  void               *addr2,*addr3,*addr,*addr4;\n  PetscBool          stack;\n\n  ierr = PetscGetHostName(host,256);CHKERRQ(ierr);\n  ierr = AMS_Connect(host, -1, &comm_list);\n  ierr = PetscWebSendHeader(fd, 200, \"OK\", NULL, \"text/html\", -1);CHKERRQ(ierr);\n  if (!comm_list || !comm_list[0]) fprintf(fd, \"AMS Communicator not running</p>\\r\\n\");\n  else {\n    ierr = AMS_Comm_attach(comm_list[0],&ams);\n    ierr = AMS_Comm_get_memory_list(ams,&mem_list);\n    if (!mem_list[0]) fprintf(fd, \"AMS Communicator %s has no published memories</p>\\r\\n\",comm_list[0]);\n    else {\n      PetscInt  Nlevels,*Level,*Levelcnt,*Idbylevel,*Column,*parentid,*Id,maxId = 0,maxCol = 0,*parentId,id,cnt,Nlevelcnt = 0;\n      PetscBool *mask;\n      char      **classes,*clas,**subclasses,*sclas;\n\n      /* get maximum number of objects */\n      while (mem_list[i]) {\n        ierr = PetscStrcmp(mem_list[i],\"Stack\",&stack);CHKERRQ(ierr);\n        if (stack) {i++; continue;}\n        ierr = AMS_Memory_attach(ams,mem_list[i],&memory,NULL);\n        ierr = AMS_Memory_get_field_list(memory, &fld_list);\n        ierr = AMS_Memory_get_field_info(memory, \"Id\", &addr2, &len, &dtype, &mtype, &stype, &rtype);\n        Id    = (int*) addr2;\n        maxId = PetscMax(maxId,*Id);\n        i++;\n      }\n      maxId++;\n\n      /* Gets everyone's parent ID and which nodes are masked */\n      ierr = PetscMalloc4(maxId,PetscInt,&parentid,maxId,PetscBool,&mask,maxId,char**,&classes,maxId,char**,&subclasses);CHKERRQ(ierr);\n      ierr = PetscMemzero(classes,maxId*sizeof(char*));CHKERRQ(ierr);\n      ierr = PetscMemzero(subclasses,maxId*sizeof(char*));CHKERRQ(ierr);\n      for (i=0; i<maxId; i++) mask[i] = PETSC_TRUE;\n      i = 0;\n      while (mem_list[i]) {\n        ierr = PetscStrcmp(mem_list[i],\"Stack\",&stack);CHKERRQ(ierr);\n        if (stack) {i++; continue;}\n        ierr = AMS_Memory_attach(ams,mem_list[i],&memory,NULL);\n        ierr = AMS_Memory_get_field_list(memory, &fld_list);\n        ierr = AMS_Memory_get_field_info(memory, \"Id\", &addr2, &len, &dtype, &mtype, &stype, &rtype);\n        Id            = (int*) addr2;\n        ierr = AMS_Memory_get_field_info(memory, \"ParentId\", &addr3, &len, &dtype, &mtype, &stype, &rtype);\n        parentId      = (int*) addr3;\n        ierr = AMS_Memory_get_field_info(memory, \"Class\", &addr, &len, &dtype, &mtype, &stype, &rtype);\n        clas          = *(char**)addr;\n        ierr = AMS_Memory_get_field_info(memory, \"Type\", &addr4, &len, &dtype, &mtype, &stype, &rtype);\n        sclas         = *(char**)addr4;\n        parentid[*Id] = *parentId;\n        mask[*Id]     = PETSC_FALSE;\n\n        ierr = PetscStrallocpy(clas,classes+*Id);CHKERRQ(ierr);\n        ierr = PetscStrallocpy(sclas,subclasses+*Id);CHKERRQ(ierr);\n        i++;\n      }\n\n      /* if the parent is masked then relabel the parent as 0 since the true parent was deleted */\n      for (i=0; i<maxId; i++) {\n        if (!mask[i] && parentid[i] > 0 && mask[parentid[i]]) parentid[i] = 0;\n      }\n\n      ierr = PetscProcessTree(maxId,mask,parentid,&Nlevels,&Level,&Levelcnt,&Idbylevel,&Column);CHKERRQ(ierr);\n\n      for (i=0; i<Nlevels; i++) maxCol    = PetscMax(maxCol,Levelcnt[i]);\n      for (i=0; i<Nlevels; i++) Nlevelcnt = PetscMax(Nlevelcnt,Levelcnt[i]);\n\n      /* print all the top-level objects */\n      fprintf(fd, \"<HTML><HEAD><TITLE>Petsc Application Server</TITLE>\\r\\n\");\n      fprintf(fd, \"<canvas width=800 height=600 id=\\\"tree\\\"></canvas>\\r\\n\");\n      fprintf(fd, \"<script type=\\\"text/javascript\\\">\\r\\n\");\n      fprintf(fd, \"  function draw() {\\r\\n\");\n      fprintf(fd, \"  var example = document.getElementById('tree');\\r\\n\");\n      fprintf(fd, \"  var context = example.getContext('2d');\\r\\n\");\n      /* adjust font size based on how big a tree is printed */\n      if (Nlevels > 5 || Nlevelcnt > 10) fprintf(fd, \"  context.font         = \\\"normal 12px sans-serif\\\";\\r\\n\");\n      else                               fprintf(fd, \"  context.font         = \\\"normal 24px sans-serif\\\";\\r\\n\");\n      fprintf(fd, \"  context.fillStyle = \\\"rgb(255,0,0)\\\";\\r\\n\");\n      fprintf(fd, \"  context.textBaseline = \\\"top\\\";\\r\\n\");\n      fprintf(fd, \"  var xspacep = 0;\\r\\n\");\n      fprintf(fd, \"  var yspace = example.height/%d;\\r\\n\",(Nlevels+1));\n      /* estimate the height of a string as twice the width of a character */\n      fprintf(fd, \"  var wheight = context.measureText(\\\"K\\\");\\r\\n\");\n      fprintf(fd, \"  var height = 1.6*wheight.width;\\r\\n\");\n\n      cnt = 0;\n      for (i=0; i<Nlevels; i++) {\n        fprintf(fd, \"  var xspace = example.width/%d;\\r\\n\",Levelcnt[i]+1);\n        for (j=0; j<Levelcnt[i]; j++) {\n          id    = Idbylevel[cnt++];\n          clas  = classes[id];\n          sclas = subclasses[id];\n          fprintf(fd, \"  var width = context.measureText(\\\"%s\\\");\\r\\n\",clas);\n          fprintf(fd, \"  var swidth = context.measureText(\\\"%s\\\");\\r\\n\",sclas);\n          fprintf(fd, \"  context.fillStyle = \\\"rgb(255,0,0)\\\";\\r\\n\");\n          fprintf(fd, \"  context.fillRect((%d)*xspace-width.width/2, %d*yspace-height/2, width.width, height);\\r\\n\",j+1,i+1);\n          fprintf(fd, \"  context.fillRect((%d)*xspace-swidth.width/2, %d*yspace+height/2, swidth.width, height);\\r\\n\",j+1,i+1);\n          fprintf(fd, \"  context.fillStyle = \\\"rgb(0,0,0)\\\";\\r\\n\");\n          fprintf(fd, \"  context.fillText(\\\"%s\\\",(%d)*xspace-width.width/2, %d*yspace-height/2);\\r\\n\",clas,j+1,i+1);\n          fprintf(fd, \"  context.fillText(\\\"%s\\\",(%d)*xspace-swidth.width/2, %d*yspace+height/2);\\r\\n\",sclas,j+1,i+1);\n          if (parentid[id]) {\n            fprintf(fd, \"  context.moveTo(%d*xspace,%d*yspace-height/2);\\r\\n\",j+1,i+1);\n            fprintf(fd, \"  context.lineTo(%d*xspacep,%d*yspace+3*height/2);\\r\\n\",Column[parentid[id]]+1,i);\n            fprintf(fd, \"  context.stroke();\\r\\n\");\n          }\n        }\n        fprintf(fd, \"  xspacep = xspace;\\r\\n\");\n      }\n      ierr = PetscFree(Level);CHKERRQ(ierr);\n      ierr = PetscFree(Levelcnt);CHKERRQ(ierr);\n      ierr = PetscFree(Idbylevel);CHKERRQ(ierr);\n      ierr = PetscFree(Column);CHKERRQ(ierr);\n      for (i=0; i<maxId; i++) {\n        ierr = PetscFree(classes[i]);CHKERRQ(ierr);\n        ierr = PetscFree(subclasses[i]);CHKERRQ(ierr);\n      }\n      ierr = PetscFree4(mask,parentid,classes,subclasses);CHKERRQ(ierr);\n\n      ierr = AMS_Disconnect();\n      fprintf(fd, \"}\\r\\n\");\n      fprintf(fd, \"</script>\\r\\n\");\n      fprintf(fd, \"<body onload=\\\"draw();\\\">\\r\\n\");\n      fprintf(fd, \"</body></html>\\r\\n\");\n    }\n  }\n  ierr = PetscWebSendFooter(fd);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebServeRequestGet\"\n/*@C\n      PetscWebServeRequestGet - serves a single web Get request\n\n    Not collective\n\n  Input Parameters:\n+   port - the network file to read and write from\n-   path - the command from the server\n\n    Level: developer\n\n.seealso: PetscWebServe()\n@*/\nstatic PetscErrorCode  PetscWebServeRequestGet(FILE *fd,const char path[])\n{\n  PetscErrorCode ierr;\n  FILE           *fdo;\n  char           fullpath[PETSC_MAX_PATH_LEN],truefullpath[PETSC_MAX_PATH_LEN],*qmark;\n  const char     *type;\n  PetscBool      flg;\n\n  PetscFunctionBegin;\n  fseek(fd, 0, SEEK_CUR); /* Force change of stream direction */\n\n  ierr = PetscStrcmp(path,\"/favicon.ico\",&flg);CHKERRQ(ierr);\n  if (flg) {\n    /* should have cool PETSc icon */;\n    PetscFunctionReturn(0);\n  }\n  ierr = PetscStrcmp(path,\"/\",&flg);CHKERRQ(ierr);\n  if (flg) {\n    char        program[128];\n    PetscMPIInt size;\n    PetscViewer viewer;\n\n    ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRQ(ierr);\n    ierr = PetscGetProgramName(program,128);CHKERRQ(ierr);\n    ierr = PetscWebSendHeader(fd, 200, \"OK\", NULL, \"text/html\", -1);CHKERRQ(ierr);\n    fprintf(fd, \"<HTML><HEAD><TITLE>Petsc Application Server</TITLE></HEAD>\\r\\n<BODY>\");\n    fprintf(fd, \"<H4>Serving PETSc application code %s </H4>\\r\\n\\n\",program);\n    fprintf(fd, \"Number of processes %d\\r\\n\\n\",size);\n    fprintf(fd, \"<HR>\\r\\n\");\n    ierr = PetscViewerASCIIOpenWithFILE(PETSC_COMM_WORLD,fd,&viewer);CHKERRQ(ierr);\n    ierr = PetscOptionsView(viewer);CHKERRQ(ierr);\n    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);\n    fprintf(fd, \"<HR>\\r\\n\");\n    fprintf(fd, \"<a href=\\\"./ams-tree\\\">View published PETSc objects -- As a static graphical tree</a></p>\\r\\n\\r\\n\");\n    fprintf(fd, \"<a href=\\\"./ams-list\\\">View published PETSc objects -- As a static list</a></p>\\r\\n\\r\\n\");\n    fprintf(fd, \"<a href=\\\"./AMSSnoopObjects.html\\\">Snoop on published PETSc objects --Interactive Javascript</a></p>\\r\\n\\r\\n\");\n    fprintf(fd, \"<a href=\\\"./AMSSnoopStack.html\\\">Snoop on published PETSc stackframes --Interactive Javascript</a></p>\\r\\n\\r\\n\");\n    ierr = PetscWebSendFooter(fd);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n\n  ierr = PetscStrcmp(path,\"/ams-list\",&flg);CHKERRQ(ierr);\n  if (flg) {\n    ierr = PetscAMSObjectsDisplayList(fd);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = PetscStrcmp(path,\"/ams-tree\",&flg);CHKERRQ(ierr);\n  if (flg) {\n    ierr = PetscAMSObjectsDisplayTree(fd);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = PetscStrcpy(fullpath,\"${PETSC_DIR}/include/web\");CHKERRQ(ierr);\n  ierr = PetscStrcat(fullpath,path);CHKERRQ(ierr);\n  ierr = PetscInfo1(NULL,\"Checking for file %s\\n\",fullpath);CHKERRQ(ierr);\n  ierr = PetscStrstr(fullpath,\"?\",&qmark);CHKERRQ(ierr);\n  if (qmark) *qmark = 0;\n  ierr = PetscStrreplace(PETSC_COMM_SELF,fullpath,truefullpath,PETSC_MAX_PATH_LEN);CHKERRQ(ierr);\n  fdo  = fopen(truefullpath,\"r\");\n  if (fdo) {\n    PetscInt    length,index;\n    char        data[4096];\n    struct stat statbuf;\n    int         n;\n    const char  *suffixes[] = {\".html\",\".js\",\".gif\",0}, *mimes[] = {\"text/html\",\"text/javascript\",\"image/gif\",\"text/unknown\"};\n\n    ierr = PetscStrendswithwhich(fullpath,suffixes,&index);CHKERRQ(ierr);\n    type = mimes[index];\n    if (!stat(truefullpath, &statbuf)) length = -1;\n    else length = S_ISREG(statbuf.st_mode) ? statbuf.st_size : -1;\n    ierr = PetscWebSendHeader(fd, 200, \"OK\", NULL, type, length);CHKERRQ(ierr);\n    while ((n = fread(data, 1, sizeof(data), fdo)) > 0) fwrite(data, 1, n, fd);\n    fclose(fdo);\n    ierr = PetscInfo2(NULL,\"Sent file %s to browser using format %s\\n\",fullpath,type);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = PetscWebSendError(fd, 501, \"Not supported\", NULL, \"Unknown request.\");CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*\n    Toy YAML/JSON-RPC function that returns all the arguments it is passed\n*/\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_echo\"\nPETSC_UNUSED static PetscErrorCode YAML_echo(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  PetscInt       i;\n\n  ierr = PetscPrintf(PETSC_COMM_SELF,\"Number of arguments to function %d\\n\",argc);CHKERRQ(ierr);\n  for (i=0; i<argc; i++) {\n    ierr = PetscPrintf(PETSC_COMM_SELF,\"  %s\\n\",args[i]);CHKERRQ(ierr);\n  }\n  *argco = argc;\n  ierr   = PetscMalloc(argc*sizeof(char*),argso);CHKERRQ(ierr);\n  for (i=0; i<argc; i++) {\n    ierr = PetscStrallocpy(args[i],&(*argso)[i]);CHKERRQ(ierr);\n  }\n  PetscFunctionReturn(0);\n}\n\n/* -------------------------------------------------------------------------------------------\n     The following set of functions are wrapper functions for AMS functions that\n\n    1)  convert from string arguments to appropriate AMS arguments (int, double, char*, etc)\n    2)  call the AMS function\n    3)  convert from the AMS result arguments to string arguments\n\n    Developers Note: Rather than having PetscProcessYAMLRPC() convert the YAML/JSON representation of the params to an array of strings\n       it may be better to simple pass those YAML/JSON strings to these routines and have them pull out the values from the YAML/JSON\n       Similarly these routines could put their result directly back into YAML/JSON rather than putting them into an array of strings\n       returning that and having PetscProcessYAMLRPC() put them into the YAML/JSON.\n*/\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Utility_StringToArray\"\nstatic PetscErrorCode YAML_AMS_Utility_StringToArray(const char *instring,AMS_Data_type dtype,PetscInt *n,void **addr)\n{\n  PetscErrorCode ierr;\n  char           *bracket,*sub;\n  PetscInt       N;\n  PetscToken     token;\n  char           *string,*cstring;\n\n  PetscFunctionBegin;\n  ierr = PetscStrallocpy(instring,&cstring);CHKERRQ(ierr);\n  ierr = PetscStrchr(instring,'[',&bracket);CHKERRQ(ierr);\n  if (bracket) {\n    string = bracket + 1;\n    ierr = PetscStrchr(instring,']',&bracket);CHKERRQ(ierr);\n    if (bracket) *bracket = 0;\n  } else string = cstring;\n\n  N = 0;\n  ierr = PetscTokenCreate(string,',',&token);CHKERRQ(ierr);\n  ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n  while (sub) {\n    ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n    N++;\n  }\n  ierr = PetscTokenDestroy(&token);CHKERRQ(ierr);\n  ierr = PetscInfo2(NULL,\"String value %s number of entries in array %d\\n\",string,(int)N);CHKERRQ(ierr);\n  ierr = PetscTokenCreate(string,',',&token);CHKERRQ(ierr);\n  ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n\n  if (dtype == AMS_STRING) {\n    char **caddr;\n    ierr = PetscMalloc(N*sizeof(char*),&caddr);CHKERRQ(ierr);\n    *addr = (void*) caddr;\n    while (sub) {\n      ierr = PetscStrallocpy(sub,(char**)caddr);CHKERRQ(ierr);\n      ierr = PetscInfo2(NULL,\"String value %s, computed value %s\\n\",sub,*caddr);CHKERRQ(ierr);\n      ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n      caddr++;\n    }\n  } else if (dtype == AMS_BOOLEAN) {\n    PetscBool *baddr;\n    ierr = PetscMalloc(N*sizeof(PetscBool),&baddr);CHKERRQ(ierr);\n    *addr = (void*) baddr;\n    while (sub) {\n      ierr = PetscOptionsStringToBool(sub,baddr);CHKERRQ(ierr);\n      ierr = PetscInfo2(NULL,\"String value %s, computed value %d\\n\",sub,(int)*baddr);CHKERRQ(ierr);\n      ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n      baddr++;\n    }\n  } else if (dtype == AMS_INT) {\n    PetscInt *iaddr;\n    ierr = PetscMalloc(N*sizeof(PetscInt),&iaddr);CHKERRQ(ierr);\n    *addr = (void*) iaddr;\n    while (sub) {\n      sscanf(sub,\"%d\",iaddr);\n      ierr = PetscInfo2(NULL,\"String value %s, computed value %d\\n\",sub,(int)*iaddr);CHKERRQ(ierr);\n      ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n      iaddr++;\n    }\n  } else if (dtype == AMS_DOUBLE) {\n    PetscReal *raddr;\n    ierr = PetscMalloc(N*sizeof(PetscReal),&raddr);CHKERRQ(ierr);\n    *addr = (void*) raddr;\n    while (sub) {\n      sscanf(sub,\"%le\",(double*)raddr);\n      ierr = PetscInfo2(NULL,\"String value %s, computed value %g\\n\",sub,(double)*raddr);CHKERRQ(ierr);\n      ierr = PetscTokenFind(token,&sub);CHKERRQ(ierr);\n      raddr++;\n    }\n  } else {\n    ierr = PetscInfo1(NULL,\"String value %s, datatype not handled\\n\",string);CHKERRQ(ierr);\n  }\n  ierr = PetscTokenDestroy(&token);CHKERRQ(ierr);\n  ierr = PetscFree(cstring);CHKERRQ(ierr);\n  *n   = N;\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Utility_ArrayToString\"\nstatic PetscErrorCode YAML_AMS_Utility_ArrayToString(PetscInt n,void *addr,AMS_Data_type dtype,char **result)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  if (!n) {\n    ierr = PetscStrallocpy(\"null\",result);CHKERRQ(ierr);\n  } else if (n == 1) {\n    if (dtype == AMS_STRING) {\n      ierr = PetscStrallocpy(*(const char**)addr,result);CHKERRQ(ierr);\n    } else if (dtype == AMS_DOUBLE) {\n      ierr = PetscMalloc(20*sizeof(char),result);CHKERRQ(ierr);\n      sprintf(*result,\"%18.16e\",*(double*)addr);\n    } else if (dtype == AMS_INT) {\n      ierr = PetscMalloc(10*sizeof(char),result);CHKERRQ(ierr);\n      sprintf(*result,\"%d\",*(int*)addr);\n    } else if (dtype == AMS_BOOLEAN) {\n      if (*(PetscBool*)addr) {\n        ierr = PetscStrallocpy(\"true\",result);CHKERRQ(ierr);\n      } else {\n        ierr = PetscStrallocpy(\"false\",result);CHKERRQ(ierr);\n      }\n    } else {\n      ierr = PetscStrallocpy(\"Not yet done\",result);CHKERRQ(ierr);\n    }\n  } else {\n    PetscInt i;\n    size_t   len = 0,lent;\n    char     buff[25],**array = (char**)addr;\n\n    if (dtype == AMS_STRING) {\n      for (i=0; i<n; i++) {\n        ierr = PetscStrlen(array[i],&lent);CHKERRQ(ierr);\n        len += lent + 10;\n      }\n      ierr = PetscMalloc(len*sizeof(char),result);CHKERRQ(ierr);\n      ierr = PetscStrcpy(*result,\"[\\\"\");CHKERRQ(ierr);\n      for (i=0; i<n-1; i++) {\n        ierr = PetscStrcat(*result,array[i]);CHKERRQ(ierr);\n        ierr = PetscStrcat(*result,\"\\\",\\\"\");CHKERRQ(ierr);\n      }\n      ierr = PetscStrcat(*result,array[n-1]);CHKERRQ(ierr);\n      ierr = PetscStrcat(*result,\"\\\"]\");CHKERRQ(ierr);\n    } else if (dtype == AMS_DOUBLE) {\n      ierr = PetscMalloc(30*n*sizeof(char),result);CHKERRQ(ierr);\n      ierr = PetscStrcpy(*result,\"[\\\"\");CHKERRQ(ierr);\n      for (i=0; i<n-1; i++) {\n        sprintf(buff,\"%18.16e\",*(double*)addr);\n        ierr = PetscStrcat(*result,buff);CHKERRQ(ierr);\n        ierr = PetscStrcat(*result,\"\\\",\\\"\");CHKERRQ(ierr);\n        addr = (void *) ((char *)addr + sizeof(PetscReal));\n      }\n      sprintf(buff,\"%18.16e\",*(double*)addr);\n      ierr = PetscStrcat(*result,buff);CHKERRQ(ierr);\n      ierr = PetscStrcat(*result,\"\\\"]\");CHKERRQ(ierr);\n    } else if (dtype == AMS_INT) {\n      ierr = PetscMalloc(13*n*sizeof(char),result);CHKERRQ(ierr);\n      ierr = PetscStrcpy(*result,\"[\\\"\");CHKERRQ(ierr);\n      for (i=0; i<n-1; i++) {\n        sprintf(buff,\"%d\",*(int*)addr);\n        ierr = PetscStrcat(*result,buff);CHKERRQ(ierr);\n        ierr = PetscStrcat(*result,\"\\\",\\\"\");CHKERRQ(ierr);\n        addr = (void *) ((char *)addr + sizeof(PetscInt));\n      }\n      sprintf(buff,\"%d\",*(int*)addr);\n      ierr = PetscStrcat(*result,buff);CHKERRQ(ierr);\n      ierr = PetscStrcat(*result,\"\\\"]\");CHKERRQ(ierr);\n    } else if (dtype == AMS_BOOLEAN) {\n      ierr = PetscMalloc(7*n*sizeof(char),result);CHKERRQ(ierr);\n      ierr = PetscStrcpy(*result,\"[\");CHKERRQ(ierr);\n      for (i=0; i<n-1; i++) {\n        ierr = PetscStrcat(*result,*(PetscBool*)addr ? \"\\\"true\\\"\" : \"\\\"false\\\"\");CHKERRQ(ierr);\n        ierr = PetscStrcat(*result,\",\");CHKERRQ(ierr);\n        addr = (void *) ((char *)addr + sizeof(int));\n      }\n      ierr = PetscStrcat(*result,*(PetscBool*)addr ? \"\\\"true\\\"\" : \"\\\"false\\\"\");CHKERRQ(ierr);\n      ierr = PetscStrcat(*result,\"]\");CHKERRQ(ierr);\n    } else {\n      ierr = PetscStrallocpy(\"Not yet done\",result);CHKERRQ(ierr);\n    }\n  }\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Utility_Error\"\nstatic PetscErrorCode YAML_AMS_Utility_Error(PetscInt ier,const char *message,char **err)\n{\n  PetscErrorCode ierr;\n  char           fullmess[128];\n\n  PetscFunctionBegin;\n  ierr = PetscInfo2(NULL,\"%s Error code %d\\n\",message,(int)ier);CHKERRQ(ierr);\n  ierr = PetscSNPrintf(fullmess,128,\"{ \\\"code\\\": \\\"%d\\\", \\\"message\\\": \\\"%s\\\", \\\"data\\\": null }\",1+(int)ier,message);CHKERRQ(ierr);\n  ierr = PetscStrallocpy(fullmess,err);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Connect\"\n/*\n      Connects to the local AMS and gets communicator names\n\n   Input Parameters:\n.     none\n\n   Output Parameter:\n.     oarg1 - the string name of the first communicator\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Connect(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  char           host[256],**list = 0;\n  PetscInt       n = 0;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  ierr = PetscGetHostName(host,256);CHKERRQ(ierr);\n  ierr = AMS_Connect(host,-1,&list);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Connect()\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  } else if (!list) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Connect() list empty, not running AMS server\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  *argco = 1;\n  ierr   = PetscMalloc(sizeof(char*),argso);CHKERRQ(ierr);\n  while (list[n]) n++;\n  ierr = YAML_AMS_Utility_ArrayToString(n,list,AMS_STRING,&(*argso)[0]);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Comm_attach\"\n/*\n      Attaches to an AMS communicator\n\n   Input Parameter:\n.     arg1 - string name of the communicator\n\n   Output Parameter:\n.     oarg1 - the integer name of the communicator\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Comm_attach(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  AMS_Comm       comm = -1;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  ierr = AMS_Comm_attach(args[0],&comm);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Comm_attach()\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  *argco = 1;\n  ierr   = PetscMalloc(sizeof(char*),argso);CHKERRQ(ierr);\n  ierr   = PetscMalloc(3*sizeof(char*),&argso[0][0]);CHKERRQ(ierr);\n  sprintf(argso[0][0],\"%d\",(int)comm);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Comm_get_memory_list\"\n/*\n      Gets the list of memories on an AMS Comm\n\n   Input Parameter:\n.     arg1 - integer name of the communicator\n\n   Output Parameter:\n.     oarg1 - the list of names\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Comm_get_memory_list(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  char           **mem_list;\n  AMS_Comm       comm;\n  PetscInt       i,iargco = 0;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&comm);\n  ierr = AMS_Comm_get_memory_list(comm,&mem_list);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Comm_get_memory_list()\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  } else {\n    while (mem_list[iargco++]) ;\n    iargco--;\n\n    ierr = PetscMalloc((iargco)*sizeof(char*),argso);CHKERRQ(ierr);\n    for (i=0; i<iargco; i++) {\n      ierr = PetscStrallocpy(mem_list[i],(*argso)+i);CHKERRQ(ierr);\n    }\n  }\n  *argco = iargco;\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Memory_attach\"\n/*\n      Attaches to an AMS memory in a communicator\n\n   Input Parameter:\n.     arg1 - communicator\n.     arg2 - string name of the memory\n\n   Output Parameter:\n.     oarg1 - the integer name of the memory\n.     oarg2 - the integer step of the memory\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Memory_attach(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  AMS_Comm       comm;\n  AMS_Memory     mem;\n  unsigned int   step;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&comm);\n  ierr = AMS_Memory_attach(comm,args[1],&mem,&step);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_attach()\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  *argco = 2;\n  ierr   = PetscMalloc(2*sizeof(char*),argso);CHKERRQ(ierr);\n  ierr   = PetscMalloc(3*sizeof(char*),&argso[0][0]);CHKERRQ(ierr);\n  sprintf(argso[0][0],\"%d\",(int)mem);\n  ierr = PetscMalloc(3*sizeof(char*),&argso[0][1]);CHKERRQ(ierr);\n  sprintf(argso[0][1],\"%d\",(int)step);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Memory_get_field_list\"\n/*\n      Gets the list of fields on an AMS Memory\n\n   Input Parameter:\n.     arg1 - integer name of the memory\n\n   Output Parameter:\n.     oarg1 - the list of names\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Memory_get_field_list(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode ierr;\n  char           **field_list;\n  AMS_Memory     mem;\n  PetscInt       i,iargco = 0;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&mem);\n  ierr = AMS_Memory_get_field_list(mem,&field_list);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_get_field_list()\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  } else {\n    while (field_list[iargco++]) ;\n    iargco--;\n\n    ierr = PetscMalloc((iargco)*sizeof(char*),argso);CHKERRQ(ierr);\n    for (i=0; i<iargco; i++) {\n      ierr = PetscStrallocpy(field_list[i],(*argso)+i);CHKERRQ(ierr);\n    }\n  }\n  *argco = iargco;\n  PetscFunctionReturn(0);\n}\n\nconst char *AMS_Data_types[] = {\"AMS_DATA_UNDEF\",\"AMS_BOOLEAN\",\"AMS_INT\",\"AMS_FLOAT\",\"AMS_DOUBLE\",\"AMS_STRING\",\"AMS_Data_type\",\"AMS_\",0};\nconst char *AMS_Memory_types[] = {\"AMS_MEMORY_UNDEF\",\"AMS_READ\",\"AMS_WRITE\",\"AMS_Memory_type\",\"AMS_\",0};\nconst char *AMS_Shared_types[] = {\"AMS_SHARED_UNDEF\",\"AMS_COMMON\",\"AMS_REDUCED\",\"AMS_DISTRIBUTED\",\"AMS_Shared_type\",\"AMS_\",0};\nconst char *AMS_Reduction_types[] = {\"AMS_REDUCTION_WHY_NOT_UNDEF?\",\"AMS_SUM\",\"AMS_MAX\",\"AMS_MIN\",\"AMS_REDUCTION_UNDEF\",\"AMS_Reduction_type\",\"AMS_\",0};\n\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Memory_get_field_info\"\n/*\n      Gets information about a field\n\n   Input Parameter:\n.     arg1 - memory\n.     arg2 - string name of the field\n\n   Output Parameter:\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Memory_get_field_info(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode     ierr;\n  AMS_Memory         mem;\n  char               *addr;\n  int                len;\n  AMS_Data_type      dtype;\n  AMS_Memory_type    mtype;\n  AMS_Shared_type    stype;\n  AMS_Reduction_type rtype;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&mem);\n  ierr = AMS_Memory_get_field_info(mem,args[1],(void**)&addr,&len,&dtype,&mtype,&stype,&rtype);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_get_field_info() \",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  *argco = 5;\n  ierr   = PetscMalloc((*argco)*sizeof(char*),argso);CHKERRQ(ierr);\n  ierr   = PetscStrallocpy(AMS_Data_types[dtype],&argso[0][0]);CHKERRQ(ierr);\n  ierr   = PetscStrallocpy(AMS_Memory_types[mtype],&argso[0][1]);CHKERRQ(ierr);\n  ierr   = PetscStrallocpy(AMS_Shared_types[stype],&argso[0][2]);CHKERRQ(ierr);\n  ierr   = PetscStrallocpy(AMS_Reduction_types[rtype],&argso[0][3]);CHKERRQ(ierr);\n  ierr   = YAML_AMS_Utility_ArrayToString(len,addr,dtype,&argso[0][4]);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Memory_set_field_info\"\n/*\n      Gets information about a field\n\n   Input Parameter:\n.     arg1 - memory\n.     arg2 - string name of the field\n\n   Output Parameter:\n\n*/\nPETSC_EXTERN PetscErrorCode YAML_AMS_Memory_set_field_info(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode     ierr;\n  AMS_Memory         mem;\n  void               *addr;\n  int                len,newlen;\n  AMS_Data_type      dtype;\n  AMS_Memory_type    mtype;\n  AMS_Shared_type    stype;\n  AMS_Reduction_type rtype;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&mem);\n  ierr = AMS_Memory_get_field_info(mem,args[1],(void**)&addr,&len,&dtype,&mtype,&stype,&rtype);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_set_field_info() Memory field can not be located\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  if (mtype == AMS_READ) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_set_field_info() Memory field is read only\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = YAML_AMS_Utility_StringToArray(args[2],dtype,&newlen,(void**)&addr);CHKERRQ(ierr);\n  if (newlen != len) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_set_field_info() Changing array length\",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = AMS_Memory_set_field_info(mem,args[1],addr,len);CHKERRQ(ierr);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_set_field_info() \",err);CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  *argco = 1;\n  ierr   = PetscMalloc(sizeof(char*),argso);CHKERRQ(ierr);\n  ierr   = PetscStrallocpy(\"Memory field value set\",*argso);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"YAML_AMS_Memory_update_send_begin\"\nPETSC_EXTERN PetscErrorCode YAML_AMS_Memory_update_send_begin(PetscInt argc,char **args,PetscInt *argco,char ***argso,char **err)\n{\n  PetscErrorCode     ierr;\n  AMS_Memory         mem;\n\n  PetscFunctionBegin;\n  *argco = 0;\n  sscanf(args[0],\"%d\",&mem);\n  ierr = AMS_Memory_update_send_begin(mem);\n  if (ierr) {\n    ierr = YAML_AMS_Utility_Error(ierr,\"AMS_Memory_update_send_begin() \",err);CHKERRQ(ierr);\n  }\n  *argco = 0;\n  PetscFunctionReturn(0);\n}\n\n#include \"yaml.h\"\n#undef __FUNCT__\n#define __FUNCT__ \"PetscProcessYAMLRPC\"\n/*\n     1) Parses a YAML/JSON-RPC function call generating a function name for an AMS wrapper function and the arguments to the function\n     2) loads the function with dlsym(),\n     3) calls the wrapper function with the arguments\n     4) converts the result arguments back to YAML/JSON.\n*/\nstatic PetscErrorCode PetscProcessYAMLRPC(const char *request,char **result)\n{\n  yaml_parser_t  parser;\n  yaml_event_t   event;\n  int            done  = 0;\n  int            count = 0;\n  size_t         len;\n  PetscErrorCode ierr;\n  PetscBool      method,params,id;\n  char           *methodname,*idname,**args,**argso = 0,*err = 0;\n  PetscInt       argc = 0,argco,i;\n  PetscErrorCode (*fun)(PetscInt,char**,PetscInt*,char***,char**);\n\n  PetscFunctionBegin;\n  ierr = PetscMalloc(20*sizeof(char*),&args);CHKERRQ(ierr);\n  yaml_parser_initialize(&parser);\n  PetscStrlen(request,&len);\n  yaml_parser_set_input_string(&parser, (unsigned char*)request, len);\n\n  /* this is totally bogus; it only handles the simple JSON-RPC messages */\n  while (!done) {\n    if (!yaml_parser_parse(&parser, &event)) {\n      ierr = PetscInfo(NULL,\"Found error in yaml/json\\n\");CHKERRQ(ierr);\n      break;\n    }\n    done = (event.type == YAML_STREAM_END_EVENT);\n    switch (event.type) {\n    case YAML_STREAM_START_EVENT:\n      ierr = PetscInfo(NULL,\"Stream start\\n\");CHKERRQ(ierr);\n      break;\n    case YAML_STREAM_END_EVENT:\n      ierr = PetscInfo(NULL,\"Stream end\\n\");CHKERRQ(ierr);\n      break;\n    case YAML_DOCUMENT_START_EVENT:\n      ierr = PetscInfo(NULL,\"Document start\\n\");CHKERRQ(ierr);\n      break;\n    case YAML_DOCUMENT_END_EVENT:\n      ierr = PetscInfo(NULL,\"Document end\\n\");CHKERRQ(ierr);\n      break;\n    case YAML_MAPPING_START_EVENT:\n      ierr = PetscInfo(NULL,\"Mapping start event\\n\");CHKERRQ(ierr);\n      break;\n    case YAML_MAPPING_END_EVENT:\n      ierr = PetscInfo(NULL,\"Mapping end event \\n\");CHKERRQ(ierr);\n      break;\n    case YAML_ALIAS_EVENT:\n      ierr = PetscInfo1(NULL,\"Alias event %s\\n\",event.data.alias.anchor);CHKERRQ(ierr);\n      break;\n    case YAML_SCALAR_EVENT:\n      ierr = PetscInfo1(NULL,\"Scalar event %s\\n\",event.data.scalar.value);CHKERRQ(ierr);\n      ierr = PetscStrcmp((char*)event.data.scalar.value,\"method\",&method);CHKERRQ(ierr);\n      ierr = PetscStrcmp((char*)event.data.scalar.value,\"params\",&params);CHKERRQ(ierr);\n      ierr = PetscStrcmp((char*)event.data.scalar.value,\"id\",&id);CHKERRQ(ierr);\n      if (method) {\n        yaml_event_delete(&event);\n        ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n        ierr = PetscInfo1(NULL,\"Method %s\\n\",event.data.scalar.value);CHKERRQ(ierr);\n        ierr = PetscStrallocpy((char*)event.data.scalar.value,&methodname);CHKERRQ(ierr);\n      } else if (id) {\n        yaml_event_delete(&event);\n        ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n        ierr = PetscInfo1(NULL,\"Id %s\\n\",event.data.scalar.value);CHKERRQ(ierr);\n        ierr = PetscStrallocpy((char*)event.data.scalar.value,&idname);CHKERRQ(ierr);\n      } else if (params) {\n        yaml_event_delete(&event);\n        ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n        yaml_event_delete(&event);\n        ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n        while (event.type != YAML_SEQUENCE_END_EVENT) {\n          ierr = PetscInfo1(NULL,\"  Parameter %s\\n\",event.data.scalar.value);CHKERRQ(ierr);\n          ierr = PetscStrallocpy((char*)event.data.scalar.value,&args[argc++]);CHKERRQ(ierr);\n          yaml_event_delete(&event);\n          ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n        }\n      } else { /* ignore all the other variables in the mapping */\n        yaml_event_delete(&event);\n        ierr = yaml_parser_parse(&parser, &event);CHKERRQ(!ierr);\n      }\n      break;\n    case YAML_SEQUENCE_START_EVENT:\n      ierr = PetscInfo(NULL,\"Sequence start event \\n\");CHKERRQ(ierr);\n      break;\n    case YAML_SEQUENCE_END_EVENT:\n      ierr = PetscInfo(NULL,\"Sequence end event \\n\");CHKERRQ(ierr);\n      break;\n    default:\n      /* It couldn't really happen. */\n      break;\n    }\n\n    yaml_event_delete(&event);\n    count++;\n  }\n  yaml_parser_delete(&parser);\n\n  ierr = PetscDLLibrarySym(PETSC_COMM_SELF,NULL,NULL,methodname,(void**)&fun);CHKERRQ(ierr);\n  if (fun) {\n    ierr = PetscInfo1(NULL,\"Located function %s and running it\\n\",methodname);CHKERRQ(ierr);\n    ierr = (*fun)(argc,args,&argco,&argso,&err);CHKERRQ(ierr);\n  } else {\n    ierr = PetscInfo1(NULL,\"Did not locate function %s skipping it\\n\",methodname);CHKERRQ(ierr);\n  }\n\n  for (i=0; i<argc; i++) {\n    ierr = PetscFree(args[i]);CHKERRQ(ierr);\n  }\n  ierr = PetscFree(args);CHKERRQ(ierr);\n  ierr = PetscFree(methodname);CHKERRQ(ierr);\n\n  /* convert the result back to YAML/JSON; should use YAML/JSON encoder, does not handle zero return arguments */\n  ierr = PetscMalloc(16000,result);CHKERRQ(ierr);\n  ierr = PetscStrcpy(*result,\"{\\\"jsonrpc\\\": \\\"2.0\\\", \");CHKERRQ(ierr);\n  if (err) {\n    ierr = PetscStrcat(*result,\"\\\"error\\\": \");CHKERRQ(ierr);\n    ierr = PetscStrcat(*result,err);CHKERRQ(ierr);\n    ierr = PetscStrcat(*result,\",\");CHKERRQ(ierr);\n  } else {\n    ierr = PetscStrcat(*result,\"\\\"error\\\": null,\");CHKERRQ(ierr);\n  }\n  ierr = PetscStrcat(*result,\" \\\"id\\\": \\\"\");CHKERRQ(ierr);\n  ierr = PetscStrcat(*result,idname);CHKERRQ(ierr);\n  if (err) {\n    ierr = PetscStrcat(*result,\"\\\", \\\"result\\\" : null\");CHKERRQ(ierr);\n  } else {\n    ierr = PetscStrcat(*result,\"\\\", \\\"result\\\" : \");CHKERRQ(ierr);\n    if (!argco) {ierr = PetscStrcat(*result,\"null\");CHKERRQ(ierr);}\n    if (argco > 1) {ierr = PetscStrcat(*result,\"[\");CHKERRQ(ierr);}\n    for (i=0; i<argco; i++) {\n      if (argso[i][0] != '[') {\n        ierr = PetscStrcat(*result,\"\\\"\");CHKERRQ(ierr);\n      }\n      ierr = PetscStrcat(*result,argso[i]);CHKERRQ(ierr);\n      if (argso[i][0] != '[') {\n        ierr = PetscStrcat(*result,\"\\\"\");CHKERRQ(ierr);\n      }\n      if (i < argco-1) {ierr = PetscStrcat(*result,\",\");CHKERRQ(ierr);}\n    }\n    if (argco > 1) {ierr = PetscStrcat(*result,\"]\");CHKERRQ(ierr);}\n  }\n  ierr = PetscFree(err);CHKERRQ(ierr);\n  ierr = PetscStrcat(*result,\"}\");CHKERRQ(ierr);\n  ierr = PetscInfo1(NULL,\"YAML/JSON result of function %s\\n\",*result);CHKERRQ(ierr);\n\n  /* free work space */\n  ierr = PetscFree(idname);CHKERRQ(ierr);\n  for (i=0; i<argco; i++) {\n    ierr = PetscFree(argso[i]);CHKERRQ(ierr);\n  }\n  ierr = PetscFree(argso);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebServeRequestPostAMSJSONRPC\"\n/*@C\n      PetscWebServeRequestPostAMSJSONRPC - serves a single web POST request based on JSON-RPC\n\n       This function allows a Javascript program (running in the browser) to make an AMS function \n       call via JSON-RPC\n\n       The currently available Javascript programs are in ${PETSC_DIR}/include/web\n\n    Not collective\n\n  Input Parameters:\n.   fd - the network file to read and write from\n-   path - the command from the server\n\n    Level: developer\n\n.seealso: PetscWebServe()\n@*/\nstatic PetscErrorCode  PetscWebServeRequestPostAMSJSONRPC(FILE *fd,const char path[])\n{\n  PetscErrorCode ierr;\n  char           buf[16000];\n  char           *result;\n  int            len = -1;\n  size_t         elen;\n  char           *fnd;\n\n  PetscFunctionBegin;\n  while (PETSC_TRUE) {\n    if (!fgets(buf, sizeof(buf), fd)) {\n      ierr = PetscInfo(NULL,\"Cannot read POST data, giving up\\n\");CHKERRQ(ierr);\n      PetscFunctionReturn(0);\n    }\n    ierr = PetscInfo1(NULL,\"POSTED header: %s\",buf);CHKERRQ(ierr);\n    ierr = PetscStrstr(buf,\"Content-Type:\",&fnd);CHKERRQ(ierr);\n    if (fnd) {\n      ierr = PetscStrstr(buf,\"application/json-rpc\",&fnd);CHKERRQ(ierr);\n      if (!fnd) {\n        ierr = PetscInfo(NULL,\"POSTED content is not json-rpc, skipping post\\n\");CHKERRQ(ierr);\n        PetscFunctionReturn(0);\n      }\n    }\n    ierr = PetscStrstr(buf,\"Content-Length:\",&fnd);CHKERRQ(ierr);\n    if (fnd) {\n      sscanf(buf,\"Content-Length: %d\\n\",&len);\n      ierr = PetscInfo1(NULL,\"POSTED Content-Length: %d\\n\",len);CHKERRQ(ierr);\n    }\n    if (buf[0] == '\\r') break;\n  }\n  if (len == -1) {\n    ierr = PetscInfo(NULL,\"Did not find POST Content-Length in header, giving up\\n\");CHKERRQ(ierr);\n  }\n\n  if (!fgets(buf, len+1, fd)) { /* why is this len + 1? */\n    ierr = PetscInfo(NULL,\"Cannot read POST data, giving up\\n\");CHKERRQ(ierr);\n    PetscFunctionReturn(0);\n  }\n  ierr = PetscInfo1(NULL,\"POSTED JSON/RPC request: %s\\n\",buf);CHKERRQ(ierr);\n  fseek(fd, 0, SEEK_CUR); /* Force change of stream direction */\n  ierr = PetscProcessYAMLRPC(buf,&result);CHKERRQ(ierr);\n  ierr = PetscStrlen(result,&elen);CHKERRQ(ierr);\n  ierr = PetscWebSendHeader(fd, 200, \"OK\", NULL, \"application/json-rpc\",(int)elen);CHKERRQ(ierr);\n  fprintf(fd, \"%s\",result);\n  ierr = PetscInfo(NULL,\"Completed AMS JSON-RPC function call\\n\");CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebServeRequest\"\n/*@C\n      PetscWebServeRequest - serves a single web request\n\n    Not collective\n\n  Input Parameters:\n.   port - the port\n\n    Level: developer\n\n.seealso: PetscWebServe()\n@*/\nstatic PetscErrorCode  PetscWebServeRequest(int port)\n{\n  PetscErrorCode ierr;\n  FILE           *fd;\n  char           buf[4096];\n  char           *method, *path, *protocol;\n  PetscBool      flg;\n  PetscToken     tok;\n\n  PetscFunctionBegin;\n  fd = fdopen(port, \"r+\");\n\n  ierr = PetscInfo(NULL,\"Processing web request\\n\");CHKERRQ(ierr);\n  if (!fgets(buf, sizeof(buf), fd)) {\n    ierr = PetscInfo(NULL,\"Cannot read web request, giving up\\n\");CHKERRQ(ierr);\n    goto theend;\n  }\n  ierr = PetscInfo1(NULL,\"Processing web request %s\",buf);CHKERRQ(ierr);\n\n  ierr = PetscTokenCreate(buf,' ',&tok);CHKERRQ(ierr);\n  ierr = PetscTokenFind(tok,&method);CHKERRQ(ierr);\n  ierr = PetscTokenFind(tok,&path);CHKERRQ(ierr);\n  ierr = PetscTokenFind(tok,&protocol);CHKERRQ(ierr);\n\n  if (!method || !path || !protocol) {\n    ierr = PetscInfo(NULL,\"Web request not well formatted, giving up\\n\");CHKERRQ(ierr);\n    goto theend;\n  }\n\n  ierr = PetscStrcmp(method,\"GET\",&flg);\n  if (flg) {\n      ierr = PetscWebServeRequestGet(fd,path);CHKERRQ(ierr);\n  } else {\n    ierr = PetscStrcmp(method,\"POST\",&flg);\n    if (flg) {\n      ierr = PetscWebServeRequestPostAMSJSONRPC(fd,path);CHKERRQ(ierr);\n    } else {\n      ierr = PetscWebSendError(fd, 501, \"Not supported\", NULL, \"Method is not supported.\");CHKERRQ(ierr);\n      ierr = PetscInfo(NULL,\"Web request not a GET or POST, giving up\\n\");CHKERRQ(ierr);\n    }\n  }\ntheend:\n  ierr = PetscTokenDestroy(&tok);CHKERRQ(ierr);\n  fclose(fd);\n  ierr = PetscInfo1(NULL,\"Finished processing request %s\\n\",method);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebServeWait\"\n/*@C\n      PetscWebServeWait - waits for requests on a thread\n\n    Not collective\n\n  Input Parameter:\n.   port - port to listen on\n\n    Level: developer\n\n.seealso: PetscViewerSocketOpen(), PetscWebServe()\n@*/\nPetscErrorCode PetscWebServeWait(int *port)\n{\n  PetscErrorCode ierr;\n  int            iport,listenport,tport = *port;\n\n  PetscFunctionBegin;\n  ierr = PetscInfo1(NULL,\"Starting webserver at port %d\\n\",tport);CHKERRQ(ierr);\n  ierr = PetscSocketEstablish(tport,&listenport);CHKERRQ(ierr);\n  while (1) {\n    ierr = PetscSocketListen(listenport,&iport);CHKERRQ(ierr);\n    ierr = PetscWebServeRequest(iport);CHKERRQ(ierr);\n    close(iport);\n  }\n  close(listenport);\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscWebServe\"\n/*@C\n      PetscWebServe - start up the PETSc web server and respond to requests\n\n    Not collective - only does something on process zero of the communicator\n\n  Input Parameters:\n+   comm - the MPI communicator\n-   port - port to listen on\n\n  Options Database Key:\n+  -server <port> - start PETSc webserver (default port is 8080)\n-  -xxx_view ams - publish object xxx to be accessible in the server\n\n\n   Notes: Point your browser to http://hostname:8080   to access the PETSc web server, where hostname is the name of your machine.\n      If you are running PETSc on your local machine you can use http://localhost:8080\n\n      If the PETSc program completes before you connect with the browser you will not be able to connect to the PETSc webserver.\n\n      Read the top of $PETSC_DIR/include/web/AMSSnoopObjects.py before running.\n\n    Level: intermediate\n\n.seealso: PetscViewerSocketOpen()\n@*/\nPetscErrorCode  PetscWebServe(MPI_Comm comm,int port)\n{\n  PetscErrorCode ierr;\n  PetscMPIInt    rank;\n\n  PetscFunctionBegin;\n  if (port < 1 && port != PETSC_DEFAULT && port != PETSC_DECIDE) SETERRQ1(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,\"Cannot use negative port number %d\",port);\n  ierr = MPI_Comm_rank(comm,&rank);CHKERRQ(ierr);\n  if (rank) PetscFunctionReturn(0);\n\n  if (port == PETSC_DECIDE || port == PETSC_DEFAULT) port = 8080;\n  ierr = PetscWebServeWait(&port);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/sys/dll/dlimpl.c.html": "<center><a href=\"dlimpl.c\">Actual source code: dlimpl.c</a></center><br>\n\n<html>\n<head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/sys/dll/dlimpl.c.html\" />\n<title></title>\n<meta name=\"generator\" content=\"c2html 0.9.4\">\n<meta name=\"date\" content=\"2014-03-14T02:51:20+00:00\">\n</head>\n\n<body bgcolor=\"#FFFFFF\">\n   <div id=\"version\" align=right><b>petsc-3.4.4 2014-03-13</b></div>\n<pre width=\"80\">\n<a name=\"line2\">  2: </a><font color=\"#B22222\">/*</font>\n<a name=\"line3\">  3: </a><font color=\"#B22222\">   Low-level routines for managing dynamic link libraries (DLLs).</font>\n<a name=\"line4\">  4: </a><font color=\"#B22222\">*/</font>\n\n<a name=\"line6\">  6: </a><font color=\"#A020F0\">#include &lt;petsc-private/petscimpl.h&gt;</font>\n\n<a name=\"line8\">  8: </a><font color=\"#B22222\">/* XXX Should be done better !!!*/</font>\n<a name=\"line9\">  9: </a><font color=\"#A020F0\">#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line10\"> 10: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_WINDOWS_H</font></strong>\n<a name=\"line11\"> 11: </a><strong><font color=\"#228B22\">#undef PETSC_HAVE_DLFCN_H</font></strong>\n<a name=\"line12\"> 12: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line14\"> 14: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line15\"> 15: </a><font color=\"#A020F0\">#include &lt;windows.h&gt;</font>\n<a name=\"line16\"> 16: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line17\"> 17: </a><font color=\"#A020F0\">#include &lt;dlfcn.h&gt;</font>\n<a name=\"line18\"> 18: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line20\"> 20: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line21\"> 21: </a><font color=\"#4169E1\">typedef HMODULE dlhandle_t;</font>\n<a name=\"line22\"> 22: </a><font color=\"#4169E1\">typedef FARPROC dlsymbol_t;</font>\n<a name=\"line23\"> 23: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line24\"> 24: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line25\"> 25: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line26\"> 26: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line27\"> 27: </a><font color=\"#4169E1\">typedef void* dlhandle_t;</font>\n<a name=\"line28\"> 28: </a><font color=\"#4169E1\">typedef void* dlsymbol_t;</font>\n<a name=\"line29\"> 29: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line33\"> 33: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line34\"> 34: </a><font color=\"#B22222\">   <A href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</A> - opens dynamic library</font>\n\n<a name=\"line36\"> 36: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line38\"> 38: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line39\"> 39: </a><font color=\"#B22222\">+    name - name of library</font>\n<a name=\"line40\"> 40: </a><font color=\"#B22222\">-    mode - options on how to open library</font>\n\n<a name=\"line42\"> 42: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line43\"> 43: </a><font color=\"#B22222\">.    handle</font>\n\n<a name=\"line45\"> 45: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line47\"> 47: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line48\"> 48: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLOpen\"></a><A href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</A>  <A href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</A>(const char name[],PetscDLMode mode,PetscDLHandle *handle)</font></strong>\n<a name=\"line49\"> 49: </a>{\n<a name=\"line50\"> 50: </a>  PETSC_UNUSED int dlflags1,dlflags2; <font color=\"#B22222\">/* There are some preprocessor paths where these variables are set, but not used */</font>\n<a name=\"line51\"> 51: </a>  dlhandle_t       dlhandle;\n\n\n<a name=\"line57\"> 57: </a>  dlflags1 = 0;\n<a name=\"line58\"> 58: </a>  dlflags2 = 0;\n<a name=\"line59\"> 59: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line60\"> 60: </a>  *handle  = (PetscDLHandle) 0;\n\n<a name=\"line62\"> 62: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line63\"> 63: </a><font color=\"#B22222\">     --- LoadLibrary ---</font>\n<a name=\"line64\"> 64: </a><font color=\"#B22222\">  */</font>\n<a name=\"line65\"> 65: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H) &amp;&amp; defined(PETSC_HAVE_LOADLIBRARY)</font>\n<a name=\"line66\"> 66: </a>  dlhandle = LoadLibrary(name);\n<a name=\"line67\"> 67: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line68\"> 68: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line70\"> 70: </a>    DWORD          erc;\n<a name=\"line71\"> 71: </a>    char           *buff = NULL;\n<a name=\"line72\"> 72: </a>    erc = GetLastError();\n<a name=\"line73\"> 73: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n<a name=\"line74\"> 74: </a>                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line75\"> 75: </a>    <A href=\"../../../docs/manualpages/Sys/PetscError.html#PetscError\">PetscError</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,__LINE__,__FUNCT__,__FILE__,__SDIR__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n<a name=\"line76\"> 76: </a>                      <font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,buff);\n<a name=\"line77\"> 77: </a>    LocalFree(buff);\n<a name=\"line78\"> 78: </a>    <A href=\"../../../docs/manualpages/Sys/PetscFunctionReturn.html#PetscFunctionReturn\">PetscFunctionReturn</A>(ierr);\n<a name=\"line79\"> 79: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line80\"> 80: </a>    <A href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\"</font>,name,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line81\"> 81: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line82\"> 82: </a>  }\n\n<a name=\"line84\"> 84: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line85\"> 85: </a><font color=\"#B22222\">     --- dlopen ---</font>\n<a name=\"line86\"> 86: </a><font color=\"#B22222\">  */</font>\n<a name=\"line87\"> 87: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H) &amp;&amp; defined(PETSC_HAVE_DLOPEN)</font>\n<a name=\"line88\"> 88: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line89\"> 89: </a><font color=\"#B22222\">      Mode indicates symbols required by symbol loaded with dlsym()</font>\n<a name=\"line90\"> 90: </a><font color=\"#B22222\">     are only loaded when required (not all together) also indicates</font>\n<a name=\"line91\"> 91: </a><font color=\"#B22222\">     symbols required can be contained in other libraries also opened</font>\n<a name=\"line92\"> 92: </a><font color=\"#B22222\">     with dlopen()</font>\n<a name=\"line93\"> 93: </a><font color=\"#B22222\">  */</font>\n<a name=\"line94\"> 94: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line95\"> 95: </a>  dlflags1 = RTLD_LAZY;\n<a name=\"line96\"> 96: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line97\"> 97: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line98\"> 98: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n<a name=\"line99\"> 99: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line100\">100: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line101\">101: </a>  dlflags2 = RTLD_GLOBAL;\n<a name=\"line102\">102: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line103\">103: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line104\">104: </a>  <font color=\"#4169E1\">if</font> (mode &amp; PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n<a name=\"line105\">105: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line106\">106: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line107\">107: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line108\">108: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line109\">109: </a>  dlhandle = dlopen(name,dlflags1|dlflags2);\n<a name=\"line110\">110: </a>  <font color=\"#4169E1\">if</font> (!dlhandle) {\n<a name=\"line111\">111: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line112\">112: </a>    const char *errmsg = dlerror();\n<a name=\"line113\">113: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line114\">114: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line115\">115: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line116\">116: </a>    <A href=\"../../../docs/manualpages/Sys/SETERRQ2.html#SETERRQ2\">SETERRQ2</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,PETSC_ERR_FILE_OPEN,<font color=\"#666666\">\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\"</font>,name,errmsg);\n<a name=\"line117\">117: </a>  }\n\n<a name=\"line119\">119: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line120\">120: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line121\">121: </a><font color=\"#B22222\">  */</font>\n<a name=\"line122\">122: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line123\">123: </a>  <A href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line124\">124: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line126\">126: </a>  *handle = (PetscDLHandle) dlhandle;\n<a name=\"line127\">127: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line128\">128: </a>}\n\n\n<a name=\"line133\">133: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line134\">134: </a><font color=\"#B22222\">   <A href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</A> -  closes a dynamic library</font>\n\n<a name=\"line136\">136: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line138\">138: </a><font color=\"#B22222\">  Input Parameter:</font>\n<a name=\"line139\">139: </a><font color=\"#B22222\">.   handle - the handle for the library obtained with <A href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</A>()</font>\n\n<a name=\"line141\">141: </a><font color=\"#B22222\">  Level: developer</font>\n<a name=\"line142\">142: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line143\">143: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLClose\"></a><A href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</A>  <A href=\"../../../docs/manualpages/Sys/PetscDLClose.html#PetscDLClose\">PetscDLClose</A>(PetscDLHandle *handle)</font></strong>\n<a name=\"line144\">144: </a>{\n\n\n<a name=\"line149\">149: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line150\">150: </a><font color=\"#B22222\">     --- FreeLibrary ---</font>\n<a name=\"line151\">151: </a><font color=\"#B22222\">  */</font>\n<a name=\"line152\">152: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line153\">153: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_FREELIBRARY)</font>\n<a name=\"line154\">154: </a>  <font color=\"#4169E1\">if</font> (FreeLibrary((dlhandle_t)*handle) == 0) {\n<a name=\"line155\">155: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETLASTERROR)</font>\n<a name=\"line156\">156: </a>    char  *buff = NULL;\n<a name=\"line157\">157: </a>    DWORD erc   = GetLastError();\n<a name=\"line158\">158: </a>    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&amp;buff,0,NULL);\n<a name=\"line159\">159: </a>    <A href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</A>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,buff);\n<a name=\"line160\">160: </a>    LocalFree(buff);\n<a name=\"line161\">161: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line162\">162: </a>    <A href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</A>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\"</font>,<font color=\"#666666\">\"unavailable\"</font>);\n<a name=\"line163\">163: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line164\">164: </a>  }\n<a name=\"line165\">165: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_FREELIBRARY */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line167\">167: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line168\">168: </a><font color=\"#B22222\">     --- dclose ---</font>\n<a name=\"line169\">169: </a><font color=\"#B22222\">  */</font>\n<a name=\"line170\">170: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line171\">171: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLCLOSE)</font>\n<a name=\"line172\">172: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line173\">173: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line174\">174: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line175\">175: </a>  <font color=\"#4169E1\">if</font> (dlclose((dlhandle_t)*handle) &lt; 0) {\n<a name=\"line176\">176: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line177\">177: </a>    const char *errmsg = dlerror();\n<a name=\"line178\">178: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line179\">179: </a>    const char *errmsg = <font color=\"#666666\">\"unavailable\"</font>;\n<a name=\"line180\">180: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line181\">181: </a>    <A href=\"../../../docs/manualpages/Sys/PetscErrorPrintf.html#PetscErrorPrintf\">PetscErrorPrintf</A>(<font color=\"#666666\">\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\"</font>, errmsg);\n<a name=\"line182\">182: </a>  }\n<a name=\"line183\">183: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_DLCLOSE */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line185\">185: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line186\">186: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line187\">187: </a><font color=\"#B22222\">  */</font>\n<a name=\"line188\">188: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line189\">189: </a>  <A href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line190\">190: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line192\">192: </a>  *handle = NULL;\n<a name=\"line193\">193: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line194\">194: </a>}\n\n<a name=\"line198\">198: </a><font color=\"#B22222\">/*@C</font>\n<a name=\"line199\">199: </a><font color=\"#B22222\">   <A href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</A> - finds a symbol in a dynamic library</font>\n\n<a name=\"line201\">201: </a><font color=\"#B22222\">   Not Collective</font>\n\n<a name=\"line203\">203: </a><font color=\"#B22222\">   Input Parameters:</font>\n<a name=\"line204\">204: </a><font color=\"#B22222\">+   handle - obtained with <A href=\"../../../docs/manualpages/Sys/PetscDLOpen.html#PetscDLOpen\">PetscDLOpen</A>() or NULL</font>\n<a name=\"line205\">205: </a><font color=\"#B22222\">-   symbol - name of symbol</font>\n\n<a name=\"line207\">207: </a><font color=\"#B22222\">   Output Parameter:</font>\n<a name=\"line208\">208: </a><font color=\"#B22222\">.   value - pointer to the function, NULL if not found</font>\n\n<a name=\"line210\">210: </a><font color=\"#B22222\">   Level: developer</font>\n\n<a name=\"line212\">212: </a><font color=\"#B22222\">  Notes:</font>\n<a name=\"line213\">213: </a><font color=\"#B22222\">   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.</font>\n<a name=\"line214\">214: </a><font color=\"#B22222\">   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like</font>\n<a name=\"line215\">215: </a><font color=\"#B22222\">   systems this requires platform-specific linker flags.</font>\n\n<a name=\"line217\">217: </a><font color=\"#B22222\">@*/</font>\n<a name=\"line218\">218: </a><strong><font color=\"#4169E1\"><a name=\"PetscDLSym\"></a><A href=\"../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode\">PetscErrorCode</A>  <A href=\"../../../docs/manualpages/Sys/PetscDLSym.html#PetscDLSym\">PetscDLSym</A>(PetscDLHandle handle,const char symbol[],void **value)</font></strong>\n<a name=\"line219\">219: </a>{\n<a name=\"line220\">220: </a>  PETSC_UNUSED dlhandle_t dlhandle;\n<a name=\"line221\">221: </a>  dlsymbol_t              dlsymbol;\n\n\n<a name=\"line226\">226: </a>  dlhandle = (dlhandle_t) 0;\n<a name=\"line227\">227: </a>  dlsymbol = (dlsymbol_t) 0;\n<a name=\"line228\">228: </a>  *value   = (void*) 0;\n\n<a name=\"line230\">230: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line231\">231: </a><font color=\"#B22222\">     --- GetProcAddress ---</font>\n<a name=\"line232\">232: </a><font color=\"#B22222\">  */</font>\n<a name=\"line233\">233: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_WINDOWS_H)</font>\n<a name=\"line234\">234: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_GETPROCADDRESS)</font>\n<a name=\"line235\">235: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line236\">236: </a>  <font color=\"#4169E1\">else</font> dlhandle = (dlhandle_t) GetCurrentProcess();\n<a name=\"line237\">237: </a>  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n<a name=\"line238\">238: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_SETLASTERROR)</font>\n<a name=\"line239\">239: </a>  SetLastError((DWORD)0); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line240\">240: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line241\">241: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* !PETSC_HAVE_GETPROCADDRESS */</font><font color=\"#A020F0\"></font>\n\n<a name=\"line243\">243: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line244\">244: </a><font color=\"#B22222\">     --- dlsym ---</font>\n<a name=\"line245\">245: </a><font color=\"#B22222\">  */</font>\n<a name=\"line246\">246: </a><font color=\"#A020F0\">#elif defined(PETSC_HAVE_DLFCN_H)</font>\n<a name=\"line247\">247: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLSYM)</font>\n<a name=\"line248\">248: </a>  <font color=\"#4169E1\">if</font> (handle) dlhandle = (dlhandle_t) handle;\n<a name=\"line249\">249: </a>  <font color=\"#4169E1\">else</font> {\n\n<a name=\"line251\">251: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLOPEN) &amp;&amp; defined(PETSC_HAVE_DYNAMIC_LIBRARIES)</font>\n<a name=\"line252\">252: </a>    <font color=\"#B22222\">/* Attempt to retrieve the main executable's dlhandle. */</font>\n<a name=\"line253\">253: </a>    { int dlflags1 = 0, dlflags2 = 0;\n<a name=\"line254\">254: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LAZY)</font>\n<a name=\"line255\">255: </a>      dlflags1 = RTLD_LAZY;\n<a name=\"line256\">256: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line257\">257: </a>      <font color=\"#4169E1\">if</font> (!dlflags1) {\n<a name=\"line258\">258: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_NOW)</font>\n<a name=\"line259\">259: </a>        dlflags1 = RTLD_NOW;\n<a name=\"line260\">260: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line261\">261: </a>      }\n<a name=\"line262\">262: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_LOCAL)</font>\n<a name=\"line263\">263: </a>      dlflags2 = RTLD_LOCAL;\n<a name=\"line264\">264: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line265\">265: </a>      <font color=\"#4169E1\">if</font> (!dlflags2) {\n<a name=\"line266\">266: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTLD_GLOBAL)</font>\n<a name=\"line267\">267: </a>        dlflags2 = RTLD_GLOBAL;\n<a name=\"line268\">268: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line269\">269: </a>      }\n<a name=\"line270\">270: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line271\">271: </a>      <font color=\"#4169E1\">if</font> (!(PETSC_RUNNING_ON_VALGRIND)) {\n<a name=\"line272\">272: </a>        dlerror(); <font color=\"#B22222\">/* clear any previous error; valgrind does not like this */</font>\n<a name=\"line273\">273: </a>      }\n<a name=\"line274\">274: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line275\">275: </a>      <font color=\"#B22222\">/* Attempt to open the main executable as a dynamic library. */</font>\n<a name=\"line276\">276: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_RTDL_DEFAULT)</font>\n<a name=\"line277\">277: </a>      dlhandle = RTLD_DEFAULT;\n<a name=\"line278\">278: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line279\">279: </a>      dlhandle = dlopen(0, dlflags1|dlflags2);\n<a name=\"line280\">280: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line281\">281: </a>      { const char *e = (const char*) dlerror();\n<a name=\"line282\">282: </a>        <font color=\"#4169E1\">if</font> (e) <A href=\"../../../docs/manualpages/Sys/SETERRQ1.html#SETERRQ1\">SETERRQ1</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>, PETSC_ERR_ARG_WRONG, <font color=\"#666666\">\"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\"</font>, e);\n<a name=\"line283\">283: </a>      }\n<a name=\"line284\">284: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line285\">285: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line286\">286: </a>    }\n<a name=\"line287\">287: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line288\">288: </a><font color=\"#A020F0\">#endif </font><font color=\"#B22222\">/* PETSC_HAVE_DLOPEN &amp;&amp; PETSC_USE_DYNAMIC_LIBRARIES */</font><font color=\"#A020F0\"></font>\n<a name=\"line289\">289: </a>  }\n<a name=\"line290\">290: </a><font color=\"#A020F0\">#if defined(PETSC_HAVE_DLERROR)</font>\n<a name=\"line291\">291: </a>  dlerror(); <font color=\"#B22222\">/* clear any previous error */</font>\n<a name=\"line292\">292: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line293\">293: </a>  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n<a name=\"line294\">294: </a>  <font color=\"#B22222\">/*</font>\n<a name=\"line295\">295: </a><font color=\"#B22222\">     --- unimplemented ---</font>\n<a name=\"line296\">296: </a><font color=\"#B22222\">  */</font>\n<a name=\"line297\">297: </a><font color=\"#A020F0\">#else</font>\n<a name=\"line298\">298: </a>  <A href=\"../../../docs/manualpages/Sys/SETERRQ.html#SETERRQ\">SETERRQ</A>(<A href=\"../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF\">PETSC_COMM_SELF</A>,PETSC_ERR_SUP_SYS, <font color=\"#666666\">\"Cannot use dynamic libraries on this platform\"</font>);\n<a name=\"line299\">299: </a><font color=\"#A020F0\">#endif</font>\n\n<a name=\"line301\">301: </a>  *value = *((void**)&amp;dlsymbol);\n\n<a name=\"line303\">303: </a><font color=\"#A020F0\">#if defined(PETSC_SERIALIZE_FUNCTIONS)</font>\n<a name=\"line304\">304: </a>  <font color=\"#4169E1\">if</font> (*value) {\n<a name=\"line306\">306: </a>    PetscFPTAdd(*value,symbol);\n<a name=\"line307\">307: </a>  }\n<a name=\"line308\">308: </a><font color=\"#A020F0\">#endif</font>\n<a name=\"line309\">309: </a>  <font color=\"#4169E1\">return</font>(0);\n<a name=\"line310\">310: </a>}\n</pre>\n</body>\n\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/sys/dll/dlimpl.c": "\n/*\n   Low-level routines for managing dynamic link libraries (DLLs).\n*/\n\n#include <petsc-private/petscimpl.h>\n\n/* XXX Should be done better !!!*/\n#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n#undef PETSC_HAVE_WINDOWS_H\n#undef PETSC_HAVE_DLFCN_H\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\n#include <windows.h>\n#elif defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\ntypedef HMODULE dlhandle_t;\ntypedef FARPROC dlsymbol_t;\n#elif defined(PETSC_HAVE_DLFCN_H)\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#else\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#endif\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLOpen\"\n/*@C\n   PetscDLOpen - opens dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+    name - name of library\n-    mode - options on how to open library\n\n   Output Parameter:\n.    handle\n\n   Level: developer\n\n@*/\nPetscErrorCode  PetscDLOpen(const char name[],PetscDLMode mode,PetscDLHandle *handle)\n{\n  PETSC_UNUSED int dlflags1,dlflags2; /* There are some preprocessor paths where these variables are set, but not used */\n  dlhandle_t       dlhandle;\n\n  PetscFunctionBegin;\n  PetscValidCharPointer(name,1);\n  PetscValidPointer(handle,3);\n\n  dlflags1 = 0;\n  dlflags2 = 0;\n  dlhandle = (dlhandle_t) 0;\n  *handle  = (PetscDLHandle) 0;\n\n  /*\n     --- LoadLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H) && defined(PETSC_HAVE_LOADLIBRARY)\n  dlhandle = LoadLibrary(name);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    PetscErrorCode ierr;\n    DWORD          erc;\n    char           *buff = NULL;\n    erc = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    ierr = PetscError(PETSC_COMM_SELF,__LINE__,__FUNCT__,__FILE__,__SDIR__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n                      \"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,buff);\n    LocalFree(buff);\n    PetscFunctionReturn(ierr);\n#else\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,\"unavailable\");\n#endif\n  }\n\n  /*\n     --- dlopen ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H) && defined(PETSC_HAVE_DLOPEN)\n  /*\n      Mode indicates symbols required by symbol loaded with dlsym()\n     are only loaded when required (not all together) also indicates\n     symbols required can be contained in other libraries also opened\n     with dlopen()\n  */\n#if defined(PETSC_HAVE_RTLD_LAZY)\n  dlflags1 = RTLD_LAZY;\n#endif\n#if defined(PETSC_HAVE_RTLD_NOW)\n  if (mode & PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n#endif\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n  dlflags2 = RTLD_GLOBAL;\n#endif\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n  if (mode & PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n#endif\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlhandle = dlopen(name,dlflags1|dlflags2);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\",name,errmsg);\n  }\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = (PetscDLHandle) dlhandle;\n  PetscFunctionReturn(0);\n}\n\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLClose\"\n/*@C\n   PetscDLClose -  closes a dynamic library\n\n   Not Collective\n\n  Input Parameter:\n.   handle - the handle for the library obtained with PetscDLOpen()\n\n  Level: developer\n@*/\nPetscErrorCode  PetscDLClose(PetscDLHandle *handle)\n{\n\n  PetscFunctionBegin;\n  PetscValidPointer(handle,1);\n\n  /*\n     --- FreeLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_FREELIBRARY)\n  if (FreeLibrary((dlhandle_t)*handle) == 0) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    char  *buff = NULL;\n    DWORD erc   = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",buff);\n    LocalFree(buff);\n#else\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",\"unavailable\");\n#endif\n  }\n#endif /* !PETSC_HAVE_FREELIBRARY */\n\n  /*\n     --- dclose ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLCLOSE)\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  if (dlclose((dlhandle_t)*handle) < 0) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\", errmsg);\n  }\n#endif /* !PETSC_HAVE_DLCLOSE */\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = NULL;\n  PetscFunctionReturn(0);\n}\n\n#undef __FUNCT__\n#define __FUNCT__ \"PetscDLSym\"\n/*@C\n   PetscDLSym - finds a symbol in a dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+   handle - obtained with PetscDLOpen() or NULL\n-   symbol - name of symbol\n\n   Output Parameter:\n.   value - pointer to the function, NULL if not found\n\n   Level: developer\n\n  Notes:\n   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.\n   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like\n   systems this requires platform-specific linker flags.\n\n@*/\nPetscErrorCode  PetscDLSym(PetscDLHandle handle,const char symbol[],void **value)\n{\n  PETSC_UNUSED dlhandle_t dlhandle;\n  dlsymbol_t              dlsymbol;\n\n  PetscValidCharPointer(symbol,2);\n  PetscValidPointer(value,3);\n\n  dlhandle = (dlhandle_t) 0;\n  dlsymbol = (dlsymbol_t) 0;\n  *value   = (void*) 0;\n\n  /*\n     --- GetProcAddress ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_GETPROCADDRESS)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else dlhandle = (dlhandle_t) GetCurrentProcess();\n  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n#if defined(PETSC_HAVE_SETLASTERROR)\n  SetLastError((DWORD)0); /* clear any previous error */\n#endif\n#endif /* !PETSC_HAVE_GETPROCADDRESS */\n\n  /*\n     --- dlsym ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLSYM)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else {\n\n#if defined(PETSC_HAVE_DLOPEN) && defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n    /* Attempt to retrieve the main executable's dlhandle. */\n    { int dlflags1 = 0, dlflags2 = 0;\n#if defined(PETSC_HAVE_RTLD_LAZY)\n      dlflags1 = RTLD_LAZY;\n#endif\n      if (!dlflags1) {\n#if defined(PETSC_HAVE_RTLD_NOW)\n        dlflags1 = RTLD_NOW;\n#endif\n      }\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n      dlflags2 = RTLD_LOCAL;\n#endif\n      if (!dlflags2) {\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n        dlflags2 = RTLD_GLOBAL;\n#endif\n      }\n#if defined(PETSC_HAVE_DLERROR)\n      if (!(PETSC_RUNNING_ON_VALGRIND)) {\n        dlerror(); /* clear any previous error; valgrind does not like this */\n      }\n#endif\n      /* Attempt to open the main executable as a dynamic library. */\n#if defined(PETSC_HAVE_RTDL_DEFAULT)\n      dlhandle = RTLD_DEFAULT;\n#else\n      dlhandle = dlopen(0, dlflags1|dlflags2);\n#if defined(PETSC_HAVE_DLERROR)\n      { const char *e = (const char*) dlerror();\n        if (e) SETERRQ1(PETSC_COMM_SELF, PETSC_ERR_ARG_WRONG, \"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\", e);\n      }\n#endif\n#endif\n    }\n#endif\n#endif /* PETSC_HAVE_DLOPEN && PETSC_USE_DYNAMIC_LIBRARIES */\n  }\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *value = *((void**)&dlsymbol);\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  if (*value) {\n    PetscErrorCode ierr;\n    ierr = PetscFPTAdd(*value,symbol);CHKERRQ(ierr);\n  }\n#endif\n  return(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/docs/faq.html": "\n <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n <html>\n  <head> <link rel=\"canonical\" href=\"http://www.mcs.anl.gov/petsc/petsc-current/docs/faq.html\" />\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n    <title>Documentation: FAQ</title>\n  </head>\n  <body bgcolor=\"#ffffff\">\n   <div id=\"version\" align=right><b>petsc-3.4.4 2014-03-13</b></div>\n\n    <h1>Documentation: FAQ</h1>\n\n    \n\n    <style type=\"text/css\">\n      #answers > h3 a[name] {\n        color: red;\n      }\n\n      #answers > ol > li {\n        list-style-type: lower-alpha;\n        padding: .5em 0;\n      }\n    </style>\n\n    <div id=\"main\">\n\n      <h4><a href=\"#general\">General</a></h4>\n\n      <ul>\n        <li><a href=\"#petsc-mailing-list\">How can I subscribe to the PETSc mailing lists?</a></li>\n        <li><a href=\"#book\">Any useful books on numerical computing?</a></li>\n        <li><a href=\"#computers\">What kind of parallel computers or clusters are needed to use PETSc?</a></li>\n        <li><a href=\"#license\">What kind of license is PETSc released under?</a></li>\n        <li><a href=\"#why-c\">Why is PETSc programmed in C, instead of Fortran or C++?</a> </li>\n        <li><a href=\"#logging-overhead\">Does all the PETSc error checking and logging reduce PETSc's efficiency?</a></li>\n        <li><a href=\"#work-efficiently\">How do such a small group of people manage to write and maintain such a large and marvelous package as PETSc?</a></li>\n        <li><a href=\"#complex\">For complex numbers will I get better performance using C or C++?</a></li>\n        <li><a href=\"#different\">How come when I run the same program on the same number of processes I get \"different\" answers?</a></li>\n        <li><a href=\"#differentiterations\">How come when I run the same linear solver with different number of processes it takes a different number of iterations?</a></li>\n        <li><a href=\"#gpus\">Can PETSc use GPUs to speed up the computation time?</a></li>\n        <li><a href=\"#precision\">Can I run PETSc with extended precision?</a></li>\n        <li><a href=\"#qd\">Why doesn't PETSc use QD to implement support for extended precision?</a></li>\n      </ul>\n\n      <h4><a href=\"#installation\">Installation</a></h4>\n\n      <ul>\n        <li><a href=\"#already-installed\">How do I begin using PETSc if the software has already been completely built and installed by someone else?</a></li>\n        <li><a href=\"#reduce-disk-space\">The PETSc distribution is SO large. How can I reduce my disk space usage?</a></li>\n        <li><a href=\"#petsc-uni\">I want to use PETSc only for uniprocessor programs. Must I still install and use a version of MPI?</a></li>\n        <li><a href=\"#no-x\">Can I install PETSc to not use X windows (either under Unix or Windows with gcc, the gnu compiler)?</a></li>\n        <li><a href=\"#use-mpi\">Why do you use MPI</a>?</li> <li><a href=\"#mpi-compilers\">What do I do if my MPI compiler wrappers are invalid</a>?</li>\n        <li><a href=\"#with-64-bit-indices\">When should/can I use the ./configure option --with-64-bit-indices</a>?</li>\n        <li><a href=\"#install-petsc4py-dev\">How do I install petsc4py with the development PETSc</a>?</li>\n        <li><a href=\"#gfortran\">What Fortran compiler do you recommend for the Apple Mac OS X?</a></li>\n      </ul>\n\n      <h4><a href=\"#usage\">Usage</a></h4>\n\n      <ul>\n        <li><a href=\"#redirectstdout\">How can I redirect PETSc's stdout and stderr when programming with a GUI interface in Windows Developer Studio or to C++ streams?</a></li>\n        <li><a href=\"#hypre\">I want to use hypre boomerAMG without GMRES but when I run -pc_type hypre -pc_hypre_type boomeramg -ksp_type preonly I don't get a very accurate answer!</a></li>\n        <li><a href=\"#nosaij\">You have AIJ and BAIJ matrix formats, and SBAIJ for symmetric storage, how come no SAIJ?</a></li>\n        <li><a href=\"#domaindecomposition\">How do I use PETSc for domain decomposition?</a></li>\n        <li><a href=\"#blocks\">Can I create BAIJ matrices with different size blocks for different block rows?</a></li>\n        <li><a href=\"#mpi-vec-access\">How do I access values from a parallel PETSc vector on a different process than the one that owns the values?</a></li>\n        <li><a href=\"#mpi-vec-to-seq-vec\">How do I collect all the values from a parallel PETSc vector into a sequential vector on each processor?</a></li>\n        <li><a href=\"#mpi-vec-to-mpi-vec\">How do I collect all the values from a parallel PETSc vector into a vector on the zeroth (or any particular) processor?</a></li>\n        <li><a href=\"#sparse-matrix-ascii-format\">How can I read in or write out a sparse matrix in Matrix Market, Harwell-Boeing, SLAPC or other ASCII format?</a></li>\n        <li><a href=\"#setfromoptions\">Does TSSetFromOptions(), SNESSetFromOptions() or KSPSetFromOptions() reset all the parameters I set or how come TS/SNES/KSPSetXXX() don't seem to work?</a></li>\n        <li><a href=\"#makefiles\">Can I use my own makefiles or rules for compiling code, rather than PETSc's?</a></li>\n        <li><a href=\"#cmake\">Can I use CMake to build my own project that depends on PETSc?</a></li>\n        <li><a href=\"#carriagereturns\">How can I put carriage returns in PetscPrintf() statements from Fortran?</a></li>\n        <li><a href=\"#cxxmethod\">How can I implement callbacks using C++ class methods?</a></li>\n        <li><a href=\"#functionjacobian\">Everyone knows that when you code Newton's method you should compute the function and its Jacobian at the same time. How can one do this in PETSc?</a></li>\n        <li><a href=\"#conditionnumber\">How can I determine the condition number of a matrix?</a></li>\n        <li><a href=\"#invertmatrix\">How can I compute the inverse of a PETSc matrix?</a></li>\n        <li><a href=\"#schurcomplement\">How can I compute a Schur complement: Kbb - Kba *inverse(Kaa)*Kab?</a></li>\n        <li><a href=\"#fem\">Do you have examples of doing unstructured grid finite element computations (FEM) with PETSc?</a></li>\n        <li><a href=\"#da_mpi_cart\">The PETSc DMDA object decomposes the domain differently than the MPI_Cart_create() command. How can one use them together?</a></li>\n        <li><a href=\"#redistribute\">When solving a system with Dirichlet boundary conditions I can use MatZeroRows() to eliminate the Dirichlet rows but this results in a non-symmetric system. How can I apply Dirichlet boundary conditions and yet keep the matrix symmetric?</a></li>\n        <li><a href=\"#matlab\">How can I use PETSc with MATLAB? How can I get PETSc Vecs and Mats to MATLAB or vice versa?</a></li>\n        <li><a href=\"#cython\">How do I get started with Cython so that I can extend petsc4py?</a></li>\n      </ul>\n\n      <h4><a href=\"#Execution\">Execution</a></h4>\n\n      <ul>\n        <li><a href=\"#long-link-time\">PETSc executables are SO big and take SO long to link.</a></li>\n        <li><a href=\"#petsc-options\">PETSc has so many options for my program that it is hard to keep them straight.</a></li>\n        <li><a href=\"#petsc-log-info\">PETSc automatically handles many of the details in parallel PDE solvers.  How can I understand what is really happening within my program? </a></li>\n        <li><a href=\"#efficient-assembly\">Assembling large sparse matrices takes a long time. What can I do make this process faster? or MatSetValues() is <b>so slow</b>, what can I do to make it faster?</a></li>\n        <li><a href=\"#log-summary\">How can I generate performance summaries with PETSc?</a></li>\n        <li><a href=\"#parallel-roundoff\">Why do I get different answers on a different numbers of processors?</a></li>\n        <li><a href=\"#mg-log\">How do I know the amount of time spent on each level of the solver in multigrid (PCType of PCMG) -pc_type mg.</a></li>\n        <li><a href=\"#datafiles\">Where do I get the input matrices for the examples?</a></li>\n        <li><a href=\"#info\">When I dump some matrices and vectors to binary, I seem to be generating some empty files with .info extensions. What's the deal with these?</a></li>\n        <li><a href=\"#slowerparallel\">Why is my parallel <b>solver slower</b> than the sequential solver, or I have poor speed-up?</a></li>\n        <li><a href=\"#pipelined\">What steps are necessary to make the pipelined solvers execute efficiently?</a></li>\n        <li><a href=\"#singleprecision\">When using PETSc in single precision mode (--with-precision=single when running ./configure) are the operations done in single or double precision?</a></li>\n        <li><a href=\"#newton\">Why is Newton's method (SNES) not converging, or converges slowly?</a></li>\n        <li><a href=\"#kspdiverged\">Why is the linear solver (KSP) not converging, or converges slowly?</a></li>\n      </ul>\n\n      <h4><a href=\"#debugging\">Debugging</a></h4>\n\n      <ul>\n        <li><a href=\"#debug-ibmfortran\">How do I turn off PETSc signal handling so I can use the -C option on xlF?</a></li>\n        <li><a href=\"#start_in_debugger-doesnotwork\">How do I debug if -start_in_debugger does not work on my machine?</a></li>\n        <li><a href=\"#debug-hang\">How can I see where my code is hanging?</a></li>\n        <li><a href=\"#debug-inspect\">How can I inspect Vec and Mat values when in the debugger?</a></li>\n        <li><a href=\"#debug-fp\">How can I find the cause of floating point exceptions like not-a-number (NaN) or infinity?</a></li>\n        <li><a href=\"#libimf\">Error while loading shared libraries: libimf.so: cannot open shared object file: No such file or directory.</a></li>\n        <li><a href=\"#objecttypenotset\">What does Object Type not set: Argument # n mean?</a></li>\n        <li><a href=\"#split\">What does Error detected in PetscSplitOwnership() about \"sum of local lengths ...\": mean?</a></li>\n        <li><a href=\"#valgrind\">What does Corrupt argument or Caught signal or SEQV or segmentation violation or bus error mean? Can I use valgrind to debug memory corruption issues?</a></li>\n        <li><a href=\"#zeropivot\">What does Detected zero pivot in LU factorization mean?</a></li>\n        <li><a href=\"#xwindows\">You create Draw windows or ViewerDraw windows or use options -ksp_monitor or_draw -snes_monitor_lg_residualnorm and the program seems to run OK but windows never open.</a></li>\n        <li><a href=\"#memory\">The program seems to use more and more memory as it runs, even though you don't think you are allocating more memory.</a></li>\n        <li><a href=\"#key\">When calling MatPartitioningApply() you get a message <code>Error! Key 16615 not found</code></a></li>\n        <li><a href=\"#gmres\">With GMRES At restart the second residual norm printed does not match the first </a></li>\n        <li><a href=\"#doubleits\">Why do some Krylov methods seem to print two residual norms per iteration?</a></li>\n        <li><a href=\"#dylib\">Unable to locate PETSc dynamic library /home/balay/spetsc/lib/libg/linux/libpetsc</a></li>\n        <li><a href=\"#bisect\">How do I determine what update to PETSc broke my code?</a></li>\n      </ul>\n\n      <h4><a href=\"#shared-libraries\">Shared Libraries</a></h4>\n\n      <ul>\n        <li><a href=\"#install-shared\">Can I install PETSc libraries as shared libraries?</a></li>\n        <li><a href=\"#why-use-shared\">Why should I use shared libraries?</a></li>\n        <li><a href=\"#link-shared\">How do I link to the PETSc shared libraries?</a></li>\n        <li><a href=\"#link-regular-lib\">What if I want to link to the regular .a library files?</a></li>\n        <li><a href=\"#move-shared-exec\">What do I do if I want to move my executable to a different machine?</a></li>\n        <li><a href=\"#dynamic-shared\">What is the deal with dynamic libraries (and difference with shared libraries)?</a></li>\n      </ul>\n\n    </div>\n\n    <hr>\n\n    <div id=\"answers\">\n\n      <h1><a name=\"general\">General</a></h1>\n\n      <h3><a name=\"petsc-mailing-list\">How can I subscribe to the PETSc mailing lists?</a></h3>\n\n      See <a href=\"http://www.mcs.anl.gov/petsc/miscellaneous/mailing-lists.html\">http://www.mcs.anl.gov/petsc/miscellaneous/mailing-lists.html</a>\n\n      <h3><a name=\"book\">Any useful books on numerical computing?</a></h3>\n\n      <a href=\"http://ebooks.cambridge.org/ebook.jsf?bid=CBO9780511617973\">Writing Scientific Software: A Guide to Good Style</a>\n\n      <h3><a name=\"computers\">What kind of parallel computers or clusters are needed to use PETSc?</a></h3>\n\n      PETSc can be used with any kind of parallel system that supports MPI\n      <b>BUT</b> for any decent performance one needs\n\n      <ul>\n        <li>\n          a <b>fast, low-latency interconnect</b>; any ethernet, even 10 gigE\n          simply cannot provide the needed performance.\n        </li>\n        <li>\n          <b>high per-CPU memory performance</b>. Each CPU (core in multi-core\n          systems) needs to have its <b>own</b> memory bandwith of roughly 2 or\n          more gigabytes/second. For example, standard dual processor \"PC's\" will\n          <b>not</b> provide better performance when the second processor is\n          used, that is, you will not see speed-up when you using the second\n          processor. This is because the speed of sparse matrix computations is\n          almost totally determined by the speed of the memory, not the speed of\n          the CPU.  Smart process to core/socket binding may help you. For\n          example, consider using fewer processes than cores and binding\n          processes to separate sockets so that each process uses a different\n          memory bus:\n\n          <dl>\n            <dt><a href=\"http://wiki.mcs.anl.gov/mpich2/index.php/Using_the_Hydra_Process_Manager#Process-core_Binding\">MPICH2 binding with the Hydra process manager</a></dt>\n            <dd><code>mpiexec.hydra -n 4 --binding cpu:sockets</code></dd>\n\n            <dt><a href=\"http://www.open-mpi.org/doc/v1.5/man1/mpiexec.1.php#sect8\">Open MPI binding</a></dt>\n            <dd><code>mpiexec -n 4 --bysocket --bind-to-socket --report-bindings</code></dd>\n          </dl>\n\n          Other tools to manage affinity include\n          <dl>\n            <dt><tt>taskset</tt>, part of the <tt>util-linux</tt> package</dt>\n            <dd>\n              <tt>Usage: taskset [options] [mask | cpu-list] [pid|cmd [args...]]</tt>, type <tt>man taskset</tt> for details.\n              Make sure to set affinity for your program, not for the <tt>mpiexec</tt> program.\n            </dd>\n\n            <dt><tt>numactl</tt></dt>\n            <dd>In addition to task affinity, this tool also allows changing the default memory affinity policy.\n              On Linux, the default policy is to attempt to find memory on the same memory bus that serves the core that a thread is running on at whatever time the memory is faulted (<em>not</em> when <tt>malloc()</tt> is called).\n              If local memory is not available, it is found elsewhere, possibly leading to serious memory imbalances.\n              The option <tt>--localalloc</tt> allocates memory on the local NUMA node, similar to the <tt>numa_alloc_local()</tt> function in the <tt>libnuma</tt> library.\n              The option <tt>--cpunodebind=nodes</tt> binds the process to a given NUMA node (note that this can be larger or smaller than a CPU (socket); a NUMA node usually has multiple cores).\n              The option <tt>--physcpubind=cpus</tt> binds the process to a given processor core (numbered according to <tt>/proc/cpuinfo</tt>, therefore including logical cores if Hyper-threading is enabled).\n              With Open MPI, you can use knowledge of the NUMA hierarchy and core numbering on your machine to calculate the correct NUMA node or processor number given the environment variable <tt>OMPI_COMM_WORLD_LOCAL_RANK</tt>.\n              In most cases, it is easier to make <tt>mpiexec</tt> or a resource manager set affinities.\n            </dd>\n          </dl>\n        </li>\n\n        <li>\n          The software <a href=\"http://open-mx.org\">http://open-mx.org</a>\n          provides faster speed for ethernet systems, we have not tried it but it\n          claims it can dramatically reduce latency and increase bandwidth on\n          Linux system. You must first install this software and then install\n          MPICH or Open MPI to use it.\n        </li>\n\n        <li>\n          In ${PETSC_DIR} run make streams and when requested enter the number of\n          cores your system has. The more the achieved memory bandwidth increases\n          the more performance you can expect across your multiple cores. If the\n          bandwidth does not increase significently then you cannot expect to get\n          any improvement in parallel performance.\n        </li>\n\n      </ul>\n\n      <h3><a name=\"license\">What kind of license is PETSc released under?</a></h3>\n\n      See the <a href=\"copyright.html\">licensing notice.</a>\n\n      <h3><a name=\"why-c\">Why is PETSc programmed in C, instead of Fortran or C++?</a></h3>\n\n      C enables us to build data structures for storing sparse matrices, solver\n      information, etc. in ways that Fortran simply does not allow. ANSI C is\n      a complete standard that all modern C compilers support. The language is\n      identical on all machines. C++ is still evolving and compilers on different\n      machines are not identical. Using C function pointers to provide data\n      encapsulation and polymorphism allows us to get many of the advantages of\n      C++ without using such a large and more complicated language. It would be\n      natural and reasonable to have coded PETSc in C++; we opted to use\n      C instead.\n\n      <h3><a name=\"logging-overhead\">Does all the PETSc error checking and logging reduce PETSc's efficiency?</a></h3>\n\n      No.\n\n      <h3><a name=\"work-efficiently\">How do such a small group of people manage to write and maintain such a large and marvelous package as PETSc?</a></h3>\n\n      <ol>\n        <li>We work very efficiently.\n          <ol>\n            <li>\n              We use Emacs for all editing; the etags feature makes navigating\n              and changing our source code very easy.\n            </li>\n            <li>\n              Our manual pages are generated automatically from\n              formatted comments in the code, thus alleviating the\n              need for creating and maintaining manual pages.\n            </li>\n            <li>\n              We employ automatic nightly tests of PETSc on several\n              different machine architectures. This process helps us\n              to discover problems the day after we have introduced\n              them rather than weeks or months later.\n            </li>\n          </ol>\n        </li>\n\n        <li>\n          We are very careful in our design (and are constantly\n          revising our design) to make the package easy to use,\n          write, and maintain.\n        </li>\n\n        <li>\n          We are willing to do the grunt work of going through\n          all the code regularly to make sure that <u>all</u> code\n          conforms to our interface design. We will <u>never</u>\n          keep in a bad design decision simply because changing it\n          will require a lot of editing; we do a lot of editing.\n        </li>\n\n        <li>\n          We constantly seek out and experiment with new design\n          ideas; we retain the the useful ones and discard the rest.\n          All of these decisions are based on <u>practicality</u>.\n        </li>\n\n        <li>\n          Function and variable names are chosen to be very\n          consistent throughout the software. Even the rules about\n          capitalization are designed to make it easy to figure out\n          the name of a particular object or routine. Our memories\n          are terrible, so careful consistent naming puts less\n          stress on our limited human RAM.\n        </li>\n\n        <li>\n          The PETSc directory tree is carefully designed to make\n          it easy to move throughout the entire package.\n        </li>\n\n        <li>\n          Our bug reporting system, based on email to <a\n            href=\"../documentation/bugreporting.html\">petsc-maint@mcs.anl.gov</a>,\n          makes it very simple to keep track of what bugs have been found and\n          fixed. In addition, the bug report system retains an archive of all\n          reported problems and fixes, so it is easy to refind fixes to\n          previously discovered problems.\n        </li>\n\n        <li>\n          We contain the complexity of PETSc by using object-oriented programming\n          techniques including data encapsulation (this is why your program\n          cannot, for example, look directly at what is inside the object Mat)\n          and polymorphism (you call MatMult() regardless of whether your matrix\n          is dense, sparse, parallel or sequential; you don't call a different\n          routine for each format).\n        </li>\n\n        <li>We try to provide the functionality requested by our users.</li>\n\n        <li>We never sleep.</li>\n      </ol>\n\n      <h3><a name=\"complex\">For complex numbers will I get better performance with C++?</a></h3>\n\n      To use PETSc with complex numbers you either <code>./configure</code> with\n      the option <code>--with-scalar-type</code> complex and either\n      <code>--with-clanguage=c++</code> or, the default,\n      <code>--with-clanguage=c</code>. In our experience they will deliver very\n      similar performance (speed), but if one is concerned they should just try\n      both and see if one is faster.\n\n      <h3><a name=\"different\">How come when I run the same program on the same number of processes I get a \"different\" answer?</a></h3>\n\n      <p>\n        Inner products and norms in PETSc are computed using the MPI_Allreduce()\n        command. In different runs the order at which values arrive at a given\n        process (via MPI) can be in a different order, thus the order in which some\n        floating point arithmetic operations are performed will be different. Since\n        floating point arithmetic arithmetic is not associative, the computed\n        quantity may be (slightly) different. Over a run the many slight\n        differences in the inner products and norms will effect all the computed\n        results. It is important to realize that none of the computed answers are\n        any less right or wrong (in fact the sequential computation is no more\n        right then the parallel ones), they are all equally valid.\n      </p>\n\n      <p>\n        The discussion above assumes that the exact same algorithm is being used on\n        the different number of processes. When the algorithm is different for the\n        different number of processes (almost all preconditioner algorithms except\n        Jacobi are different for different number of processes) then one expects to\n        see (and does) a greater difference in results for different numbers of\n        processes.  In some cases (for example block Jacobi preconditioner) it may\n        be that the algorithm works for some number of processes and does not work\n        for others.\n      </p>\n\n      <h3><a name=\"differentiterations\">How come when I run the same linear solver on a different number of processes it takes a different number of iterations?</a></h3>\n\n      The convergence of many of the preconditioners in PETSc including the the\n      default parallel preconditioner block Jacobi depends on the number of\n      processes. The more processes the (slightly) slower convergence it has.\n      This is the nature of iterative solvers, the more parallelism means the\n      more \"older\" information is used in the solution process hence slower\n      convergence.\n\n      <h3><a name=\"gpus\">Can PETSc use GPUs to speedup computations?</a></h3>\n\n      PETSc-dev has some support for running portions of the computation on\n      Nvidia GPUs. See <a href=\"http://www.mcs.anl.gov/petsc/features/gpus.html\">PETSc GPUs</a> for\n      more information. PETSc has a Vec class VECCUSP that performs almost all\n      the vector operations on the GPU. The Mat class MATCUSP performs\n      matrix-vector products on the GPU but does not have matrix assembly on the\n      GPU yet. Both of these classes run in parallel with MPI. All KSP methods,\n      except KSPIBCGS, run all their vector operations on the GPU thus, for\n      example Jacobi preconditioned Krylov methods run completely on the GPU.\n      Preconditioners are a problem, we could do with some help for these. The\n      example <a href=\"http://www.mcs.anl.gov/petsc/petsc-dev/src/snes/examples/tutorials/ex47cu.cu.html\">src/snes/examples/tutorials/ex47cu.cu</a>\n      demonstates how the nonlinear function evaluation can be done on the\n      GPU.\n\n      <h3><a name=\"precision\">Can I run PETSc with exended precision?</a></h3>\n\n      Yes, with gcc 4.6 and later (and gfortran 4.6 and later)\n      <code>./configure</code> PETSc using the options\n      <code>--with-precision=__float128 --download-f2cblaslapack</code>.\n      External packages cannot be used in this mode and some print statements in\n      PETSc (those that use the %G format) will not print correctly.\n\n      <h3><a name=\"qd\">Why doesn't PETSc use QD to implement support for exended precision?</a></h3>\n\n      We tried really hard but could not. The problem is that the QD c++ classes,\n      though they try to implement the built-in data types of double etc are not\n      native types and cannot \"just be used\" in a general piece of numerical\n      source code rather the code has to rewritten to live within the limitations\n      of QD classes.\n\n      <hr>\n\n      <h2><a name=\"installation\">Installation</a></h2>\n\n      <h3><a name=\"already-installed\">How do I begin using PETSc if the software has already been completely built and installed by someone else?</a></h3>\n\n      Assuming that the PETSc libraries have been successfully built for\n      a particular architecture and level of optimization, a new user must\n      merely:\n\n      <ol>\n        <li>\n          Set the environmental variable PETSC_DIR to the full\n          path of the PETSc home directory (for example,\n          /home/username/petsc).\n        </li>\n\n        <li>\n          Set the environmental variable PETSC_ARCH, which indicates the\n          configuration on which PETSc will be used. Note that the PETSC_ARCH is\n          simply a name the installer used when installing the libraries. There\n          many be several on a single system, like mylinux-g for the debug\n          versions of the library and mylinux-O for the optimized version, or\n          petscdebug for the debug version and petscopt for the optimized\n          version.\n        </li>\n\n        <li>\n          Begin by copying one of the many PETSc examples (in, for example,\n          petsc/src/ksp/examples/tutorials) and its corresponding makefile.\n        </li>\n\n        <li>\n          See the introductory section of the PETSc users manual for tips on\n          documentation.\n        </li>\n      </ol>\n\n      <h3><a name=\"reduce-disk-space\">The PETSc distribution is SO large. How can I reduce my disk space usage?</a></h3>\n\n      <ol>\n        <li>\n          The directory ${PETSC_DIR}/docs contains a set of HTML manual pages in\n          for use with a browser. You can delete these pages to save about .8\n          Mbyte of space.\n        </li>\n\n        <li>\n          The PETSc users manual is provided in PDF in\n          ${PETSC_DIR}/docs/manual.pdf. You can delete this.\n        </li>\n\n        <li>\n          The PETSc test suite contains sample output for many of the examples.\n          These are contained in the PETSc directories\n          ${PETSC_DIR}/src/*/examples/tutorials/output and\n          ${PETSC_DIR}/src/*/examples/tests/output. Once you have run the test\n          examples, you may remove all of these directories to save about 300\n          Kbytes of disk space.\n        </li>\n\n        <li>\n          The debugging versions of the libraries are larger than the optimized\n          versions. In a pinch you can work with the optimized version although\n          we do not recommend it generally because finding bugs is much easier\n          with the debug version.\n        </li>\n      </ol>\n\n      <h3><a name=\"petsc-uni\">I want to use PETSc only for uniprocessor programs. Must I still install and use a version of MPI?</a></h3>\n\n      No, run ./configure with the option <code>--with-mpi=0</code>\n\n      <h3><a name=\"no-x\">Can I install PETSc to not use X windows (either under Unix or Windows with gcc, the gnu compiler)?</a></h3>\n\n      Yes. Run ./configure with the additional flag <code>--with-x=0</code>\n\n      <h3><a name=\"use-mpi\">Why do you use MPI</a>?</h3>\n\n      MPI is the message-passing standard. Because it is a standard, it will not\n      change over time; thus, we do not have to change PETSc every time the\n      provider of the message-passing system decides to make an interface change.\n      MPI was carefully designed by experts from industry, academia, and\n      government labs to provide the highest quality performance and capability.\n      For example, the careful design of communicators in MPI allows the easy\n      nesting of different libraries; no other message-passing system provides\n      this support. All of the major parallel computer vendors were involved in\n      the design of MPI and have committed to providing quality implementations.\n      In addition, since MPI is a standard, several different groups have already\n      provided complete free implementations. Thus, one does not have to rely on\n      the technical skills of one particular group to provide the message-passing\n      libraries. Today, MPI is the only practical, portable approach to writing\n      efficient parallel numerical software.\n\n      <h3><a name=\"mpi-compilers\">What do I do if my MPI compiler wrappers are invalid</a>?</h3>\n\n      Most MPI implementations provide compiler wrappers (such as mpicc) which\n      give the include and link options necessary to use that verson of MPI to\n      the underlying compilers . These wrappers are either absent or broken in\n      the MPI pointed to by --with-mpi-dir. You can rerun the configure with the\n      additional option --with-mpi-compilers=0, which will try to auto-detect\n      working compilers; however, these compilers may be incompatible with the\n      particular MPI build. If this fix does not work, run with\n      --with-cc=c_compiler where you know c_compiler works with this particular\n      MPI, and likewise for C++ and Fortran.\n\n      <h3><a name=\"with-64-bit-indices\">When should/can I use the ./configure option --with-64-bit-indices?</a></h3>\n\n      By default the type that PETSc uses to index into arrays and keep sizes of\n      arrays is a PetscInt defined to be a 32 bit int. If your problem\n\n      <ul>\n        <li>involves more than 2^31 - 1 unknowns (around 2 billion) OR</li>\n        <li>your matrix might contain more than 2^31 - 1 nonzeros on a single process</li>\n      </ul>\n\n      then you need to use this option. Otherwise you will get strange crashes.\n\n      <p>\n        This option can be used when you are using either 32 bit or 64 bit\n        pointers. You do not need to use this option if you are using 64 bit\n        pointers unless the two conditions above hold.\n      </p>\n\n      <h3><a name=\"install-petsc4py-dev\">How do I install petsc4py with the development PETSc?</a></h3>\n\n      You can follow these steps\n\n      <ol>\n        <li>grab petsc4py-dev repo [from hg]</li>\n        <li>install Cython</li>\n        <li>make cython [in petsc4py-dev]</li>\n        <li>place petsc4py-dev in PETSC_DIR/externalpackages</li>\n        <li>export ARCHFLAGS=''</li>\n        <li>install PETSc with --download-petsc4py etc..</li>\n      </ol>\n\n      <h3><a name=\"gfortran\">What Fortran compiler do you recommend for the Apple Mac OS X?</a></h3>\n\n      <p>\n        (as of 11/6/2010) We recommend installing gfortran from <a\n          href=\"http://hpc.sourceforge.net/\">http://hpc.sourceforge.net</a>.  They\n        have gfortran-4.6.0 (experimental) for Snow Leopard (10.6) and gfortran\n        4.4.1 (prerelease) for Leopard (10.5).\n      </p>\n\n      <p>\n        Please contact Apple at <a\n          href=\"http://www.apple.com/feedback\">http://www.apple.com/feedback</a>\n        and urge them to bundle gfortran with future versions of Xcode.\n      </p>\n\n      <hr>\n\n      <h2><a name=\"using\">Using</a></h2>\n\n      <h3><a name=\"redirectstdout\">How can I redirect PETSc's stdout and stderr when programming with a GUI interface in Windows Developer Studio or too C++ streams?</a> </h3>\n\n      <p>\n        To overload just the error messages write your own MyPrintError() function\n        that does whatever you want (including pop up windows etc) and use it like\n        below.\n      </p>\n\n      <pre>\nextern \"C\" {\n  int PASCAL WinMain(HINSTANCE inst,HINSTANCE dumb,LPSTR param,int show);\n};\n\n#include &lt;petscsys.h&gt;\n#include &lt;mpi.h&gt;\n\nconst char help[] = \"Set up from main\";\n\nint MyPrintError(const char error[], ...) {\n  printf(\"%s\", error);\n  return 0;\n}\n\nint main(int ac, char *av[]) {\n  char buf[256];\n  int i;\n  HINSTANCE inst;\n  PetscErrorCode ierr;\n\n  inst=(HINSTANCE)GetModuleHandle(NULL);\n  PetscErrorPrintf = MyPrintError;\n\n  buf[0]=0;\n  for (i=1; i&lt;ac; i++) {\n    strcat(buf,av[i]);\n    strcat(buf,\" \");\n  }\n\n  PetscInitialize(&amp;ac, &amp;av, NULL, help);\n\n  return WinMain(inst,NULL,buf,SW_SHOWNORMAL);\n}\n    </pre>\n\n      <p>\n        file in the project and compile with this preprocessor definitiions:\n        <code>WIN32,_DEBUG,_CONSOLE,_MBCS,USE_PETSC_LOG,USE_PETSC_BOPT_g,USE_PETSC_STA CK,_AFXDLL</code>\n      </p>\n\n      <p>\n        And these link options: <code>/nologo /subsystem:console /incremental:yes\n          /debug /machine:I386 /nodefaultlib:\"libcmtd.lib\"\n          /nodefaultlib:\"libcd.lib\" /nodefaultlib:\"mvcrt.lib\"\n          /pdbtype:sept</code>\n      </p>\n\n      <p>\n        Note that it is compiled and linked as if it was a console program. The\n        linker will search for a main, and then from it the WinMain will start.\n        This works with MFC templates and derived classes too.\n      </p>\n\n      <p>\n        Note: When writing a Window's console application you do not need to do\n        anything, the stdout and stderr is automatically output to the console\n        window.\n      </p>\n\n      <p>To change where all PETSc stdout and stderr go write a function</p>\n\n      <p>\n        You can also reassign PetscVFPrintf() to handle stdout and stderr any way\n        you like write the following function:\n      </p>\n\n      <pre>\nPetscErrorCode mypetscvfprintf(FILE *fd, const char format[], va_list Argp) {\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  if (fd != stdout &amp;&amp; fd != stderr) { /* handle regular files */\n    ierr = PetscVFPrintfDefault(fd,format,Argp); CHKERR(ierr);\n  } else {\n    char buff[BIG];\n    int length;\n    ierr = PetscVSNPrintf(buff,BIG,format,&amp;length,Argp);CHKERRQ(ierr);\n\n    /* now send buff to whatever stream or whatever you want */\n  }\n  PetscFunctionReturn(0);\n}\n    </pre>\n\n      and assign <code>PetscVFPrintf = mypetscprintf;</code> before\n      <code>PetscInitialize()</code> in your main program.\n\n      <h3><a name=\"hypre\">I want to use hypre boomerAMG without GMRES but when I run <code>-pc_type hypre -pc_hypre_type boomeramg -ksp_type preonly</code> I don't get a very accurate answer!</a> </h3>\n\n      You should run with -ksp_type richardson to have PETSc run several V or\n      W cycles. -ksp_type of preonly causes boomerAMG to use only one V/W cycle.\n      You can control how many cycles are used in a single application of the\n      boomerAMG preconditioner with <code>-pc_hypre_boomeramg_max_iter\n        &lt;it&gt;</code> (the default is 1). You can also control the tolerance\n      boomerAMG uses to decide if to stop before max_iter with\n      <code>-pc_hypre_boomeramg_tol &lt;tol&gt;</code> (the default is 1.e-7).\n      Run with <code>-ksp_view</code> to see all the hypre options used and\n      <code>-help | grep boomeramg</code> to see all the command line options.\n\n      <h3><a name=\"nosaij\">You have AIJ and BAIJ matrix formats, and SBAIJ for symmetric storage, how come no SAIJ?</a></h3>\n\n      Just for historical reasons, the SBAIJ format with blocksize one is just as\n      efficient as an SAIJ would be.\n\n      <h3><a name=\"domaindecomposition\">How do I use PETSc for Domain Decomposition?</a></h3>\n\n      <p>\n        PETSc includes Additive Schwarz methods in the suite of preconditioners.\n        These may be activated with the runtime option <code>-pc_type asm.</code>\n        Various other options may be set, including the degree of overlap\n        <code>-pc_asm_overlap &lt;number&gt;</code> the type of restriction/extension\n        <code>-pc_asm_type [basic,restrict,interpolate,none]</code> - Sets ASM type\n        and several others. You may see the available ASM options by using\n        <code>-pc_type asm -help</code> Also, see the procedural interfaces in the\n        manual pages, with names <code>PCASMxxxx()</code> and check the index of the\n        <a href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manual.pdf\">users manual</a>\n        for <code>PCASMxxx</code>().\n      </p>\n\n      <p>\n        PETSc also contains a domain decomposition inspired wirebasket or face\n        based two level method where the coarse mesh to fine mesh interpolation\n        is defined by solving specific local subdomain problems. It currently\n        only works for 3D scalar problems on structured grids created with PETSc\n        DMDAs. See the manual page for PCEXOTIC and\n        src/ksp/ksp/examples/tutorials/ex45.c for any example.\n      </p>\n\n      <p>\n        PETSc also contains a balancing Neumann-Neumann preconditioner, see the\n        manual page for PCNN. This requires matrices be constructed with\n        <code>MatCreateIS()</code> via the finite element method. There are currently\n        no examples that demonstrate its use.\n      </p>\n\n      <h3><a name=\"blocks\">Can I create BAIJ matrices with different size blocks for different block rows?</a></h3>\n\n      Sorry, this is not possible, the BAIJ format only supports a single fixed\n      block size on the entire matrix. But the AIJ format automatically searches\n      for matching rows and thus still takes advantage of the natural blocks in\n      your matrix to obtain good performance. Unfortunately you cannot use the\n      <code>MatSetValuesBlocked()</code>.\n\n      <h3><a name=\"mpi-vec-access\">How do I access the values of a parallel PETSc vector on a different process than owns them?</a></h3>\n\n      <ul>\n        <li>On each process create a local vector large enough to hold all the values it wishes to access</li>\n        <li>Create a VecScatter that scatters from the parallel vector into the local vectors</li>\n        <li>Use VecGetArray() to access the values in the local vector</li>\n      </ul>\n\n      <h3><a name=\"mpi-vec-to-seq-vec\">How do I collect all the values from a parallel PETSc vector into a sequential vector on each processor?</a></h3>\n\n      <ul>\n        <li>Create the scatter context that will do the communication</li>\n        <li> <a href=\"manualpages/Vec/VecScatterCreateToAll.html\">VecScatterCreateToAll</a>(v,&amp;ctx,&amp;w);</li>\n        <li>\n          Actually do the communication; this can be done repeatedly as needed\n          <ul>\n            <li><a href=\"manualpages/Vec/VecScatterBegin.html\">VecScatterBegin</a>(ctx,v,w,INSERT_VALUES,SCATTER_FORWARD);</li>\n            <li> <a href=\"manualpages/Vec/VecScatterEnd.html\">VecScatterEnd</a>(ctx,v,w,INSERT_VALUES,SCATTER_FORWARD);</li>\n          </ul>\n        </li>\n        <li>\n          Remember to free the scatter context when no longer needed\n          <ul>\n            <li> <a href=\"manualpages/Vec/VecScatterDestroy.html\">VecScatterDestroy</a>(ctx);</li>\n          </ul>\n        </li>\n      </ul>\n\n      Note that this simply concatenates in the parallel ordering of the vector.\n      If you are using a vector from DMCreateGlobalVector() you likely want to\n      first call DMDAGlobalToNaturalBegin/End() to scatter the original vector\n      into the natural ordering in a new global vector before calling\n      VecScatterBegin/End() to scatter the natural vector onto all processes.\n\n      <h3><a name=\"mpi-vec-to-mpi-vec\">How do I collect all the values from a parallel PETSc vector into a vector on the zeroth processor?</a></h3>\n\n      <ul>\n        <li>\n          Create the scatter context that will do the communication\n          <ul>\n            <li><a href=\"manualpages/Vec/VecScatterCreateToZero.html\">VecScatterCreateToZero</a>(v,&amp;ctx,&amp;w);</li>\n          </ul>\n        </li>\n        <li>\n          Actually do the communication; this can be done repeatedly as needed\n          <ul>\n            <li><a href=\"manualpages/Vec/VecScatterBegin.html\">VecScatterBegin</a>(ctx,v,w,INSERT_VALUES,SCATTER_FORWARD);</li>\n            <li> <a href=\"manualpages/Vec/VecScatterEnd.html\">VecScatterEnd</a>(ctx,v,w,INSERT_VALUES,SCATTER_FORWARD);</li>\n          </ul>\n        </li>\n        <li>\n          Remember to free the scatter context when no longer needed\n          <ul>\n            <li> <a href=\"manualpages/Vec/VecScatterDestroy.html\">VecScatterDestroy</a>(ctx);</li>\n          </ul>\n        </li>\n      </ul>\n\n      Note that this simply concatenates in the parallel ordering of the vector.\n      If you are using a vector from DMCreateGlobalVector() you likely want to\n      first call DMDAGlobalToNaturalBegin/End() to scatter the original vector\n      into the natural ordering in a new global vector before calling\n      VecScatterBegin/End() to scatter the natural vector onto process 0.\n\n      <h3><a name=\"sparse-matrix-ascii-format\">How can I read in or write out a sparse matrix in Matrix Market, Harwell-Boeing, SLAPC or other ASCII format?</a></h3>\n\n      See the examples in src/mat/examples/tests, specifically ex72.c, ex78.c,\n      and ex32.c. You will likely need to modify the code slightly to match your\n      required ASCII format. Note: Never read or write in parallel an ASCII\n      matrix file, instead for reading: read in sequentially with a standalone\n      code based on ex72.c, ex78.c, or ex32.c then save the matrix with the\n      binary viewer PetscBinaryViewerOpen() and load the matrix in parallel in\n      your \"real\" PETSc program with MatLoad(); for writing save with the binary\n      viewer and then load with the sequential code to store it as ASCII.\n\n      <h3><a name=\"setfromoptions\">Does TSSetFromOptions(), SNESSetFromOptions() or KSPSetFromOptions() reset all the parameters I previously set or how come my TS/SNES/KSPSetXXX() does not seem to work?</a></h3>\n\n      <p>\n        If XXSetFromOptions() is used (with -xxx_type aaaa) to change the type of\n        the object then all parameters associated with the previous type are\n        removed.  Otherwise it does not reset parameters.\n      </p>\n\n      <p>\n        TS/SNES/KSPSetXXX() commands that set properties for a particular type of\n        object (such as KSPGMRESSetRestart()) ONLY work if the object is ALREADY\n        of that type. For example, with\n        <code>KSPCreate(PETSC_COMM_WORLD,&amp;ksp); KSPGMRESSetRestart(ksp,10);</code>\n        the restart will be ignored since the type has not yet been set to GMRES.\n        To have those values take effect you should do one of the following:\n      </p>\n\n      <ul style=\"list-style-type: none; padding: .5em;\">\n        <li><code>XXXCreate(..,&amp;obj);</code></li>\n        <li>\n          <code>XXXSetFromOptions(obj)</code>; allow setting the\n          type from the command line, if it is not on the\n          command line then the default type is automatically\n          set\n        </li>\n        <li>\n          <code>XXXSetYYYYY(obj,...)</code>;  if the obj is the\n          appropriate type then the operation takes place\n        </li>\n        <li>\n          <code>XXXSetFromOptions(obj)</code>; allow user to\n          overwrite options hardwired in code (optional)<br>\n        </li>\n        <li>\n          The other approach is to replace the first\n          <code>XXXSetFromOptions()</code> to <code>XXXSetType(obj,type)</code>\n          and hardwire the type at that point.\n        </li>\n      </ul>\n\n      <h3><a name=\"makefiles\">Can I use my own makefiles or rules for compiling code, instead of using PETSc's?</a></h3>\n\n      Yes, see the section of the <a href=\"manual.pdf\">users manual</a> called Makefiles\n\n      <h3><a name=\"cmake\">Can I use CMake to build my own project that depends on PETSc?</a></h3>\n\n      Use the FindPETSc.cmake module from <a\n        href=\"https://github.com/jedbrown/cmake-modules/\">this repository</a>.\n      See the CMakeLists.txt from <a\n        href=\"https://github.com/jedbrown/dohp\">Dohp</a> for example usage.\n\n      <h3><a name=\"carriagereturns\">How can I put carriage returns in PetscPrintf() statements from Fortran?</a></h3>\n\n      <p>\n        You can use the same notation as in C, just put a \\n in the string. Note\n        that no other C format instruction is supported.\n      </p>\n\n      <p>\n        Or you can use the Fortran concatination // and char(10); for example\n        'some string'//char(10)//'another string on the next line'\n      </p>\n\n      <h3><a name=\"cxxmethod\">How can I implement callbacks using C++ class methods?</a></h3>\n\n      <p>\n        Declare the class method <tt>static</tt>. Static methods do not have a <tt>this</tt> pointer, but the <tt>void*</tt> context parameter will usually be cast to a pointer to the class where it can serve the same function. Note that all PETSc callbacks return <tt>PetscErrorCode</tt>.\n      </p>\n\n      <h3><a name=\"functionjacobian\">Everyone knows that when you code Newton's method you should compute the function and its Jacobian at the same time. How can one do this in PETSc?</a></h3>\n\n      <p>\n        The update in Newton's method is computed as u^{n+1} = u^n - lambda\n        * approx-inverse[J(u^n)] * F(u^n)]. The reason PETSc doesn't default to\n        computing both the function and Jacobian at the same time is<br>\n      </p>\n\n      <ol>\n        <li>\n          In order to do the line search, F (u^n - lambda * step) may need to be\n          computed for several lambda, the Jacobian is not needed for each of\n          those and one does not know in advance which will be the final lambda\n          until after the function value is computed, so many extra Jacobians may\n          be computed.\n        </li>\n        <li>\n          In the final step if || F(u^p)|| satisfies the convergence criteria\n          then a Jacobian need not be computed.\n        </li>\n      </ol>\n\n      <p>\n        You are free to have your \"FormFunction\" compute as\n        much of the Jacobian at that point as you like, keep\n        the information in the user context (the final\n        argument to FormFunction and FormJacobian) and then\n        retreive the information in your FormJacobian()\n        function.\n      </p>\n\n      <h3><a name=\"conditionnumber\">How can I determine the condition number of a matrix?</a></h3>\n\n      For small matrices, the condition number can be reliably computed using\n      <code>-pc_type svd -pc_svd_monitor</code>.  For larger matrices, you can\n      run with <code>-pc_type none -ksp_type gmres -ksp_monitor_singular_value\n        -ksp_gmres_restart 1000</code> to get approximations to the condition\n      number of the operator. This will generally be accurate for the largest\n      singular values, but may overestimate the smallest singular value unless\n      the method has converged. Make sure to avoid restarts. To estimate the\n      condition number of the preconditioned operator, use <code>-pc_type\n        somepc</code> in the last command.\n\n      <h3><a name=\"invertmatrix\">How can I compute the inverse of a matrix in PETSc?</a></h3>\n\n      It is very expensive to compute the inverse of a matrix and very rarely\n      needed in practice. We highly recommend avoiding algorithms that need it.\n      The inverse of a matrix (dense or sparse) is essentially always dense, so\n      begin by creating a dense matrix B and fill it with the identity matrix\n      (ones along the diagonal), also create a dense matrix X of the same size\n      that will hold the solution. Then factor the matrix you wish to invert with\n      MatLUFactor() or MatCholeskyFactor(), call the result A. Then call MatMatSolve(A,B,X)\n      to compute the inverse into X. <a href=\"#schurcomplement\">See also</a>.\n\n      <h3><a name=\"schurcomplement\">How can I compute the Schur complement, Kbb - Kab * inverse(Kbb) * Kba in PETSc?</a></h3>\n\n      <p>\n        It is very expensive to compute the Schur complement of a matrix and very\n        rarely needed in practice. We highly recommend avoiding algorithms that\n        need it. The Schur complement of a matrix (dense or sparse) is essentially\n        always dense, so begin by\n      </p>\n\n      <ul>\n        <li>forming a dense matrix Kba,</li>\n        <li>also create another dense matrix T of the same size.</li>\n        <li>\n          Then either factor the matrix Kaa directly with MatLUFactor() or\n          MatCholeskyFactor(), or use MatGetFactor() followed by\n          MatLUFactorSymbolic() followed by MatLUFactorNumeric() if you wish to\n          use and external solver package like SuperLU_Dist.  Call the result A.\n        </li>\n        <li>Then call MatMatSolve(A,Kba,T).</li>\n        <li>Then call MatMatMult(Kab,T,MAT_INITIAL_MATRIX,1.0,&amp;S).</li>\n        <li>Now call MatAXPY(S,-1.0,Kbb,MAT_SUBSET_NONZERO).</li>\n        <li>Followed by MatScale(S,-1.0);</li>\n      </ul>\n\n      For computing Schur complements like this it does not make sense to use the\n      KSP iterative solvers since for solving many moderate size problems using\n      a direct factorization is much faster than iterative solvers.  As you can\n      see, this requires a great deal of work space and computation so is best\n      avoided.  However, it is not necessary to assemble the Schur complement\n      S in order to solve systems with it.\n\n      Use MatCreateSchurComplement(Kaa,Kaa_pre,Kab,Kba,Kbb,&amp;S) to create\n      a matrix that applies the action of S (using Kaa_pre to solve with Kaa),\n      but does not assemble.  Alternatively, if you already have a block matrix\n      K = [Kaa, Kab; Kba, Kbb] (in some ordering), then you can create index sets\n      (IS) isa and isb to address each block, then use MatGetSchurComplement() to\n      create the Schur complement and/or an approximation suitable for\n      preconditioning.  Since S is generally dense, standard preconditioning\n      methods cannot typically be applied directly to Schur complements.  There\n      are many approaches to preconditioning Schur complements including using\n      the SIMPLE approximation K_bb - Kba inv(diag(Kaa)) Kab to create a sparse\n      matrix that approximates the Schur complement (this is returned by default\n      for the optional \"preconditioning\" matrix in MatGetSchurComplement()).  An\n      alternative is to interpret the matrices as differential operators and\n      apply approximate commutator arguments to find a spectrally equivalent\n      operation that can be applied efficiently (see the \"PCD\" preconditioners\n      from Elman, Silvester, and Wathen).  A variant of this is the least squares\n      commutator, which is closely related to the Moore-Penrose pseudoinverse,\n      and is available in PCLSC which operates on matrices of type\n      MATSCHURCOMPLEMENT.\n\n      <h3><a name=\"fem\">Do you have examples of doing unstructured grid finite element computations (FEM) with PETSc?</a></h3>\n\n      There are at least two ways to write a finite element code using PETSc\n\n      <ol>\n        <li>\n          use the Sieve construct in PETSc, this is a high\n          level approach that uses a small number of\n          abstractions to help you manage distributing the\n          grid data structures and computing the elements into\n          the matrices.\n        </li>\n        <li>\n          manage the grid data structure yourself and use\n          PETSc IS and VecScatter to communicate the required\n          ghost point communication. See <a href=\"http://www.mcs.anl.gov/petsc/petsc-current/src/snes/examples/tutorials/ex10d/ex10.c.html\">src/snes/examples/tutorials/ex10d/ex10.c</a>\n        </li>\n      </ol>\n\n      <h3><a name=\"da_mpi_cart\">The PETSc DA object decomposes the domain differently than the MPI_Cart_create() command. How can one use them together?</a></h3>\n\n      <p>\n        The MPI_Cart_create() first divides the mesh along the z direction, then\n        the y, then the x. DMDA divides along the x, then y, then z. Thus, for\n        example, rank 1 of the processes will be in a different part of the mesh\n        for the two schemes. To resolve this you can create a new MPI\n        communicator that you pass to DMDACreate() that renumbers the process\n        ranks so that each physical process shares the same part of the mesh with\n        both the DMDA and the MPI_Cart_create(). The code to determine the new\n        numbering was provided by Rolf Kuiper.\n      </p>\n\n      <pre>\n// the numbers of processors per direction are (int) x_procs, y_procs, z_procs respectively\n// (no parallelization in direction 'dir' means dir_procs = 1)\n\nMPI_Comm NewComm;\nint MPI_Rank, NewRank, x,y,z;\n\n// get rank from MPI ordering:\nMPI_Comm_rank(MPI_COMM_WORLD, &amp;MPI_Rank);\n\n// calculate coordinates of cpus in MPI ordering:\nx = MPI_rank / (z_procs*y_procs);\ny = (MPI_rank % (z_procs*y_procs)) / z_procs;\nz = (MPI_rank % (z_procs*y_procs)) % z_procs;\n\n// set new rank according to PETSc ordering:\nNewRank = z*y_procs*x_procs + y*x_procs + x;\n\n// create communicator with new ranks according to\nPETSc ordering:\nMPI_Comm_split(PETSC_COMM_WORLD, 1, NewRank, &amp;NewComm);\n\n// override the default communicator (was\nMPI_COMM_WORLD as default)\nPETSC_COMM_WORLD = NewComm;\n    </pre>\n\n      <h3><a name=\"redistribute\">The When solving a system with Dirichlet boundary conditions I can use MatZeroRows() to eliminate the Dirichlet rows but this results in a non-symmetric system. How can I apply Dirichlet boundary conditions but keep the matrix symmetric?</a></h3>\n\n      <p>\n        For nonsymmetric systems put the appropriate boundary solutions in the\n        x vector and use MatZeroRows() followed by KSPSetOperators(). For symmetric\n        problems use MatZeroRowsColumns() instead.  If you have many Dirichlet\n        locations you can use MatZeroRows() (not MatZeroRowsColumns()) and\n        -ksp_type preonly -pc_type redistribute, see the manual page for\n        PCREDISTRIBUTE) and PETSc will repartition the parallel matrix for load\n        balancing; in this case the new matrix solved remains symmetric even though\n        MatZeroRows() is used.\n      </p>\n\n      <p>\n        An alternative approach is when assemblying the matrix, (generating values\n        and passing them to the matrix), never include locations for the Dirichlet\n        grid points in the vector and matrix, instead take them into account as you\n        put the other values into the load.\n      </p>\n\n      <h3><a name=\"matlab\">How can I get PETSc Vecs and Mats to MATLAB or vice versa?</a></h3>\n\n      There are five ways to work with PETSc and MATLAB\n\n      <ol>\n        <li>\n          Using the MATLAB Engine, this allows PETSc to automatically call MATLAB\n          to perform some specific computations. It does not allow MATLAB to be\n          used interactively by the user. See the <a\n            href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manualpages/Sys/PetscMatlabEngine.html\">PetscMatlabEngine</a>.\n        </li>\n\n        <li>\n          To save PETSc Mat and Vecs to files that can be read from MATLAB use <a\n            href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manualpages/Viewer/PetscViewerBinaryOpen.html\">PetscViewerBinaryOpen()</a>\n          viewer and VecView() or MatView() to save objects for MATLAB and\n          VecLoad() and MatLoad() to get the objects that MATLAB has saved. See\n          PetscBinaryRead.m and PetscBinaryWrite.m in bin/matlab for loading and\n          saving the objects in MATLAB.\n        </li>\n\n        <li>\n          You can open a socket connection between MATLAB and PETSc to allow\n          sending objects back and forth between an interactive MATLAB session\n          and a running PETSc program. See\n          <a href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manualpages/Viewer/PetscViewerSocketOpen.html\">PetscViewerSocketOpen</a>()\n          for access from the PETSc side and PetscOpenSocket in bin/matlab for\n          access from the MATLAB side.\n        </li>\n\n        <li>\n          You can save PETSc Vecs (not Mats) with the <a\n            href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manualpages/Viewer/PetscViewerMatlabOpen.html\">PetscViewerMatlabOpen</a>()\n          viewer that saves .mat files can then be loaded into MATLAB.\n        </li>\n        <li>\n          We are just being to develop in <a\n            href=\"../developers/index.html\">petsc-dev</a> an API to call most of\n          the PETSc function directly from MATLAB; we could use help in\n          developing this. See bin/matlab/classes/PetscInitialize.m\n        </li>\n      </ol>\n\n      <h3><a name=\"cython\">How do I get started with Cython so that I can extend petsc4py?</a></h3>\n\n      Steps I used:\n\n      <ol>\n        <li>\n          Learn how to <a href=\"http://docs.cython.org/src/quickstart/build.html\">build a Cython module</a>\n        </li>\n        <li>\n          Go through the simple example provided by Denis <a href=\"http://stackoverflow.com/questions/3046305/simple-wrapping-of-c-code-with-cython\">here</a>.\n          Note also the next comment that shows how to create numpy arrays in the Cython and pass them back.\n        </li>\n        <li>\n          Check out <a href=\"http://docs.cython.org/src/tutorial/numpy.html\">this page</a> which tells you how to get fast indexing\n        </li>\n        <li>\n          Have a look at the petsc4py <a href=\"http://code.google.com/p/petsc4py/source/browse/src/PETSc/arraynpy.pxi\">array source</a>\n        </li>\n      </ol>\n\n      <hr>\n\n      <h2><a name=\"execution\">Execution</a></h2>\n\n      <h3><a name=\"long-link-time\">PETSc executables are SO big and take SO long to link.</a></h3>\n\n      We find this annoying as well. On most machines PETSc can use shared\n      libraries, so executables should be much smaller, run ./configure with the\n      additional option --with-shared-libraries. Also, if you have room,\n      compiling and linking PETSc on your machine's /tmp disk or similar local\n      disk, rather than over the network will be much faster.\n\n      <h3><a name=\"petsc-options\">PETSc has so many options for my program that it is hard to keep them straight.</a></h3>\n\n      Running the PETSc program with the option -help will print of many of the\n      options. To print the options that have been specified within a program,\n      employ -optionsleft to print any options that the user specified but were\n      not actually used by the program and all options used; this is helpful for\n      detecting typo errors.\n\n      <h3><a name=\"petsc-log-info\">PETSc automatically handles many of the details in parallel PDE solvers. How can I understand what is really happening within my program?</a></h3>\n\n      You can use the option -info to get more details about the solution\n      process. The option -log_summary provides details about the distribution of\n      time spent in the various phases of the solution process. You can run with\n      -ts_view or -snes_view or -ksp_view to see what solver options are being\n      used. Run with -ts_monitor -snes_monitor or -ksp_monitor to watch\n      convergence of the methods.  -snes_converged_reason and\n      -ksp_converged_reason will indicate why and if the solvers have converged.\n\n      <h3><a name=\"efficient-assembly\">Assembling large sparse matrices takes a long time. What can I do make this process faster? or MatSetValues() is so slow, what can I do to speed it up?</a></h3>\n\n      See the <a href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manual.pdf#nameddest=ch_performance\">Performance chapter of the users manual</a> for many tips on this.\n\n      <ol>\n        <li>\n          Preallocate enough space for the sparse matrix. For example, rather\n          than calling MatCreateSeqAIJ(comm,n,n,0,NULL,&amp;mat); call\n          MatCreateSeqAIJ(comm,n,n,rowmax,NULL,&amp;mat); where rowmax is\n          the maximum number of nonzeros expected per row. Or if you know the\n          number of nonzeros per row, you can pass this information in instead of\n          the NULL argument. See the manual pages for each of the\n          MatCreateXXX() routines.\n        </li>\n\n        <li>\n          Insert blocks of values into the matrix, rather than individual components.\n        </li>\n      </ol>\n\n\n      <p>Preallocation of matrix memory is crucial for good performance for large problems, see:</p>\n\n      <ul>\n        <li><a href=\"manual.pdf#sec_matsparse\">manual.pdf#sec_matsparse</a></li>\n        <li><a href=\"manualpages/Mat/MatCreateMPIAIJ.html\">manualpages/Mat/MatCreateMPIAIJ.html</a></li>\n      </ul>\n\n      <p>\n        If you can set several nonzeros in a block at the same time, this is faster\n        than calling MatSetValues() for each individual matrix entry.\n      </p>\n\n      <p>\n        It is best to generate most matrix entries on the process they belong to\n        (so they do not have to be stashed and then shipped to the owning process).\n        Note: it is fine to have some entries generated on the \"wrong\" process,\n        just not many.\n      </p>\n\n      <h3><a name=\"log-summary\">How can I generate performance summaries with PETSc?</a></h3>\n\n      Use these options at runtime: -log_summary. See the <a href=\"http://www.mcs.anl.gov/petsc/petsc-dev/docs/manual.pdf#nameddest=ch_performance\">Performance chapter of the users manual</a>\n      for information on interpreting the summary data. If using the PETSc\n      (non)linear solvers, one can also specify -snes_view or -ksp_view for\n      a printout of solver info. Only the highest level PETSc object used needs\n      to specify the view option.\n\n      <h3><a name=\"parallel-roundoff\">Why do I get different answers on a different numbers of processors?</a></h3>\n\n      Most commonly, you are using a preconditioner which behaves differently\n      based upon the number of processors, such as Block-Jacobi which is the\n      PETSc default. However, since computations are reordered in parallel, small\n      roundoff errors will still be present with identical mathematical\n      formulations. If you set a tighter linear solver tolerance (using\n      -ksp_rtol), the differences will decrease.\n\n      <h3><a name=\"mg-log\">How do I know the amount of time spent on each level of the multigrid solver/preconditioner?</a></h3>\n\n      Run with <code>-log_summary</code> and <code>-pc_mg_log</code>\n\n      <h3><a name=\"datafiles\">Where do I get the input matrices for the examples?</a></h3>\n\n      Some makefiles use ${DATAFILESPATH}/matrices/medium and other files. These\n      test matrices in PETSc binary format can be found with anonymous ftp from\n      <a href=\"http://ftp.mcs.anl.gov\">ftp.mcs.anl.gov</a> in the directory\n      pub/petsc/matrices. The are not included with the PETSc distribution in the\n      interest of reducing the distribution size.\n\n      <h3><a name=\"info\">When I dump some matrices and vectors to binary, I seem to be generating some empty files with .info extensions. What's the deal with these?</a></h3>\n\n      PETSc binary viewers put some additional information into .info files like\n      matrix block size; it is harmless but if you really don't like it you can\n      use -viewer_binary_skip_info or PetscViewerBinarySkipInfo() note you need\n      to call PetscViewerBinarySkipInfo() before PetscViewerFileSetName(). In\n      other words you cannot use PetscViewerBinaryOpen() directly.\n\n      <h3><a name=\"slowerparallel\">Why is my parallel solver slower than my sequential solver, or I have poor speed-up?</a></h3>\n\n      This can happen for many reasons:\n\n      <ul>\n        <li>\n          First make sure it is truely the time in KSPSolve() that is slower (by\n          running the code with <a href=\"#log-summary\">-log_summary</a>).\n          Often the slower time is in <a href=\"#slow\">generating the matrix</a>\n          or some other operation.\n        </li>\n\n        <li>\n          There must be enough work for each process to overweigh the\n          communication time. We recommend an absolute minimum of about 10,000\n          unknowns per process, better is 20,000 or more.\n        </li>\n\n        <li>\n          Make sure the <a href=\"#computers\">communication speed of the parallel computer</a>\n          is good enough for parallel solvers.\n        </li>\n\n        <li>\n          Check the number of solver iterates with the parallel solver against\n          the sequential solver. Most preconditioners require more iterations\n          when used on more processes, this is particularly true for block\n          Jaccobi, the default parallel preconditioner, you can try -pc_type asm\n          (<a href=\"manualpages/PC/PCASM.html\">PCASM</a>)\n          its iterations scale a bit better for more processes.  You may also consider\n          multigrid preconditioners like <a href=\"manualpages/PC/PCMG.html\">PCMG</a>\n          or BoomerAMG in <a href=\"manualpages/PC/PCHYPRE.html\">PCHYPRE</a>.\n        </li>\n      </ul>\n\n      <h3><a name=\"pipelined\">What steps are necessary to make the pipelined solvers execute efficiently?</a></h3>\n\n      Pipelined solvers like\n      <a href=\"manualpages/KSP/KSPPGMRES.html\">KSPPGMRES</a>,\n      <a href=\"manualpages/KSP/KSPPIPECG.html\">KSPPIPECG</a>,\n      <a href=\"manualpages/KSP/KSPPIPECR.html\">KSPPIPECR</a>, and\n      <a href=\"manualpages/KSP/KSPGROPPCG.html\">KSPGROPPCG</a>\n      may require special MPI configuration to effectively overlap reductions with computation.\n      In general, this requires an MPI-3 implementation, an implementation that supports multiple threads, and use of a \"progress thread\".\n      Consult the documentation from your vendor or computing facility for more.\n\n      <dl>\n        <dt>MPICH</dt>\n        <dd>\n          MPICH version 3.0 and later implements the MPI-3 standard and the default configuration supports use of threads.\n          Use of a progress thread is configured by setting the environment variable <tt>MPICH_ASYNC_PROGRESS=1</tt>.\n        </dd>\n        <dt>Cray MPI</dt>\n        <dd>\n          Cray MPT-5.6 supports MPI-3, but requires the environment variable <tt>MPICH_MAX_THREAD_SAFETY=multiple</tt> for threads, plus either <tt>MPICH_ASYNC_PROGRESS=1</tt> or <tt>MPICH_NEMESIS_ASYNC_PROGRESS=1</tt>.\n        </dd>\n      </dl>\n\n      <h3><a name=\"singleprecision\">When using PETSc in single precision mode (--with-precision=single when running ./configure) are the operations done in single or double precision?</a></h3>\n\n      PETSc does NOT do any explicit conversion of single precision to double\n      before performing computations; this it depends on the hardware and\n      compiler what happens. For example, the compiler could choose to put the\n      single precision numbers into the usual double precision registers and then\n      use the usual double precision floating point unit.  Or it could use SSE2\n      instructions that work directly on the single precision numbers. It is\n      a bit of a mystery what decisions get made sometimes. There may be compiler\n      flags in some circumstances that can affect this.\n\n      <h3><a name=\"newton\">Why is Newton's method (SNES) not converging, or converges slowly?</a></h3>\n\n      Newton's method may not converge for many reasons, here are some of the most common.\n\n      <ul>\n        <li>The Jacobian is wrong (or correct in sequential but not in parallel).</li>\n        <li>The linear system <a href=\"#kspdiverged\">is not solved</a> or is not solved accurately enough.</li>\n        <li>The Jacobian system has a singularity that the linear solver is not handling.</li>\n        <li>There is a bug in the function evaluation routine.</li>\n        <li>The function is not continuous or does not have continuous first derivatives (e.g. phase change or TVD limiters).</li>\n        <li>\n          The equations may not have a solution (e.g. limit cycle instead of\n          a steady state) or there may be a \"hill\" between the initial guess and\n          the steady state (e.g. reactants must ignite and burn before reaching\n          a steady state, but the steady-state residual will be larger during\n          combustion).\n        </li>\n      </ul>\n\n      Here are some of the ways to help debug lack of convergence of Newton.\n\n      <ul>\n        <li>Run with the options <code>-snes_monitor -ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason</code>.\n          <ul>\n            <li>\n              If the linear solve does not converge, check if the Jacobian is\n              correct, then see <a href=\"#kspdiverged\">this question</a>.\n            </li>\n            <li>\n              If the preconditioned residual converges, but the true residual\n              does not, the preconditioner may be singular.\n            </li>\n            <li>\n              If the linear solve converges well, but the line search fails, the\n              Jacobian may be incorrect.\n            </li>\n          </ul>\n        </li>\n\n        <li>\n          Run with <code>-pc_type lu</code> or <code>-pc_type svd</code> to see\n          if the problem is a poor linear solver\n        </li>\n\n        <li>\n          Run with <code>-mat_view</code> or <code>-mat_view draw</code> to see\n          if the Jacobian looks reasonable\n        </li>\n\n        <li>\n          Run with <code>-snes_type test -snes_test_display</code> to see if the\n          Jacobian you are using is wrong. Compare the output when you add\n          <code>-mat_fd_type ds</code> to see if the result is sensitive to the\n          choice of differencing parameter.\n        </li>\n\n        <li>\n          Run with <code>-snes_mf_operator -pc_type lu</code> to see if the\n          Jacobian you are using is wrong. If the problem is too large for\n          a direct solve, try <code>-snes_mf_operator -pc_type ksp -ksp_ksp_rtol\n            1e-12</code>. Compare the output when you add <code>-mat_mffd_type\n            ds</code> to see if the result is sensitive to choice of differencing\n          parameter.\n        </li>\n\n        <li>Run on one processor to see if the problem is only in parallel.</li>\n\n        <li>\n          Run with <code>-snes_linesearch_monitor</code> to see if the line search\n          is failing (this is usually a sign of a bad Jacobian). Use -info in PETSc 3.1\n          and older versions, <code>-snes_ls_monitor</code> in PETSc 3.2\n          and <code>-snes_linesearch_monitor</code> in PETSc 3.3 and later.\n        </li>\n\n        <li>\n          Run with <code>-info</code> to get more detailed information on the\n          solution process.\n        </li>\n      </ul>\n\n      Here are some ways to help the Newton process if everything above checks out\n\n      <ul>\n        <li>\n          Run with grid sequencing (<code>-snes_grid_sequence</code> if working\n          with a DM is all you need) to generate better initial guess on your\n          finer mesh\n        </li>\n\n        <li>\n          Run with quad precision (./configure with --with-precision=__float128\n          --download-f2cblaslapack with PETSc 3.2 and later and recent versions\n          of the GNU compilers)\n        </li>\n\n        <li>\n          Change the units (nondimensionalization), boundary condition scaling,\n          or formulation so that the Jacobian is better conditioned. See <a href=\"http://en.wikipedia.org/wiki/Buckingham_\u03c0_theorem\">http://en.wikipedia.org/wiki/Buckingham_\u03c0_theorem</a>\n        </li>\n\n        <li>\n          Mollify features in the function that do not have continuous first\n          derivatives (often occurs when there are \"if\" statements in the\n          residual evaluation, e.g.  phase change or TVD limiters). Use\n          a variational inequality solver (SNESVINEWTONRSLS) if the discontinuities are\n          of fundamental importance.\n        </li>\n\n        <li>\n          Try a trust region method (<code>-ts_type tr</code>, may have to adjust\n          parameters).\n        </li>\n\n        <li>\n          Run with some continuation parameter from a point where you know the\n          solution, see TSPSEUDO for steady-states.\n        </li>\n\n        <li>\n          There are homotopy solver packages like PHCpack that can get you all\n          possible solutions (and tell you that it has found them all) but those\n          are not scalable and cannot solve anything but small problems.\n        </li>\n      </ul>\n\n      <h3><a name=\"kspdiverged\">Why is the linear solver (KSP) not converging, or converges slowly?</a></h3>\n\n      <p>\n        Always run with <code>-ksp_converged_reason -ksp_monitor_true_residual</code>\n        when trying to learn why a method is not converging. Common reasons for\n        KSP not converging are\n      </p>\n\n      <ul>\n        <li>\n          The equations are singular by accident (e.g. forgot to impose boundary\n          conditions). Check this for a small problem using <code>-pc_type svd\n            -pc_svd_monitor</code>.\n        </li>\n\n        <li>\n          The equations are intentionally singular (e.g.  constant null space),\n          but the Krylov method was not informed, see KSPSetNullSpace().\n        </li>\n\n        <li>\n          The equations are intentionally singular and KSPSetNullSpace() was\n          used, but the right hand side is not consistent. You may have to call\n          MatNullSpaceRemove() on the right hand side before calling KSPSolve().\n        </li>\n\n        <li>\n          The equations are indefinite so that standard preconditioners don't\n          work. Usually you will know this from the physics, but you can check\n          with <code>-ksp_compute_eigenvalues -ksp_gmres_restart 1000 -pc_type none</code>.\n          For simple saddle point problems, try <code>-pc_type fieldsplit\n            -pc_fieldsplit_type schur -pc_fieldsplit_detect_saddle_point</code>.\n          For more difficult problems, read the literature to find robust methods\n          and ask petsc-users@mcs.anl.gov or petsc-maint@mcs.anl.gov if you want\n          advice about how to implement them.\n        </li>\n\n        <li>\n          If the method converges in preconditioned residual, but not in true\n          residual, the preconditioner is likely singular or nearly so. This is\n          common for saddle point problems (e.g. incompressible flow) or strongly\n          nonsymmetric operators (e.g. low-Mach hyperbolic problems with large\n          time steps).\n        </li>\n\n        <li>\n          The preconditioner is too weak or is unstable. See if <code>-pc_type\n            asm -sub_pc_type lu</code> improves the convergence rate. If GMRES is\n          losing too much progress in the restart, see if longer restarts help\n          <code>-ksp_gmres_restart 300</code>. If a transpose is available, try\n          <code>-ksp_type bcgs</code> or other methods that do not require\n          a restart. (Note that convergence with these methods is frequently\n          erratic.)\n        </li>\n\n        <li>\n          The preconditioner is nonlinear (e.g. a nested iterative solve), try\n          <code>-ksp_type fgmres</code> or <code>-ksp_type gcr</code>.\n        </li>\n\n        <li>\n          You are using geometric multigrid, but some equations (often boundary\n          conditions) are not scaled compatibly between levels. Try\n          <code>-pc_mg_galerkin</code> to algebraically construct a correctly\n          scaled coarse operator or make sure that all the equations are scaled\n          in the same way if you want to use rediscretized coarse levels.\n        </li>\n\n        <li>\n          The matrix is very ill-conditioned. Check the <a href=\"#conditionnumber\">condition number</a>.\n          <ul>\n            <li> Try to improve it by choosing the relative scaling of components/boundary conditions.</li>\n            <li>Try <code>-ksp_diagonal_scale -ksp_diagonal_scale_fix</code>.</li>\n            <li>Perhaps change the formulation of the problem to produce more friendly algebraic equations.</li>\n          </ul>\n        </li>\n\n        <li>\n          The matrix is nonlinear (e.g. evaluated using finite differencing of\n          a nonlinear function). Try different differencing parameters,\n          <code>./configure --with-precision=__float128 --download-f2cblaslapack</code>,\n          check if it converges in \"easier\" parameter regimes.\n        </li>\n\n        <li>A symmetric method is being used for a non-symmetric problem.</li>\n\n        <li>\n          Classical Gram-Schmidt is becoming unstable, try <code>-ksp_gmres_modifiedgramschmidt</code>\n          or use a method that orthogonalizes differently, e.g. <code>-ksp_type gcr</code>.\n        </li>\n      </ul>\n\n      <hr>\n\n      <h2><a name=\"debugging\">Debugging</a></h2>\n\n      <h3><a name=\"debug-ibm\">How do I turn off PETSc signal handling so I can use the -C option on xlF?</a></h3>\n\n      <p>Immediately after calling PetscInitialize() call PetscPopSignalHandler()</p>\n\n      <p>\n        Some Fortran compilers including the IBM xlf, xlF etc compilers have\n        a compile option (-C for IBM's) that causes all array access in Fortran\n        to be checked that they are in-bounds. This is a great feature but does\n        require that the array dimensions be set explicitly, not with a *.\n      </p>\n\n      <h3><a name=\"start_in_debugger-doesnotwork\">How do I debug if -start_in_debugger does not work on my machine?</a></h3>\n\n      <p> On newer Mac OSX machines - one has to be in admin group to be able to use debugger</p>\n\n      <p>\n        On newer UBUNTU linux machines - one has to disable <a href=\"https://wiki.ubuntu.com/Security/Features#ptrace\">ptrace_scop</a>\n        with \"sudo echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope\" - to get start\n        in debugger working.\n      </p>\n\n      <p>\n        If start_in_debugger does not really work on your OS, for a uniprocessor\n        job, just try the debugger directly, for example: gdb ex1. You can also\n        use Totalview which is a good graphical parallel debugger.\n      </p>\n\n      <h3><a name=\"debug-hang\">How do I see where my code is hanging?</a></h3>\n\n      You can use the -start_in_debugger option to start all processes in the\n      debugger (each will come up in its own xterm) or run in Totalview. Then use\n      cont (for continue) in each xterm. Once you are sure that the program is\n      hanging, hit control-c in each xterm and then use 'where' to print a stack\n      trace for each process.\n\n      <h3><a name=\"debug-inspect\">How can I inspect Vec and Mat values when in the debugger?</a></h3>\n\n      <p>\n        I will illustrate this with gdb, but it should be similar on other\n        debuggers. You can look at local Vec values directly by obtaining the\n        array. For a Vec v, we can print all local values using\n      </p>\n\n      <pre>\n(gdb) p ((Vec_Seq*) v-&gt;data)-&gt;array[0]@v-&gt;map.n\n    </pre>\n\n      <p>\n        However, this becomes much more complicated for a matrix.  Therefore, it\n        is advisable to use the default viewer to look at the object. For a Vec\n        v and a Mat m, this would be\n      </p>\n\n      <pre>\n  (gdb) call VecView(v, 0)\n  (gdb) call MatView(m, 0)\n    </pre>\n\n      <p>or with a communicator other than MPI_COMM_WORLD,</p>\n\n      <pre>\n(gdb) call MatView(m, PETSC_VIEWER_STDOUT_(m-&gt;comm))\n    </pre>\n\n      <p>\n        Totalview 8.8.0 has a new feature that allows libraries to provide their\n        own code to display objects in the debugger. Thus in theory each PETSc\n        object, Vec, Mat etc could have custom code to print values in the\n        object. We have only done this for the most elementary display of Vec and\n        Mat. See the routine TV_display_type() in src/vec/vec/interface/vector.c\n        for an example of how these may be written. Contact us if you would like\n        to add more.\n      </p>\n\n      <h3><a name=\"debug-fp\">How can I find the cause of floating point exceptions like not-a-number (NaN) or infinity?</a></h3>\n      <p>\n        The best way to locate floating point exceptions is to use a debugger.\n        On supported architectures (including Linux and glibc-based systems), just run in a debugger and pass -fp_trap to the PETSc application.\n        This will activate signaling exceptions and the debugger will break on the line that first divides by zero or otherwise generates an exceptions.\n        Without a debugger, running with -fp_trap in debug mode will only identify the function in which the error occurred, but not the line or the type of exception.\n        If -fp_trap is not supported on your architecture, consult the documentation for your debugger since there is likely a way to have it catch exceptions.\n      </p>\n\n      <h3><a name=\"libimf\">Error while loading shared libraries: libimf.so: cannot open shared object file: No such file or directory.</a></h3>\n\n      <p>\n        The Intel compilers use shared libraries (like libimf) that cannot by\n        default at run time. When using the Intel compilers (and running the\n        resulting code) you must make sure that the proper Intel initialization\n        scripts are run.  This is usually done by putting some code into your\n        .cshrc, .bashrc, .profile etc file. Sometimes on batch file systems that\n        do now access your initialization files (like .cshrc) you must include\n        the initialization calls in your batch file submission.\n      </p>\n\n      For example, on my Mac using csh I have the following in my .cshrc file\n\n      <pre>\nsource /opt/intel/cc/10.1.012/bin/iccvars.csh\nsource /opt/intel/fc/10.1.012/bin/ifortvars.csh\nsource /opt/intel/idb/10.1.012/bin/idbvars.csh\n    </pre>\n\n      in my .profile I have\n\n      <pre>\nsource /opt/intel/cc/10.1.012/bin/iccvars.sh\nsource /opt/intel/fc/10.1.012/bin/ifortvars.sh\nsource /opt/intel/idb/10.1.012/bin/idbvars.sh\n    </pre>\n\n      <h3><a name=\"objecttypenotset\">What does Object Type not set: Argument # n mean?</a></h3>\n\n      Many operations on PETSc objects require that the specific type of the\n      object be set before the operations is performed. You must call\n      XXXSetType() or XXXSetFromOptions() before you make the offending call. For\n      example, MatCreate(comm,&amp;A); MatSetValues(A,....); will not work.  You\n      must add MatSetType(A,...) or MatSetFromOptions(A,....); before the call to\n      MatSetValues();\n\n      <h3><a name=\"split\">What does <code>Error detected in PetscSplitOwnership() about \"sum of local lengths ...\":</code> mean?</a></h3>\n\n      In a previous call to VecSetSizes(), MatSetSizes(), VecCreateXXX() or\n      MatCreateXXX() you passed in local and global sizes that do not make sense\n      for the correct number of processors. For example if you pass in a local\n      size of 2 and a global size of 100 and run on two processors, this cannot\n      work since the sum of the local sizes is 4, not 100.\n\n      <h3><a name=\"valgrind\">What does <code>Corrupt argument or Caught signal or SEQV or segmentation violation or bus error</code> mean? Can I use valgrind to debug memory corruption issues?</a></h3>\n\n      <p>\n        Sometimes it can mean an argument to a function is invalid. In Fortran\n        this may be caused by forgeting to list an argument in the call,\n        especially the final ierr.\n      </p>\n\n      <p>\n        Otherwise it is usually caused by memory corruption; that is somewhere\n        the code is writing out of array bounds. To track this down rerun the\n        debug version of the code with the option -malloc_debug. Occasionally the\n        code may crash only with the optimized version, in that case run the\n        optimized version with -malloc_debug. If you determine the problem is\n        from memory corruption you can put the macro CHKMEMQ in the code near the\n        crash to determine exactly what line is causing the problem.\n      </p>\n\n      If -malloc_debug does not help: on GNU/Linux and Apple Mac OS X machines\n      - you can try using<a href=\"http://valgrind.org/\">http://valgrind.org</a>\n      to look for memory corruption. - Make sure valgrind is installed\n\n      <ul>\n        <li>Recommend building PETSc with <code>--download-mpich --with-debugging</code> [debugging is enabled by default]</li>\n        <li>Compile application code with this build of PETSc</li>\n        <li>run with valgrind using: <code>${PETSC_DIR}/bin/petscmpiexec -valgrind -n NPROC PETSCPROGRAMNAME -malloc off PROGRAMOPTIONS</code></li>\n        <li>or invoke valgrind directly with: <code>mpiexec -n NPROC valgrind --tool=memcheck -q --num-callers=20 --log-file=valgrind.log.%p PETSCPROGRAMNAME -malloc off PROGRAMOPTIONS</code></li>\n      </ul>\n\n      Notes:\n\n      <ul>\n        <li>option <code>--with-debugging</code> enables valgrind to give stack trace with additional source-file:line-number info.</li>\n        <li>option <code>--download-mpich</code> gives valgrind clean MPI - hence the recommendation.</li>\n        <li>Wrt Other MPI impls, Open MPI should also work. MPICH1 will not work.</li>\n        <li>if <code>--download-mpich</code> is used - mpiexec will be in PETSC_ARCH/bin</li>\n        <li><code>--log-file=valgrind.log.%p</code> option tells valgrind to store the output from each proc in a different file [as %p i.e PID, is different for each MPI proc].</li>\n        <li>On Apple you need the additional valgrind option <code>--dsymutil=yes</code></li>\n        <li>memcheck will not find certain array access that violate static array declarations so if memcheck runs clean you can try the <code>--tool=exp-ptrcheck</code> instead.</li>\n      </ul>\n\n      <h3><a name=\"zeropivot\">What does <code>Detected zero pivot in LU factorization</code> mean?</a></h3>\n\n      <p>\n        A zero pivot in LU, ILU, Cholesky, or ICC sparse factorization does not\n        always mean that the matrix is singular. You can use '-pc_factor_shift_type\n        NONZERO -pc_factor_shift_amount [amount]' or '-pc_factor_shift_type\n        POSITIVE_DEFINITE'; '-[level]_pc_factor_shift_type NONZERO\n        -pc_factor_shift_amount [amount]'   or '-[level]_pc_factor_shift_type\n        POSITIVE_DEFINITE' to prevent the zero pivot. [level] is \"sub\" when lu,\n        ilu, cholesky, or icc are employed in each individual block of the bjacobi\n        or ASM preconditioner; and [level] is \"mg_levels\" or \"mg_coarse\" when lu,\n        ilu, cholesky, or icc are used inside multigrid smoothers or to the coarse\n        grid solver.  See PCFactorSetShiftType(), PCFactorSetAmount().\n      </p>\n\n      <p>This error can also happen if your matrix is singular, see KSPSetNullSpace() for how to handle this.</p>\n\n      <p>\n        If this error occurs in the zeroth row of the matrix, it is likely you have\n        an error in the code that generates the matrix.\n      </p>\n\n      <h3><a name=\"xwindows\">You create <code>Draw</code> windows or <code>ViewerDraw</code> windows or use options <code>-ksp_monitor_lg_residualnorm</code> or <code>-snes_monitor_lg_residualnorm</code> and the program seems to run OK but windows never open.</a></h3>\n\n      The libraries were compiled without support for X windows. Make sure that\n      ./configure was run with the option <code>--with-x</code>\n\n      <h3><a name=\"memory\">The program seems to use more and more memory as it runs, even though you don't think you are allocating more memory.</a></h3>\n\n      Problem: Possibly some of the following:\n\n      <ol>\n        <li>You are creating new PETSc objects but never freeing them.</li>\n\n        <li>There is a memory leak in PETSc or your code.</li>\n\n        <li>\n          Something much more subtle: (if you are using Fortran). When you\n          declare a large array in Fortran, the operating system does not\n          allocate all the memory pages for that array until you start using the\n          different locations in the array. Thus, in a code, if at each step you\n          start using later values in the array your virtual memory usage will\n          \"continue\" to increase as measured by <code>ps</code> or <code>top</code>.\n        </li>\n\n        <li>\n          You are running with the -log, -log_mpe, or -log_all option. He a great\n          deal of logging information is stored in memory until the conclusion of\n          the run.\n        </li>\n\n        <li>\n          You are linking with the MPI profiling libraries; these cause logging\n          of all MPI activities. Another Symptom is at the conclusion of the run\n          it may print some message about writing log files.\n        </li>\n      </ol>\n\n      Cures:\n\n      <ol>\n        <li>\n          Run with the -malloc_debug option and -malloc_dump. Or use the commands\n          PetscMallocDump() and PetscMallocLogDump() sprinkled in your code to\n          track memory that is allocated and not later freed. Use the commands\n          PetscMallocGetCurrentUsage() and PetscMemoryGetCurrentUsage() to\n          monitor memory allocated and PetscMallocGetMaximumUsage() and PetscMemoryGetMaximumUsage()\n          for total memory used ass the code progresses.\n        </li>\n\n        <li>This is just the way Unix works and is harmless.</li>\n\n        <li>\n          Do not use the -log, -log_mpe, or -log_all option, or use\n          PLogEventDeactivate() or PLogEventDeactivateClass(),\n          PLogEventMPEDeactivate() to turn off logging of specific events.\n        </li>\n\n        <li>Make sure you do not link with the MPI profiling libraries.</li>\n      </ol>\n\n      <h3><a name=\"key\">When calling MatPartitioningApply() you get a message Error! Key 16615 not found</a></h3>\n\n      The graph of the matrix you are using is not symmetric. You must use symmetric matrices for partitioning.\n\n      <h3><a name=\"gmres\">With GMRES At restart the second residual norm printed does not match the first.</a></h3>\n\n      <pre>\n26 KSP Residual norm 3.421544615851e-04\n27 KSP Residual norm 2.973675659493e-04\n28 KSP Residual norm 2.588642948270e-04\n29 KSP Residual norm 2.268190747349e-04\n30 KSP Residual norm 1.977245964368e-04\n30 KSP Residual norm 1.994426291979e-04 &lt;----- At restart the residual norm is printed a second time\n    </pre>\n\n      <p>\n        <b>Problem</b>: Actually this is not surprising. GMRES computes the norm of the\n        residual at each iteration via a recurrence relation between the norms of\n        the residuals at the previous iterations and quantities computed at the\n        current iteration; it does not compute it via directly || b - A x^{n} ||.\n        Sometimes, especially with an ill-conditioned matrix, or computation of the\n        matrix-vector product via differencing, the residual norms computed by\n        GMRES start to \"drift\" from the correct values. At the restart, we compute\n        the residual norm directly, hence the \"strange stuff,\" the difference\n        printed. The drifting, if it remains small, is harmless (doesn't effect the\n        accuracy of the solution that GMRES computes).\n      </p>\n\n      <p>\n        <b>Cure</b>: There realy isn't a cure, but if you use a more powerful\n        preconditioner the drift will often be smaller and less noticeable. Of if\n        you are running matrix-free you may need to tune the matrix-free\n        parameters.\n      </p>\n\n      <h3><a name=\"doubleits\">Why do some Krylov methods seem to print two residual norms per iteration?</a></h3>\n\n      <pre>\n1198 KSP Residual norm 1.366052062216e-04\n1198 KSP Residual norm 1.931875025549e-04\n1199 KSP Residual norm 1.366026406067e-04\n1199 KSP Residual norm 1.931819426344e-04\n    </pre>\n\n      <p>\n        Some Krylov methods, for example tfqmr, actually have a \"sub-iteration\"\n        of size 2 inside the loop; each of the two substeps has its own matrix\n        vector product and application of the preconditioner and updates the\n        residual approximations. This is why you get this \"funny\" output where it\n        looks like there are two residual norms per iteration. You can also think\n        of it as twice as many iterations.\n      </p>\n\n      <h3><a name=\"dylib\">Unable to locate PETSc dynamic library /home/balay/spetsc/lib/libg/linux/libpetsc</a></h3>\n\n      When using DYNAMIC libraries - the libraries cannot be moved after they are\n      installed. This could also happen on clusters - where the paths are\n      different on the (run) nodes - than on the (compile) front-end. Do not use\n      dynamic libraries &amp; shared libraries. Run ./configure with\n      <code>--with-shared-libraries=0 --with-dynamic-loading=0</code>\n\n      <h3><a name=\"bisect\">How do I determine what update to PETSc broke my code?</a></h3>\n\n      If at some point [in petsc code history] you had a working code - but the\n      latest petsc code broke it, its possible to determine the petsc code change\n      that might have caused this behavior. This is achieved by:\n\n      <ul>\n        <li>using <a href=\"http://git-scm.com/\">Git</a> to access PETSc sources</li>\n\n        <li>knowing the Git commit for the <b>known working</b> version of PETSc</li>\n\n        <li>knowing the Git commit for the <b>known broken</b> version of PETSc</li>\n\n        <li>using the <a href=\"https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html\">bisect</a> functionality of Git</li>\n      </ul>\n\n      This process can be as follows:\n\n      <ul>\n        <li>get petsc-dev sources:\n          <ul>\n            <li><code>git clone https://bitbucket.org/petsc/petsc</code></li>\n          </ul>\n        </li>\n\n        <li>\n          Find the <b>good</b> and <b>bad</b> markers to\n          start the bisection process. This can be done either by checking\n          <code>git log</code> or <code>gitk</code> or <a href=\"https://bitbucket.org/petsc/petsc\">https://bitbucket.org/petsc/petsc</a>\n          or the web history of petsc-release clones. Lets say the known bad\n          commit is 21af4baa815c and known good commit is 5ae5ab319844\n        </li>\n\n        <li>\n          Now start the bisection process with these known revisions. [build PETSc, and test your code to confirm known good/bad behavior]\n          <ul>\n            <li><code>git bisect start 21af4baa815c 5ae5ab319844</code></li>\n            <li>&lt;build/test/confirm-bad&gt;</li>\n            <li><code>git bisect bad</code></li>\n            <li>&lt;build/test/confirm-good&gt;</li>\n            <li><code>git bisect good</code></li>\n          </ul>\n        </li>\n\n        <li>\n          Now until done - keep bisecting, building PETSc, and testing your code with it and determine if the code is working or not.\n          After something like 5-15 iterations, <code>git bisect</code> will\n          pin-point the exact code change that resulted in the difference in\n          application behavior.\n        </li>\n\n        <li>\n          See <a href=\"https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html\">git-bisect(1)</a>\n          and the <a href=\"http://git-scm.com/book/en/Git-Tools-Debugging-with-Git\">debugging\n          section of the Git Book</a> for more debugging tips.\n        <li>\n      </ul>\n\n      <hr>\n\n      <h2><a name=\"shared-libraries\">Shared Libraries</a></h2>\n\n      <h3><a name=\"install-shared\">Can I install PETSc libraries as shared libraries?</a></h3>\n\n      Yes.Use the <code>./configure --with-shared-libraries</code>\n\n      <h3><a name=\"why-use-shared\">Why should I use shared libraries?</a></h3>\n\n      When you link to shared libraries, the function symbols from the shared\n      libraries are not copied in the executable. This way the size of the\n      executable is considerably smaller than when using regular libraries.  This\n      helps in a couple of ways:\n\n      <ol>\n        <li>saves disk space when more than one executable is created, and</li>\n        <li>improves the compile time immensly, because the compiler has to write a much smaller file (executable) to the disk.</li>\n      </ol>\n\n      <h3><a name=\"link-shared\">How do I link to the PETSc shared libraries?</a></h3>\n\n      By default, the compiler should pick up the shared libraries instead of the regular ones. Nothing special should be done for this.\n\n      <h3><a name=\"link-regular-lib\">What If I want to link to the regular .a library files?</a></h3>\n\n      You must run ./configure without the option --with-shared-libraries (you\n      can use a different PETSC_ARCH for this build so you can easily switch\n      between the two).\n\n      <h3><a name=\"move-shared-exec\">What do I do if I want to move my executable to a different machine?</a></h3>\n\n      <p>\n        You would also need to have access to the shared libraries on this new\n        machine. The other alternative is to build the exeutable without shared\n        libraries by first deleting the shared libraries, and then creating the\n        executable.\n      </p>\n\n      <h3><a name=\"dynamic-shared\">What is the deal with dynamic libraries (and difference between shared libraries)?</a></h3>\n\n      <p>\n        PETSc libraries are installed as dynamic libraries when the ./configure\n        flag --with-dynamic-loading is used. The difference with this - from\n        shared libraries - is the way the libraries are used. From the program\n        the library is loaded using dlopen() - and the functions are searched\n        using dlsymm(). This separates the resolution of function names from\n        link-time to run-time - i.e when dlopen()/dlsymm() are called.\n      </p>\n\n      <p>\n        When using Dynamic libraries - PETSc libraries cannot be moved to\n        a different location after they are built.\n      </p>\n\n    </div>\n\n    \n  </body>\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/bin/win32fe/win32fe.exe",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/bin/win32fe/win32feutils.dll",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/config/BuildSystem/docs/tutorials/GettingStartedwithSIDL.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/config/BuildSystem/docs/tutorials/DevelopingApplicationsWithSIDL.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/systems/Apple/iOS/PETSc/AddSource.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/dm/impls/mesh/examples/tests/meshes/Square-quad.gen",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/dm/impls/mesh/examples/tests/meshes/Square-tri2.gen",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/dm/impls/mesh/examples/tests/meshes/Square-tri.gen",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/dm/impls/mesh/examples/tests/meshes/Hex.gen",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/dm/impls/mesh/examples/tests/meshes/Tet.gen",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/ts/examples/tutorials/power_grid/PDF_eqs_power_grid.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/Ybus.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/src/ts/examples/tutorials/power_grid/stability_9bus/X.bin",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/sevenside.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/sevenside-quad-15.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/annulus-20.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/sevenside-quad.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/squaremotor-30.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.exo",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/docs/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-petsc-3.4.4-pvfingixuldplzbokssbp3cj7nnim5uo/spack-src/docs/developers.pdf"
    ],
    "total_files": 9636
}