{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/ts/tutorials/advection-diffusion-reaction/ex1.c": "\nstatic char help[] = \"Nonlinear Reaction Problem from Chemistry.\\n\";\n\n/*F\n\n     This directory contains examples based on the PDES/ODES given in the book\n      Numerical Solution of Time-Dependent Advection-Diffusion-Reaction Equations by\n      W. Hundsdorf and J.G. Verwer\n\n     Page 3, Section 1.1 Nonlinear Reaction Problems from Chemistry\n\n\\begin{eqnarray}\n                 {U_1}_t  - k U_1 U_2  & = & 0 \\\\\n                 {U_2}_t  - k U_1 U_2 & = & 0 \\\\\n                 {U_3}_t  - k U_1 U_2 & = & 0\n\\end{eqnarray}\n\n     Helpful runtime monitoring options:\n         -ts_view                  -  prints information about the solver being used\n         -ts_monitor               -  prints the progess of the solver\n         -ts_adapt_monitor         -  prints the progress of the time-step adaptor\n         -ts_monitor_lg_timestep   -  plots the size of each timestep (at each time-step)\n         -ts_monitor_lg_solution   -  plots each component of the solution as a function of time (at each timestep)\n         -ts_monitor_lg_error      -  plots each component of the error in the solution as a function of time (at each timestep)\n         -draw_pause -2            -  hold the plots a the end of the solution process, enter a mouse press in each window to end the process\n\n         -ts_monitor_lg_timestep -1  -  plots the size of each timestep (at the end of the solution process)\n         -ts_monitor_lg_solution -1  -  plots each component of the solution as a function of time (at the end of the solution process)\n         -ts_monitor_lg_error -1     -  plots each component of the error in the solution as a function of time (at the end of the solution process)\n         -lg_use_markers false       -  do NOT show the data points on the plots\n         -draw_save                  -  save the timestep and solution plot as a .Gif image file\n\nF*/\n\n/*\n      Project: Generate a nicely formated HTML page using\n         1) the HTML version of the source code and text in this file, use make html to generate the file ex1.c.html\n         2) the images (Draw_XXX_0_0.Gif Draw_YYY_0_0.Gif Draw_ZZZ_1_0.Gif) and\n         3) the text output (output.txt) generated by running the following commands.\n         4) <iframe src=\"generated_topics.html\" scrolling=\"no\" frameborder=\"0\"  width=600 height=300></iframe>\n\n      rm -rf *.Gif\n      ./ex1 -ts_monitor_lg_error -1 -ts_monitor_lg_solution -1   -draw_pause -2 -ts_max_steps 100 -ts_monitor_lg_timestep -1 -draw_save -draw_virtual -ts_monitor -ts_adapt_monitor -ts_view  > output.txt\n\n      For example something like\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n    <title>PETSc Example -- Nonlinear Reaction Problem from Chemistry</title>\n  </head>\n  <body>\n  <iframe src=\"ex1.c.html\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=400></iframe>\n  <img alt=\"\" src=\"Draw_0x84000000_0_0.Gif\"/><img alt=\"\" src=\"Draw_0x84000001_0_0.Gif\"/><img alt=\"\" src=\"Draw_0x84000001_1_0.Gif\"/>\n  <iframe src=\"output.txt\" scrolling=\"yes\" frameborder=\"1\"  width=2000 height=1000></iframe>\n  </body>\n</html>\n\n*/\n\n/*\n   Include \"petscts.h\" so that we can use TS solvers.  Note that this\n   file automatically includes:\n     petscsys.h       - base PETSc routines   petscvec.h - vectors\n     petscmat.h - matrices\n     petscis.h     - index sets            petscksp.h - Krylov subspace methods\n     petscviewer.h - viewers               petscpc.h  - preconditioners\n     petscksp.h   - linear solvers\n*/\n\n#include <petscts.h>\n\ntypedef struct {\n  PetscScalar k;\n  Vec         initialsolution;\n} AppCtx;\n\nPetscErrorCode IFunctionView(AppCtx *ctx,PetscViewer v)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscViewerBinaryWrite(v,&ctx->k,1,PETSC_SCALAR);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\nPetscErrorCode IFunctionLoad(AppCtx **ctx,PetscViewer v)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscNew(ctx);CHKERRQ(ierr);\n  ierr = PetscViewerBinaryRead(v,&(*ctx)->k,1,NULL,PETSC_SCALAR);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the ODE passed to the ODE solver\n*/\nPetscErrorCode IFunction(TS ts,PetscReal t,Vec U,Vec Udot,Vec F,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  PetscScalar       *f;\n  const PetscScalar *u,*udot;\n\n  PetscFunctionBegin;\n  /*  The next three lines allow us to access the entries of the vectors directly */\n  ierr = VecGetArrayRead(U,&u);CHKERRQ(ierr);\n  ierr = VecGetArrayRead(Udot,&udot);CHKERRQ(ierr);\n  ierr = VecGetArrayWrite(F,&f);CHKERRQ(ierr);\n  f[0] = udot[0] + ctx->k*u[0]*u[1];\n  f[1] = udot[1] + ctx->k*u[0]*u[1];\n  f[2] = udot[2] - ctx->k*u[0]*u[1];\n  ierr = VecRestoreArrayRead(U,&u);CHKERRQ(ierr);\n  ierr = VecRestoreArrayRead(Udot,&udot);CHKERRQ(ierr);\n  ierr = VecRestoreArrayWrite(F,&f);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the Jacobian of the ODE passed to the ODE solver. See TSSetIJacobian() for the meaning of a and the Jacobian.\n*/\nPetscErrorCode IJacobian(TS ts,PetscReal t,Vec U,Vec Udot,PetscReal a,Mat A,Mat B,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  PetscInt          rowcol[] = {0,1,2};\n  PetscScalar       J[3][3];\n  const PetscScalar *u,*udot;\n\n  PetscFunctionBegin;\n  ierr    = VecGetArrayRead(U,&u);CHKERRQ(ierr);\n  ierr    = VecGetArrayRead(Udot,&udot);CHKERRQ(ierr);\n  J[0][0] = a + ctx->k*u[1];   J[0][1] = ctx->k*u[0];       J[0][2] = 0.0;\n  J[1][0] = ctx->k*u[1];       J[1][1] = a + ctx->k*u[0];   J[1][2] = 0.0;\n  J[2][0] = -ctx->k*u[1];      J[2][1] = -ctx->k*u[0];      J[2][2] = a;\n  ierr    = MatSetValues(B,3,rowcol,3,rowcol,&J[0][0],INSERT_VALUES);CHKERRQ(ierr);\n  ierr    = VecRestoreArrayRead(U,&u);CHKERRQ(ierr);\n  ierr    = VecRestoreArrayRead(Udot,&udot);CHKERRQ(ierr);\n\n  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  if (A != B) {\n    ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n    ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);\n  }\n  PetscFunctionReturn(0);\n}\n\n/*\n     Defines the exact (analytic) solution to the ODE\n*/\nstatic PetscErrorCode Solution(TS ts,PetscReal t,Vec U,AppCtx *ctx)\n{\n  PetscErrorCode    ierr;\n  const PetscScalar *uinit;\n  PetscScalar       *u,d0,q;\n\n  PetscFunctionBegin;\n  ierr = VecGetArrayRead(ctx->initialsolution,&uinit);CHKERRQ(ierr);\n  ierr = VecGetArrayWrite(U,&u);CHKERRQ(ierr);\n  d0   = uinit[0] - uinit[1];\n  if (d0 == 0.0) q = ctx->k*t;\n  else q = (1.0 - PetscExpScalar(-ctx->k*t*d0))/d0;\n  u[0] = uinit[0]/(1.0 + uinit[1]*q);\n  u[1] = u[0] - d0;\n  u[2] = uinit[1] + uinit[2] - u[1];\n  ierr = VecRestoreArrayWrite(U,&u);CHKERRQ(ierr);\n  ierr = VecRestoreArrayRead(ctx->initialsolution,&uinit);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\nint main(int argc,char **argv)\n{\n  TS             ts;            /* ODE integrator */\n  Vec            U;             /* solution will be stored here */\n  Mat            A;             /* Jacobian matrix */\n  PetscErrorCode ierr;\n  PetscMPIInt    size;\n  PetscInt       n = 3;\n  AppCtx         ctx;\n  PetscScalar    *u;\n  const char     * const names[] = {\"U1\",\"U2\",\"U3\",NULL};\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Initialize program\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = PetscInitialize(&argc,&argv,(char*)0,help);if (ierr) return ierr;\n  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRMPI(ierr);\n  if (size > 1) SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_SUP,\"Only for sequential runs\");\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Create necessary matrix and vectors\n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);\n  ierr = MatSetSizes(A,n,n,PETSC_DETERMINE,PETSC_DETERMINE);CHKERRQ(ierr);\n  ierr = MatSetFromOptions(A);CHKERRQ(ierr);\n  ierr = MatSetUp(A);CHKERRQ(ierr);\n\n  ierr = MatCreateVecs(A,&U,NULL);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Set runtime options\n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ctx.k = .9;\n  ierr  = PetscOptionsGetScalar(NULL,NULL,\"-k\",&ctx.k,NULL);CHKERRQ(ierr);\n  ierr  = VecDuplicate(U,&ctx.initialsolution);CHKERRQ(ierr);\n  ierr  = VecGetArrayWrite(ctx.initialsolution,&u);CHKERRQ(ierr);\n  u[0]  = 1;\n  u[1]  = .7;\n  u[2]  = 0;\n  ierr  = VecRestoreArrayWrite(ctx.initialsolution,&u);CHKERRQ(ierr);\n  ierr  = PetscOptionsGetVec(NULL,NULL,\"-initial\",ctx.initialsolution,NULL);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Create timestepping solver context\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSCreate(PETSC_COMM_WORLD,&ts);CHKERRQ(ierr);\n  ierr = TSSetProblemType(ts,TS_NONLINEAR);CHKERRQ(ierr);\n  ierr = TSSetType(ts,TSROSW);CHKERRQ(ierr);\n  ierr = TSSetIFunction(ts,NULL,(TSIFunction) IFunction,&ctx);CHKERRQ(ierr);\n  ierr = TSSetIJacobian(ts,A,A,(TSIJacobian)IJacobian,&ctx);CHKERRQ(ierr);\n  ierr = TSSetSolutionFunction(ts,(TSSolutionFunction)Solution,&ctx);CHKERRQ(ierr);\n\n  {\n    DM   dm;\n    void *ptr;\n    ierr = TSGetDM(ts,&dm);CHKERRQ(ierr);\n    ierr = PetscDLSym(NULL,\"IFunctionView\",&ptr);CHKERRQ(ierr);\n    ierr = PetscDLSym(NULL,\"IFunctionLoad\",&ptr);CHKERRQ(ierr);\n    ierr = DMTSSetIFunctionSerialize(dm,(PetscErrorCode (*)(void*,PetscViewer))IFunctionView,(PetscErrorCode (*)(void**,PetscViewer))IFunctionLoad);CHKERRQ(ierr);\n    ierr = DMTSSetIJacobianSerialize(dm,(PetscErrorCode (*)(void*,PetscViewer))IFunctionView,(PetscErrorCode (*)(void**,PetscViewer))IFunctionLoad);CHKERRQ(ierr);\n  }\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Set initial conditions\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = Solution(ts,0,U,&ctx);CHKERRQ(ierr);\n  ierr = TSSetSolution(ts,U);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Set solver options\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSSetTimeStep(ts,.001);CHKERRQ(ierr);\n  ierr = TSSetMaxSteps(ts,1000);CHKERRQ(ierr);\n  ierr = TSSetMaxTime(ts,20.0);CHKERRQ(ierr);\n  ierr = TSSetExactFinalTime(ts,TS_EXACTFINALTIME_STEPOVER);CHKERRQ(ierr);\n  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);\n  ierr = TSMonitorLGSetVariableNames(ts,names);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Solve nonlinear system\n     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = TSSolve(ts,U);CHKERRQ(ierr);\n\n  ierr = TSView(ts,PETSC_VIEWER_BINARY_WORLD);CHKERRQ(ierr);\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n     Free work space.  All PETSc objects should be destroyed when they are no longer needed.\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n  ierr = VecDestroy(&ctx.initialsolution);CHKERRQ(ierr);\n  ierr = MatDestroy(&A);CHKERRQ(ierr);\n  ierr = VecDestroy(&U);CHKERRQ(ierr);\n  ierr = TSDestroy(&ts);CHKERRQ(ierr);\n\n  ierr = PetscFinalize();\n  return ierr;\n}\n\n\n/*TEST\n\n   test:\n     args: -ts_view\n     requires: dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)\n\n   test:\n     suffix: 2\n     args: -ts_monitor_lg_error -ts_monitor_lg_solution  -ts_view\n     requires: x dlsym define(PETSC_HAVE_DYNAMIC_LIBRARIES)\n     output_file: output/ex1_1.out\n\nTEST*/\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/sys/objects/pinit.c": "#define PETSC_DESIRE_FEATURE_TEST_MACROS\n/*\n   This file defines the initialization of PETSc, including PetscInitialize()\n*/\n#include <petsc/private/petscimpl.h>        /*I  \"petscsys.h\"   I*/\n#include <petscvalgrind.h>\n#include <petscviewer.h>\n#if defined(PETSC_USE_GCOV)\nEXTERN_C_BEGIN\nvoid  __gcov_flush(void);\nEXTERN_C_END\n#endif\n\n#if defined(PETSC_USE_LOG)\nPETSC_INTERN PetscErrorCode PetscLogFinalize(void);\n#endif\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\nPETSC_INTERN PetscFPT PetscFPTData;\nPetscFPT PetscFPTData = 0;\n#endif\n\n#if defined(PETSC_HAVE_SAWS)\n#include <petscviewersaws.h>\n#endif\n\n/* -----------------------------------------------------------------------------------------*/\n\nPETSC_INTERN FILE *petsc_history;\n\nPETSC_INTERN PetscErrorCode PetscInitialize_DynamicLibraries(void);\nPETSC_INTERN PetscErrorCode PetscFinalize_DynamicLibraries(void);\nPETSC_INTERN PetscErrorCode PetscFunctionListPrintAll(void);\nPETSC_INTERN PetscErrorCode PetscSequentialPhaseBegin_Private(MPI_Comm,int);\nPETSC_INTERN PetscErrorCode PetscSequentialPhaseEnd_Private(MPI_Comm,int);\nPETSC_INTERN PetscErrorCode PetscCloseHistoryFile(FILE**);\n\n/* user may set these BEFORE calling PetscInitialize() */\nMPI_Comm PETSC_COMM_WORLD = MPI_COMM_NULL;\n#if defined(PETSC_HAVE_MPI_INIT_THREAD)\nPetscMPIInt PETSC_MPI_THREAD_REQUIRED = MPI_THREAD_FUNNELED;\n#else\nPetscMPIInt PETSC_MPI_THREAD_REQUIRED = 0;\n#endif\n\nPetscMPIInt Petsc_Counter_keyval   = MPI_KEYVAL_INVALID;\nPetscMPIInt Petsc_InnerComm_keyval = MPI_KEYVAL_INVALID;\nPetscMPIInt Petsc_OuterComm_keyval = MPI_KEYVAL_INVALID;\nPetscMPIInt Petsc_ShmComm_keyval   = MPI_KEYVAL_INVALID;\n\n/*\n     Declare and set all the string names of the PETSc enums\n*/\nconst char *const PetscBools[]     = {\"FALSE\",\"TRUE\",\"PetscBool\",\"PETSC_\",NULL};\nconst char *const PetscCopyModes[] = {\"COPY_VALUES\",\"OWN_POINTER\",\"USE_POINTER\",\"PetscCopyMode\",\"PETSC_\",NULL};\n\nPetscBool PetscPreLoadingUsed = PETSC_FALSE;\nPetscBool PetscPreLoadingOn   = PETSC_FALSE;\n\nPetscInt PetscHotRegionDepth;\n\n#if defined(PETSC_HAVE_THREADSAFETY)\nPetscSpinlock PetscViewerASCIISpinLockOpen;\nPetscSpinlock PetscViewerASCIISpinLockStdout;\nPetscSpinlock PetscViewerASCIISpinLockStderr;\nPetscSpinlock PetscCommSpinLock;\n#endif\n\n/*\n      PetscInitializeNoPointers - Calls PetscInitialize() from C/C++ without the pointers to argc and args\n\n   Collective\n\n   Level: advanced\n\n    Notes:\n    this is called only by the PETSc Julia interface. Even though it might start MPI it sets the flag to\n     indicate that it did NOT start MPI so that the PetscFinalize() does not end MPI, thus allowing PetscInitialize() to\n     be called multiple times from Julia without the problem of trying to initialize MPI more than once.\n\n     Developer Note: Turns off PETSc signal handling to allow Julia to manage signals\n\n.seealso: PetscInitialize(), PetscInitializeFortran(), PetscInitializeNoArguments()\n*/\nPetscErrorCode  PetscInitializeNoPointers(int argc,char **args,const char *filename,const char *help)\n{\n  PetscErrorCode ierr;\n  int            myargc   = argc;\n  char           **myargs = args;\n\n  PetscFunctionBegin;\n  ierr = PetscInitialize(&myargc,&myargs,filename,help);if (ierr) return ierr;\n  ierr = PetscPopSignalHandler();CHKERRQ(ierr);\n  PetscBeganMPI = PETSC_FALSE;\n  PetscFunctionReturn(ierr);\n}\n\n/*\n      Used by Julia interface to get communicator\n*/\nPetscErrorCode  PetscGetPETSC_COMM_SELF(MPI_Comm *comm)\n{\n  PetscFunctionBegin;\n  *comm = PETSC_COMM_SELF;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n      PetscInitializeNoArguments - Calls PetscInitialize() from C/C++ without\n        the command line arguments.\n\n   Collective\n\n   Level: advanced\n\n.seealso: PetscInitialize(), PetscInitializeFortran()\n@*/\nPetscErrorCode  PetscInitializeNoArguments(void)\n{\n  PetscErrorCode ierr;\n  int            argc   = 0;\n  char           **args = NULL;\n\n  PetscFunctionBegin;\n  ierr = PetscInitialize(&argc,&args,NULL,NULL);\n  PetscFunctionReturn(ierr);\n}\n\n/*@\n      PetscInitialized - Determine whether PETSc is initialized.\n\n   Level: beginner\n\n.seealso: PetscInitialize(), PetscInitializeNoArguments(), PetscInitializeFortran()\n@*/\nPetscErrorCode PetscInitialized(PetscBool *isInitialized)\n{\n  *isInitialized = PetscInitializeCalled;\n  return 0;\n}\n\n/*@\n      PetscFinalized - Determine whether PetscFinalize() has been called yet\n\n   Level: developer\n\n.seealso: PetscInitialize(), PetscInitializeNoArguments(), PetscInitializeFortran()\n@*/\nPetscErrorCode  PetscFinalized(PetscBool  *isFinalized)\n{\n  *isFinalized = PetscFinalizeCalled;\n  return 0;\n}\n\nPETSC_INTERN PetscErrorCode PetscOptionsCheckInitial_Private(const char []);\n\n/*\n       This function is the MPI reduction operation used to compute the sum of the\n   first half of the datatype and the max of the second half.\n*/\nMPI_Op MPIU_MAXSUM_OP = 0;\n\nPETSC_INTERN void MPIAPI MPIU_MaxSum_Local(void *in,void *out,int *cnt,MPI_Datatype *datatype)\n{\n  PetscInt *xin = (PetscInt*)in,*xout = (PetscInt*)out,i,count = *cnt;\n\n  PetscFunctionBegin;\n  if (*datatype != MPIU_2INT) {\n    (*PetscErrorPrintf)(\"Can only handle MPIU_2INT data types\");\n    PETSCABORT(MPI_COMM_SELF,PETSC_ERR_ARG_WRONG);\n  }\n\n  for (i=0; i<count; i++) {\n    xout[2*i]    = PetscMax(xout[2*i],xin[2*i]);\n    xout[2*i+1] += xin[2*i+1];\n  }\n  PetscFunctionReturnVoid();\n}\n\n/*\n    Returns the max of the first entry owned by this processor and the\nsum of the second entry.\n\n    The reason sizes[2*i] contains lengths sizes[2*i+1] contains flag of 1 if length is nonzero\nis so that the MPIU_MAXSUM_OP() can set TWO values, if we passed in only sizes[i] with lengths\nthere would be no place to store the both needed results.\n*/\nPetscErrorCode  PetscMaxSum(MPI_Comm comm,const PetscInt sizes[],PetscInt *max,PetscInt *sum)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n#if defined(PETSC_HAVE_MPI_REDUCE_SCATTER_BLOCK)\n  {\n    struct {PetscInt max,sum;} work;\n    ierr = MPI_Reduce_scatter_block((void*)sizes,&work,1,MPIU_2INT,MPIU_MAXSUM_OP,comm);CHKERRMPI(ierr);\n    *max = work.max;\n    *sum = work.sum;\n  }\n#else\n  {\n    PetscMPIInt    size,rank;\n    struct {PetscInt max,sum;} *work;\n    ierr = MPI_Comm_size(comm,&size);CHKERRMPI(ierr);\n    ierr = MPI_Comm_rank(comm,&rank);CHKERRMPI(ierr);\n    ierr = PetscMalloc1(size,&work);CHKERRQ(ierr);\n    ierr = MPIU_Allreduce((void*)sizes,work,size,MPIU_2INT,MPIU_MAXSUM_OP,comm);CHKERRQ(ierr);\n    *max = work[rank].max;\n    *sum = work[rank].sum;\n    ierr = PetscFree(work);CHKERRQ(ierr);\n  }\n#endif\n  PetscFunctionReturn(0);\n}\n\n/* ----------------------------------------------------------------------------*/\n\n#if (defined(PETSC_HAVE_COMPLEX) && !defined(PETSC_HAVE_MPI_C_DOUBLE_COMPLEX)) || defined(PETSC_USE_REAL___FLOAT128) || defined(PETSC_USE_REAL___FP16)\nMPI_Op MPIU_SUM = 0;\n\nPETSC_EXTERN void PetscSum_Local(void *in,void *out,PetscMPIInt *cnt,MPI_Datatype *datatype)\n{\n  PetscInt i,count = *cnt;\n\n  PetscFunctionBegin;\n  if (*datatype == MPIU_REAL) {\n    PetscReal *xin = (PetscReal*)in,*xout = (PetscReal*)out;\n    for (i=0; i<count; i++) xout[i] += xin[i];\n  }\n#if defined(PETSC_HAVE_COMPLEX)\n  else if (*datatype == MPIU_COMPLEX) {\n    PetscComplex *xin = (PetscComplex*)in,*xout = (PetscComplex*)out;\n    for (i=0; i<count; i++) xout[i] += xin[i];\n  }\n#endif\n  else {\n    (*PetscErrorPrintf)(\"Can only handle MPIU_REAL or MPIU_COMPLEX data types\");\n    PETSCABORT(MPI_COMM_SELF,PETSC_ERR_ARG_WRONG);\n  }\n  PetscFunctionReturnVoid();\n}\n#endif\n\n#if defined(PETSC_USE_REAL___FLOAT128) || defined(PETSC_USE_REAL___FP16)\nMPI_Op MPIU_MAX = 0;\nMPI_Op MPIU_MIN = 0;\n\nPETSC_EXTERN void PetscMax_Local(void *in,void *out,PetscMPIInt *cnt,MPI_Datatype *datatype)\n{\n  PetscInt i,count = *cnt;\n\n  PetscFunctionBegin;\n  if (*datatype == MPIU_REAL) {\n    PetscReal *xin = (PetscReal*)in,*xout = (PetscReal*)out;\n    for (i=0; i<count; i++) xout[i] = PetscMax(xout[i],xin[i]);\n  }\n#if defined(PETSC_HAVE_COMPLEX)\n  else if (*datatype == MPIU_COMPLEX) {\n    PetscComplex *xin = (PetscComplex*)in,*xout = (PetscComplex*)out;\n    for (i=0; i<count; i++) {\n      xout[i] = PetscRealPartComplex(xout[i])<PetscRealPartComplex(xin[i]) ? xin[i] : xout[i];\n    }\n  }\n#endif\n  else {\n    (*PetscErrorPrintf)(\"Can only handle MPIU_REAL or MPIU_COMPLEX data types\");\n    PETSCABORT(MPI_COMM_SELF,PETSC_ERR_ARG_WRONG);\n  }\n  PetscFunctionReturnVoid();\n}\n\nPETSC_EXTERN void PetscMin_Local(void *in,void *out,PetscMPIInt *cnt,MPI_Datatype *datatype)\n{\n  PetscInt    i,count = *cnt;\n\n  PetscFunctionBegin;\n  if (*datatype == MPIU_REAL) {\n    PetscReal *xin = (PetscReal*)in,*xout = (PetscReal*)out;\n    for (i=0; i<count; i++) xout[i] = PetscMin(xout[i],xin[i]);\n  }\n#if defined(PETSC_HAVE_COMPLEX)\n  else if (*datatype == MPIU_COMPLEX) {\n    PetscComplex *xin = (PetscComplex*)in,*xout = (PetscComplex*)out;\n    for (i=0; i<count; i++) {\n      xout[i] = PetscRealPartComplex(xout[i])>PetscRealPartComplex(xin[i]) ? xin[i] : xout[i];\n    }\n  }\n#endif\n  else {\n    (*PetscErrorPrintf)(\"Can only handle MPIU_REAL or MPIU_SCALAR data (i.e. double or complex) types\");\n    PETSCABORT(MPI_COMM_SELF,PETSC_ERR_ARG_WRONG);\n  }\n  PetscFunctionReturnVoid();\n}\n#endif\n\n/*\n   Private routine to delete internal tag/name counter storage when a communicator is freed.\n\n   This is called by MPI, not by users. This is called by MPI_Comm_free() when the communicator that has this  data as an attribute is freed.\n\n   Note: this is declared extern \"C\" because it is passed to MPI_Comm_create_keyval()\n\n*/\nPETSC_EXTERN PetscMPIInt MPIAPI Petsc_Counter_Attr_Delete_Fn(MPI_Comm comm,PetscMPIInt keyval,void *count_val,void *extra_state)\n{\n  PetscErrorCode   ierr;\n  PetscCommCounter *counter=(PetscCommCounter*)count_val;\n\n  PetscFunctionBegin;\n  ierr = PetscInfo1(NULL,\"Deleting counter data in an MPI_Comm %ld\\n\",(long)comm);CHKERRMPI(ierr);\n  ierr = PetscFree(counter->iflags);CHKERRMPI(ierr);\n  ierr = PetscFree(counter);CHKERRMPI(ierr);\n  PetscFunctionReturn(MPI_SUCCESS);\n}\n\n/*\n  This is invoked on the outer comm as a result of either PetscCommDestroy() (via MPI_Comm_delete_attr) or when the user\n  calls MPI_Comm_free().\n\n  This is the only entry point for breaking the links between inner and outer comms.\n\n  This is called by MPI, not by users. This is called when MPI_Comm_free() is called on the communicator.\n\n  Note: this is declared extern \"C\" because it is passed to MPI_Comm_create_keyval()\n\n*/\nPETSC_EXTERN PetscMPIInt MPIAPI Petsc_InnerComm_Attr_Delete_Fn(MPI_Comm comm,PetscMPIInt keyval,void *attr_val,void *extra_state)\n{\n  PetscErrorCode                    ierr;\n  union {MPI_Comm comm; void *ptr;} icomm;\n\n  PetscFunctionBegin;\n  if (keyval != Petsc_InnerComm_keyval) SETERRMPI(PETSC_COMM_SELF,PETSC_ERR_ARG_CORRUPT,\"Unexpected keyval\");\n  icomm.ptr = attr_val;\n  if (PetscDefined(USE_DEBUG)) {\n    /* Error out if the inner/outer comms are not correctly linked through their Outer/InnterComm attributes */\n    PetscMPIInt flg;\n    union {MPI_Comm comm; void *ptr;} ocomm;\n    ierr = MPI_Comm_get_attr(icomm.comm,Petsc_OuterComm_keyval,&ocomm,&flg);CHKERRMPI(ierr);\n    if (!flg) SETERRMPI(PETSC_COMM_SELF,PETSC_ERR_ARG_CORRUPT,\"Inner comm does not have OuterComm attribute\");\n    if (ocomm.comm != comm) SETERRMPI(PETSC_COMM_SELF,PETSC_ERR_ARG_CORRUPT,\"Inner comm's OuterComm attribute does not point to outer PETSc comm\");\n  }\n  ierr = MPI_Comm_delete_attr(icomm.comm,Petsc_OuterComm_keyval);CHKERRMPI(ierr);\n  ierr = PetscInfo2(NULL,\"User MPI_Comm %ld is being unlinked from inner PETSc comm %ld\\n\",(long)comm,(long)icomm.comm);CHKERRMPI(ierr);\n  PetscFunctionReturn(MPI_SUCCESS);\n}\n\n/*\n * This is invoked on the inner comm when Petsc_InnerComm_Attr_Delete_Fn calls MPI_Comm_delete_attr().  It should not be reached any other way.\n */\nPETSC_EXTERN PetscMPIInt MPIAPI Petsc_OuterComm_Attr_Delete_Fn(MPI_Comm comm,PetscMPIInt keyval,void *attr_val,void *extra_state)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscInfo1(NULL,\"Removing reference to PETSc communicator embedded in a user MPI_Comm %ld\\n\",(long)comm);CHKERRMPI(ierr);\n  PetscFunctionReturn(MPI_SUCCESS);\n}\n\nPETSC_EXTERN PetscMPIInt MPIAPI Petsc_ShmComm_Attr_Delete_Fn(MPI_Comm,PetscMPIInt,void *,void *);\n\n#if defined(PETSC_USE_PETSC_MPI_EXTERNAL32)\nPETSC_EXTERN PetscMPIInt PetscDataRep_extent_fn(MPI_Datatype,MPI_Aint*,void*);\nPETSC_EXTERN PetscMPIInt PetscDataRep_read_conv_fn(void*, MPI_Datatype,PetscMPIInt,void*,MPI_Offset,void*);\nPETSC_EXTERN PetscMPIInt PetscDataRep_write_conv_fn(void*, MPI_Datatype,PetscMPIInt,void*,MPI_Offset,void*);\n#endif\n\nPetscMPIInt PETSC_MPI_ERROR_CLASS=MPI_ERR_LASTCODE,PETSC_MPI_ERROR_CODE;\n\nPETSC_INTERN int  PetscGlobalArgc;\nPETSC_INTERN char **PetscGlobalArgs;\nint  PetscGlobalArgc   = 0;\nchar **PetscGlobalArgs = NULL;\nPetscSegBuffer PetscCitationsList;\n\nPetscErrorCode PetscCitationsInitialize(void)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr = PetscSegBufferCreate(1,10000,&PetscCitationsList);CHKERRQ(ierr);\n  ierr = PetscCitationsRegister(\"@TechReport{petsc-user-ref,\\n  Author = {Satish Balay and Shrirang Abhyankar and Mark F. Adams and Jed Brown \\n            and Peter Brune and Kris Buschelman and Lisandro Dalcin and\\n            Victor Eijkhout and William D. Gropp and Dmitry Karpeyev and\\n            Dinesh Kaushik and Matthew G. Knepley and Dave A. May and Lois Curfman McInnes\\n            and Richard Tran Mills and Todd Munson and Karl Rupp and Patrick Sanan\\n            and Barry F. Smith and Stefano Zampini and Hong Zhang and Hong Zhang},\\n  Title = {{PETS}c Users Manual},\\n  Number = {ANL-95/11 - Revision 3.11},\\n  Institution = {Argonne National Laboratory},\\n  Year = {2019}\\n}\\n\",NULL);CHKERRQ(ierr);\n  ierr = PetscCitationsRegister(\"@InProceedings{petsc-efficient,\\n  Author = {Satish Balay and William D. Gropp and Lois Curfman McInnes and Barry F. Smith},\\n  Title = {Efficient Management of Parallelism in Object Oriented Numerical Software Libraries},\\n  Booktitle = {Modern Software Tools in Scientific Computing},\\n  Editor = {E. Arge and A. M. Bruaset and H. P. Langtangen},\\n  Pages = {163--202},\\n  Publisher = {Birkh{\\\\\\\"{a}}user Press},\\n  Year = {1997}\\n}\\n\",NULL);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\nstatic char programname[PETSC_MAX_PATH_LEN] = \"\"; /* HP includes entire path in name */\n\nPetscErrorCode  PetscSetProgramName(const char name[])\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  ierr  = PetscStrncpy(programname,name,sizeof(programname));CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*@C\n    PetscGetProgramName - Gets the name of the running program.\n\n    Not Collective\n\n    Input Parameter:\n.   len - length of the string name\n\n    Output Parameter:\n.   name - the name of the running program\n\n   Level: advanced\n\n    Notes:\n    The name of the program is copied into the user-provided character\n    array of length len.  On some machines the program name includes\n    its entire path, so one should generally set len >= PETSC_MAX_PATH_LEN.\n@*/\nPetscErrorCode  PetscGetProgramName(char name[],size_t len)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n   ierr = PetscStrncpy(name,programname,len);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscGetArgs - Allows you to access the raw command line arguments anywhere\n     after PetscInitialize() is called but before PetscFinalize().\n\n   Not Collective\n\n   Output Parameters:\n+  argc - count of number of command line arguments\n-  args - the command line arguments\n\n   Level: intermediate\n\n   Notes:\n      This is usually used to pass the command line arguments into other libraries\n   that are called internally deep in PETSc or the application.\n\n      The first argument contains the program name as is normal for C arguments.\n\n.seealso: PetscFinalize(), PetscInitializeFortran(), PetscGetArguments()\n\n@*/\nPetscErrorCode  PetscGetArgs(int *argc,char ***args)\n{\n  PetscFunctionBegin;\n  if (!PetscInitializeCalled && PetscFinalizeCalled) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ORDER,\"You must call after PetscInitialize() but before PetscFinalize()\");\n  *argc = PetscGlobalArgc;\n  *args = PetscGlobalArgs;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscGetArguments - Allows you to access the  command line arguments anywhere\n     after PetscInitialize() is called but before PetscFinalize().\n\n   Not Collective\n\n   Output Parameters:\n.  args - the command line arguments\n\n   Level: intermediate\n\n   Notes:\n      This does NOT start with the program name and IS null terminated (final arg is void)\n\n.seealso: PetscFinalize(), PetscInitializeFortran(), PetscGetArgs(), PetscFreeArguments()\n\n@*/\nPetscErrorCode  PetscGetArguments(char ***args)\n{\n  PetscInt       i,argc = PetscGlobalArgc;\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  if (!PetscInitializeCalled && PetscFinalizeCalled) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ORDER,\"You must call after PetscInitialize() but before PetscFinalize()\");\n  if (!argc) {*args = NULL; PetscFunctionReturn(0);}\n  ierr = PetscMalloc1(argc,args);CHKERRQ(ierr);\n  for (i=0; i<argc-1; i++) {\n    ierr = PetscStrallocpy(PetscGlobalArgs[i+1],&(*args)[i]);CHKERRQ(ierr);\n  }\n  (*args)[argc-1] = NULL;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscFreeArguments - Frees the memory obtained with PetscGetArguments()\n\n   Not Collective\n\n   Output Parameters:\n.  args - the command line arguments\n\n   Level: intermediate\n\n.seealso: PetscFinalize(), PetscInitializeFortran(), PetscGetArgs(), PetscGetArguments()\n\n@*/\nPetscErrorCode  PetscFreeArguments(char **args)\n{\n  PetscInt       i = 0;\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n  if (!args) PetscFunctionReturn(0);\n  while (args[i]) {\n    ierr = PetscFree(args[i]);CHKERRQ(ierr);\n    i++;\n  }\n  ierr = PetscFree(args);CHKERRQ(ierr);\n  PetscFunctionReturn(0);\n}\n\n#if defined(PETSC_HAVE_SAWS)\n#include <petscconfiginfo.h>\n\nPETSC_INTERN PetscErrorCode PetscInitializeSAWs(const char help[])\n{\n  if (!PetscGlobalRank) {\n    char           cert[PETSC_MAX_PATH_LEN],root[PETSC_MAX_PATH_LEN],*intro,programname[64],*appline,*options,version[64];\n    int            port;\n    PetscBool      flg,rootlocal = PETSC_FALSE,flg2,selectport = PETSC_FALSE;\n    size_t         applinelen,introlen;\n    PetscErrorCode ierr;\n    char           sawsurl[256];\n\n    ierr = PetscOptionsHasName(NULL,NULL,\"-saws_log\",&flg);CHKERRQ(ierr);\n    if (flg) {\n      char  sawslog[PETSC_MAX_PATH_LEN];\n\n      ierr = PetscOptionsGetString(NULL,NULL,\"-saws_log\",sawslog,sizeof(sawslog),NULL);CHKERRQ(ierr);\n      if (sawslog[0]) {\n        PetscStackCallSAWs(SAWs_Set_Use_Logfile,(sawslog));\n      } else {\n        PetscStackCallSAWs(SAWs_Set_Use_Logfile,(NULL));\n      }\n    }\n    ierr = PetscOptionsGetString(NULL,NULL,\"-saws_https\",cert,sizeof(cert),&flg);CHKERRQ(ierr);\n    if (flg) {\n      PetscStackCallSAWs(SAWs_Set_Use_HTTPS,(cert));\n    }\n    ierr = PetscOptionsGetBool(NULL,NULL,\"-saws_port_auto_select\",&selectport,NULL);CHKERRQ(ierr);\n    if (selectport) {\n        PetscStackCallSAWs(SAWs_Get_Available_Port,(&port));\n        PetscStackCallSAWs(SAWs_Set_Port,(port));\n    } else {\n      ierr = PetscOptionsGetInt(NULL,NULL,\"-saws_port\",&port,&flg);CHKERRQ(ierr);\n      if (flg) {\n        PetscStackCallSAWs(SAWs_Set_Port,(port));\n      }\n    }\n    ierr = PetscOptionsGetString(NULL,NULL,\"-saws_root\",root,sizeof(root),&flg);CHKERRQ(ierr);\n    if (flg) {\n      PetscStackCallSAWs(SAWs_Set_Document_Root,(root));CHKERRQ(ierr);\n      ierr = PetscStrcmp(root,\".\",&rootlocal);CHKERRQ(ierr);\n    } else {\n      ierr = PetscOptionsHasName(NULL,NULL,\"-saws_options\",&flg);CHKERRQ(ierr);\n      if (flg) {\n        ierr = PetscStrreplace(PETSC_COMM_WORLD,\"${PETSC_DIR}/share/petsc/saws\",root,sizeof(root));CHKERRQ(ierr);\n        PetscStackCallSAWs(SAWs_Set_Document_Root,(root));CHKERRQ(ierr);\n      }\n    }\n    ierr = PetscOptionsHasName(NULL,NULL,\"-saws_local\",&flg2);CHKERRQ(ierr);\n    if (flg2) {\n      char jsdir[PETSC_MAX_PATH_LEN];\n      if (!flg) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP,\"-saws_local option requires -saws_root option\");\n      ierr = PetscSNPrintf(jsdir,sizeof(jsdir),\"%s/js\",root);CHKERRQ(ierr);\n      ierr = PetscTestDirectory(jsdir,'r',&flg);CHKERRQ(ierr);\n      if (!flg) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_FILE_READ,\"-saws_local option requires js directory in root directory\");\n      PetscStackCallSAWs(SAWs_Push_Local_Header,());CHKERRQ(ierr);\n    }\n    ierr = PetscGetProgramName(programname,sizeof(programname));CHKERRQ(ierr);\n    ierr = PetscStrlen(help,&applinelen);CHKERRQ(ierr);\n    introlen   = 4096 + applinelen;\n    applinelen += 1024;\n    ierr = PetscMalloc(applinelen,&appline);CHKERRQ(ierr);\n    ierr = PetscMalloc(introlen,&intro);CHKERRQ(ierr);\n\n    if (rootlocal) {\n      ierr = PetscSNPrintf(appline,applinelen,\"%s.c.html\",programname);CHKERRQ(ierr);\n      ierr = PetscTestFile(appline,'r',&rootlocal);CHKERRQ(ierr);\n    }\n    ierr = PetscOptionsGetAll(NULL,&options);CHKERRQ(ierr);\n    if (rootlocal && help) {\n      ierr = PetscSNPrintf(appline,applinelen,\"<center> Running <a href=\\\"%s.c.html\\\">%s</a> %s</center><br><center><pre>%s</pre></center><br>\\n\",programname,programname,options,help);CHKERRQ(ierr);\n    } else if (help) {\n      ierr = PetscSNPrintf(appline,applinelen,\"<center>Running %s %s</center><br><center><pre>%s</pre></center><br>\",programname,options,help);CHKERRQ(ierr);\n    } else {\n      ierr = PetscSNPrintf(appline,applinelen,\"<center> Running %s %s</center><br>\\n\",programname,options);CHKERRQ(ierr);\n    }\n    ierr = PetscFree(options);CHKERRQ(ierr);\n    ierr = PetscGetVersion(version,sizeof(version));CHKERRQ(ierr);\n    ierr = PetscSNPrintf(intro,introlen,\"<body>\\n\"\n                                    \"<center><h2> <a href=\\\"https://www.mcs.anl.gov/petsc\\\">PETSc</a> Application Web server powered by <a href=\\\"https://bitbucket.org/saws/saws\\\">SAWs</a> </h2></center>\\n\"\n                                    \"<center>This is the default PETSc application dashboard, from it you can access any published PETSc objects or logging data</center><br><center>%s configured with %s</center><br>\\n\"\n                                    \"%s\",version,petscconfigureoptions,appline);CHKERRQ(ierr);\n    PetscStackCallSAWs(SAWs_Push_Body,(\"index.html\",0,intro));\n    ierr = PetscFree(intro);CHKERRQ(ierr);\n    ierr = PetscFree(appline);CHKERRQ(ierr);\n    if (selectport) {\n      PetscBool silent;\n\n      ierr = SAWs_Initialize();\n      /* another process may have grabbed the port so keep trying */\n      while (ierr) {\n        PetscStackCallSAWs(SAWs_Get_Available_Port,(&port));\n        PetscStackCallSAWs(SAWs_Set_Port,(port));\n        ierr = SAWs_Initialize();\n      }\n\n      ierr = PetscOptionsGetBool(NULL,NULL,\"-saws_port_auto_select_silent\",&silent,NULL);CHKERRQ(ierr);\n      if (!silent) {\n        PetscStackCallSAWs(SAWs_Get_FullURL,(sizeof(sawsurl),sawsurl));\n        ierr = PetscPrintf(PETSC_COMM_WORLD,\"Point your browser to %s for SAWs\\n\",sawsurl);CHKERRQ(ierr);\n      }\n    } else {\n      PetscStackCallSAWs(SAWs_Initialize,());\n    }\n    ierr = PetscCitationsRegister(\"@TechReport{ saws,\\n\"\n                                  \"  Author = {Matt Otten and Jed Brown and Barry Smith},\\n\"\n                                  \"  Title  = {Scientific Application Web Server (SAWs) Users Manual},\\n\"\n                                  \"  Institution = {Argonne National Laboratory},\\n\"\n                                  \"  Year   = 2013\\n}\\n\",NULL);CHKERRQ(ierr);\n  }\n  PetscFunctionReturn(0);\n}\n#endif\n\n/* Things must be done before MPI_Init() when MPI is not yet initialized, and can be shared between C init and Fortran init */\nPETSC_INTERN PetscErrorCode PetscPreMPIInit_Private(void)\n{\n  PetscFunctionBegin;\n#if defined(PETSC_HAVE_HWLOC_SOLARIS_BUG)\n    /* see MPI.py for details on this bug */\n    (void) setenv(\"HWLOC_COMPONENTS\",\"-x86\",1);\n#endif\n  PetscFunctionReturn(0);\n}\n\n#if defined(PETSC_HAVE_ADIOS)\n#include <adios.h>\n#include <adios_read.h>\nint64_t Petsc_adios_group;\n#endif\n#if defined(PETSC_HAVE_ADIOS2)\n#include <adios2_c.h>\n#endif\n#if defined(PETSC_HAVE_OPENMP)\n#include <omp.h>\nPetscInt PetscNumOMPThreads;\n#endif\n\n#if defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n/*@C\n   PetscInitialize - Initializes the PETSc database and MPI.\n   PetscInitialize() calls MPI_Init() if that has yet to be called,\n   so this routine should always be called near the beginning of\n   your program -- usually the very first line!\n\n   Collective on MPI_COMM_WORLD or PETSC_COMM_WORLD if it has been set\n\n   Input Parameters:\n+  argc - count of number of command line arguments\n.  args - the command line arguments\n.  file - [optional] PETSc database file, append \":yaml\" to filename to specify YAML options format.\n          Use NULL or empty string to not check for code specific file.\n          Also checks ~/.petscrc, .petscrc and petscrc.\n          Use -skip_petscrc in the code specific file (or command line) to skip ~/.petscrc, .petscrc and petscrc files.\n-  help - [optional] Help message to print, use NULL for no message\n\n   If you wish PETSc code to run ONLY on a subcommunicator of MPI_COMM_WORLD, create that\n   communicator first and assign it to PETSC_COMM_WORLD BEFORE calling PetscInitialize(). Thus if you are running a\n   four process job and two processes will run PETSc and have PetscInitialize() and PetscFinalize() and two process will not,\n   then do this. If ALL processes in the job are using PetscInitialize() and PetscFinalize() then you don't need to do this, even\n   if different subcommunicators of the job are doing different things with PETSc.\n\n   Options Database Keys:\n+  -help [intro] - prints help method for each option; if intro is given the program stops after printing the introductory help message\n.  -start_in_debugger [noxterm,dbx,xdb,gdb,...] - Starts program in debugger\n.  -on_error_attach_debugger [noxterm,dbx,xdb,gdb,...] - Starts debugger when error detected\n.  -on_error_emacs <machinename> - causes emacsclient to jump to error file\n.  -on_error_abort - calls abort() when error detected (no traceback)\n.  -on_error_mpiabort - calls MPI_abort() when error detected\n.  -error_output_stderr - prints error messages to stderr instead of the default stdout\n.  -error_output_none - does not print the error messages (but handles errors in the same way as if this was not called)\n.  -debugger_ranks [rank1,rank2,...] - Indicates ranks to start in debugger\n.  -debugger_pause [sleeptime] (in seconds) - Pauses debugger\n.  -stop_for_debugger - Print message on how to attach debugger manually to\n                        process and wait (-debugger_pause) seconds for attachment\n.  -malloc - Indicates use of PETSc error-checking malloc (on by default for debug version of libraries) (deprecated, use -malloc_debug)\n.  -malloc no - Indicates not to use error-checking malloc (deprecated, use -malloc_debug no)\n.  -malloc_debug - check for memory corruption at EVERY malloc or free, see PetscMallocSetDebug()\n.  -malloc_dump - prints a list of all unfreed memory at the end of the run\n.  -malloc_test - like -malloc_dump -malloc_debug, but only active for debugging builds, ignored in optimized build. May want to set in PETSC_OPTIONS environmental variable\n.  -malloc_view - show a list of all allocated memory during PetscFinalize()\n.  -malloc_view_threshold <t> - only list memory allocations of size greater than t with -malloc_view\n.  -malloc_requested_size - malloc logging will record the requested size rather than size after alignment\n.  -fp_trap - Stops on floating point exceptions\n.  -no_signal_handler - Indicates not to trap error signals\n.  -shared_tmp - indicates /tmp directory is shared by all processors\n.  -not_shared_tmp - each processor has own /tmp\n.  -tmp - alternative name of /tmp directory\n.  -get_total_flops - returns total flops done by all processors\n-  -memory_view - Print memory usage at end of run\n\n   Options Database Keys for Option Database:\n+  -skip_petscrc - skip the default option files ~/.petscrc, .petscrc, petscrc\n.  -options_monitor - monitor all set options to standard output for the whole program run\n-  -options_monitor_cancel - cancel options monitoring hard-wired using PetscOptionsMonitorSet()\n\n   Options -options_monitor_{all,cancel} are\n   position-independent and apply to all options set since the PETSc start.\n   They can be used also in option files.\n\n   See PetscOptionsMonitorSet() to do monitoring programmatically.\n\n   Options Database Keys for Profiling:\n   See Users-Manual: ch_profiling for details.\n+  -info [filename][:[~]<list,of,classnames>[:[~]self]] - Prints verbose information. See PetscInfo().\n.  -log_sync - Enable barrier synchronization for all events. This option is useful to debug imbalance within each event,\n        however it slows things down and gives a distorted view of the overall runtime.\n.  -log_trace [filename] - Print traces of all PETSc calls to the screen (useful to determine where a program\n        hangs without running in the debugger).  See PetscLogTraceBegin().\n.  -log_view [:filename:format] - Prints summary of flop and timing information to screen or file, see PetscLogView().\n.  -log_view_memory - Includes in the summary from -log_view the memory used in each method, see PetscLogView().\n.  -log_summary [filename] - (Deprecated, use -log_view) Prints summary of flop and timing information to screen. If the filename is specified the\n        summary is written to the file.  See PetscLogView().\n.  -log_exclude: <vec,mat,pc,ksp,snes> - excludes subset of object classes from logging\n.  -log_all [filename] - Logs extensive profiling information  See PetscLogDump().\n.  -log [filename] - Logs basic profiline information  See PetscLogDump().\n.  -log_mpe [filename] - Creates a logfile viewable by the utility Jumpshot (in MPICH distribution)\n.  -viewfromoptions on,off - Enable or disable XXXSetFromOptions() calls, for applications with many small solves turn this off\n-  -check_pointer_intensity 0,1,2 - if pointers are checked for validity (debug version only), using 0 will result in faster code\n\n    Only one of -log_trace, -log_view, -log_view, -log_all, -log, or -log_mpe may be used at a time\n\n   Options Database Keys for SAWs:\n+  -saws_port <portnumber> - port number to publish SAWs data, default is 8080\n.  -saws_port_auto_select - have SAWs select a new unique port number where it publishes the data, the URL is printed to the screen\n                            this is useful when you are running many jobs that utilize SAWs at the same time\n.  -saws_log <filename> - save a log of all SAWs communication\n.  -saws_https <certificate file> - have SAWs use HTTPS instead of HTTP\n-  -saws_root <directory> - allow SAWs to have access to the given directory to search for requested resources and files\n\n   Environmental Variables:\n+   PETSC_TMP - alternative tmp directory\n.   PETSC_SHARED_TMP - tmp is shared by all processes\n.   PETSC_NOT_SHARED_TMP - each process has its own private tmp\n.   PETSC_OPTIONS - a string containing additional options for petsc in the form of command line \"-key value\" pairs\n.   PETSC_OPTIONS_YAML - (requires configuring PETSc to use libyaml) a string containing additional options for petsc in the form of a YAML document\n.   PETSC_VIEWER_SOCKET_PORT - socket number to use for socket viewer\n-   PETSC_VIEWER_SOCKET_MACHINE - machine to use for socket viewer to connect to\n\n\n   Level: beginner\n\n   Notes:\n   If for some reason you must call MPI_Init() separately, call\n   it before PetscInitialize().\n\n   Fortran Version:\n   In Fortran this routine has the format\n$       call PetscInitialize(file,ierr)\n\n+   ierr - error return code\n-  file - [optional] PETSc database file, also checks ~/.petscrc, .petscrc and petscrc.\n          Use PETSC_NULL_CHARACTER to not check for code specific file.\n          Use -skip_petscrc in the code specific file (or command line) to skip ~/.petscrc, .petscrc and petscrc files.\n\n   Important Fortran Note:\n   In Fortran, you MUST use PETSC_NULL_CHARACTER to indicate a\n   null character string; you CANNOT just use NULL as\n   in the C version. See Users-Manual: ch_fortran for details.\n\n   If your main program is C but you call Fortran code that also uses PETSc you need to call PetscInitializeFortran() soon after\n   calling PetscInitialize().\n\n.seealso: PetscFinalize(), PetscInitializeFortran(), PetscGetArgs(), PetscInitializeNoArguments()\n\n@*/\nPetscErrorCode  PetscInitialize(int *argc,char ***args,const char file[],const char help[])\n{\n  PetscErrorCode ierr;\n  PetscMPIInt    flag, size;\n  PetscBool      flg = PETSC_TRUE;\n  char           hostname[256];\n\n  PetscFunctionBegin;\n  if (PetscInitializeCalled) PetscFunctionReturn(0);\n  /*\n      The checking over compatible runtime libraries is complicated by the MPI ABI initiative\n      https://wiki.mpich.org/mpich/index.php/ABI_Compatibility_Initiative which started with\n        MPICH v3.1 (Released Feburary 2014)\n        IBM MPI v2.1 (December 2014)\n        Intel MPI Library v5.0 (2014)\n        Cray MPT v7.0.0 (June 2014)\n      As of July 31, 2017 the ABI number still appears to be 12, that is all of the versions\n      listed above and since that time are compatible.\n\n      Unfortunately the MPI ABI initiative has not defined a way to determine the ABI number\n      at compile time or runtime. Thus we will need to systematically track the allowed versions\n      and how they are represented in the mpi.h and MPI_Get_library_version() output in order\n      to perform the checking.\n\n      Currently we only check for pre MPI ABI versions (and packages that do not follow the MPI ABI).\n\n      Questions:\n\n        Should the checks for ABI incompatibility be only on the major version number below?\n        Presumably the output to stderr will be removed before a release.\n  */\n\n#if defined(PETSC_HAVE_MPI_GET_LIBRARY_VERSION)\n  {\n    char        mpilibraryversion[MPI_MAX_LIBRARY_VERSION_STRING];\n    PetscMPIInt mpilibraryversionlength;\n    ierr = MPI_Get_library_version(mpilibraryversion,&mpilibraryversionlength);if (ierr) return ierr;\n    /* check for MPICH versions before MPI ABI initiative */\n#if defined(MPICH_VERSION)\n#if MPICH_NUMVERSION < 30100000\n    {\n      char *ver,*lf;\n      flg = PETSC_FALSE;\n      ierr = PetscStrstr(mpilibraryversion,\"MPICH Version:\",&ver);if (ierr) return ierr;\n      if (ver) {\n        ierr = PetscStrchr(ver,'\\n',&lf);if (ierr) return ierr;\n        if (lf) {\n          *lf = 0;\n          ierr = PetscStrendswith(ver,MPICH_VERSION,&flg);if (ierr) return ierr;\n        }\n      }\n      if (!flg) {\n        fprintf(stderr,\"PETSc Error --- MPICH library version \\n%s does not match what PETSc was compiled with %s, aborting\\n\",mpilibraryversion,MPICH_VERSION);\n        return PETSC_ERR_MPI_LIB_INCOMP;\n      }\n    }\n#endif\n    /* check for OpenMPI version, it is not part of the MPI ABI initiative (is it part of another initiative that needs to be handled?) */\n#elif defined(OMPI_MAJOR_VERSION)\n    {\n      char *ver,bs[32],*bsf;\n      flg = PETSC_FALSE;\n      ierr = PetscStrstr(mpilibraryversion,\"Open MPI\",&ver);if (ierr) return ierr;\n      if (ver) {\n        PetscSNPrintf(bs,32,\"v%d.%d\",OMPI_MAJOR_VERSION,OMPI_MINOR_VERSION);\n        ierr = PetscStrstr(ver,bs,&bsf);if (ierr) return ierr;\n        if (bsf) flg = PETSC_TRUE;\n      }\n      if (!flg) {\n        fprintf(stderr,\"PETSc Error --- Open MPI library version \\n%s does not match what PETSc was compiled with %d.%d, aborting\\n\",mpilibraryversion,OMPI_MAJOR_VERSION,OMPI_MINOR_VERSION);\n        return PETSC_ERR_MPI_LIB_INCOMP;\n      }\n    }\n#endif\n  }\n#endif\n\n#if defined(PETSC_HAVE_DLSYM)\n  {\n    PetscInt cnt = 0;\n    /* These symbols are currently in the OpenMPI and MPICH libraries; they may not always be, in that case the test will simply not detect the problem */\n    if (dlsym(RTLD_DEFAULT,\"ompi_mpi_init\")) cnt++;\n    if (dlsym(RTLD_DEFAULT,\"MPL_exit\")) cnt++;\n    if (cnt > 1) {\n      fprintf(stderr,\"PETSc Error --- Application was linked against both OpenMPI and MPICH based MPI libraries and will not run correctly\\n\");\n      return PETSC_ERR_MPI_LIB_INCOMP;\n    }\n  }\n#endif\n\n  /* these must be initialized in a routine, not as a constant declaration*/\n  PETSC_STDOUT = stdout;\n  PETSC_STDERR = stderr;\n\n  /*CHKERRQ can be used from now */\n  PetscErrorHandlingInitialized = PETSC_TRUE;\n\n  /* on Windows - set printf to default to printing 2 digit exponents */\n#if defined(PETSC_HAVE__SET_OUTPUT_FORMAT)\n  _set_output_format(_TWO_DIGIT_EXPONENT);\n#endif\n\n  ierr = PetscOptionsCreateDefault();CHKERRQ(ierr);\n\n  /*\n     We initialize the program name here (before MPI_Init()) because MPICH has a bug in\n     it that it sets args[0] on all processors to be args[0] on the first processor.\n  */\n  if (argc && *argc) {\n    ierr = PetscSetProgramName(**args);CHKERRQ(ierr);\n  } else {\n    ierr = PetscSetProgramName(\"Unknown Name\");CHKERRQ(ierr);\n  }\n\n  ierr = MPI_Initialized(&flag);CHKERRMPI(ierr);\n  if (!flag) {\n    if (PETSC_COMM_WORLD != MPI_COMM_NULL) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP,\"You cannot set PETSC_COMM_WORLD if you have not initialized MPI first\");\n    ierr = PetscPreMPIInit_Private();CHKERRQ(ierr);\n#if defined(PETSC_HAVE_MPI_INIT_THREAD)\n    {\n      PetscMPIInt provided;\n      ierr = MPI_Init_thread(argc,args,PETSC_MPI_THREAD_REQUIRED,&provided);CHKERRMPI(ierr);\n    }\n#else\n    ierr = MPI_Init(argc,args);CHKERRMPI(ierr);\n#endif\n    PetscBeganMPI = PETSC_TRUE;\n  }\n\n  if (argc && args) {\n    PetscGlobalArgc = *argc;\n    PetscGlobalArgs = *args;\n  }\n  PetscFinalizeCalled = PETSC_FALSE;\n  ierr = PetscSpinlockCreate(&PetscViewerASCIISpinLockOpen);CHKERRQ(ierr);\n  ierr = PetscSpinlockCreate(&PetscViewerASCIISpinLockStdout);CHKERRQ(ierr);\n  ierr = PetscSpinlockCreate(&PetscViewerASCIISpinLockStderr);CHKERRQ(ierr);\n  ierr = PetscSpinlockCreate(&PetscCommSpinLock);CHKERRQ(ierr);\n\n  if (PETSC_COMM_WORLD == MPI_COMM_NULL) PETSC_COMM_WORLD = MPI_COMM_WORLD;\n  ierr = MPI_Comm_set_errhandler(PETSC_COMM_WORLD,MPI_ERRORS_RETURN);CHKERRMPI(ierr);\n\n  if (PETSC_MPI_ERROR_CLASS == MPI_ERR_LASTCODE) {\n    ierr = MPI_Add_error_class(&PETSC_MPI_ERROR_CLASS);CHKERRMPI(ierr);\n    ierr = MPI_Add_error_code(PETSC_MPI_ERROR_CLASS,&PETSC_MPI_ERROR_CODE);CHKERRMPI(ierr);\n  }\n\n  /* Done after init due to a bug in MPICH-GM? */\n  ierr = PetscErrorPrintfInitialize();CHKERRQ(ierr);\n\n  ierr = MPI_Comm_rank(MPI_COMM_WORLD,&PetscGlobalRank);CHKERRMPI(ierr);\n  ierr = MPI_Comm_size(MPI_COMM_WORLD,&PetscGlobalSize);CHKERRMPI(ierr);\n\n  MPIU_BOOL = MPI_INT;\n  MPIU_ENUM = MPI_INT;\n  MPIU_FORTRANADDR = (sizeof(void*) == sizeof(int)) ? MPI_INT : MPIU_INT64;\n  if (sizeof(size_t) == sizeof(unsigned)) MPIU_SIZE_T = MPI_UNSIGNED;\n  else if (sizeof(size_t) == sizeof(unsigned long)) MPIU_SIZE_T = MPI_UNSIGNED_LONG;\n#if defined(PETSC_SIZEOF_LONG_LONG)\n  else if (sizeof(size_t) == sizeof(unsigned long long)) MPIU_SIZE_T = MPI_UNSIGNED_LONG_LONG;\n#endif\n  else {(*PetscErrorPrintf)(\"PetscInitialize: Could not find MPI type for size_t\\n\"); return PETSC_ERR_SUP_SYS;}\n\n  /*\n     Initialized the global complex variable; this is because with\n     shared libraries the constructors for global variables\n     are not called; at least on IRIX.\n  */\n#if defined(PETSC_HAVE_COMPLEX)\n  {\n#if defined(PETSC_CLANGUAGE_CXX) && !defined(PETSC_USE_REAL___FLOAT128)\n    PetscComplex ic(0.0,1.0);\n    PETSC_i = ic;\n#else\n    PETSC_i = _Complex_I;\n#endif\n  }\n\n#if !defined(PETSC_HAVE_MPI_C_DOUBLE_COMPLEX)\n  ierr = MPI_Type_contiguous(2,MPI_DOUBLE,&MPIU_C_DOUBLE_COMPLEX);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU_C_DOUBLE_COMPLEX);CHKERRMPI(ierr);\n  ierr = MPI_Type_contiguous(2,MPI_FLOAT,&MPIU_C_COMPLEX);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU_C_COMPLEX);CHKERRMPI(ierr);\n#endif\n#endif /* PETSC_HAVE_COMPLEX */\n\n  /*\n     Create the PETSc MPI reduction operator that sums of the first\n     half of the entries and maxes the second half.\n  */\n  ierr = MPI_Op_create(MPIU_MaxSum_Local,1,&MPIU_MAXSUM_OP);CHKERRMPI(ierr);\n\n#if defined(PETSC_USE_REAL___FLOAT128)\n  ierr = MPI_Type_contiguous(2,MPI_DOUBLE,&MPIU___FLOAT128);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU___FLOAT128);CHKERRMPI(ierr);\n#if defined(PETSC_HAVE_COMPLEX)\n  ierr = MPI_Type_contiguous(4,MPI_DOUBLE,&MPIU___COMPLEX128);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU___COMPLEX128);CHKERRMPI(ierr);\n#endif\n  ierr = MPI_Op_create(PetscMax_Local,1,&MPIU_MAX);CHKERRMPI(ierr);\n  ierr = MPI_Op_create(PetscMin_Local,1,&MPIU_MIN);CHKERRMPI(ierr);\n#elif defined(PETSC_USE_REAL___FP16)\n  ierr = MPI_Type_contiguous(2,MPI_CHAR,&MPIU___FP16);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU___FP16);CHKERRMPI(ierr);\n  ierr = MPI_Op_create(PetscMax_Local,1,&MPIU_MAX);CHKERRMPI(ierr);\n  ierr = MPI_Op_create(PetscMin_Local,1,&MPIU_MIN);CHKERRMPI(ierr);\n#endif\n\n#if (defined(PETSC_HAVE_COMPLEX) && !defined(PETSC_HAVE_MPI_C_DOUBLE_COMPLEX)) || defined(PETSC_USE_REAL___FLOAT128) || defined(PETSC_USE_REAL___FP16)\n  ierr = MPI_Op_create(PetscSum_Local,1,&MPIU_SUM);CHKERRMPI(ierr);\n#endif\n\n  ierr = MPI_Type_contiguous(2,MPIU_SCALAR,&MPIU_2SCALAR);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU_2SCALAR);CHKERRMPI(ierr);\n\n#if defined(PETSC_USE_64BIT_INDICES)\n  ierr = MPI_Type_contiguous(2,MPIU_INT,&MPIU_2INT);CHKERRMPI(ierr);\n  ierr = MPI_Type_commit(&MPIU_2INT);CHKERRMPI(ierr);\n#endif\n\n  /*\n     Attributes to be set on PETSc communicators\n  */\n  ierr = MPI_Comm_create_keyval(MPI_COMM_NULL_COPY_FN,Petsc_Counter_Attr_Delete_Fn,&Petsc_Counter_keyval,(void*)0);CHKERRMPI(ierr);\n  ierr = MPI_Comm_create_keyval(MPI_COMM_NULL_COPY_FN,Petsc_InnerComm_Attr_Delete_Fn,&Petsc_InnerComm_keyval,(void*)0);CHKERRMPI(ierr);\n  ierr = MPI_Comm_create_keyval(MPI_COMM_NULL_COPY_FN,Petsc_OuterComm_Attr_Delete_Fn,&Petsc_OuterComm_keyval,(void*)0);CHKERRMPI(ierr);\n  ierr = MPI_Comm_create_keyval(MPI_COMM_NULL_COPY_FN,Petsc_ShmComm_Attr_Delete_Fn,&Petsc_ShmComm_keyval,(void*)0);CHKERRMPI(ierr);\n\n  /*\n     Build the options database\n  */\n  ierr = PetscOptionsInsert(NULL,argc,args,file);CHKERRQ(ierr);\n\n  /* call a second time so it can look in the options database */\n  ierr = PetscErrorPrintfInitialize();CHKERRQ(ierr);\n\n  /*\n     Check system options and print help\n  */\n  ierr = PetscOptionsCheckInitial_Private(help);CHKERRQ(ierr);\n\n  ierr = PetscCitationsInitialize();CHKERRQ(ierr);\n\n#if defined(PETSC_HAVE_SAWS)\n  ierr = PetscInitializeSAWs(help);CHKERRQ(ierr);\n#endif\n\n  /*\n     Load the dynamic libraries (on machines that support them), this registers all\n     the solvers etc. (On non-dynamic machines this initializes the PetscDraw and PetscViewer classes)\n  */\n  ierr = PetscInitialize_DynamicLibraries();CHKERRQ(ierr);\n\n  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRMPI(ierr);\n  ierr = PetscInfo1(NULL,\"PETSc successfully started: number of processors = %d\\n\",size);CHKERRQ(ierr);\n  ierr = PetscGetHostName(hostname,256);CHKERRQ(ierr);\n  ierr = PetscInfo1(NULL,\"Running on machine: %s\\n\",hostname);CHKERRQ(ierr);\n#if defined(PETSC_HAVE_OPENMP)\n  {\n    PetscBool omp_view_flag;\n    char      *threads = getenv(\"OMP_NUM_THREADS\");\n\n   if (threads) {\n     ierr = PetscInfo1(NULL,\"Number of OpenMP threads %s (given by OMP_NUM_THREADS)\\n\",threads);CHKERRQ(ierr);\n     (void) sscanf(threads, \"%\" PetscInt_FMT,&PetscNumOMPThreads);\n   } else {\n#define NMAX  10000\n     int          i;\n      PetscScalar *x;\n      ierr = PetscMalloc1(NMAX,&x);CHKERRQ(ierr);\n#pragma omp parallel for\n      for (i=0; i<NMAX; i++) {\n        x[i] = 0.0;\n        PetscNumOMPThreads  = (PetscInt) omp_get_num_threads();\n      }\n      ierr = PetscFree(x);CHKERRQ(ierr);\n      ierr = PetscInfo1(NULL,\"Number of OpenMP threads %D (number not set with OMP_NUM_THREADS, chosen by system)\\n\",PetscNumOMPThreads);CHKERRQ(ierr);\n    }\n    ierr = PetscOptionsBegin(PETSC_COMM_WORLD,NULL,\"OpenMP options\",\"Sys\");CHKERRQ(ierr);\n    ierr = PetscOptionsInt(\"-omp_num_threads\",\"Number of OpenMP threads to use (can also use environmental variable OMP_NUM_THREADS\",\"None\",PetscNumOMPThreads,&PetscNumOMPThreads,&flg);CHKERRQ(ierr);\n    ierr = PetscOptionsName(\"-omp_view\",\"Display OpenMP number of threads\",NULL,&omp_view_flag);CHKERRQ(ierr);\n    ierr = PetscOptionsEnd();CHKERRQ(ierr);\n    if (flg) {\n      ierr = PetscInfo1(NULL,\"Number of OpenMP theads %D (given by -omp_num_threads)\\n\",PetscNumOMPThreads);CHKERRQ(ierr);\n      omp_set_num_threads((int)PetscNumOMPThreads);\n    }\n    if (omp_view_flag) {\n      ierr = PetscPrintf(PETSC_COMM_WORLD,\"OpenMP: number of threads %D\\n\",PetscNumOMPThreads);CHKERRQ(ierr);\n    }\n  }\n#endif\n\n#if defined(PETSC_USE_PETSC_MPI_EXTERNAL32)\n  /*\n      Tell MPI about our own data representation converter, this would/should be used if extern32 is not supported by the MPI\n\n      Currently not used because it is not supported by MPICH.\n  */\n  if (!PetscBinaryBigEndian()) {\n    ierr = MPI_Register_datarep((char*)\"petsc\",PetscDataRep_read_conv_fn,PetscDataRep_write_conv_fn,PetscDataRep_extent_fn,NULL);CHKERRMPI(ierr);\n  }\n#endif\n\n  /*\n      Setup building of stack frames for all function calls\n  */\n#if defined(PETSC_USE_DEBUG) && !defined(PETSC_HAVE_THREADSAFETY)\n  ierr = PetscStackCreate();CHKERRQ(ierr);\n#endif\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  ierr = PetscFPTCreate(10000);CHKERRQ(ierr);\n#endif\n\n#if defined(PETSC_HAVE_HWLOC)\n  {\n    PetscViewer viewer;\n    ierr = PetscOptionsGetViewer(PETSC_COMM_WORLD,NULL,NULL,\"-process_view\",&viewer,NULL,&flg);CHKERRQ(ierr);\n    if (flg) {\n      ierr = PetscProcessPlacementView(viewer);CHKERRQ(ierr);\n      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);\n    }\n  }\n#endif\n\n  flg = PETSC_TRUE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-viewfromoptions\",&flg,NULL);CHKERRQ(ierr);\n  if (!flg) {ierr = PetscOptionsPushGetViewerOff(PETSC_TRUE);CHKERRQ(ierr);}\n\n#if defined(PETSC_HAVE_ADIOS)\n  ierr = adios_init_noxml(PETSC_COMM_WORLD);CHKERRQ(ierr);\n  ierr = adios_declare_group(&Petsc_adios_group,\"PETSc\",\"\",adios_stat_default);CHKERRQ(ierr);\n  ierr = adios_select_method(Petsc_adios_group,\"MPI\",\"\",\"\");CHKERRQ(ierr);\n  ierr = adios_read_init_method(ADIOS_READ_METHOD_BP,PETSC_COMM_WORLD,\"\");CHKERRQ(ierr);\n#endif\n#if defined(PETSC_HAVE_ADIOS2)\n#endif\n\n  /*\n      Set flag that we are completely initialized\n  */\n  PetscInitializeCalled = PETSC_TRUE;\n\n  ierr = PetscOptionsHasName(NULL,NULL,\"-python\",&flg);CHKERRQ(ierr);\n  if (flg) {ierr = PetscPythonInitialize(NULL,NULL);CHKERRQ(ierr);}\n  PetscFunctionReturn(0);\n}\n\n#if defined(PETSC_USE_LOG)\nPETSC_INTERN PetscObject *PetscObjects;\nPETSC_INTERN PetscInt    PetscObjectsCounts;\nPETSC_INTERN PetscInt    PetscObjectsMaxCounts;\nPETSC_INTERN PetscBool   PetscObjectsLog;\n#endif\n\n/*\n    Frees all the MPI types and operations that PETSc may have created\n*/\nPetscErrorCode  PetscFreeMPIResources(void)\n{\n  PetscErrorCode ierr;\n\n  PetscFunctionBegin;\n#if defined(PETSC_USE_REAL___FLOAT128)\n  ierr = MPI_Type_free(&MPIU___FLOAT128);CHKERRMPI(ierr);\n#if defined(PETSC_HAVE_COMPLEX)\n  ierr = MPI_Type_free(&MPIU___COMPLEX128);CHKERRMPI(ierr);\n#endif\n  ierr = MPI_Op_free(&MPIU_MAX);CHKERRMPI(ierr);\n  ierr = MPI_Op_free(&MPIU_MIN);CHKERRMPI(ierr);\n#elif defined(PETSC_USE_REAL___FP16)\n  ierr = MPI_Type_free(&MPIU___FP16);CHKERRMPI(ierr);\n  ierr = MPI_Op_free(&MPIU_MAX);CHKERRMPI(ierr);\n  ierr = MPI_Op_free(&MPIU_MIN);CHKERRMPI(ierr);\n#endif\n\n#if defined(PETSC_HAVE_COMPLEX)\n#if !defined(PETSC_HAVE_MPI_C_DOUBLE_COMPLEX)\n  ierr = MPI_Type_free(&MPIU_C_DOUBLE_COMPLEX);CHKERRMPI(ierr);\n  ierr = MPI_Type_free(&MPIU_C_COMPLEX);CHKERRMPI(ierr);\n#endif\n#endif\n\n#if (defined(PETSC_HAVE_COMPLEX) && !defined(PETSC_HAVE_MPI_C_DOUBLE_COMPLEX)) || defined(PETSC_USE_REAL___FLOAT128) || defined(PETSC_USE_REAL___FP16)\n  ierr = MPI_Op_free(&MPIU_SUM);CHKERRMPI(ierr);\n#endif\n\n  ierr = MPI_Type_free(&MPIU_2SCALAR);CHKERRMPI(ierr);\n#if defined(PETSC_USE_64BIT_INDICES)\n  ierr = MPI_Type_free(&MPIU_2INT);CHKERRMPI(ierr);\n#endif\n  ierr = MPI_Op_free(&MPIU_MAXSUM_OP);CHKERRMPI(ierr);\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscFinalize - Checks for options to be called at the conclusion\n   of the program. MPI_Finalize() is called only if the user had not\n   called MPI_Init() before calling PetscInitialize().\n\n   Collective on PETSC_COMM_WORLD\n\n   Options Database Keys:\n+  -options_view - Calls PetscOptionsView()\n.  -options_left - Prints unused options that remain in the database\n.  -objects_dump [all] - Prints list of objects allocated by the user that have not been freed, the option all cause all outstanding objects to be listed\n.  -mpidump - Calls PetscMPIDump()\n.  -malloc_dump <optional filename> - Calls PetscMallocDump(), displays all memory allocated that has not been freed\n.  -malloc_info - Prints total memory usage\n-  -malloc_view <optional filename> - Prints list of all memory allocated and where\n\n   Level: beginner\n\n   Note:\n   See PetscInitialize() for more general runtime options.\n\n.seealso: PetscInitialize(), PetscOptionsView(), PetscMallocDump(), PetscMPIDump(), PetscEnd()\n@*/\nPetscErrorCode  PetscFinalize(void)\n{\n  PetscErrorCode ierr;\n  PetscMPIInt    rank;\n  PetscInt       nopt;\n  PetscBool      flg1 = PETSC_FALSE,flg2 = PETSC_FALSE,flg3 = PETSC_FALSE;\n  PetscBool      flg;\n#if defined(PETSC_USE_LOG)\n  char           mname[PETSC_MAX_PATH_LEN];\n#endif\n\n  if (!PetscInitializeCalled) {\n    printf(\"PetscInitialize() must be called before PetscFinalize()\\n\");\n    return(PETSC_ERR_ARG_WRONGSTATE);\n  }\n  PetscFunctionBegin;\n  ierr = PetscInfo(NULL,\"PetscFinalize() called\\n\");CHKERRQ(ierr);\n\n  ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank);CHKERRMPI(ierr);\n#if defined(PETSC_HAVE_ADIOS)\n  ierr = adios_read_finalize_method(ADIOS_READ_METHOD_BP_AGGREGATE);CHKERRQ(ierr);\n  ierr = adios_finalize(rank);CHKERRQ(ierr);\n#endif\n#if defined(PETSC_HAVE_ADIOS2)\n#endif\n  ierr = PetscOptionsHasName(NULL,NULL,\"-citations\",&flg);CHKERRQ(ierr);\n  if (flg) {\n    char  *cits, filename[PETSC_MAX_PATH_LEN];\n    FILE  *fd = PETSC_STDOUT;\n\n    ierr = PetscOptionsGetString(NULL,NULL,\"-citations\",filename,sizeof(filename),NULL);CHKERRQ(ierr);\n    if (filename[0]) {\n      ierr = PetscFOpen(PETSC_COMM_WORLD,filename,\"w\",&fd);CHKERRQ(ierr);\n    }\n    ierr = PetscSegBufferGet(PetscCitationsList,1,&cits);CHKERRQ(ierr);\n    cits[0] = 0;\n    ierr = PetscSegBufferExtractAlloc(PetscCitationsList,&cits);CHKERRQ(ierr);\n    ierr = PetscFPrintf(PETSC_COMM_WORLD,fd,\"If you publish results based on this computation please cite the following:\\n\");CHKERRQ(ierr);\n    ierr = PetscFPrintf(PETSC_COMM_WORLD,fd,\"===========================================================================\\n\");CHKERRQ(ierr);\n    ierr = PetscFPrintf(PETSC_COMM_WORLD,fd,\"%s\",cits);CHKERRQ(ierr);\n    ierr = PetscFPrintf(PETSC_COMM_WORLD,fd,\"===========================================================================\\n\");CHKERRQ(ierr);\n    ierr = PetscFClose(PETSC_COMM_WORLD,fd);CHKERRQ(ierr);\n    ierr = PetscFree(cits);CHKERRQ(ierr);\n  }\n  ierr = PetscSegBufferDestroy(&PetscCitationsList);CHKERRQ(ierr);\n\n#if defined(PETSC_HAVE_SSL) && defined(PETSC_USE_SOCKET_VIEWER)\n  /* TextBelt is run for testing purposes only, please do not use this feature often */\n  {\n    PetscInt nmax = 2;\n    char     **buffs;\n    ierr = PetscMalloc1(2,&buffs);CHKERRQ(ierr);\n    ierr = PetscOptionsGetStringArray(NULL,NULL,\"-textbelt\",buffs,&nmax,&flg1);CHKERRQ(ierr);\n    if (flg1) {\n      if (!nmax) SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,\"-textbelt requires either the phone number or number,\\\"message\\\"\");\n      if (nmax == 1) {\n        ierr = PetscMalloc1(128,&buffs[1]);CHKERRQ(ierr);\n        ierr = PetscGetProgramName(buffs[1],32);CHKERRQ(ierr);\n        ierr = PetscStrcat(buffs[1],\" has completed\");CHKERRQ(ierr);\n      }\n      ierr = PetscTextBelt(PETSC_COMM_WORLD,buffs[0],buffs[1],NULL);CHKERRQ(ierr);\n      ierr = PetscFree(buffs[0]);CHKERRQ(ierr);\n      ierr = PetscFree(buffs[1]);CHKERRQ(ierr);\n    }\n    ierr = PetscFree(buffs);CHKERRQ(ierr);\n  }\n  {\n    PetscInt nmax = 2;\n    char     **buffs;\n    ierr = PetscMalloc1(2,&buffs);CHKERRQ(ierr);\n    ierr = PetscOptionsGetStringArray(NULL,NULL,\"-tellmycell\",buffs,&nmax,&flg1);CHKERRQ(ierr);\n    if (flg1) {\n      if (!nmax) SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,\"-tellmycell requires either the phone number or number,\\\"message\\\"\");\n      if (nmax == 1) {\n        ierr = PetscMalloc1(128,&buffs[1]);CHKERRQ(ierr);\n        ierr = PetscGetProgramName(buffs[1],32);CHKERRQ(ierr);\n        ierr = PetscStrcat(buffs[1],\" has completed\");CHKERRQ(ierr);\n      }\n      ierr = PetscTellMyCell(PETSC_COMM_WORLD,buffs[0],buffs[1],NULL);CHKERRQ(ierr);\n      ierr = PetscFree(buffs[0]);CHKERRQ(ierr);\n      ierr = PetscFree(buffs[1]);CHKERRQ(ierr);\n    }\n    ierr = PetscFree(buffs);CHKERRQ(ierr);\n  }\n#endif\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  ierr = PetscFPTDestroy();CHKERRQ(ierr);\n#endif\n\n#if defined(PETSC_HAVE_SAWS)\n  flg = PETSC_FALSE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-saw_options\",&flg,NULL);CHKERRQ(ierr);\n  if (flg) {\n    ierr = PetscOptionsSAWsDestroy();CHKERRQ(ierr);\n  }\n#endif\n\n#if defined(PETSC_HAVE_X)\n  flg1 = PETSC_FALSE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-x_virtual\",&flg1,NULL);CHKERRQ(ierr);\n  if (flg1) {\n    /*  this is a crude hack, but better than nothing */\n    ierr = PetscPOpen(PETSC_COMM_WORLD,NULL,\"pkill -9 Xvfb\",\"r\",NULL);CHKERRQ(ierr);\n  }\n#endif\n\n#if !defined(PETSC_HAVE_THREADSAFETY)\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-malloc_info\",&flg2,NULL);CHKERRQ(ierr);\n  if (!flg2) {\n    flg2 = PETSC_FALSE;\n    ierr = PetscOptionsGetBool(NULL,NULL,\"-memory_view\",&flg2,NULL);CHKERRQ(ierr);\n  }\n  if (flg2) {\n    ierr = PetscMemoryView(PETSC_VIEWER_STDOUT_WORLD,\"Summary of Memory Usage in PETSc\\n\");CHKERRQ(ierr);\n  }\n#endif\n\n#if defined(PETSC_USE_LOG)\n  flg1 = PETSC_FALSE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-get_total_flops\",&flg1,NULL);CHKERRQ(ierr);\n  if (flg1) {\n    PetscLogDouble flops = 0;\n    ierr = MPI_Reduce(&petsc_TotalFlops,&flops,1,MPI_DOUBLE,MPI_SUM,0,PETSC_COMM_WORLD);CHKERRMPI(ierr);\n    ierr = PetscPrintf(PETSC_COMM_WORLD,\"Total flops over all processors %g\\n\",flops);CHKERRQ(ierr);\n  }\n#endif\n\n\n#if defined(PETSC_USE_LOG)\n#if defined(PETSC_HAVE_MPE)\n  mname[0] = 0;\n  ierr = PetscOptionsGetString(NULL,NULL,\"-log_mpe\",mname,sizeof(mname),&flg1);CHKERRQ(ierr);\n  if (flg1) {\n    if (mname[0]) {ierr = PetscLogMPEDump(mname);CHKERRQ(ierr);}\n    else          {ierr = PetscLogMPEDump(0);CHKERRQ(ierr);}\n  }\n#endif\n#endif\n\n  /*\n     Free all objects registered with PetscObjectRegisterDestroy() such as PETSC_VIEWER_XXX_().\n  */\n  ierr = PetscObjectRegisterDestroyAll();CHKERRQ(ierr);\n\n#if defined(PETSC_USE_LOG)\n  ierr = PetscOptionsPushGetViewerOff(PETSC_FALSE);CHKERRQ(ierr);\n  ierr = PetscLogViewFromOptions();CHKERRQ(ierr);\n  ierr = PetscOptionsPopGetViewerOff();CHKERRQ(ierr);\n\n  mname[0] = 0;\n  ierr = PetscOptionsGetString(NULL,NULL,\"-log_summary\",mname,sizeof(mname),&flg1);CHKERRQ(ierr);\n  if (flg1) {\n    PetscViewer viewer;\n    ierr = (*PetscHelpPrintf)(PETSC_COMM_WORLD,\"\\n\\n WARNING:   -log_summary is being deprecated; switch to -log_view\\n\\n\\n\");CHKERRQ(ierr);\n    if (mname[0]) {\n      ierr = PetscViewerASCIIOpen(PETSC_COMM_WORLD,mname,&viewer);CHKERRQ(ierr);\n      ierr = PetscLogView(viewer);CHKERRQ(ierr);\n      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);\n    } else {\n      viewer = PETSC_VIEWER_STDOUT_WORLD;\n      ierr   = PetscViewerPushFormat(viewer,PETSC_VIEWER_DEFAULT);CHKERRQ(ierr);\n      ierr   = PetscLogView(viewer);CHKERRQ(ierr);\n      ierr   = PetscViewerPopFormat(viewer);CHKERRQ(ierr);\n    }\n  }\n\n  /*\n     Free any objects created by the last block of code.\n  */\n  ierr = PetscObjectRegisterDestroyAll();CHKERRQ(ierr);\n\n  mname[0] = 0;\n  ierr = PetscOptionsGetString(NULL,NULL,\"-log_all\",mname,sizeof(mname),&flg1);CHKERRQ(ierr);\n  ierr = PetscOptionsGetString(NULL,NULL,\"-log\",mname,sizeof(mname),&flg2);CHKERRQ(ierr);\n  if (flg1 || flg2) {ierr = PetscLogDump(mname);CHKERRQ(ierr);}\n#endif\n\n  ierr = PetscStackDestroy();CHKERRQ(ierr);\n\n  flg1 = PETSC_FALSE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-no_signal_handler\",&flg1,NULL);CHKERRQ(ierr);\n  if (!flg1) { ierr = PetscPopSignalHandler();CHKERRQ(ierr);}\n  flg1 = PETSC_FALSE;\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-mpidump\",&flg1,NULL);CHKERRQ(ierr);\n  if (flg1) {\n    ierr = PetscMPIDump(stdout);CHKERRQ(ierr);\n  }\n  flg1 = PETSC_FALSE;\n  flg2 = PETSC_FALSE;\n  /* preemptive call to avoid listing this option in options table as unused */\n  ierr = PetscOptionsHasName(NULL,NULL,\"-malloc_dump\",&flg1);CHKERRQ(ierr);\n  ierr = PetscOptionsHasName(NULL,NULL,\"-objects_dump\",&flg1);CHKERRQ(ierr);\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-options_view\",&flg2,NULL);CHKERRQ(ierr);\n\n  if (flg2) {\n    PetscViewer viewer;\n    ierr = PetscViewerCreate(PETSC_COMM_WORLD,&viewer);CHKERRQ(ierr);\n    ierr = PetscViewerSetType(viewer,PETSCVIEWERASCII);CHKERRQ(ierr);\n    ierr = PetscOptionsView(NULL,viewer);CHKERRQ(ierr);\n    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);\n  }\n\n  /* to prevent PETSc -options_left from warning */\n  ierr = PetscOptionsHasName(NULL,NULL,\"-nox\",&flg1);CHKERRQ(ierr);\n  ierr = PetscOptionsHasName(NULL,NULL,\"-nox_warning\",&flg1);CHKERRQ(ierr);\n\n  flg3 = PETSC_FALSE; /* default value is required */\n  ierr = PetscOptionsGetBool(NULL,NULL,\"-options_left\",&flg3,&flg1);CHKERRQ(ierr);\n  if (PetscUnlikelyDebug(!flg1)) flg3 = PETSC_TRUE;\n  if (flg3) {\n    if (!flg2 && flg1) { /* have not yet printed the options */\n      PetscViewer viewer;\n      ierr = PetscViewerCreate(PETSC_COMM_WORLD,&viewer);CHKERRQ(ierr);\n      ierr = PetscViewerSetType(viewer,PETSCVIEWERASCII);CHKERRQ(ierr);\n      ierr = PetscOptionsView(NULL,viewer);CHKERRQ(ierr);\n      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);\n    }\n    ierr = PetscOptionsAllUsed(NULL,&nopt);CHKERRQ(ierr);\n    if (nopt) {\n      ierr = PetscPrintf(PETSC_COMM_WORLD,\"WARNING! There are options you set that were not used!\\n\");CHKERRQ(ierr);\n      ierr = PetscPrintf(PETSC_COMM_WORLD,\"WARNING! could be spelling mistake, etc!\\n\");CHKERRQ(ierr);\n      if (nopt == 1) {\n        ierr = PetscPrintf(PETSC_COMM_WORLD,\"There is one unused database option. It is:\\n\");CHKERRQ(ierr);\n      } else {\n        ierr = PetscPrintf(PETSC_COMM_WORLD,\"There are %D unused database options. They are:\\n\",nopt);CHKERRQ(ierr);\n      }\n    } else if (flg3 && flg1) {\n      ierr = PetscPrintf(PETSC_COMM_WORLD,\"There are no unused options.\\n\");CHKERRQ(ierr);\n    }\n    ierr = PetscOptionsLeft(NULL);CHKERRQ(ierr);\n  }\n\n#if defined(PETSC_HAVE_SAWS)\n  if (!PetscGlobalRank) {\n    ierr = PetscStackSAWsViewOff();CHKERRQ(ierr);\n    PetscStackCallSAWs(SAWs_Finalize,());\n  }\n#endif\n\n#if defined(PETSC_USE_LOG)\n  /*\n       List all objects the user may have forgot to free\n  */\n  if (PetscObjectsLog) {\n    ierr = PetscOptionsHasName(NULL,NULL,\"-objects_dump\",&flg1);CHKERRQ(ierr);\n    if (flg1) {\n      MPI_Comm local_comm;\n      char     string[64];\n\n      ierr = PetscOptionsGetString(NULL,NULL,\"-objects_dump\",string,sizeof(string),NULL);CHKERRQ(ierr);\n      ierr = MPI_Comm_dup(MPI_COMM_WORLD,&local_comm);CHKERRMPI(ierr);\n      ierr = PetscSequentialPhaseBegin_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = PetscObjectsDump(stdout,(string[0] == 'a') ? PETSC_TRUE : PETSC_FALSE);CHKERRQ(ierr);\n      ierr = PetscSequentialPhaseEnd_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = MPI_Comm_free(&local_comm);CHKERRMPI(ierr);\n    }\n  }\n#endif\n\n#if defined(PETSC_USE_LOG)\n  PetscObjectsCounts    = 0;\n  PetscObjectsMaxCounts = 0;\n  ierr = PetscFree(PetscObjects);CHKERRQ(ierr);\n#endif\n\n  /*\n     Destroy any packages that registered a finalize\n  */\n  ierr = PetscRegisterFinalizeAll();CHKERRQ(ierr);\n\n#if defined(PETSC_USE_LOG)\n  ierr = PetscLogFinalize();CHKERRQ(ierr);\n#endif\n\n  /*\n     Print PetscFunctionLists that have not been properly freed\n\n  ierr = PetscFunctionListPrintAll();CHKERRQ(ierr);\n  */\n\n  if (petsc_history) {\n    ierr = PetscCloseHistoryFile(&petsc_history);CHKERRQ(ierr);\n    petsc_history = NULL;\n  }\n  ierr = PetscOptionsHelpPrintedDestroy(&PetscOptionsHelpPrintedSingleton);CHKERRQ(ierr);\n  ierr = PetscInfoDestroy();CHKERRQ(ierr);\n\n#if !defined(PETSC_HAVE_THREADSAFETY)\n  if (!(PETSC_RUNNING_ON_VALGRIND)) {\n    char fname[PETSC_MAX_PATH_LEN];\n    char sname[PETSC_MAX_PATH_LEN];\n    FILE *fd;\n    int  err;\n\n    flg2 = PETSC_FALSE;\n    flg3 = PETSC_FALSE;\n    if (PetscDefined(USE_DEBUG)) {ierr = PetscOptionsGetBool(NULL,NULL,\"-malloc_test\",&flg2,NULL);CHKERRQ(ierr);}\n    ierr = PetscOptionsGetBool(NULL,NULL,\"-malloc_debug\",&flg3,NULL);CHKERRQ(ierr);\n    fname[0] = 0;\n    ierr = PetscOptionsGetString(NULL,NULL,\"-malloc_dump\",fname,sizeof(fname),&flg1);CHKERRQ(ierr);\n    if (flg1 && fname[0]) {\n\n      PetscSNPrintf(sname,sizeof(sname),\"%s_%d\",fname,rank);\n      fd   = fopen(sname,\"w\"); if (!fd) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Cannot open log file: %s\",sname);\n      ierr = PetscMallocDump(fd);CHKERRQ(ierr);\n      err  = fclose(fd);\n      if (err) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SYS,\"fclose() failed on file\");\n    } else if (flg1 || flg2 || flg3) {\n      MPI_Comm local_comm;\n\n      ierr = MPI_Comm_dup(MPI_COMM_WORLD,&local_comm);CHKERRMPI(ierr);\n      ierr = PetscSequentialPhaseBegin_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = PetscMallocDump(stdout);CHKERRQ(ierr);\n      ierr = PetscSequentialPhaseEnd_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = MPI_Comm_free(&local_comm);CHKERRMPI(ierr);\n    }\n    fname[0] = 0;\n    ierr = PetscOptionsGetString(NULL,NULL,\"-malloc_view\",fname,sizeof(fname),&flg1);CHKERRQ(ierr);\n    if (flg1 && fname[0]) {\n\n      PetscSNPrintf(sname,sizeof(sname),\"%s_%d\",fname,rank);\n      fd   = fopen(sname,\"w\"); if (!fd) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Cannot open log file: %s\",sname);\n      ierr = PetscMallocView(fd);CHKERRQ(ierr);\n      err  = fclose(fd);\n      if (err) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SYS,\"fclose() failed on file\");\n    } else if (flg1) {\n      MPI_Comm local_comm;\n\n      ierr = MPI_Comm_dup(MPI_COMM_WORLD,&local_comm);CHKERRMPI(ierr);\n      ierr = PetscSequentialPhaseBegin_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = PetscMallocView(stdout);CHKERRQ(ierr);\n      ierr = PetscSequentialPhaseEnd_Private(local_comm,1);CHKERRQ(ierr);\n      ierr = MPI_Comm_free(&local_comm);CHKERRMPI(ierr);\n    }\n  }\n#endif\n\n  /*\n     Close any open dynamic libraries\n  */\n  ierr = PetscFinalize_DynamicLibraries();CHKERRQ(ierr);\n\n  /* Can be destroyed only after all the options are used */\n  ierr = PetscOptionsDestroyDefault();CHKERRQ(ierr);\n\n  PetscGlobalArgc = 0;\n  PetscGlobalArgs = NULL;\n\n#if defined(PETSC_HAVE_KOKKOS)\n  if (PetscBeganKokkos) {\n    ierr = PetscKokkosFinalize_Private();CHKERRQ(ierr);\n    PetscBeganKokkos = PETSC_FALSE;\n    PetscKokkosInitialized = PETSC_FALSE;\n  }\n#endif\n\n  ierr = PetscFreeMPIResources();CHKERRQ(ierr);\n\n  /*\n     Destroy any known inner MPI_Comm's and attributes pointing to them\n     Note this will not destroy any new communicators the user has created.\n\n     If all PETSc objects were not destroyed those left over objects will have hanging references to\n     the MPI_Comms that were freed; but that is ok because those PETSc objects will never be used again\n */\n  {\n    PetscCommCounter *counter;\n    PetscMPIInt      flg;\n    MPI_Comm         icomm;\n    union {MPI_Comm comm; void *ptr;} ucomm;\n    ierr = MPI_Comm_get_attr(PETSC_COMM_SELF,Petsc_InnerComm_keyval,&ucomm,&flg);CHKERRMPI(ierr);\n    if (flg) {\n      icomm = ucomm.comm;\n      ierr = MPI_Comm_get_attr(icomm,Petsc_Counter_keyval,&counter,&flg);CHKERRMPI(ierr);\n      if (!flg) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_CORRUPT,\"Inner MPI_Comm does not have expected tag/name counter, problem with corrupted memory\");\n\n      ierr = MPI_Comm_delete_attr(PETSC_COMM_SELF,Petsc_InnerComm_keyval);CHKERRMPI(ierr);\n      ierr = MPI_Comm_delete_attr(icomm,Petsc_Counter_keyval);CHKERRMPI(ierr);\n      ierr = MPI_Comm_free(&icomm);CHKERRMPI(ierr);\n    }\n    ierr = MPI_Comm_get_attr(PETSC_COMM_WORLD,Petsc_InnerComm_keyval,&ucomm,&flg);CHKERRMPI(ierr);\n    if (flg) {\n      icomm = ucomm.comm;\n      ierr = MPI_Comm_get_attr(icomm,Petsc_Counter_keyval,&counter,&flg);CHKERRMPI(ierr);\n      if (!flg) SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_ARG_CORRUPT,\"Inner MPI_Comm does not have expected tag/name counter, problem with corrupted memory\");\n\n      ierr = MPI_Comm_delete_attr(PETSC_COMM_WORLD,Petsc_InnerComm_keyval);CHKERRMPI(ierr);\n      ierr = MPI_Comm_delete_attr(icomm,Petsc_Counter_keyval);CHKERRMPI(ierr);\n      ierr = MPI_Comm_free(&icomm);CHKERRMPI(ierr);\n    }\n  }\n\n  ierr = MPI_Comm_free_keyval(&Petsc_Counter_keyval);CHKERRMPI(ierr);\n  ierr = MPI_Comm_free_keyval(&Petsc_InnerComm_keyval);CHKERRMPI(ierr);\n  ierr = MPI_Comm_free_keyval(&Petsc_OuterComm_keyval);CHKERRMPI(ierr);\n  ierr = MPI_Comm_free_keyval(&Petsc_ShmComm_keyval);CHKERRMPI(ierr);\n\n  ierr = PetscSpinlockDestroy(&PetscViewerASCIISpinLockOpen);CHKERRQ(ierr);\n  ierr = PetscSpinlockDestroy(&PetscViewerASCIISpinLockStdout);CHKERRQ(ierr);\n  ierr = PetscSpinlockDestroy(&PetscViewerASCIISpinLockStderr);CHKERRQ(ierr);\n  ierr = PetscSpinlockDestroy(&PetscCommSpinLock);CHKERRQ(ierr);\n\n  if (PetscBeganMPI) {\n#if defined(PETSC_HAVE_MPI_FINALIZED)\n    PetscMPIInt flag;\n    ierr = MPI_Finalized(&flag);CHKERRMPI(ierr);\n    if (flag) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_LIB,\"MPI_Finalize() has already been called, even though MPI_Init() was called by PetscInitialize()\");\n#endif\n    ierr = MPI_Finalize();CHKERRMPI(ierr);\n  }\n/*\n\n     Note: In certain cases PETSC_COMM_WORLD is never MPI_Comm_free()ed because\n   the communicator has some outstanding requests on it. Specifically if the\n   flag PETSC_HAVE_BROKEN_REQUEST_FREE is set (for IBM MPI implementation). See\n   src/vec/utils/vpscat.c. Due to this the memory allocated in PetscCommDuplicate()\n   is never freed as it should be. Thus one may obtain messages of the form\n   [ 1] 8 bytes PetscCommDuplicate() line 645 in src/sys/mpiu.c indicating the\n   memory was not freed.\n\n*/\n  ierr = PetscMallocClear();CHKERRQ(ierr);\n\n  PetscErrorHandlingInitialized = PETSC_FALSE;\n  PetscInitializeCalled = PETSC_FALSE;\n  PetscFinalizeCalled   = PETSC_TRUE;\n#if defined(PETSC_USE_GCOV)\n  /*\n     flush gcov, otherwise during CI the flushing continues into the next pipeline resulting in git not being able to delete directories since the\n     gcov files are still being added to the directories as git tries to remove the directories.\n   */\n  __gcov_flush();\n#endif\n  PetscFunctionReturn(0);\n}\n\n#if defined(PETSC_MISSING_LAPACK_lsame_)\nPETSC_EXTERN int lsame_(char *a,char *b)\n{\n  if (*a == *b) return 1;\n  if (*a + 32 == *b) return 1;\n  if (*a - 32 == *b) return 1;\n  return 0;\n}\n#endif\n\n#if defined(PETSC_MISSING_LAPACK_lsame)\nPETSC_EXTERN int lsame(char *a,char *b)\n{\n  if (*a == *b) return 1;\n  if (*a + 32 == *b) return 1;\n  if (*a - 32 == *b) return 1;\n  return 0;\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/sys/dll/dlimpl.c": "\n/*\n   Low-level routines for managing dynamic link libraries (DLLs).\n*/\n\n#include <petsc/private/petscimpl.h>\n#include <petscvalgrind.h>\n\n/* XXX Should be done better !!!*/\n#if !defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n#undef PETSC_HAVE_WINDOWS_H\n#undef PETSC_HAVE_DLFCN_H\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\n#include <windows.h>\n#elif defined(PETSC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\n#if defined(PETSC_HAVE_WINDOWS_H)\ntypedef HMODULE dlhandle_t;\ntypedef FARPROC dlsymbol_t;\n#elif defined(PETSC_HAVE_DLFCN_H)\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#else\ntypedef void* dlhandle_t;\ntypedef void* dlsymbol_t;\n#endif\n\n/*@C\n   PetscDLOpen - opens dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+    name - name of library\n-    mode - options on how to open library\n\n   Output Parameter:\n.    handle\n\n   Level: developer\n\n@*/\nPetscErrorCode  PetscDLOpen(const char name[],PetscDLMode mode,PetscDLHandle *handle)\n{\n  PETSC_UNUSED int dlflags1,dlflags2; /* There are some preprocessor paths where these variables are set, but not used */\n  dlhandle_t       dlhandle;\n\n  PetscFunctionBegin;\n  PetscValidCharPointer(name,1);\n  PetscValidPointer(handle,3);\n\n  dlflags1 = 0;\n  dlflags2 = 0;\n  dlhandle = (dlhandle_t) 0;\n  *handle  = (PetscDLHandle) 0;\n\n  /*\n     --- LoadLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H) && defined(PETSC_HAVE_LOADLIBRARY)\n  dlhandle = LoadLibrary(name);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    PetscErrorCode ierr;\n    DWORD          erc;\n    char           *buff = NULL;\n    erc = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    ierr = PetscError(PETSC_COMM_SELF,__LINE__,PETSC_FUNCTION_NAME,__FILE__,PETSC_ERR_FILE_OPEN,PETSC_ERROR_REPEAT,\n                      \"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,buff);\n    LocalFree(buff);\n    PetscFunctionReturn(ierr);\n#else\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from LoadLibrary() %s\\n\",name,\"unavailable\");\n#endif\n  }\n\n  /*\n     --- dlopen ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H) && defined(PETSC_HAVE_DLOPEN)\n  /*\n      Mode indicates symbols required by symbol loaded with dlsym()\n     are only loaded when required (not all together) also indicates\n     symbols required can be contained in other libraries also opened\n     with dlopen()\n  */\n#if defined(PETSC_HAVE_RTLD_LAZY)\n  dlflags1 = RTLD_LAZY;\n#endif\n#if defined(PETSC_HAVE_RTLD_NOW)\n  if (mode & PETSC_DL_NOW) dlflags1 = RTLD_NOW;\n#endif\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n  dlflags2 = RTLD_GLOBAL;\n#endif\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n  if (mode & PETSC_DL_LOCAL) dlflags2 = RTLD_LOCAL;\n#endif\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlhandle = dlopen(name,dlflags1|dlflags2);\n  if (!dlhandle) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,\"Unable to open dynamic library:\\n  %s\\n  Error message from dlopen() %s\\n\",name,errmsg);\n  }\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = (PetscDLHandle) dlhandle;\n  PetscFunctionReturn(0);\n}\n\n\n/*@C\n   PetscDLClose -  closes a dynamic library\n\n   Not Collective\n\n  Input Parameter:\n.   handle - the handle for the library obtained with PetscDLOpen()\n\n  Level: developer\n@*/\nPetscErrorCode  PetscDLClose(PetscDLHandle *handle)\n{\n\n  PetscFunctionBegin;\n  PetscValidPointer(handle,1);\n\n  /*\n     --- FreeLibrary ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_FREELIBRARY)\n  if (FreeLibrary((dlhandle_t)*handle) == 0) {\n#if defined(PETSC_HAVE_GETLASTERROR)\n    char  *buff = NULL;\n    DWORD erc   = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,NULL,erc,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(LPSTR)&buff,0,NULL);\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",buff);\n    LocalFree(buff);\n#else\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from FreeLibrary() %s\\n\",\"unavailable\");\n#endif\n  }\n#endif /* !PETSC_HAVE_FREELIBRARY */\n\n  /*\n     --- dclose ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLCLOSE)\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  if (dlclose((dlhandle_t)*handle) < 0) {\n#if defined(PETSC_HAVE_DLERROR)\n    const char *errmsg = dlerror();\n#else\n    const char *errmsg = \"unavailable\";\n#endif\n    PetscErrorPrintf(\"Error closing dynamic library:\\n  Error message from dlclose() %s\\n\", errmsg);\n  }\n#endif /* !PETSC_HAVE_DLCLOSE */\n\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *handle = NULL;\n  PetscFunctionReturn(0);\n}\n\n/*@C\n   PetscDLSym - finds a symbol in a dynamic library\n\n   Not Collective\n\n   Input Parameters:\n+   handle - obtained with PetscDLOpen() or NULL\n-   symbol - name of symbol\n\n   Output Parameter:\n.   value - pointer to the function, NULL if not found\n\n   Level: developer\n\n  Notes:\n   If handle is NULL, the symbol is looked for in the main executable's dynamic symbol table.\n   In order to be dynamically loadable, the symbol has to be exported as such.  On many UNIX-like\n   systems this requires platform-specific linker flags.\n\n@*/\nPetscErrorCode  PetscDLSym(PetscDLHandle handle,const char symbol[],void **value)\n{\n  PETSC_UNUSED dlhandle_t dlhandle;\n  dlsymbol_t              dlsymbol;\n\n  PetscValidCharPointer(symbol,2);\n  PetscValidPointer(value,3);\n\n  dlhandle = (dlhandle_t) 0;\n  dlsymbol = (dlsymbol_t) 0;\n  *value   = (void*) 0;\n\n  /*\n     --- GetProcAddress ---\n  */\n#if defined(PETSC_HAVE_WINDOWS_H)\n#if defined(PETSC_HAVE_GETPROCADDRESS)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else dlhandle = (dlhandle_t) GetCurrentProcess();\n  dlsymbol = (dlsymbol_t) GetProcAddress(dlhandle,symbol);\n#if defined(PETSC_HAVE_SETLASTERROR)\n  SetLastError((DWORD)0); /* clear any previous error */\n#endif\n#endif /* !PETSC_HAVE_GETPROCADDRESS */\n\n  /*\n     --- dlsym ---\n  */\n#elif defined(PETSC_HAVE_DLFCN_H)\n#if defined(PETSC_HAVE_DLSYM)\n  if (handle) dlhandle = (dlhandle_t) handle;\n  else {\n\n#if defined(PETSC_HAVE_DLOPEN) && defined(PETSC_HAVE_DYNAMIC_LIBRARIES)\n    /* Attempt to retrieve the main executable's dlhandle. */\n    { int dlflags1 = 0, dlflags2 = 0;\n#if defined(PETSC_HAVE_RTLD_LAZY)\n      dlflags1 = RTLD_LAZY;\n#endif\n      if (!dlflags1) {\n#if defined(PETSC_HAVE_RTLD_NOW)\n        dlflags1 = RTLD_NOW;\n#endif\n      }\n#if defined(PETSC_HAVE_RTLD_LOCAL)\n      dlflags2 = RTLD_LOCAL;\n#endif\n      if (!dlflags2) {\n#if defined(PETSC_HAVE_RTLD_GLOBAL)\n        dlflags2 = RTLD_GLOBAL;\n#endif\n      }\n#if defined(PETSC_HAVE_DLERROR)\n      if (!(PETSC_RUNNING_ON_VALGRIND)) {\n        dlerror(); /* clear any previous error; valgrind does not like this */\n      }\n#endif\n      /* Attempt to open the main executable as a dynamic library. */\n#if defined(PETSC_HAVE_RTDL_DEFAULT)\n      dlhandle = RTLD_DEFAULT;\n#else\n      dlhandle = dlopen(NULL, dlflags1|dlflags2);\n#if defined(PETSC_HAVE_DLERROR)\n      { const char *e = (const char*) dlerror();\n        if (e) SETERRQ1(PETSC_COMM_SELF, PETSC_ERR_ARG_WRONG, \"Error opening main executable as a dynamic library:\\n  Error message from dlopen(): '%s'\\n\", e);\n      }\n#endif\n#endif\n    }\n#endif\n#endif /* PETSC_HAVE_DLOPEN && PETSC_HAVE_DYNAMIC_LIBRARIES */\n  }\n#if defined(PETSC_HAVE_DLERROR)\n  dlerror(); /* clear any previous error */\n#endif\n  dlsymbol = (dlsymbol_t) dlsym(dlhandle,symbol);\n  /*\n     --- unimplemented ---\n  */\n#else\n  SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP_SYS, \"Cannot use dynamic libraries on this platform\");\n#endif\n\n  *value = *((void**)&dlsymbol);\n\n#if defined(PETSC_SERIALIZE_FUNCTIONS)\n  if (*value) {\n    PetscErrorCode ierr;\n    ierr = PetscFPTAdd(*value,symbol);CHKERRQ(ierr);\n  }\n#endif\n  return(0);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/binding/petsc4py/src/include/compat/mpi.h": "#ifndef PETSC4PY_COMPAT_MPI_H\n#define PETSC4PY_COMPAT_MPI_H\n\n#if defined(OPEN_MPI)\n\n/*\n * The hackery below redefines the actuall calls to 'MPI_Init()' and\n * 'MPI_Init_thread()' in order to preload the main MPI dynamic\n * library with appropriate flags to 'dlopen()' ensuring global\n * availability of library symbols.\n */\n\n#if !defined(OPENMPI_DLOPEN_LIBMPI) && defined(OMPI_MAJOR_VERSION)\n#if OMPI_MAJOR_VERSION >= 3 && OMPI_MAJOR_VERSION < 10\n#define OPENMPI_DLOPEN_LIBMPI 0\n#endif\n#endif\n\n#ifndef OPENMPI_DLOPEN_LIBMPI\n#define OPENMPI_DLOPEN_LIBMPI 1\n#endif\n\n#if OPENMPI_DLOPEN_LIBMPI\n#if HAVE_DLOPEN\n\n#if HAVE_DLFCN_H\n  #include <dlfcn.h>\n#else\n  #if defined(__linux__)\n    #define RTLD_LAZY     0x00001\n    #define RTLD_NOW      0x00002\n    #define RTLD_LOCAL    0x00000\n    #define RTLD_GLOBAL   0x00100\n    #define RTLD_NOLOAD   0x00004\n    #define RTLD_NODELETE 0x01000\n    #define RTLD_DEEPBIND 0x00008\n  #elif defined(__APPLE__)\n    #define RTLD_LAZY     0x1\n    #define RTLD_NOW      0x2\n    #define RTLD_LOCAL    0x4\n    #define RTLD_GLOBAL   0x8\n    #define RTLD_NOLOAD   0x10\n    #define RTLD_NODELETE 0x80\n    #define RTLD_FIRST    0x100\n  #elif defined(__CYGWIN__)\n    #define RTLD_LAZY     1\n    #define RTLD_NOW      2\n    #define RTLD_LOCAL    0\n    #define RTLD_GLOBAL   4\n  #endif\n  #if defined(__cplusplus) || defined(c_plusplus)\n  extern \"C\" {\n  #endif\n  extern void *dlopen(const char *, int);\n  extern void *dlsym(void *, const char *);\n  extern int   dlclose(void *);\n  extern char *dlerror(void);\n  #if defined(__cplusplus) || defined(c_plusplus)\n  }\n  #endif\n#endif\n\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL RTLD_LOCAL\n#endif\n\n/*\nstatic void * my_dlopen(const char *name, int mode) {\n  void *handle;\n  static int called = 0;\n  if (!called) {\n    called = 1;\n    #if HAVE_DLFCN_H\n    printf(\"HAVE_DLFCN_H: yes\\n\");\n    #else\n    printf(\"HAVE_DLFCN_H: no\\n\");\n    #endif\n    printf(\"\\n\");\n    printf(\"RTLD_LAZY:    0x%X\\n\", RTLD_LAZY);\n    printf(\"RTLD_NOW:     0x%X\\n\", RTLD_NOW);\n    printf(\"RTLD_LOCAL:   0x%X\\n\", RTLD_LOCAL);\n    printf(\"RTLD_GLOBAL:  0x%X\\n\", RTLD_GLOBAL);\n    #ifdef RTLD_NOLOAD\n    printf(\"RTLD_NOLOAD:  0x%X\\n\", RTLD_NOLOAD);\n    #endif\n    printf(\"\\n\");\n  }\n  handle = dlopen(name, mode);\n  printf(\"dlopen(\\\"%s\\\",0x%X) -> %p\\n\", name, mode, handle);\n  printf(\"dlerror() -> %s\\n\\n\", dlerror());\n  return handle;\n}\n#define dlopen my_dlopen\n*/\n\nstatic void OPENMPI_dlopen_libmpi(void)\n{\n  void *handle = 0;\n  int mode = RTLD_NOW | RTLD_GLOBAL;\n#if defined(__APPLE__)\n  /* macOS */\n  #ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n  #endif\n  #if defined(OMPI_MAJOR_VERSION)\n  #if OMPI_MAJOR_VERSION == 3\n  if (!handle) handle = dlopen(\"libmpi.40.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 2\n  if (!handle) handle = dlopen(\"libmpi.20.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 10\n  if (!handle) handle = dlopen(\"libmpi.12.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 6\n  if (!handle) handle = dlopen(\"libmpi.1.dylib\", mode);\n  #elif OMPI_MAJOR_VERSION == 1\n  if (!handle) handle = dlopen(\"libmpi.0.dylib\", mode);\n  #endif\n  #endif\n  if (!handle) handle = dlopen(\"libmpi.dylib\", mode);\n#else\n  /* GNU/Linux and others */\n  #ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n  #endif\n  #if defined(OMPI_MAJOR_VERSION)\n  #if OMPI_MAJOR_VERSION >= 10 /* IBM Spectrum MPI */\n  if (!handle) handle = dlopen(\"libmpi_ibm.so.2\", mode);\n  if (!handle) handle = dlopen(\"libmpi_ibm.so.1\", mode);\n  if (!handle) handle = dlopen(\"libmpi_ibm.so\", mode);\n  #elif OMPI_MAJOR_VERSION == 3\n  if (!handle) handle = dlopen(\"libmpi.so.40\", mode);\n  #elif OMPI_MAJOR_VERSION == 2\n  if (!handle) handle = dlopen(\"libmpi.so.20\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 10\n  if (!handle) handle = dlopen(\"libmpi.so.12\", mode);\n  #elif OMPI_MAJOR_VERSION == 1 && OMPI_MINOR_VERSION >= 6\n  if (!handle) handle = dlopen(\"libmpi.so.1\", mode);\n  #elif OMPI_MAJOR_VERSION == 1\n  if (!handle) handle = dlopen(\"libmpi.so.0\", mode);\n  #endif\n  #endif\n  if (!handle) handle = dlopen(\"libmpi.so\", mode);\n#endif\n}\n\nstatic PetscErrorCode PetscInitialize_OpenMPI(int *argc,char ***args,\n                                              const char file[],\n                                              const char help[])\n{\n  OPENMPI_dlopen_libmpi();\n  return PetscInitialize(argc,args,file,help);\n}\n#undef  PetscInitialize\n#define PetscInitialize PetscInitialize_OpenMPI\n\n#endif /* HAVE_DLOPEN */\n#endif /* OPENMPI_DLOPEN_LIBMPI */\n\n#endif /* OPEN_MPI */\n\n#endif/*PETSC4PY_COMPAT_MPI_H*/\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/config/PETSc/Configure.py": "import config.base\n\nimport os\nimport sys\nimport re\nimport pickle\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = 'PETSC'\n    self.substPrefix  = 'PETSC'\n    self.installed = 0 # 1 indicates that Configure itself has already compiled and installed PETSc\n    return\n\n  def __str2__(self):\n    desc = ['  Using GNU make: ' + self.make.make]\n    if not self.installed:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Configure stage complete. Now build PETSc libraries with:')\n      desc.append('   %s PETSC_DIR=%s PETSC_ARCH=%s all' % (self.make.make_user, self.petscdir.dir, self.arch.arch))\n      desc.append('xxx=========================================================================xxx')\n    else:\n      desc.append('xxx=========================================================================xxx')\n      desc.append(' Installation complete. You do not need to run make to compile or install the software')\n      desc.append('xxx=========================================================================xxx')\n    return '\\n'.join(desc)+'\\n'\n\n  def setupHelp(self, help):\n    import nargs\n    help.addArgument('PETSc',  '-prefix=<dir>',                   nargs.Arg(None, '', 'Specifiy location to install PETSc (eg. /usr/local)'))\n    help.addArgument('PETSc',  '-with-prefetch=<bool>',           nargs.ArgBool(None, 1,'Enable checking for prefetch instructions'))\n    help.addArgument('Windows','-with-windows-graphics=<bool>',   nargs.ArgBool(None, 1,'Enable check for Windows Graphics'))\n    help.addArgument('PETSc', '-with-default-arch=<bool>',        nargs.ArgBool(None, 1, 'Allow using the last configured arch without setting PETSC_ARCH'))\n    help.addArgument('PETSc','-with-single-library=<bool>',       nargs.ArgBool(None, 1,'Put all PETSc code into the single -lpetsc library'))\n    help.addArgument('PETSc','-with-fortran-bindings=<bool>',     nargs.ArgBool(None, 1,'Build PETSc fortran bindings in the library and corresponding module files'))\n    help.addArgument('PETSc', '-with-ios=<bool>',              nargs.ArgBool(None, 0, 'Build an iPhone/iPad version of PETSc library'))\n    help.addArgument('PETSc', '-with-xsdk-defaults', nargs.ArgBool(None, 0, 'Set the following as defaults for the xSDK standard: --enable-debug=1, --enable-shared=1, --with-precision=double, --with-index-size=32, locate blas/lapack automatically'))\n    help.addArgument('PETSc', '-with-display=<x11display>',       nargs.Arg(None, '', 'Specifiy DISPLAY env variable for use with matlab test)'))\n    help.addArgument('PETSc', '-with-package-scripts=<pyscripts>',nargs.ArgFileList(None,None,'Specify configure package scripts for user provided packages'))\n    return\n\n  def registerPythonFile(self,filename,directory):\n    ''' Add a python file to the framework and registers its headerprefix, ... externalpackagedir\n        directory is the directory where the file relative to the BuildSystem or config path in python notation with . '''\n    (utilityName, ext) = os.path.splitext(filename)\n    if not utilityName.startswith('.') and not utilityName.startswith('#') and ext == '.py' and not utilityName == '__init__':\n      if directory: directory = directory+'.'\n      utilityObj                             = self.framework.require(directory+utilityName, self)\n      utilityObj.headerPrefix                = self.headerPrefix\n      utilityObj.archProvider                = self.arch\n      utilityObj.languageProvider            = self.languages\n      utilityObj.installDirProvider          = self.installdir\n      utilityObj.externalPackagesDirProvider = self.externalpackagesdir\n      utilityObj.precisionProvider           = self.scalartypes\n      utilityObj.indexProvider               = self.indexTypes\n      setattr(self, utilityName.lower(), utilityObj)\n      return utilityObj\n    return None\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.programs      = framework.require('config.programs',           self)\n    self.setCompilers  = framework.require('config.setCompilers',       self)\n    self.compilers     = framework.require('config.compilers',          self)\n    self.arch          = framework.require('PETSc.options.arch',        self.setCompilers)\n    self.petscdir      = framework.require('PETSc.options.petscdir',    self.arch)\n    self.installdir    = framework.require('PETSc.options.installDir',  self)\n    self.dataFilesPath = framework.require('PETSc.options.dataFilesPath',self)\n    self.scalartypes   = framework.require('PETSc.options.scalarTypes', self)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self)\n    self.languages     = framework.require('PETSc.options.languages',   self.setCompilers)\n    self.indexTypes    = framework.require('PETSc.options.indexTypes',  self.compilers)\n    self.types         = framework.require('config.types',              self)\n    self.headers       = framework.require('config.headers',            self)\n    self.functions     = framework.require('config.functions',          self)\n    self.libraries     = framework.require('config.libraries',          self)\n    self.atomics       = framework.require('config.atomics',            self)\n    self.make          = framework.require('config.packages.make',      self)\n    self.blasLapack    = framework.require('config.packages.BlasLapack',self)\n    self.mpi           = framework.require('config.packages.MPI',       self)\n    self.fortran       = framework.require('config.compilersFortran',   self)\n    self.externalpackagesdir = framework.require('PETSc.options.externalpackagesdir',self)\n\n    for utility in sorted(os.listdir(os.path.join('config','PETSc','options'))):\n      self.registerPythonFile(utility,'PETSc.options')\n\n    for utility in sorted(os.listdir(os.path.join('config','BuildSystem','config','utilities'))):\n      self.registerPythonFile(utility,'config.utilities')\n\n    for package in sorted(os.listdir(os.path.join('config', 'BuildSystem', 'config', 'packages'))):\n      obj = self.registerPythonFile(package,'config.packages')\n      if obj:\n        obj.archProvider                = self.framework.requireModule(obj.archProvider, obj)\n        obj.languageProvider            = self.framework.requireModule(obj.languageProvider, obj)\n        obj.installDirProvider          = self.framework.requireModule(obj.installDirProvider, obj)\n        obj.externalPackagesDirProvider = self.framework.requireModule(obj.externalPackagesDirProvider, obj)\n        obj.precisionProvider           = self.framework.requireModule(obj.precisionProvider, obj)\n        obj.indexProvider               = self.framework.requireModule(obj.indexProvider, obj)\n\n    # Force blaslapack and opencl to depend on scalarType so precision is set before BlasLapack is built\n    framework.require('PETSc.options.scalarTypes', self.f2cblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.fblaslapack)\n    framework.require('PETSc.options.scalarTypes', self.blaslapack)\n    framework.require('PETSc.options.scalarTypes', self.opencl)\n\n    self.programs.headerPrefix   = self.headerPrefix\n    self.compilers.headerPrefix  = self.headerPrefix\n    self.fortran.headerPrefix    = self.headerPrefix\n    self.types.headerPrefix      = self.headerPrefix\n    self.headers.headerPrefix    = self.headerPrefix\n    self.functions.headerPrefix  = self.headerPrefix\n    self.libraries.headerPrefix  = self.headerPrefix\n\n    # Register user provided package scripts\n    if 'with-package-scripts' in self.framework.argDB:\n      for script in self.framework.argDB['with-package-scripts']:\n        if os.path.splitext(script)[1] != '.py':\n          raise RuntimeError('Only python scripts compatible with configure package script format should be specified! Invalid option -with-package-scripts='+script)\n        self.framework.logPrint('User is registering a new package script: '+script)\n        dname,fname = os.path.split(script)\n        if dname: sys.path.append(dname)\n        self.registerPythonFile(fname,'')\n\n    # test for a variety of basic headers and functions\n    headersC = map(lambda name: name+'.h',['setjmp','dos','fcntl','float','io','malloc','pwd','strings',\n                                            'unistd','sys/sysinfo','machine/endian','sys/param','sys/procfs','sys/resource',\n                                            'sys/systeminfo','sys/times','sys/utsname',\n                                            'sys/socket','sys/wait','netinet/in','netdb','direct','time','Ws2tcpip','sys/types',\n                                            'WindowsX','float','ieeefp','stdint','pthread','inttypes','immintrin','zmmintrin'])\n    functions = ['access','_access','clock','drand48','getcwd','_getcwd','getdomainname','gethostname',\n                 'getwd','memalign','popen','PXFGETARG','rand','getpagesize',\n                 'readlink','realpath','usleep','sleep','_sleep',\n                 'uname','snprintf','_snprintf','lseek','_lseek','time','fork','stricmp',\n                 'strcasecmp','bzero','dlopen','dlsym','dlclose','dlerror',\n                 '_set_output_format','_mkdir','socket','gethostbyname','_pipe','fpresetsticky','fpsetsticky']\n    libraries = [(['fpe'],'handle_sigfpes')]\n    librariessock = [(['socket','nsl'],'socket')]\n    self.headers.headers.extend(headersC)\n    self.functions.functions.extend(functions)\n    self.libraries.libraries.extend(libraries)\n    if not hasattr(self,'socket'):\n      self.libraries.libraries.extend(librariessock)\n    return\n\n  def DumpPkgconfig(self, petsc_pc):\n    ''' Create a pkg-config file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig'))\n    with open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','pkgconfig',petsc_pc),'w') as fd:\n      cflags_inc = ['-I${includedir}']\n      if self.framework.argDB['prefix']:\n        fd.write('prefix='+self.installdir.dir+'\\n')\n      else:\n        fd.write('prefix='+os.path.join(self.petscdir.dir, self.arch.arch)+'\\n')\n        cflags_inc.append('-I' + os.path.join(self.petscdir.dir, 'include'))\n      fd.write('exec_prefix=${prefix}\\n')\n      fd.write('includedir=${prefix}/include\\n')\n      fd.write('libdir=${prefix}/lib\\n')\n\n      with self.setCompilers.Language('C'):\n        fd.write('ccompiler='+self.setCompilers.getCompiler()+'\\n')\n        fd.write('cflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n        fd.write('cflags_dep='+self.compilers.dependenciesGenerationFlag.get('C','')+'\\n')\n        fd.write('ldflag_rpath='+self.setCompilers.CSharedLinkerFlag+'\\n')\n      if hasattr(self.compilers, 'CXX'):\n        with self.setCompilers.Language('C++'):\n          fd.write('cxxcompiler='+self.setCompilers.getCompiler()+'\\n')\n          fd.write('cxxflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      if hasattr(self.compilers, 'FC'):\n        with self.setCompilers.Language('FC'):\n          fd.write('fcompiler='+self.setCompilers.getCompiler()+'\\n')\n          fd.write('fflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n      if hasattr(self.compilers, 'CUDAC'):\n        with self.setCompilers.Language('CUDA'):\n          fd.write('cudacompiler='+self.setCompilers.getCompiler()+'\\n')\n          fd.write('cudaflags_extra='+self.setCompilers.getCompilerFlags().strip()+'\\n')\n          p = self.framework.require('config.packages.cuda')\n          fd.write('cudalib='+self.libraries.toStringNoDupes(p.lib)+'\\n')\n          fd.write('cudainclude='+self.headers.toStringNoDupes(p.include)+'\\n')\n          if hasattr(self.setCompilers,'CUDA_CXX'):\n            fd.write('cuda_cxx='+self.setCompilers.CUDA_CXX+'\\n')\n            fd.write('cuda_cxxflags='+self.setCompilers.CUDA_CXXFLAGS+'\\n')\n\n      fd.write('\\n')\n      fd.write('Name: PETSc\\n')\n      fd.write('Description: Library to solve ODEs and algebraic equations\\n')\n      fd.write('Version: %s\\n' % self.petscdir.version)\n      fd.write('Cflags: ' + ' '.join([self.setCompilers.CPPFLAGS] + cflags_inc) + '\\n')\n      fd.write('Libs: '+self.libraries.toStringNoDupes(['-L${libdir}', self.petsclib], with_rpath=False)+'\\n')\n      # Remove RPATH flags from library list.  User can add them using\n      # pkg-config --variable=ldflag_rpath and pkg-config --libs-only-L\n      fd.write('Libs.private: '+self.libraries.toStringNoDupes([f for f in self.packagelibs+self.complibs if not f.startswith(self.setCompilers.CSharedLinkerFlag)], with_rpath=False)+'\\n')\n    return\n\n  def DumpModule(self):\n    ''' Create a module file '''\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules'))\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc'))\n    if self.framework.argDB['prefix']:\n      installdir  = self.installdir.dir\n      installarch = ''\n      installpath = os.path.join(installdir,'bin')\n    else:\n      installdir  = self.petscdir.dir\n      installarch = self.arch.arch\n      installpath = os.path.join(installdir,installarch,'bin')+':'+os.path.join(installdir,'bin')\n    fd = open(os.path.join(self.petscdir.dir,self.arch.arch,'lib','petsc','conf','modules','petsc',self.petscdir.version),'w')\n    fd.write('''\\\n#%%Module\n\nproc ModulesHelp { } {\n    puts stderr \"This module sets the path and environment variables for petsc-%s\"\n    puts stderr \"     see https://www.mcs.anl.gov/petsc/ for more information      \"\n    puts stderr \"\"\n}\nmodule-whatis \"PETSc - Portable, Extensible Toolkit for Scientific Computation\"\n\nset petsc_dir   \"%s\"\nset petsc_arch  \"%s\"\n\nsetenv PETSC_ARCH \"$petsc_arch\"\nsetenv PETSC_DIR \"$petsc_dir\"\nprepend-path PATH \"%s\"\n''' % (self.petscdir.version, installdir, installarch, installpath))\n    fd.close()\n    return\n\n  def Dump(self):\n    ''' Actually put the values into the configuration files '''\n    # eventually everything between -- should be gone\n    if self.mpi.usingMPIUni:\n      #\n      # Remove any MPI/MPICH include files that may have been put here by previous runs of ./configure\n      self.executeShellCommand('rm -rf  '+os.path.join(self.petscdir.dir,self.arch.arch,'include','mpi*')+' '+os.path.join(self.petscdir.dir,self.arch.arch,'include','opa*'), log = self.log)\n\n    self.logPrintDivider()\n    # Test for compiler-specific macros that need to be defined.\n    if self.setCompilers.isCrayVector('CC', self.log):\n      self.addDefine('HAVE_CRAY_VECTOR','1')\n\n    if self.functions.haveFunction('gethostbyname') and self.functions.haveFunction('socket') and self.headers.haveHeader('netinet/in.h'):\n      self.addDefine('USE_SOCKET_VIEWER','1')\n      if self.checkCompile('#include <sys/socket.h>','setsockopt(0,SOL_SOCKET,SO_REUSEADDR,0,0)'):\n        self.addDefine('HAVE_SO_REUSEADDR','1')\n\n    self.logPrintDivider()\n    self.setCompilers.pushLanguage('C')\n    compiler = self.setCompilers.getCompiler()\n    if compiler.endswith('mpicc') or compiler.endswith('mpiicc'):\n      try:\n        output   = self.executeShellCommand(compiler + ' -show', log = self.log)[0]\n        compiler = output.split(' ')[0]\n        self.addDefine('MPICC_SHOW','\"'+output.strip().replace('\\n','\\\\\\\\n')+'\"')\n      except:\n        self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    else:\n      self.addDefine('MPICC_SHOW','\"Unavailable\"')\n    self.setCompilers.popLanguage()\n#-----------------------------------------------------------------------------------------------------\n\n    # Sometimes we need C compiler, even if built with C++\n    self.setCompilers.pushLanguage('C')\n    self.addMakeMacro('CC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.setCompilers.popLanguage()\n\n    # And sometimes we need a C++ compiler even when PETSc is built with C\n    if hasattr(self.compilers, 'CXX'):\n      self.setCompilers.pushLanguage('Cxx')\n      self.addDefine('HAVE_CXX','1')\n      self.addMakeMacro('CXXPP_FLAGS',self.setCompilers.CXXPPFLAGS)\n      self.addMakeMacro('CXX_FLAGS',self.setCompilers.getCompilerFlags())\n      cxx_linker = self.setCompilers.getLinker()\n      self.addMakeMacro('CXX_LINKER',cxx_linker)\n      self.addMakeMacro('CXX_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      self.setCompilers.popLanguage()\n\n    # C preprocessor values\n    self.addMakeMacro('CPP_FLAGS',self.setCompilers.CPPFLAGS)\n\n    # compiler values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    self.addMakeMacro('PCC',self.setCompilers.getCompiler())\n    self.addMakeMacro('PCC_FLAGS',self.setCompilers.getCompilerFlags())\n    self.addMakeMacro('PCPP_FLAGS',getattr(self.setCompilers,self.languages.clanguage.upper()+'PPFLAGS'))\n    self.addMakeMacro('PFLAGS','${'+self.languages.clanguage.upper()+'FLAGS}')\n    self.addMakeMacro('PPPFLAGS','${'+self.languages.clanguage.upper()+'PPFLAGS}')\n    # ugly work-around for python3 distutils parse_makefile() issue with the above 2 lines\n    self.addMakeMacro('PY_'+self.languages.clanguage.upper()+'FLAGS','')\n    self.addMakeMacro('PY_'+self.languages.clanguage.upper()+'PPFLAGS','')\n    self.setCompilers.popLanguage()\n    # .o or .obj\n    self.addMakeMacro('CC_SUFFIX','o')\n\n    # executable linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    pcc_linker = self.setCompilers.getLinker()\n    self.addMakeMacro('PCC_LINKER',pcc_linker)\n    self.addMakeMacro('PCC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n    self.setCompilers.popLanguage()\n    # '' for Unix, .exe for Windows\n    self.addMakeMacro('CC_LINKER_SUFFIX','')\n\n    if hasattr(self.compilers, 'FC'):\n      if self.framework.argDB['with-fortran-bindings']:\n        if not self.fortran.fortranIsF90:\n          raise RuntimeError('Error! Fortran compiler \"'+self.compilers.FC+'\" does not support F90! PETSc fortran bindings require a F90 compiler')\n        self.addDefine('HAVE_FORTRAN','1')\n      self.setCompilers.pushLanguage('FC')\n      # need FPPFLAGS in config/setCompilers\n      self.addMakeMacro('FPP_FLAGS',self.setCompilers.FPPFLAGS)\n\n      # compiler values\n      self.addMakeMacro('FC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n      # .o or .obj\n      self.addMakeMacro('FC_SUFFIX','o')\n\n      # executable linker values\n      self.setCompilers.pushLanguage('FC')\n      self.addMakeMacro('FC_LINKER',self.setCompilers.getLinker())\n      self.addMakeMacro('FC_LINKER_FLAGS',self.setCompilers.getLinkerFlags())\n      # apple requires this shared library linker flag on SOME versions of the os\n      if self.setCompilers.getLinkerFlags().find('-Wl,-commons,use_dylibs') > -1:\n        self.addMakeMacro('DARWIN_COMMONS_USE_DYLIBS',' -Wl,-commons,use_dylibs ')\n      self.setCompilers.popLanguage()\n\n      # F90 Modules\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_FLAG', self.setCompilers.fortranModuleIncludeFlag)\n      else: # for non-f90 compilers like g77\n        self.addMakeMacro('FC_MODULE_FLAG', '-I')\n      if self.setCompilers.fortranModuleIncludeFlag:\n        self.addMakeMacro('FC_MODULE_OUTPUT_FLAG', self.setCompilers.fortranModuleOutputFlag)\n    else:\n      self.addMakeMacro('FC','')\n\n    if hasattr(self.compilers, 'CUDAC'):\n      self.setCompilers.pushLanguage('CUDA')\n      self.addMakeMacro('CUDAC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    if hasattr(self.compilers, 'HIPCC'):\n      self.setCompilers.pushLanguage('HIP')\n      self.addMakeMacro('HIPCC_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    if hasattr(self.compilers, 'SYCLCXX'):\n      self.setCompilers.pushLanguage('SYCL')\n      self.addMakeMacro('SYCLCXX_FLAGS',self.setCompilers.getCompilerFlags())\n      self.setCompilers.popLanguage()\n\n    # shared library linker values\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    # need to fix BuildSystem to collect these separately\n    self.addMakeMacro('SL_LINKER',self.setCompilers.getLinker())\n    self.addMakeMacro('SL_LINKER_FLAGS','${PCC_LINKER_FLAGS}')\n    self.setCompilers.popLanguage()\n    # One of 'a', 'so', 'lib', 'dll', 'dylib' (perhaps others also?) depending on the library generator and architecture\n    # Note: . is not included in this macro, consistent with AR_LIB_SUFFIX\n    if self.setCompilers.sharedLibraryExt == self.setCompilers.AR_LIB_SUFFIX:\n      self.addMakeMacro('SL_LINKER_SUFFIX', '')\n      self.addDefine('SLSUFFIX','\"\"')\n    else:\n      self.addMakeMacro('SL_LINKER_SUFFIX', self.setCompilers.sharedLibraryExt)\n      self.addDefine('SLSUFFIX','\"'+self.setCompilers.sharedLibraryExt+'\"')\n\n    self.addMakeMacro('SL_LINKER_LIBS','${PETSC_EXTERNAL_LIB_BASIC}')\n\n#-----------------------------------------------------------------------------------------------------\n\n    # CONLY or CPP. We should change the PETSc makefiles to do this better\n    if self.languages.clanguage == 'C': lang = 'CONLY'\n    else: lang = 'CXXONLY'\n    self.addMakeMacro('PETSC_LANGUAGE',lang)\n\n    # real or complex\n    self.addMakeMacro('PETSC_SCALAR',self.scalartypes.scalartype)\n    # double or float\n    self.addMakeMacro('PETSC_PRECISION',self.scalartypes.precision)\n\n    if self.framework.argDB['with-batch']:\n      self.addMakeMacro('PETSC_WITH_BATCH','1')\n\n#-----------------------------------------------------------------------------------------------------\n    # print include and lib for makefiles\n    self.logPrintDivider()\n    self.framework.packages.reverse()\n    petscincludes = [os.path.join(self.petscdir.dir,'include'),os.path.join(self.petscdir.dir,self.arch.arch,'include')]\n    petscincludes_install = [os.path.join(self.installdir.dir, 'include')] if self.framework.argDB['prefix'] else petscincludes\n    includes = []\n    self.packagelibs = []\n    for i in self.framework.packages:\n      if not i.required:\n        self.addDefine('HAVE_'+i.PACKAGE.replace('-','_'), 1)  # ONLY list package if it is used directly by PETSc (and not only by another package)\n      if not isinstance(i.lib, list):\n        i.lib = [i.lib]\n      if i.linkedbypetsc: self.packagelibs.extend(i.lib)\n      self.addMakeMacro(i.PACKAGE.replace('-','_')+'_LIB', self.libraries.toStringNoDupes(i.lib))\n      if hasattr(i,'include'):\n        if not isinstance(i.include,list):\n          i.include = [i.include]\n        includes.extend(i.include)\n        self.addMakeMacro(i.PACKAGE.replace('-','_')+'_INCLUDE',self.headers.toStringNoDupes(i.include))\n    if self.framework.argDB['with-single-library']:\n      self.petsclib = '-lpetsc'\n    else:\n      self.petsclib = '-lpetscts -lpetscsnes -lpetscksp -lpetscdm -lpetscmat -lpetscvec -lpetscsys'\n    self.complibs = self.compilers.flibs+self.compilers.cxxlibs+self.compilers.LIBS.split()\n    self.PETSC_WITH_EXTERNAL_LIB = self.libraries.toStringNoDupes(['-L${PETSC_DIR}/${PETSC_ARCH}/lib', self.petsclib]+self.packagelibs+self.complibs)\n    self.PETSC_EXTERNAL_LIB_BASIC = self.libraries.toStringNoDupes(self.packagelibs+self.complibs)\n\n    self.addMakeMacro('PETSC_EXTERNAL_LIB_BASIC',self.PETSC_EXTERNAL_LIB_BASIC)\n    allincludes = petscincludes + includes\n    allincludes_install = petscincludes_install + includes\n    self.PETSC_CC_INCLUDES = self.headers.toStringNoDupes(allincludes)\n    self.PETSC_CC_INCLUDES_INSTALL = self.headers.toStringNoDupes(allincludes_install)\n    self.addMakeMacro('PETSC_CC_INCLUDES',self.PETSC_CC_INCLUDES)\n    self.addMakeMacro('PETSC_CC_INCLUDES_INSTALL', self.PETSC_CC_INCLUDES_INSTALL)\n    if hasattr(self.compilers, 'FC'):\n      def modinc(includes):\n        return includes if self.fortran.fortranIsF90 else []\n      self.addMakeMacro('PETSC_FC_INCLUDES',self.headers.toStringNoDupes(allincludes,modinc(allincludes)))\n      self.addMakeMacro('PETSC_FC_INCLUDES_INSTALL',self.headers.toStringNoDupes(allincludes_install,modinc(allincludes_install)))\n\n    self.addDefine('LIB_DIR','\"'+os.path.join(self.installdir.dir,'lib')+'\"')\n\n    if self.framework.argDB['with-single-library']:\n      # overrides the values set in conf/variables\n      self.addMakeMacro('LIBNAME','${INSTALL_LIB_DIR}/libpetsc.${AR_LIB_SUFFIX}')\n      self.addMakeMacro('SHLIBS','libpetsc')\n      self.addMakeMacro('PETSC_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_KSP_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TS_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_TAO_LIB_BASIC','-lpetsc')\n      self.addMakeMacro('PETSC_WITH_EXTERNAL_LIB',self.PETSC_WITH_EXTERNAL_LIB)\n      self.addDefine('USE_SINGLE_LIBRARY', '1')\n      if self.sharedlibraries.useShared:\n        self.addMakeMacro('PETSC_SYS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${C_SH_LIB_PATH} ${PETSC_WITH_EXTERNAL_LIB}')\n      else:\n        self.addMakeMacro('PETSC_SYS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_VEC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_MAT_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_DM_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_KSP_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_SNES_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TS_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_TAO_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CHARACTERISTIC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_LIB','${PETSC_WITH_EXTERNAL_LIB}')\n        self.addMakeMacro('PETSC_CONTRIB','${PETSC_WITH_EXTERNAL_LIB}')\n\n    if not os.path.exists(os.path.join(self.petscdir.dir,self.arch.arch,'lib')):\n      os.makedirs(os.path.join(self.petscdir.dir,self.arch.arch,'lib'))\n\n# add a makefile endtry for display\n    if self.framework.argDB['with-display']:\n      self.addMakeMacro('DISPLAY',self.framework.argDB['with-display'])\n\n    # add a makefile entry for configure options\n    self.addMakeMacro('CONFIGURE_OPTIONS', self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"'))\n    return\n\n  def dumpConfigInfo(self):\n    import time\n    fd = open(os.path.join(self.arch.arch,'include','petscconfiginfo.h'),'w')\n    fd.write('static const char *petscconfigureoptions = \"'+self.framework.getOptionsString(['configModules', 'optionsModule']).replace('\\\"','\\\\\"').replace('\\\\ ','\\\\\\\\ ')+'\";\\n')\n    fd.close()\n    return\n\n  def dumpMachineInfo(self):\n    import platform\n    import datetime\n    import time\n    import script\n    def escape(s):\n      return s.replace('\"',r'\\\"').replace(r'\\ ',r'\\\\ ') # novermin\n    fd = open(os.path.join(self.arch.arch,'include','petscmachineinfo.h'),'w')\n    fd.write('static const char *petscmachineinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"-----------------------------------------\\\\n\\\"\\n')\n    buildhost = platform.node()\n    if os.environ.get('SOURCE_DATE_EPOCH'):\n      buildhost = \"reproducible\"\n    buildtime = datetime.datetime.utcfromtimestamp(int(os.environ.get('SOURCE_DATE_EPOCH', time.time())))\n    fd.write('\\\"Libraries compiled on %s on %s \\\\n\\\"\\n' % (buildtime, buildhost))\n    fd.write('\\\"Machine characteristics: %s\\\\n\\\"\\n' % (platform.platform()))\n    fd.write('\\\"Using PETSc directory: %s\\\\n\\\"\\n' % (escape(self.installdir.petscDir)))\n    fd.write('\\\"Using PETSc arch: %s\\\\n\\\"\\n' % (escape(self.installdir.petscArch)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C compiler: %s %s \\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran compiler: %s %s  %s\\\\n\\\"\\n' % (escape(self.setCompilers.getCompiler()), escape(self.setCompilers.getCompilerFlags()), escape(self.setCompilers.CPPFLAGS)))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsccompilerflagsinfo = \\\"\\\\n\\\"\\n')\n    fd.write('\\\"Using include paths: %s\\\\n\\\"\\n' % (escape(self.PETSC_CC_INCLUDES_INSTALL.replace('${PETSC_DIR}', self.installdir.petscDir))))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.write('static const char *petsclinkerinfo = \\\"\\\\n\\\"\\n')\n    self.setCompilers.pushLanguage(self.languages.clanguage)\n    fd.write('\\\"Using C linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n    self.setCompilers.popLanguage()\n    if hasattr(self.compilers, 'FC'):\n      self.setCompilers.pushLanguage('FC')\n      fd.write('\\\"Using Fortran linker: %s\\\\n\\\"\\n' % (escape(self.setCompilers.getLinker())))\n      self.setCompilers.popLanguage()\n    fd.write('\\\"Using libraries: %s%s -L%s %s %s\\\\n\\\"\\n' % (escape(self.setCompilers.CSharedLinkerFlag), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(os.path.join(self.installdir.petscDir, self.installdir.petscArch, 'lib')), escape(self.petsclib), escape(self.PETSC_EXTERNAL_LIB_BASIC)))\n    fd.write('\\\"-----------------------------------------\\\\n\\\";\\n')\n    fd.close()\n    return\n\n  def configurePrefetch(self):\n    '''Sees if there are any prefetch functions supported'''\n    if config.setCompilers.Configure.isSolaris(self.log) or self.framework.argDB['with-ios'] or not self.framework.argDB['with-prefetch']:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch((const char*)v,_MM_HINT_NTA);\\n'):\n      # The Intel Intrinsics manual [1] specifies the prototype\n      #\n      #   void _mm_prefetch(char const *a, int sel);\n      #\n      # but other vendors seem to insist on using subtly different\n      # prototypes, including void* for the pointer, and an enum for\n      # sel.  These are both reasonable changes, but negatively impact\n      # portability.\n      #\n      # [1] https://software.intel.com/file/6373\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const char*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('#include <xmmintrin.h>', 'void *v = 0;_mm_prefetch(v,_MM_HINT_NTA);\\n'):\n      self.addDefine('HAVE_XMMINTRIN_H', 1)\n      self.addDefine('Prefetch(a,b,c)', '_mm_prefetch((const void*)(a),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '_MM_HINT_NTA')\n      self.addDefine('PREFETCH_HINT_T0',  '_MM_HINT_T0')\n      self.addDefine('PREFETCH_HINT_T1',  '_MM_HINT_T1')\n      self.addDefine('PREFETCH_HINT_T2',  '_MM_HINT_T2')\n    elif self.checkLink('', 'void *v = 0;__builtin_prefetch(v,0,0);\\n'):\n      # From GCC docs: void __builtin_prefetch(const void *addr,int rw,int locality)\n      #\n      #   The value of rw is a compile-time constant one or zero; one\n      #   means that the prefetch is preparing for a write to the memory\n      #   address and zero, the default, means that the prefetch is\n      #   preparing for a read. The value locality must be a compile-time\n      #   constant integer between zero and three. A value of zero means\n      #   that the data has no temporal locality, so it need not be left\n      #   in the cache after the access. A value of three means that the\n      #   data has a high degree of temporal locality and should be left\n      #   in all levels of cache possible. Values of one and two mean,\n      #   respectively, a low or moderate degree of temporal locality.\n      #\n      # Here we adopt Intel's x86/x86-64 naming scheme for the locality\n      # hints.  Using macros for these values in necessary since some\n      # compilers require an enum.\n      self.addDefine('Prefetch(a,b,c)', '__builtin_prefetch((a),(b),(c))')\n      self.addDefine('PREFETCH_HINT_NTA', '0')\n      self.addDefine('PREFETCH_HINT_T0',  '3')\n      self.addDefine('PREFETCH_HINT_T1',  '2')\n      self.addDefine('PREFETCH_HINT_T2',  '1')\n    else:\n      self.addDefine('Prefetch(a,b,c)', ' ')\n    self.popLanguage()\n\n  def delGenFiles(self):\n    '''Delete generated files'''\n    delfile = os.path.join(self.arch.arch,'lib','petsc','conf','files')\n    try:\n      os.unlink(delfile)\n    except: pass\n\n  def configureAtoll(self):\n    '''Checks if atoll exists'''\n    if self.checkLink('#define _POSIX_C_SOURCE 200112L\\n#include <stdlib.h>','long v = atoll(\"25\")') or self.checkLink ('#include <stdlib.h>','long v = atoll(\"25\")'):\n       self.addDefine('HAVE_ATOLL', '1')\n\n  def configureUnused(self):\n    '''Sees if __attribute((unused)) is supported'''\n    if self.framework.argDB['with-ios']:\n      self.addDefine('UNUSED', ' ')\n      return\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('__attribute((unused)) static int myfunc(__attribute((unused)) void *name){ return 1;}', 'int i = 0;\\nint j = myfunc(&i);\\ntypedef void* atype;\\n__attribute((unused))  atype a;\\n'):\n      self.addDefine('UNUSED', '__attribute((unused))')\n    else:\n      self.addDefine('UNUSED', ' ')\n    self.popLanguage()\n\n  def configureIsatty(self):\n    '''Check if the Unix C function isatty() works correctly\n       Actually just assumes it does not work correctly on batch systems'''\n    if not self.framework.argDB['with-batch']:\n      self.addDefine('USE_ISATTY',1)\n\n  def configureDeprecated(self):\n    '''Check if __attribute((deprecated)) is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    ## Recent versions of gcc and clang support __attribute((deprecated(\"string argument\"))), which is very useful, but\n    ## Intel has conspired to make a supremely environment-sensitive compiler.  The Intel compiler looks at the gcc\n    ## executable in the environment to determine the language compatibility that it should attempt to emulate.  Some\n    ## important Cray installations have built PETSc using the Intel compiler, but with a newer gcc module loaded (e.g.,\n    ## 4.7).  Thus at PETSc configure time, the Intel compiler decides to support the string argument, but the gcc\n    ## found in the default user environment is older and does not support the argument.  If GCC and Intel were cool\n    ## like Clang and supported __has_attribute, we could avoid configure tests entirely, but they don't.  And that is\n    ## why we can't have nice things.\n    #\n    # if self.checkCompile(\"\"\"__attribute((deprecated(\"Why you shouldn't use myfunc\"))) static int myfunc(void) { return 1;}\"\"\", ''):\n    #   self.addDefine('DEPRECATED_FUNCTION(why)', '__attribute((deprecated(why)))')\n    #   self.addDefine('DEPRECATED_TYPEDEF(why)', '__attribute((deprecated(why)))')\n    if self.checkCompile(\"\"\"__attribute((deprecated)) static int myfunc(void) { return 1;}\"\"\", ''):\n      self.addDefine('DEPRECATED_FUNCTION(why)', '__attribute((deprecated))')\n      self.addDefine('DEPRECATED_TYPEDEF(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED_FUNCTION(why)', ' ')\n      self.addDefine('DEPRECATED_TYPEDEF(why)', ' ')\n    if self.checkCompile(\"\"\"enum E {oldval __attribute((deprecated)), newval };\"\"\", ''):\n      self.addDefine('DEPRECATED_ENUM(why)', '__attribute((deprecated))')\n    else:\n      self.addDefine('DEPRECATED_ENUM(why)', ' ')\n    # I was unable to make a CPP macro that takes the old and new values as separate arguments and builds the message needed by _Pragma\n    # hence the deprecation message is handled as it is\n    if self.checkCompile('#define TEST _Pragma(\"GCC warning \\\"Testing _Pragma\\\"\") value'):\n      self.addDefine('DEPRECATED_MACRO(why)', '_Pragma(why)')\n    else:\n      self.addDefine('DEPRECATED_MACRO(why)', ' ')\n    self.popLanguage()\n\n  def configureAlign(self):\n    '''Check if __attribute(aligned) is supported'''\n    code = '''\\\nstruct mystruct {int myint;} __attribute((aligned(16)));\nchar assert_aligned[(sizeof(struct mystruct)==16)*2-1];\n'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile(code):\n      self.addDefine('ATTRIBUTEALIGNED(size)', '__attribute((aligned(size)))')\n      self.addDefine('HAVE_ATTRIBUTEALIGNED', 1)\n    else:\n      self.framework.logPrint('Incorrect attribute(aligned)')\n      self.addDefine('ATTRIBUTEALIGNED(size)', ' ')\n    self.popLanguage()\n    return\n\n  def configureExpect(self):\n    '''Sees if the __builtin_expect directive is supported'''\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkLink('', 'if (__builtin_expect(0,1)) return 1;'):\n      self.addDefine('HAVE_BUILTIN_EXPECT', 1)\n    self.popLanguage()\n\n  def configureFunctionName(self):\n    '''Sees if the compiler supports __func__ or a variant.'''\n    def getFunctionName(lang):\n      name = '\"unknown\"'\n      self.pushLanguage(lang)\n      for fname in ['__func__','__FUNCTION__','__extension__ __func__']:\n        code = \"if (\"+fname+\"[0] != 'm') return 1;\"\n        if self.checkCompile('',code) and self.checkLink('',code):\n          name = fname\n          break\n      self.popLanguage()\n      return name\n    langs = []\n\n    self.addDefine('FUNCTION_NAME_C', getFunctionName('C'))\n    if hasattr(self.compilers, 'CXX'):\n      self.addDefine('FUNCTION_NAME_CXX', getFunctionName('Cxx'))\n\n  def configureIntptrt(self):\n    '''Determine what to use for uintptr_t'''\n    def staticAssertSizeMatchesVoidStar(inc,typename):\n      # The declaration is an error if either array size is negative.\n      # It should be okay to use an int that is too large, but it would be very unlikely for this to be the case\n      return self.checkCompile(inc, ('#define STATIC_ASSERT(cond) char negative_length_if_false[2*(!!(cond))-1]\\n'\n                                     + 'STATIC_ASSERT(sizeof(void*) == sizeof(%s));'%typename))\n    self.pushLanguage(self.languages.clanguage)\n    if self.checkCompile('#include <stdint.h>', 'int x; uintptr_t i = (uintptr_t)&x;'):\n      self.addDefine('UINTPTR_T', 'uintptr_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long long'):\n      self.addDefine('UINTPTR_T', 'unsigned long long')\n    elif staticAssertSizeMatchesVoidStar('#include <stdlib.h>','size_t') or staticAssertSizeMatchesVoidStar('#include <string.h>', 'size_t'):\n      self.addDefine('UINTPTR_T', 'size_t')\n    elif staticAssertSizeMatchesVoidStar('','unsigned long'):\n      self.addDefine('UINTPTR_T', 'unsigned long')\n    elif staticAssertSizeMatchesVoidStar('','unsigned'):\n      self.addDefine('UINTPTR_T', 'unsigned')\n    else:\n      raise RuntimeError('Could not find any unsigned integer type matching void*')\n    self.popLanguage()\n\n  def configureRTLDDefault(self):\n    if self.checkCompile('#include <dlfcn.h>\\n void *ptr =  RTLD_DEFAULT;'):\n      self.addDefine('RTLD_DEFAULT','1')\n    return\n\n  def configureSolaris(self):\n    '''Solaris specific stuff'''\n    if os.path.isdir(os.path.join('/usr','ucblib')):\n      try:\n        flag = getattr(self.setCompilers, self.language[-1]+'SharedLinkerFlag')\n      except AttributeError:\n        flag = None\n      if flag is None:\n        self.compilers.LIBS += ' -L/usr/ucblib'\n      else:\n        self.compilers.LIBS += ' '+flag+'/usr/ucblib'\n    return\n\n  def configureLinux(self):\n    '''Linux specific stuff'''\n    # TODO: Test for this by mallocing an odd number of floats and checking the address\n    self.addDefine('HAVE_DOUBLE_ALIGN_MALLOC', 1)\n    return\n\n  def configureWin32(self):\n    '''Win32 non-cygwin specific stuff'''\n    kernel32=0\n    if self.libraries.add('Kernel32.lib','GetComputerName',prototype='#include <windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    elif self.libraries.add('kernel32','GetComputerName',prototype='#include <windows.h>', call='GetComputerName(NULL,NULL);'):\n      self.addDefine('HAVE_WINDOWS_H',1)\n      self.addDefine('HAVE_GETCOMPUTERNAME',1)\n      kernel32=1\n    if kernel32:\n      if self.framework.argDB['with-windows-graphics']:\n        self.addDefine('USE_WINDOWS_GRAPHICS',1)\n      if self.checkLink('#include <windows.h>','LoadLibrary(0)'):\n        self.addDefine('HAVE_LOADLIBRARY',1)\n      if self.checkLink('#include <windows.h>','GetProcAddress(0,0)'):\n        self.addDefine('HAVE_GETPROCADDRESS',1)\n      if self.checkLink('#include <windows.h>','FreeLibrary(0)'):\n        self.addDefine('HAVE_FREELIBRARY',1)\n      if self.checkLink('#include <windows.h>','GetLastError()'):\n        self.addDefine('HAVE_GETLASTERROR',1)\n      if self.checkLink('#include <windows.h>','SetLastError(0)'):\n        self.addDefine('HAVE_SETLASTERROR',1)\n      if self.checkLink('#include <windows.h>\\n','QueryPerformanceCounter(0);\\n'):\n        self.addDefine('USE_MICROSOFT_TIME',1)\n    if self.libraries.add('Advapi32.lib','GetUserName',prototype='#include <windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n    elif self.libraries.add('advapi32','GetUserName',prototype='#include <windows.h>', call='GetUserName(NULL,NULL);'):\n      self.addDefine('HAVE_GET_USER_NAME',1)\n\n    if not self.libraries.add('User32.lib','GetDC',prototype='#include <windows.h>',call='GetDC(0);'):\n      self.libraries.add('user32','GetDC',prototype='#include <windows.h>',call='GetDC(0);')\n    if not self.libraries.add('Gdi32.lib','CreateCompatibleDC',prototype='#include <windows.h>',call='CreateCompatibleDC(0);'):\n      self.libraries.add('gdi32','CreateCompatibleDC',prototype='#include <windows.h>',call='CreateCompatibleDC(0);')\n\n    self.types.check('int32_t', 'int')\n    if not self.checkCompile('#include <sys/types.h>\\n','uid_t u;\\n'):\n      self.addTypedef('int', 'uid_t')\n      self.addTypedef('int', 'gid_t')\n    if not self.checkLink('#if defined(PETSC_HAVE_UNISTD_H)\\n#include <unistd.h>\\n#endif\\n','int a=R_OK;\\n'):\n      self.framework.addDefine('R_OK', '04')\n      self.framework.addDefine('W_OK', '02')\n      self.framework.addDefine('X_OK', '01')\n    if not self.checkLink('#include <sys/stat.h>\\n','int a=0;\\nif (S_ISDIR(a)){}\\n'):\n      self.framework.addDefine('S_ISREG(a)', '(((a)&_S_IFMT) == _S_IFREG)')\n      self.framework.addDefine('S_ISDIR(a)', '(((a)&_S_IFMT) == _S_IFDIR)')\n    if self.checkCompile('#include <windows.h>\\n','LARGE_INTEGER a;\\nDWORD b=a.u.HighPart;\\n'):\n      self.addDefine('HAVE_LARGE_INTEGER_U',1)\n\n    # Windows requires a Binary file creation flag when creating/opening binary files.  Is a better test in order?\n    if self.checkCompile('#include <windows.h>\\n#include <fcntl.h>\\n', 'int flags = O_BINARY;'):\n      self.addDefine('HAVE_O_BINARY',1)\n\n    if self.compilers.CC.find('win32fe') >= 0:\n      self.addDefine('HAVE_WINDOWS_COMPILERS',1)\n      self.addDefine('DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('CANNOT_START_DEBUGGER',1)\n      (petscdir,error,status) = self.executeShellCommand('cygpath -w '+self.installdir.petscDir, log = self.log)\n      self.addDefine('DIR','\"'+petscdir.replace('\\\\','\\\\\\\\')+'\"')\n      (petscdir,error,status) = self.executeShellCommand('cygpath -m '+self.installdir.petscDir, log = self.log)\n      self.addMakeMacro('wPETSC_DIR',petscdir)\n      if self.dataFilesPath.datafilespath:\n        (datafilespath,error,status) = self.executeShellCommand('cygpath -m '+self.dataFilesPath.datafilespath, log = self.log)\n        self.addMakeMacro('DATAFILESPATH',datafilespath)\n\n    else:\n      self.addDefine('REPLACE_DIR_SEPARATOR','\\'\\\\\\\\\\'')\n      self.addDefine('DIR_SEPARATOR','\\'/\\'')\n      self.addDefine('DIR','\"'+self.installdir.petscDir+'\"')\n      self.addMakeMacro('wPETSC_DIR',self.installdir.petscDir)\n      if self.dataFilesPath.datafilespath:\n        self.addMakeMacro('DATAFILESPATH',self.dataFilesPath.datafilespath)\n    self.addDefine('ARCH','\"'+self.installdir.petscArch+'\"')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureCygwinBrokenPipe(self):\n    '''Cygwin version <= 1.7.18 had issues with pipes and long commands invoked from gnu-make\n    http://cygwin.com/ml/cygwin/2013-05/msg00340.html '''\n    if config.setCompilers.Configure.isCygwin(self.log):\n      import platform\n      import re\n      r=re.compile(\"([0-9]+).([0-9]+).([0-9]+)\")\n      m=r.match(platform.release())\n      major=int(m.group(1))\n      minor=int(m.group(2))\n      subminor=int(m.group(3))\n      if ((major < 1) or (major == 1 and minor < 7) or (major == 1 and minor == 7 and subminor <= 18)):\n        self.addMakeMacro('PETSC_CYGWIN_BROKEN_PIPE','1')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureDefaultArch(self):\n    conffile = os.path.join('lib','petsc','conf', 'petscvariables')\n    if self.framework.argDB['with-default-arch']:\n      fd = open(conffile, 'w')\n      fd.write('PETSC_ARCH='+self.arch.arch+'\\n')\n      fd.write('PETSC_DIR='+self.petscdir.dir+'\\n')\n      fd.write('include '+os.path.join('$(PETSC_DIR)','$(PETSC_ARCH)','lib','petsc','conf','petscvariables')+'\\n')\n      fd.close()\n      self.framework.actions.addArgument('PETSc', 'Build', 'Set default architecture to '+self.arch.arch+' in '+conffile)\n    elif os.path.isfile(conffile):\n      try:\n        os.unlink(conffile)\n      except:\n        raise RuntimeError('Unable to remove file '+conffile+'. Did a different user create it?')\n    return\n\n#-----------------------------------------------------------------------------------------------------\n  def configureScript(self):\n    '''Output a script in the conf directory which will reproduce the configuration'''\n    import nargs\n    import sys\n    scriptName = os.path.join(self.arch.arch,'lib','petsc','conf', 'reconfigure-'+self.arch.arch+'.py')\n    args = dict([(nargs.Arg.parseArgument(arg)[0], arg) for arg in self.framework.clArgs])\n    if 'with-clean' in args:\n      del args['with-clean']\n    if 'force' in args:\n      del args['force']\n    if 'configModules' in args:\n      if nargs.Arg.parseArgument(args['configModules'])[1] == 'PETSc.Configure':\n        del args['configModules']\n    if 'optionsModule' in args:\n      if nargs.Arg.parseArgument(args['optionsModule'])[1] == 'config.compilerOptions':\n        del args['optionsModule']\n    if not 'PETSC_ARCH' in args:\n      args['PETSC_ARCH'] = 'PETSC_ARCH='+str(self.arch.arch)\n    f = open(scriptName, 'w')\n    f.write('#!'+sys.executable+'\\n')\n    f.write('if __name__ == \\'__main__\\':\\n')\n    f.write('  import sys\\n')\n    f.write('  import os\\n')\n    f.write('  sys.path.insert(0, os.path.abspath(\\'config\\'))\\n')\n    f.write('  import configure\\n')\n    # pretty print repr(args.values())\n    f.write('  configure_options = [\\n')\n    for itm in sorted(args.values()):\n      f.write('    \\''+str(itm)+'\\',\\n')\n    f.write('  ]\\n')\n    f.write('  configure.petsc_configure(configure_options)\\n')\n    f.close()\n    try:\n      os.chmod(scriptName, 0o775)\n    except OSError as e:\n      self.framework.logPrint('Unable to make reconfigure script executable:\\n'+str(e))\n    self.framework.actions.addArgument('PETSc', 'File creation', 'Created '+scriptName+' for automatic reconfiguration')\n    return\n\n  def configureInstall(self):\n    '''Setup the directories for installation'''\n    if self.framework.argDB['prefix']:\n      self.addMakeRule('print_mesg_after_build','',\n       ['-@echo \"=========================================\"',\n        '-@echo \"Now to install the libraries do:\"',\n        '-@echo \"%s${MAKE_USER} PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} install\"' % self.installdir.installSudo,\n        '-@echo \"=========================================\"'])\n    else:\n      self.addMakeRule('print_mesg_after_build','',\n       ['-@echo \"=========================================\"',\n        '-@echo \"Now to check if the libraries are working do:\"',\n        '-@echo \"${MAKE_USER} PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} check\"',\n        '-@echo \"=========================================\"'])\n      return\n\n  def configureGCOV(self):\n    if self.framework.argDB['with-gcov']:\n      self.addDefine('USE_GCOV','1')\n    return\n\n  def postProcessPackages(self):\n    postPackages=[]\n    for i in self.framework.packages:\n      if hasattr(i,'postProcess'): postPackages.append(i)\n    if postPackages:\n      # ctetgen needs petsc conf files. so attempt to create them early\n      self.framework.dumpConfFiles()\n      # tacky fix for dependency of Aluimia on Pflotran; requested via petsc-dev Matt provide a correct fix\n      for i in postPackages:\n        if i.name.upper() in ['PFLOTRAN']:\n          i.postProcess()\n          postPackages.remove(i)\n      for i in postPackages: i.postProcess()\n      for i in postPackages:\n        if i.installedpetsc:\n          self.installed = 1\n          break\n    return\n\n  def configure(self):\n    if 'package-prefix-hash' in self.argDB:\n      # turn off prefix if it was only used to for installing external packages.\n      self.framework.argDB['prefix'] = ''\n      self.dir = os.path.abspath(os.path.join(self.petscdir.dir, self.arch.arch))\n      self.installdir.dir = self.dir\n      self.installdir.petscDir = self.petscdir.dir\n      self.petscDir = self.petscdir.dir\n      self.petscArch = self.arch.arch\n      self.addMakeMacro('PREFIXDIR',self.dir)\n      self.confDir = os.path.abspath(os.path.join(self.petscdir.dir, self.arch.arch))\n\n    if not os.path.samefile(self.petscdir.dir, os.getcwd()):\n      raise RuntimeError('Wrong PETSC_DIR option specified: '+str(self.petscdir.dir) + '\\n  Configure invoked in: '+os.path.realpath(os.getcwd()))\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],self.petscdir.dir):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR!')\n    if self.framework.argDB['prefix'] and self.framework.argDB['prefix'].find(' ') > -1:\n      raise RuntimeError('Your --prefix '+self.framework.argDB['prefix']+' has spaces in it; this is not allowed.\\n Use a --prefix that does not have spaces in it')\n    if self.framework.argDB['prefix'] and os.path.isdir(self.framework.argDB['prefix']) and os.path.samefile(self.framework.argDB['prefix'],os.path.join(self.petscdir.dir,self.arch.arch)):\n      raise RuntimeError('Incorrect option --prefix='+self.framework.argDB['prefix']+' specified. It cannot be same as PETSC_DIR/PETSC_ARCH!')\n    self.framework.header          = os.path.join(self.arch.arch,'include','petscconf.h')\n    self.framework.cHeader         = os.path.join(self.arch.arch,'include','petscfix.h')\n    self.framework.pkgheader       = os.path.join(self.arch.arch,'include','petscpkg_version.h')\n    self.framework.makeMacroHeader = os.path.join(self.arch.arch,'lib','petsc','conf','petscvariables')\n    self.framework.makeRuleHeader  = os.path.join(self.arch.arch,'lib','petsc','conf','petscrules')\n    if self.libraries.math is None:\n      raise RuntimeError('PETSc requires a functional math library. Please send configure.log to petsc-maint@mcs.anl.gov.')\n    if self.languages.clanguage == 'Cxx' and not hasattr(self.compilers, 'CXX'):\n      raise RuntimeError('Cannot set C language to C++ without a functional C++ compiler.')\n    self.executeTest(self.configureRTLDDefault)\n    self.executeTest(self.configurePrefetch)\n    self.executeTest(self.configureUnused)\n    self.executeTest(self.configureDeprecated)\n    self.executeTest(self.configureIsatty)\n    self.executeTest(self.configureExpect)\n    self.executeTest(self.configureAlign)\n    self.executeTest(self.configureFunctionName)\n    self.executeTest(self.configureIntptrt)\n    self.executeTest(self.configureSolaris)\n    self.executeTest(self.configureLinux)\n    self.executeTest(self.configureWin32)\n    self.executeTest(self.configureCygwinBrokenPipe)\n    self.executeTest(self.configureDefaultArch)\n    self.executeTest(self.configureScript)\n    self.executeTest(self.configureInstall)\n    self.executeTest(self.configureGCOV)\n    self.executeTest(self.configureAtoll)\n\n    self.Dump()\n    self.dumpConfigInfo()\n    self.dumpMachineInfo()\n    self.delGenFiles()\n    # need to save the current state of BuildSystem so that postProcess() packages can read it in and perhaps run make install\n    self.framework.storeSubstitutions(self.framework.argDB)\n    self.framework.argDB['configureCache'] = pickle.dumps(self.framework)\n    self.framework.argDB.save(force = True)\n    self.DumpPkgconfig('PETSc.pc')\n    self.DumpPkgconfig('petsc.pc')\n    self.DumpModule()\n    self.postProcessPackages()\n    self.framework.log.write('================================================================================\\n')\n    self.logClear()\n    return\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/config/BuildSystem/config/setCompilers.py": "from __future__ import generators\nimport config.base\nimport config\nimport os\nfrom functools import reduce\n\n# not sure how to handle this with 'self' so its outside the class\ndef noCheck(command, status, output, error):\n  return\n\ntry:\n  any\nexcept NameError:\n  def any(lst):\n    return reduce(lambda x,y:x or y,lst,False)\n\ndef _picTestIncludes(export=''):\n  return '\\n'.join(['#include <stdio.h>',\n                    'int (*fprintf_ptr)(FILE*,const char*,...) = fprintf;',\n                    'void '+export+' foo(void){',\n                    '  fprintf_ptr(stdout,\"hello\");',\n                    '  return;',\n                    '}',\n                    'void bar(void){foo();}\\n'])\n\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.usedMPICompilers = 0\n    self.mainLanguage = 'C'\n    return\n\n  def __str__(self):\n    self.compilerflags = self.framework.getChild('config.compilerFlags')\n    desc = ['Compilers:']\n    if hasattr(self, 'CC'):\n      self._setupCompiler('C',desc)\n    if hasattr(self, 'CUDAC'):\n      self._setupCompiler('CUDA',desc)\n    if hasattr(self, 'HIPCC'):\n      self._setupCompiler('HIP',desc)\n    if hasattr(self, 'SYCLCXX'):\n      self._setupCompiler('SYCL',desc)\n    if hasattr(self, 'CXX'):\n      self._setupCompiler('Cxx',desc)\n    if hasattr(self, 'FC'):\n      self._setupCompiler('FC',desc)\n    desc.append('Linkers:')\n    if hasattr(self, 'staticLinker'):\n      desc.append('  Static linker:   '+self.getSharedLinker()+' '+self.AR_FLAGS)\n    elif hasattr(self, 'sharedLinker'):\n      desc.append('  Shared linker:   '+self.getSharedLinker()+' '+self.getSharedLinkerFlags())\n    if hasattr(self, 'dynamicLinker'):\n      desc.append('  Dynamic linker:   '+self.getDynamicLinker()+' '+self.getDynamicLinkerFlags())\n      desc.append('  Libraries linked against:   '+self.LIBS)\n    return '\\n'.join(desc)+'\\n'\n\n  def _setupCompiler(self,compiler,desc):\n    \"\"\" Simple utility routine to minimize verbiage\"\"\"\n    clabel='  '+compiler+' '\n    if compiler == 'Cxx': clabel='  C++ '\n    if compiler == 'FC':  clabel='  Fortran '\n    self.pushLanguage(compiler)\n    desc.append(clabel+'Compiler:         '\n                +self.getCompiler()+' '+self.getCompilerFlags())\n    if self.compilerflags.version[compiler]:\n      desc.append('    Version: '+self.compilerflags.version[compiler])\n    if not self.getLinker() == self.getCompiler():\n      desc.append(clabel+'Linker:           '\n                  +self.getLinker()+' '+self.getLinkerFlags())\n    self.popLanguage()\n    return\n\n  def setupHelp(self, help):\n    import nargs\n\n    help.addArgument('Compilers', '-with-cpp=<prog>', nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPP=<prog>',            nargs.Arg(None, None, 'Specify the C preprocessor'))\n    help.addArgument('Compilers', '-CPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C only (not used for C++ or FC) preprocessor options'))\n    help.addArgument('Compilers', '-with-cc=<prog>',  nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CC=<prog>',             nargs.Arg(None, None, 'Specify the C compiler'))\n    help.addArgument('Compilers', '-CFLAGS=<string>',       nargs.Arg(None, None, 'Specify the C compiler options'))\n    help.addArgument('Compilers', '-CC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the C linker flags'))\n\n    help.addArgument('Compilers', '-CXXPP=<prog>',          nargs.Arg(None, None, 'Specify the C++ preprocessor'))\n    help.addArgument('Compilers', '-CXXPPFLAGS=<string>',   nargs.Arg(None, None, 'Specify the C++ preprocessor options'))\n    help.addArgument('Compilers', '-with-cxx=<prog>', nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXX=<prog>',            nargs.Arg(None, None, 'Specify the C++ compiler'))\n    help.addArgument('Compilers', '-CXXFLAGS=<string>',     nargs.Arg(None, None, 'Specify the C++ compiler options, also passed to linker'))\n    help.addArgument('Compilers', '-CXX_CXXFLAGS=<string>', nargs.Arg(None, '',   'Specify the C++ compiler-only options, not passed to linker'))\n    help.addArgument('Compilers', '-CXX_LINKER_FLAGS=<string>',       nargs.Arg(None, [], 'Specify the C++ linker flags'))\n\n    help.addArgument('Compilers', '-FPP=<prog>',            nargs.Arg(None, None, 'Specify the Fortran preprocessor'))\n    help.addArgument('Compilers', '-FPPFLAGS=<string>',     nargs.Arg(None, None, 'Specify the Fortran preprocessor options'))\n    help.addArgument('Compilers', '-with-fc=<prog>',  nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FC=<prog>',             nargs.Arg(None, None, 'Specify the Fortran compiler'))\n    help.addArgument('Compilers', '-FFLAGS=<string>',       nargs.Arg(None, None, 'Specify the Fortran compiler options'))\n    help.addArgument('Compilers', '-FC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the FC linker flags'))\n\n    help.addArgument('Compilers', '-with-large-file-io=<bool>', nargs.ArgBool(None, 0, 'Allow IO with files greater then 2 GB'))\n\n    help.addArgument('Compilers', '-CUDAPP=<prog>',        nargs.Arg(None, None, 'Specify the CUDA preprocessor'))\n    help.addArgument('Compilers', '-CUDAPPFLAGS=<string>', nargs.Arg(None, '-Wno-deprecated-gpu-targets', 'Specify the CUDA preprocessor options'))\n    help.addArgument('Compilers', '-with-cudac=<prog>',    nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAC=<prog>',         nargs.Arg(None, None, 'Specify the CUDA compiler'))\n    help.addArgument('Compilers', '-CUDAFLAGS=<string>',   nargs.Arg(None, None, 'Specify the CUDA compiler options'))\n    help.addArgument('Compilers', '-CUDAC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the CUDA linker flags'))\n\n    help.addArgument('Compilers', '-HIPPP=<prog>', nargs.Arg(None, None, 'Specify the HIP preprocessor'))\n    help.addArgument('Compilers', '-HIPPPFLAGS=<string>', nargs.Arg(None, '-Wno-deprecated-gpu-targets', 'Specify the HIPpreprocessor options'))\n    help.addArgument('Compilers', '-with-hipcc=<prog>', nargs.Arg(None, None, 'Specify the HIP compiler'))\n    help.addArgument('Compilers', '-HIPCC=<prog>',         nargs.Arg(None, None, 'Specify the HIP compiler'))\n    help.addArgument('Compilers', '-HIPCCFLAGS=<string>',   nargs.Arg(None, None, 'Specify the HIP compiler options'))\n    help.addArgument('Compilers', '-HIPCC_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the HIP linker flags'))\n\n    help.addArgument('Compilers', '-SYCLPP=<prog>', nargs.Arg(None, None, 'Specify the SYCL preprocessor'))\n    help.addArgument('Compilers', '-SYCLPPFLAGS=<string>', nargs.Arg(None, '-Wno-deprecated-gpu-targets', 'Specify the SYCL preprocessor options'))\n    help.addArgument('Compilers', '-with-syclcxx=<prog>', nargs.Arg(None, None, 'Specify the SYCLcompiler'))\n    help.addArgument('Compilers', '-SYCLCXX=<prog>',         nargs.Arg(None, None, 'Specify the SYCL compiler')) \n    help.addArgument('Compilers', '-SYCLCXXFLAGS=<string>',   nargs.Arg(None, None, 'Specify the SYCL compiler options'))\n    help.addArgument('Compilers', '-SYCLCXX_LINKER_FLAGS=<string>',        nargs.Arg(None, [], 'Specify the SYCL linker flags'))\n\n##    help.addArgument('Compilers', '-LD=<prog>',              nargs.Arg(None, None, 'Specify the executable linker'))\n##    help.addArgument('Compilers', '-CC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for C only'))\n##    help.addArgument('Compilers', '-CXX_LD=<prog>',          nargs.Arg(None, None, 'Specify the linker for C++ only'))\n##    help.addArgument('Compilers', '-FC_LD=<prog>',           nargs.Arg(None, None, 'Specify the linker for Fortran only'))\n    help.addArgument('Compilers', '-with-shared-ld=<prog>',  nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LD_SHARED=<prog>',       nargs.Arg(None, None, 'Specify the shared linker'))\n    help.addArgument('Compilers', '-LDFLAGS=<string>',       nargs.Arg(None, '',   'Specify the linker options'))\n    help.addArgument('Compilers', '-with-ar=<prog>',                nargs.Arg(None, None,   'Specify the archiver'))\n    help.addArgument('Compilers', '-AR=<prog>',                     nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-AR_FLAGS=<string>',               nargs.Arg(None, None,   'Specify the archiver flags'))\n    help.addArgument('Compilers', '-with-ranlib=<prog>',            nargs.Arg(None, None,   'Specify ranlib'))\n    help.addArgument('Compilers', '-with-pic=<bool>',               nargs.ArgBool(None, 0, 'Compile with -fPIC or equivalent flag if possible'))\n    help.addArgument('Compilers', '-sharedLibraryFlags=<string>',     nargs.Arg(None, [], 'Specify the shared library flags'))\n    help.addArgument('Compilers', '-dynamicLibraryFlags=<string>',    nargs.Arg(None, [], 'Specify the dynamic library flags'))\n    help.addArgument('Compilers', '-LIBS=<string>',          nargs.Arg(None, None, 'Specify extra libraries for all links'))\n    help.addArgument('Compilers', '-with-environment-variables=<bool>',nargs.ArgBool(None, 0, 'Use compiler variables found in environment'))\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.languages = framework.require('PETSc.options.languages', self)\n    self.libraries = self.framework.getChild('config.libraries')\n    self.headers   = self.framework.getChild('config.headers')\n    return\n\n  @staticmethod\n  def isNAG(compiler, log):\n    '''Returns true if the compiler is a NAG F90 compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('NAGWare Fortran') >= 0 or output.find('The Numerical Algorithms Group Ltd') >= 0:\n        if log: log.write('Detected NAG Fortran compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isMINGW(compiler, log):\n    '''Returns true if the compiler is a MINGW GCC compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -v',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('w64-mingw32') >= 0:\n        if log: log.write('Detected MINGW GCC compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGNU(compiler, log):\n    '''Returns true if the compiler is a GNU compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20 ', log = log)\n      output = output + error\n      found = (any([s in output for s in ['www.gnu.org',\n                                         'bugzilla.redhat.com',\n                                         'gcc.gnu.org',\n                                         'gcc version',\n                                         '-print-libgcc-file-name',\n                                         'passed on to the various sub-processes invoked by gcc',\n                                         'passed on to the various sub-processes invoked by cc',\n                                         'passed on to the various sub-processes invoked by gfortran',\n                                         'passed on to the various sub-processes invoked by g++',\n                                         'passed on to the various sub-processes invoked by c++',\n                                         ]])\n              and not any([s in output for s in ['Intel(R)',\n                                                 'Unrecognised option --help passed to ld', # NAG f95 compiler\n                                                 ]]))\n      if found:\n        if log: log.write('Detected GNU compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isClang(compiler, log):\n    '''Returns true if the compiler is a Clang/LLVM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 500', log = log, logOutputflg = False)\n      output = output + error\n      found = any([s in output for s in ['Emit Clang AST']])\n      if found:\n        if log: log.write('Detected CLANG compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGfortran45x(compiler, log):\n    '''returns true if the compiler is gfortran-4.5.x'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      if re.match(r'GNU Fortran \\(.*\\) (4.5.\\d+|4.6.0 20100703)', output):\n        if log: log.write('Detected GFortran45x compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGfortran46plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.6.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,6):\n          if log: log.write('Detected GFortran46plus compiler\\n')\n          return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGfortran47plus(compiler, log):\n    '''returns true if the compiler is gfortran-4.7.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (4,7):\n          if log: log.write('Detected GFortran47plus compiler\\n')\n          return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGfortran100plus(compiler, log):\n    '''returns true if the compiler is gfortran-10.0.x or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (10,0):\n          if log: log.write('Detected GFortran100plus compiler\\n')\n          return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isGfortran8plus(compiler, log):\n    '''returns true if the compiler is gfortran-8 or later'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --version', log = log)\n      output = output +  error\n      import re\n      strmatch = re.match('GNU Fortran\\s+\\(.*\\)\\s+(\\d+)\\.(\\d+)',output)\n      if strmatch:\n        VMAJOR,VMINOR = strmatch.groups()\n        if (int(VMAJOR),int(VMINOR)) >= (8,0):\n          if log: log.write('Detected GFortran8plus compiler\\n')\n          return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isG95(compiler, log):\n    '''Returns true if the compiler is g95'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('http://www.g95.org') >= 0:\n        if log: log.write('Detected g95 compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isCompaqF90(compiler, log):\n    '''Returns true if the compiler is Compaq f90'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Unrecognised option --help passed to ld') >=0:    # NAG f95 compiler\n        return 0\n      if output.find('Compaq Visual Fortran') >= 0 or output.find('Digital Visual Fortran') >=0 :\n        if log: log.write('Detected Compaq Visual Fortran compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isSun(compiler, log):\n    '''Returns true if the compiler is a Sun/Oracle compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find(' Sun ') >= 0:\n        if log: log.write('Detected Sun/Oracle compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isIBM(compiler, log):\n    '''Returns true if the compiler is a IBM compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -qversion', log = log)\n      output = output + error\n      if 'IBM XL' in output:\n        if log: log.write('Detected IBM compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isIntel(compiler, log):\n    '''Returns true if the compiler is a Intel compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' --help | head -n 20', log = log)\n      output = output + error\n      if output.find('Intel') >= 0:\n        if log: log.write('Detected Intel compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isCrayKNL(compiler, log):\n    '''Returns true if the compiler is a compiler for KNL running on a Cray'''\n    x = os.getenv('PE_PRODUCT_LIST')\n    if x and x.find('CRAYPE_MIC-KNL') > -1:\n      if log: log.write('Detected Cray KNL compiler\\n')\n      return 1\n\n  @staticmethod\n  def isCray(compiler, log):\n    '''Returns true if the compiler is a Cray compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V', log = log)\n      output = output + error\n      if output.find('Cray Standard C') >= 0 or output.find('Cray C++') >= 0 or output.find('Cray Fortran') >= 0:\n        if log: log.write('Detected Cray compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isCrayVector(compiler, log):\n    '''Returns true if the compiler is a Cray compiler for a Cray Vector system'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -VV', log = log)\n      output = output + error\n      if not status and output.find('x86') >= 0:\n        return 0\n      elif not status:\n        if log: log.write('Detected Cray vector compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isPGI(compiler, log):\n    '''Returns true if the compiler is a PGI compiler'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(compiler+' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('The Portland Group') >= 0 or output.find('PGI Compilers and Tools') >= 0:\n        if log: log.write('Detected PGI compiler\\n')\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isSolarisAR(ar, log):\n    '''Returns true AR is solaris'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('Software Generation Utilities') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isAIXAR(ar, log):\n    '''Returns true AR is AIX'''\n    try:\n      (output, error, status) = config.base.Configure.executeShellCommand(ar + ' -V',checkCommand = noCheck, log = log)\n      output = output + error\n      if output.find('[-X{32|64|32_64|d64|any}]') >= 0:\n        return 1\n    except RuntimeError:\n      pass\n\n  @staticmethod\n  def isLinux(log):\n    '''Returns true if system is linux'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('linux') >= 0:\n      if log: log.write('Detected Linux OS')\n      return 1\n\n  @staticmethod\n  def isCygwin(log):\n    '''Returns true if system is cygwin'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('cygwin') >= 0:\n      if log: log.write('Detected Cygwin\\n')\n      return 1\n\n  @staticmethod\n  def isSolaris(log):\n    '''Returns true if system is solaris'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status and output.lower().strip().find('sunos') >= 0:\n      if log: log.write('Detected Solaris OS\\n')\n      return 1\n\n  @staticmethod\n  def isDarwin(log):\n    '''Returns true if system is Darwin/MacOSX'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      found = (output.lower().strip() == 'darwin')\n      if found:\n        if log: log.write('Detected Darwin/MacOSX OS\\n\\n')\n      return found\n\n  @staticmethod\n  def isDarwinCatalina(log):\n    '''Returns true if system is Darwin/MacOSX Version Catalina or higher'''\n    import platform\n    if platform.system() != 'Darwin': return 0\n    v = tuple([int(a) for a in platform.mac_ver()[0].split('.')])\n    if v < (10,15,0): return 0\n    if log: log.write('Detected Darwin/MacOSX Catalina OS\\n')\n    return 1\n\n  @staticmethod\n  def isFreeBSD(log):\n    '''Returns true if system is FreeBSD'''\n    (output, error, status) = config.base.Configure.executeShellCommand('uname -s', log = log)\n    if not status:\n      found = output.lower().strip() == 'freebsd'\n      if found:\n        if log: log.write('Detected FreeBSD OS\\n')\n      return found\n\n  @staticmethod\n  def isWindows(compiler, log):\n    '''Returns true if the compiler is a Windows compiler'''\n    if compiler in ['icl', 'cl', 'bcc32', 'ifl', 'df']:\n      if log: log.write('Detected Windows OS\\n')\n      return 1\n    if compiler in ['ifort','f90'] and Configure.isCygwin(log):\n      if log: log.write('Detected Windows OS\\n')\n      return 1\n    if compiler in ['lib', 'tlib']:\n      if log: log.write('Detected Windows OS\\n')\n      return 1\n\n  @staticmethod\n  def addLdPath(path):\n    if 'LD_LIBRARY_PATH' in os.environ:\n      ldPath=os.environ['LD_LIBRARY_PATH']\n    else:\n      ldPath=''\n    if ldPath == '': ldPath = path\n    else: ldPath += ':' + path\n    os.environ['LD_LIBRARY_PATH'] = ldPath\n    return\n\n  def useMPICompilers(self):\n    if ('with-cc' in self.argDB and self.argDB['with-cc'] != '0') or 'CC' in self.argDB:\n      return 0\n    if ('with-cxx' in self.argDB and self.argDB['with-cxx'] != '0') or 'CXX' in self.argDB:\n      return 0\n    if ('with-fc' in self.argDB and self.argDB['with-fc'] != '0') or 'FC' in self.argDB:\n      return 0\n    if self.argDB['download-mpich'] or self.argDB['download-openmpi']:\n      return 0\n    if 'with-mpi' in self.argDB and self.argDB['with-mpi'] and self.argDB['with-mpi-compilers']:\n      return 1\n    return 0\n\n  def checkInitialFlags(self):\n    '''Initialize the compiler and linker flags'''\n    for language in ['C', 'CUDA', 'HIP', 'SYCL', 'Cxx', 'FC']:\n      self.pushLanguage(language)\n      for flagsArg in [config.base.Configure.getCompilerFlagsName(language), config.base.Configure.getCompilerFlagsName(language, 1), config.base.Configure.getLinkerFlagsName(language)]:\n        if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n        else: setattr(self, flagsArg, '')\n        self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n      self.popLanguage()\n    for flagsArg in ['CPPFLAGS', 'FPPFLAGS', 'CUDAPPFLAGS', 'CXXPPFLAGS', 'HIPPPFLAGS', 'SYCLPPFLAGS']:\n      if flagsArg in self.argDB: setattr(self, flagsArg, self.argDB[flagsArg])\n      else: setattr(self, flagsArg, '')\n      self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    for flagsArg in ['CC_LINKER_FLAGS', 'CXX_LINKER_FLAGS', 'FC_LINKER_FLAGS', 'CUDAC_LINKER_FLAGS', 'HIPCC_LINKER_FLAGS', 'SYCLCXX_LINKER_FLAGS', 'sharedLibraryFlags', 'dynamicLibraryFlags']:\n      if isinstance(self.argDB[flagsArg],str): val = [self.argDB[flagsArg]]\n      else: val = self.argDB[flagsArg]\n      setattr(self, flagsArg, val)\n      self.logPrint('Initialized '+flagsArg+' to '+str(getattr(self, flagsArg)))\n    if 'LIBS' in self.argDB:\n      self.LIBS = self.argDB['LIBS']\n    else:\n      self.LIBS = ''\n    return\n\n  def checkCompiler(self, language, linkLanguage=None,includes = '', body = '', cleanup = 1, codeBegin = None, codeEnd = None):\n    '''Check that the given compiler is functional, and if not raise an exception'''\n    self.pushLanguage(language)\n    if not self.checkCompile(includes, body, cleanup, codeBegin, codeEnd):\n      msg = 'Cannot compile '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    if language == 'CUDA' or language == 'HIP' or language == 'SYCL': # do not check CUDA/HIP/SYCL linker since it is never used (assumed for now)\n      self.popLanguage()\n      return\n    if not self.checkLink(linkLanguage=linkLanguage,includes=includes,body=body):\n      msg = 'Cannot compile/link '+language+' with '+self.getCompiler()+'.'\n      self.popLanguage()\n      raise RuntimeError(msg)\n    oldlibs = self.LIBS\n    self.LIBS += ' -lpetsc-ufod4vtr9mqHvKIQiVAm'\n    if self.checkLink(linkLanguage=linkLanguage):\n      msg = language + ' compiler ' + self.getCompiler()+ ''' is broken! It is returning a zero error when the linking failed! Either\n 1) switch to another compiler suite or\n 2) report this entire error message to your compiler/linker suite vendor and ask for fix for this issue.'''\n      self.popLanguage()\n      self.LIBS = oldlibs\n      raise RuntimeError(msg)\n    self.LIBS = oldlibs\n    if not self.argDB['with-batch']:\n      if not self.checkRun(linkLanguage=linkLanguage):\n        msg = 'Cannot run executables created with '+language+'. If this machine uses a batch system \\nto submit jobs you will need to configure using ./configure with the additional option  --with-batch.\\n Otherwise there is problem with the compilers. Can you compile and run code with your compiler \\''+ self.getCompiler()+'\\'?\\n'\n        if self.isIntel(self.getCompiler(), self.log):\n          msg = msg + 'See https://www.mcs.anl.gov/petsc/documentation/faq.html#libimf'\n        self.popLanguage()\n        raise OSError(msg)\n    self.popLanguage()\n    return\n\n  def crayCrossCompiler(self,compiler):\n    import script\n    '''For Cray Intel KNL systems returns the underlying compiler line used by the wrapper compiler if is for KNL systems'''\n    '''This removes all the KNL specific options allowing the generated binary to run on the front-end'''\n    '''This is needed by some build systems include HDF5 that insist on running compiled programs during the configure and'''\n    '''make process. This does not work for the Cray compiler module, only intel and gcc'''\n\n    (output,error,status) = self.executeShellCommand(compiler+' -craype-verbose',checkCommand = script.Script.passCheckCommand,log=self.log)\n    output = output.split()\n    if output[0].strip().startswith('driver'): return ''\n    newoutput = [output[0]]\n    cross = 0\n    for i in output[1:-1]:\n      if i.find('mic') > -1 or i.find('knl') > -1 or i.find('KNL') > -1:\n        cross = 1\n        continue\n      if i.startswith('-L') or i.startswith('-l') or i.startswith('-Wl'):\n        continue\n      newoutput.append(i)\n    if cross:\n      return ' '.join(newoutput)\n    return ''\n\n  def crayCrossLIBS(self,compiler):\n    import script\n    '''For Cray Intel KNL systems returns the underlying linker options used by the wrapper compiler if is for KNL systems'''\n    (output,error,status) = self.executeShellCommand(compiler+' -craype-verbose',checkCommand = script.Script.passCheckCommand,log=self.log)\n    output = output.split()\n    newoutput = []\n    cross = 0\n    for i in output[1:-1]:\n      if i.find('mic') > -1 or i.find('knl') > -1 or i.find('KNL') > -1:\n        cross = 1\n        continue\n      if i.find('darshan') > -1:\n        cross = 1\n        continue\n      if i.find('static') > -1:\n        continue\n      if i.startswith('-I') or i.startswith('-D'):\n        continue\n      # the math libraries are not needed by external packages and cause errors in HDF5 with libgfortran.so.4 => not found\n      if i.startswith('-lsci_gnu'):\n        continue\n      newoutput.append(i)\n    if cross:\n      return ' '.join(newoutput)\n    return ''\n\n  def generateCCompilerGuesses(self):\n    '''Determine the C compiler '''\n    if hasattr(self, 'CC'):\n      yield self.CC\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-cc' in self.argDB:\n      if self.isWindows(self.argDB['with-cc'], self.log):\n        yield 'win32fe '+self.argDB['with-cc']\n      else:\n        yield self.argDB['with-cc']\n      raise RuntimeError('C compiler you provided with -with-cc='+self.argDB['with-cc']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'CC' in self.argDB:\n      if self.isWindows(self.argDB['CC'], self.log):\n        yield 'win32fe '+self.argDB['CC']\n      else:\n        yield self.argDB['CC']\n      raise RuntimeError('C compiler you provided with -CC='+self.argDB['CC']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif self.useMPICompilers() and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      self.usedMPICompilers = 1\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpcc_r')\n      self.usedMPICompilers = 0\n      raise RuntimeError('MPI compiler wrappers in '+self.argDB['with-mpi-dir']+'/bin cannot be found or do not work. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.useMPICompilers() and 'with-mpi-dir' in self.argDB:\n      # if it gets here these means that self.argDB['with-mpi-dir']/bin does not exist so we should not search for MPI compilers\n      # that is we are turning off the self.useMPICompilers()\n        self.logPrintBox('***** WARNING: '+os.path.join(self.argDB['with-mpi-dir'], 'bin')+ ' dir does not exist!\\n Skipping check for MPI compilers due to potentially incorrect --with-mpi-dir option.\\n Suggest using --with-cc=/path/to/mpicc option instead ******')\n\n        self.argDB['with-mpi-compilers'] = 0\n      if self.useMPICompilers():\n        self.usedMPICompilers = 1\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_cc = self.crayCrossCompiler('cc')\n          if cross_cc:\n            self.cross_cc = cross_cc\n            self.log.write('Cray system using C cross compiler:'+cross_cc+'\\n')\n            self.cross_LIBS = self.crayCrossLIBS('cc')\n            self.log.write('Cray system using C cross LIBS:'+self.cross_LIBS+'\\n')\n          yield 'cc'\n          if cross_cc:\n            delattr(self, 'cross_cc')\n            delattr(self, 'cross_LIBS')\n        yield 'mpicc'\n        yield 'mpiicc'\n        yield 'mpcc_r'\n        yield 'mpcc'\n        yield 'mpxlc'\n        yield 'hcc'\n        self.usedMPICompilers = 0\n      yield 'gcc'\n      yield 'clang'\n      yield 'icc'\n      yield 'cc'\n      yield 'xlc'\n      yield 'win32fe icl'\n      yield 'win32fe cl'\n      yield 'pgcc'\n      yield 'win32fe bcc32'\n    return\n\n  def checkCCompiler(self):\n    '''Locate a functional C compiler'''\n    if 'with-cc' in self.argDB and self.argDB['with-cc'] == '0':\n      raise RuntimeError('A functional C compiler is necessary for configure, cannot use --with-cc=0')\n    self.mesg = ''\n    for compiler in self.generateCCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CC'):\n          self.checkCompiler('C')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing C compiler: '+str(e))\n        if os.path.basename(self.CC) == 'mpicc':\n          self.logPrint(' MPI installation '+str(self.CC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('CC')\n        del self.CC\n    if not hasattr(self, 'CC'):\n      raise RuntimeError('Could not locate a functional C compiler')\n    try:\n      self.executeShellCommand(self.CC+' --version', log = self.log)\n    except:\n      pass\n    if os.path.basename(self.CC).startswith('mpi'):\n       self.logPrint('Since MPI c compiler starts with mpi, force searches for other compilers to only look for MPI compilers\\n')\n       self.argDB['with-mpi-compilers'] = 1\n    return\n\n  def generateCPreprocessorGuesses(self):\n    '''Determines the C preprocessor from CPP, then --with-cpp, then the C compiler'''\n    if 'with-cpp' in self.argDB:\n      yield self.argDB['with-cpp']\n    elif 'CPP' in self.argDB:\n      yield self.argDB['CPP']\n    else:\n      yield self.CC+' -E'\n      yield self.CC+' --use cpp32'\n    return\n\n  def checkCPreprocessor(self):\n    '''Locate a functional C preprocessor'''\n    for compiler in self.generateCPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CPP'):\n          self.pushLanguage('C')\n          if not self.checkPreprocess('#include <stdlib.h>\\n'):\n            raise RuntimeError('Cannot preprocess C with '+self.CPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    raise RuntimeError('Cannot find a C preprocessor')\n    return\n\n  def generateCUDACompilerGuesses(self):\n    '''Determine the CUDA compiler using CUDAC, then --with-cudac\n       - Any given category can be excluded'''\n    if hasattr(self, 'CUDAC'):\n      yield self.CUDAC\n      raise RuntimeError('Error: '+self.mesg)\n    elif 'with-cudac' in self.argDB:\n      yield self.argDB['with-cudac']\n      raise RuntimeError('CUDA compiler you provided with -with-cudac='+self.argDB['with-cudac']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'CUDAC' in self.argDB:\n      yield self.argDB['CUDAC']\n      raise RuntimeError('CUDA compiler you provided with -CUDAC='+self.argDB['CUDAC']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'with-cuda-dir' in self.argDB:\n      nvccPath = os.path.join(self.argDB['with-cuda-dir'], 'bin','nvcc')\n      yield nvccPath\n    else:\n      yield 'nvcc'\n      yield os.path.join('/Developer','NVIDIA','CUDA-6.5','bin','nvcc')\n      yield os.path.join('/usr','local','cuda','bin','nvcc')\n    return\n\n  def checkCUDACompiler(self):\n    '''Locate a functional CUDA compiler'''\n    if ('with-cudac' in self.argDB and self.argDB['with-cudac'] == '0'):\n      if 'CUDAC' in self.argDB:\n        del self.argDB['CUDAC']\n      return\n    self.mesg = ''\n    for compiler in self.generateCUDACompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAC'):\n          self.checkCompiler('CUDA')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.CUDAC+' --version', log = self.log)\n          compilerVersion = compilerVersion[0]\n          compilerVersion = compilerVersion.split()\n          i = 0\n          for word in compilerVersion:\n            i = i+1\n            if word == 'release':\n              break\n          self.compilerVersionCUDA = compilerVersion[i].strip(',')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing CUDA compiler: '+str(e))\n        self.delMakeMacro('CUDAC')\n        del self.CUDAC\n    return\n\n  def generateCUDAPreprocessorGuesses(self):\n    '''Determines the CUDA preprocessor from --with-cudacpp, then CUDAPP, then the CUDA compiler'''\n    if 'with-cudacpp' in self.argDB:\n      yield self.argDB['with-cudacpp']\n    elif 'CUDAPP' in self.argDB:\n      yield self.argDB['CUDAPP']\n    else:\n      if hasattr(self, 'CUDAC'):\n        yield self.CUDAC+' -E'\n    return\n\n  def checkCUDAPreprocessor(self):\n    '''Locate a functional CUDA preprocessor'''\n    for compiler in self.generateCUDAPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CUDAPP'):\n          self.pushLanguage('CUDA')\n          if not self.checkPreprocess('#include <stdlib.h>\\n__global__ void testFunction() {return;};'):\n            raise RuntimeError('Cannot preprocess CUDA with '+self.CUDAPP+'.')\n          self.popLanguage()\n          return\n      except RuntimeError as e:\n        self.popLanguage()\n    return\n\n  def generateHIPCompilerGuesses(self):\n    '''Determine the HIP compiler using HIPCC, then --with-hipcc\n       - Any given category can be excluded'''\n    if hasattr(self, 'HIPCC'):\n      yield self.HIPCC\n      raise RuntimeError('Error: '+self.mesg)\n    elif 'with-hipcc' in self.argDB:\n      yield self.argDB['with-hipcc']\n      raise RuntimeError('HIPCC compiler you provided with -with-hipcc='+self.argDB['with-hipcc']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'HIPCC' in self.argDB:\n      yield self.argDB['HIPCC']\n      raise RuntimeError('HIP compiler you provided with -HIPCC='+self.argDB['HIPCC']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'with-hip-dir' in self.argDB:\n      hipPath = os.path.join(self.argDB['with-hip-dir'], 'bin','hipcc')\n      yield hipPath\n    else:\n      yield 'hipcc'\n      yield os.path.join('opt','rocm','bin','hipcc')\n    return\n\n  def checkHIPCompiler(self):\n    '''Locate a functional HIP compiler'''\n    if ('with-hipcc' in self.argDB and self.argDB['with-hipcc'] == '0'):\n      if 'HIPCC' in self.argDB:\n        del self.argDB['HIPCC']\n      return\n    self.mesg = 'in generateHIPCompilerGuesses'\n    for compiler in self.generateHIPCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'HIPCC'):\n          self.checkCompiler('HIP')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.HIPCC+' --version', log = self.log)\n          if 'nvcc' in compilerVersion and 'NVIDIA' in compilerVersion:\n            hipLine = compilerVersion.split('\\n')[0]\n            self.compilerVersionHIP = hipLine.split(':')[1]\n            nvccReleaseLine = compilerVersion.split('\\n')[-1]\n            import re\n            if 'release' in nvccReleaseLine:\n              self.compilerVersionCUDA = re.split('release',nvccReleaseLine)[1]\n            else:\n              raise RuntimeError('Error: Could not determine CUDA version from hipcc')\n          else:\n            self.compilerVersionHIP = compilerVersion[0]\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('HERE Error testing HIP compiler: '+str(e))\n        self.delMakeMacro('HIPCC')\n        del self.HIPCC\n    return\n\n  def generateHIPPreprocessorGuesses(self):\n    ''' Placeholder for now '''\n    return\n\n  def checkHIPPreprocessor(self):\n    ''' Placeholder for now '''\n    return\n\n  def generateSYCLCompilerGuesses(self):\n    '''Determine the SYCL compiler using SYCLCXX, then --with-syclcxx\n       - Any given category can be excluded'''\n    if hasattr(self, 'SYCLCXX'):\n      yield self.SYCLCXX\n      raise RuntimeError('Error: '+self.mesg)\n    elif 'with-syclcxx' in self.argDB:\n      yield self.argDB['with-syclcxx']\n      raise RuntimeError('SYCLCXX compiler you provided with -with-syclxx='+self.argDB['with-syclxx']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'SYCLCXX' in self.argDB:\n      yield self.argDB['SYCLCXX']\n      raise RuntimeError('SYCLCXX compiler you provided with -SYCLCXX='+self.argDB['SYCLCXX']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'with-sycl-dir' in self.argDB:\n      syclPath = os.path.join(self.argDB['with-sycl-dir'], 'bin','dpcpp')\n      yield syclPath\n    return\n\n  def checkSYCLCompiler(self):\n    '''Locate a functional SYCL compiler'''\n    if ('with-syclcxx' in self.argDB and self.argDB['with-syclcxx'] == '0'):\n      if 'SYCLCXX' in self.argDB:\n        del self.argDB['SYCLCXX']\n      return\n    self.mesg = 'in generateSYCLCompilerGuesses'\n    for compiler in self.generateSYCLCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'SYCLCXX'):\n          self.checkCompiler('SYCL')\n          # Put version info into the log\n          compilerVersion = self.executeShellCommand(self.SYCLCXX+' --version', log = self.log)\n          compilerVersion = compilerVersion[0]\n          compilerVersoin = compilerVersion.partition('Compiler')[-1].strip()\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.delMakeMacro('SYCLCXX')\n        del self.SYCLCXX\n    return\n\n  def generateSYCLPreprocessorGuesses(self):\n    ''' Placeholder for now '''\n    return\n\n  def checkSYCLPreprocessor(self):\n    ''' Placeholder for now '''\n    return\n\n  def generateCxxCompilerGuesses(self):\n    '''Determine the Cxx compiler'''\n\n    if hasattr(self, 'CXX'):\n      yield self.CXX\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-c++' in self.argDB:\n      raise RuntimeError('Keyword --with-c++ is WRONG, use --with-cxx')\n    if 'with-CC' in self.argDB:\n      raise RuntimeError('Keyword --with-CC is WRONG, use --with-cxx')\n\n    if 'with-cxx' in self.argDB:\n      if self.argDB['with-cxx'] == 'gcc': raise RuntimeError('Cannot use C compiler gcc as the C++ compiler passed in with --with-cxx')\n      if self.isWindows(self.argDB['with-cxx'], self.log):\n        yield 'win32fe '+self.argDB['with-cxx']\n      else:\n        yield self.argDB['with-cxx']\n      raise RuntimeError('C++ compiler you provided with -with-cxx='+self.argDB['with-cxx']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'CXX' in self.argDB:\n      if self.isWindows(self.argDB['CXX'], self.log):\n        yield 'win32fe '+self.argDB['CXX']\n      else:\n        yield self.argDB['CXX']\n      raise RuntimeError('C++ compiler you provided with -CXX='+self.argDB['CXX']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif self.usedMPICompilers and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiicpc')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpicxx')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'hcp')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpic++')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiCC')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpCC_r')\n      raise RuntimeError('bin/<mpiCC,mpicxx,hcp,mpCC_r> you provided with -with-mpi-dir='+self.argDB['with-mpi-dir']+' cannot be found or does not work. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.usedMPICompilers:\n        # TODO: Should only look for the MPI CXX compiler related to the found MPI C compiler\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_CC = self.crayCrossCompiler('CC')\n          if cross_CC:\n            self.cross_CC = cross_CC\n            self.log.write('Cray system using C++ cross compiler:'+cross_CC+'\\n')\n          yield 'CC'\n          if cross_CC: delattr(self, 'cross_CC')\n        yield 'mpicxx'\n        yield 'mpiicpc'\n        yield 'mpCC_r'\n        yield 'mpiCC'\n        yield 'mpic++'\n        yield 'mpCC'\n        yield 'mpxlC'\n      else:\n        #attempt to match c++ compiler with c compiler\n        if self.CC.find('win32fe cl') >= 0:\n          yield 'win32fe cl'\n        elif self.CC.find('win32fe icl') >= 0:\n          yield 'win32fe icl'\n        elif self.CC == 'gcc':\n          yield 'g++'\n        elif self.CC == 'clang':\n          yield 'clang++'\n        elif self.CC == 'icc':\n          yield 'icpc'\n        elif self.CC == 'xlc':\n          yield 'xlC'\n        yield 'g++'\n        yield 'clang++'\n        yield 'c++'\n        yield 'icpc'\n        yield 'CC'\n        yield 'cxx'\n        yield 'cc++'\n        yield 'xlC'\n        yield 'ccpc'\n        yield 'win32fe icl'\n        yield 'win32fe cl'\n        yield 'pgCC'\n        yield 'CC'\n        yield 'win32fe bcc32'\n    return\n\n  def checkCxxCompiler(self):\n    '''Locate a functional Cxx compiler'''\n    if 'with-cxx' in self.argDB and self.argDB['with-cxx'] == '0':\n      if 'CXX' in self.argDB:\n        del self.argDB['CXX']\n      return\n    self.mesg = ''\n    for compiler in self.generateCxxCompilerGuesses():\n      # Determine an acceptable extensions for the C++ compiler\n      for ext in ['.cc', '.cpp', '.C']:\n        self.framework.getCompilerObject('Cxx').sourceExtension = ext\n        try:\n          if self.getExecutable(compiler, resultName = 'CXX'):\n            self.checkCompiler('Cxx')\n            break\n        except RuntimeError as e:\n          self.mesg = str(e)\n          self.logPrint('Error testing C++ compiler: '+str(e))\n          if os.path.basename(self.CXX) in ['mpicxx', 'mpiCC']:\n            self.logPrint('  MPI installation '+str(self.CXX)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n          self.delMakeMacro('CXX')\n          del self.CXX\n      if hasattr(self, 'CXX'):\n        try:\n          self.executeShellCommand(self.CXX+' --version', log = self.log)\n        except:\n          pass\n        break\n    return\n\n  def generateCxxPreprocessorGuesses(self):\n    '''Determines the Cxx preprocessor from CXXPP, then --with-cxxpp, then the Cxx compiler'''\n    if 'with-cxxpp' in self.argDB:\n      yield self.argDB['with-cxxpp']\n    elif 'CXXPP' in self.argDB:\n      yield self.argDB['CXXPP']\n    else:\n      yield self.CXX+' -E'\n      yield self.CXX+' --use cpp32'\n    return\n\n  def checkCxxPreprocessor(self):\n    '''Locate a functional Cxx preprocessor'''\n    if not hasattr(self, 'CXX'):\n      return\n    for compiler in self.generateCxxPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'CXXPP'):\n          self.pushLanguage('Cxx')\n          if not self.checkPreprocess('#include <cstdlib>\\n'):\n            raise RuntimeError('Cannot preprocess Cxx with '+self.CXXPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError as e:\n\n        if os.path.basename(self.CXXPP) in ['mpicxx', 'mpiCC']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('CXXPP')\n        del self.CXXPP\n    return\n\n  def generateFortranCompilerGuesses(self):\n    '''Determine the Fortran compiler'''\n\n    if hasattr(self, 'FC'):\n      yield self.FC\n      if self.argDB['download-mpich']: mesg ='with downloaded MPICH'\n      elif self.argDB['download-openmpi']: mesg ='with downloaded OpenMPI'\n      else: mesg = ''\n      raise RuntimeError('Error '+mesg+': '+self.mesg)\n    elif 'with-fc' in self.argDB:\n      if self.isWindows(self.argDB['with-fc'], self.log):\n        yield 'win32fe '+self.argDB['with-fc']\n      else:\n        yield self.argDB['with-fc']\n      raise RuntimeError('Fortran compiler you provided with --with-fc='+self.argDB['with-fc']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif 'FC' in self.argDB:\n      if self.isWindows(self.argDB['FC'], self.log):\n        yield 'win32fe '+self.argDB['FC']\n      else:\n        yield self.argDB['FC']\n      yield self.argDB['FC']\n      raise RuntimeError('Fortran compiler you provided with -FC='+self.argDB['FC']+' cannot be found or does not work.'+'\\n'+self.mesg)\n    elif self.usedMPICompilers and 'with-mpi-dir' in self.argDB and os.path.isdir(os.path.join(self.argDB['with-mpi-dir'], 'bin')):\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpiifort')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpf90')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf95_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf90_r')\n      yield os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpxlf_r')\n      if os.path.isfile(os.path.join(self.argDB['with-mpi-dir'], 'bin', 'mpif90')):\n        raise RuntimeError('bin/mpif90 you provided with --with-mpi-dir='+self.argDB['with-mpi-dir']+' cannot be found or does not work.\\nRun with --with-fc=0 if you wish to use this MPI and disable Fortran. See https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-compilers')\n    else:\n      if self.usedMPICompilers:\n        # TODO: Should only look for the MPI Fortran compiler related to the found MPI C compiler\n        cray = os.getenv('CRAYPE_DIR')\n        if cray:\n          cross_fc = self.crayCrossCompiler('ftn')\n          if cross_fc:\n            self.cross_fc = cross_fc\n            self.log.write('Cray system using Fortran cross compiler:'+cross_fc+'\\n')\n          yield 'ftn'\n          if cross_fc: delattr(self, 'cross_fc')\n        yield 'mpif90'\n        yield 'mpiifort'\n        yield 'mpxlf_r'\n        yield 'mpxlf'\n        yield 'mpf90'\n      else:\n        #attempt to match fortran compiler with c compiler\n        if self.CC == 'gcc':\n          yield 'gfortran'\n        elif self.CC == 'clang':\n          yield 'gfortran'\n        elif self.CC == 'icc':\n          yield 'ifort'\n        elif self.CC == 'xlc':\n          yield 'xlf90'\n          yield 'xlf'\n        elif self.CC.find('win32fe cl') >= 0:\n          yield 'win32fe f90'\n          yield 'win32fe ifc'\n        elif self.CC.find('win32fe icl') >= 0:\n          yield 'win32fe ifc'\n        yield 'gfortran'\n        yield 'g95'\n        yield 'xlf90'\n        yield 'xlf'\n        yield 'f90'\n        yield 'lf95'\n        yield 'win32fe ifort'\n        yield 'win32fe ifl'\n        yield 'ifort'\n        yield 'ifc'\n        yield 'pgf90'\n        yield 'f95'\n        yield 'f90'\n    return\n\n  def checkFortranCompiler(self):\n    '''Locate a functional Fortran compiler'''\n    if 'with-fc' in self.argDB and self.argDB['with-fc'] == '0':\n      if 'FC' in self.argDB:\n        del self.argDB['FC']\n      return\n    self.mesg = ''\n    for compiler in self.generateFortranCompilerGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FC'):\n          self.checkCompiler('FC')\n          break\n      except RuntimeError as e:\n        self.mesg = str(e)\n        self.logPrint('Error testing Fortran compiler: '+str(e))\n        if os.path.basename(self.FC) in ['mpif90']:\n          self.logPrint(' MPI installation '+str(self.FC)+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI.')\n        self.delMakeMacro('FC')\n        del self.FC\n    if hasattr(self, 'FC'):\n      try:\n        self.executeShellCommand(self.FC+' --version', log = self.log)\n      except:\n        pass\n    return\n\n  def generateFortranPreprocessorGuesses(self):\n    '''Determines the Fortran preprocessor from FPP, then --with-fpp, then the Fortran compiler'''\n    if 'with-fpp' in self.argDB:\n      yield self.argDB['with-fpp']\n    elif 'FPP' in self.argDB:\n      yield self.argDB['FPP']\n    else:\n      yield self.FC+' -E'\n      yield self.FC+' --use cpp32'\n    return\n\n  def checkFortranPreprocessor(self):\n    '''Locate a functional Fortran preprocessor'''\n    if not hasattr(self, 'FC'):\n      return\n    for compiler in self.generateFortranPreprocessorGuesses():\n      try:\n        if self.getExecutable(compiler, resultName = 'FPP'):\n          self.pushLanguage('FC')\n          if not self.checkPreprocess('#define foo 10\\n'):\n            raise RuntimeError('Cannot preprocess Fortran with '+self.FPP+'.')\n          self.popLanguage()\n          break\n      except RuntimeError as e:\n\n        if os.path.basename(self.FPP) in ['mpif90']:\n          self.logPrint('MPI installation '+self.getCompiler()+' is likely incorrect.\\n  Use --with-mpi-dir to indicate an alternate MPI')\n        self.popLanguage()\n        self.delMakeMacro('FPP')\n        del self.FPP\n    return\n\n\n  def checkFortranComments(self):\n    '''Make sure fortran comment \"!\" works'''\n    self.pushLanguage('FC')\n    if not self.checkCompile('! comment'):\n      raise RuntimeError(self.getCompiler()+' cannot process fortran comments.')\n    self.logPrint('Fortran comments can use ! in column 1')\n    self.popLanguage()\n    return\n\n  def containsInvalidFlag(self, output):\n    '''If the output contains evidence that an invalid flag was used, return True'''\n    if (output.find('Unrecognized command line option') >= 0 or output.find('Unrecognised command line option') >= 0 or\n        output.find('unrecognized command line option') >= 0 or output.find('unrecognized option') >= 0 or output.find('unrecognised option') >= 0 or\n        output.find('not recognized') >= 0 or output.find('not recognised') >= 0 or\n        output.find('unknown option') >= 0 or output.find('unknown flag') >= 0 or output.find('Unknown switch') >= 0 or\n        output.find('ignoring option') >= 0 or output.find('ignored') >= 0 or\n        output.find('argument unused') >= 0 or output.find('not supported') >= 0 or\n        # When checking for the existence of 'attribute'\n        output.find('is unsupported and will be skipped') >= 0 or\n        output.find('illegal option') >= 0 or output.find('Invalid option') >= 0 or\n        (output.find('bad ') >= 0 and output.find(' option') >= 0) or\n        output.find('linker input file unused because linking not done') >= 0 or\n        output.find('PETSc Error') >= 0 or\n        output.find('Unbekannte Option') >= 0 or\n        output.find('warning: // comments are not allowed in this language') >= 0 or\n        output.find('no se reconoce la opci') >= 0) or output.find('non reconnue') >= 0:\n      return 1\n    return 0\n\n  def checkCompilerFlag(self, flag, includes = '', body = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag'''\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, error, status) = self.outputCompile(includes, body)\n    output += error\n    valid   = 1\n    setattr(self, flagsArg, oldFlags)\n    # Please comment each entry and provide an example line\n    if status:\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to nonzero status from link')\n    # Lahaye F95\n    if output.find('Invalid suboption') >= 0:\n      valid = 0\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting compiler flag '+flag+' due to \\n'+output)\n    return valid\n\n  def insertCompilerFlag(self, flag, compilerOnly):\n    '''DANGEROUS: Put in the compiler flag without checking'''\n    if not flag: return\n    flagsArg = self.getCompilerFlagsArg(compilerOnly)\n    setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n    self.log.write('Added '+self.language[-1]+' compiler flag '+flag+'\\n')\n    return\n\n  def addCompilerFlag(self, flag, includes = '', body = '', extraflags = '', compilerOnly = 0):\n    '''Determine whether the compiler accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkCompilerFlag(flag+' '+extraflags, includes, body, compilerOnly):\n      self.insertCompilerFlag(flag, compilerOnly)\n      return\n    raise RuntimeError('Bad compiler flag: '+flag)\n\n  def generatePICGuesses(self):\n    yield ''\n    if self.language[-1] == 'CUDA':\n      yield '-Xcompiler -fPIC'\n    elif config.setCompilers.Configure.isGNU(self.getCompiler(), self.log):\n      yield '-fPIC'\n    else:\n      yield '-PIC'\n      yield '-fPIC'\n      yield '-KPIC'\n      yield '-qpic'\n    return\n\n  def checkPIC(self):\n    '''Determine the PIC option for each compiler'''\n    self.usePIC = 0\n    useSharedLibraries = 'with-shared-libraries' in self.argDB and self.argDB['with-shared-libraries']\n    myLanguage = self.language[-1]\n    if not self.argDB['with-pic'] and not useSharedLibraries:\n      self.logPrint(\"Skip checking PIC options on user request\")\n      return\n    if self.argDB['with-pic'] and not useSharedLibraries:\n      # this is a flaw in configure; it is a legitimate use case where PETSc is built with PIC flags but not shared libraries\n      # to fix it the capability to build shared libraries must be enabled in configure if --with-pic=true even if shared libraries are off and this\n      # test must use that capability instead of using the default shared library build in that case which is static libraries\n      raise RuntimeError(\"Cannot determine compiler PIC flags if shared libraries is turned off\\nEither run using --with-shared-libraries or --with-pic=0 and supply the compiler PIC flag via CFLAGS, CXXXFLAGS, and FCFLAGS\\n\")\n    if self.sharedLibraries and self.mainLanguage == 'C': languages = []\n    else: languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    if hasattr(self, 'HIPCC'):\n      languages.append('HIP')\n    if hasattr(self, 'SYCLCXX'):\n      languages.append('SYCL')\n    for language in languages:\n      self.pushLanguage(language)\n      if language in ['C','Cxx','CUDA','HIP','SYCL']:\n        includeLine = _picTestIncludes()\n      else:\n        includeLine = '      function foo(a)\\n      real:: a,x,bar\\n      common /xx/ x\\n      x=a\\n      foo = bar(x)\\n      end\\n'\n      compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n      oldCompilerFlags = getattr(self, compilerFlagsArg)\n      for testFlag in self.generatePICGuesses():\n        if testFlag:\n          self.logPrint('Trying '+language+' compiler flag '+testFlag+' for PIC code')\n        else:\n          self.logPrint('Trying '+language+' for PIC code without any compiler flag')\n        acceptedPIC = 1\n        try:\n          self.addCompilerFlag(testFlag, compilerOnly = 1)\n          acceptedPIC = self.checkLink(includes = includeLine, body = None, codeBegin = '', codeEnd = '', cleanup = 1, shared = 1, linkLanguage = myLanguage)\n        except RuntimeError:\n          acceptedPIC = 0\n        if not acceptedPIC:\n          self.logPrint('Rejected '+language+' compiler flag '+testFlag+' because shared linker cannot handle it')\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n          continue\n        if testFlag:\n          self.logPrint('Accepted '+language+' compiler flag '+testFlag+' for PIC code')\n        else:\n          self.logPrint('Accepted '+language+' PIC code without compiler flag')\n        self.isPIC = 1\n        break\n      self.popLanguage()\n    return\n\n  def checkLargeFileIO(self):\n    # check for large file support with 64bit offset\n    if not self.argDB['with-large-file-io']:\n      return\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      if self.checkCompile('#include <unistd.h>','#ifndef _LFS64_LARGEFILE \\n#error no largefile defines \\n#endif'):\n        try:\n          self.addCompilerFlag('-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64',compilerOnly=1)\n        except RuntimeError as e:\n          self.logPrint('Error adding ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      else:\n        self.logPrint('Rejected ' +language+ ' flags -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64')\n      self.popLanguage()\n    return\n\n  def getArchiverFlags(self, archiver):\n    prog = os.path.basename(archiver).split(' ')[0]\n    flag = ''\n    if 'AR_FLAGS' in self.argDB:\n      flag = self.argDB['AR_FLAGS']\n    elif prog.endswith('ar'):\n      flag = 'cr'\n    elif prog == 'win32fe':\n      args = os.path.basename(archiver).split(' ')\n      if 'lib' in args:\n        flag = '-a'\n      elif 'tlib' in args:\n        flag = '-a -P512'\n    if prog.endswith('ar') and not (self.isSolarisAR(prog, self.log) or self.isAIXAR(prog, self.log)):\n      self.FAST_AR_FLAGS = 'Scq'\n    else:\n      self.FAST_AR_FLAGS = flag\n    self.framework.addMakeMacro('FAST_AR_FLAGS',self.FAST_AR_FLAGS )\n    return flag\n\n  def generateArchiverGuesses(self):\n    defaultAr = None\n    if 'with-ar' in self.argDB:\n      if self.isWindows(self.argDB['with-ar'], self.log):\n        defaultAr = 'win32fe '+self.argDB['with-ar']\n      else:\n        defaultAr = self.argDB['with-ar']\n    envAr = None\n    if 'AR' in self.argDB:\n      if self.isWindows(self.argDB['AR'], self.log):\n        envAr = 'win32fe '+self.argDB['AR']\n      else:\n        envAr = self.argDB['AR']\n    defaultRanlib = None\n    if 'with-ranlib' in self.argDB:\n      defaultRanlib = self.argDB['with-ranlib']\n    envRanlib = None\n    if 'RANLIB' in self.argDB:\n      envRanlib = self.argDB['RANLIB']\n    if defaultAr and defaultRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),defaultRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if defaultAr and envRanlib:\n      yield(defaultAr,self.getArchiverFlags(defaultAr),envRanlib)\n      raise RuntimeError('The archiver set --with-ar=\"'+defaultAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if envAr and defaultRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),defaultRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set --with-ranlib=\"'+defaultRanlib+'\".')\n    if envAr and envRanlib:\n      yield(envAr,self.getArchiverFlags(envAr),envRanlib)\n      raise RuntimeError('The archiver set --AR=\"'+envAr+'\" is incompatible with the ranlib set (perhaps in your environment) -RANLIB=\"'+envRanlib+'\".')\n    if defaultAr:\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'ranlib')\n      yield (defaultAr,self.getArchiverFlags(defaultAr),'true')\n      raise RuntimeError('You set a value for --with-ar='+defaultAr+'\", but '+defaultAr+' cannot be used\\n')\n    if envAr:\n      yield (envAr,self.getArchiverFlags(envAr),'ranlib')\n      yield (envAr,self.getArchiverFlags(envAr),'true')\n      raise RuntimeError('You set a value for -AR=\"'+envAr+'\" (perhaps in your environment), but '+envAr+' cannot be used\\n')\n    if defaultRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),defaultRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),defaultRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),defaultRanlib)\n      raise RuntimeError('You set --with-ranlib=\"'+defaultRanlib+'\", but '+defaultRanlib+' cannot be used\\n')\n    if envRanlib:\n      yield ('ar',self.getArchiverFlags('ar'),envRanlib)\n      yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),envRanlib)\n      yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),envRanlib)\n      raise RuntimeError('You set -RANLIB=\"'+envRanlib+'\" (perhaps in your environment), but '+defaultRanlib+' cannot be used\\n')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar',self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar',self.getArchiverFlags('ar'),'true')\n    # IBM with 64 bit pointers\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib -c')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'ranlib')\n    yield ('ar','-X64 '+self.getArchiverFlags('ar'),'true')\n    yield ('win32fe tlib',self.getArchiverFlags('win32fe tlib'),'true')\n    yield ('win32fe lib',self.getArchiverFlags('win32fe lib'),'true')\n    return\n\n  def checkArchiver(self):\n    '''Check that the archiver exists and can make a library usable by the compiler'''\n    objName    = os.path.join(self.tmpDir, 'conf1.o')\n    arcUnix    = os.path.join(self.tmpDir, 'libconf1.a')\n    arcWindows = os.path.join(self.tmpDir, 'libconf1.lib')\n    def checkArchive(command, status, output, error):\n      if error in [\"xiar: executing 'ar'\\n\"]: error = None\n      if error or status:\n        self.logError('archiver', status, output, error)\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('Archiver is not functional')\n      return\n    def checkRanlib(command, status, output, error):\n      if error or status:\n        self.logError('ranlib', status, output, error)\n        if os.path.isfile(arcUnix):\n          os.remove(arcUnix)\n        raise RuntimeError('Ranlib is not functional with your archiver.  Try --with-ranlib=true if ranlib is unnecessary.')\n      return\n    oldLibs = self.LIBS\n    self.pushLanguage('C')\n    for (archiver, arflags, ranlib) in self.generateArchiverGuesses():\n      if not self.checkCompile('', 'int foo(int a) {\\n  return a+1;\\n}\\n\\n', cleanup = 0, codeBegin = '', codeEnd = ''):\n        raise RuntimeError('Compiler is not functional')\n      if os.path.isfile(objName):\n        os.remove(objName)\n      os.rename(self.compilerObj, objName)\n      if self.getExecutable(archiver, getFullPath = 1, resultName = 'AR'):\n        if self.getExecutable(ranlib, getFullPath = 1, resultName = 'RANLIB'):\n          arext = 'a'\n          try:\n            (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+arflags+' '+arcUnix+' '+objName, checkCommand = checkArchive, log = self.log)\n            (output, error, status) = config.base.Configure.executeShellCommand(self.RANLIB+' '+arcUnix, checkCommand = checkRanlib, log = self.log)\n          except RuntimeError as e:\n            self.logPrint(str(e))\n            continue\n          self.LIBS = '-L'+self.tmpDir+' -lconf1 ' + oldLibs\n          success =  self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n          os.rename(arcUnix, arcWindows)\n          if not success:\n            arext = 'lib'\n            success = self.checkLink('extern int foo(int);', '  int b = foo(1);  if (b);\\n')\n            os.remove(arcWindows)\n            if success:\n              break\n          else:\n            os.remove(arcWindows)\n            break\n    else:\n      if os.path.isfile(objName):\n        os.remove(objName)\n      self.LIBS = oldLibs\n      self.popLanguage()\n      raise RuntimeError('Could not find a suitable archiver.  Use --with-ar to specify an archiver.')\n    self.AR_FLAGS      = arflags\n    self.AR_LIB_SUFFIX = arext\n    self.framework.addMakeMacro('AR_FLAGS', self.AR_FLAGS)\n    self.addMakeMacro('AR_LIB_SUFFIX', self.AR_LIB_SUFFIX)\n    os.remove(objName)\n    self.LIBS = oldLibs\n    self.popLanguage()\n    return\n\n  def checkArchiverRecipeArgfile(self):\n    '''Checks if AR handles @ notation'''\n    def checkArchiverArgfile(command, status, output, error):\n      if error or status:\n        self.logError('archiver', status, output, error)\n        if os.path.isfile(objName):\n          os.remove(objName)\n        raise RuntimeError('ArchiverArgfile error')\n      return\n    oldDir = os.getcwd()\n    os.chdir(self.tmpDir)\n    try:\n      objName = 'checkRecipeArgfile.o'\n      obj = open(objName, 'a').close()\n      argsName = 'checkRecipeArgfile.args'\n      args = open(argsName, 'a')\n      args.write(objName)\n      args.close()\n      archiveName = 'checkRecipeArgfile.'+self.AR_LIB_SUFFIX\n      (output, error, status) = config.base.Configure.executeShellCommand(self.AR+' '+self.AR_FLAGS+' '+archiveName+' @'+argsName,checkCommand = checkArchiverArgfile, log = self.log)\n      os.remove(objName)\n      os.remove(argsName)\n      os.remove(archiveName)\n      if not status:\n        self.framework.addMakeMacro('AR_ARGFILE','yes')\n    except RuntimeError:\n      pass\n    os.chdir(oldDir)\n\n  def setStaticLinker(self):\n    language = self.language[-1]\n    return self.framework.setSharedLinkerObject(language, self.framework.getLanguageModule(language).StaticLinker(self.argDB))\n\n  def generateSharedLinkerGuesses(self):\n    if not self.argDB['with-shared-libraries']:\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n      raise RuntimeError('Archiver failed static link check')\n    if 'with-shared-ld' in self.argDB:\n      yield (self.argDB['with-shared-ld'], [], 'so')\n    if 'LD_SHARED' in self.argDB:\n      yield (self.argDB['LD_SHARED'], [], 'so')\n    if Configure.isDarwin(self.log):\n      if 'with-shared-ld' in self.argDB:\n        yield (self.argDB['with-shared-ld'], ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module', '-undefined dynamic_lookup', '-multiply_defined suppress', '-no_compact_unwind'], 'dylib')\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      # C++ compiler default\n      yield (self.CXX, ['-shared'], 'so')\n      yield (self.CXX, ['-dynamic'], 'so')\n    # C compiler default\n    yield (self.CC, ['-shared'], 'so')\n    yield (self.CC, ['-dynamic'], 'so')\n    yield (self.CC, ['-qmkshrobj'], 'so')\n    yield (self.CC, ['-shared'], 'dll')\n    # Windows default\n    if self.CC.find('win32fe') >=0:\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-LD'], 'dll')\n      yield (self.CC, ['-LD'], 'dll')\n    # Solaris default\n    if Configure.isSolaris(self.log):\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-G'], 'so')\n      yield (self.CC, ['-G'], 'so')\n    # If user does not explicitly enable shared-libraries - disable shared libraries and default to static linker\n    if not 'with-shared-libraries' in self.framework.clArgDB:\n      self.argDB['with-shared-libraries'] = 0\n      self.setStaticLinker()\n      self.staticLinker = self.AR\n      self.staticLibraries = 1\n      self.LDFLAGS = ''\n      yield (self.AR, [], self.AR_LIB_SUFFIX)\n    raise RuntimeError('Exhausted all shared linker guesses. Could not determine how to create a shared library!')\n\n  def checkSharedLinker(self):\n    '''Check that the linker can produce shared libraries'''\n    self.sharedLibraries = 0\n    self.staticLibraries = 0\n    for linker, flags, ext in self.generateSharedLinkerGuesses():\n      self.logPrint('Checking shared linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'LD_SHARED'):\n        for picFlag in self.generatePICGuesses():\n          self.logPrint('Trying '+self.language[-1]+' compiler flag '+picFlag)\n          compilerFlagsArg = self.getCompilerFlagsArg(1) # compiler only\n          oldCompilerFlags = getattr(self, compilerFlagsArg)\n          accepted = 1\n          try:\n            self.addCompilerFlag(picFlag,compilerOnly=1)\n          except RuntimeError:\n            accepted = 0\n          if accepted:\n            goodFlags = list(filter(self.checkLinkerFlag, flags))\n            self.sharedLinker = self.LD_SHARED\n            self.sharedLibraryFlags = goodFlags\n            self.sharedLibraryExt = ext\n            if ext == 'dll':\n              dllexport = '__declspec(dllexport) '\n              dllimport = '__declspec(dllimport) '\n            else:\n              dllexport = ''\n              dllimport = ''\n            # using printf appears to correctly identify non-pic code on X86_64\n            if self.checkLink(includes = _picTestIncludes(dllexport), codeBegin = '', codeEnd = '', cleanup = 0, shared = 1):\n              oldLib  = self.linkerObj\n              oldLibs = self.LIBS\n              self.LIBS += ' -L'+self.tmpDir+' -lconftest'\n              accepted = self.checkLink(includes = dllimport+'int foo(void);', body = 'int ret = foo();\\nif (ret) {}\\n')\n              os.remove(oldLib)\n              self.LIBS = oldLibs\n              if accepted:\n                self.sharedLibraries = 1\n                self.logPrint('Using shared linker '+self.sharedLinker+' with flags '+str(self.sharedLibraryFlags)+' and library extension '+self.sharedLibraryExt)\n                break\n          self.logPrint('Rejected '+self.language[-1]+' compiler flag '+picFlag+' because it was not compatible with shared linker '+linker+' using flags '+str(flags))\n          setattr(self, compilerFlagsArg, oldCompilerFlags)\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        if self.sharedLibraries: break\n        self.delMakeMacro('LD_SHARED')\n        del self.LD_SHARED\n        del self.sharedLinker\n    return\n\n  def checkLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag'''\n    flagsArg = self.getLinkerFlagsArg()\n    oldFlags = getattr(self, flagsArg)\n    setattr(self, flagsArg, oldFlags+' '+flag)\n    (output, status) = self.outputLink('', '')\n    valid = 1\n    if status:\n      valid = 0\n      self.logPrint('Rejecting linker flag '+flag+' due to nonzero status from link')\n    if self.containsInvalidFlag(output):\n      valid = 0\n      self.logPrint('Rejecting '+self.language[-1]+' linker flag '+flag+' due to \\n'+output)\n    if valid:\n      self.logPrint('Valid '+self.language[-1]+' linker flag '+flag)\n    setattr(self, flagsArg, oldFlags)\n    return valid\n\n  def addLinkerFlag(self, flag):\n    '''Determine whether the linker accepts the given flag, and add it if valid, otherwise throw an exception'''\n    if self.checkLinkerFlag(flag):\n      flagsArg = self.getLinkerFlagsArg()\n      setattr(self, flagsArg, getattr(self, flagsArg)+' '+flag)\n      return\n    raise RuntimeError('Bad linker flag: '+flag)\n\n  def checkLinkerMac(self):\n    '''Tests some Apple Mac specific linker flags'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC','HIP':'HIPCC','SYCL':'SYCLCXX'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Wl,-bind_at_load','-Wl,-multiply_defined,suppress', '-Wl,-multiply_defined -Wl,suppress', '-Wl,-commons,use_dylibs', '-Wl,-search_paths_first', '-Wl,-no_compact_unwind']:\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n          linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n          val.append(testFlag)\n          setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkLinkerWindows(self):\n    '''Turns off linker warning about unknown .o files extension'''\n    langMap = {'C':'CC','FC':'FC','Cxx':'CXX','CUDA':'CUDAC','HIP':'HIPCC','SYCL':'SYCLCXX'}\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    for language in languages:\n      self.pushLanguage(language)\n      for testFlag in ['-Qwd10161']:  #Warning for Intel icl,  there appear to be no way to remove warnings with Microsoft cl\n        if self.checkLinkerFlag(testFlag):\n          # expand to CC_LINKER_FLAGS or CXX_LINKER_FLAGS or FC_LINKER_FLAGS\n          linker_flag_var = langMap[language]+'_LINKER_FLAGS'\n          val = getattr(self,linker_flag_var)\n          val.append(testFlag)\n          setattr(self,linker_flag_var,val)\n      self.popLanguage()\n    return\n\n  def checkSharedLinkerPaths(self):\n    '''Determine the shared linker path options\n       - IRIX: -rpath\n       - Linux, OSF: -Wl,-rpath,\n       - Solaris: -R\n       - FreeBSD: -Wl,-R,'''\n    languages = ['C']\n    if hasattr(self, 'CXX'):\n      languages.append('Cxx')\n    if hasattr(self, 'FC'):\n      languages.append('FC')\n    if hasattr(self, 'CUDAC'):\n      languages.append('CUDA')\n    if hasattr(self, 'HIPCC'):\n      languages.append('HIP')\n    if hasattr(self, 'SYCLCXX'):\n      languages.append('SYCL')\n    for language in languages:\n      flag = '-L'\n      self.pushLanguage(language)\n      # test '-R' before '-rpath' as sun compilers [c,fortran] don't give proper errors with wrong options.\n      if not Configure.isDarwin(self.log):\n        testFlags = ['-Wl,-rpath,', '-R','-rpath ' , '-Wl,-R,']\n      else:\n        testFlags = ['-Wl,-rpath,']\n      # test '-R' before '-Wl,-rpath' for SUN compilers [as cc on linux accepts -Wl,-rpath, but  f90 & CC do not.\n      if self.isSun(self.framework.getCompiler(), self.log):\n        testFlags.insert(0,'-R')\n      for testFlag in testFlags:\n        self.logPrint('Trying '+language+' linker flag '+testFlag)\n        if self.checkLinkerFlag(testFlag+os.path.abspath(os.getcwd())):\n          flag = testFlag\n          break\n        else:\n          self.logPrint('Rejected '+language+' linker flag '+testFlag)\n      self.popLanguage()\n      setattr(self, language+'SharedLinkerFlag', flag)\n    return\n\n  def checkLibC(self):\n    '''Test whether we need to explicitly include libc in shared linking\n       - Mac OSX requires an explicit reference to libc for shared linking'''\n    self.explicitLibc = None\n    if self.staticLibraries:\n      return\n    tmpCompilerDefines   = self.compilerDefines\n    self.compilerDefines = ''\n    code = '#include <stdlib.h> \\nint foo(void) {void *chunk = malloc(31); free(chunk); return 0;}\\n'\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking does not require an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      return\n    oldLibs = self.LIBS\n    self.LIBS += '-lc '\n    if self.checkLink(includes = code, codeBegin = '', codeEnd = '', shared = 1):\n      self.logPrint('Shared linking requires an explicit libc reference')\n      self.compilerDefines = tmpCompilerDefines\n      self.explicitLibc = ['libc.so']\n      return\n    self.LIBS = oldLibs\n    self.compilerDefines = tmpCompilerDefines\n    self.logPrint('*** WARNING *** Shared linking may not function on this architecture')\n    self.staticLibrary=1\n    self.sharedLibrary=0\n\n  def generateDynamicLinkerGuesses(self):\n    if 'with-dynamic-ld' in self.argDB:\n      yield (self.argDB['with-dynamic-ld'], [], 'so')\n    # Mac OSX\n    if Configure.isDarwin(self.log):\n      if 'with-dynamic-ld' in self.argDB:\n        yield (self.argDB['with-dynamic-ld'], ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n      if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n        yield (self.CXX, ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n      yield (self.CC, ['-dynamiclib -single_module -undefined dynamic_lookup -multiply_defined suppress'], 'dylib')\n    # Shared default\n    if hasattr(self, 'sharedLinker'):\n      yield (self.sharedLinker, self.sharedLibraryFlags, 'so')\n    # C++ Compiler default\n    if hasattr(self, 'CXX') and self.mainLanguage == 'Cxx':\n      yield (self.CXX, ['-shared'], 'so')\n    # C Compiler default\n    yield (self.CC, ['-shared'], 'so')\n    self.logPrint('Unable to find working dynamic linker')\n\n  def checkDynamicLinker(self):\n    '''Check that the linker can dynamicaly load shared libraries'''\n    self.dynamicLibraries = 0\n    if not self.headers.check('dlfcn.h'):\n      self.logPrint('Dynamic loading disabled since dlfcn.h was missing')\n      return\n    self.libraries.saveLog()\n    if not self.libraries.add('dl', ['dlopen', 'dlsym', 'dlclose']):\n      if not self.libraries.check('', ['dlopen', 'dlsym', 'dlclose']):\n        self.logWrite(self.libraries.restoreLog())\n        self.logPrint('Dynamic linking disabled since functions dlopen(), dlsym(), and dlclose() were not found')\n        return\n    self.logWrite(self.libraries.restoreLog())\n    for linker, flags, ext in self.generateDynamicLinkerGuesses():\n      self.logPrint('Checking dynamic linker '+linker+' using flags '+str(flags))\n      if self.getExecutable(linker, resultName = 'dynamicLinker'):\n        flagsArg = self.getLinkerFlagsArg()\n        goodFlags = list(filter(self.checkLinkerFlag, flags))\n        self.dynamicLibraryFlags = goodFlags\n        self.dynamicLibraryExt = ext\n        testMethod = 'foo'\n        if self.checkLink(includes = '#include <stdio.h>\\nint '+testMethod+'(void) {printf(\"test\");return 0;}\\n', codeBegin = '', codeEnd = '', cleanup = 0, shared = 'dynamic'):\n          oldLib  = self.linkerObj\n          code = '''\nvoid *handle = dlopen(\"%s\", 0);\nint (*foo)(void) = (int (*)(void)) dlsym(handle, \"foo\");\n\nif (!foo) {\n  printf(\"Could not load symbol\\\\n\");\n  return -1;\n}\nif ((*foo)()) {\n  printf(\"Invalid return from foo()\\\\n\");\n  return -1;\n}\nif (dlclose(handle)) {\n  printf(\"Could not close library\\\\n\");\n  return -1;\n}\n''' % oldLib\n          if self.checkLink(includes = '#include <dlfcn.h>\\n#include <stdio.h>', body = code):\n            self.dynamicLibraries = 1\n            self.logPrint('Using dynamic linker '+self.dynamicLinker+' with flags '+str(self.dynamicLibraryFlags)+' and library extension '+self.dynamicLibraryExt)\n            os.remove(oldLib)\n            break\n        if os.path.isfile(self.linkerObj): os.remove(self.linkerObj)\n        del self.dynamicLinker\n    return\n\n  def output(self):\n    '''Output module data as defines and substitutions'''\n    if hasattr(self, 'CC'):\n      self.addSubstitution('CC', self.CC)\n      self.addSubstitution('CFLAGS', self.CFLAGS)\n      self.addMakeMacro('CC_LINKER_SLFLAG', self.CSharedLinkerFlag)\n    if hasattr(self, 'CPP'):\n      self.addSubstitution('CPP', self.CPP)\n      self.addSubstitution('CPPFLAGS', self.CPPFLAGS)\n    if hasattr(self, 'CUDAC'):\n      self.addSubstitution('CUDAC', self.CUDAC)\n      self.addSubstitution('CUDAFLAGS', self.CUDAFLAGS)\n    if hasattr(self, 'CUDAPP'):\n      self.addSubstitution('CUDAPP', self.CUDAPP)\n      self.addSubstitution('CUDAPPFLAGS', self.CUDAPPFLAGS)\n    if hasattr(self, 'HIPCC'):\n      self.addSubstitution('HIPCC', self.HIPCC)\n      self.addSubstitution('HIPCCFLAGS', self.HIPCCFLAGS)\n    if hasattr(self, 'HIPPP'):\n      self.addSubstitution('HIPPP', self.HIPPP)\n      self.addSubstitution('HIPPPFLAGS', self.HIPPPFLAGS)\n    if hasattr(self, 'SYCLCXX'):\n      self.addSubstitution('SYCLCXX', self.SYCLCXX)\n      self.addSubstitution('SYCLCXXFLAGS', self.SYCLCXXFLAGS)\n    if hasattr(self, 'SYCLPP'):\n      self.addSubstitution('SYCLPP', self.SYCLPP)\n      self.addSubstitution('SYCLPPFLAGS', self.SYCLPPFLAGS)\n    if hasattr(self, 'CXX'):\n      self.addSubstitution('CXX', self.CXX)\n      self.addSubstitution('CXX_CXXFLAGS', self.CXX_CXXFLAGS)\n      self.addSubstitution('CXXFLAGS', self.CXXFLAGS)\n      self.addSubstitution('CXX_LINKER_SLFLAG', self.CxxSharedLinkerFlag)\n    else:\n      self.addSubstitution('CXX', '')\n    if hasattr(self, 'CXXPP'):\n      self.addSubstitution('CXXPP', self.CXXPP)\n      self.addSubstitution('CXXPPFLAGS', self.CXXPPFLAGS)\n    if hasattr(self, 'FC'):\n      self.addSubstitution('FC', self.FC)\n      self.addSubstitution('FFLAGS', self.FFLAGS)\n      self.addMakeMacro('FC_LINKER_SLFLAG', self.FCSharedLinkerFlag)\n    else:\n      self.addSubstitution('FC', '')\n    self.addSubstitution('LDFLAGS', self.LDFLAGS)\n    if hasattr(self, 'FPP'):\n      self.addSubstitution('FPP', self.FPP)\n      self.addSubstitution('FPPFLAGS', self.FPPFLAGS)\n    self.addSubstitution('LIBS', self.LIBS)\n    if hasattr(self, 'sharedLibraryFlags'):\n      self.addSubstitution('SHARED_LIBRARY_FLAG', ' '.join(self.sharedLibraryFlags))\n    else:\n      self.addSubstitution('SHARED_LIBRARY_FLAG','')\n    return\n\n  def updateMPICompilers(self, mpicc, mpicxx, mpifc):\n    '''Reset compilers by an external module aka MPI'''\n    self.CC = mpicc\n    self.delMakeMacro(\"CC\")\n\n    if hasattr(self, 'CXX'):\n      self.CXX = mpicxx\n      self.delMakeMacro(\"CXX\")\n\n    if hasattr(self, 'FC'):\n      self.FC = mpifc\n      self.delMakeMacro(\"FC\")\n\n    self.configure()\n    self.usedMPICompilers=1\n    return\n\n  def checkMPICompilerOverride(self):\n    '''Check if --with-mpi-dir is used along with CC CXX or FC compiler options.\n    This usually prevents mpi compilers from being used - so issue a warning'''\n\n    if 'with-mpi-dir' in self.argDB and self.argDB['with-mpi-compilers']:\n      optcplrs = [(['with-cc','CC'],['mpiicc','mpicc','mpcc','hcc','mpcc_r']),\n              (['with-fc','FC'],['mpiifort','mpif90','mpxlf95_r','mpxlf90_r','mpxlf_r','mpf90']),\n              (['with-cxx','CXX'],['mpiicpc','mpicxx','hcp','mpic++','mpiCC','mpCC_r'])]\n      for opts,cplrs in optcplrs:\n        for opt in opts:\n          if (opt in self.argDB  and self.argDB[opt] != '0'):\n            # check if corresponding mpi wrapper exists\n            for cplr in cplrs:\n              for mpicplr in [os.path.join(self.argDB['with-mpi-dir'], 'bin', cplr),os.path.join(self.argDB['with-mpi-dir'], 'intel64', 'bin', cplr)]:\n                if os.path.exists(mpicplr):\n                  msg = '--'+opt+'='+self.argDB[opt]+' is specified along with --with-mpi-dir='+self.argDB['with-mpi-dir']+' which implies using '+mpicplr+'.\\n\\\n  configure is confused and does not know which compiler to select and use! Please specify either [mpi] compilers or --with-mpi-dir - but not both!\\n\\\n  In most cases, specifying --with-mpi-dir - and not explicitly listing compilers could be preferable.'\n                  raise RuntimeError(msg)\n    return\n\n  def requireMpiLdPath(self):\n    '''OpenMPI wrappers require LD_LIBRARY_PATH set'''\n    if 'with-mpi-dir' in self.argDB:\n      libdir = os.path.join(self.argDB['with-mpi-dir'], 'lib')\n      if os.path.exists(os.path.join(libdir,'libopen-rte.so')):\n        Configure.addLdPath(libdir)\n        self.logPrint('Adding to LD_LIBRARY_PATH '+libdir)\n    return\n\n  def resetEnvCompilers(self):\n    ignoreEnvCompilers = ['CC','CXX','FC','F77','F90']\n    for envVal in ignoreEnvCompilers:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB or 'with-'+envVal.lower() in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables ******')\n        elif self.framework.argDB['with-xsdk-defaults'] and 'with-environment-variables' not in self.framework.clArgDB:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n because --with-xsdk-defaults was selected. Add --disable-environment-variables \\n to NOT use the environmental variables ******')\n\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n\n    ignoreEnv = ['CFLAGS','CXXFLAGS','FCFLAGS','FFLAGS','F90FLAGS','CPP','CPPFLAGS','CXXPP','CXXPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR','RANLIB']\n    for envVal in ignoreEnv:\n      if envVal in os.environ:\n        if envVal in self.framework.clArgDB:\n          self.logPrint(envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring since also set on command line')\n          del os.environ[envVal]\n        elif self.argDB['with-environment-variables']:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - using it \\n use ./configure --disable-environment-variables to NOT use the environmental variables******')\n        else:\n          self.logPrintBox('***** WARNING: '+envVal+' (set to '+os.environ[envVal]+') found in environment variables - ignoring \\n use ./configure '+envVal+'=$'+envVal+' if you really want to use that value ******')\n          del os.environ[envVal]\n    return\n\n\n  def checkEnvCompilers(self):\n    if 'with-environment-variables' in self.framework.clArgDB or 'with-xsdk-defaults' in self.framework.clArgDB:\n      envVarChecklist = ['CC','CFLAGS','CXX','CXXFLAGS','FC','FCFLAGS','F77','FFLAGS','F90','F90FLAGS','CPP','CPPFLAGS','CXXPP','CXXPPFLAGS','LDFLAGS','LIBS','MPI_DIR','RM','MAKEFLAGS','AR']\n      for ev in envVarChecklist:\n        if ev in os.environ:\n          self.argDB[ev] = os.environ[ev]\n\n    # abort if FCFLAGS and FFLAGS both set, but to different values\n    if 'FFLAGS' in self.argDB and 'FCFLAGS' in self.argDB:\n      if self.argDB['FCFLAGS'] != self.argDB['FFLAGS']:\n        raise RuntimeError('FCFLAGS and FFLAGS are both set, but with different values (FCFLAGS=%s, FFLAGS=%s)'%(self.argDB['FCFLAGS'],self.argDB['FFLAGS']))\n    return\n\n  def checkIntoShared(self,symbol,lib):\n    '''Check that a given library can be linked into a shared library'''\n    import sys\n    if not self.checkCompile(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}'):\n      raise RuntimeError('Unable to compile test file with symbol: '+symbol)\n    oldLibs = self.LIBS\n    self.LIBS = self.libraries.toStringNoDupes(lib) + ' '+self.LIBS\n    ret = self.checkLink(includes = 'char *'+symbol+'(void);\\n',body = 'return '+symbol+'();\\n', cleanup = 0, codeBegin = 'char* testroutine(void){', codeEnd = '}',shared =1)\n    self.LIBS = oldLibs\n    return ret\n\n  def configure(self):\n    self.mainLanguage = self.languages.clanguage\n    self.executeTest(self.resetEnvCompilers)\n    self.executeTest(self.checkEnvCompilers)\n    self.executeTest(self.checkMPICompilerOverride)\n    self.executeTest(self.requireMpiLdPath)\n    self.executeTest(self.checkInitialFlags)\n    self.executeTest(self.checkCCompiler)\n    self.executeTest(self.checkCPreprocessor)\n    self.executeTest(self.checkCUDACompiler)\n    self.executeTest(self.checkCUDAPreprocessor)\n    self.executeTest(self.checkHIPCompiler)\n    self.executeTest(self.checkHIPPreprocessor)\n    self.executeTest(self.checkSYCLCompiler)\n    self.executeTest(self.checkSYCLPreprocessor)\n    self.executeTest(self.checkCxxCompiler)\n    if hasattr(self, 'CXX'):\n      self.executeTest(self.checkCxxPreprocessor)\n    self.executeTest(self.checkFortranCompiler)\n    if hasattr(self, 'FC'):\n      self.executeTest(self.checkFortranPreprocessor)\n      self.executeTest(self.checkFortranComments)\n    self.executeTest(self.checkLargeFileIO)\n    self.executeTest(self.checkArchiver)\n    self.executeTest(self.checkArchiverRecipeArgfile)\n    self.executeTest(self.checkSharedLinker)\n    if Configure.isDarwin(self.log):\n      self.executeTest(self.checkLinkerMac)\n    if Configure.isCygwin(self.log):\n      self.executeTest(self.checkLinkerWindows)\n    self.executeTest(self.checkPIC)\n    self.executeTest(self.checkSharedLinkerPaths)\n    self.executeTest(self.checkLibC)\n    self.executeTest(self.checkDynamicLinker)\n    self.executeTest(self.output)\n    return\n\n  def no_configure(self):\n    if self.staticLibraries:\n      self.setStaticLinker()\n    return\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/config/BuildSystem/config/libraries.py": "import config.base\n\nimport os\nimport re\n\nclass Configure(config.base.Configure):\n  def __init__(self, framework, libraries = []):\n    config.base.Configure.__init__(self, framework)\n    self.headerPrefix = ''\n    self.substPrefix  = ''\n    self.libraries    = libraries\n    return\n\n  def setupDependencies(self, framework):\n    config.base.Configure.setupDependencies(self, framework)\n    self.setCompilers = framework.require('config.setCompilers', self)\n    self.compilers    = framework.require('config.compilers',    self)\n    self.headers      = framework.require('config.headers',      self)\n    return\n\n  def getLibArgumentList(self, library, with_rpath=True):\n    '''Return the proper link line argument for the given filename library as a list of options\n      - If the path is empty, return it unchanged\n      - If starts with - then return unchanged\n      - If the path ends in \".lib\" return it unchanged\n      - If the path is absolute and the filename is \"lib\"<name>, return -L<dir> -l<name> (optionally including rpath flag)\n      - If the filename is \"lib\"<name>, return -l<name>\n      - If the path ends in \".so\" return it unchanged\n      - If the path ends in \".o\" return it unchanged\n      - If the path is absolute, return it unchanged\n      - Otherwise return -l<library>'''\n    if not library:\n      return []\n    if library.startswith('${CC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.startswith('${FC_LINKER_SLFLAG}'):\n      return [library] if with_rpath else []\n    if library.lstrip()[0] == '-':\n      return [library]\n    if len(library) > 3 and library[-4:] == '.lib':\n      return [library.replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')]\n    if os.path.basename(library).startswith('lib'):\n      name = self.getLibName(library)\n      if ((len(library) > 2 and library[1] == ':') or os.path.isabs(library)):\n        flagName  = self.language[-1]+'SharedLinkerFlag'\n        flagSubst = self.language[-1].upper()+'_LINKER_SLFLAG'\n        dirname   = os.path.dirname(library).replace('\\\\ ',' ').replace(' ', '\\\\ ').replace('\\\\(','(').replace('(', '\\\\(').replace('\\\\)',')').replace(')', '\\\\)')\n        if dirname in ['/usr/lib','/lib','/usr/lib64','/lib64']:\n          return [library]\n        if with_rpath:\n          if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n            return [getattr(self.setCompilers, flagName)+dirname,'-L'+dirname,'-l'+name]\n          if flagSubst in self.argDB:\n            return [self.argDB[flagSubst]+dirname,'-L'+dirname,'-l'+name]\n        return ['-L'+dirname,'-l'+name]\n      else:\n        return ['-l'+name]\n    if os.path.splitext(library)[1] == '.so' or os.path.splitext(library)[1] == '.o':\n      return [library]\n    if os.path.isabs(library):\n      return [library]\n    return ['-l'+library]\n\n  def getLibArgument(self, library):\n    '''Same as getLibArgumentList - except it returns a string instead of list.'''\n    return  ' '.join(self.getLibArgumentList(library))\n\n  def getLibName(library):\n    if os.path.basename(library).startswith('lib'):\n      return os.path.splitext(os.path.basename(library))[0][3:]\n    return library\n  getLibName = staticmethod(getLibName)\n\n  def getDefineName(self, library):\n    return 'HAVE_LIB'+self.getLibName(library).upper().replace('-','_').replace('=','_').replace('+','_').replace('.', '_').replace('/','_')\n\n  def getDefineNameFunc(self, funcName):\n    return 'HAVE_'+ funcName.upper()\n\n  def haveLib(self, library):\n    return self.getDefineName(library) in self.defines\n\n  def add(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName AND adds it to $LIBS\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(libName, list): libName = [libName]\n    if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle):\n      self.logPrint('Adding '+str(libName)+' to LIBS')\n      # Note: this MUST be setCompilers since it can happen before dispatch names is made\n      self.setCompilers.LIBS = self.toString(libName)+' '+self.setCompilers.LIBS\n      return 1\n    return 0\n\n  def toString(self,libs):\n    '''Converts a list of libraries to a string suitable for a linker'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib)\n    return ' '.join(newlibs)\n\n  def toStringNoDupes(self,libs,with_rpath=True):\n    '''Converts a list of libraries to a string suitable for a linker, removes duplicates'''\n    '''Moves the flags that can be moved to the beginning of the string but always leaves the libraries and other items that must remain in the same order'''\n    newlibs = []\n    frame = 0\n    for lib in libs:\n      if frame:\n        newlibs += [lib]\n        frame   = 0\n      elif lib == '-framework':\n        newlibs += [lib]\n        frame = 1\n      else:\n        newlibs += self.getLibArgumentList(lib, with_rpath)\n    libs = newlibs\n    newldflags = []\n    newlibs = []\n    frame = 0\n    dupflags = ['-L']\n    flagName  = self.language[-1]+'SharedLinkerFlag'\n    if hasattr(self.setCompilers, flagName) and not getattr(self.setCompilers, flagName) is None:\n      dupflags.append(getattr(self.setCompilers, flagName))\n    for j in libs:\n      # remove duplicate -L, -Wl,-rpath options - and only consecutive -l options\n      if j in newldflags and any([j.startswith(flg) for flg in dupflags]): continue\n      if newlibs and j == newlibs[-1]: continue\n      if j.startswith('-l') or j.endswith('.lib') or j.endswith('.a') or j.endswith('.o') or j == '-Wl,-Bstatic' or j == '-Wl,-Bdynamic' or j == '-Wl,--start-group' or j == '-Wl,--end-group':\n        newlibs.append(j)\n      else:\n        newldflags.append(j)\n    liblist = ' '.join(newldflags + newlibs)\n    return liblist\n\n  def getShortLibName(self,lib):\n    '''returns the short name for the library. Valid names are foo -lfoo or libfoo.[a,so,lib]'''\n    if lib.startswith('-l'):\n      libname = lib[2:]\n      return libname\n    if lib.startswith('-'): # must be some compiler options - not a library\n      return ''\n    if lib.endswith('.a') or lib.endswith('.so') or lib.endswith('.lib'):\n      libname = os.path.splitext(os.path.basename(lib))[0]\n      if lib.startswith('lib'): libname = libname[3:]\n      return libname\n    # no match - assuming the given name is already in short notation\n    return lib\n\n  def check(self, libName, funcs, libDir = None, otherLibs = [], prototype = '', call = '', fortranMangle = 0, cxxMangle = 0, cxxLink = 0, functionDefine = 0, examineOutput=lambda ret,out,err:None):\n    '''Checks that the library \"libName\" contains \"funcs\", and if it does defines HAVE_LIB\"libName\"\n       - libDir may be a list of directories\n       - libName may be a list of library names'''\n    if not isinstance(funcs,list): funcs = [funcs]\n    if not isinstance(libName, list): libName = [libName]\n    def genPreamble(f, funcName):\n      # Construct prototype\n      if self.language[-1] == 'FC':\n        return ''\n      if prototype:\n        if isinstance(prototype, str):\n          pre = prototype\n        else:\n          pre = prototype[f]\n      else:\n        # We use char because int might match the return type of a gcc2 builtin and its argument prototype would still apply.\n        pre = 'char '+funcName+'();'\n      # Capture the function call in a static function so that any local variables are isolated from\n      # calls to other library functions.\n      return pre + '\\nstatic void _check_%s() { %s }' % (funcName, genCall(f, funcName, pre=True))\n    def genCall(f, funcName, pre=False):\n      if self.language[-1] != 'FC' and not pre:\n        return '_check_' + funcName + '();'\n      # Construct function call\n      if call:\n        if isinstance(call, str):\n          body = call\n        else:\n          body = call[f]\n      else:\n        body = funcName+'()'\n      if self.language[-1] != 'FC':\n        body += ';'\n      return body\n    # Handle Fortran mangling\n    if fortranMangle:\n      funcs = list(map(self.compilers.mangleFortranFunction, funcs))\n    if not funcs:\n      self.logPrint('No functions to check for in library '+str(libName)+' '+str(otherLibs))\n      return True\n    self.logPrint('Checking for functions ['+' '.join(funcs)+'] in library '+str(libName)+' '+str(otherLibs))\n    if self.language[-1] == 'FC':\n      includes = ''\n    else:\n      includes = '/* Override any gcc2 internal prototype to avoid an error. */\\n'\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n'''\n    includes += '\\n'.join([genPreamble(f, fname) for f, fname in enumerate(funcs)])\n    # Handle C++ mangling\n    if self.language[-1] == 'Cxx' and not cxxMangle:\n      includes += '''\n#ifdef __cplusplus\n}\n#endif\n'''\n    body = '\\n'.join([genCall(f, fname) for f, fname in enumerate(funcs)])\n    # Setup link line\n    oldLibs = self.setCompilers.LIBS\n    if libDir:\n      if not isinstance(libDir, list): libDir = [libDir]\n      for dir in libDir:\n        self.setCompilers.LIBS += ' -L'+dir\n    # new libs may/will depend on system libs so list new libs first!\n    # Matt, do not change this without talking to me\n    if libName and otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(libName+otherLibs) +' '+ self.setCompilers.LIBS\n    elif otherLibs:\n      self.setCompilers.LIBS = ' '+self.toString(otherLibs) +' '+ self.setCompilers.LIBS\n    elif libName:\n      self.setCompilers.LIBS = ' '+self.toString(libName) +' '+ self.setCompilers.LIBS\n    if cxxMangle: compileLang = 'Cxx'\n    else:         compileLang = self.language[-1]\n    if cxxLink: linklang = 'Cxx'\n    else: linklang = self.language[-1]\n    self.pushLanguage(compileLang)\n    found = 0\n    if self.checkLink(includes, body, linkLanguage=linklang, examineOutput=examineOutput):\n      found = 1\n      # define the symbol as found\n      if functionDefine: [self.addDefine(self.getDefineNameFunc(fname), 1) for f, fname in enumerate(funcs)]\n      # add to list of found libraries\n      elif libName:\n        for lib in libName:\n          shortlib = self.getShortLibName(lib)\n          if shortlib: self.addDefine(self.getDefineName(shortlib), 1)\n    self.setCompilers.LIBS = oldLibs\n    self.popLanguage()\n    return found\n\n  def checkClassify(self, libName, funcs, libDir=None, otherLibs=[], prototype='', call='', fortranMangle=0, cxxMangle=0, cxxLink=0):\n    '''Recursive decompose to rapidly classify functions as found or missing'''\n    import config\n    def functional(funcs):\n      named = config.NamedInStderr(funcs)\n      if self.check(libName, funcs, libDir, otherLibs, prototype, call, fortranMangle, cxxMangle, cxxLink):\n        return True\n      else:\n        return named.named\n    found, missing = config.classify(funcs, functional)\n    return found, missing\n\n  def checkMath(self):\n    '''Check for sin() in libm, the math library'''\n    self.math = None\n    funcs = ['sin', 'floor', 'log10', 'pow']\n    prototypes = ['#include <stdio.h>\\ndouble sin(double);',\n                  '#include <stdio.h>\\ndouble floor(double);',\n                  '#include <stdio.h>\\ndouble log10(double);',\n                  '#include <stdio.h>\\ndouble pow(double, double);']\n    calls = ['double x,y; scanf(\"%lf\",&x); y = sin(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = floor(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = log10(x); printf(\"%f\",y);\\n',\n             'double x,y; scanf(\"%lf\",&x); y = pow(x,x); printf(\"%f\",y);\\n']\n    if self.check('', funcs, prototype = prototypes, call = calls):\n      self.math = []\n    elif self.check('m', funcs, prototype = prototypes, call = calls):\n      self.math = ['libm.a']\n    self.logPrint('CheckMath: using math library '+str(self.math))\n    return\n\n  def checkMathErf(self):\n    '''Check for erf() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['erf'], prototype = ['#include <math.h>'], call = ['double (*checkErf)(double) = erf;double x = 0,y; y = (*checkErf)(x)']):\n      self.logPrint('erf() found')\n      self.addDefine('HAVE_ERF', 1)\n    else:\n      self.logPrint('Warning: erf() not found')\n    return\n\n  def checkMathTgamma(self):\n    '''Check for tgamma() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['tgamma'], prototype = ['#include <math.h>'], call = ['double (*checkTgamma)(double) = tgamma;double x = 0,y; y = (*checkTgamma)(x)']):\n      self.logPrint('tgamma() found')\n      self.addDefine('HAVE_TGAMMA', 1)\n    else:\n      self.logPrint('Warning: tgamma() not found')\n    return\n\n  def checkMathLgamma(self):\n    '''Check for lgamma() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['lgamma'], prototype = ['#include <math.h>\\n#include <stdlib.h>'], call = ['double (*checkLgamma)(double) = lgamma;double x = 1,y; y = (*checkLgamma)(x);if (y != 0.) abort()']):\n      self.logPrint('lgamma() found')\n      self.addDefine('HAVE_LGAMMA', 1)\n    elif not self.math is None and self.check(self.math, ['gamma'], prototype = ['#include <math.h>\\n#include <stdlib.h>'], call = ['double (*checkLgamma)(double) = gamma;double x = 1,y; y = (*checkLgamma)(x);if (y != 0.) abort()']):\n      self.logPrint('gamma() found')\n      self.addDefine('HAVE_LGAMMA', 1)\n      self.addDefine('HAVE_LGAMMA_IS_GAMMA', 1)\n    else:\n      self.logPrint('Warning: lgamma() and gamma() not found')\n    return\n\n  def checkMathFenv(self):\n    '''Checks if <fenv.h> can be used with FE_DFL_ENV'''\n    if not self.math is None and self.check(self.math, ['fesetenv'], prototype = ['#include <fenv.h>'], call = ['fesetenv(FE_DFL_ENV);']):\n      self.addDefine('HAVE_FENV_H', 1)\n    else:\n      self.logPrint('Warning: <fenv.h> with FE_DFL_ENV not found')\n    return\n\n  def checkMathLog2(self):\n    '''Check for log2() in libm, the math library'''\n    if not self.math is None and self.check(self.math, ['log2'], prototype = ['#include <math.h>'], call = ['double (*checkLog2)(double) = log2; double x = 2.5, y = (*checkLog2)(x)']):\n      self.logPrint('log2() found')\n      self.addDefine('HAVE_LOG2', 1)\n    else:\n      self.logPrint('Warning: log2() not found')\n    return\n\n  def checkRealtime(self):\n    '''Check for presence of clock_gettime() in realtime library (POSIX Realtime extensions)'''\n    self.rt = None\n    funcs = ['clock_gettime']\n    prototypes = ['#include <time.h>']\n    calls = ['struct timespec tp; clock_gettime(CLOCK_REALTIME,&tp);']\n    if self.check('', funcs, prototype=prototypes, call=calls):\n      self.logPrint('realtime functions are linked in by default')\n      self.rt = []\n    elif self.check('rt', funcs, prototype=prototypes, call=calls):\n      self.logPrint('Using librt for the realtime library')\n      self.rt = ['librt.a']\n    else:\n      self.logPrint('Warning: No realtime library found')\n    return\n\n  def checkDynamic(self):\n    '''Check for the header and libraries necessary for dynamic library manipulation'''\n    if 'with-dynamic-loading' in self.argDB and not self.argDB['with-dynamic-loading']: return\n    self.check(['dl'], 'dlopen')\n    self.headers.check('dlfcn.h')\n    return\n\n  def checkShared(self, includes, initFunction, checkFunction, finiFunction = None, checkLink = None, libraries = [], initArgs = '&argc, &argv', boolType = 'int', noCheckArg = 0, defaultArg = '', executor = None, timeout = 60):\n    '''Determine whether a library is shared\n       - initFunction(int *argc, char *argv[]) is called to initialize some static data\n       - checkFunction(int *check) is called to verify that the static data wer set properly\n       - finiFunction() is called to finalize the data, and may be omitted\n       - checkLink may be given as ana alternative to the one in base.Configure'''\n    isShared = 0\n    if checkLink is None:\n      checkLink = self.checkLink\n      configObj = self\n    else:\n      if hasattr(checkLink, '__self__'):\n        configObj = checkLink.__self__\n      else:\n        configObj = self\n\n    # Fix these flags\n    oldFlags = self.setCompilers.LIBS\n    self.setCompilers.LIBS = ' '+self.toString(libraries)+' '+self.setCompilers.LIBS\n\n    # Make a library which calls initFunction(), and returns checkFunction()\n    lib1Name = os.path.join(self.tmpDir, 'lib1.'+self.setCompilers.sharedLibraryExt)\n    if noCheckArg:\n      checkCode = 'isInitialized = '+checkFunction+'();'\n    else:\n      checkCode = checkFunction+'(&isInitialized);'\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint init(int argc,  char *argv[]) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s(%s);\n  %s\n  return (int) isInitialized;\n''' % (boolType, initFunction, initArgs, checkCode)\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib1Name)\n\n    # Make a library which calls checkFunction()\n    lib2Name = os.path.join(self.tmpDir, 'lib2.'+self.setCompilers.sharedLibraryExt)\n    codeBegin = '''\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint checkInit(void) {\n'''\n    body      = '''\n  %s isInitialized;\n\n  %s\n''' % (boolType, checkCode)\n    if finiFunction:\n      body += '  if (isInitialized) '+finiFunction+'();\\n'\n    body += '  return (int) isInitialized;\\n'\n    codeEnd   = '\\n}\\n'\n    if not checkLink(includes, body, cleanup = 0, codeBegin = codeBegin, codeEnd = codeEnd, shared = 1):\n      if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n      self.setCompilers.LIBS = oldFlags\n      raise RuntimeError('Could not complete shared library check')\n      return 0\n    if os.path.isfile(configObj.compilerObj): os.remove(configObj.compilerObj)\n    os.rename(configObj.linkerObj, lib2Name)\n\n    self.setCompilers.LIBS = oldFlags\n\n    # Make an executable that dynamically loads and calls both libraries\n    #   If the check returns true in the second library, the static data was shared\n    guard = self.headers.getDefineName('dlfcn.h')\n    if self.headers.headerPrefix:\n      guard = self.headers.headerPrefix+'_'+guard\n    defaultIncludes = '''\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef %s\n#include <dlfcn.h>\n#endif\n    ''' % guard\n    body = '''\n  int   argc    = 1;\n  char *argv[2] = {(char *) \"conftest\", NULL};\n  void *lib;\n  int (*init)(int, char **);\n  int (*checkInit)(void);\n\n  lib = dlopen(\"'''+lib1Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib1.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  init = (int (*)(int, char **)) dlsym(lib, \"init\");\n  if (!init) {\n    fprintf(stderr, \"Could not find initialization function\\\\n\");\n    exit(1);\n  }\n  if (!(*init)(argc, argv)) {\n    fprintf(stderr, \"Could not initialize library\\\\n\");\n    exit(1);\n  }\n  lib = dlopen(\"'''+lib2Name+'''\", RTLD_LAZY);\n  if (!lib) {\n    fprintf(stderr, \"Could not open lib2.so: %s\\\\n\", dlerror());\n    exit(1);\n  }\n  checkInit = (int (*)(void)) dlsym(lib, \"checkInit\");\n  if (!checkInit) {\n    fprintf(stderr, \"Could not find initialization check function\\\\n\");\n    exit(1);\n  }\n  if (!(*checkInit)()) {\n    fprintf(stderr, \"Did not link with shared library\\\\n\");\n    exit(2);\n  }\n  '''\n    oldLibs = self.setCompilers.LIBS\n    if self.haveLib('dl'):\n      self.setCompilers.LIBS += ' -ldl'\n    isShared = 0\n    try:\n      isShared = self.checkRun(defaultIncludes, body, defaultArg = defaultArg, executor = executor, timeout = timeout)\n    except RuntimeError as e:\n      if executor and str(e).find('Runaway process exceeded time limit') > -1:\n        raise RuntimeError('Timeout: Unable to run MPI program with '+executor+'\\n\\\n    (1) make sure this is the correct program to run MPI jobs\\n\\\n    (2) your network may be misconfigured; see https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-network-misconfigure\\n\\\n    (3) you may have VPN running whose network settings may not play nice with MPI\\n')\n\n    self.setCompilers.LIBS = oldLibs\n    if os.path.isfile(lib1Name) and self.framework.doCleanup: os.remove(lib1Name)\n    if os.path.isfile(lib2Name) and self.framework.doCleanup: os.remove(lib2Name)\n    if isShared:\n      self.logPrint('Library was shared')\n    else:\n      self.logPrint('Library was not shared')\n    return isShared\n\n  def isBGL(self):\n    '''Returns true if compiler is IBM cross compiler for BGL'''\n    if not hasattr(self, '_isBGL'):\n      self.logPrint('**********Checking if running on BGL/IBM detected')\n      if (self.check('', 'bgl_perfctr_void') or self.check('','ADIOI_BGL_Open')) and self.check('', '_xlqadd'):\n        self.logPrint('*********BGL/IBM detected')\n        self._isBGL = 1\n      else:\n        self.logPrint('*********BGL/IBM test failure')\n        self._isBGL = 0\n    return self._isBGL\n\n  def configure(self):\n    list(map(lambda args: self.executeTest(self.check, list(args)), self.libraries))\n    self.executeTest(self.checkMath)\n    self.executeTest(self.checkMathErf)\n    self.executeTest(self.checkMathTgamma)\n    self.executeTest(self.checkMathLgamma)\n    self.executeTest(self.checkMathFenv)\n    self.executeTest(self.checkMathLog2)\n    self.executeTest(self.checkRealtime)\n    self.executeTest(self.checkDynamic)\n    return\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/config/BuildSystem/config/packages/MPI.py": "#!/usr/bin/env python\nfrom __future__ import generators\nimport config.base\nimport config.package\nimport os\nfrom stat import *\n\ndef noCheck(command, status, output, error):\n  ''' Do no check result'''\n  return\n\nclass Configure(config.package.Package):\n  def __init__(self, framework):\n    config.package.Package.__init__(self, framework)\n    self.minversion         = '2'\n    self.versionname        = 'MPI_VERSION'\n    self.functions          = ['MPI_Init', 'MPI_Comm_create']\n    self.includes           = ['mpi.h']\n    liblist_mpich         = [['fmpich2.lib','fmpich2g.lib','fmpich2s.lib','mpi.lib'],\n                             ['fmpich2.lib','fmpich2g.lib','mpi.lib'],['fmpich2.lib','mpich2.lib'],\n                             ['libfmpich2g.a','libmpi.a'],['libfmpich.a','libmpich.a', 'libpmpich.a'],\n                             ['libmpich.a', 'libpmpich.a'],\n                             ['libfmpich.a','libmpich.a', 'libpmpich.a', 'libmpich.a', 'libpmpich.a', 'libpmpich.a'],\n                             ['libmpich.a', 'libpmpich.a', 'libmpich.a', 'libpmpich.a', 'libpmpich.a'],\n                             ['libmpich.a','librt.a','libaio.a','libsnl.a','libpthread.a'],\n                             ['libmpich.a','libssl.a','libuuid.a','libpthread.a','librt.a','libdl.a'],\n                             ['libmpich.a','libnsl.a','libsocket.a','librt.a','libnsl.a','libsocket.a'],\n                             ['libmpich.a','libgm.a','libpthread.a']]\n    liblist_lam           = [['liblamf77mpi.a','libmpi++.a','libmpi.a','liblam.a'],\n                             ['liblammpi++.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','liblamf77mpi.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','liblamf90mpi.a','libmpi.a','liblam.a'],\n                             ['liblammpio.a','libpmpi.a','libmpi.a','liblam.a'],\n                             ['liblammpi++.a','libmpi.a','liblam.a'],\n                             ['libmpi.a','liblam.a']]\n    liblist_msmpi         = [[os.path.join('amd64','msmpifec.lib'),os.path.join('amd64','msmpi.lib')],\n                             [os.path.join('i386','msmpifec.lib'),os.path.join('i386','msmpi.lib')]]\n    liblist_other         = [['libmpich.a','libpthread.a'],['libmpi++.a','libmpi.a']]\n    liblist_single        = [['libmpi.a'],['libmpich.a'],['mpi.lib'],['mpich2.lib'],['mpich.lib'],\n                             [os.path.join('amd64','msmpi.lib')],[os.path.join('i386','msmpi.lib')]]\n    self.liblist          = liblist_mpich + liblist_lam + liblist_msmpi + liblist_other + liblist_single\n    # defaults to --with-mpi=yes\n    self.required         = 1\n    self.complex          = 1\n    self.isPOE            = 0\n    self.usingMPIUni      = 0\n    self.shared           = 0\n    # local state\n    self.commf2c          = 0\n    self.commc2f          = 0\n    self.needBatchMPI     = 1\n    self.alternativedownload = 'mpich'\n    # support MPI-3 process shared memory\n    self.support_mpi3_shm = 0\n    # support MPI-3 non-blocking collectives\n    self.support_mpi3_nbc = 0\n    self.mpi_pkg_version  = ''\n    self.mpiexec          = None\n    self.mpiexecExecutable = None\n    return\n\n  def setupHelp(self, help):\n    config.package.Package.setupHelp(self,help)\n    import nargs\n    help.addArgument('MPI', '-with-mpiexec=<prog>',                              nargs.Arg(None, None, 'The utility used to launch MPI jobs. (should support \"-n <np>\" option)'))\n    help.addArgument('MPI', '-with-mpi-compilers=<bool>',                        nargs.ArgBool(None, 1, 'Try to use the MPI compilers, e.g. mpicc'))\n    help.addArgument('MPI', '-known-mpi-shared-libraries=<bool>',                nargs.ArgBool(None, None, 'Indicates the MPI libraries are shared (the usual test will be skipped)'))\n    return\n\n  def setupDependencies(self, framework):\n    config.package.Package.setupDependencies(self, framework)\n    self.mpich   = framework.require('config.packages.MPICH', self)\n    self.openmpi = framework.require('config.packages.OpenMPI', self)\n    return\n\n  def __str__(self):\n    output  = config.package.Package.__str__(self)\n    if output and self.mpiexec: output  += '  Mpiexec: '+self.mpiexec.replace(' -n 1','')+'\\n'\n    return output+self.mpi_pkg_version\n\n  def generateLibList(self, directory):\n    if self.setCompilers.usedMPICompilers:\n      self.liblist = []\n      self.libdir  = ''\n    return config.package.Package.generateLibList(self,directory)\n\n  # search many obscure locations for MPI\n  def getSearchDirectories(self):\n    import re\n    if self.mpich.found:\n      yield (self.mpich.installDir)\n      raise RuntimeError('--download-mpich libraries cannot be used')\n    if self.openmpi.found:\n      yield (self.openmpi.installDir)\n      raise RuntimeError('--download-openmpi libraries cannot be used')\n\n    yield ''\n    # Try configure package directories\n    dirExp = re.compile(r'mpi(ch)?(-.*)?')\n    for packageDir in self.argDB['with-packages-search-path']:\n      packageDir = os.path.abspath(packageDir)\n      if not os.path.isdir(packageDir):\n        raise RuntimeError('Invalid package directory: '+packageDir)\n      for f in os.listdir(packageDir):\n        dir = os.path.join(packageDir, f)\n        if not os.path.isdir(dir):\n          continue\n        if not dirExp.match(f):\n          continue\n        yield (dir)\n    # Try SUSE location\n    yield (os.path.abspath(os.path.join('/opt', 'mpich')))\n    # Try IBM\n    self.isPOE = 1\n    dir = os.path.abspath(os.path.join('/usr', 'lpp', 'ppe.poe'))\n    yield (os.path.abspath(os.path.join('/usr', 'lpp', 'ppe.poe')))\n    self.isPOE = 0\n    # Try /usr/local\n    yield (os.path.abspath(os.path.join('/usr', 'local')))\n    # Try /usr/local/*mpich*\n    if os.path.isdir(dir):\n      ls = os.listdir(dir)\n      for dir in ls:\n        if dir.find('mpich') >= 0:\n          dir = os.path.join('/usr','local',dir)\n          if os.path.isdir(dir):\n            yield (dir)\n    # Try ~/mpich*\n    homedir = os.getenv('HOME')\n    if homedir:\n      ls = os.listdir(homedir)\n      for dir in ls:\n        if dir.find('mpich') >= 0:\n          dir = os.path.join(homedir,dir)\n          if os.path.isdir(dir):\n            yield (dir)\n    # Try MSMPI/MPICH install locations under Windows\n    # ex: /cygdrive/c/Program Files/Microsoft HPC Pack 2008 SDK\n    for root in ['/',os.path.join('/','cygdrive')]:\n      for drive in ['c']:\n        for programFiles in ['Program Files','Program Files (x86)']:\n          for packageDir in ['Microsoft HPC Pack 2008 SDK','Microsoft Compute Cluster Pack','MPICH2','MPICH',os.path.join('MPICH','SDK.gcc'),os.path.join('MPICH','SDK')]:\n            yield(os.path.join(root,drive,programFiles,packageDir))\n    return\n\n  def checkSharedLibrary_ThisIsBroken(self):\n  # TODO: Fix this routine, currently\n  #       * the visibility flag is passed to the compiling/linking so the symbols are not visable to the loader and the test fails (this is easily fixed)\n  #       * even with that fixed the dlsym() is unable to locate the checkInit symbol in the library even though nm shows it is there; I am not sure the cause\n    '''Sets flag indicating if MPI libraries are shared or not and\n    determines if MPI libraries CANNOT be used by shared libraries'''\n    if self.argDB['with-batch']:\n      if self.argDB['with-shared-libraries']:\n        if not 'known-mpi-shared-libraries' in self.argDB:\n          self.logPrintBox('***** WARNING: Cannot verify that MPI is a shared library - in\\n\\\nbatch-mode! If MPI is a static library but linked into multiple shared\\n\\\nlibraries that the application uses, sometimes compiles work -\\n\\\nbut one might get run-time errors. If you know that the MPI library is\\n\\\nshared - run with --known-mpi-shared-libraries=1 option to remove this\\n\\\nwarning message *****')\n        elif not self.argDB['known-mpi-shared-libraries']:\n          raise RuntimeError('Provided MPI library is flagged as static library! If its linked\\n\\\ninto multipe shared libraries that an application uses, sometimes\\n\\\ncompiles go through - but one might get run-time errors.  Either\\n\\\nreconfigure PETSc with --with-shared-libraries=0 or provide MPI with\\n\\\nshared libraries and run with --known-mpi-shared-libraries=1')\n      return\n    self.shared = self.libraries.checkShared('#include <mpi.h>\\n','MPI_Init','MPI_Initialized','MPI_Finalize',checkLink = self.checkPackageLink,libraries = self.lib, defaultArg = 'known-mpi-shared-libraries', executor = self.mpiexec)\n\n    # TODO: Turn this on once shared library checks are working again\n    #if self.argDB['with-shared-libraries'] and not self.shared:\n    #  self.logPrint('MPI libraries cannot be used with shared libraries')\n    #  raise RuntimeError('Shared libraries cannot be built using MPI provided.\\nEither reconfigure with --with-shared-libraries=0 or rebuild MPI with shared library support')\n    return\n\n  def configureMPIEXEC(self):\n    '''Checking for location of mpiexec'''\n    if self.argDB['with-batch']:\n      if 'with-mpiexec' in self.argDB:\n        self.logPrintBox('--with-mpiexec is ignored since --with-batch is provided; one cannot run generated executables on the compile server')\n      self.mpiexec = 'Not_appropriate_for_batch_systems_You_must_use_your_batch_system_to_submit_MPI_jobs_speak_with_your_local_sys_admin'\n      self.addMakeMacro('MPIEXEC', self.mpiexec)\n      return\n    if 'with-mpiexec' in self.argDB:\n      self.argDB['with-mpiexec'] = os.path.expanduser(self.argDB['with-mpiexec'])\n      if not self.getExecutable(self.argDB['with-mpiexec'], resultName = 'mpiexec'):\n        raise RuntimeError('Invalid mpiexec specified: '+str(self.argDB['with-mpiexec']))\n      self.mpiexec = self.argDB['with-mpiexec']\n    elif self.isPOE:\n      self.mpiexec = os.path.abspath(os.path.join('bin', 'mpiexec.poe'))\n    else:\n      mpiexecs = ['mpiexec', 'mpirun', 'mprun', 'srun']\n      path    = []\n      if 'with-mpi-dir' in self.argDB:\n        path.append(os.path.join(os.path.abspath(self.argDB['with-mpi-dir']), 'bin'))\n        # MPICH-NT-1.2.5 installs MPIRun.exe in mpich/mpd/bin\n        path.append(os.path.join(os.path.abspath(self.argDB['with-mpi-dir']), 'mpd','bin'))\n        useDefaultPath = 0\n      else:\n        for inc in self.include:\n          path.append(os.path.join(os.path.dirname(inc), 'bin'))\n          # MPICH-NT-1.2.5 installs MPIRun.exe in mpich/SDK/include/../../mpd/bin\n          path.append(os.path.join(os.path.dirname(os.path.dirname(inc)),'mpd','bin'))\n        for lib in self.lib:\n          path.append(os.path.join(os.path.dirname(os.path.dirname(lib)), 'bin'))\n        self.pushLanguage('C')\n        if (os.path.basename(self.getCompiler()) == 'mpicc' or os.path.basename(self.getCompiler()) == 'mpiicc') and os.path.dirname(self.getCompiler()):\n          path.append(os.path.dirname(self.getCompiler()))\n        self.popLanguage()\n        useDefaultPath = 1\n      if not self.getExecutable(mpiexecs, path = path, useDefaultPath = useDefaultPath, resultName = 'mpiexec',setMakeMacro=0):\n        if not self.getExecutable('/bin/false', path = [], useDefaultPath = 0, resultName = 'mpiexec',setMakeMacro=0):\n          raise RuntimeError('Could not locate MPIEXEC - please specify --with-mpiexec option')\n      # Support for spaces and () in executable names; also needs to handle optional arguments at the end\n      # TODO: This support for spaces and () should be moved to core BuildSystem\n      self.mpiexec = self.mpiexec.replace(' ', '\\\\ ').replace('(', '\\\\(').replace(')', '\\\\)').replace('\\ -',' -')\n      self.mpiexecExecutable = self.mpiexec\n      if (hasattr(self, 'ompi_major_version') and int(self.ompi_major_version) >= 3):\n        (out, err, ret) = Configure.executeShellCommand(self.mpiexec+' -help all', checkCommand = noCheck, timeout = 60, log = self.log, threads = 1)\n        if out.find('--oversubscribe') >=0:\n          self.mpiexec = self.mpiexec + ' --oversubscribe'\n\n    if not self.mpiexecExecutable:\n      self.mpiexecExecutable = self.mpiexec\n    self.getExecutable(self.mpiexecExecutable, getFullPath=1, resultName='mpiexecExecutable')\n\n    # using mpiexec environmental variables make sure mpiexec matches the MPI libraries and save the variables for testing in PetscInitialize()\n    # the variable HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE is not currently used. PetscInitialize() can check the existence of the environmental variable to\n    # determine if the program has been started with the correct mpiexec (will only be set for parallel runs so not clear how to check appropriately)\n    (out, err, ret) = Configure.executeShellCommand(self.mpiexec+' -n 1 printenv', checkCommand = noCheck, timeout = 120, threads = 1, log = self.log)\n    if ret:\n      self.logWrite('Unable to run '+self.mpiexec+' with option \"-n 1 printenv\"\\nThis could be ok, some MPI implementations such as SGI produce a non-zero status with non-MPI programs\\n'+out+err)\n    else:\n      if out.find('MPIR_CVAR_CH3') > -1:\n        if hasattr(self,'ompi_major_version'): raise RuntimeError(\"Your libraries are from OpenMPI but it appears your mpiexec is from MPICH\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'MPIR_CVAR_CH3')\n      elif  out.find('MPIR_CVAR_CH3') > -1:\n        if hasattr(self,'ompi_major_version'): raise RuntimeError(\"Your libraries are from OpenMPI but it appears your mpiexec is from MPICH\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'MPICH')\n      elif out.find('OMPI_COMM_WORLD_SIZE') > -1:\n        if hasattr(self,'mpich_numversion'): raise RuntimeError(\"Your libraries are from MPICH but it appears your mpiexec is from OpenMPI\");\n        self.addDefine('HAVE_MPIEXEC_ENVIRONMENTAL_VARIABLE', 'OMP')\n\n    self.addMakeMacro('MPIEXEC', self.mpiexec)\n    self.mpiexec = self.mpiexec + ' -n 1'\n\n    if hasattr(self,'mpich_numversion') or hasattr(self,'ompi_major_version'):\n\n      hostnameworks = 0\n      # turn of checks if Apple firewall is on since it prevents success of the tests even though MPI will work\n      self.getExecutable('socketfilterfw', path = ['/usr/libexec/ApplicationFirewall'])\n      if hasattr(self,'socketfilterfw'):\n        try:\n          (result, err, ret) = Configure.executeShellCommand(self.socketfilterfw + ' --getglobalstate', timeout = 60, log = self.log, threads = 1)\n          if result.find(\"Firewall is enabled\") > -1:  hostnameworks = 1\n        except:\n          self.logPrint(\"Exception: Unable to get result from socketfilterfw\\n\")\n\n\n      self.getExecutable('hostname')\n      if not hostnameworks and hasattr(self,'hostname'):\n        try:\n          (hostname, err, ret) = Configure.executeShellCommand(self.hostname, timeout = 60, log = self.log, threads = 1)\n          self.logPrint(\"Return code from hostname: %s\\n\" % ret)\n        except:\n          self.logPrint(\"Exception: Unable to get result from hostname, skipping network checks\\n\")\n        else:\n          if ret == 0:\n            self.logPrint(\"Hostname works, running network checks\")\n\n            self.getExecutable('ping', path = ['/sbin'], useDefaultPath = 1)\n            if not hasattr(self,'ping'):\n              self.getExecutable('fping', resultName = 'ping')\n            if hasattr(self,'ping'):\n              if self.setCompilers.isCygwin(self.log):\n                count = ' -n 2 '\n              else:\n                count = ' -c 2 '\n              try:\n                (ok, err, ret) = Configure.executeShellCommand(self.ping + count + hostname, timeout = 60, log = self.log, threads = 1)\n                self.logPrint(\"Return code from ping: %s\\n\" % ret)\n                if not ret: hostnameworks = 1\n              except:\n                self.logPrint(\"Exception: while running ping skipping ping check\\n\")\n\n              if not hostnameworks:\n                # Note: host may not work on MacOS, this is normal\n                self.getExecutable('host')\n                if hasattr(self,'host'):\n                  try:\n                    (ok, err, ret) = Configure.executeShellCommand(self.host + ' '+ hostname, timeout = 60, log = self.log, threads = 1)\n                    self.logPrint(\"Return code from host: %s\\n\" % ret)\n                    # host works even with broken VPN is is not a useful test\n                  except:\n                    self.logPrint(\"Exception: while running host skipping host check\\n\")\n\n              if not hostnameworks:\n                self.getExecutable('traceroute', path = ['/usr/sbin'], useDefaultPath = 1)\n                if hasattr(self,'traceroute'):\n                  try:\n                    (ok, err, ret) = Configure.executeShellCommand(self.traceroute + ' ' + hostname, timeout = 60, log = self.log, threads = 1)\n                    self.logPrint(\"Return code from traceroute: %s\\n\" % ret)\n                    if not ret: hostnameworks = 1\n                  except:\n                    self.logPrint(\"Exception: while running traceroute skipping traceroute check\\n\")\n\n              if not hostnameworks:\n                self.logPrintBox('***** WARNING: mpiexec may not work on your system due to network issues.\\n\\\nPerhaps you have VPN running whose network settings may not work with mpiexec or your network is misconfigured')\n          else:\n            self.logPrintBox('***** WARNING: mpiexec may not work on your system due to network issues.\\n\\\nUnable to run hostname to check the network')\n          self.logPrintDivider()\n\n\n    # check that mpiexec runs an MPI program correctly\n    error_message = 'Unable to run MPI program with '+self.mpiexec+'\\n\\\n    (1) make sure this is the correct program to run MPI jobs\\n\\\n    (2) your network may be misconfigured; see https://www.mcs.anl.gov/petsc/documentation/faq.html#mpi-network-misconfigure\\n\\\n    (3) you may have VPN running whose network settings may not play nice with MPI\\n'\n\n    includes = '#include <mpi.h>'\n    body = 'MPI_Init(0,0);\\nMPI_Finalize();\\n'\n    try:\n      ok = self.checkRun(includes, body, executor = self.mpiexec, timeout = 120, threads = 1)\n      if not ok: raise RuntimeError(error_message)\n    except RuntimeError as e:\n      if str(e).find('Runaway process exceeded time limit') > -1:\n        raise RuntimeError('Timeout: %s' % error_message)\n\n  def configureMPI2(self):\n    '''Check for functions added to the interface in MPI-2'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    self.framework.saveLog()\n    if self.checkLink('#include <mpi.h>\\n', 'int flag;if (MPI_Finalized(&flag));\\n'):\n      self.haveFinalized = 1\n      self.addDefine('HAVE_MPI_FINALIZED', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Allreduce(MPI_IN_PLACE,0, 1, MPI_INT, MPI_SUM, MPI_COMM_SELF));\\n'):\n      self.haveInPlace = 1\n      self.addDefine('HAVE_MPI_IN_PLACE', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'int count=2; int blocklens[2]={0,1}; MPI_Aint indices[2]={0,1}; MPI_Datatype old_types[2]={0,1}; MPI_Datatype *newtype = 0;\\n \\\n                                             if (MPI_Type_create_struct(count, blocklens, indices, old_types, newtype));\\n'):\n      self.haveTypeCreateStruct = 1\n    else:\n      self.haveTypeCreateStruct = 0\n      self.framework.addDefine('MPI_Type_create_struct(count,lens,displs,types,newtype)', 'MPI_Type_struct((count),(lens),(displs),(types),(newtype))')\n    if self.checkLink('#include <mpi.h>\\n', 'MPI_Comm_errhandler_fn * p_err_fun = 0; MPI_Errhandler * p_errhandler = 0; if (MPI_Comm_create_errhandler(p_err_fun,p_errhandler));\\n'):\n      self.haveCommCreateErrhandler = 1\n    else:\n      self.haveCommCreateErrhandler = 0\n      self.framework.addDefine('MPI_Comm_create_errhandler(p_err_fun,p_errhandler)', 'MPI_Errhandler_create((p_err_fun),(p_errhandler))')\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Comm_set_errhandler(MPI_COMM_WORLD,MPI_ERRORS_RETURN));\\n'):\n      self.haveCommSetErrhandler = 1\n    else:\n      self.haveCommSetErrhandler = 0\n      self.framework.addDefine('MPI_Comm_set_errhandler(comm,p_errhandler)', 'MPI_Errhandler_set((comm),(p_errhandler))')\n    if self.checkLink('#include <mpi.h>\\n', 'if (MPI_Reduce_local(0, 0, 0, MPI_INT, MPI_SUM));'):\n      self.haveReduceLocal = 1\n      self.addDefine('HAVE_MPI_REDUCE_LOCAL',1)\n    if self.checkLink('#include <mpi.h>\\n', 'char version[MPI_MAX_LIBRARY_VERSION_STRING];int verlen;if (MPI_Get_library_version(version,&verlen));\\n'):\n      self.addDefine('HAVE_MPI_GET_LIBRARY_VERSION', 1)\n    # Even MPI_Win_create is in MPI 2.0, we do this test to supress MPIUNI, which does not support MPI one-sided.\n    if self.checkLink('#include <mpi.h>\\n', 'int base[100]; MPI_Win win; if (MPI_Win_create(base,100,4,MPI_INFO_NULL,MPI_COMM_WORLD,&win));\\n'):\n      self.addDefine('HAVE_MPI_WIN_CREATE', 1)\n    # flag broken one-sided tests\n    if not 'HAVE_MSMPI' in self.defines and not (hasattr(self, 'mpich_numversion') and int(self.mpich_numversion) <= 30004300):\n      self.addDefine('HAVE_MPI_ONE_SIDED', 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    self.logWrite(self.framework.restoreLog())\n    return\n\n  def configureMPI3(self):\n    '''Check for functions added to the interface in MPI-3'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    self.framework.saveLog()\n    # Skip buggy MPICH versions\n    if (hasattr(self, 'mpich_numversion') and int(self.mpich_numversion) > 30004300) or not hasattr(self, 'mpich_numversion'):\n      if self.checkLink('#include <mpi.h>\\n',\n                      'MPI_Comm scomm; MPI_Aint size=128; int disp_unit=8,*baseptr; MPI_Win win;\\n\\\n                       if (MPI_Comm_split_type(MPI_COMM_WORLD, MPI_COMM_TYPE_SHARED, 0, MPI_INFO_NULL, &scomm));\\n\\\n                       if (MPI_Win_allocate_shared(size,disp_unit,MPI_INFO_NULL,MPI_COMM_WORLD,&baseptr,&win));\\n\\\n                       if (MPI_Win_shared_query(win,0,&size,&disp_unit,&baseptr));\\n'):\n        self.addDefine('HAVE_MPI_PROCESS_SHARED_MEMORY', 1)\n        self.support_mpi3_shm = 1\n    if self.checkLink('#include <mpi.h>\\n',\n                      'int send=0,recv,counts[2]={1,1},displs[2]={1,2}; MPI_Request req;\\n\\\n                       if (MPI_Iscatter(&send,1,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iscatterv(&send,counts,displs,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Igather(&send,1,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Igatherv(&send,1,MPI_INT,&recv,counts,displs,MPI_INT,0,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iallgather(&send,1,MPI_INT,&recv,1,MPI_INT,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Iallgatherv(&send,1,MPI_INT,&recv,counts,displs,MPI_INT,MPI_COMM_WORLD,&req));\\n \\\n                       if (MPI_Ialltoall(&send,1,MPI_INT,&recv,1,MPI_INT,MPI_COMM_WORLD,&req));\\n'):\n      self.addDefine('HAVE_MPI_NONBLOCKING_COLLECTIVES', 1)\n      self.support_mpi3_nbc = 1\n    if self.checkLink('#include <mpi.h>\\n',\n                      'MPI_Comm distcomm; \\n\\\n                       MPI_Request req; \\n\\\n                       if (MPI_Dist_graph_create_adjacent(MPI_COMM_WORLD,0,0,MPI_WEIGHTS_EMPTY,0,0,MPI_WEIGHTS_EMPTY,MPI_INFO_NULL,0,&distcomm));\\n\\\n                       if (MPI_Neighbor_alltoallv(0,0,0,MPI_INT,0,0,0,MPI_INT,distcomm));\\n\\\n                       if (MPI_Ineighbor_alltoallv(0,0,0,MPI_INT,0,0,0,MPI_INT,distcomm,&req));\\n'):\n      self.addDefine('HAVE_MPI_NEIGHBORHOOD_COLLECTIVES',1)\n    if hasattr(self, 'ompi_major_version'):\n      openmpi_cuda_test = '#include<mpi.h>\\n #include <mpi-ext.h>\\n #if defined(MPIX_CUDA_AWARE_SUPPORT) && MPIX_CUDA_AWARE_SUPPORT\\n #else\\n #error This OpenMPI is not CUDA-aware\\n #endif\\n'\n      if self.checkCompile(openmpi_cuda_test):\n        self.addDefine('HAVE_MPI_GPU_AWARE', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'int ptr[1]; MPI_Win win; if (MPI_Get_accumulate(ptr,1,MPI_INT,ptr,1,MPI_INT,0,0,1,MPI_INT,MPI_SUM,win));\\n'):\n      self.addDefine('HAVE_MPI_GET_ACCUMULATE', 1)\n    if self.checkLink('#include <mpi.h>\\n', 'int ptr[1]; MPI_Win win; MPI_Request req; if (MPI_Rget(ptr,1,MPI_INT,0,1,1,MPI_INT,win,&req));\\n'):\n      self.addDefine('HAVE_MPI_RGET', 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    self.logWrite(self.framework.restoreLog())\n    return\n\n  def configureMPITypes(self):\n    '''Checking for MPI Datatype handles'''\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    mpitypes = [('MPI_LONG_DOUBLE', 'long-double'), ('MPI_INT64_T', 'int64_t')]\n    if self.getDefaultLanguage() == 'C': mpitypes.extend([('MPI_C_DOUBLE_COMPLEX', 'c-double-complex')])\n    for datatype, name in mpitypes:\n      includes = '#include <stdlib.h>\\n#include <mpi.h>\\n'\n      body     = 'int size;\\nint ierr;\\nMPI_Init(0,0);\\nierr = MPI_Type_size('+datatype+', &size);\\nif(ierr || (size == 0)) exit(1);\\nMPI_Finalize();\\n'\n      if self.checkCompile(includes, body):\n        if 'known-mpi-'+name in self.argDB:\n          if int(self.argDB['known-mpi-'+name]):\n            self.addDefine('HAVE_'+datatype, 1)\n        elif not self.argDB['with-batch']:\n          self.pushLanguage('C')\n          if self.checkRun(includes, body, defaultArg = 'known-mpi-'+name, executor = self.mpiexec, timeout = 120):\n            self.addDefine('HAVE_'+datatype, 1)\n          self.popLanguage()\n        else:\n         self.logPrintBox('***** WARNING: Cannot determine if '+datatype+' works on your system\\n\\\nin batch-mode! Assuming it does work. Run with --known-mpi-'+name+'=0\\n\\\nif you know it does not work (very unlikely). Run with --known-mpi-'+name+'=1\\n\\\nto remove this warning message *****')\n         self.addDefine('HAVE_'+datatype, 1)\n    self.compilers.CPPFLAGS = oldFlags\n    self.compilers.LIBS = oldLibs\n    return\n\n  def alternateConfigureLibrary(self):\n    '''Setup MPIUNI, our uniprocessor version of MPI'''\n    self.addDefine('HAVE_MPIUNI', 1)\n    self.addMakeMacro('MPI_IS_MPIUNI', 1)\n    self.framework.packages.append(self)\n    self.mpiexec = '${PETSC_DIR}/lib/petsc/bin/petsc-mpiexec.uni'\n    self.addMakeMacro('MPIEXEC','${PETSC_DIR}/lib/petsc/bin/petsc-mpiexec.uni')\n    self.addDefine('HAVE_MPI_IN_PLACE', 1)\n    self.addDefine('HAVE_MPI_TYPE_DUP', 1)\n    self.addDefine('HAVE_MPI_TYPE_GET_ENVELOPE', 1)\n    self.framework.saveLog()\n    self.framework.addDefine('MPI_Type_create_struct(count,lens,displs,types,newtype)', 'MPI_Type_struct((count),(lens),(displs),(types),(newtype))')\n    self.framework.addDefine('MPI_Comm_create_errhandler(p_err_fun,p_errhandler)', 'MPI_Errhandler_create((p_err_fun),(p_errhandler))')\n    self.framework.addDefine('MPI_Comm_set_errhandler(comm,p_errhandler)', 'MPI_Errhandler_set((comm),(p_errhandler))')\n    self.logWrite(self.framework.restoreLog())\n    if self.getDefaultLanguage == 'C': self.addDefine('HAVE_MPI_C_DOUBLE_COMPLEX', 1)\n    self.commf2c = 1\n    self.commc2f = 1\n    self.usingMPIUni = 1\n    self.version = 'PETSc MPIUNI uniprocessor MPI replacement'\n    self.executeTest(self.PetscArchMPICheck)\n    return\n\n  def checkDownload(self):\n    '''Check if we should download MPICH or OpenMPI'''\n    if 'download-mpi' in self.argDB and self.argDB['download-mpi']:\n      raise RuntimeError('Option --download-mpi does not exist! Use --download-mpich or --download-openmpi instead.')\n    if self.argDB['download-mpich'] and self.argDB['download-openmpi']:\n      raise RuntimeError('Cannot install more than one of OpenMPI or  MPICH for a single configuration. \\nUse different PETSC_ARCH if you want to be able to switch between two')\n    return None\n\n  def SGIMPICheck(self):\n    '''Returns true if SGI MPI is used'''\n    if self.libraries.check(self.lib, 'MPI_SGI_barrier') :\n      self.logPrint('SGI MPI detected - defining MISSING_SIGTERM')\n      self.addDefine('MISSING_SIGTERM', 1)\n      return 1\n    else:\n      self.logPrint('SGI MPI test failure')\n      return 0\n\n  def CxxMPICheck(self):\n    '''Make sure C++ can compile and link'''\n    if not hasattr(self.compilers, 'CXX'):\n      return 0\n    self.libraries.pushLanguage('Cxx')\n    oldFlags = self.compilers.CXXPPFLAGS\n    self.compilers.CXXPPFLAGS += ' '+self.headers.toString(self.include)\n    self.log.write('Checking for header mpi.h\\n')\n    # check if MPI_Finalize from c++ exists\n    self.log.write('Checking for C++ MPI_Finalize()\\n')\n    if not self.libraries.check(self.lib, 'MPI_Finalize', prototype = '#include <mpi.h>', call = 'int ierr;\\nierr = MPI_Finalize();', cxxMangle = 1):\n      raise RuntimeError('C++ error! MPI_Finalize() could not be located!')\n    self.compilers.CXXPPFLAGS = oldFlags\n    self.libraries.popLanguage()\n    return\n\n  def FortranMPICheck(self):\n    '''Make sure fortran include [mpif.h] and library symbols are found'''\n    if not hasattr(self.compilers, 'FC'):\n      return 0\n    # Fortran compiler is being used - so make sure mpif.h exists\n    self.libraries.pushLanguage('FC')\n    oldFlags = self.compilers.FPPFLAGS\n    self.compilers.FPPFLAGS += ' '+self.headers.toString(self.include)\n    # check if mpi_init form fortran works\n    self.log.write('Checking for fortran mpi_init()\\n')\n    if not self.libraries.check(self.lib,'', call = '#include \"mpif.h\"\\n       integer ierr\\n       call mpi_init(ierr)'):\n      raise RuntimeError('Fortran error! mpi_init() could not be located!')\n    # check if mpi.mod exists\n    if self.fortran.fortranIsF90:\n      self.log.write('Checking for mpi.mod\\n')\n      if self.libraries.check(self.lib,'', call = '       use mpi\\n       integer ierr,rank\\n       call mpi_init(ierr)\\n       call mpi_comm_rank(MPI_COMM_WORLD,rank,ierr)\\n'):\n        self.havef90module = 1\n        self.addDefine('HAVE_MPI_F90MODULE', 1)\n    self.compilers.FPPFLAGS = oldFlags\n    self.libraries.popLanguage()\n    return 0\n\n  def configureIO(self):\n    '''Check for the functions in MPI/IO\n       - Define HAVE_MPIIO if they are present\n       - Some older MPI 1 implementations are missing these'''\n    # MSWIN has buggy MPI IO\n    if 'HAVE_MSMPI' in self.defines: return\n    oldFlags = self.compilers.CPPFLAGS\n    oldLibs  = self.compilers.LIBS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    self.compilers.LIBS = self.libraries.toString(self.lib)+' '+self.compilers.LIBS\n    if not self.checkLink('#include <mpi.h>\\n', '''MPI_Aint lb, extent;\\nif (MPI_Type_get_extent(MPI_INT, &lb, &extent));\\n\n                                                 MPI_File fh;\\nvoid *buf;\\nMPI_Status status;\\nif (MPI_File_write_all(fh, buf, 1, MPI_INT, &status));\\n\n                                                 if (MPI_File_read_all(fh, buf, 1, MPI_INT, &status));\\n\n                                                 MPI_Offset disp;\\nMPI_Info info;\\nif (MPI_File_set_view(fh, disp, MPI_INT, MPI_INT, \"\", info));\\n\n                                                 if (MPI_File_open(MPI_COMM_SELF, \"\", 0, info, &fh));\\n\n                                                 if (MPI_File_close(&fh));\\n'''):\n      self.compilers.LIBS = oldLibs\n      self.compilers.CPPFLAGS = oldFlags\n      return\n    self.addDefine('HAVE_MPIIO', 1)\n    self.compilers.LIBS = oldLibs\n    self.compilers.CPPFLAGS = oldFlags\n    return\n\n  def checkMPIDistro(self):\n    '''Determine if MPICH_NUMVERSION, OMPI_MAJOR_VERSION or MSMPI_VER exist in mpi.h\n       Used for consistency checking of MPI installation at compile time'''\n    import re\n    HASHLINESPACE = ' *(?:\\n#.*\\n *)*'\n    oldFlags = self.compilers.CPPFLAGS\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n\n    # the following packages are all derived orginally from the MPICH implementation\n    MPI_VER = ''\n    # I_MPI_NUMVERSION is broken on Windows and only has a value of 0 so test also for the named version\n    MPICHPKG = 'I_MPI'\n    mpich_test = '#include <mpi.h>\\nconst char *mpich_ver = '+MPICHPKG+'_VERSION;\\n'\n    if self.checkCompile(mpich_test):\n      buf = self.outputPreprocess(mpich_test)\n      try:\n        mpich_numversion = re.compile('\\nconst char *mpich_ver ='+HASHLINESPACE+'\"([\\.0-9]+)\"'+HASHLINESPACE+';').search(buf).group(1)\n        self.addDefine('HAVE_'+MPICHPKG+'_VERSION',mpich_numversion)\n        MPI_VER  = '  '+MPICHPKG+'_VERSION: '+mpich_numversion\n      except:\n        self.logPrint('Unable to parse '+MPICHPKG+' version from header. Probably a buggy preprocessor')\n    for mpichpkg in ['i_mpi','mvapich2','mpich']:\n      MPICHPKG = mpichpkg.upper()\n      mpich_test = '#include <mpi.h>\\nint mpich_ver = '+MPICHPKG+'_NUMVERSION;\\n'\n      if self.checkCompile(mpich_test):\n        buf = self.outputPreprocess(mpich_test)\n        try:\n          mpich_numversion = re.compile('\\nint mpich_ver ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n          self.addDefine('HAVE_'+MPICHPKG+'_NUMVERSION',mpich_numversion)\n          MPI_VER += '  '+MPICHPKG+'_NUMVERSION: '+mpich_numversion\n          if mpichpkg == 'mpich': self.mpich_numversion = mpich_numversion\n        except:\n          self.logPrint('Unable to parse '+MPICHPKG+' version from header. Probably a buggy preprocessor')\n    if MPI_VER:\n      self.compilers.CPPFLAGS = oldFlags\n      self.mpi_pkg_version = MPI_VER+'\\n'\n      return\n\n    # IBM Spectrum MPI is derived from OpenMPI, we do not yet have specific tests for it\n    # https://www.ibm.com/us-en/marketplace/spectrum-mpi\n    openmpi_test = '#include <mpi.h>\\nint ompi_major = OMPI_MAJOR_VERSION;\\nint ompi_minor = OMPI_MINOR_VERSION;\\nint ompi_release = OMPI_RELEASE_VERSION;\\n'\n    if self.checkCompile(openmpi_test):\n      buf = self.outputPreprocess(openmpi_test)\n      ompi_major_version = ompi_minor_version = ompi_release_version = 'unknown'\n      try:\n        ompi_major_version = re.compile('\\nint ompi_major ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        ompi_minor_version = re.compile('\\nint ompi_minor ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        ompi_release_version = re.compile('\\nint ompi_release ='+HASHLINESPACE+'([0-9]+)'+HASHLINESPACE+';').search(buf).group(1)\n        self.addDefine('HAVE_OMPI_MAJOR_VERSION',ompi_major_version)\n        self.addDefine('HAVE_OMPI_MINOR_VERSION',ompi_minor_version)\n        self.addDefine('HAVE_OMPI_RELEASE_VERSION',ompi_release_version)\n        self.ompi_major_version = ompi_major_version\n        self.ompi_version = tuple([int(i) for i in [ompi_major_version,ompi_minor_version,ompi_release_version]])\n        self.mpi_pkg_version = '  OMPI_VERSION: '+ompi_major_version+'.'+ompi_minor_version+'.'+ompi_release_version+'\\n'\n        MPI_VER = '  OMPI_VERSION: '+ompi_major_version+'.'+ompi_minor_version+'.'+ompi_release_version\n      except:\n        self.logPrint('Unable to parse OpenMPI version from header. Probably a buggy preprocessor')\n    if MPI_VER:\n      self.compilers.CPPFLAGS = oldFlags\n      self.mpi_pkg_version = MPI_VER+'\\n'\n      return\n\n    msmpi_test = '#include <mpi.h>\\n#define xstr(s) str(s)\\n#define str(s) #s\\n#if defined(MSMPI_VER)\\nchar msmpi_hex[] = xstr(MSMPI_VER);\\n#else\\n#error not MSMPI\\n#endif\\n'\n    if self.checkCompile(msmpi_test):\n      buf = self.outputPreprocess(msmpi_test)\n      msmpi_version = 'unknown'\n      self.addDefine('HAVE_MSMPI',1) # flag we have MSMPI since we need to disable broken components\n      try:\n        msmpi_version = re.compile('\\nchar msmpi_hex\\[\\] = '+HASHLINESPACE+'\\\"([a-zA-Z0-9_]*)\\\"'+HASHLINESPACE+';').search(buf).group(1)\n        MPI_VER = '  MSMPI_VERSION: '+msmpi_version\n        self.addDefine('HAVE_MSMPI_VERSION',msmpi_version)\n      except:\n        self.logPrint('Unable to parse MSMPI version from header. Probably a buggy preprocessor')\n    if MPI_VER:\n      self.compilers.CPPFLAGS = oldFlags\n      self.mpi_pkg_version = MPI_VER+'\\n'\n      return\n\n    return\n\n  def findMPIInc(self):\n    '''Find MPI include paths from \"mpicc -show\" and use with CUDAC_FLAGS'''\n    needInclude=False\n    if hasattr(self.compilers, 'CUDAC'): needInclude=True\n    if hasattr(self.compilers, 'HIPCC'): needInclude=True\n    if not needInclude: return\n    import re\n    output = ''\n    try:\n      output   = self.executeShellCommand(self.compilers.CC + ' -show', log = self.log)[0]\n      compiler = output.split(' ')[0]\n    except:\n      pass\n    argIter = iter(output.split())\n    try:\n      while 1:\n        arg = next(argIter)\n        self.logPrint( 'Checking arg '+arg, 4, 'compilers')\n        m = re.match(r'^-I.*$', arg)\n        if m:\n          self.logPrint('Found include option: '+arg, 4, 'compilers')\n          if hasattr(self.compilers, 'CUDAC'):\n            self.setCompilers.pushLanguage('CUDA')\n            self.setCompilers.addCompilerFlag(arg)\n            self.setCompilers.popLanguage()\n          if hasattr(self.compilers, 'HIPCC'):\n            self.setCompilers.pushLanguage('HIP')\n            self.setCompilers.addCompilerFlag(arg)\n            self.setCompilers.popLanguage()\n          continue\n    except StopIteration:\n      pass\n    return\n\n  def log_print_mpi_h_line(self,buf):\n    for line in buf.splitlines():\n      if 'mpi.h' in line:\n        self.log.write('mpi_h_line:\\n'+line+'\\n')\n        return\n    self.log.write('mpi.h not found in buf')\n    return\n\n  def PetscArchMPICheck(self):\n    import os\n    '''Makes sure incompatable mpi.h is not in the PETSC_ARCH/include directory'''\n    build_mpi_h_dir = os.path.join(self.petscdir.dir,self.arch,'include')\n    build_mpi_h = os.path.join(build_mpi_h_dir,'mpi.h')\n    if os.path.isfile(build_mpi_h):\n      self.log.write('mpi.h found in build dir! Checking if its a bad copy.\\n')\n      if self.usingMPIUni:\n        raise RuntimeError('There is a copy of mpi.h in '+build_mpi_h_dir+' that will conflict with --with-mpi=0 build. do:\\nrm -rf '+self.arch+' and run ./configure again\\n')\n      oldFlags = self.compilers.CPPFLAGS\n      mpi_h_test = '#include <mpi.h>'\n      # check self.include\n      self.compilers.CPPFLAGS = oldFlags+' '+self.headers.toString(self.include)\n      buf1 = self.outputPreprocess(mpi_h_test)\n      self.log_print_mpi_h_line(buf1)\n      # check build_mpi_h_dir and self.include\n      self.compilers.CPPFLAGS = oldFlags+' '+self.headers.getIncludeArgument(build_mpi_h_dir)+' '+self.headers.toString(self.include)\n      buf2 = self.outputPreprocess(mpi_h_test)\n      self.log_print_mpi_h_line(buf2)\n      if buf1 != buf2:\n        raise RuntimeError('There is a copy of mpi.h in '+build_mpi_h_dir+' that is not compatible with your MPI, do:\\nrm -rf '+self.arch+' and run ./configure again\\n')\n      self.compilers.CPPFLAGS = oldFlags\n    return\n\n\n  def configureLibrary(self):\n    import platform\n    '''Calls the regular package configureLibrary and then does an additional test needed by MPI'''\n    if 'with-'+self.package+'-shared' in self.argDB:\n      self.argDB['with-'+self.package] = 1\n    config.package.Package.configureLibrary(self)\n    if self.setCompilers.usedMPICompilers:\n      if 'with-mpi-include' in self.argDB: raise RuntimeError('Do not use --with-mpi-include when using MPI compiler wrappers')\n      if 'with-mpi-lib' in self.argDB: raise RuntimeError('Do not use --with-mpi-lib when using MPI compiler wrappers')\n    self.executeTest(self.checkMPIDistro)\n    if any(x in platform.processor() for x in ['i386','x86','i86pc']) and config.setCompilers.Configure.isSolaris(self.log) and hasattr(self, 'mpich_numversion') and int(self.mpich_numversion) >= 30301300:\n      # this is only needed if MPICH/HWLOC were compiled with optimization\n      self.logWrite('Setting environmental variable to work around buggy HWLOC\\nhttps://github.com/open-mpi/hwloc/issues/290\\n')\n      os.environ['HWLOC_COMPONENTS'] = '-x86'\n      self.addDefine('HAVE_HWLOC_SOLARIS_BUG',1)\n      self.logPrintBox('***** WARNING: This MPI implementation may have a bug in it that causes programs to hang.\\n\\\nYou may need to set the environmental variable HWLOC_COMPONENTS to -x86 to prevent such hangs. warning message *****')\n    self.executeTest(self.configureMPI2) #depends on checkMPIDistro\n    self.executeTest(self.configureMPI3) #depends on checkMPIDistro\n    self.executeTest(self.configureMPIEXEC)\n    self.executeTest(self.configureMPITypes)\n    self.executeTest(self.SGIMPICheck)\n    self.executeTest(self.CxxMPICheck)\n    self.executeTest(self.FortranMPICheck)\n    self.executeTest(self.configureIO) #depends on checkMPIDistro\n    self.executeTest(self.findMPIInc)\n    self.executeTest(self.PetscArchMPICheck)\n    funcs = '''MPI_Type_get_envelope  MPI_Type_dup MPI_Init_thread MPI_Iallreduce MPI_Ibarrier MPI_Finalized MPI_Exscan MPI_Reduce_scatter MPI_Reduce_scatter_block'''.split()\n    found, missing = self.libraries.checkClassify(self.dlib, funcs)\n    for f in found:\n      self.addDefine('HAVE_' + f.upper(),1)\n    for f in ['MPIX_Iallreduce', 'MPIX_Ibarrier']: # Unlikely to be found\n      if self.libraries.check(self.dlib, f):\n        self.addDefine('HAVE_' + f.upper(),1)\n\n    oldFlags = self.compilers.CPPFLAGS # Disgusting save and restore\n    self.compilers.CPPFLAGS += ' '+self.headers.toString(self.include)\n    for combiner in ['MPI_COMBINER_DUP', 'MPI_COMBINER_CONTIGUOUS', 'MPI_COMBINER_NAMED']:\n      if self.checkCompile('#include <mpi.h>', 'int combiner = %s;' % (combiner,)):\n        self.addDefine('HAVE_' + combiner,1)\n    self.compilers.CPPFLAGS = oldFlags\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/systems/Apple/iOS/examples/Basic/Default-568h@2x.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/ts/tutorials/power_grid/PDF_eqs_power_grid.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/ts/tutorials/power_grid/stability_9bus/Ybus.bin",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/ts/tutorials/power_grid/stability_9bus/X.bin",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/ksp/ksp/tutorials/data/ex35_mesh.h5m",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/vertebra.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/spine0l.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/scalinglarge.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/pump.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/ocean.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/katz3.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/katz2.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/katz1.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/heart.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/cell.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/publications/images/brain.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/miscellaneous/pie.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/miscellaneous/ftp.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/victorminden.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/victor.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/vaclav.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/todd.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/tobin.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/stefano.jepg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/shri.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/sean.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/scaling.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/satish.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/sarich.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/richard.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/peter.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/patricksanan.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/mrhongzhang.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/mcs-rule-small.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/matt.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/lois.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/lisandro.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/karli.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/jed.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/hong.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/dmitry.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/dinesh.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/dave.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/buschelman.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/bill.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/barry.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/alp.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/adams.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/images/PETSc_RGB-logo.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/features/gpus.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/images/river.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/images/power.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/images/network.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/images/dmnetwork.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/documents/Application5_Rinaldo-etal-2018_paper.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/documents/Application4_Werner-etal-2019_paper.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/documents/Application2_Betrie_etal_2018_slide.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/website/dmnetwork/documents/Application1_Betrie_etal-2019_poster.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/nersc/datalayout3.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/tao_pic3.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/pjb5050.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/pjb.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/pinene.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/mso_s.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/mso_e.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/mso.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/molecule-uo23co36.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/lans_logo.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/lans-c.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/henon_circ_sol.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/glider_x2.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/glider_cl.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/gl2_s.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/gl2_c.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/gl2.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/gaussian.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/f4.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/f3.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/camel15.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/camel10.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/tutorials/images/argonne.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/taofig.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/taofig.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/pjb.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/ArgonneReportTemplatePage2.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/ArgonneReportTemplateLastPage.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/ArgonneLogo.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/manual/ANL-MCS-TM-322.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/demo/sc01opt.vsd",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/demo/sc01opt.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/accomps/tao_graph.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/accomps/tao_comps.ppt",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/tao_tex/accomps/tao_comps.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/usg.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/usg.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/stream-results-intel.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/stream-results-intel.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/numa.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/numa.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/mathworks-account.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/mathworks-account-5.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/mathworks-account-4.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/mathworks-account-3.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/mathworks-account-2.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/ghost.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/ghost.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/danumbering.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/images/danumbering.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/anl_tech_report/ArgonneReportTemplatePage2.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/anl_tech_report/ArgonneReportTemplateLastPage.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/anl_tech_report/ArgonneReportTemplate.doc",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/manual/anl_tech_report/ArgonneLogo.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/stokes_p2p1_sys_mat_sparse.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/stokes_p2p1_sys_mat.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/stokes_p2p1_prec_mat_sparse.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/stokes_p2p1_prec_mat.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/ex69_sol_m_2_n_2_B_375.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/physics/images/ex69_sol_m_2_n_2_B_1.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/meshing/images/surface.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/meshing/images/extrusionParallel.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/meshing/images/extrusionAdaptiveParallel.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/guides/meshing/images/extrusion.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/write-review-text.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/unfreed-memory.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/test-artifacts.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/started-retry-job.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/start-comment-on-code.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/show-failure.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/see-mr-pipelines.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/retry-pipeline.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/retry-job.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/provide-suggestion.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/pipeline-pause-button.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/pipeline-from-MR.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/pipeline-configure.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/pipeline-configure-browse.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-thread.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-thread-details.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-select-target.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-select-labels.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-select-branch.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-overview.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/mr-assign.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/label-subscribe.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/git-push-mr.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/find-exact-bad-job.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/failed-examples.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/error-compiling-source.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/continued-pipeline.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/changes-or-commits.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/cancel-pipeline.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/button-for-approvers.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/badsource.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/approvers.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/developers/images/another-failure.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/victorminden.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/victor.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/vaclav.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/todd.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/tobin.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/stefano.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/shri.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/sean.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/scaling.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/satish.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/sarich.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/richard.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/peter.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/patricksanan.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/mrhongzhang.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/mcs-rule-small.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/matt.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/lois.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/lisandro.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/karli.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/jed.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/hong.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/dmitry.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/dinesh.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/dave.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/buschelman.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/bill.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/barry.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/alp.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/docs/sphinx_docs/_static/images/adams.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/src/dm/impls/moab/tests/input/ex3_in.h5m",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/saws/images/transition.bmp",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/saws/images/arrow.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/unit_sphere.egadslite",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/tut21.cgns",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/surfacesphere_bin.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/squaremotor-30.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/square_periodic_bin.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/square_bin_physnames.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/square_bin.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/square.med",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/simpleblock-100.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/sevenside.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/sevenside-quad.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/sevenside-quad-15.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/nozzle.egadslite",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/mesh-3d-box-innersphere_bin.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/hybrid_hexwedge.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/hybrid_hexwedge.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/horse.ply.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/grid_c.cgns",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary.msh4",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary.msh2",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary-64.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/gmsh-3d-binary-32.msh",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/cylinder.med",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/cube_5tets.cas",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.h5",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/blockcylinder-50.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/barycentricallyrefinedcube.h5",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/annulus-20.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/TwoQuads.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/Rect-tri3.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/FourSquareT-large.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/FourSquareQ-large.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/FourSquareH-large.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/FourBrickTet-large.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/FourBrickHex-large.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/meshes/2Dgrd.exo",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/matrices/tiny_system_with_x0_complex.mat",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/share/petsc/datafiles/matrices/tiny_system_with_x0.mat",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/lib/petsc/bin/win32fe/win32feutils.dll",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/lib/petsc/bin/win32fe/win32fe.exe",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/.git/objects/pack/pack-b834db307a2352d041f6167da76813a71877ed10.idx",
        "/var/tmp/sochat1/spack-stage/spack-stage-petsc-main-it2wyuy3gtwgf36qfft3rl4y53husikt/spack-src/.git/objects/pack/pack-b834db307a2352d041f6167da76813a71877ed10.pack"
    ],
    "total_files": 8667
}