{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/testing/selftests/x86/test_syscall_vdso.c": "/*\n * 32-bit syscall ABI conformance test.\n *\n * Copyright (c) 2015 Denys Vlasenko\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n */\n/*\n * Can be built statically:\n * gcc -Os -Wall -static -m32 test_syscall_vdso.c thunks_32.S\n */\n#undef _GNU_SOURCE\n#define _GNU_SOURCE 1\n#undef __USE_GNU\n#define __USE_GNU 1\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <elf.h>\n#include <sys/ptrace.h>\n#include <sys/wait.h>\n\n#if !defined(__i386__)\nint main(int argc, char **argv, char **envp)\n{\n\tprintf(\"[SKIP]\\tNot a 32-bit x86 userspace\\n\");\n\treturn 0;\n}\n#else\n\nlong syscall_addr;\nlong get_syscall(char **envp)\n{\n\tElf32_auxv_t *auxv;\n\twhile (*envp++ != NULL)\n\t\tcontinue;\n\tfor (auxv = (void *)envp; auxv->a_type != AT_NULL; auxv++)\n\t\tif (auxv->a_type == AT_SYSINFO)\n\t\t\treturn auxv->a_un.a_val;\n\tprintf(\"[WARN]\\tAT_SYSINFO not supplied\\n\");\n\treturn 0;\n}\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.global\tint80\\n\"\n\t\"int80:\\n\"\n\t\"\tint\t$0x80\\n\"\n\t\"\tret\\n\"\n\t\"\t.popsection\\n\"\n);\nextern char int80;\n\nstruct regs64 {\n\tuint64_t rax, rbx, rcx, rdx;\n\tuint64_t rsi, rdi, rbp, rsp;\n\tuint64_t r8,  r9,  r10, r11;\n\tuint64_t r12, r13, r14, r15;\n};\nstruct regs64 regs64;\nint kernel_is_64bit;\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.code64\\n\"\n\t\"get_regs64:\\n\"\n\t\"\tpush\t%rax\\n\"\n\t\"\tmov\t$regs64, %eax\\n\"\n\t\"\tpop\t0*8(%rax)\\n\"\n\t\"\tmovq\t%rbx, 1*8(%rax)\\n\"\n\t\"\tmovq\t%rcx, 2*8(%rax)\\n\"\n\t\"\tmovq\t%rdx, 3*8(%rax)\\n\"\n\t\"\tmovq\t%rsi, 4*8(%rax)\\n\"\n\t\"\tmovq\t%rdi, 5*8(%rax)\\n\"\n\t\"\tmovq\t%rbp, 6*8(%rax)\\n\"\n\t\"\tmovq\t%rsp, 7*8(%rax)\\n\"\n\t\"\tmovq\t%r8,  8*8(%rax)\\n\"\n\t\"\tmovq\t%r9,  9*8(%rax)\\n\"\n\t\"\tmovq\t%r10, 10*8(%rax)\\n\"\n\t\"\tmovq\t%r11, 11*8(%rax)\\n\"\n\t\"\tmovq\t%r12, 12*8(%rax)\\n\"\n\t\"\tmovq\t%r13, 13*8(%rax)\\n\"\n\t\"\tmovq\t%r14, 14*8(%rax)\\n\"\n\t\"\tmovq\t%r15, 15*8(%rax)\\n\"\n\t\"\tret\\n\"\n\t\"poison_regs64:\\n\"\n\t\"\tmovq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tshl\t$32, %r8\\n\"\n\t\"\torq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tmovq\t%r8, %r9\\n\"\n\t\"\tmovq\t%r8, %r10\\n\"\n\t\"\tmovq\t%r8, %r11\\n\"\n\t\"\tmovq\t%r8, %r12\\n\"\n\t\"\tmovq\t%r8, %r13\\n\"\n\t\"\tmovq\t%r8, %r14\\n\"\n\t\"\tmovq\t%r8, %r15\\n\"\n\t\"\tret\\n\"\n\t\"\t.code32\\n\"\n\t\"\t.popsection\\n\"\n);\nextern void get_regs64(void);\nextern void poison_regs64(void);\nextern unsigned long call64_from_32(void (*function)(void));\nvoid print_regs64(void)\n{\n\tif (!kernel_is_64bit)\n\t\treturn;\n\tprintf(\"ax:%016llx bx:%016llx cx:%016llx dx:%016llx\\n\", regs64.rax,  regs64.rbx,  regs64.rcx,  regs64.rdx);\n\tprintf(\"si:%016llx di:%016llx bp:%016llx sp:%016llx\\n\", regs64.rsi,  regs64.rdi,  regs64.rbp,  regs64.rsp);\n\tprintf(\" 8:%016llx  9:%016llx 10:%016llx 11:%016llx\\n\", regs64.r8 ,  regs64.r9 ,  regs64.r10,  regs64.r11);\n\tprintf(\"12:%016llx 13:%016llx 14:%016llx 15:%016llx\\n\", regs64.r12,  regs64.r13,  regs64.r14,  regs64.r15);\n}\n\nint check_regs64(void)\n{\n\tint err = 0;\n\tint num = 8;\n\tuint64_t *r64 = &regs64.r8;\n\n\tif (!kernel_is_64bit)\n\t\treturn 0;\n\n\tdo {\n\t\tif (*r64 == 0x7f7f7f7f7f7f7f7fULL)\n\t\t\tcontinue; /* register did not change */\n\t\tif (syscall_addr != (long)&int80) {\n\t\t\t/*\n\t\t\t * Non-INT80 syscall entrypoints are allowed to clobber R8+ regs:\n\t\t\t * either clear them to 0, or for R11, load EFLAGS.\n\t\t\t */\n\t\t\tif (*r64 == 0)\n\t\t\t\tcontinue;\n\t\t\tif (num == 11) {\n\t\t\t\tprintf(\"[NOTE]\\tR11 has changed:%016llx - assuming clobbered by SYSRET insn\\n\", *r64);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* INT80 syscall entrypoint can be used by\n\t\t\t * 64-bit programs too, unlike SYSCALL/SYSENTER.\n\t\t\t * Therefore it must preserve R12+\n\t\t\t * (they are callee-saved registers in 64-bit C ABI).\n\t\t\t *\n\t\t\t * This was probably historically not intended,\n\t\t\t * but R8..11 are clobbered (cleared to 0).\n\t\t\t * IOW: they are the only registers which aren't\n\t\t\t * preserved across INT80 syscall.\n\t\t\t */\n\t\t\tif (*r64 == 0 && num <= 11)\n\t\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"[FAIL]\\tR%d has changed:%016llx\\n\", num, *r64);\n\t\terr++;\n\t} while (r64++, ++num < 16);\n\n\tif (!err)\n\t\tprintf(\"[OK]\\tR8..R15 did not leak kernel data\\n\");\n\treturn err;\n}\n\nint nfds;\nfd_set rfds;\nfd_set wfds;\nfd_set efds;\nstruct timespec timeout;\nsigset_t sigmask;\nstruct {\n\tsigset_t *sp;\n\tint sz;\n} sigmask_desc;\n\nvoid prep_args()\n{\n\tnfds = 42;\n\tFD_ZERO(&rfds);\n\tFD_ZERO(&wfds);\n\tFD_ZERO(&efds);\n\tFD_SET(0, &rfds);\n\tFD_SET(1, &wfds);\n\tFD_SET(2, &efds);\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_nsec = 123;\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGINT);\n\tsigaddset(&sigmask, SIGUSR2);\n\tsigaddset(&sigmask, SIGRTMAX);\n\tsigmask_desc.sp = &sigmask;\n\tsigmask_desc.sz = 8; /* bytes */\n}\n\nstatic void print_flags(const char *name, unsigned long r)\n{\n\tstatic const char *bitarray[] = {\n\t\"\\n\" ,\"c\\n\" ,/* Carry Flag */\n\t\"0 \" ,\"1 \"  ,/* Bit 1 - always on */\n\t\"\"   ,\"p \"  ,/* Parity Flag */\n\t\"0 \" ,\"3? \" ,\n\t\"\"   ,\"a \"  ,/* Auxiliary carry Flag */\n\t\"0 \" ,\"5? \" ,\n\t\"\"   ,\"z \"  ,/* Zero Flag */\n\t\"\"   ,\"s \"  ,/* Sign Flag */\n\t\"\"   ,\"t \"  ,/* Trap Flag */\n\t\"\"   ,\"i \"  ,/* Interrupt Flag */\n\t\"\"   ,\"d \"  ,/* Direction Flag */\n\t\"\"   ,\"o \"  ,/* Overflow Flag */\n\t\"0 \" ,\"1 \"  ,/* I/O Privilege Level (2 bits) */\n\t\"0\"  ,\"1\"   ,/* I/O Privilege Level (2 bits) */\n\t\"\"   ,\"n \"  ,/* Nested Task */\n\t\"0 \" ,\"15? \",\n\t\"\"   ,\"r \"  ,/* Resume Flag */\n\t\"\"   ,\"v \"  ,/* Virtual Mode */\n\t\"\"   ,\"ac \" ,/* Alignment Check/Access Control */\n\t\"\"   ,\"vif \",/* Virtual Interrupt Flag */\n\t\"\"   ,\"vip \",/* Virtual Interrupt Pending */\n\t\"\"   ,\"id \" ,/* CPUID detection */\n\tNULL\n\t};\n\tconst char **bitstr;\n\tint bit;\n\n\tprintf(\"%s=%016lx \", name, r);\n\tbitstr = bitarray + 42;\n\tbit = 21;\n\tif ((r >> 22) != 0)\n\t\tprintf(\"(extra bits are set) \");\n\tdo {\n\t\tif (bitstr[(r >> bit) & 1][0])\n\t\t\tfputs(bitstr[(r >> bit) & 1], stdout);\n\t\tbitstr -= 2;\n\t\tbit--;\n\t} while (bit >= 0);\n}\n\nint run_syscall(void)\n{\n\tlong flags, bad_arg;\n\n\tprep_args();\n\n\tif (kernel_is_64bit)\n\t\tcall64_from_32(poison_regs64);\n\t/*print_regs64();*/\n\n\tasm(\"\\n\"\n\t/* Try 6-arg syscall: pselect. It should return quickly */\n\t\"\tpush\t%%ebp\\n\"\n\t\"\tmov\t$308, %%eax\\n\"     /* PSELECT */\n\t\"\tmov\tnfds, %%ebx\\n\"     /* ebx  arg1 */\n\t\"\tmov\t$rfds, %%ecx\\n\"    /* ecx  arg2 */\n\t\"\tmov\t$wfds, %%edx\\n\"    /* edx  arg3 */\n\t\"\tmov\t$efds, %%esi\\n\"    /* esi  arg4 */\n\t\"\tmov\t$timeout, %%edi\\n\" /* edi  arg5 */\n\t\"\tmov\t$sigmask_desc, %%ebp\\n\" /* %ebp arg6 */\n\t\"\tpush\t$0x200ed7\\n\"      /* set almost all flags */\n\t\"\tpopf\\n\"\t\t/* except TF, IOPL, NT, RF, VM, AC, VIF, VIP */\n\t\"\tcall\t*syscall_addr\\n\"\n\t/* Check that registers are not clobbered */\n\t\"\tpushf\\n\"\n\t\"\tpop\t%%eax\\n\"\n\t\"\tcld\\n\"\n\t\"\tcmp\tnfds, %%ebx\\n\"     /* ebx  arg1 */\n\t\"\tmov\t$1, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$rfds, %%ecx\\n\"    /* ecx  arg2 */\n\t\"\tmov\t$2, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$wfds, %%edx\\n\"    /* edx  arg3 */\n\t\"\tmov\t$3, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$efds, %%esi\\n\"    /* esi  arg4 */\n\t\"\tmov\t$4, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$timeout, %%edi\\n\" /* edi  arg5 */\n\t\"\tmov\t$5, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmpl\t$sigmask_desc, %%ebp\\n\" /* %ebp arg6 */\n\t\"\tmov\t$6, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tmov\t$0, %%ebx\\n\"\n\t\"1:\\n\"\n\t\"\tpop\t%%ebp\\n\"\n\t: \"=a\" (flags), \"=b\" (bad_arg)\n\t:\n\t: \"cx\", \"dx\", \"si\", \"di\"\n\t);\n\n\tif (kernel_is_64bit) {\n\t\tmemset(&regs64, 0x77, sizeof(regs64));\n\t\tcall64_from_32(get_regs64);\n\t\t/*print_regs64();*/\n\t}\n\n\t/*\n\t * On paravirt kernels, flags are not preserved across syscalls.\n\t * Thus, we do not consider it a bug if some are changed.\n\t * We just show ones which do.\n\t */\n\tif ((0x200ed7 ^ flags) != 0) {\n\t\tprint_flags(\"[WARN]\\tFlags before\", 0x200ed7);\n\t\tprint_flags(\"[WARN]\\tFlags  after\", flags);\n\t\tprint_flags(\"[WARN]\\tFlags change\", (0x200ed7 ^ flags));\n\t}\n\n\tif (bad_arg) {\n\t\tprintf(\"[FAIL]\\targ#%ld clobbered\\n\", bad_arg);\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\tArguments are preserved across syscall\\n\");\n\n\treturn check_regs64();\n}\n\nint run_syscall_twice()\n{\n\tint exitcode = 0;\n\tlong sv;\n\n\tif (syscall_addr) {\n\t\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via VDSO\\n\");\n\t\texitcode = run_syscall();\n\t}\n\tsv = syscall_addr;\n\tsyscall_addr = (long)&int80;\n\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via INT 80\\n\");\n\texitcode += run_syscall();\n\tsyscall_addr = sv;\n\treturn exitcode;\n}\n\nvoid ptrace_me()\n{\n\tpid_t pid;\n\n\tfflush(NULL);\n\tpid = fork();\n\tif (pid < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\t/* child */\n\t\tif (ptrace(PTRACE_TRACEME, 0L, 0L, 0L) != 0)\n\t\t\texit(0);\n\t\traise(SIGSTOP);\n\t\treturn;\n\t}\n\t/* parent */\n\tprintf(\"[RUN]\\tRunning tests under ptrace\\n\");\n\twhile (1) {\n\t\tint status;\n\t\tpid = waitpid(-1, &status, __WALL);\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\tif (WIFSIGNALED(status))\n\t\t\texit(WTERMSIG(status));\n\t\tif (pid <= 0 || !WIFSTOPPED(status)) /* paranoia */\n\t\t\texit(255);\n\t\t/*\n\t\t * Note: we do not inject sig = WSTOPSIG(status).\n\t\t * We probably should, but careful: do not inject SIGTRAP\n\t\t * generated by syscall entry/exit stops.\n\t\t * That kills the child.\n\t\t */\n\t\tptrace(PTRACE_SYSCALL, pid, 0L, 0L /*sig*/);\n\t}\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint exitcode = 0;\n\tint cs;\n\n\tasm(\"\\n\"\n\t\"\tmovl\t%%cs, %%eax\\n\"\n\t: \"=a\" (cs)\n\t);\n\tkernel_is_64bit = (cs == 0x23);\n\tif (!kernel_is_64bit)\n\t\tprintf(\"[NOTE]\\tNot a 64-bit kernel, won't test R8..R15 leaks\\n\");\n\n\t/* This only works for non-static builds:\n\t * syscall_addr = dlsym(dlopen(\"linux-gate.so.1\", RTLD_NOW), \"__kernel_vsyscall\");\n\t */\n\tsyscall_addr = get_syscall(envp);\n\n\texitcode += run_syscall_twice();\n\tptrace_me();\n\texitcode += run_syscall_twice();\n\n\treturn exitcode;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/lib/traceevent/event-plugin.c": "/*\n * Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License (not later!)\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not,  see <http://www.gnu.org/licenses>\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include \"event-parse.h\"\n#include \"event-utils.h\"\n\n#define LOCAL_PLUGIN_DIR \".traceevent/plugins\"\n\nstatic struct registered_plugin_options {\n\tstruct registered_plugin_options\t*next;\n\tstruct pevent_plugin_option\t\t*options;\n} *registered_options;\n\nstatic struct trace_plugin_options {\n\tstruct trace_plugin_options\t*next;\n\tchar\t\t\t\t*plugin;\n\tchar\t\t\t\t*option;\n\tchar\t\t\t\t*value;\n} *trace_plugin_options;\n\nstruct plugin_list {\n\tstruct plugin_list\t*next;\n\tchar\t\t\t*name;\n\tvoid\t\t\t*handle;\n};\n\nstatic void lower_case(char *str)\n{\n\tif (!str)\n\t\treturn;\n\tfor (; *str; str++)\n\t\t*str = tolower(*str);\n}\n\nstatic int update_option_value(struct pevent_plugin_option *op, const char *val)\n{\n\tchar *op_val;\n\n\tif (!val) {\n\t\t/* toggle, only if option is boolean */\n\t\tif (op->value)\n\t\t\t/* Warn? */\n\t\t\treturn 0;\n\t\top->set ^= 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the option has a value then it takes a string\n\t * otherwise the option is a boolean.\n\t */\n\tif (op->value) {\n\t\top->value = val;\n\t\treturn 0;\n\t}\n\n\t/* Option is boolean, must be either \"1\", \"0\", \"true\" or \"false\" */\n\n\top_val = strdup(val);\n\tif (!op_val)\n\t\treturn -1;\n\tlower_case(op_val);\n\n\tif (strcmp(val, \"1\") == 0 || strcmp(val, \"true\") == 0)\n\t\top->set = 1;\n\telse if (strcmp(val, \"0\") == 0 || strcmp(val, \"false\") == 0)\n\t\top->set = 0;\n\tfree(op_val);\n\n\treturn 0;\n}\n\n/**\n * traceevent_plugin_list_options - get list of plugin options\n *\n * Returns an array of char strings that list the currently registered\n * plugin options in the format of <plugin>:<option>. This list can be\n * used by toggling the option.\n *\n * Returns NULL if there's no options registered. On error it returns\n * INVALID_PLUGIN_LIST_OPTION\n *\n * Must be freed with traceevent_plugin_free_options_list().\n */\nchar **traceevent_plugin_list_options(void)\n{\n\tstruct registered_plugin_options *reg;\n\tstruct pevent_plugin_option *op;\n\tchar **list = NULL;\n\tchar *name;\n\tint count = 0;\n\n\tfor (reg = registered_options; reg; reg = reg->next) {\n\t\tfor (op = reg->options; op->name; op++) {\n\t\t\tchar *alias = op->plugin_alias ? op->plugin_alias : op->file;\n\t\t\tchar **temp = list;\n\n\t\t\tname = malloc(strlen(op->name) + strlen(alias) + 2);\n\t\t\tif (!name)\n\t\t\t\tgoto err;\n\n\t\t\tsprintf(name, \"%s:%s\", alias, op->name);\n\t\t\tlist = realloc(list, count + 2);\n\t\t\tif (!list) {\n\t\t\t\tlist = temp;\n\t\t\t\tfree(name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlist[count++] = name;\n\t\t\tlist[count] = NULL;\n\t\t}\n\t}\n\treturn list;\n\n err:\n\twhile (--count >= 0)\n\t\tfree(list[count]);\n\tfree(list);\n\n\treturn INVALID_PLUGIN_LIST_OPTION;\n}\n\nvoid traceevent_plugin_free_options_list(char **list)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn;\n\n\tif (list == INVALID_PLUGIN_LIST_OPTION)\n\t\treturn;\n\n\tfor (i = 0; list[i]; i++)\n\t\tfree(list[i]);\n\n\tfree(list);\n}\n\nstatic int\nupdate_option(const char *file, struct pevent_plugin_option *option)\n{\n\tstruct trace_plugin_options *op;\n\tchar *plugin;\n\tint ret = 0;\n\n\tif (option->plugin_alias) {\n\t\tplugin = strdup(option->plugin_alias);\n\t\tif (!plugin)\n\t\t\treturn -1;\n\t} else {\n\t\tchar *p;\n\t\tplugin = strdup(file);\n\t\tif (!plugin)\n\t\t\treturn -1;\n\t\tp = strstr(plugin, \".\");\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t}\n\n\t/* first look for named options */\n\tfor (op = trace_plugin_options; op; op = op->next) {\n\t\tif (!op->plugin)\n\t\t\tcontinue;\n\t\tif (strcmp(op->plugin, plugin) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(op->option, option->name) != 0)\n\t\t\tcontinue;\n\n\t\tret = update_option_value(option, op->value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* first look for unnamed options */\n\tfor (op = trace_plugin_options; op; op = op->next) {\n\t\tif (op->plugin)\n\t\t\tcontinue;\n\t\tif (strcmp(op->option, option->name) != 0)\n\t\t\tcontinue;\n\n\t\tret = update_option_value(option, op->value);\n\t\tbreak;\n\t}\n\n out:\n\tfree(plugin);\n\treturn ret;\n}\n\n/**\n * traceevent_plugin_add_options - Add a set of options by a plugin\n * @name: The name of the plugin adding the options\n * @options: The set of options being loaded\n *\n * Sets the options with the values that have been added by user.\n */\nint traceevent_plugin_add_options(const char *name,\n\t\t\t\t  struct pevent_plugin_option *options)\n{\n\tstruct registered_plugin_options *reg;\n\n\treg = malloc(sizeof(*reg));\n\tif (!reg)\n\t\treturn -1;\n\treg->next = registered_options;\n\treg->options = options;\n\tregistered_options = reg;\n\n\twhile (options->name) {\n\t\tupdate_option(name, options);\n\t\toptions++;\n\t}\n\treturn 0;\n}\n\n/**\n * traceevent_plugin_remove_options - remove plugin options that were registered\n * @options: Options to removed that were registered with traceevent_plugin_add_options\n */\nvoid traceevent_plugin_remove_options(struct pevent_plugin_option *options)\n{\n\tstruct registered_plugin_options **last;\n\tstruct registered_plugin_options *reg;\n\n\tfor (last = &registered_options; *last; last = &(*last)->next) {\n\t\tif ((*last)->options == options) {\n\t\t\treg = *last;\n\t\t\t*last = reg->next;\n\t\t\tfree(reg);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * traceevent_print_plugins - print out the list of plugins loaded\n * @s: the trace_seq descripter to write to\n * @prefix: The prefix string to add before listing the option name\n * @suffix: The suffix string ot append after the option name\n * @list: The list of plugins (usually returned by traceevent_load_plugins()\n *\n * Writes to the trace_seq @s the list of plugins (files) that is\n * returned by traceevent_load_plugins(). Use @prefix and @suffix for formating:\n * @prefix = \"  \", @suffix = \"\\n\".\n */\nvoid traceevent_print_plugins(struct trace_seq *s,\n\t\t\t      const char *prefix, const char *suffix,\n\t\t\t      const struct plugin_list *list)\n{\n\twhile (list) {\n\t\ttrace_seq_printf(s, \"%s%s%s\", prefix, list->name, suffix);\n\t\tlist = list->next;\n\t}\n}\n\nstatic void\nload_plugin(struct pevent *pevent, const char *path,\n\t    const char *file, void *data)\n{\n\tstruct plugin_list **plugin_list = data;\n\tpevent_plugin_load_func func;\n\tstruct plugin_list *list;\n\tconst char *alias;\n\tchar *plugin;\n\tvoid *handle;\n\n\tplugin = malloc(strlen(path) + strlen(file) + 2);\n\tif (!plugin) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\treturn;\n\t}\n\n\tstrcpy(plugin, path);\n\tstrcat(plugin, \"/\");\n\tstrcat(plugin, file);\n\n\thandle = dlopen(plugin, RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\twarning(\"could not load plugin '%s'\\n%s\\n\",\n\t\t\tplugin, dlerror());\n\t\tgoto out_free;\n\t}\n\n\talias = dlsym(handle, PEVENT_PLUGIN_ALIAS_NAME);\n\tif (!alias)\n\t\talias = file;\n\n\tfunc = dlsym(handle, PEVENT_PLUGIN_LOADER_NAME);\n\tif (!func) {\n\t\twarning(\"could not find func '%s' in plugin '%s'\\n%s\\n\",\n\t\t\tPEVENT_PLUGIN_LOADER_NAME, plugin, dlerror());\n\t\tgoto out_free;\n\t}\n\n\tlist = malloc(sizeof(*list));\n\tif (!list) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\tgoto out_free;\n\t}\n\n\tlist->next = *plugin_list;\n\tlist->handle = handle;\n\tlist->name = plugin;\n\t*plugin_list = list;\n\n\tpr_stat(\"registering plugin: %s\", plugin);\n\tfunc(pevent);\n\treturn;\n\n out_free:\n\tfree(plugin);\n}\n\nstatic void\nload_plugins_dir(struct pevent *pevent, const char *suffix,\n\t\t const char *path,\n\t\t void (*load_plugin)(struct pevent *pevent,\n\t\t\t\t     const char *path,\n\t\t\t\t     const char *name,\n\t\t\t\t     void *data),\n\t\t void *data)\n{\n\tstruct dirent *dent;\n\tstruct stat st;\n\tDIR *dir;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (!S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn;\n\n\twhile ((dent = readdir(dir))) {\n\t\tconst char *name = dent->d_name;\n\n\t\tif (strcmp(name, \".\") == 0 ||\n\t\t    strcmp(name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t/* Only load plugins that end in suffix */\n\t\tif (strcmp(name + (strlen(name) - strlen(suffix)), suffix) != 0)\n\t\t\tcontinue;\n\n\t\tload_plugin(pevent, path, name, data);\n\t}\n\n\tclosedir(dir);\n}\n\nstatic void\nload_plugins(struct pevent *pevent, const char *suffix,\n\t     void (*load_plugin)(struct pevent *pevent,\n\t\t\t\t const char *path,\n\t\t\t\t const char *name,\n\t\t\t\t void *data),\n\t     void *data)\n{\n\tchar *home;\n\tchar *path;\n\tchar *envdir;\n\n\tif (pevent->flags & PEVENT_DISABLE_PLUGINS)\n\t\treturn;\n\n\t/*\n\t * If a system plugin directory was defined,\n\t * check that first.\n\t */\n#ifdef PLUGIN_DIR\n\tif (!(pevent->flags & PEVENT_DISABLE_SYS_PLUGINS))\n\t\tload_plugins_dir(pevent, suffix, PLUGIN_DIR,\n\t\t\t\t load_plugin, data);\n#endif\n\n\t/*\n\t * Next let the environment-set plugin directory\n\t * override the system defaults.\n\t */\n\tenvdir = getenv(\"TRACEEVENT_PLUGIN_DIR\");\n\tif (envdir)\n\t\tload_plugins_dir(pevent, suffix, envdir, load_plugin, data);\n\n\t/*\n\t * Now let the home directory override the environment\n\t * or system defaults.\n\t */\n\thome = getenv(\"HOME\");\n\tif (!home)\n\t\treturn;\n\n\tpath = malloc(strlen(home) + strlen(LOCAL_PLUGIN_DIR) + 2);\n\tif (!path) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\treturn;\n\t}\n\n\tstrcpy(path, home);\n\tstrcat(path, \"/\");\n\tstrcat(path, LOCAL_PLUGIN_DIR);\n\n\tload_plugins_dir(pevent, suffix, path, load_plugin, data);\n\n\tfree(path);\n}\n\nstruct plugin_list*\ntraceevent_load_plugins(struct pevent *pevent)\n{\n\tstruct plugin_list *list = NULL;\n\n\tload_plugins(pevent, \".so\", load_plugin, &list);\n\treturn list;\n}\n\nvoid\ntraceevent_unload_plugins(struct plugin_list *plugin_list, struct pevent *pevent)\n{\n\tpevent_plugin_unload_func func;\n\tstruct plugin_list *list;\n\n\twhile (plugin_list) {\n\t\tlist = plugin_list;\n\t\tplugin_list = list->next;\n\t\tfunc = dlsym(list->handle, PEVENT_PLUGIN_UNLOADER_NAME);\n\t\tif (func)\n\t\t\tfunc(pevent);\n\t\tdlclose(list->handle);\n\t\tfree(list->name);\n\t\tfree(list);\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/lib/lockdep/preload.c": "#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <sysexits.h>\n#include \"include/liblockdep/mutex.h\"\n#include \"../../include/linux/rbtree.h\"\n\n/**\n * struct lock_lookup - liblockdep's view of a single unique lock\n * @orig: pointer to the original pthread lock, used for lookups\n * @dep_map: lockdep's dep_map structure\n * @key: lockdep's key structure\n * @node: rb-tree node used to store the lock in a global tree\n * @name: a unique name for the lock\n */\nstruct lock_lookup {\n\tvoid *orig; /* Original pthread lock, used for lookups */\n\tstruct lockdep_map dep_map; /* Since all locks are dynamic, we need\n\t\t\t\t     * a dep_map and a key for each lock */\n\t/*\n\t * Wait, there's no support for key classes? Yup :(\n\t * Most big projects wrap the pthread api with their own calls to\n\t * be compatible with different locking methods. This means that\n\t * \"classes\" will be brokes since the function that creates all\n\t * locks will point to a generic locking function instead of the\n\t * actual code that wants to do the locking.\n\t */\n\tstruct lock_class_key key;\n\tstruct rb_node node;\n#define LIBLOCKDEP_MAX_LOCK_NAME 22\n\tchar name[LIBLOCKDEP_MAX_LOCK_NAME];\n};\n\n/* This is where we store our locks */\nstatic struct rb_root locks = RB_ROOT;\nstatic pthread_rwlock_t locks_rwlock = PTHREAD_RWLOCK_INITIALIZER;\n\n/* pthread mutex API */\n\n#ifdef __GLIBC__\nextern int __pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);\nextern int __pthread_mutex_lock(pthread_mutex_t *mutex);\nextern int __pthread_mutex_trylock(pthread_mutex_t *mutex);\nextern int __pthread_mutex_unlock(pthread_mutex_t *mutex);\nextern int __pthread_mutex_destroy(pthread_mutex_t *mutex);\n#else\n#define __pthread_mutex_init\tNULL\n#define __pthread_mutex_lock\tNULL\n#define __pthread_mutex_trylock\tNULL\n#define __pthread_mutex_unlock\tNULL\n#define __pthread_mutex_destroy\tNULL\n#endif\nstatic int (*ll_pthread_mutex_init)(pthread_mutex_t *mutex,\n\t\t\tconst pthread_mutexattr_t *attr)\t= __pthread_mutex_init;\nstatic int (*ll_pthread_mutex_lock)(pthread_mutex_t *mutex)\t= __pthread_mutex_lock;\nstatic int (*ll_pthread_mutex_trylock)(pthread_mutex_t *mutex)\t= __pthread_mutex_trylock;\nstatic int (*ll_pthread_mutex_unlock)(pthread_mutex_t *mutex)\t= __pthread_mutex_unlock;\nstatic int (*ll_pthread_mutex_destroy)(pthread_mutex_t *mutex)\t= __pthread_mutex_destroy;\n\n/* pthread rwlock API */\n\n#ifdef __GLIBC__\nextern int __pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);\nextern int __pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\nextern int __pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\nextern int __pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\nextern int __pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nextern int __pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nextern int __pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n#else\n#define __pthread_rwlock_init\t\tNULL\n#define __pthread_rwlock_destroy\tNULL\n#define __pthread_rwlock_wrlock\t\tNULL\n#define __pthread_rwlock_trywrlock\tNULL\n#define __pthread_rwlock_rdlock\t\tNULL\n#define __pthread_rwlock_tryrdlock\tNULL\n#define __pthread_rwlock_unlock\t\tNULL\n#endif\n\nstatic int (*ll_pthread_rwlock_init)(pthread_rwlock_t *rwlock,\n\t\t\tconst pthread_rwlockattr_t *attr)\t\t= __pthread_rwlock_init;\nstatic int (*ll_pthread_rwlock_destroy)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_destroy;\nstatic int (*ll_pthread_rwlock_rdlock)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_rdlock;\nstatic int (*ll_pthread_rwlock_tryrdlock)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_tryrdlock;\nstatic int (*ll_pthread_rwlock_trywrlock)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_trywrlock;\nstatic int (*ll_pthread_rwlock_wrlock)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_wrlock;\nstatic int (*ll_pthread_rwlock_unlock)(pthread_rwlock_t *rwlock)\t= __pthread_rwlock_unlock;\n\nenum { none, prepare, done, } __init_state;\nstatic void init_preload(void);\nstatic void try_init_preload(void)\n{\n\tif (__init_state != done)\n\t\tinit_preload();\n}\n\nstatic struct rb_node **__get_lock_node(void *lock, struct rb_node **parent)\n{\n\tstruct rb_node **node = &locks.rb_node;\n\tstruct lock_lookup *l;\n\n\t*parent = NULL;\n\n\twhile (*node) {\n\t\tl = rb_entry(*node, struct lock_lookup, node);\n\n\t\t*parent = *node;\n\t\tif (lock < l->orig)\n\t\t\tnode = &l->node.rb_left;\n\t\telse if (lock > l->orig)\n\t\t\tnode = &l->node.rb_right;\n\t\telse\n\t\t\treturn node;\n\t}\n\n\treturn node;\n}\n\n#ifndef LIBLOCKDEP_STATIC_ENTRIES\n#define LIBLOCKDEP_STATIC_ENTRIES\t1024\n#endif\n\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n\nstatic struct lock_lookup __locks[LIBLOCKDEP_STATIC_ENTRIES];\nstatic int __locks_nr;\n\nstatic inline bool is_static_lock(struct lock_lookup *lock)\n{\n\treturn lock >= __locks && lock < __locks + ARRAY_SIZE(__locks);\n}\n\nstatic struct lock_lookup *alloc_lock(void)\n{\n\tif (__init_state != done) {\n\t\t/*\n\t\t * Some programs attempt to initialize and use locks in their\n\t\t * allocation path. This means that a call to malloc() would\n\t\t * result in locks being initialized and locked.\n\t\t *\n\t\t * Why is it an issue for us? dlsym() below will try allocating\n\t\t * to give us the original function. Since this allocation will\n\t\t * result in a locking operations, we have to let pthread deal\n\t\t * with it, but we can't! we don't have the pointer to the\n\t\t * original API since we're inside dlsym() trying to get it\n\t\t */\n\n\t\tint idx = __locks_nr++;\n\t\tif (idx >= ARRAY_SIZE(__locks)) {\n\t\t\tfprintf(stderr,\n\t\t\"LOCKDEP error: insufficient LIBLOCKDEP_STATIC_ENTRIES\\n\");\n\t\t\texit(EX_UNAVAILABLE);\n\t\t}\n\t\treturn __locks + idx;\n\t}\n\n\treturn malloc(sizeof(struct lock_lookup));\n}\n\nstatic inline void free_lock(struct lock_lookup *lock)\n{\n\tif (likely(!is_static_lock(lock)))\n\t\tfree(lock);\n}\n\n/**\n * __get_lock - find or create a lock instance\n * @lock: pointer to a pthread lock function\n *\n * Try to find an existing lock in the rbtree using the provided pointer. If\n * one wasn't found - create it.\n */\nstatic struct lock_lookup *__get_lock(void *lock)\n{\n\tstruct rb_node **node, *parent;\n\tstruct lock_lookup *l;\n\n\tll_pthread_rwlock_rdlock(&locks_rwlock);\n\tnode = __get_lock_node(lock, &parent);\n\tll_pthread_rwlock_unlock(&locks_rwlock);\n\tif (*node) {\n\t\treturn rb_entry(*node, struct lock_lookup, node);\n\t}\n\n\t/* We didn't find the lock, let's create it */\n\tl = alloc_lock();\n\tif (l == NULL)\n\t\treturn NULL;\n\n\tl->orig = lock;\n\t/*\n\t * Currently the name of the lock is the ptr value of the pthread lock,\n\t * while not optimal, it makes debugging a bit easier.\n\t *\n\t * TODO: Get the real name of the lock using libdwarf\n\t */\n\tsprintf(l->name, \"%p\", lock);\n\tlockdep_init_map(&l->dep_map, l->name, &l->key, 0);\n\n\tll_pthread_rwlock_wrlock(&locks_rwlock);\n\t/* This might have changed since the last time we fetched it */\n\tnode = __get_lock_node(lock, &parent);\n\trb_link_node(&l->node, parent, node);\n\trb_insert_color(&l->node, &locks);\n\tll_pthread_rwlock_unlock(&locks_rwlock);\n\n\treturn l;\n}\n\nstatic void __del_lock(struct lock_lookup *lock)\n{\n\tll_pthread_rwlock_wrlock(&locks_rwlock);\n\trb_erase(&lock->node, &locks);\n\tll_pthread_rwlock_unlock(&locks_rwlock);\n\tfree_lock(lock);\n}\n\nint pthread_mutex_init(pthread_mutex_t *mutex,\n\t\t\tconst pthread_mutexattr_t *attr)\n{\n\tint r;\n\n\t/*\n\t * We keep trying to init our preload module because there might be\n\t * code in init sections that tries to touch locks before we are\n\t * initialized, in that case we'll need to manually call preload\n\t * to get us going.\n\t *\n\t * Funny enough, kernel's lockdep had the same issue, and used\n\t * (almost) the same solution. See look_up_lock_class() in\n\t * kernel/locking/lockdep.c for details.\n\t */\n\ttry_init_preload();\n\n\tr = ll_pthread_mutex_init(mutex, attr);\n\tif (r == 0)\n\t\t/*\n\t\t * We do a dummy initialization here so that lockdep could\n\t\t * warn us if something fishy is going on - such as\n\t\t * initializing a held lock.\n\t\t */\n\t\t__get_lock(mutex);\n\n\treturn r;\n}\n\nint pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tint r;\n\n\ttry_init_preload();\n\n\tlock_acquire(&__get_lock(mutex)->dep_map, 0, 0, 0, 1, NULL,\n\t\t\t(unsigned long)_RET_IP_);\n\t/*\n\t * Here's the thing with pthread mutexes: unlike the kernel variant,\n\t * they can fail.\n\t *\n\t * This means that the behaviour here is a bit different from what's\n\t * going on in the kernel: there we just tell lockdep that we took the\n\t * lock before actually taking it, but here we must deal with the case\n\t * that locking failed.\n\t *\n\t * To do that we'll \"release\" the lock if locking failed - this way\n\t * we'll get lockdep doing the correct checks when we try to take\n\t * the lock, and if that fails - we'll be back to the correct\n\t * state by releasing it.\n\t */\n\tr = ll_pthread_mutex_lock(mutex);\n\tif (r)\n\t\tlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_mutex_trylock(pthread_mutex_t *mutex)\n{\n\tint r;\n\n\ttry_init_preload();\n\n\tlock_acquire(&__get_lock(mutex)->dep_map, 0, 1, 0, 1, NULL, (unsigned long)_RET_IP_);\n\tr = ll_pthread_mutex_trylock(mutex);\n\tif (r)\n\t\tlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tint r;\n\n\ttry_init_preload();\n\n\tlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\n\t/*\n\t * Just like taking a lock, only in reverse!\n\t *\n\t * If we fail releasing the lock, tell lockdep we're holding it again.\n\t */\n\tr = ll_pthread_mutex_unlock(mutex);\n\tif (r)\n\t\tlock_acquire(&__get_lock(mutex)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n\ttry_init_preload();\n\n\t/*\n\t * Let's see if we're releasing a lock that's held.\n\t *\n\t * TODO: Hook into free() and add that check there as well.\n\t */\n\tdebug_check_no_locks_freed(mutex, sizeof(*mutex));\n\t__del_lock(__get_lock(mutex));\n\treturn ll_pthread_mutex_destroy(mutex);\n}\n\n/* This is the rwlock part, very similar to what happened with mutex above */\nint pthread_rwlock_init(pthread_rwlock_t *rwlock,\n\t\t\tconst pthread_rwlockattr_t *attr)\n{\n\tint r;\n\n\ttry_init_preload();\n\n\tr = ll_pthread_rwlock_init(rwlock, attr);\n\tif (r == 0)\n\t\t__get_lock(rwlock);\n\n\treturn r;\n}\n\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock)\n{\n\ttry_init_preload();\n\n\tdebug_check_no_locks_freed(rwlock, sizeof(*rwlock));\n\t__del_lock(__get_lock(rwlock));\n\treturn ll_pthread_rwlock_destroy(rwlock);\n}\n\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)\n{\n\tint r;\n\n        init_preload();\n\n\tlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 2, 1, NULL, (unsigned long)_RET_IP_);\n\tr = ll_pthread_rwlock_rdlock(rwlock);\n\tif (r)\n\t\tlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)\n{\n\tint r;\n\n        init_preload();\n\n\tlock_acquire(&__get_lock(rwlock)->dep_map, 0, 1, 2, 1, NULL, (unsigned long)_RET_IP_);\n\tr = ll_pthread_rwlock_tryrdlock(rwlock);\n\tif (r)\n\t\tlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)\n{\n\tint r;\n\n        init_preload();\n\n\tlock_acquire(&__get_lock(rwlock)->dep_map, 0, 1, 0, 1, NULL, (unsigned long)_RET_IP_);\n\tr = ll_pthread_rwlock_trywrlock(rwlock);\n\tif (r)\n                lock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)\n{\n\tint r;\n\n        init_preload();\n\n\tlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\n\tr = ll_pthread_rwlock_wrlock(rwlock);\n\tif (r)\n\t\tlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock)\n{\n\tint r;\n\n        init_preload();\n\n\tlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\n\tr = ll_pthread_rwlock_unlock(rwlock);\n\tif (r)\n\t\tlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\n\n\treturn r;\n}\n\n__attribute__((constructor)) static void init_preload(void)\n{\n\tif (__init_state == done)\n\t\treturn;\n\n#ifndef __GLIBC__\n\t__init_state = prepare;\n\n\tll_pthread_mutex_init = dlsym(RTLD_NEXT, \"pthread_mutex_init\");\n\tll_pthread_mutex_lock = dlsym(RTLD_NEXT, \"pthread_mutex_lock\");\n\tll_pthread_mutex_trylock = dlsym(RTLD_NEXT, \"pthread_mutex_trylock\");\n\tll_pthread_mutex_unlock = dlsym(RTLD_NEXT, \"pthread_mutex_unlock\");\n\tll_pthread_mutex_destroy = dlsym(RTLD_NEXT, \"pthread_mutex_destroy\");\n\n\tll_pthread_rwlock_init = dlsym(RTLD_NEXT, \"pthread_rwlock_init\");\n\tll_pthread_rwlock_destroy = dlsym(RTLD_NEXT, \"pthread_rwlock_destroy\");\n\tll_pthread_rwlock_rdlock = dlsym(RTLD_NEXT, \"pthread_rwlock_rdlock\");\n\tll_pthread_rwlock_tryrdlock = dlsym(RTLD_NEXT, \"pthread_rwlock_tryrdlock\");\n\tll_pthread_rwlock_wrlock = dlsym(RTLD_NEXT, \"pthread_rwlock_wrlock\");\n\tll_pthread_rwlock_trywrlock = dlsym(RTLD_NEXT, \"pthread_rwlock_trywrlock\");\n\tll_pthread_rwlock_unlock = dlsym(RTLD_NEXT, \"pthread_rwlock_unlock\");\n#endif\n\n\t__init_state = done;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/perf/builtin-report.c": "/*\n * builtin-report.c\n *\n * Builtin report command: Analyze the perf.data input file,\n * look up and read DSOs and symbol information and display\n * a histogram of results, along various sorting keys.\n */\n#include \"builtin.h\"\n\n#include \"util/util.h\"\n#include \"util/config.h\"\n\n#include \"util/annotate.h\"\n#include \"util/color.h\"\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include \"util/symbol.h\"\n#include \"util/callchain.h\"\n#include \"util/strlist.h\"\n#include \"util/values.h\"\n\n#include \"perf.h\"\n#include \"util/debug.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/header.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n\n#include <subcmd/parse-options.h>\n#include <subcmd/exec-cmd.h>\n#include \"util/parse-events.h\"\n\n#include \"util/thread.h\"\n#include \"util/sort.h\"\n#include \"util/hist.h\"\n#include \"util/data.h\"\n#include \"arch/common.h\"\n\n#include \"util/auxtrace.h\"\n\n#include <dlfcn.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n\nstruct report {\n\tstruct perf_tool\ttool;\n\tstruct perf_session\t*session;\n\tbool\t\t\tuse_tui, use_gtk, use_stdio;\n\tbool\t\t\tshow_full_info;\n\tbool\t\t\tshow_threads;\n\tbool\t\t\tinverted_callchain;\n\tbool\t\t\tmem_mode;\n\tbool\t\t\theader;\n\tbool\t\t\theader_only;\n\tbool\t\t\tnonany_branch_mode;\n\tint\t\t\tmax_stack;\n\tstruct perf_read_values\tshow_threads_values;\n\tconst char\t\t*pretty_printing_style;\n\tconst char\t\t*cpu_list;\n\tconst char\t\t*symbol_filter_str;\n\tfloat\t\t\tmin_percent;\n\tu64\t\t\tnr_entries;\n\tu64\t\t\tqueue_size;\n\tint\t\t\tsocket_filter;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n};\n\nstatic int report__config(const char *var, const char *value, void *cb)\n{\n\tstruct report *rep = cb;\n\n\tif (!strcmp(var, \"report.group\")) {\n\t\tsymbol_conf.event_group = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.percent-limit\")) {\n\t\tdouble pcnt = strtof(value, NULL);\n\n\t\trep->min_percent = pcnt;\n\t\tcallchain_param.min_percent = pcnt;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.children\")) {\n\t\tsymbol_conf.cumulate_callchain = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.queue-size\")) {\n\t\trep->queue_size = perf_config_u64(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.sort_order\")) {\n\t\tdefault_sort_order = strdup(value);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int hist_iter__report_callback(struct hist_entry_iter *iter,\n\t\t\t\t      struct addr_location *al, bool single,\n\t\t\t\t      void *arg)\n{\n\tint err = 0;\n\tstruct report *rep = arg;\n\tstruct hist_entry *he = iter->he;\n\tstruct perf_evsel *evsel = iter->evsel;\n\tstruct mem_info *mi;\n\tstruct branch_info *bi;\n\n\tif (!ui__has_annotation())\n\t\treturn 0;\n\n\thist__account_cycles(iter->sample->branch_stack, al, iter->sample,\n\t\t\t     rep->nonany_branch_mode);\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\tbi = he->branch_info;\n\t\terr = addr_map_symbol__inc_samples(&bi->from, evsel->idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = addr_map_symbol__inc_samples(&bi->to, evsel->idx);\n\n\t} else if (rep->mem_mode) {\n\t\tmi = he->mem_info;\n\t\terr = addr_map_symbol__inc_samples(&mi->daddr, evsel->idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\n\n\t} else if (symbol_conf.cumulate_callchain) {\n\t\tif (single)\n\t\t\terr = hist_entry__inc_addr_samples(he, evsel->idx,\n\t\t\t\t\t\t\t   al->addr);\n\t} else {\n\t\terr = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct perf_evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct report *rep = container_of(tool, struct report, tool);\n\tstruct addr_location al;\n\tstruct hist_entry_iter iter = {\n\t\t.evsel \t\t\t= evsel,\n\t\t.sample \t\t= sample,\n\t\t.hide_unresolved \t= symbol_conf.hide_unresolved,\n\t\t.add_entry_cb \t\t= hist_iter__report_callback,\n\t};\n\tint ret = 0;\n\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_debug(\"problem processing %d event, skipping it.\\n\",\n\t\t\t event->header.type);\n\t\treturn -1;\n\t}\n\n\tif (symbol_conf.hide_unresolved && al.sym == NULL)\n\t\tgoto out_put;\n\n\tif (rep->cpu_list && !test_bit(sample->cpu, rep->cpu_bitmap))\n\t\tgoto out_put;\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t/*\n\t\t * A non-synthesized event might not have a branch stack if\n\t\t * branch stacks have been synthesized (using itrace options).\n\t\t */\n\t\tif (!sample->branch_stack)\n\t\t\tgoto out_put;\n\t\titer.ops = &hist_iter_branch;\n\t} else if (rep->mem_mode) {\n\t\titer.ops = &hist_iter_mem;\n\t} else if (symbol_conf.cumulate_callchain) {\n\t\titer.ops = &hist_iter_cumulative;\n\t} else {\n\t\titer.ops = &hist_iter_normal;\n\t}\n\n\tif (al.map != NULL)\n\t\tal.map->dso->hit = 1;\n\n\tret = hist_entry_iter__add(&iter, &al, rep->max_stack, rep);\n\tif (ret < 0)\n\t\tpr_debug(\"problem adding hist entry, skipping event\\n\");\nout_put:\n\taddr_location__put(&al);\n\treturn ret;\n}\n\nstatic int process_read_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct perf_evsel *evsel,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct report *rep = container_of(tool, struct report, tool);\n\n\tif (rep->show_threads) {\n\t\tconst char *name = evsel ? perf_evsel__name(evsel) : \"unknown\";\n\t\tperf_read_values_add_value(&rep->show_threads_values,\n\t\t\t\t\t   event->read.pid, event->read.tid,\n\t\t\t\t\t   event->read.id,\n\t\t\t\t\t   name,\n\t\t\t\t\t   event->read.value);\n\t}\n\n\tdump_printf(\": %d %d %s %\" PRIu64 \"\\n\", event->read.pid, event->read.tid,\n\t\t    evsel ? perf_evsel__name(evsel) : \"FAIL\",\n\t\t    event->read.value);\n\n\treturn 0;\n}\n\n/* For pipe mode, sample_type is not currently set */\nstatic int report__setup_sample_type(struct report *rep)\n{\n\tstruct perf_session *session = rep->session;\n\tu64 sample_type = perf_evlist__combined_sample_type(session->evlist);\n\tbool is_pipe = perf_data_file__is_pipe(session->file);\n\n\tif (session->itrace_synth_opts->callchain ||\n\t    (!is_pipe &&\n\t     perf_header__has_feat(&session->header, HEADER_AUXTRACE) &&\n\t     !session->itrace_synth_opts->set))\n\t\tsample_type |= PERF_SAMPLE_CALLCHAIN;\n\n\tif (session->itrace_synth_opts->last_branch)\n\t\tsample_type |= PERF_SAMPLE_BRANCH_STACK;\n\n\tif (!is_pipe && !(sample_type & PERF_SAMPLE_CALLCHAIN)) {\n\t\tif (perf_hpp_list.parent) {\n\t\t\tui__error(\"Selected --sort parent, but no \"\n\t\t\t\t    \"callchain data. Did you call \"\n\t\t\t\t    \"'perf record' without -g?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (symbol_conf.use_callchain) {\n\t\t\tui__error(\"Selected -g or --branch-history but no \"\n\t\t\t\t  \"callchain data. Did\\n\"\n\t\t\t\t  \"you call 'perf record' without -g?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!callchain_param.enabled &&\n\t\t   callchain_param.mode != CHAIN_NONE &&\n\t\t   !symbol_conf.use_callchain) {\n\t\t\tsymbol_conf.use_callchain = true;\n\t\t\tif (callchain_register_param(&callchain_param) < 0) {\n\t\t\t\tui__error(\"Can't register callchain params.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t}\n\n\tif (symbol_conf.cumulate_callchain) {\n\t\t/* Silently ignore if callchain is missing */\n\t\tif (!(sample_type & PERF_SAMPLE_CALLCHAIN)) {\n\t\t\tsymbol_conf.cumulate_callchain = false;\n\t\t\tperf_hpp__cancel_cumulate();\n\t\t}\n\t}\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\tif (!is_pipe &&\n\t\t    !(sample_type & PERF_SAMPLE_BRANCH_STACK)) {\n\t\t\tui__error(\"Selected -b but no branch data. \"\n\t\t\t\t  \"Did you call perf record without -b?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (symbol_conf.use_callchain || symbol_conf.cumulate_callchain) {\n\t\tif ((sample_type & PERF_SAMPLE_REGS_USER) &&\n\t\t    (sample_type & PERF_SAMPLE_STACK_USER))\n\t\t\tcallchain_param.record_mode = CALLCHAIN_DWARF;\n\t\telse if (sample_type & PERF_SAMPLE_BRANCH_STACK)\n\t\t\tcallchain_param.record_mode = CALLCHAIN_LBR;\n\t\telse\n\t\t\tcallchain_param.record_mode = CALLCHAIN_FP;\n\t}\n\n\t/* ??? handle more cases than just ANY? */\n\tif (!(perf_evlist__combined_branch_type(session->evlist) &\n\t\t\t\tPERF_SAMPLE_BRANCH_ANY))\n\t\trep->nonany_branch_mode = true;\n\n\treturn 0;\n}\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tsession_done = 1;\n}\n\nstatic size_t hists__fprintf_nr_sample_events(struct hists *hists, struct report *rep,\n\t\t\t\t\t      const char *evname, FILE *fp)\n{\n\tsize_t ret;\n\tchar unit;\n\tunsigned long nr_samples = hists->stats.nr_events[PERF_RECORD_SAMPLE];\n\tu64 nr_events = hists->stats.total_period;\n\tstruct perf_evsel *evsel = hists_to_evsel(hists);\n\tchar buf[512];\n\tsize_t size = sizeof(buf);\n\tint socked_id = hists->socket_filter;\n\n\tif (symbol_conf.filter_relative) {\n\t\tnr_samples = hists->stats.nr_non_filtered_samples;\n\t\tnr_events = hists->stats.total_non_filtered_period;\n\t}\n\n\tif (perf_evsel__is_group_event(evsel)) {\n\t\tstruct perf_evsel *pos;\n\n\t\tperf_evsel__group_desc(evsel, buf, size);\n\t\tevname = buf;\n\n\t\tfor_each_group_member(pos, evsel) {\n\t\t\tconst struct hists *pos_hists = evsel__hists(pos);\n\n\t\t\tif (symbol_conf.filter_relative) {\n\t\t\t\tnr_samples += pos_hists->stats.nr_non_filtered_samples;\n\t\t\t\tnr_events += pos_hists->stats.total_non_filtered_period;\n\t\t\t} else {\n\t\t\t\tnr_samples += pos_hists->stats.nr_events[PERF_RECORD_SAMPLE];\n\t\t\t\tnr_events += pos_hists->stats.total_period;\n\t\t\t}\n\t\t}\n\t}\n\n\tnr_samples = convert_unit(nr_samples, &unit);\n\tret = fprintf(fp, \"# Samples: %lu%c\", nr_samples, unit);\n\tif (evname != NULL)\n\t\tret += fprintf(fp, \" of event '%s'\", evname);\n\n\tif (symbol_conf.show_ref_callgraph &&\n\t    strstr(evname, \"call-graph=no\")) {\n\t\tret += fprintf(fp, \", show reference callgraph\");\n\t}\n\n\tif (rep->mem_mode) {\n\t\tret += fprintf(fp, \"\\n# Total weight : %\" PRIu64, nr_events);\n\t\tret += fprintf(fp, \"\\n# Sort order   : %s\", sort_order ? : default_mem_sort_order);\n\t} else\n\t\tret += fprintf(fp, \"\\n# Event count (approx.): %\" PRIu64, nr_events);\n\n\tif (socked_id > -1)\n\t\tret += fprintf(fp, \"\\n# Processor Socket: %d\", socked_id);\n\n\treturn ret + fprintf(fp, \"\\n#\\n\");\n}\n\nstatic int perf_evlist__tty_browse_hists(struct perf_evlist *evlist,\n\t\t\t\t\t struct report *rep,\n\t\t\t\t\t const char *help)\n{\n\tstruct perf_evsel *pos;\n\n\tfprintf(stdout, \"#\\n# Total Lost Samples: %\" PRIu64 \"\\n#\\n\", evlist->stats.total_lost_samples);\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\tconst char *evname = perf_evsel__name(pos);\n\n\t\tif (symbol_conf.event_group &&\n\t\t    !perf_evsel__is_group_leader(pos))\n\t\t\tcontinue;\n\n\t\thists__fprintf_nr_sample_events(hists, rep, evname, stdout);\n\t\thists__fprintf(hists, true, 0, 0, rep->min_percent, stdout,\n\t\t\t       symbol_conf.use_callchain);\n\t\tfprintf(stdout, \"\\n\\n\");\n\t}\n\n\tif (sort_order == NULL &&\n\t    parent_pattern == default_parent_pattern)\n\t\tfprintf(stdout, \"#\\n# (%s)\\n#\\n\", help);\n\n\tif (rep->show_threads) {\n\t\tbool style = !strcmp(rep->pretty_printing_style, \"raw\");\n\t\tperf_read_values_display(stdout, &rep->show_threads_values,\n\t\t\t\t\t style);\n\t\tperf_read_values_destroy(&rep->show_threads_values);\n\t}\n\n\treturn 0;\n}\n\nstatic void report__warn_kptr_restrict(const struct report *rep)\n{\n\tstruct map *kernel_map = machine__kernel_map(&rep->session->machines.host);\n\tstruct kmap *kernel_kmap = kernel_map ? map__kmap(kernel_map) : NULL;\n\n\tif (kernel_map == NULL ||\n\t    (kernel_map->dso->hit &&\n\t     (kernel_kmap->ref_reloc_sym == NULL ||\n\t      kernel_kmap->ref_reloc_sym->addr == 0))) {\n\t\tconst char *desc =\n\t\t    \"As no suitable kallsyms nor vmlinux was found, kernel samples\\n\"\n\t\t    \"can't be resolved.\";\n\n\t\tif (kernel_map) {\n\t\t\tconst struct dso *kdso = kernel_map->dso;\n\t\t\tif (!RB_EMPTY_ROOT(&kdso->symbols[MAP__FUNCTION])) {\n\t\t\t\tdesc = \"If some relocation was applied (e.g. \"\n\t\t\t\t       \"kexec) symbols may be misresolved.\";\n\t\t\t}\n\t\t}\n\n\t\tui__warning(\n\"Kernel address maps (/proc/{kallsyms,modules}) were restricted.\\n\\n\"\n\"Check /proc/sys/kernel/kptr_restrict before running 'perf record'.\\n\\n%s\\n\\n\"\n\"Samples in kernel modules can't be resolved as well.\\n\\n\",\n\t\tdesc);\n\t}\n}\n\nstatic int report__gtk_browse_hists(struct report *rep, const char *help)\n{\n\tint (*hist_browser)(struct perf_evlist *evlist, const char *help,\n\t\t\t    struct hist_browser_timer *timer, float min_pcnt);\n\n\thist_browser = dlsym(perf_gtk_handle, \"perf_evlist__gtk_browse_hists\");\n\n\tif (hist_browser == NULL) {\n\t\tui__error(\"GTK browser not found!\\n\");\n\t\treturn -1;\n\t}\n\n\treturn hist_browser(rep->session->evlist, help, NULL, rep->min_percent);\n}\n\nstatic int report__browse_hists(struct report *rep)\n{\n\tint ret;\n\tstruct perf_session *session = rep->session;\n\tstruct perf_evlist *evlist = session->evlist;\n\tconst char *help = perf_tip(system_path(TIPDIR));\n\n\tif (help == NULL) {\n\t\t/* fallback for people who don't install perf ;-) */\n\t\thelp = perf_tip(DOCDIR);\n\t\tif (help == NULL)\n\t\t\thelp = \"Cannot load tips.txt file, please install perf!\";\n\t}\n\n\tswitch (use_browser) {\n\tcase 1:\n\t\tret = perf_evlist__tui_browse_hists(evlist, help, NULL,\n\t\t\t\t\t\t    rep->min_percent,\n\t\t\t\t\t\t    &session->header.env);\n\t\t/*\n\t\t * Usually \"ret\" is the last pressed key, and we only\n\t\t * care if the key notifies us to switch data file.\n\t\t */\n\t\tif (ret != K_SWITCH_INPUT_DATA)\n\t\t\tret = 0;\n\t\tbreak;\n\tcase 2:\n\t\tret = report__gtk_browse_hists(rep, help);\n\t\tbreak;\n\tdefault:\n\t\tret = perf_evlist__tty_browse_hists(evlist, rep, help);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int report__collapse_hists(struct report *rep)\n{\n\tstruct ui_progress prog;\n\tstruct perf_evsel *pos;\n\tint ret = 0;\n\n\tui_progress__init(&prog, rep->nr_entries, \"Merging related events...\");\n\n\tevlist__for_each_entry(rep->session->evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\n\t\tif (pos->idx == 0)\n\t\t\thists->symbol_filter_str = rep->symbol_filter_str;\n\n\t\thists->socket_filter = rep->socket_filter;\n\n\t\tret = hists__collapse_resort(hists, &prog);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/* Non-group events are considered as leader */\n\t\tif (symbol_conf.event_group &&\n\t\t    !perf_evsel__is_group_leader(pos)) {\n\t\t\tstruct hists *leader_hists = evsel__hists(pos->leader);\n\n\t\t\thists__match(leader_hists, hists);\n\t\t\thists__link(leader_hists, hists);\n\t\t}\n\t}\n\n\tui_progress__finish();\n\treturn ret;\n}\n\nstatic void report__output_resort(struct report *rep)\n{\n\tstruct ui_progress prog;\n\tstruct perf_evsel *pos;\n\n\tui_progress__init(&prog, rep->nr_entries, \"Sorting events for output...\");\n\n\tevlist__for_each_entry(rep->session->evlist, pos)\n\t\tperf_evsel__output_resort(pos, &prog);\n\n\tui_progress__finish();\n}\n\nstatic int __cmd_report(struct report *rep)\n{\n\tint ret;\n\tstruct perf_session *session = rep->session;\n\tstruct perf_evsel *pos;\n\tstruct perf_data_file *file = session->file;\n\n\tsignal(SIGINT, sig_handler);\n\n\tif (rep->cpu_list) {\n\t\tret = perf_session__cpu_bitmap(session, rep->cpu_list,\n\t\t\t\t\t       rep->cpu_bitmap);\n\t\tif (ret) {\n\t\t\tui__error(\"failed to set cpu bitmap\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rep->show_threads)\n\t\tperf_read_values_init(&rep->show_threads_values);\n\n\tret = report__setup_sample_type(rep);\n\tif (ret) {\n\t\t/* report__setup_sample_type() already showed error message */\n\t\treturn ret;\n\t}\n\n\tret = perf_session__process_events(session);\n\tif (ret) {\n\t\tui__error(\"failed to process sample\\n\");\n\t\treturn ret;\n\t}\n\n\treport__warn_kptr_restrict(rep);\n\n\tevlist__for_each_entry(session->evlist, pos)\n\t\trep->nr_entries += evsel__hists(pos)->nr_entries;\n\n\tif (use_browser == 0) {\n\t\tif (verbose > 3)\n\t\t\tperf_session__fprintf(session, stdout);\n\n\t\tif (verbose > 2)\n\t\t\tperf_session__fprintf_dsos(session, stdout);\n\n\t\tif (dump_trace) {\n\t\t\tperf_session__fprintf_nr_events(session, stdout);\n\t\t\tperf_evlist__fprintf_nr_events(session->evlist, stdout);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = report__collapse_hists(rep);\n\tif (ret) {\n\t\tui__error(\"failed to process hist entry\\n\");\n\t\treturn ret;\n\t}\n\n\tif (session_done())\n\t\treturn 0;\n\n\t/*\n\t * recalculate number of entries after collapsing since it\n\t * might be changed during the collapse phase.\n\t */\n\trep->nr_entries = 0;\n\tevlist__for_each_entry(session->evlist, pos)\n\t\trep->nr_entries += evsel__hists(pos)->nr_entries;\n\n\tif (rep->nr_entries == 0) {\n\t\tui__error(\"The %s file has no samples!\\n\", file->path);\n\t\treturn 0;\n\t}\n\n\treport__output_resort(rep);\n\n\treturn report__browse_hists(rep);\n}\n\nstatic int\nreport_parse_callchain_opt(const struct option *opt, const char *arg, int unset)\n{\n\tstruct callchain_param *callchain = opt->value;\n\n\tcallchain->enabled = !unset;\n\t/*\n\t * --no-call-graph\n\t */\n\tif (unset) {\n\t\tsymbol_conf.use_callchain = false;\n\t\tcallchain->mode = CHAIN_NONE;\n\t\treturn 0;\n\t}\n\n\treturn parse_callchain_report_opt(arg);\n}\n\nint\nreport_parse_ignore_callees_opt(const struct option *opt __maybe_unused,\n\t\t\t\tconst char *arg, int unset __maybe_unused)\n{\n\tif (arg) {\n\t\tint err = regcomp(&ignore_callees_regex, arg, REG_EXTENDED);\n\t\tif (err) {\n\t\t\tchar buf[BUFSIZ];\n\t\t\tregerror(err, &ignore_callees_regex, buf, sizeof(buf));\n\t\t\tpr_err(\"Invalid --ignore-callees regex: %s\\n%s\", arg, buf);\n\t\t\treturn -1;\n\t\t}\n\t\thave_ignore_callees = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparse_branch_mode(const struct option *opt __maybe_unused,\n\t\t  const char *str __maybe_unused, int unset)\n{\n\tint *branch_mode = opt->value;\n\n\t*branch_mode = !unset;\n\treturn 0;\n}\n\nstatic int\nparse_percent_limit(const struct option *opt, const char *str,\n\t\t    int unset __maybe_unused)\n{\n\tstruct report *rep = opt->value;\n\tdouble pcnt = strtof(str, NULL);\n\n\trep->min_percent = pcnt;\n\tcallchain_param.min_percent = pcnt;\n\treturn 0;\n}\n\n#define CALLCHAIN_DEFAULT_OPT  \"graph,0.5,caller,function,percent\"\n\nconst char report_callchain_help[] = \"Display call graph (stack chain/backtrace):\\n\\n\"\n\t\t\t\t     CALLCHAIN_REPORT_HELP\n\t\t\t\t     \"\\n\\t\\t\\t\\tDefault: \" CALLCHAIN_DEFAULT_OPT;\n\nint cmd_report(int argc, const char **argv, const char *prefix __maybe_unused)\n{\n\tstruct perf_session *session;\n\tstruct itrace_synth_opts itrace_synth_opts = { .set = 0, };\n\tstruct stat st;\n\tbool has_br_stack = false;\n\tint branch_mode = -1;\n\tbool branch_call_mode = false;\n\tchar callchain_default_opt[] = CALLCHAIN_DEFAULT_OPT;\n\tconst char * const report_usage[] = {\n\t\t\"perf report [<options>]\",\n\t\tNULL\n\t};\n\tstruct report report = {\n\t\t.tool = {\n\t\t\t.sample\t\t = process_sample_event,\n\t\t\t.mmap\t\t = perf_event__process_mmap,\n\t\t\t.mmap2\t\t = perf_event__process_mmap2,\n\t\t\t.comm\t\t = perf_event__process_comm,\n\t\t\t.exit\t\t = perf_event__process_exit,\n\t\t\t.fork\t\t = perf_event__process_fork,\n\t\t\t.lost\t\t = perf_event__process_lost,\n\t\t\t.read\t\t = process_read_event,\n\t\t\t.attr\t\t = perf_event__process_attr,\n\t\t\t.tracing_data\t = perf_event__process_tracing_data,\n\t\t\t.build_id\t = perf_event__process_build_id,\n\t\t\t.id_index\t = perf_event__process_id_index,\n\t\t\t.auxtrace_info\t = perf_event__process_auxtrace_info,\n\t\t\t.auxtrace\t = perf_event__process_auxtrace,\n\t\t\t.ordered_events\t = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t\t.max_stack\t\t = PERF_MAX_STACK_DEPTH,\n\t\t.pretty_printing_style\t = \"normal\",\n\t\t.socket_filter\t\t = -1,\n\t};\n\tconst struct option options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t    \"input file name\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('f', \"force\", &symbol_conf.force, \"don't complain, do it\"),\n\tOPT_BOOLEAN('m', \"modules\", &symbol_conf.use_modules,\n\t\t    \"load module symbols - WARNING: use only with -k and LIVE kernel\"),\n\tOPT_BOOLEAN('n', \"show-nr-samples\", &symbol_conf.show_nr_samples,\n\t\t    \"Show a column with the number of samples\"),\n\tOPT_BOOLEAN('T', \"threads\", &report.show_threads,\n\t\t    \"Show per-thread event counters\"),\n\tOPT_STRING(0, \"pretty\", &report.pretty_printing_style, \"key\",\n\t\t   \"pretty printing style key: normal raw\"),\n\tOPT_BOOLEAN(0, \"tui\", &report.use_tui, \"Use the TUI interface\"),\n\tOPT_BOOLEAN(0, \"gtk\", &report.use_gtk, \"Use the GTK2 interface\"),\n\tOPT_BOOLEAN(0, \"stdio\", &report.use_stdio,\n\t\t    \"Use the stdio interface\"),\n\tOPT_BOOLEAN(0, \"header\", &report.header, \"Show data header.\"),\n\tOPT_BOOLEAN(0, \"header-only\", &report.header_only,\n\t\t    \"Show only data header.\"),\n\tOPT_STRING('s', \"sort\", &sort_order, \"key[,key2...]\",\n\t\t   \"sort by key(s): pid, comm, dso, symbol, parent, cpu, srcline, ...\"\n\t\t   \" Please refer the man page for the complete list.\"),\n\tOPT_STRING('F', \"fields\", &field_order, \"key[,keys...]\",\n\t\t   \"output field(s): overhead, period, sample plus all of sort keys\"),\n\tOPT_BOOLEAN(0, \"show-cpu-utilization\", &symbol_conf.show_cpu_utilization,\n\t\t    \"Show sample percentage for different cpu modes\"),\n\tOPT_BOOLEAN_FLAG(0, \"showcpuutilization\", &symbol_conf.show_cpu_utilization,\n\t\t    \"Show sample percentage for different cpu modes\", PARSE_OPT_HIDDEN),\n\tOPT_STRING('p', \"parent\", &parent_pattern, \"regex\",\n\t\t   \"regex filter to identify parent, see: '--sort parent'\"),\n\tOPT_BOOLEAN('x', \"exclude-other\", &symbol_conf.exclude_other,\n\t\t    \"Only display entries with parent-match\"),\n\tOPT_CALLBACK_DEFAULT('g', \"call-graph\", &callchain_param,\n\t\t\t     \"print_type,threshold[,print_limit],order,sort_key[,branch],value\",\n\t\t\t     report_callchain_help, &report_parse_callchain_opt,\n\t\t\t     callchain_default_opt),\n\tOPT_BOOLEAN(0, \"children\", &symbol_conf.cumulate_callchain,\n\t\t    \"Accumulate callchains of children and show total overhead as well\"),\n\tOPT_INTEGER(0, \"max-stack\", &report.max_stack,\n\t\t    \"Set the maximum stack depth when parsing the callchain, \"\n\t\t    \"anything beyond the specified depth will be ignored. \"\n\t\t    \"Default: kernel.perf_event_max_stack or \" __stringify(PERF_MAX_STACK_DEPTH)),\n\tOPT_BOOLEAN('G', \"inverted\", &report.inverted_callchain,\n\t\t    \"alias for inverted call graph\"),\n\tOPT_CALLBACK(0, \"ignore-callees\", NULL, \"regex\",\n\t\t   \"ignore callees of these functions in call graphs\",\n\t\t   report_parse_ignore_callees_opt),\n\tOPT_STRING('d', \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING('c', \"comms\", &symbol_conf.comm_list_str, \"comm[,comm...]\",\n\t\t   \"only consider symbols in these comms\"),\n\tOPT_STRING(0, \"pid\", &symbol_conf.pid_list_str, \"pid[,pid...]\",\n\t\t   \"only consider symbols in these pids\"),\n\tOPT_STRING(0, \"tid\", &symbol_conf.tid_list_str, \"tid[,tid...]\",\n\t\t   \"only consider symbols in these tids\"),\n\tOPT_STRING('S', \"symbols\", &symbol_conf.sym_list_str, \"symbol[,symbol...]\",\n\t\t   \"only consider these symbols\"),\n\tOPT_STRING(0, \"symbol-filter\", &report.symbol_filter_str, \"filter\",\n\t\t   \"only show symbols that (partially) match with this filter\"),\n\tOPT_STRING('w', \"column-widths\", &symbol_conf.col_width_list_str,\n\t\t   \"width[,width...]\",\n\t\t   \"don't try to adjust column width, use these fixed values\"),\n\tOPT_STRING_NOEMPTY('t', \"field-separator\", &symbol_conf.field_sep, \"separator\",\n\t\t   \"separator for columns, no spaces will be added between \"\n\t\t   \"columns '.' is reserved.\"),\n\tOPT_BOOLEAN('U', \"hide-unresolved\", &symbol_conf.hide_unresolved,\n\t\t    \"Only display entries resolved to a symbol\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_STRING('C', \"cpu\", &report.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_BOOLEAN('I', \"show-info\", &report.show_full_info,\n\t\t    \"Display extended information about perf.data file\"),\n\tOPT_BOOLEAN(0, \"source\", &symbol_conf.annotate_src,\n\t\t    \"Interleave source code with assembly code (default)\"),\n\tOPT_BOOLEAN(0, \"asm-raw\", &symbol_conf.annotate_asm_raw,\n\t\t    \"Display raw encoding of assembly instructions (default)\"),\n\tOPT_STRING('M', \"disassembler-style\", &disassembler_style, \"disassembler style\",\n\t\t   \"Specify disassembler style (e.g. -M intel for intel syntax)\"),\n\tOPT_BOOLEAN(0, \"show-total-period\", &symbol_conf.show_total_period,\n\t\t    \"Show a column with the sum of periods\"),\n\tOPT_BOOLEAN(0, \"group\", &symbol_conf.event_group,\n\t\t    \"Show event group information together\"),\n\tOPT_CALLBACK_NOOPT('b', \"branch-stack\", &branch_mode, \"\",\n\t\t    \"use branch records for per branch histogram filling\",\n\t\t    parse_branch_mode),\n\tOPT_BOOLEAN(0, \"branch-history\", &branch_call_mode,\n\t\t    \"add last branch records to call history\"),\n\tOPT_STRING(0, \"objdump\", &objdump_path, \"path\",\n\t\t   \"objdump binary to use for disassembly and annotations\"),\n\tOPT_BOOLEAN(0, \"demangle\", &symbol_conf.demangle,\n\t\t    \"Disable symbol demangling\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t    \"Enable kernel symbol demangling\"),\n\tOPT_BOOLEAN(0, \"mem-mode\", &report.mem_mode, \"mem access profile\"),\n\tOPT_CALLBACK(0, \"percent-limit\", &report, \"percent\",\n\t\t     \"Don't show entries under that percent\", parse_percent_limit),\n\tOPT_CALLBACK(0, \"percentage\", NULL, \"relative|absolute\",\n\t\t     \"how to display percentage of filtered entries\", parse_filter_percentage),\n\tOPT_CALLBACK_OPTARG(0, \"itrace\", &itrace_synth_opts, NULL, \"opts\",\n\t\t\t    \"Instruction Tracing options\",\n\t\t\t    itrace_parse_synth_opts),\n\tOPT_BOOLEAN(0, \"full-source-path\", &srcline_full_filename,\n\t\t\t\"Show full source file name path for source lines\"),\n\tOPT_BOOLEAN(0, \"show-ref-call-graph\", &symbol_conf.show_ref_callgraph,\n\t\t    \"Show callgraph from reference event\"),\n\tOPT_INTEGER(0, \"socket-filter\", &report.socket_filter,\n\t\t    \"only show processor socket that match with this filter\"),\n\tOPT_BOOLEAN(0, \"raw-trace\", &symbol_conf.raw_trace,\n\t\t    \"Show raw trace event output (do not use print fmt or plugins)\"),\n\tOPT_BOOLEAN(0, \"hierarchy\", &symbol_conf.report_hierarchy,\n\t\t    \"Show entries in a hierarchy\"),\n\tOPT_CALLBACK_DEFAULT(0, \"stdio-color\", NULL, \"mode\",\n\t\t\t     \"'always' (default), 'never' or 'auto' only applicable to --stdio mode\",\n\t\t\t     stdio__config_color, \"always\"),\n\tOPT_END()\n\t};\n\tstruct perf_data_file file = {\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t};\n\tint ret = hists__init();\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tperf_config(report__config, &report);\n\n\targc = parse_options(argc, argv, options, report_usage, 0);\n\tif (argc) {\n\t\t/*\n\t\t * Special case: if there's an argument left then assume that\n\t\t * it's a symbol filter:\n\t\t */\n\t\tif (argc > 1)\n\t\t\tusage_with_options(report_usage, options);\n\n\t\treport.symbol_filter_str = argv[0];\n\t}\n\n\tif (symbol_conf.vmlinux_name &&\n\t    access(symbol_conf.vmlinux_name, R_OK)) {\n\t\tpr_err(\"Invalid file: %s\\n\", symbol_conf.vmlinux_name);\n\t\treturn -EINVAL;\n\t}\n\tif (symbol_conf.kallsyms_name &&\n\t    access(symbol_conf.kallsyms_name, R_OK)) {\n\t\tpr_err(\"Invalid file: %s\\n\", symbol_conf.kallsyms_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (report.use_stdio)\n\t\tuse_browser = 0;\n\telse if (report.use_tui)\n\t\tuse_browser = 1;\n\telse if (report.use_gtk)\n\t\tuse_browser = 2;\n\n\tif (report.inverted_callchain)\n\t\tcallchain_param.order = ORDER_CALLER;\n\tif (symbol_conf.cumulate_callchain && !callchain_param.order_set)\n\t\tcallchain_param.order = ORDER_CALLER;\n\n\tif (itrace_synth_opts.callchain &&\n\t    (int)itrace_synth_opts.callchain_sz > report.max_stack)\n\t\treport.max_stack = itrace_synth_opts.callchain_sz;\n\n\tif (!input_name || !strlen(input_name)) {\n\t\tif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\n\t\t\tinput_name = \"-\";\n\t\telse\n\t\t\tinput_name = \"perf.data\";\n\t}\n\n\tfile.path  = input_name;\n\tfile.force = symbol_conf.force;\n\nrepeat:\n\tsession = perf_session__new(&file, false, &report.tool);\n\tif (session == NULL)\n\t\treturn -1;\n\n\tif (report.queue_size) {\n\t\tordered_events__set_alloc_size(&session->ordered_events,\n\t\t\t\t\t       report.queue_size);\n\t}\n\n\tsession->itrace_synth_opts = &itrace_synth_opts;\n\n\treport.session = session;\n\n\thas_br_stack = perf_header__has_feat(&session->header,\n\t\t\t\t\t     HEADER_BRANCH_STACK);\n\n\tif (itrace_synth_opts.last_branch)\n\t\thas_br_stack = true;\n\n\t/*\n\t * Branch mode is a tristate:\n\t * -1 means default, so decide based on the file having branch data.\n\t * 0/1 means the user chose a mode.\n\t */\n\tif (((branch_mode == -1 && has_br_stack) || branch_mode == 1) &&\n\t    !branch_call_mode) {\n\t\tsort__mode = SORT_MODE__BRANCH;\n\t\tsymbol_conf.cumulate_callchain = false;\n\t}\n\tif (branch_call_mode) {\n\t\tcallchain_param.key = CCKEY_ADDRESS;\n\t\tcallchain_param.branch_callstack = 1;\n\t\tsymbol_conf.use_callchain = true;\n\t\tcallchain_register_param(&callchain_param);\n\t\tif (sort_order == NULL)\n\t\t\tsort_order = \"srcline,symbol,dso\";\n\t}\n\n\tif (report.mem_mode) {\n\t\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t\tpr_err(\"branch and mem mode incompatible\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tsort__mode = SORT_MODE__MEMORY;\n\t\tsymbol_conf.cumulate_callchain = false;\n\t}\n\n\tif (symbol_conf.report_hierarchy) {\n\t\t/* disable incompatible options */\n\t\tsymbol_conf.cumulate_callchain = false;\n\n\t\tif (field_order) {\n\t\t\tpr_err(\"Error: --hierarchy and --fields options cannot be used together\\n\");\n\t\t\tparse_options_usage(report_usage, options, \"F\", 1);\n\t\t\tparse_options_usage(NULL, options, \"hierarchy\", 0);\n\t\t\tgoto error;\n\t\t}\n\n\t\tperf_hpp_list.need_collapse = true;\n\t}\n\n\t/* Force tty output for header output and per-thread stat. */\n\tif (report.header || report.header_only || report.show_threads)\n\t\tuse_browser = 0;\n\n\tif (strcmp(input_name, \"-\") != 0)\n\t\tsetup_browser(true);\n\telse\n\t\tuse_browser = 0;\n\n\tif (setup_sorting(session->evlist) < 0) {\n\t\tif (sort_order)\n\t\t\tparse_options_usage(report_usage, options, \"s\", 1);\n\t\tif (field_order)\n\t\t\tparse_options_usage(sort_order ? NULL : report_usage,\n\t\t\t\t\t    options, \"F\", 1);\n\t\tgoto error;\n\t}\n\n\tif (report.header || report.header_only) {\n\t\tperf_session__fprintf_info(session, stdout,\n\t\t\t\t\t   report.show_full_info);\n\t\tif (report.header_only) {\n\t\t\tret = 0;\n\t\t\tgoto error;\n\t\t}\n\t} else if (use_browser == 0) {\n\t\tfputs(\"# To display the perf.data header info, please use --header/--header-only options.\\n#\\n\",\n\t\t      stdout);\n\t}\n\n\t/*\n\t * Only in the TUI browser we are doing integrated annotation,\n\t * so don't allocate extra space that won't be used in the stdio\n\t * implementation.\n\t */\n\tif (ui__has_annotation()) {\n\t\tret = symbol__annotation_init();\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\t/*\n \t\t * For searching by name on the \"Browse map details\".\n \t\t * providing it only in verbose mode not to bloat too\n \t\t * much struct symbol.\n \t\t */\n\t\tif (verbose) {\n\t\t\t/*\n\t\t\t * XXX: Need to provide a less kludgy way to ask for\n\t\t\t * more space per symbol, the u32 is for the index on\n\t\t\t * the ui browser.\n\t\t\t * See symbol__browser_index.\n\t\t\t */\n\t\t\tsymbol_conf.priv_size += sizeof(u32);\n\t\t\tsymbol_conf.sort_by_name = true;\n\t\t}\n\t}\n\n\tif (symbol__init(&session->header.env) < 0)\n\t\tgoto error;\n\n\tsort__setup_elide(stdout);\n\n\tret = __cmd_report(&report);\n\tif (ret == K_SWITCH_INPUT_DATA) {\n\t\tperf_session__delete(session);\n\t\tgoto repeat;\n\t} else\n\t\tret = 0;\n\nerror:\n\tperf_session__delete(session);\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/perf/builtin-annotate.c": "/*\n * builtin-annotate.c\n *\n * Builtin annotate command: Analyze the perf.data input file,\n * look up and read DSOs and symbol information and display\n * a histogram of results, along various sorting keys.\n */\n#include \"builtin.h\"\n\n#include \"util/util.h\"\n#include \"util/color.h\"\n#include <linux/list.h>\n#include \"util/cache.h\"\n#include <linux/rbtree.h>\n#include \"util/symbol.h\"\n\n#include \"perf.h\"\n#include \"util/debug.h\"\n\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/annotate.h\"\n#include \"util/event.h\"\n#include <subcmd/parse-options.h>\n#include \"util/parse-events.h\"\n#include \"util/thread.h\"\n#include \"util/sort.h\"\n#include \"util/hist.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/data.h\"\n#include \"arch/common.h\"\n#include \"util/block-range.h\"\n\n#include <dlfcn.h>\n#include <linux/bitmap.h>\n\nstruct perf_annotate {\n\tstruct perf_tool tool;\n\tstruct perf_session *session;\n\tbool\t   use_tui, use_stdio, use_gtk;\n\tbool\t   full_paths;\n\tbool\t   print_line;\n\tbool\t   skip_missing;\n\tconst char *sym_hist_filter;\n\tconst char *cpu_list;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n};\n\n/*\n * Given one basic block:\n *\n *\tfrom\tto\t\tbranch_i\n *\t* ----> *\n *\t\t|\n *\t\t| block\n *\t\tv\n *\t\t* ----> *\n *\t\tfrom\tto\tbranch_i+1\n *\n * where the horizontal are the branches and the vertical is the executed\n * block of instructions.\n *\n * We count, for each 'instruction', the number of blocks that covered it as\n * well as count the ratio each branch is taken.\n *\n * We can do this without knowing the actual instruction stream by keeping\n * track of the address ranges. We break down ranges such that there is no\n * overlap and iterate from the start until the end.\n *\n * @acme: once we parse the objdump output _before_ processing the samples,\n * we can easily fold the branch.cycles IPC bits in.\n */\nstatic void process_basic_block(struct addr_map_symbol *start,\n\t\t\t\tstruct addr_map_symbol *end,\n\t\t\t\tstruct branch_flags *flags)\n{\n\tstruct symbol *sym = start->sym;\n\tstruct annotation *notes = sym ? symbol__annotation(sym) : NULL;\n\tstruct block_range_iter iter;\n\tstruct block_range *entry;\n\n\t/*\n\t * Sanity; NULL isn't executable and the CPU cannot execute backwards\n\t */\n\tif (!start->addr || start->addr > end->addr)\n\t\treturn;\n\n\titer = block_range__create(start->addr, end->addr);\n\tif (!block_range_iter__valid(&iter))\n\t\treturn;\n\n\t/*\n\t * First block in range is a branch target.\n\t */\n\tentry = block_range_iter(&iter);\n\tassert(entry->is_target);\n\tentry->entry++;\n\n\tdo {\n\t\tentry = block_range_iter(&iter);\n\n\t\tentry->coverage++;\n\t\tentry->sym = sym;\n\n\t\tif (notes)\n\t\t\tnotes->max_coverage = max(notes->max_coverage, entry->coverage);\n\n\t} while (block_range_iter__next(&iter));\n\n\t/*\n\t * Last block in rage is a branch.\n\t */\n\tentry = block_range_iter(&iter);\n\tassert(entry->is_branch);\n\tentry->taken++;\n\tif (flags->predicted)\n\t\tentry->pred++;\n}\n\nstatic void process_branch_stack(struct branch_stack *bs, struct addr_location *al,\n\t\t\t\t struct perf_sample *sample)\n{\n\tstruct addr_map_symbol *prev = NULL;\n\tstruct branch_info *bi;\n\tint i;\n\n\tif (!bs || !bs->nr)\n\t\treturn;\n\n\tbi = sample__resolve_bstack(sample, al);\n\tif (!bi)\n\t\treturn;\n\n\tfor (i = bs->nr - 1; i >= 0; i--) {\n\t\t/*\n\t\t * XXX filter against symbol\n\t\t */\n\t\tif (prev)\n\t\t\tprocess_basic_block(prev, &bi[i].from, &bi[i].flags);\n\t\tprev = &bi[i].to;\n\t}\n\n\tfree(bi);\n}\n\nstatic int perf_evsel__add_sample(struct perf_evsel *evsel,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  struct addr_location *al,\n\t\t\t\t  struct perf_annotate *ann)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct hist_entry *he;\n\tint ret;\n\n\tif (ann->sym_hist_filter != NULL &&\n\t    (al->sym == NULL ||\n\t     strcmp(ann->sym_hist_filter, al->sym->name) != 0)) {\n\t\t/* We're only interested in a symbol named sym_hist_filter */\n\t\t/*\n\t\t * FIXME: why isn't this done in the symbol_filter when loading\n\t\t * the DSO?\n\t\t */\n\t\tif (al->sym != NULL) {\n\t\t\trb_erase(&al->sym->rb_node,\n\t\t\t\t &al->map->dso->symbols[al->map->type]);\n\t\t\tsymbol__delete(al->sym);\n\t\t\tdso__reset_find_symbol_cache(al->map->dso);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * XXX filtered samples can still have branch entires pointing into our\n\t * symbol and are missed.\n\t */\n\tprocess_branch_stack(sample->branch_stack, al, sample);\n\n\tsample->period = 1;\n\tsample->weight = 1;\n\n\the = hists__add_entry(hists, al, NULL, NULL, NULL, sample, true);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\n\thists__inc_nr_samples(hists, true);\n\treturn ret;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct perf_evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_annotate *ann = container_of(tool, struct perf_annotate, tool);\n\tstruct addr_location al;\n\tint ret = 0;\n\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_warning(\"problem processing %d event, skipping it.\\n\",\n\t\t\t   event->header.type);\n\t\treturn -1;\n\t}\n\n\tif (ann->cpu_list && !test_bit(sample->cpu, ann->cpu_bitmap))\n\t\tgoto out_put;\n\n\tif (!al.filtered && perf_evsel__add_sample(evsel, sample, &al, ann)) {\n\t\tpr_warning(\"problem incrementing symbol count, \"\n\t\t\t   \"skipping event\\n\");\n\t\tret = -1;\n\t}\nout_put:\n\taddr_location__put(&al);\n\treturn ret;\n}\n\nstatic int hist_entry__tty_annotate(struct hist_entry *he,\n\t\t\t\t    struct perf_evsel *evsel,\n\t\t\t\t    struct perf_annotate *ann)\n{\n\treturn symbol__tty_annotate(he->ms.sym, he->ms.map, evsel,\n\t\t\t\t    ann->print_line, ann->full_paths, 0, 0);\n}\n\nstatic void hists__find_annotations(struct hists *hists,\n\t\t\t\t    struct perf_evsel *evsel,\n\t\t\t\t    struct perf_annotate *ann)\n{\n\tstruct rb_node *nd = rb_first(&hists->entries), *next;\n\tint key = K_RIGHT;\n\n\twhile (nd) {\n\t\tstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\n\t\tstruct annotation *notes;\n\n\t\tif (he->ms.sym == NULL || he->ms.map->dso->annotate_warned)\n\t\t\tgoto find_next;\n\n\t\tnotes = symbol__annotation(he->ms.sym);\n\t\tif (notes->src == NULL) {\nfind_next:\n\t\t\tif (key == K_LEFT)\n\t\t\t\tnd = rb_prev(nd);\n\t\t\telse\n\t\t\t\tnd = rb_next(nd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (use_browser == 2) {\n\t\t\tint ret;\n\t\t\tint (*annotate)(struct hist_entry *he,\n\t\t\t\t\tstruct perf_evsel *evsel,\n\t\t\t\t\tstruct hist_browser_timer *hbt);\n\n\t\t\tannotate = dlsym(perf_gtk_handle,\n\t\t\t\t\t \"hist_entry__gtk_annotate\");\n\t\t\tif (annotate == NULL) {\n\t\t\t\tui__error(\"GTK browser not found!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tret = annotate(he, evsel, NULL);\n\t\t\tif (!ret || !ann->skip_missing)\n\t\t\t\treturn;\n\n\t\t\t/* skip missing symbols */\n\t\t\tnd = rb_next(nd);\n\t\t} else if (use_browser == 1) {\n\t\t\tkey = hist_entry__tui_annotate(he, evsel, NULL);\n\t\t\tswitch (key) {\n\t\t\tcase -1:\n\t\t\t\tif (!ann->skip_missing)\n\t\t\t\t\treturn;\n\t\t\t\t/* fall through */\n\t\t\tcase K_RIGHT:\n\t\t\t\tnext = rb_next(nd);\n\t\t\t\tbreak;\n\t\t\tcase K_LEFT:\n\t\t\t\tnext = rb_prev(nd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next != NULL)\n\t\t\t\tnd = next;\n\t\t} else {\n\t\t\thist_entry__tty_annotate(he, evsel, ann);\n\t\t\tnd = rb_next(nd);\n\t\t\t/*\n\t\t\t * Since we have a hist_entry per IP for the same\n\t\t\t * symbol, free he->ms.sym->src to signal we already\n\t\t\t * processed this symbol.\n\t\t\t */\n\t\t\tzfree(&notes->src->cycles_hist);\n\t\t\tzfree(&notes->src);\n\t\t}\n\t}\n}\n\nstatic int __cmd_annotate(struct perf_annotate *ann)\n{\n\tint ret;\n\tstruct perf_session *session = ann->session;\n\tstruct perf_evsel *pos;\n\tu64 total_nr_samples;\n\n\tif (ann->cpu_list) {\n\t\tret = perf_session__cpu_bitmap(session, ann->cpu_list,\n\t\t\t\t\t       ann->cpu_bitmap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!objdump_path) {\n\t\tret = perf_env__lookup_objdump(&session->header.env);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = perf_session__process_events(session);\n\tif (ret)\n\t\tgoto out;\n\n\tif (dump_trace) {\n\t\tperf_session__fprintf_nr_events(session, stdout);\n\t\tperf_evlist__fprintf_nr_events(session->evlist, stdout);\n\t\tgoto out;\n\t}\n\n\tif (verbose > 3)\n\t\tperf_session__fprintf(session, stdout);\n\n\tif (verbose > 2)\n\t\tperf_session__fprintf_dsos(session, stdout);\n\n\ttotal_nr_samples = 0;\n\tevlist__for_each_entry(session->evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\tu32 nr_samples = hists->stats.nr_events[PERF_RECORD_SAMPLE];\n\n\t\tif (nr_samples > 0) {\n\t\t\ttotal_nr_samples += nr_samples;\n\t\t\thists__collapse_resort(hists, NULL);\n\t\t\t/* Don't sort callchain */\n\t\t\tperf_evsel__reset_sample_bit(pos, CALLCHAIN);\n\t\t\tperf_evsel__output_resort(pos, NULL);\n\n\t\t\tif (symbol_conf.event_group &&\n\t\t\t    !perf_evsel__is_group_leader(pos))\n\t\t\t\tcontinue;\n\n\t\t\thists__find_annotations(hists, pos, ann);\n\t\t}\n\t}\n\n\tif (total_nr_samples == 0) {\n\t\tui__error(\"The %s file has no samples!\\n\", session->file->path);\n\t\tgoto out;\n\t}\n\n\tif (use_browser == 2) {\n\t\tvoid (*show_annotations)(void);\n\n\t\tshow_annotations = dlsym(perf_gtk_handle,\n\t\t\t\t\t \"perf_gtk__show_annotations\");\n\t\tif (show_annotations == NULL) {\n\t\t\tui__error(\"GTK browser not found!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tshow_annotations();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic const char * const annotate_usage[] = {\n\t\"perf annotate [<options>]\",\n\tNULL\n};\n\nint cmd_annotate(int argc, const char **argv, const char *prefix __maybe_unused)\n{\n\tstruct perf_annotate annotate = {\n\t\t.tool = {\n\t\t\t.sample\t= process_sample_event,\n\t\t\t.mmap\t= perf_event__process_mmap,\n\t\t\t.mmap2\t= perf_event__process_mmap2,\n\t\t\t.comm\t= perf_event__process_comm,\n\t\t\t.exit\t= perf_event__process_exit,\n\t\t\t.fork\t= perf_event__process_fork,\n\t\t\t.ordered_events = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t};\n\tstruct perf_data_file file = {\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t};\n\tconst struct option options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t    \"input file name\"),\n\tOPT_STRING('d', \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING('s', \"symbol\", &annotate.sym_hist_filter, \"symbol\",\n\t\t    \"symbol to annotate\"),\n\tOPT_BOOLEAN('f', \"force\", &file.force, \"don't complain, do it\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_BOOLEAN(0, \"gtk\", &annotate.use_gtk, \"Use the GTK interface\"),\n\tOPT_BOOLEAN(0, \"tui\", &annotate.use_tui, \"Use the TUI interface\"),\n\tOPT_BOOLEAN(0, \"stdio\", &annotate.use_stdio, \"Use the stdio interface\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_BOOLEAN('m', \"modules\", &symbol_conf.use_modules,\n\t\t    \"load module symbols - WARNING: use only with -k and LIVE kernel\"),\n\tOPT_BOOLEAN('l', \"print-line\", &annotate.print_line,\n\t\t    \"print matching source lines (may be slow)\"),\n\tOPT_BOOLEAN('P', \"full-paths\", &annotate.full_paths,\n\t\t    \"Don't shorten the displayed pathnames\"),\n\tOPT_BOOLEAN(0, \"skip-missing\", &annotate.skip_missing,\n\t\t    \"Skip symbols that cannot be annotated\"),\n\tOPT_STRING('C', \"cpu\", &annotate.cpu_list, \"cpu\", \"list of cpus to profile\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_BOOLEAN(0, \"source\", &symbol_conf.annotate_src,\n\t\t    \"Interleave source code with assembly code (default)\"),\n\tOPT_BOOLEAN(0, \"asm-raw\", &symbol_conf.annotate_asm_raw,\n\t\t    \"Display raw encoding of assembly instructions (default)\"),\n\tOPT_STRING('M', \"disassembler-style\", &disassembler_style, \"disassembler style\",\n\t\t   \"Specify disassembler style (e.g. -M intel for intel syntax)\"),\n\tOPT_STRING(0, \"objdump\", &objdump_path, \"path\",\n\t\t   \"objdump binary to use for disassembly and annotations\"),\n\tOPT_BOOLEAN(0, \"group\", &symbol_conf.event_group,\n\t\t    \"Show event group information together\"),\n\tOPT_BOOLEAN(0, \"show-total-period\", &symbol_conf.show_total_period,\n\t\t    \"Show a column with the sum of periods\"),\n\tOPT_CALLBACK_DEFAULT(0, \"stdio-color\", NULL, \"mode\",\n\t\t\t     \"'always' (default), 'never' or 'auto' only applicable to --stdio mode\",\n\t\t\t     stdio__config_color, \"always\"),\n\tOPT_END()\n\t};\n\tint ret = hists__init();\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\targc = parse_options(argc, argv, options, annotate_usage, 0);\n\tif (argc) {\n\t\t/*\n\t\t * Special case: if there's an argument left then assume that\n\t\t * it's a symbol filter:\n\t\t */\n\t\tif (argc > 1)\n\t\t\tusage_with_options(annotate_usage, options);\n\n\t\tannotate.sym_hist_filter = argv[0];\n\t}\n\n\tfile.path  = input_name;\n\n\tannotate.session = perf_session__new(&file, false, &annotate.tool);\n\tif (annotate.session == NULL)\n\t\treturn -1;\n\n\tret = symbol__annotation_init();\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tsymbol_conf.try_vmlinux_path = true;\n\n\tret = symbol__init(&annotate.session->header.env);\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tif (setup_sorting(NULL) < 0)\n\t\tusage_with_options(annotate_usage, options);\n\n\tif (annotate.use_stdio)\n\t\tuse_browser = 0;\n\telse if (annotate.use_tui)\n\t\tuse_browser = 1;\n\telse if (annotate.use_gtk)\n\t\tuse_browser = 2;\n\n\tsetup_browser(true);\n\n\tret = __cmd_annotate(&annotate);\n\nout_delete:\n\t/*\n\t * Speed up the exit process, for large files this can\n\t * take quite a while.\n\t *\n\t * XXX Enable this when using valgrind or if we ever\n\t * librarize this command.\n\t *\n\t * Also experiment with obstacks to see how much speed\n\t * up we'll get here.\n\t *\n\t * perf_session__delete(session);\n\t */\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/perf/ui/setup.c": "#include <pthread.h>\n#include <dlfcn.h>\n\n#include \"../util/cache.h\"\n#include \"../util/debug.h\"\n#include \"../util/hist.h\"\n\npthread_mutex_t ui__lock = PTHREAD_MUTEX_INITIALIZER;\nvoid *perf_gtk_handle;\n\n#ifdef HAVE_GTK2_SUPPORT\nstatic int setup_gtk_browser(void)\n{\n\tint (*perf_ui_init)(void);\n\n\tif (perf_gtk_handle)\n\t\treturn 0;\n\n\tperf_gtk_handle = dlopen(PERF_GTK_DSO, RTLD_LAZY);\n\tif (perf_gtk_handle == NULL) {\n\t\tchar buf[PATH_MAX];\n\t\tscnprintf(buf, sizeof(buf), \"%s/%s\", LIBDIR, PERF_GTK_DSO);\n\t\tperf_gtk_handle = dlopen(buf, RTLD_LAZY);\n\t}\n\tif (perf_gtk_handle == NULL)\n\t\treturn -1;\n\n\tperf_ui_init = dlsym(perf_gtk_handle, \"perf_gtk__init\");\n\tif (perf_ui_init == NULL)\n\t\tgoto out_close;\n\n\tif (perf_ui_init() == 0)\n\t\treturn 0;\n\nout_close:\n\tdlclose(perf_gtk_handle);\n\treturn -1;\n}\n\nstatic void exit_gtk_browser(bool wait_for_ok)\n{\n\tvoid (*perf_ui_exit)(bool);\n\n\tif (perf_gtk_handle == NULL)\n\t\treturn;\n\n\tperf_ui_exit = dlsym(perf_gtk_handle, \"perf_gtk__exit\");\n\tif (perf_ui_exit == NULL)\n\t\tgoto out_close;\n\n\tperf_ui_exit(wait_for_ok);\n\nout_close:\n\tdlclose(perf_gtk_handle);\n\n\tperf_gtk_handle = NULL;\n}\n#else\nstatic inline int setup_gtk_browser(void) { return -1; }\nstatic inline void exit_gtk_browser(bool wait_for_ok __maybe_unused) {}\n#endif\n\nint stdio__config_color(const struct option *opt __maybe_unused,\n\t\t\tconst char *mode, int unset __maybe_unused)\n{\n\tperf_use_color_default = perf_config_colorbool(\"color.ui\", mode, -1);\n\treturn 0;\n}\n\nvoid setup_browser(bool fallback_to_pager)\n{\n\tif (use_browser < 2 && (!isatty(1) || dump_trace))\n\t\tuse_browser = 0;\n\n\t/* default to TUI */\n\tif (use_browser < 0)\n\t\tuse_browser = 1;\n\n\tswitch (use_browser) {\n\tcase 2:\n\t\tif (setup_gtk_browser() == 0)\n\t\t\tbreak;\n\t\tprintf(\"GTK browser requested but could not find %s\\n\",\n\t\t       PERF_GTK_DSO);\n\t\tsleep(1);\n\t\t/* fall through */\n\tcase 1:\n\t\tuse_browser = 1;\n\t\tif (ui__init() == 0)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tuse_browser = 0;\n\t\tif (fallback_to_pager)\n\t\t\tsetup_pager();\n\t\tbreak;\n\t}\n}\n\nvoid exit_browser(bool wait_for_ok)\n{\n\tswitch (use_browser) {\n\tcase 2:\n\t\texit_gtk_browser(wait_for_ok);\n\t\tbreak;\n\n\tcase 1:\n\t\tui__exit(wait_for_ok);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/crypto/sha256_neon_glue.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/crypto/sha256_glue.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/boot/dts/sun4i-a10-inet97fv2.dts",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/m68k/hp300/hp300map.map",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/s390/kernel/ebcdic.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_7x14.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_pearl_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_8x16.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/kernel/events/callchain.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/staging/rtl8188eu/include/odm.h",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/power/reset/ltc2952-poweroff.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/crypto/vmx/ghashp8-ppc.pl",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/tty/vt/defkeymap.map",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/dvb/intro_files/dvbstb.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/dvb/intro_files/dvbstb.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_625.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_525.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_hsync.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_525.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_hsync.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_625.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/selection-api-003_files/selection.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/crop_files/crop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/crop_files/crop.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/pixfmt-nv12mt_files/nv12mt.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/pixfmt-nv12mt_files/nv12mt_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/subdev-formats_files/bayer.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_tb.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_bt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_tb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_bt.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/pipeline.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-crop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-full.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-scaling-multi-source.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/vidioc-g-selection_files/constraints.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/media_api_files/typical_media_device.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/devicetree/bindings/net/nfc/pn544.txt",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/power/cpupower/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/power/cpupower/po/de.po"
    ],
    "total_files": 50920
}