{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/include/hwloc/plugins.h": "/*\n * Copyright \u00a9 2013-2020 Inria.  All rights reserved.\n * Copyright \u00a9 2016 Cisco Systems, Inc.  All rights reserved.\n * See COPYING in top-level directory.\n */\n\n#ifndef HWLOC_PLUGINS_H\n#define HWLOC_PLUGINS_H\n\n/** \\file\n * \\brief Public interface for building hwloc plugins.\n */\n\nstruct hwloc_backend;\n\n#include \"hwloc.h\"\n\n#ifdef HWLOC_INSIDE_PLUGIN\n/* needed for hwloc_plugin_check_namespace() */\n#ifdef HWLOC_HAVE_LTDL\n#include <ltdl.h>\n#else\n#include <dlfcn.h>\n#endif\n#endif\n\n\n\n/** \\defgroup hwlocality_disc_components Components and Plugins: Discovery components\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Discovery component structure\n *\n * This is the major kind of components, taking care of the discovery.\n * They are registered by generic components, either statically-built or as plugins.\n */\nstruct hwloc_disc_component {\n  /** \\brief Name.\n   * If this component is built as a plugin, this name does not have to match the plugin filename.\n   */\n  const char *name;\n\n  /** \\brief Discovery phases performed by this component.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Component phases to exclude, as an OR'ed set of ::hwloc_disc_phase_t.\n   *\n   * For a GLOBAL component, this usually includes all other phases (\\c ~UL).\n   *\n   * Other components only exclude types that may bring conflicting\n   * topology information. MISC components should likely not be excluded\n   * since they usually bring non-primary additional information.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief Instantiate callback to create a backend from the component.\n   * Parameters data1, data2, data3 are NULL except for components\n   * that have special enabling routines such as hwloc_topology_set_xml(). */\n  struct hwloc_backend * (*instantiate)(struct hwloc_topology *topology, struct hwloc_disc_component *component, unsigned excluded_phases, const void *data1, const void *data2, const void *data3);\n\n  /** \\brief Component priority.\n   * Used to sort topology->components, higher priority first.\n   * Also used to decide between two components with the same name.\n   *\n   * Usual values are\n   * 50 for native OS (or platform) components,\n   * 45 for x86,\n   * 40 for no-OS fallback,\n   * 30 for global components (xml, synthetic),\n   * 20 for pci,\n   * 10 for other misc components (opencl etc.).\n   */\n  unsigned priority;\n\n  /** \\brief Enabled by default.\n   * If unset, if will be disabled unless explicitly requested.\n   */\n  unsigned enabled_by_default;\n\n  /** \\private Used internally to list components by priority on topology->components\n   * (the component structure is usually read-only,\n   *  the core copies it before using this field for queueing)\n   */\n  struct hwloc_disc_component * next;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_disc_backends Components and Plugins: Discovery backends\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Discovery phase */\ntypedef enum hwloc_disc_phase_e {\n  /** \\brief xml or synthetic, platform-specific components such as bgq.\n   * Discovers everything including CPU, memory, I/O and everything else.\n   * A component with a Global phase usually excludes all other phases.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_GLOBAL = (1U<<0),\n\n  /** \\brief CPU discovery.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_CPU = (1U<<1),\n\n  /** \\brief Attach memory to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MEMORY = (1U<<2),\n\n  /** \\brief Attach PCI devices and bridges to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_PCI = (1U<<3),\n\n  /** \\brief I/O discovery that requires PCI devices (OS devices such as OpenCL, CUDA, etc.).\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_IO = (1U<<4),\n\n  /** \\brief Misc objects that gets added below anything else.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MISC = (1U<<5),\n\n  /** \\brief Annotating existing objects, adding distances, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),\n\n  /** \\brief Final tweaks to a ready-to-use topology.\n   * This phase runs once the topology is loaded, before it is returned to the topology.\n   * Hence it may only use the main hwloc API for modifying the topology,\n   * for instance by restricting it, adding info attributes, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_TWEAK = (1U<<7)\n} hwloc_disc_phase_t;\n\n/** \\brief Discovery status flags */\nenum hwloc_disc_status_flag_e {\n  /** \\brief The sets of allowed resources were already retrieved \\hideinitializer */\n  HWLOC_DISC_STATUS_FLAG_GOT_ALLOWED_RESOURCES = (1UL<<1)\n};\n\n/** \\brief Discovery status structure\n *\n * Used by the core and backends to inform about what has been/is being done\n * during the discovery process.\n */\nstruct hwloc_disc_status {\n  /** \\brief The current discovery phase that is performed.\n   * Must match one of the phases in the component phases field.\n   */\n  hwloc_disc_phase_t phase;\n\n  /** \\brief Dynamically excluded phases.\n   * If a component decides during discovery that some phases are no longer needed.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief OR'ed set of hwloc_disc_status_flag_e */\n  unsigned long flags;\n};\n\n/** \\brief Discovery backend structure\n *\n * A backend is the instantiation of a discovery component.\n * When a component gets enabled for a topology,\n * its instantiate() callback creates a backend.\n *\n * hwloc_backend_alloc() initializes all fields to default values\n * that the component may change (except \"component\" and \"next\")\n * before enabling the backend with hwloc_backend_enable().\n *\n * Most backends assume that the topology is_thissystem flag is\n * set because they talk to the underlying operating system.\n * However they may still be used in topologies without the\n * is_thissystem flag for debugging reasons.\n * In practice, they are usually auto-disabled in such cases\n * (excluded by xml or synthetic backends, or by environment\n *  variables when changing the Linux fsroot or the x86 cpuid path).\n */\nstruct hwloc_backend {\n  /** \\private Reserved for the core, set by hwloc_backend_alloc() */\n  struct hwloc_disc_component * component;\n  /** \\private Reserved for the core, set by hwloc_backend_enable() */\n  struct hwloc_topology * topology;\n  /** \\private Reserved for the core. Set to 1 if forced through envvar, 0 otherwise. */\n  int envvar_forced;\n  /** \\private Reserved for the core. Used internally to list backends topology->backends. */\n  struct hwloc_backend * next;\n\n  /** \\brief Discovery phases performed by this component, possibly without some of them if excluded by other components.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Backend flags, currently always 0. */\n  unsigned long flags;\n\n  /** \\brief Backend-specific 'is_thissystem' property.\n   * Set to 0 if the backend disables the thissystem flag for this topology\n   * (e.g. loading from xml or synthetic string,\n   *  or using a different fsroot on Linux, or a x86 CPUID dump).\n   * Set to -1 if the backend doesn't care (default).\n   */\n  int is_thissystem;\n\n  /** \\brief Backend private data, or NULL if none. */\n  void * private_data;\n  /** \\brief Callback for freeing the private_data.\n   * May be NULL.\n   */\n  void (*disable)(struct hwloc_backend *backend);\n\n  /** \\brief Main discovery callback.\n   * returns -1 on error, either because it couldn't add its objects ot the existing topology,\n   * or because of an actual discovery/gathering failure.\n   * May be NULL.\n   */\n  int (*discover)(struct hwloc_backend *backend, struct hwloc_disc_status *status);\n\n  /** \\brief Callback to retrieve the locality of a PCI object.\n   * Called by the PCI core when attaching PCI hierarchy to CPU objects.\n   * May be NULL.\n   */\n  int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);\n};\n\n/** \\brief Allocate a backend structure, set good default values, initialize backend->component and topology, etc.\n * The caller will then modify whatever needed, and call hwloc_backend_enable().\n */\nHWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_topology *topology, struct hwloc_disc_component *component);\n\n/** \\brief Enable a previously allocated and setup backend. */\nHWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_backend *backend);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_generic_components Components and Plugins: Generic components\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Generic component type */\ntypedef enum hwloc_component_type_e {\n  /** \\brief The data field must point to a struct hwloc_disc_component. */\n  HWLOC_COMPONENT_TYPE_DISC,\n\n  /** \\brief The data field must point to a struct hwloc_xml_component. */\n  HWLOC_COMPONENT_TYPE_XML\n} hwloc_component_type_t;\n\n/** \\brief Generic component structure\n *\n * Generic components structure, either statically listed by configure in static-components.h\n * or dynamically loaded as a plugin.\n */\nstruct hwloc_component {\n  /** \\brief Component ABI version, set to ::HWLOC_COMPONENT_ABI */\n  unsigned abi;\n\n  /** \\brief Process-wide component initialization callback.\n   *\n   * This optional callback is called when the component is registered\n   * to the hwloc core (after loading the plugin).\n   *\n   * When the component is built as a plugin, this callback\n   * should call hwloc_check_plugin_namespace()\n   * and return an negative error code on error.\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\return 0 on success, or a negative code on error.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  int (*init)(unsigned long flags);\n\n  /** \\brief Process-wide component termination callback.\n   *\n   * This optional callback is called after unregistering the component\n   * from the hwloc core (before unloading the plugin).\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  void (*finalize)(unsigned long flags);\n\n  /** \\brief Component type */\n  hwloc_component_type_t type;\n\n  /** \\brief Component flags, unused for now */\n  unsigned long flags;\n\n  /** \\brief Component data, pointing to a struct hwloc_disc_component or struct hwloc_xml_component. */\n  void * data;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_core_funcs Components and Plugins: Core functions to be used by components\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Check whether insertion errors are hidden */\nHWLOC_DECLSPEC int hwloc_hide_errors(void);\n\n/** \\brief Add an object to the topology.\n *\n * Insert new object \\p obj in the topology starting under existing object \\p root\n * (if \\c NULL, the topology root object is used).\n *\n * It is sorted along the tree of other objects according to the inclusion of\n * cpusets, to eventually be added as a child of the smallest object including\n * this object.\n *\n * If the cpuset is empty, the type of the object (and maybe some attributes)\n * must be enough to find where to insert the object. This is especially true\n * for NUMA nodes with memory and no CPUs.\n *\n * The given object should not have children.\n *\n * This shall only be called before levels are built.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n *\n * The topology cpuset/nodesets will be enlarged to include the object sets.\n *\n * \\p reason is a unique string identifying where and why this insertion call was performed\n * (it will be displayed in case of internal insertion error).\n *\n * Returns the object on success.\n * Returns NULL and frees obj on error.\n * Returns another object and frees obj if it was merged with an identical pre-existing object.\n */\nHWLOC_DECLSPEC hwloc_obj_t\nhwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root,\n                               hwloc_obj_t obj, const char *reason);\n\n/** \\brief Insert an object somewhere in the topology.\n *\n * It is added as the last child of the given parent.\n * The cpuset is completely ignored, so strange objects such as I/O devices should\n * preferably be inserted with this.\n *\n * When used for \"normal\" children with cpusets (when importing from XML\n * when duplicating a topology), the caller should make sure that:\n * - children are inserted in order,\n * - children cpusets do not intersect.\n *\n * The given object may have normal, I/O or Misc children, as long as they are in order as well.\n * These children must have valid parent and next_sibling pointers.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n */\nHWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);\n\n/** \\brief Allocate and initialize an object of the given type and physical index.\n *\n * If \\p os_index is unknown or irrelevant, use \\c HWLOC_UNKNOWN_INDEX.\n */\nHWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);\n\n/** \\brief Setup object cpusets/nodesets by OR'ing its children.\n *\n * Used when adding an object late in the topology.\n * Will update the new object by OR'ing all its new children sets.\n *\n * Used when PCI backend adds a hostbridge parent, when distances\n * add a new Group, etc.\n */\nHWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);\n\n/** \\brief Request a reconnection of children and levels in the topology.\n *\n * May be used by backends during discovery if they need arrays or lists\n * of object within levels or children to be fully connected.\n *\n * \\p flags is currently unused, must 0.\n */\nHWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);\n\n/** \\brief Make sure that plugins can lookup core symbols.\n *\n * This is a sanity check to avoid lazy-lookup failures when libhwloc\n * is loaded within a plugin, and later tries to load its own plugins.\n * This may fail (and abort the program) if libhwloc symbols are in a\n * private namespace.\n *\n * \\return 0 on success.\n * \\return -1 if the plugin cannot be successfully loaded. The caller\n * plugin init() callback should return a negative error code as well.\n *\n * Plugins should call this function in their init() callback to avoid\n * later crashes if lazy symbol resolution is used by the upper layer that\n * loaded hwloc (e.g. OpenCL implementations using dlopen with RTLD_LAZY).\n *\n * \\note The build system must define HWLOC_INSIDE_PLUGIN if and only if\n * building the caller as a plugin.\n *\n * \\note This function should remain inline so plugins can call it even\n * when they cannot find libhwloc symbols.\n */\nstatic __hwloc_inline int\nhwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)\n{\n#ifdef HWLOC_INSIDE_PLUGIN\n  void *sym;\n#ifdef HWLOC_HAVE_LTDL\n  lt_dlhandle handle = lt_dlopen(NULL);\n#else\n  void *handle = dlopen(NULL, RTLD_NOW|RTLD_LOCAL);\n#endif\n  if (!handle)\n    /* cannot check, assume things will work */\n    return 0;\n#ifdef HWLOC_HAVE_LTDL\n  sym = lt_dlsym(handle, symbol);\n  lt_dlclose(handle);\n#else\n  sym = dlsym(handle, symbol);\n  dlclose(handle);\n#endif\n  if (!sym) {\n    static int verboseenv_checked = 0;\n    static int verboseenv_value = 0;\n    if (!verboseenv_checked) {\n      const char *verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n      verboseenv_value = verboseenv ? atoi(verboseenv) : 0;\n      verboseenv_checked = 1;\n    }\n    if (verboseenv_value)\n      fprintf(stderr, \"Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\\n\",\n\t      pluginname, symbol);\n    return -1;\n  }\n#endif /* HWLOC_INSIDE_PLUGIN */\n  return 0;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_filtering Components and Plugins: Filtering objects\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Check whether the given PCI device classid is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_pcidev_subtype_important(unsigned classid)\n{\n  unsigned baseclass = classid >> 8;\n  return (baseclass == 0x03 /* PCI_BASE_CLASS_DISPLAY */\n\t  || baseclass == 0x02 /* PCI_BASE_CLASS_NETWORK */\n\t  || baseclass == 0x01 /* PCI_BASE_CLASS_STORAGE */\n\t  || baseclass == 0x0b /* PCI_BASE_CLASS_PROCESSOR */\n\t  || classid == 0x0c04 /* PCI_CLASS_SERIAL_FIBER */\n\t  || classid == 0x0c06 /* PCI_CLASS_SERIAL_INFINIBAND */\n\t  || baseclass == 0x12 /* Processing Accelerators */);\n}\n\n/** \\brief Check whether the given OS device subtype is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)\n{\n  return (subtype != HWLOC_OBJ_OSDEV_DMA);\n}\n\n/** \\brief Check whether a non-I/O object type should be filtered-out.\n *\n * Cannot be used for I/O objects.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)\n{\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); /* IMPORTANT only used for I/O */\n  return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;\n}\n\n/** \\brief Check whether the given object should be filtered-out.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n  hwloc_obj_type_t type = obj->type;\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)\n    return 0;\n  if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {\n    if (type == HWLOC_OBJ_PCI_DEVICE)\n      return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);\n    if (type == HWLOC_OBJ_OS_DEVICE)\n      return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);\n  }\n  return 1;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcidisc Components and Plugins: helpers for PCI discovery\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Return the offset of the given capability in the PCI config space buffer\n *\n * This function requires a 256-bytes config space. Unknown/unavailable bytes should be set to 0xff.\n */\nHWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);\n\n/** \\brief Fill linkspeed by reading the PCI config space where PCI_CAP_ID_EXP is at position offset.\n *\n * Needs 20 bytes of EXP capability block starting at offset in the config space\n * for registers up to link status.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);\n\n/** \\brief Return the hwloc object type (PCI device or Bridge) for the given class and configuration space.\n *\n * This function requires 16 bytes of common configuration header at the beginning of config.\n */\nHWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);\n\n/** \\brief Fills the attributes of the given PCI bridge using the given PCI config space.\n *\n * This function requires 32 bytes of common configuration header at the beginning of config.\n *\n * Returns -1 and destroys /p obj if bridge fields are invalid.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,\n\t\t\t\t\t\t   unsigned *secondary_busp, unsigned *subordinate_busp,\n\t\t\t\t\t\t   const unsigned char *config);\n\n/** \\brief Insert a PCI object in the given PCI tree by looking at PCI bus IDs.\n *\n * If \\p treep points to \\c NULL, the new object is inserted there.\n */\nHWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);\n\n/** \\brief Add some hostbridges on top of the given tree of PCI objects and attach them to the topology.\n *\n * Other backends may lookup PCI objects or localities (for instance to attach OS devices)\n * by using hwloc_pcidisc_find_by_busid() or hwloc_pcidisc_find_busid_parent().\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcifind Components and Plugins: finding PCI objects during other discoveries\n *\n * \\note These structures and functions may change when ::HWLOC_COMPONENT_ABI is modified.\n *\n * @{\n */\n\n/** \\brief Find the normal parent of a PCI bus ID.\n *\n * Look at PCI affinity to find out where the given PCI bus ID should be attached.\n *\n * This function should be used to attach an I/O device under the corresponding\n * PCI object (if any), or under a normal (non-I/O) object with same locality.\n */\nHWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);\n\n/** @} */\n\n\n\n\n#endif /* HWLOC_PLUGINS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/hwloc/components.c": "/*\n * Copyright \u00a9 2009-2020 Inria.  All rights reserved.\n * Copyright \u00a9 2012 Universit\u00e9 Bordeaux\n * See COPYING in top-level directory.\n */\n\n#include \"private/autogen/config.h\"\n#include \"hwloc.h\"\n#include \"private/private.h\"\n#include \"private/xml.h\"\n#include \"private/misc.h\"\n\n#define HWLOC_COMPONENT_STOP_NAME \"stop\"\n#define HWLOC_COMPONENT_EXCLUDE_CHAR '-'\n#define HWLOC_COMPONENT_SEPS \",\"\n#define HWLOC_COMPONENT_PHASESEP_CHAR ':'\n\n/* list of all registered discovery components, sorted by priority, higher priority first.\n * noos is last because its priority is 0.\n * others' priority is 10.\n */\nstatic struct hwloc_disc_component * hwloc_disc_components = NULL;\n\nstatic unsigned hwloc_components_users = 0; /* first one initializes, last ones destroys */\n\nstatic int hwloc_components_verbose = 0;\n#ifdef HWLOC_HAVE_PLUGINS\nstatic int hwloc_plugins_verbose = 0;\nstatic const char * hwloc_plugins_blacklist = NULL;\n#endif\n\n/* hwloc_components_mutex serializes:\n * - loading/unloading plugins, and modifications of the hwloc_plugins list\n * - calls to ltdl, including in hwloc_check_plugin_namespace()\n * - registration of components with hwloc_disc_component_register()\n *   and hwloc_xml_callbacks_register()\n */\n#ifdef HWLOC_WIN_SYS\n/* Basic mutex on top of InterlockedCompareExchange() on windows,\n * Far from perfect, but easy to maintain, and way enough given that this code will never be needed for real. */\n#include <windows.h>\nstatic LONG hwloc_components_mutex = 0;\n#define HWLOC_COMPONENTS_LOCK() do {\t\t\t\t\t\t\\\n  while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)\t\\\n    SwitchToThread();\t\t\t\t\t\t\t\t\\\n} while (0)\n#define HWLOC_COMPONENTS_UNLOCK() do {\t\t\t\t\t\t\\\n  assert(hwloc_components_mutex == 1);\t\t\t\t\t\t\\\n  hwloc_components_mutex = 0;\t\t\t\t\t\t\t\\\n} while (0)\n\n#elif defined HWLOC_HAVE_PTHREAD_MUTEX\n/* pthread mutex if available (except on windows) */\n#include <pthread.h>\nstatic pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;\n#define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)\n#define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)\n\n#else /* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */\n#error No mutex implementation available\n#endif\n\n\n#ifdef HWLOC_HAVE_PLUGINS\n\n#ifdef HWLOC_HAVE_LTDL\n/* ltdl-based plugin load */\n#include <ltdl.h>\ntypedef lt_dlhandle hwloc_dlhandle;\n#define hwloc_dlinit lt_dlinit\n#define hwloc_dlexit lt_dlexit\n#define hwloc_dlopenext lt_dlopenext\n#define hwloc_dlclose lt_dlclose\n#define hwloc_dlerror lt_dlerror\n#define hwloc_dlsym lt_dlsym\n#define hwloc_dlforeachfile lt_dlforeachfile\n\n#else /* !HWLOC_HAVE_LTDL */\n/* no-ltdl plugin load relies on less portable libdl */\n#include <dlfcn.h>\ntypedef void * hwloc_dlhandle;\nstatic __hwloc_inline int hwloc_dlinit(void) { return 0; }\nstatic __hwloc_inline int hwloc_dlexit(void) { return 0; }\n#define hwloc_dlclose dlclose\n#define hwloc_dlerror dlerror\n#define hwloc_dlsym dlsym\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n\nstatic hwloc_dlhandle hwloc_dlopenext(const char *_filename)\n{\n  hwloc_dlhandle handle;\n  char *filename = NULL;\n  (void) asprintf(&filename, \"%s.so\", _filename);\n  if (!filename)\n    return NULL;\n  handle = dlopen(filename, RTLD_NOW|RTLD_LOCAL);\n  free(filename);\n  return handle;\n}\n\nstatic int\nhwloc_dlforeachfile(const char *_paths,\n\t\t    int (*func)(const char *filename, void *data),\n\t\t    void *data)\n{\n  char *paths = NULL, *path;\n\n  paths = strdup(_paths);\n  if (!paths)\n    return -1;\n\n  path = paths;\n  while (*path) {\n    char *colon;\n    DIR *dir;\n    struct dirent *dirent;\n\n    colon = strchr(path, ':');\n    if (colon)\n      *colon = '\\0';\n\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \" Looking under %s\\n\", path);\n\n    dir = opendir(path);\n    if (!dir)\n      goto next;\n\n    while ((dirent = readdir(dir)) != NULL) {\n      char *abs_name, *suffix;\n      struct stat stbuf;\n      int err;\n\n      err = asprintf(&abs_name, \"%s/%s\", path, dirent->d_name);\n      if (err < 0)\n\tcontinue;\n\n      err = stat(abs_name, &stbuf);\n      if (err < 0) {\n\tfree(abs_name);\n        continue;\n      }\n      if (!S_ISREG(stbuf.st_mode)) {\n\tfree(abs_name);\n\tcontinue;\n      }\n\n      /* Only keep .so files, and remove that suffix to get the component basename */\n      suffix = strrchr(abs_name, '.');\n      if (!suffix || strcmp(suffix, \".so\")) {\n\tfree(abs_name);\n\tcontinue;\n      }\n      *suffix = '\\0';\n\n      err = func(abs_name, data);\n      if (err) {\n\tfree(abs_name);\n\tcontinue;\n      }\n\n      free(abs_name);\n    }\n\n    closedir(dir);\n\n  next:\n    if (!colon)\n      break;\n    path = colon+1;\n  }\n\n  free(paths);\n  return 0;\n}\n#endif /* !HWLOC_HAVE_LTDL */\n\n/* array of pointers to dynamically loaded plugins */\nstatic struct hwloc__plugin_desc {\n  char *name;\n  struct hwloc_component *component;\n  char *filename;\n  hwloc_dlhandle handle;\n  struct hwloc__plugin_desc *next;\n} *hwloc_plugins = NULL;\n\nstatic int\nhwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)\n{\n  const char *basename;\n  hwloc_dlhandle handle;\n  struct hwloc_component *component;\n  struct hwloc__plugin_desc *desc, **prevdesc;\n  char *componentsymbolname;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin dlforeach found `%s'\\n\", filename);\n\n  basename = strrchr(filename, '/');\n  if (!basename)\n    basename = filename;\n  else\n    basename++;\n\n  if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin `%s' is blacklisted in the environment\\n\", basename);\n    goto out;\n  }\n\n  /* dlopen and get the component structure */\n  handle = hwloc_dlopenext(filename);\n  if (!handle) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to load plugin: %s\\n\", hwloc_dlerror());\n    goto out;\n  }\n\n  componentsymbolname = malloc(strlen(basename)+10+1);\n  if (!componentsymbolname) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to allocation component `%s' symbol\\n\",\n\t      basename);\n    goto out_with_handle;\n  }\n  sprintf(componentsymbolname, \"%s_component\", basename);\n  component = hwloc_dlsym(handle, componentsymbolname);\n  if (!component) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to find component symbol `%s'\\n\",\n\t      componentsymbolname);\n    free(componentsymbolname);\n    goto out_with_handle;\n  }\n  if (component->abi != HWLOC_COMPONENT_ABI) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin symbol ABI %u instead of %d\\n\",\n\t      component->abi, HWLOC_COMPONENT_ABI);\n    free(componentsymbolname);\n    goto out_with_handle;\n  }\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin contains expected symbol `%s'\\n\",\n\t    componentsymbolname);\n  free(componentsymbolname);\n\n  if (HWLOC_COMPONENT_TYPE_DISC == component->type) {\n    if (strncmp(basename, \"hwloc_\", 6)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type DISCOVERY\\n\", basename);\n      goto out_with_handle;\n    }\n  } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {\n    if (strncmp(basename, \"hwloc_xml_\", 10)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type XML\\n\", basename);\n      goto out_with_handle;\n    }\n  } else {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin name `%s' has invalid type %u\\n\",\n\t      basename, (unsigned) component->type);\n    goto out_with_handle;\n  }\n\n  /* allocate a plugin_desc and queue it */\n  desc = malloc(sizeof(*desc));\n  if (!desc)\n    goto out_with_handle;\n  desc->name = strdup(basename);\n  desc->filename = strdup(filename);\n  desc->component = component;\n  desc->handle = handle;\n  desc->next = NULL;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' ready\\n\", basename);\n\n  /* append to the list */\n  prevdesc = &hwloc_plugins;\n  while (*prevdesc)\n    prevdesc = &((*prevdesc)->next);\n  *prevdesc = desc;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' queued\\n\", basename);\n  return 0;\n\n out_with_handle:\n  hwloc_dlclose(handle);\n out:\n  return 0;\n}\n\nstatic void\nhwloc_plugins_exit(void)\n{\n  struct hwloc__plugin_desc *desc, *next;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Closing all plugins\\n\");\n\n  desc = hwloc_plugins;\n  while (desc) {\n    next = desc->next;\n    hwloc_dlclose(desc->handle);\n    free(desc->name);\n    free(desc->filename);\n    free(desc);\n    desc = next;\n  }\n  hwloc_plugins = NULL;\n\n  hwloc_dlexit();\n}\n\nstatic int\nhwloc_plugins_init(void)\n{\n  const char *verboseenv;\n  const char *path = HWLOC_PLUGINS_PATH;\n  const char *env;\n  int err;\n\n  verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n  hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n  hwloc_plugins_blacklist = getenv(\"HWLOC_PLUGINS_BLACKLIST\");\n\n  err = hwloc_dlinit();\n  if (err)\n    goto out;\n\n  env = getenv(\"HWLOC_PLUGINS_PATH\");\n  if (env)\n    path = env;\n\n  hwloc_plugins = NULL;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Starting plugin dlforeach in %s\\n\", path);\n  err = hwloc_dlforeachfile(path, hwloc__dlforeach_cb, NULL);\n  if (err)\n    goto out_with_init;\n\n  return 0;\n\n out_with_init:\n  hwloc_plugins_exit();\n out:\n  return -1;\n}\n\n#endif /* HWLOC_HAVE_PLUGINS */\n\nstatic int\nhwloc_disc_component_register(struct hwloc_disc_component *component,\n\t\t\t      const char *filename)\n{\n  struct hwloc_disc_component **prev;\n\n  /* check that the component name is valid */\n  if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with reserved name `\" HWLOC_COMPONENT_STOP_NAME \"'\\n\");\n    return -1;\n  }\n  if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)\n      || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)\n      || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with name `%s' containing reserved characters `%c\" HWLOC_COMPONENT_SEPS \"'\\n\",\n\t      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);\n    return -1;\n  }\n\n  /* check that the component phases are valid */\n  if (!component->phases\n      || (component->phases != HWLOC_DISC_PHASE_GLOBAL\n\t  && component->phases & ~(HWLOC_DISC_PHASE_CPU\n\t\t\t\t   |HWLOC_DISC_PHASE_MEMORY\n\t\t\t\t   |HWLOC_DISC_PHASE_PCI\n\t\t\t\t   |HWLOC_DISC_PHASE_IO\n\t\t\t\t   |HWLOC_DISC_PHASE_MISC\n\t\t\t\t   |HWLOC_DISC_PHASE_ANNOTATE\n\t\t\t\t   |HWLOC_DISC_PHASE_TWEAK))) {\n    fprintf(stderr, \"Cannot register discovery component `%s' with invalid phases 0x%x\\n\",\n\t    component->name, component->phases);\n    return -1;\n  }\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if (!strcmp((*prev)->name, component->name)) {\n      /* if two components have the same name, only keep the highest priority one */\n      if ((*prev)->priority < component->priority) {\n\t/* drop the existing component */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Dropping previously registered discovery component `%s', priority %u lower than new one %u\\n\",\n\t\t  (*prev)->name, (*prev)->priority, component->priority);\n\t*prev = (*prev)->next;\n      } else {\n\t/* drop the new one */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Ignoring new discovery component `%s', priority %u lower than previously registered one %u\\n\",\n\t\t  component->name, component->priority, (*prev)->priority);\n\treturn -1;\n      }\n    }\n    prev = &((*prev)->next);\n  }\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\\n\",\n\t    component->name, component->phases, component->priority,\n\t    filename ? \"from plugin \" : \"statically build\", filename ? filename : \"\");\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if ((*prev)->priority < component->priority)\n      break;\n    prev = &((*prev)->next);\n  }\n  component->next = *prev;\n  *prev = component;\n  return 0;\n}\n\n#include \"static-components.h\"\n\nstatic void (**hwloc_component_finalize_cbs)(unsigned long);\nstatic unsigned hwloc_component_finalize_cb_count;\n\nvoid\nhwloc_components_init(void)\n{\n#ifdef HWLOC_HAVE_PLUGINS\n  struct hwloc__plugin_desc *desc;\n#endif\n  const char *verboseenv;\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert((unsigned) -1 != hwloc_components_users);\n  if (0 != hwloc_components_users++) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  verboseenv = getenv(\"HWLOC_COMPONENTS_VERBOSE\");\n  hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_init();\n#endif\n\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n  /* count the max number of finalize callbacks */\n  for(i=0; NULL != hwloc_static_components[i]; i++)\n    hwloc_component_finalize_cb_count++;\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next)\n    hwloc_component_finalize_cb_count++;\n#endif\n  if (hwloc_component_finalize_cb_count) {\n    hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,\n\t\t\t\t\t  sizeof(*hwloc_component_finalize_cbs));\n    assert(hwloc_component_finalize_cbs);\n    /* forget that max number and recompute the real one below */\n    hwloc_component_finalize_cb_count = 0;\n  }\n\n  /* hwloc_static_components is created by configure in static-components.h */\n  for(i=0; NULL != hwloc_static_components[i]; i++) {\n    if (hwloc_static_components[i]->flags) {\n      fprintf(stderr, \"Ignoring static component with invalid flags %lx\\n\",\n\t      hwloc_static_components[i]->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring static component, failed to initialize\\n\");\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (hwloc_static_components[i]->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)\n      hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);\n    else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)\n      hwloc_xml_callbacks_register(hwloc_static_components[i]->data);\n    else\n      assert(0);\n  }\n\n  /* dynamic plugins */\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {\n    if (desc->component->flags) {\n      fprintf(stderr, \"Ignoring plugin `%s' component with invalid flags %lx\\n\",\n\t      desc->name, desc->component->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (desc->component->init && desc->component->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring plugin `%s', failed to initialize\\n\", desc->name);\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (desc->component->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)\n      hwloc_disc_component_register(desc->component->data, desc->filename);\n    else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)\n      hwloc_xml_callbacks_register(desc->component->data);\n    else\n      assert(0);\n  }\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nvoid\nhwloc_topology_components_init(struct hwloc_topology *topology)\n{\n  topology->nr_blacklisted_components = 0;\n  topology->blacklisted_components = NULL;\n\n  topology->backends = NULL;\n  topology->backend_phases = 0;\n  topology->backend_excluded_phases = 0;\n}\n\n/* look for name among components, ignoring things after `:' */\nstatic struct hwloc_disc_component *\nhwloc_disc_component_find(const char *name, const char **endp)\n{\n  struct hwloc_disc_component *comp;\n  size_t length;\n  const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);\n  if (end) {\n    length = end-name;\n    if (endp)\n      *endp = end+1;\n  } else {\n    length = strlen(name);\n    if (endp)\n      *endp = NULL;\n  }\n\n  comp = hwloc_disc_components;\n  while (NULL != comp) {\n    if (!strncmp(name, comp->name, length))\n      return comp;\n    comp = comp->next;\n  }\n  return NULL;\n}\n\nstatic unsigned\nhwloc_phases_from_string(const char *s)\n{\n  if (!s)\n    return ~0U;\n  if (s[0]<'0' || s[0]>'9') {\n    if (!strcasecmp(s, \"global\"))\n      return HWLOC_DISC_PHASE_GLOBAL;\n    else if (!strcasecmp(s, \"cpu\"))\n      return HWLOC_DISC_PHASE_CPU;\n    if (!strcasecmp(s, \"memory\"))\n      return HWLOC_DISC_PHASE_MEMORY;\n    if (!strcasecmp(s, \"pci\"))\n      return HWLOC_DISC_PHASE_PCI;\n    if (!strcasecmp(s, \"io\"))\n      return HWLOC_DISC_PHASE_IO;\n    if (!strcasecmp(s, \"misc\"))\n      return HWLOC_DISC_PHASE_MISC;\n    if (!strcasecmp(s, \"annotate\"))\n      return HWLOC_DISC_PHASE_ANNOTATE;\n    if (!strcasecmp(s, \"tweak\"))\n      return HWLOC_DISC_PHASE_TWEAK;\n    return 0;\n  }\n  return (unsigned) strtoul(s, NULL, 0);\n}\n\nstatic int\nhwloc_disc_component_blacklist_one(struct hwloc_topology *topology,\n\t\t\t\t   const char *name)\n{\n  struct hwloc_topology_forced_component_s *blacklisted;\n  struct hwloc_disc_component *comp;\n  unsigned phases;\n  unsigned i;\n\n  if (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n    /* replace linuxpci and linuxio with linux (with IO phases)\n     * for backward compatibility with pre-v2.0 and v2.0 respectively */\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Replacing deprecated component `%s' with `linux' IO phases in blacklisting\\n\", name);\n    comp = hwloc_disc_component_find(\"linux\", NULL);\n    phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;\n\n  } else {\n    /* normal lookup */\n    const char *end;\n    comp = hwloc_disc_component_find(name, &end);\n    phases = hwloc_phases_from_string(end);\n  }\n  if (!comp) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Blacklisting component `%s` phases 0x%x\\n\", comp->name, phases);\n\n  for(i=0; i<topology->nr_blacklisted_components; i++) {\n    if (topology->blacklisted_components[i].component == comp) {\n      topology->blacklisted_components[i].phases |= phases;\n      return 0;\n    }\n  }\n\n  blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));\n  if (!blacklisted)\n    return -1;\n\n  blacklisted[topology->nr_blacklisted_components].component = comp;\n  blacklisted[topology->nr_blacklisted_components].phases = phases;\n  topology->blacklisted_components = blacklisted;\n  topology->nr_blacklisted_components++;\n  return 0;\n}\n\nint\nhwloc_topology_set_components(struct hwloc_topology *topology,\n\t\t\t      unsigned long flags,\n\t\t\t      const char *name)\n{\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* this flag is strictly required for now */\n  if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (!strncmp(name, \"all\", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {\n    topology->backend_excluded_phases = hwloc_phases_from_string(name+4);\n    return 0;\n  }\n\n  return hwloc_disc_component_blacklist_one(topology, name);\n}\n\n/* used by set_xml(), set_synthetic(), ... environment variables, ... to force the first backend */\nint\nhwloc_disc_component_force_enable(struct hwloc_topology *topology,\n\t\t\t\t  int envvar_forced,\n\t\t\t\t  const char *name,\n\t\t\t\t  const void *data1, const void *data2, const void *data3)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  comp = hwloc_disc_component_find(name, NULL);\n  if (!comp) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, 0U /* force-enabled don't get any phase blacklisting */,\n\t\t\t      data1, data2, data3);\n  if (backend) {\n    int err;\n    backend->envvar_forced = envvar_forced;\n    if (topology->backends)\n      hwloc_backends_disable_all(topology);\n    err = hwloc_backend_enable(backend);\n\n    if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {\n      char *env = getenv(\"HWLOC_ANNOTATE_GLOBAL_COMPONENTS\");\n      if (env && atoi(env))\n\ttopology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;\n    }\n\n    return err;\n  } else\n    return -1;\n}\n\nstatic int\nhwloc_disc_component_try_enable(struct hwloc_topology *topology,\n\t\t\t\tstruct hwloc_disc_component *comp,\n\t\t\t\tint envvar_forced,\n\t\t\t\tunsigned blacklisted_phases)\n{\n  struct hwloc_backend *backend;\n\n  if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {\n    /* all this backend phases are already excluded, exclude the backend entirely */\n    if (hwloc_components_verbose)\n      /* do not warn if envvar_forced since system-wide HWLOC_COMPONENTS must be silently ignored after set_xml() etc.\n       */\n      fprintf(stderr, \"Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\\n\",\n\t      comp->name, comp->phases, topology->backend_excluded_phases);\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,\n\t\t\t      NULL, NULL, NULL);\n  if (!backend) {\n    if (hwloc_components_verbose || envvar_forced)\n      fprintf(stderr, \"Failed to instantiate discovery component `%s'\\n\", comp->name);\n    return -1;\n  }\n\n  backend->phases &= ~blacklisted_phases;\n  backend->envvar_forced = envvar_forced;\n  return hwloc_backend_enable(backend);\n}\n\nvoid\nhwloc_disc_components_enable_others(struct hwloc_topology *topology)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n  int tryall = 1;\n  const char *_env;\n  char *env; /* we'll to modify the env value, so duplicate it */\n  unsigned i;\n\n  _env = getenv(\"HWLOC_COMPONENTS\");\n  env = _env ? strdup(_env) : NULL;\n\n  /* blacklist disabled components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c;\n\n\tif (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)\n\t  goto nextname;\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\t/* blacklist it, and just ignore failures to allocate */\n\thwloc_disc_component_blacklist_one(topology, curenv+1);\n\n\t/* remove that blacklisted name from the string */\n\tfor(i=0; i<s; i++)\n\t  curenv[i] = *HWLOC_COMPONENT_SEPS;\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n    nextname:\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* enable explicitly listed components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c;\n\tconst char *name;\n\n\tif (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {\n\t  tryall = 0;\n\t  break;\n\t}\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\tname = curenv;\n\tif (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n\t  if (hwloc_components_verbose)\n\t    fprintf(stderr, \"Replacing deprecated component `%s' with `linux' in envvar forcing\\n\", name);\n\t  name = \"linux\";\n\t}\n\n\tcomp = hwloc_disc_component_find(name, NULL /* we enable the entire component, phases must be blacklisted separately */);\n\tif (comp) {\n\t  unsigned blacklisted_phases = 0U;\n\t  for(i=0; i<topology->nr_blacklisted_components; i++)\n\t    if (comp == topology->blacklisted_components[i].component) {\n\t      blacklisted_phases = topology->blacklisted_components[i].phases;\n\t      break;\n\t    }\n\t  if (comp->phases & ~blacklisted_phases)\n\t    hwloc_disc_component_try_enable(topology, comp, 1 /* envvar forced */, blacklisted_phases);\n\t} else {\n\t  fprintf(stderr, \"Cannot find discovery component `%s'\\n\", name);\n\t}\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* env is still the same, the above loop didn't modify it */\n\n  /* now enable remaining components (except the explicitly '-'-listed ones) */\n  if (tryall) {\n    comp = hwloc_disc_components;\n    while (NULL != comp) {\n      unsigned blacklisted_phases = 0U;\n      if (!comp->enabled_by_default)\n\tgoto nextcomp;\n      /* check if this component was blacklisted by the application */\n      for(i=0; i<topology->nr_blacklisted_components; i++)\n\tif (comp == topology->blacklisted_components[i].component) {\n\t  blacklisted_phases = topology->blacklisted_components[i].phases;\n\t  break;\n\t}\n\n      if (!(comp->phases & ~blacklisted_phases)) {\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Excluding blacklisted discovery component `%s' phases 0x%x\\n\",\n\t\t  comp->name, comp->phases);\n\tgoto nextcomp;\n      }\n\n      hwloc_disc_component_try_enable(topology, comp, 0 /* defaults, not envvar forced */, blacklisted_phases);\nnextcomp:\n      comp = comp->next;\n    }\n  }\n\n  if (hwloc_components_verbose) {\n    /* print a summary */\n    int first = 1;\n    backend = topology->backends;\n    fprintf(stderr, \"Final list of enabled discovery components: \");\n    while (backend != NULL) {\n      fprintf(stderr, \"%s%s(0x%x)\", first ? \"\" : \",\", backend->component->name, backend->phases);\n      backend = backend->next;\n      first = 0;\n    }\n    fprintf(stderr, \"\\n\");\n  }\n\n  free(env);\n}\n\nvoid\nhwloc_components_fini(void)\n{\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert(0 != hwloc_components_users);\n  if (0 != --hwloc_components_users) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  for(i=0; i<hwloc_component_finalize_cb_count; i++)\n    hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);\n  free(hwloc_component_finalize_cbs);\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n\n  /* no need to unlink/free the list of components, they'll be unloaded below */\n\n  hwloc_disc_components = NULL;\n  hwloc_xml_callbacks_reset();\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_exit();\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nstruct hwloc_backend *\nhwloc_backend_alloc(struct hwloc_topology *topology,\n\t\t    struct hwloc_disc_component *component)\n{\n  struct hwloc_backend * backend = malloc(sizeof(*backend));\n  if (!backend) {\n    errno = ENOMEM;\n    return NULL;\n  }\n  backend->component = component;\n  backend->topology = topology;\n  /* filter-out component phases that are excluded */\n  backend->phases = component->phases & ~topology->backend_excluded_phases;\n  if (backend->phases != component->phases && hwloc_components_verbose)\n    fprintf(stderr, \"Trying discovery component `%s' with phases 0x%x instead of 0x%x\\n\",\n\t    component->name, backend->phases, component->phases);\n  backend->flags = 0;\n  backend->discover = NULL;\n  backend->get_pci_busid_cpuset = NULL;\n  backend->disable = NULL;\n  backend->is_thissystem = -1;\n  backend->next = NULL;\n  backend->envvar_forced = 0;\n  return backend;\n}\n\nstatic void\nhwloc_backend_disable(struct hwloc_backend *backend)\n{\n  if (backend->disable)\n    backend->disable(backend);\n  free(backend);\n}\n\nint\nhwloc_backend_enable(struct hwloc_backend *backend)\n{\n  struct hwloc_topology *topology = backend->topology;\n  struct hwloc_backend **pprev;\n\n  /* check backend flags */\n  if (backend->flags) {\n    fprintf(stderr, \"Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\\n\",\n\t    backend->component->name, backend->component->phases, backend->flags);\n    return -1;\n  }\n\n  /* make sure we didn't already enable this backend, we don't want duplicates */\n  pprev = &topology->backends;\n  while (NULL != *pprev) {\n    if ((*pprev)->component == backend->component) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Cannot enable  discovery component `%s' phases 0x%x twice\\n\",\n\t\tbackend->component->name, backend->component->phases);\n      hwloc_backend_disable(backend);\n      errno = EBUSY;\n      return -1;\n    }\n    pprev = &((*pprev)->next);\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Enabling discovery component `%s' with phases 0x%x (among 0x%x)\\n\",\n\t    backend->component->name, backend->phases, backend->component->phases);\n\n  /* enqueue at the end */\n  pprev = &topology->backends;\n  while (NULL != *pprev)\n    pprev = &((*pprev)->next);\n  backend->next = *pprev;\n  *pprev = backend;\n\n  topology->backend_phases |= backend->component->phases;\n  topology->backend_excluded_phases |= backend->component->excluded_phases;\n  return 0;\n}\n\nvoid\nhwloc_backends_is_thissystem(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n  const char *local_env;\n\n  /*\n   * If the application changed the backend with set_foo(),\n   * it may use set_flags() update the is_thissystem flag here.\n   * If it changes the backend with environment variables below,\n   * it may use HWLOC_THISSYSTEM envvar below as well.\n   */\n\n  topology->is_thissystem = 1;\n\n  /* apply thissystem from normally-given backends (envvar_forced=0, either set_foo() or defaults) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override set_foo() with flags */\n  if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)\n    topology->is_thissystem = 1;\n\n  /* now apply envvar-forced backend (envvar_forced=1) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override with envvar-given flag */\n  local_env = getenv(\"HWLOC_THISSYSTEM\");\n  if (local_env)\n    topology->is_thissystem = atoi(local_env);\n}\n\nvoid\nhwloc_backends_find_callbacks(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend = topology->backends;\n  /* use the first backend's get_pci_busid_cpuset callback */\n  topology->get_pci_busid_cpuset_backend = NULL;\n  while (backend != NULL) {\n    if (backend->get_pci_busid_cpuset) {\n      topology->get_pci_busid_cpuset_backend = backend;\n      return;\n    }\n    backend = backend->next;\n  }\n  return;\n}\n\nvoid\nhwloc_backends_disable_all(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n\n  while (NULL != (backend = topology->backends)) {\n    struct hwloc_backend *next = backend->next;\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Disabling discovery component `%s'\\n\",\n\t      backend->component->name);\n    hwloc_backend_disable(backend);\n    topology->backends = next;\n  }\n  topology->backends = NULL;\n  topology->backend_excluded_phases = 0;\n}\n\nvoid\nhwloc_topology_components_fini(struct hwloc_topology *topology)\n{\n  /* hwloc_backends_disable_all() must have been called earlier */\n  assert(!topology->backends);\n\n  free(topology->blacklisted_components);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/.git/objects/pack/pack-674d4778bae3ec69a46ea50041d62060a4eed6fa.idx",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/.git/objects/pack/pack-674d4778bae3ec69a46ea50041d62060a4eed6fa.pack",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/utils/hwloc/test-hwloc-compress-dir.input.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/utils/hwloc/test-hwloc-compress-dir.output.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/utils/hwloc/test-hwloc-dump-hwdata/knl-snc4h50.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/netloc/data/plafrim2.txz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/netloc/data/avakas.txz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/netloc/data/plafrim.txz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/netloc/data/scotch.txz",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/1alpha.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8ia64-2n2s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/fakememinitiators-1np2c+1npp+gi.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/4ia64-4s.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16em64t-4s2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8amd64-4n2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/256ppc-8n8s4t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8em64t-2s2ca2c-buggynuma.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/96em64t-4n4d3ca2co.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2pa-pcidomain32bits.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2arm-2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/32em64t-2n8c+1mic.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16ia64-8n2s.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/20s390-2g6s4c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/48amd64-4d2n6c-sparse.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8em64t-2s2ca2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2i386-2c-nohugepage.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/4em64t-2c2t-ignore-reorder.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16em64t-4s2c2t-offlines.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2ps3-2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/40intel64-2g2n4c+pci.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/64intel64-fakeKNL-A2A-cache.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8ia64-2s2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/fakecpuid1f-64intel64-2p4d2n2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8em64t-4c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/40intel64-4n10c+pci-conflicts.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16amd64-8n2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/256ia64-64n2s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/64fake-4n2s2ca2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/64intel64-fakeKNL-SNC4-hybrid.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8ia64-4s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/4fake-4gr1nu1pu.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2amd64-2n.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16amd64-8n2c-cpusets.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2i386-2t-hugepagesizecount.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/nvidiagpunumanodes.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/fakeheterocpunuma.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16amd64-4n4c-cgroup-distance-merge.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/8em64t-2s4c-heterogeneous.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/2s390-2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/64amd64-4s2n4ca2co.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/32amd64-4s2n4c-cgroup2.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/128ia64-17n4s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/16em64t-4s2ca2c-cpusetreorder.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/linux/allowed/test1.fsroot.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-SandyBridge-2xXeon-E5-2650.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Hygon-Dhyana-32cores.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-17h-Zen-2xEpyc-7451.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-CPUID.1F-Qemu-2p3d3c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-15h-Bulldozer-4xOpteron-6272.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-15h-Piledriver-4xOpteron-6348.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-K8-SantaRosa-2xOpteron-2218.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-KnightsLanding-XeonPhi-7210.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Westmere-2xXeon-X5650.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Skylake-2xXeon6140.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-K10-MagnyCours-2xOpteron-6164HE.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Haswell-2xXeon-E5-2680v3.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Nehalem-2xXeon-X5550.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-CPUID.1A-1p2co2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-K10-Istanbul-8xOpteron-8439SE.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/AMD-K8-SledgeHammer-2xOpteron-250.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-KnightsCorner-XeonPhi-SE10P.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-CascadeLake-2xXeon6230.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Zhaoxin-Shanghai-KaiSheng-ZXC+-FC1081.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Penryn-4xXeon-X7460.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Zhaoxin-CentaurHauls-ZXD-4600.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-IvyBridge-12xXeon-E5-4620v2.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Core-2xXeon-E5345.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86/Intel-Broadwell-2xXeon-E5-2650Lv4.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86+linux/5intel64-hybrid-lakefield.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/tests/hwloc/x86+linux/64amd64-4p2n4ca2co.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/ic_launcher-web.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/res/mipmap-xxhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/res/mipmap-xxxhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/res/mipmap-hdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/res/mipmap-mdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/lstopo/src/main/res/mipmap-xhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/AndroidApp/gradle/wrapper/gradle-wrapper.jar",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/contrib/android/assets/lstopo.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/ppc64-with-smt.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/emmett.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/hagrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/ppc64-full-with-smt.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/dudley.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/devel09-pci.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/netloc_design.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/netloc_draw.png",
        "/tmp/vanessa/spack-stage/spack-stage-hwloc-master-a4kix76fghq7x2q3m57fw52adkxl45ar/spack-src/doc/images/ppc64-without-smt.png"
    ],
    "total_files": 752
}