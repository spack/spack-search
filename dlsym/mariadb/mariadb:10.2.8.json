{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/lib/plugin.c": "/* -*- c-basic-offset: 2 -*- */\n/*\n  Copyright(C) 2012-2015 Brazil\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License version 2.1 as published by the Free Software Foundation.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#include \"grn.h\"\n#include <groonga/plugin.h>\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <sys/stat.h>\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n#endif /* HAVE_DIRENT_H */\n\n#ifndef S_ISREG\n# ifdef _S_IFREG\n#  define S_ISREG(mode) (mode & _S_IFREG)\n# endif /* _S_IFREG */\n#endif /* !S_ISREG */\n\n#include \"grn_db.h\"\n#include \"grn_plugin.h\"\n#include \"grn_ctx_impl.h\"\n#include \"grn_util.h\"\n\n#ifdef GRN_WITH_MRUBY\n# include <mruby.h>\n#endif /* GRN_WITH_MRUBY */\n\nstatic grn_hash *grn_plugins = NULL;\nstatic grn_critical_section grn_plugins_lock;\n\n#ifdef HAVE_DLFCN_H\n#  include <dlfcn.h>\n#  define grn_dl_open(filename)      dlopen(filename, RTLD_LAZY | RTLD_LOCAL)\n#  define grn_dl_open_error_label()  dlerror()\n#  define grn_dl_close(dl)           (dlclose(dl) == 0)\n#  define grn_dl_close_error_label() dlerror()\n#  define grn_dl_sym(dl, symbol)     dlsym(dl, symbol)\n#  define grn_dl_sym_error_label()   dlerror()\n#  define grn_dl_clear_error()       dlerror()\n#else\n#  define grn_dl_open(filename)      LoadLibrary(filename)\n#  define grn_dl_open_error_label()  \"LoadLibrary\"\n#  define grn_dl_close(dl)           (FreeLibrary(dl) != 0)\n#  define grn_dl_close_error_label() \"FreeLibrary\"\n#  define grn_dl_sym(dl, symbol)     ((void *)GetProcAddress(dl, symbol))\n#  define grn_dl_sym_error_label()   \"GetProcAddress\"\n#  define grn_dl_clear_error()\n#endif\n\n#define GRN_PLUGIN_KEY_SIZE(filename) (strlen((filename)) + 1)\n\nstatic char grn_plugins_dir[GRN_ENV_BUFFER_SIZE];\n\nvoid\ngrn_plugin_init_from_env(void)\n{\n  grn_getenv(\"GRN_PLUGINS_DIR\",\n             grn_plugins_dir,\n             GRN_ENV_BUFFER_SIZE);\n}\n\nstatic int\ncompute_name_size(const char *name, int name_size)\n{\n  if (name_size < 0) {\n    if (name) {\n      name_size = strlen(name);\n    } else {\n      name_size = 0;\n    }\n  }\n  return name_size;\n}\n\ngrn_id\ngrn_plugin_reference(grn_ctx *ctx, const char *filename)\n{\n  grn_id id;\n  grn_plugin **plugin = NULL;\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  id = grn_hash_get(&grn_gctx, grn_plugins,\n                    filename, GRN_PLUGIN_KEY_SIZE(filename),\n                    (void **)&plugin);\n  if (plugin) {\n    (*plugin)->refcount++;\n  }\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return id;\n}\n\nconst char *\ngrn_plugin_path(grn_ctx *ctx, grn_id id)\n{\n  const char *path;\n  grn_plugin *plugin;\n  int value_size;\n  const char *system_plugins_dir;\n  size_t system_plugins_dir_size;\n\n  if (id == GRN_ID_NIL) {\n    return NULL;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  value_size = grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin);\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (!plugin) {\n    return NULL;\n  }\n\n  path = plugin->path;\n  system_plugins_dir = grn_plugin_get_system_plugins_dir();\n  system_plugins_dir_size = strlen(system_plugins_dir);\n  if (strncmp(system_plugins_dir, path, system_plugins_dir_size) == 0) {\n    const char *plugin_name = path + system_plugins_dir_size;\n    while (plugin_name[0] == '/') {\n      plugin_name++;\n    }\n    /* TODO: remove suffix too? */\n    return plugin_name;\n  } else {\n    return path;\n  }\n}\n\n#define GRN_PLUGIN_FUNC_PREFIX \"grn_plugin_impl_\"\n\nstatic grn_rc\ngrn_plugin_call_init(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  if (!grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin)) {\n    return GRN_INVALID_ARGUMENT;\n  }\n  if (plugin->init_func) {\n    return plugin->init_func(ctx);\n  }\n  return GRN_SUCCESS;\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic grn_rc\ngrn_plugin_call_register_mrb(grn_ctx *ctx, grn_id id, grn_plugin *plugin)\n{\n  grn_mrb_data *data = &(ctx->impl->mrb);\n  mrb_state *mrb = data->state;\n  struct RClass *module = data->module;\n  struct RClass *plugin_loader_class;\n  int arena_index;\n\n  {\n    int added;\n    grn_hash_add(ctx, ctx->impl->mrb.registered_plugins,\n                 &id, sizeof(grn_id), NULL, &added);\n    if (!added) {\n      return ctx->rc;\n    }\n  }\n\n  arena_index = mrb_gc_arena_save(mrb);\n  plugin_loader_class = mrb_class_get_under(mrb, module, \"PluginLoader\");\n  mrb_funcall(mrb, mrb_obj_value(plugin_loader_class),\n              \"load_file\", 1, mrb_str_new_cstr(mrb, ctx->impl->plugin_path));\n  mrb_gc_arena_restore(mrb, arena_index);\n  return ctx->rc;\n}\n#endif /*GRN_WITH_MRUBY */\n\nstatic grn_rc\ngrn_plugin_call_register(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  if (!grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin)) {\n    return GRN_INVALID_ARGUMENT;\n  }\n#ifdef GRN_WITH_MRUBY\n  if (!plugin->dl) {\n    return grn_plugin_call_register_mrb(ctx, id, plugin);\n  }\n#endif /* GRN_WITH_MRUBY */\n  if (plugin->register_func) {\n    return plugin->register_func(ctx);\n  }\n  return GRN_SUCCESS;\n}\n\nstatic grn_rc\ngrn_plugin_call_fin(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  if (!grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin)) {\n    return GRN_INVALID_ARGUMENT;\n  }\n  if (plugin->fin_func) {\n    return plugin->fin_func(ctx);\n  }\n  return GRN_SUCCESS;\n}\n\nstatic grn_rc\ngrn_plugin_initialize(grn_ctx *ctx, grn_plugin *plugin,\n                      grn_dl dl, grn_id id, const char *path)\n{\n  plugin->dl = dl;\n\n#define GET_SYMBOL(type) do {                                           \\\n  grn_dl_clear_error();                                                 \\\n  plugin->type ## _func = grn_dl_sym(dl, GRN_PLUGIN_FUNC_PREFIX #type); \\\n  if (!plugin->type ## _func) {                                         \\\n    const char *label;                                                  \\\n    label = grn_dl_sym_error_label();                                   \\\n    SERR(label);                                                        \\\n  }                                                                     \\\n} while (0)\n\n  GET_SYMBOL(init);\n  GET_SYMBOL(register);\n  GET_SYMBOL(fin);\n\n#undef GET_SYMBOL\n\n  if (!plugin->init_func || !plugin->register_func || !plugin->fin_func) {\n    ERR(GRN_INVALID_FORMAT,\n        \"init func (%s) %sfound, \"\n        \"register func (%s) %sfound and \"\n        \"fin func (%s) %sfound\",\n        GRN_PLUGIN_FUNC_PREFIX \"init\", plugin->init_func ? \"\" : \"not \",\n        GRN_PLUGIN_FUNC_PREFIX \"register\", plugin->register_func ? \"\" : \"not \",\n        GRN_PLUGIN_FUNC_PREFIX \"fin\", plugin->fin_func ? \"\" : \"not \");\n  }\n\n  if (!ctx->rc) {\n    ctx->impl->plugin_path = path;\n    grn_plugin_call_init(ctx, id);\n    ctx->impl->plugin_path = NULL;\n  }\n\n  return ctx->rc;\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic grn_id\ngrn_plugin_open_mrb(grn_ctx *ctx, const char *filename, size_t filename_size)\n{\n  grn_id id = GRN_ID_NIL;\n  grn_plugin **plugin = NULL;\n\n  if (!ctx->impl->mrb.state) {\n    ERR(GRN_FUNCTION_NOT_IMPLEMENTED, \"mruby support isn't enabled\");\n    return GRN_ID_NIL;\n  }\n\n  id = grn_hash_add(&grn_gctx, grn_plugins, filename, filename_size,\n                    (void **)&plugin, NULL);\n  if (!id) {\n    return id;\n  }\n\n  *plugin = GRN_GMALLOCN(grn_plugin, 1);\n  if (!*plugin) {\n    grn_hash_delete_by_id(&grn_gctx, grn_plugins, id, NULL);\n    return GRN_ID_NIL;\n  }\n\n  grn_memcpy((*plugin)->path, filename, filename_size);\n  (*plugin)->dl = NULL;\n  (*plugin)->init_func = NULL;\n  (*plugin)->register_func = NULL;\n  (*plugin)->fin_func = NULL;\n  (*plugin)->refcount = 1;\n\n  return id;\n}\n#endif /* GRN_WITH_MRUBY */\n\ngrn_id\ngrn_plugin_open(grn_ctx *ctx, const char *filename)\n{\n  grn_id id = GRN_ID_NIL;\n  grn_dl dl;\n  grn_plugin **plugin = NULL;\n  size_t filename_size;\n\n  filename_size = GRN_PLUGIN_KEY_SIZE(filename);\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if ((id = grn_hash_get(&grn_gctx, grn_plugins, filename, filename_size,\n                         (void **)&plugin))) {\n    (*plugin)->refcount++;\n    goto exit;\n  }\n\n#ifdef GRN_WITH_MRUBY\n  {\n    const char *mrb_suffix;\n    mrb_suffix = grn_plugin_get_ruby_suffix();\n    if (filename_size > strlen(mrb_suffix) &&\n      strcmp(filename + (strlen(filename) - strlen(mrb_suffix)),\n             mrb_suffix) == 0) {\n      id = grn_plugin_open_mrb(ctx, filename, filename_size);\n      goto exit;\n    }\n  }\n#endif /* GRN_WITH_MRUBY */\n\n  if ((dl = grn_dl_open(filename))) {\n    if ((id = grn_hash_add(&grn_gctx, grn_plugins, filename, filename_size,\n                           (void **)&plugin, NULL))) {\n      *plugin = GRN_GMALLOCN(grn_plugin, 1);\n      if (*plugin) {\n        grn_memcpy((*plugin)->path, filename, filename_size);\n        if (grn_plugin_initialize(ctx, *plugin, dl, id, filename)) {\n          GRN_GFREE(*plugin);\n          *plugin = NULL;\n        }\n      }\n      if (!*plugin) {\n        grn_hash_delete_by_id(&grn_gctx, grn_plugins, id, NULL);\n        if (grn_dl_close(dl)) {\n          /* Now, __FILE__ set in plugin is invalid. */\n          ctx->errline = 0;\n          ctx->errfile = NULL;\n        } else {\n          const char *label;\n          label = grn_dl_close_error_label();\n          SERR(label);\n        }\n        id = GRN_ID_NIL;\n      } else {\n        (*plugin)->refcount = 1;\n      }\n    } else {\n      if (!grn_dl_close(dl)) {\n        const char *label;\n        label = grn_dl_close_error_label();\n        SERR(label);\n      }\n    }\n  } else {\n    const char *label;\n    label = grn_dl_open_error_label();\n    SERR(label);\n  }\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return id;\n}\n\ngrn_rc\ngrn_plugin_close(grn_ctx *ctx, grn_id id)\n{\n  grn_rc rc;\n  grn_plugin *plugin;\n\n  if (id == GRN_ID_NIL) {\n    return GRN_INVALID_ARGUMENT;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if (!grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin)) {\n    rc = GRN_INVALID_ARGUMENT;\n    goto exit;\n  }\n  if (--plugin->refcount) {\n    rc = GRN_SUCCESS;\n    goto exit;\n  }\n  if (plugin->dl) {\n    grn_plugin_call_fin(ctx, id);\n    if (!grn_dl_close(plugin->dl)) {\n      const char *label;\n      label = grn_dl_close_error_label();\n      SERR(label);\n    }\n  }\n  GRN_GFREE(plugin);\n  rc = grn_hash_delete_by_id(&grn_gctx, grn_plugins, id, NULL);\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return rc;\n}\n\nvoid *\ngrn_plugin_sym(grn_ctx *ctx, grn_id id, const char *symbol)\n{\n  grn_plugin *plugin;\n  grn_dl_symbol func;\n\n  if (id == GRN_ID_NIL) {\n    return NULL;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if (!grn_hash_get_value(&grn_gctx, grn_plugins, id, &plugin)) {\n    func = NULL;\n    goto exit;\n  }\n  grn_dl_clear_error();\n  if (!(func = grn_dl_sym(plugin->dl, symbol))) {\n    const char *label;\n    label = grn_dl_sym_error_label();\n    SERR(label);\n  }\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return func;\n}\n\ngrn_rc\ngrn_plugins_init(void)\n{\n  CRITICAL_SECTION_INIT(grn_plugins_lock);\n  grn_plugins = grn_hash_create(&grn_gctx, NULL, PATH_MAX, sizeof(grn_plugin *),\n                                GRN_OBJ_KEY_VAR_SIZE);\n  if (!grn_plugins) { return GRN_NO_MEMORY_AVAILABLE; }\n  return GRN_SUCCESS;\n}\n\ngrn_rc\ngrn_plugins_fin(void)\n{\n  grn_rc rc;\n  if (!grn_plugins) { return GRN_INVALID_ARGUMENT; }\n  GRN_HASH_EACH(&grn_gctx, grn_plugins, id, NULL, NULL, NULL, {\n    grn_plugin_close(&grn_gctx, id);\n  });\n  rc = grn_hash_close(&grn_gctx, grn_plugins);\n  CRITICAL_SECTION_FIN(grn_plugins_lock);\n  return rc;\n}\n\nconst char *\ngrn_plugin_get_suffix(void)\n{\n  return GRN_PLUGIN_SUFFIX;\n}\n\nconst char *\ngrn_plugin_get_ruby_suffix(void)\n{\n  return \".rb\";\n}\n\ngrn_rc\ngrn_plugin_register_by_path(grn_ctx *ctx, const char *path)\n{\n  grn_obj *db;\n  if (!ctx || !ctx->impl || !(db = ctx->impl->db)) {\n    ERR(GRN_INVALID_ARGUMENT, \"db not initialized\");\n    return ctx->rc;\n  }\n  GRN_API_ENTER;\n  if (GRN_DB_P(db)) {\n    grn_id id;\n    id = grn_plugin_open(ctx, path);\n    if (id) {\n      ctx->impl->plugin_path = path;\n      ctx->rc = grn_plugin_call_register(ctx, id);\n      ctx->impl->plugin_path = NULL;\n      grn_plugin_close(ctx, id);\n    }\n  } else {\n    ERR(GRN_INVALID_ARGUMENT, \"invalid db assigned\");\n  }\n  GRN_API_RETURN(ctx->rc);\n}\n\n#ifdef WIN32\nstatic char *win32_plugins_dir = NULL;\nstatic char win32_plugins_dir_buffer[PATH_MAX];\nstatic const char *\ngrn_plugin_get_default_system_plugins_dir(void)\n{\n  if (!win32_plugins_dir) {\n    const char *base_dir;\n    const char *relative_path = GRN_RELATIVE_PLUGINS_DIR;\n    size_t base_dir_length;\n\n    base_dir = grn_win32_base_dir();\n    base_dir_length = strlen(base_dir);\n    grn_strcpy(win32_plugins_dir_buffer, PATH_MAX, base_dir);\n    grn_strcat(win32_plugins_dir_buffer, PATH_MAX, \"/\");\n    grn_strcat(win32_plugins_dir_buffer, PATH_MAX, relative_path);\n    win32_plugins_dir = win32_plugins_dir_buffer;\n  }\n  return win32_plugins_dir;\n}\n\n#else /* WIN32 */\nstatic const char *\ngrn_plugin_get_default_system_plugins_dir(void)\n{\n  return GRN_PLUGINS_DIR;\n}\n#endif /* WIN32 */\n\nconst char *\ngrn_plugin_get_system_plugins_dir(void)\n{\n  if (grn_plugins_dir[0]) {\n    return grn_plugins_dir;\n  } else {\n    return grn_plugin_get_default_system_plugins_dir();\n  }\n}\n\nstatic char *\ngrn_plugin_find_path_raw(grn_ctx *ctx, const char *path)\n{\n  struct stat path_stat;\n\n  if (stat(path, &path_stat) != 0) {\n    return NULL;\n  }\n\n  if (!S_ISREG(path_stat.st_mode)) {\n    return NULL;\n  }\n\n  return GRN_STRDUP(path);\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic char *\ngrn_plugin_find_path_mrb(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char mrb_path[PATH_MAX];\n  const char *mrb_suffix;\n  size_t mrb_path_len;\n\n  mrb_suffix = grn_plugin_get_ruby_suffix();\n  if (!ctx->impl->mrb.state) {\n    return NULL;\n  }\n\n  mrb_path_len = path_len + strlen(mrb_suffix);\n  if (mrb_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%s%s>\",\n        path, mrb_suffix);\n    return NULL;\n  }\n\n  grn_strcpy(mrb_path, PATH_MAX, path);\n  grn_strcat(mrb_path, PATH_MAX, mrb_suffix);\n  return grn_plugin_find_path_raw(ctx, mrb_path);\n}\n#else /* GRN_WITH_MRUBY */\nstatic char *\ngrn_plugin_find_path_mrb(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  return NULL;\n}\n#endif /* GRN_WITH_MRUBY */\n\nstatic char *\ngrn_plugin_find_path_so(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char so_path[PATH_MAX];\n  const char *so_suffix;\n  size_t so_path_len;\n\n  so_suffix = grn_plugin_get_suffix();\n  so_path_len = path_len + strlen(so_suffix);\n  if (so_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%s%s>\",\n        path, so_suffix);\n    return NULL;\n  }\n\n  grn_strcpy(so_path, PATH_MAX, path);\n  grn_strcat(so_path, PATH_MAX, so_suffix);\n  return grn_plugin_find_path_raw(ctx, so_path);\n}\n\nstatic char *\ngrn_plugin_find_path_libs_so(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char libs_so_path[PATH_MAX];\n  const char *base_name;\n  const char *so_suffix;\n  const char *libs_path = \"/.libs\";\n  size_t libs_so_path_len;\n\n  base_name = strrchr(path, '/');\n  if (!base_name) {\n    return NULL;\n  }\n\n  so_suffix = grn_plugin_get_suffix();\n  libs_so_path_len =\n    base_name - path +\n    strlen(libs_path) +\n    strlen(base_name) +\n    strlen(so_suffix);\n  if (libs_so_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%.*s/.libs%s%s>\",\n        (int)(base_name - path), path, base_name, so_suffix);\n    return NULL;\n  }\n\n  libs_so_path[0] = '\\0';\n  grn_strncat(libs_so_path, PATH_MAX, path, base_name - path);\n  grn_strcat(libs_so_path, PATH_MAX, libs_path);\n  grn_strcat(libs_so_path, PATH_MAX, base_name);\n  grn_strcat(libs_so_path, PATH_MAX, so_suffix);\n  return grn_plugin_find_path_raw(ctx, libs_so_path);\n}\n\nchar *\ngrn_plugin_find_path(grn_ctx *ctx, const char *name)\n{\n  const char *plugins_dir;\n  char dir_last_char;\n  char path[PATH_MAX];\n  int name_length, max_name_length;\n  char *found_path = NULL;\n  size_t path_len;\n\n  GRN_API_ENTER;\n  if (name[0] == '/') {\n    path[0] = '\\0';\n  } else {\n    plugins_dir = grn_plugin_get_system_plugins_dir();\n    grn_strcpy(path, PATH_MAX, plugins_dir);\n\n    dir_last_char = plugins_dir[strlen(path) - 1];\n    if (dir_last_char != '/') {\n      grn_strcat(path, PATH_MAX, \"/\");\n    }\n  }\n\n  name_length = strlen(name);\n  max_name_length = PATH_MAX - strlen(path) - 1;\n  if (name_length > max_name_length) {\n    ERR(GRN_INVALID_ARGUMENT,\n        \"plugin name is too long: %d (max: %d) <%s%s>\",\n        name_length, max_name_length,\n        path, name);\n    goto exit;\n  }\n  grn_strcat(path, PATH_MAX, name);\n\n  found_path = grn_plugin_find_path_raw(ctx, path);\n  if (found_path) {\n    goto exit;\n  }\n\n  path_len = strlen(path);\n  found_path = grn_plugin_find_path_mrb(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\n  found_path = grn_plugin_find_path_so(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\n  found_path = grn_plugin_find_path_libs_so(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\nexit :\n  GRN_API_RETURN(found_path);\n}\n\nstatic void\ngrn_plugin_set_name_resolve_error(grn_ctx *ctx, const char *name,\n                                  const char *tag)\n{\n  const char *prefix, *prefix_separator, *suffix;\n\n  if (name[0] == '/') {\n    prefix = \"\";\n    prefix_separator = \"\";\n    suffix = \"\";\n  } else {\n    prefix = grn_plugin_get_system_plugins_dir();\n    if (prefix[strlen(prefix) - 1] != '/') {\n      prefix_separator = \"/\";\n    } else {\n      prefix_separator = \"\";\n    }\n    suffix = grn_plugin_get_suffix();\n  }\n  ERR(GRN_NO_SUCH_FILE_OR_DIRECTORY,\n      \"%s cannot find plugin file: <%s%s%s%s>\",\n      tag, prefix, prefix_separator, name, suffix);\n}\n\ngrn_rc\ngrn_plugin_register(grn_ctx *ctx, const char *name)\n{\n  grn_rc rc;\n  char *path;\n\n  GRN_API_ENTER;\n  path = grn_plugin_find_path(ctx, name);\n  if (path) {\n    rc = grn_plugin_register_by_path(ctx, path);\n    GRN_FREE(path);\n  } else {\n    if (ctx->rc == GRN_SUCCESS) {\n      grn_plugin_set_name_resolve_error(ctx, name, \"[plugin][register]\");\n    }\n    rc = ctx->rc;\n  }\n  GRN_API_RETURN(rc);\n}\n\ngrn_rc\ngrn_plugin_unregister_by_path(grn_ctx *ctx, const char *path)\n{\n  grn_obj *db;\n  grn_id plugin_id;\n\n  if (!ctx || !ctx->impl) {\n    ERR(GRN_INVALID_ARGUMENT, \"[plugin][unregister] ctx isn't initialized\");\n    return ctx->rc;\n  }\n\n  db = ctx->impl->db;\n  if (!db) {\n    ERR(GRN_INVALID_ARGUMENT, \"[plugin][unregister] DB isn't initialized\");\n    return ctx->rc;\n  }\n\n  GRN_API_ENTER;\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  plugin_id = grn_hash_get(&grn_gctx, grn_plugins,\n                           path, GRN_PLUGIN_KEY_SIZE(path),\n                           NULL);\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (plugin_id == GRN_ID_NIL) {\n    GRN_API_RETURN(ctx->rc);\n  }\n\n  {\n    grn_table_cursor *cursor;\n    grn_id id;\n\n    cursor = grn_table_cursor_open(ctx, db,\n                                   NULL, 0,\n                                   NULL, 0,\n                                   0, -1, GRN_CURSOR_BY_ID);\n    if (!cursor) {\n      GRN_API_RETURN(ctx->rc);\n    }\n\n    while ((id = grn_table_cursor_next(ctx, cursor))) {\n      grn_obj *obj;\n      obj = grn_ctx_at(ctx, id);\n      if (!obj) {\n        continue;\n      }\n      if (obj->header.type == GRN_PROC && DB_OBJ(obj)->range == plugin_id) {\n        grn_obj_remove(ctx, obj);\n      } else {\n        grn_obj_unlink(ctx, obj);\n      }\n    }\n    grn_table_cursor_close(ctx, cursor);\n  }\n\n  GRN_API_RETURN(ctx->rc);\n}\n\ngrn_rc\ngrn_plugin_unregister(grn_ctx *ctx, const char *name)\n{\n  grn_rc rc;\n  char *path;\n\n  GRN_API_ENTER;\n  path = grn_plugin_find_path(ctx, name);\n  if (path) {\n    rc = grn_plugin_unregister_by_path(ctx, path);\n    GRN_FREE(path);\n  } else {\n    if (ctx->rc == GRN_SUCCESS) {\n      grn_plugin_set_name_resolve_error(ctx, name, \"[plugin][unregister]\");\n    }\n    rc = ctx->rc;\n  }\n  GRN_API_RETURN(rc);\n}\n\nvoid\ngrn_plugin_ensure_registered(grn_ctx *ctx, grn_obj *proc)\n{\n#ifdef GRN_WITH_MRUBY\n  grn_id plugin_id;\n  const char *plugin_path;\n  uint32_t key_size;\n  grn_plugin *plugin;\n  int value_size;\n\n  if (!ctx->impl->mrb.state) {\n    return;\n  }\n\n  if (!(proc->header.flags & GRN_OBJ_CUSTOM_NAME)) {\n    return;\n  }\n\n  {\n    grn_id id;\n    int added;\n    id = DB_OBJ(proc)->id;\n    grn_hash_add(ctx, ctx->impl->mrb.checked_procs,\n                 &id, sizeof(grn_id), NULL, &added);\n    if (!added) {\n      return;\n    }\n  }\n\n  plugin_id = DB_OBJ(proc)->range;\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  plugin_path = _grn_hash_key(&grn_gctx, grn_plugins, plugin_id, &key_size);\n  if (plugin_path) {\n    value_size = grn_hash_get_value(&grn_gctx, grn_plugins, plugin_id, &plugin);\n  }\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (!plugin_path) {\n    return;\n  }\n\n  if (plugin->dl) {\n    return;\n  }\n\n  ctx->impl->plugin_path = plugin_path;\n  grn_plugin_call_register_mrb(ctx, plugin_id, plugin);\n  ctx->impl->plugin_path = NULL;\n#endif /* GRN_WITH_MRUBY */\n}\n\nvoid *\ngrn_plugin_malloc(grn_ctx *ctx, size_t size, const char *file, int line,\n                  const char *func)\n{\n  return grn_malloc(ctx, size, file, line, func);\n}\n\nvoid *\ngrn_plugin_realloc(grn_ctx *ctx, void *ptr, size_t size,\n                   const char *file, int line, const char *func)\n{\n  return grn_realloc(ctx, ptr, size, file, line, func);\n}\n\nvoid\ngrn_plugin_free(grn_ctx *ctx, void *ptr, const char *file, int line,\n                const char *func)\n{\n  grn_free(ctx, ptr, file, line, func);\n}\n\n/*\n  grn_plugin_ctx_log() is a clone of grn_ctx_log() in ctx.c. The only\n  difference is that grn_plugin_ctx_log() uses va_list instead of `...'.\n */\nstatic void\ngrn_plugin_ctx_log(grn_ctx *ctx, const char *format, va_list ap)\n{\n  vsnprintf(ctx->errbuf, GRN_CTX_MSGSIZE, format, ap);\n}\n\nvoid\ngrn_plugin_set_error(grn_ctx *ctx, grn_log_level level, grn_rc error_code,\n                     const char *file, int line, const char *func,\n                     const char *format, ...)\n{\n  ctx->errlvl = level;\n  ctx->rc = error_code;\n  ctx->errfile = file;\n  ctx->errline = line;\n  ctx->errfunc = func;\n\n  {\n    va_list ap;\n    va_start(ap, format);\n    grn_plugin_ctx_log(ctx, format, ap);\n    va_end(ap);\n  }\n}\n\nvoid\ngrn_plugin_backtrace(grn_ctx *ctx)\n{\n  BACKTRACE(ctx);\n}\n\nvoid\ngrn_plugin_logtrace(grn_ctx *ctx, grn_log_level level)\n{\n  if (level <= GRN_LOG_ERROR) {\n    LOGTRACE(ctx, level);\n  }\n}\n\nstruct _grn_plugin_mutex {\n  grn_critical_section critical_section;\n};\n\ngrn_plugin_mutex *\ngrn_plugin_mutex_open(grn_ctx *ctx)\n{\n  grn_plugin_mutex * const mutex =\n      GRN_PLUGIN_MALLOC(ctx, sizeof(grn_plugin_mutex));\n  if (mutex != NULL) {\n    CRITICAL_SECTION_INIT(mutex->critical_section);\n  }\n  return mutex;\n}\n\ngrn_plugin_mutex *\ngrn_plugin_mutex_create(grn_ctx *ctx)\n{\n  return grn_plugin_mutex_open(ctx);\n}\n\nvoid\ngrn_plugin_mutex_close(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_FIN(mutex->critical_section);\n    GRN_PLUGIN_FREE(ctx, mutex);\n  }\n}\n\nvoid\ngrn_plugin_mutex_destroy(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  grn_plugin_mutex_close(ctx, mutex);\n}\n\nvoid\ngrn_plugin_mutex_lock(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_ENTER(mutex->critical_section);\n  }\n}\n\nvoid\ngrn_plugin_mutex_unlock(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_LEAVE(mutex->critical_section);\n  }\n}\n\ngrn_obj *\ngrn_plugin_proc_alloc(grn_ctx *ctx, grn_user_data *user_data,\n                      grn_id domain, grn_obj_flags flags)\n{\n  return grn_proc_alloc(ctx, user_data, domain, flags);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_vars(grn_ctx *ctx, grn_user_data *user_data)\n{\n  return grn_proc_get_vars(ctx, user_data);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_var(grn_ctx *ctx, grn_user_data *user_data,\n                        const char *name, int name_size)\n{\n  name_size = compute_name_size(name, name_size);\n  return grn_proc_get_var(ctx, user_data, name, name_size);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_var_by_offset(grn_ctx *ctx, grn_user_data *user_data,\n                                  unsigned int offset)\n{\n  return grn_proc_get_var_by_offset(ctx, user_data, offset);\n}\n\nconst char *\ngrn_plugin_win32_base_dir(void)\n{\n#ifdef WIN32\n  return grn_win32_base_dir();\n#else /* WIN32 */\n  return NULL;\n#endif /* WIN32 */\n}\n\n/*\n  grn_plugin_charlen() takes the length of a string, unlike grn_charlen_().\n */\nint\ngrn_plugin_charlen(grn_ctx *ctx, const char *str_ptr,\n                   unsigned int str_length, grn_encoding encoding)\n{\n  return grn_charlen_(ctx, str_ptr, str_ptr + str_length, encoding);\n}\n\n/*\n  grn_plugin_isspace() takes the length of a string, unlike grn_isspace().\n */\nint\ngrn_plugin_isspace(grn_ctx *ctx, const char *str_ptr,\n                   unsigned int str_length, grn_encoding encoding)\n{\n  if ((str_ptr == NULL) || (str_length == 0)) {\n    return 0;\n  }\n  switch ((unsigned char)str_ptr[0]) {\n  case ' ' :\n  case '\\f' :\n  case '\\n' :\n  case '\\r' :\n  case '\\t' :\n  case '\\v' :\n    return 1;\n  case 0x81 :\n    if ((encoding == GRN_ENC_SJIS) && (str_length >= 2) &&\n        ((unsigned char)str_ptr[1] == 0x40)) {\n      return 2;\n    }\n    break;\n  case 0xA1 :\n    if ((encoding == GRN_ENC_EUC_JP) && (str_length >= 2) &&\n        ((unsigned char)str_ptr[1] == 0xA1)) {\n      return 2;\n    }\n    break;\n  case 0xE3 :\n    if ((encoding == GRN_ENC_UTF8) && (str_length >= 3) &&\n        ((unsigned char)str_ptr[1] == 0x80) &&\n        ((unsigned char)str_ptr[2] == 0x80)) {\n      return 3;\n    }\n    break;\n  default :\n    break;\n  }\n  return 0;\n}\n\ngrn_rc\ngrn_plugin_expr_var_init(grn_ctx *ctx,\n                         grn_expr_var *var,\n                         const char *name,\n                         int name_size)\n{\n  var->name = name;\n  var->name_size = compute_name_size(name, name_size);\n  GRN_TEXT_INIT(&var->value, 0);\n  return GRN_SUCCESS;\n}\n\ngrn_obj *\ngrn_plugin_command_create(grn_ctx *ctx,\n                          const char *name,\n                          int name_size,\n                          grn_proc_func func,\n                          unsigned int n_vars,\n                          grn_expr_var *vars)\n{\n  grn_obj *proc;\n  name_size = compute_name_size(name, name_size);\n  proc = grn_proc_create(ctx, name, name_size, GRN_PROC_COMMAND,\n                         func, NULL, NULL, n_vars, vars);\n  return proc;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/javaconn.cpp": "/************ Javaconn C++ Functions Source Code File (.CPP) ***********/\n/*  Name: JAVAConn.CPP  Version 1.0                                    */\n/*                                                                     */\n/*  (C) Copyright to the author Olivier BERTRAND          2017         */\n/*                                                                     */\n/*  This file contains the JAVA connection classes functions.          */\n/***********************************************************************/\n\n#if defined(__WIN__)\n// This is needed for RegGetValue\n#define _WINVER 0x0601\n#undef  _WIN32_WINNT\n#define _WIN32_WINNT 0x0601\n#endif   // __WIN__\n\n/***********************************************************************/\n/*  Include relevant MariaDB header file.                              */\n/***********************************************************************/\n#include <my_global.h>\n#include <m_string.h>\n#if defined(__WIN__)\n#include <direct.h>                      // for getcwd\n#if defined(__BORLANDC__)\n#define __MFC_COMPAT__                   // To define min/max as macro\n#endif   // __BORLANDC__\n#else   // !__WIN__\n#if defined(UNIX)\n#include <errno.h>\n#else   // !UNIX\n#endif  // !UNIX\n#include <stdio.h>\n#include <stdlib.h>                      // for getenv\n#define NODW\n#endif  // !__WIN__\n\n/***********************************************************************/\n/*  Required objects includes.                                         */\n/***********************************************************************/\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"colblk.h\"\n#include \"xobject.h\"\n#include \"xtable.h\"\n#include \"tabext.h\"\n#include \"javaconn.h\"\n#include \"resource.h\"\n#include \"valblk.h\"\n#include \"osutil.h\"\n\n#if defined(__WIN__)\nextern \"C\" HINSTANCE s_hModule;           // Saved module handle\n#endif   // __WIN__\n#define nullptr 0\n\n//TYPCONV GetTypeConv();\n//int GetConvSize();\nextern char *JvmPath;   // The connect_jvm_path global variable value\nextern char *ClassPath; // The connect_class_path global variable value\n\nchar *GetJavaWrapper(void);\t\t// The connect_java_wrapper variable value\n\n/***********************************************************************/\n/*  Static JAVAConn objects.                                           */\n/***********************************************************************/\nvoid  *JAVAConn::LibJvm = NULL;\nCRTJVM JAVAConn::CreateJavaVM = NULL;\nGETJVM JAVAConn::GetCreatedJavaVMs = NULL;\n#if defined(_DEBUG)\nGETDEF JAVAConn::GetDefaultJavaVMInitArgs = NULL;\n#endif   // _DEBUG\n\n/***********************************************************************/\n/*  Some macro's (should be defined elsewhere to be more accessible)   */\n/***********************************************************************/\n#if defined(_DEBUG)\n#define ASSERT(f)          assert(f)\n#define DEBUG_ONLY(f)      (f)\n#else   // !_DEBUG\n#define ASSERT(f)          ((void)0)\n#define DEBUG_ONLY(f)      ((void)0)\n#endif  // !_DEBUG\n\n/***********************************************************************/\n/*  Allocate the structure used to refer to the result set.            */\n/***********************************************************************/\nstatic JCATPARM *AllocCatInfo(PGLOBAL g, JCATINFO fid, PCSZ db,\n\tPCSZ tab, PQRYRES qrp)\n{\n\tJCATPARM *cap;\n\n#if defined(_DEBUG)\n\tassert(qrp);\n#endif\n\n\tif ((cap = (JCATPARM *)PlgDBSubAlloc(g, NULL, sizeof(JCATPARM)))) {\n\t\tmemset(cap, 0, sizeof(JCATPARM));\n\t\tcap->Id = fid;\n\t\tcap->Qrp = qrp;\n\t\tcap->DB = db;\n\t\tcap->Tab = tab;\n\t} // endif cap\n\n\treturn cap;\n} // end of AllocCatInfo\n\n/***********************************************************************/\n/*  JAVAConn construction/destruction.                                 */\n/***********************************************************************/\nJAVAConn::JAVAConn(PGLOBAL g, PCSZ wrapper)\n{\n\tm_G = g;\n\tjvm = nullptr;            // Pointer to the JVM (Java Virtual Machine)\n\tenv = nullptr;            // Pointer to native interface\n\tjdi = nullptr;\t\t\t\t\t\t// Pointer to the java wrapper class\n\tjob = nullptr;\t\t\t\t\t\t// The java wrapper class object\n\terrid = nullptr;\n\tDiscFunc = \"Disconnect\";\n\tMsg = NULL;\n\tm_Wrap = (wrapper) ? wrapper : GetJavaWrapper();\n\n\tif (!strchr(m_Wrap, '/')) {\n\t\t// Add the wrapper package name\n\t\tchar *wn = (char*)PlugSubAlloc(g, NULL, strlen(m_Wrap) + 10);\n\t\tm_Wrap = strcat(strcpy(wn, \"wrappers/\"), m_Wrap);\n\t} // endif m_Wrap\n\n\tfp = NULL;\n\tm_Opened = false;\n\tm_Connected = false;\n\tm_Rows = 0;\n//*m_ErrMsg = '\\0';\n} // end of JAVAConn\n\n//JAVAConn::~JAVAConn()\n//  {\n//if (Connected())\n//  EndCom();\n\n//  } // end of ~JAVAConn\n\n/***********************************************************************/\n/*  Screen for errors.                                                 */\n/***********************************************************************/\nbool JAVAConn::Check(jint rc)\n{\n\tjstring s;\n\n\tif (env->ExceptionCheck()) {\n\t\tjthrowable exc = env->ExceptionOccurred();\n\t\tjmethodID tid = env->GetMethodID(env->FindClass(\"java/lang/Object\"),\n\t\t\t\"toString\", \"()Ljava/lang/String;\");\n\n\t\tif (exc != nullptr && tid != nullptr) {\n\t\t\tjstring s = (jstring)env->CallObjectMethod(exc, tid);\n\t\t\tconst char *utf = env->GetStringUTFChars(s, (jboolean)false);\n\t\t\tenv->DeleteLocalRef(s);\n\t\t\tMsg = PlugDup(m_G, utf);\n\t\t} else\n\t\t\tMsg = \"Exception occured\";\n\n\t\tenv->ExceptionClear();\n\t} else if (rc < 0) {\n\t\ts = (jstring)env->CallObjectMethod(job, errid);\n\t\tMsg = (char*)env->GetStringUTFChars(s, (jboolean)false);\n\t} else\n\t\tMsg = NULL;\n\n\treturn (Msg != NULL);\n} // end of Check\n\n/***********************************************************************/\n/*  Get MethodID if not exists yet.                                    */\n/***********************************************************************/\nbool JAVAConn::gmID(PGLOBAL g, jmethodID& mid, const char *name, const char *sig)\n{\n\tif (mid == nullptr) {\n\t\tmid = env->GetMethodID(jdi, name, sig);\n\n\t\tif (Check()) {\n\t\t\tstrcpy(g->Message, Msg);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\n\t} else\n\t\treturn false;\n\n} // end of gmID\n\n#if 0\n/***********************************************************************/\n/*  Utility routine.                                                   */\n/***********************************************************************/\nint JAVAConn::GetMaxValue(int n)\n{\n\tjint      m;\n\tjmethodID maxid = nullptr;\n\n\tif (gmID(m_G, maxid, \"GetMaxValue\", \"(I)I\"))\n\t\treturn -1;\n\n\t// call method\n\tif (Check(m = env->CallIntMethod(job, maxid, n)))\n\t\thtrc(\"GetMaxValue: %s\", Msg);\n\n\treturn (int)m;\n} // end of GetMaxValue\n#endif // 0\n\n/***********************************************************************/\n/*  Reset the JVM library.                                             */\n/***********************************************************************/\nvoid JAVAConn::ResetJVM(void)\n{\n\tif (LibJvm) {\n#if defined(__WIN__)\n\t\tFreeLibrary((HMODULE)LibJvm);\n#else   // !__WIN__\n\t\tdlclose(LibJvm);\n#endif  // !__WIN__\n\t\tLibJvm = NULL;\n\t\tCreateJavaVM = NULL;\n\t\tGetCreatedJavaVMs = NULL;\n#if defined(_DEBUG)\n\t\tGetDefaultJavaVMInitArgs = NULL;\n#endif   // _DEBUG\n\t} // endif LibJvm\n\n} // end of ResetJVM\n\n/***********************************************************************/\n/*  Dynamically link the JVM library.                                  */\n/*  The purpose of this function is to allow using the CONNECT plugin  */\n/*  for other table types when the Java JDK is not installed.          */\n/***********************************************************************/\nbool JAVAConn::GetJVM(PGLOBAL g)\n{\n\tint ntry;\n\n\tif (!LibJvm) {\n\t\tchar soname[512];\n\n#if defined(__WIN__)\n\t\tfor (ntry = 0; !LibJvm && ntry < 3; ntry++) {\n\t\t\tif (!ntry && JvmPath) {\n\t\t\t\tstrcat(strcpy(soname, JvmPath), \"\\\\jvm.dll\");\n\t\t\t\tntry = 3;\t\t // No other try\n\t\t\t} else if (ntry < 2 && getenv(\"JAVA_HOME\")) {\n\t\t\t\tstrcpy(soname, getenv(\"JAVA_HOME\"));\n\n\t\t\t\tif (ntry == 1)\n\t\t\t\t\tstrcat(soname, \"\\\\jre\");\n\n\t\t\t\tstrcat(soname, \"\\\\bin\\\\client\\\\jvm.dll\");\n\t\t\t} else {\n\t\t\t\t// Try to find it through the registry\n\t\t\t\tchar version[16];\n\t\t\t\tchar javaKey[64] = \"SOFTWARE\\\\JavaSoft\\\\Java Runtime Environment\";\n\t\t\t\tLONG  rc;\n\t\t\t\tDWORD BufferSize = 16;\n\n\t\t\t\tstrcpy(soname, \"jvm.dll\");\t\t// In case it fails\n\n\t\t\t\tif ((rc = RegGetValue(HKEY_LOCAL_MACHINE, javaKey, \"CurrentVersion\",\n\t\t\t\t\tRRF_RT_ANY, NULL, (PVOID)&version, &BufferSize)) == ERROR_SUCCESS) {\n\t\t\t\t\tstrcat(strcat(javaKey, \"\\\\\"), version);\n\t\t\t\t\tBufferSize = sizeof(soname);\n\n\t\t\t\t\tif ((rc = RegGetValue(HKEY_LOCAL_MACHINE, javaKey, \"RuntimeLib\",\n\t\t\t\t\t\tRRF_RT_ANY, NULL, (PVOID)&soname, &BufferSize)) != ERROR_SUCCESS)\n\t\t\t\t\t\tprintf(\"RegGetValue: rc=%ld\\n\", rc);\n\n\t\t\t\t} // endif rc\n\n\t\t\t\tntry = 3;\t\t // Try this only once\n\t\t\t} // endelse\n\n\t\t\t// Load the desired shared library\n\t\t\tLibJvm = LoadLibrary(soname);\n\t\t}\t// endfor ntry\n\n\t\t// Get the needed entries\n\t\tif (!LibJvm) {\n\t\t\tchar  buf[256];\n\t\t\tDWORD rc = GetLastError();\n\n\t\t\tsprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n\t\t\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t\t\t\t\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n\t\t\t\t            (LPTSTR)buf, sizeof(buf), NULL);\n\t\t\tstrcat(strcat(g->Message, \": \"), buf);\n\t\t} else if (!(CreateJavaVM = (CRTJVM)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_CreateJavaVM\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), \"JNI_CreateJavaVM\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n\t\t} else if (!(GetCreatedJavaVMs = (GETJVM)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_GetCreatedJavaVMs\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), \"JNI_GetCreatedJavaVMs\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n#if defined(_DEBUG)\n\t\t} else if (!(GetDefaultJavaVMInitArgs = (GETDEF)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_GetDefaultJavaVMInitArgs\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(),\n\t\t\t\t\"JNI_GetDefaultJavaVMInitArgs\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n#endif   // _DEBUG\n\t\t} // endif LibJvm\n#else   // !__WIN__\n\t\tconst char *error = NULL;\n\n\t\tfor (ntry = 0; !LibJvm && ntry < 2; ntry++) {\n\t\t\tif (!ntry && JvmPath) {\n\t\t\t\tstrcat(strcpy(soname, JvmPath), \"/libjvm.so\");\n\t\t\t\tntry = 2;\n\t\t\t} else if (!ntry && getenv(\"JAVA_HOME\")) {\n\t\t\t\t// TODO: Replace i386 by a better guess\n\t\t\t\tstrcat(strcpy(soname, getenv(\"JAVA_HOME\")), \"/jre/lib/i386/client/libjvm.so\");\n\t\t\t} else {\t // Will need LD_LIBRARY_PATH to be set\n\t\t\t\tstrcpy(soname, \"libjvm.so\");\n\t\t\t\tntry = 2;\n\t\t\t} // endelse\n\n\t\t\tLibJvm = dlopen(soname, RTLD_LAZY);\n\t\t} // endfor ntry\n\n\t\t\t// Load the desired shared library\n\t\tif (!LibJvm) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n\t\t} else if (!(CreateJavaVM = (CRTJVM)dlsym(LibJvm, \"JNI_CreateJavaVM\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_CreateJavaVM\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n\t\t} else if (!(GetCreatedJavaVMs = (GETJVM)dlsym(LibJvm, \"JNI_GetCreatedJavaVMs\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_GetCreatedJavaVMs\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n#if defined(_DEBUG)\n\t\t} else if (!(GetDefaultJavaVMInitArgs = (GETDEF)dlsym(LibJvm,\n\t\t\t\"JNI_GetDefaultJavaVMInitArgs\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_GetDefaultJavaVMInitArgs\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n#endif   // _DEBUG\n\t\t} // endif LibJvm\n#endif  // !__WIN__\n\n\t} // endif LibJvm\n\n\treturn LibJvm == NULL;\n} // end of GetJVM\n\n/***********************************************************************/\n/*  Open: connect to a data source.                                    */\n/***********************************************************************/\nbool JAVAConn::Open(PGLOBAL g)\n{\n\tbool\t\t brc = true, err = false;\n\tjboolean jt = (trace > 0);\n\n\t// Link or check whether jvm library was linked\n\tif (GetJVM(g))\n\t\treturn true;\n\n\t// Firstly check whether the jvm was already created\n\tJavaVM* jvms[1];\n\tjsize   jsz;\n\tjint    rc = GetCreatedJavaVMs(jvms, 1, &jsz);\n\n\tif (rc == JNI_OK && jsz == 1) {\n\t\t// jvm already existing\n\t\tjvm = jvms[0];\n\t\trc = jvm->AttachCurrentThread((void**)&env, nullptr);\n\n\t\tif (rc != JNI_OK) {\n\t\t\tstrcpy(g->Message, \"Cannot attach jvm to the current thread\");\n\t\t\treturn true;\n\t\t} // endif rc\n\n\t} else {\n\t\t/*******************************************************************/\n\t\t/*  Create a new jvm\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t */\n\t\t/*******************************************************************/\n\t\tPSTRG    jpop = new(g)STRING(g, 512, \"-Djava.class.path=.\");\n\t\tchar    *cp = NULL;\n\t\tchar     sep;\n\n#if defined(__WIN__)\n\t\tsep = ';';\n#define N 1\n\t\t//#define N 2\n\t\t//#define N 3\n#else\n\t\tsep = ':';\n#define N 1\n#endif\n\n\t\t// Add wrappers jar files \n\t\tAddJars(jpop, sep);\n\n\t\t//================== prepare loading of Java VM ============================\n\t\tJavaVMInitArgs vm_args;                        // Initialization arguments\n\t\tJavaVMOption* options = new JavaVMOption[N];   // JVM invocation options\n\n\t\t// where to find java .class\n\t\tif (ClassPath && *ClassPath) {\n\t\t\tjpop->Append(sep);\n\t\t\tjpop->Append(ClassPath);\n\t\t}\t// endif ClassPath\n\n\t\t\t// Java source will be compiled as a jar file installed in the plugin dir\n\t\tjpop->Append(sep);\n\t\tjpop->Append(GetPluginDir());\n\t\tjpop->Append(\"JdbcInterface.jar\");\n\n\t\t// All wrappers are pre-compiled in JavaWrappers.jar in the plugin dir\n\t\tjpop->Append(sep);\n\t\tjpop->Append(GetPluginDir());\n\t\tjpop->Append(\"JavaWrappers.jar\");\n\n\t\tif ((cp = getenv(\"CLASSPATH\"))) {\n\t\t\tjpop->Append(sep);\n\t\t\tjpop->Append(cp);\n\t\t} // endif cp\n\n\t\tif (trace) {\n\t\t\thtrc(\"ClassPath=%s\\n\", ClassPath);\n\t\t\thtrc(\"CLASSPATH=%s\\n\", cp);\n\t\t\thtrc(\"%s\\n\", jpop->GetStr());\n\t\t} // endif trace\n\n\t\toptions[0].optionString = jpop->GetStr();\n#if N == 2\n\t\toptions[1].optionString = \"-Xcheck:jni\";\n#endif\n#if N == 3\n\t\toptions[1].optionString = \"-Xms256M\";\n\t\toptions[2].optionString = \"-Xmx512M\";\n#endif\n#if defined(_DEBUG)\n\t\tvm_args.version = JNI_VERSION_1_2;             // minimum Java version\n\t\trc = GetDefaultJavaVMInitArgs(&vm_args);\n#else\n\t\tvm_args.version = JNI_VERSION_1_6;             // minimum Java version\n#endif   // _DEBUG\n\t\tvm_args.nOptions = N;                          // number of options\n\t\tvm_args.options = options;\n\t\tvm_args.ignoreUnrecognized = false; // invalid options make the JVM init fail\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//=============== load and initialize Java VM and JNI interface =============\n\t\trc = CreateJavaVM(&jvm, (void**)&env, &vm_args);  // YES !!\n\t\tdelete options;    // we then no longer need the initialisation options.\n\n\t\tswitch (rc) {\n\t\t\tcase JNI_OK:\n\t\t\t\tstrcpy(g->Message, \"VM successfully created\");\n\t\t\t\tbrc = false;\n\t\t\t\tbreak;\n\t\t\tcase JNI_ERR:\n\t\t\t\tstrcpy(g->Message, \"Initialising JVM failed: unknown error\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EDETACHED:\n\t\t\t\tstrcpy(g->Message, \"Thread detached from the VM\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EVERSION:\n\t\t\t\tstrcpy(g->Message, \"JNI version error\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_ENOMEM:\n\t\t\t\tstrcpy(g->Message, \"Not enough memory\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EEXIST:\n\t\t\t\tstrcpy(g->Message, \"VM already created\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EINVAL:\n\t\t\t\tstrcpy(g->Message, \"Invalid arguments\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(g->Message, \"Unknown return code %d\", (int)rc);\n\t\t\t\tbreak;\n\t\t} // endswitch rc\n\n\t\tif (trace)\n\t\t\thtrc(\"%s\\n\", g->Message);\n\n\t\tif (brc)\n\t\t\treturn true;\n\n\t\t//=============== Display JVM version ===============\n\t\tjint ver = env->GetVersion();\n\t\tprintf(\"JVM Version %d.%d\\n\", ((ver >> 16) & 0x0f), (ver & 0x0f));\n\t} // endif rc\n\n\t// try to find the java wrapper class\n\tjdi = env->FindClass(m_Wrap);\n\n\tif (jdi == nullptr) {\n\t\tsprintf(g->Message, \"ERROR: class %s not found!\", m_Wrap);\n\t\treturn true;\n\t} // endif jdi\n\n#if 0\t\t// Suppressed because it does not make any usable change\n\tif (b && jpath && *jpath) {\n\t\t// Try to add that path the the jvm class path\n\t\tjmethodID alp = env->GetStaticMethodID(jdi, \"addLibraryPath\",\n\t\t\t\"(Ljava/lang/String;)I\");\n\n\t\tif (alp == nullptr) {\n\t\t\tenv->ExceptionDescribe();\n\t\t\tenv->ExceptionClear();\n\t\t} else {\n\t\t\tchar *msg;\n\t\t\tjstring path = env->NewStringUTF(jpath);\n\t\t\trc = env->CallStaticIntMethod(jdi, alp, path);\n\n\t\t\tif ((msg = Check(rc))) {\n\t\t\t\tstrcpy(g->Message, msg);\n\t\t\t\tenv->DeleteLocalRef(path);\n\t\t\t\treturn RC_FX;\n\t\t\t} else switch (rc) {\n\t\t\t\tcase JNI_OK:\n\t\t\t\t\tprintf(\"jpath added\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase JNI_EEXIST:\n\t\t\t\t\tprintf(\"jpath already exist\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase JNI_ERR:\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(g->Message, \"Error adding jpath\");\n\t\t\t\t\tenv->DeleteLocalRef(path);\n\t\t\t\t\treturn RC_FX;\n\t\t\t}\t// endswitch rc\n\n\t\t\tenv->DeleteLocalRef(path);\n\t\t}\t// endif alp\n\n\t}\t// endif jpath\n#endif // 0\n\n\t// if class found, continue\n\tjmethodID ctor = env->GetMethodID(jdi, \"<init>\", \"(Z)V\");\n\n\tif (ctor == nullptr) {\n\t\tsprintf(g->Message, \"ERROR: %s constructor not found!\", m_Wrap);\n\t\treturn true;\n\t} else\n\t\tjob = env->NewObject(jdi, ctor, jt);\n\n\tif (job == nullptr) {\n\t\tsprintf(g->Message, \"%s class object not constructed!\", m_Wrap);\n\t\treturn true;\n\t} // endif job\n\n\t// If the object is successfully constructed, \n\t// we can then search for the method we want to call, \n\t// and invoke it for the object:\n\terrid = env->GetMethodID(jdi, \"GetErrmsg\", \"()Ljava/lang/String;\");\n\n\tif (env->ExceptionCheck()) {\n\t\tstrcpy(g->Message, \"ERROR: method GetErrmsg() not found!\");\n\t\tenv->ExceptionDescribe();\n\t\tenv->ExceptionClear();\n\t\treturn true;\n\t} // endif Check\n\n\t/*********************************************************************/\n\t/*  Link a Fblock. This make possible to automatically close it      */\n\t/*  in case of error (throw).                                        */\n\t/*********************************************************************/\n\tPDBUSER dbuserp = (PDBUSER)g->Activityp->Aptr;\n\n\tfp = (PFBLOCK)PlugSubAlloc(g, NULL, sizeof(FBLOCK));\n\tfp->Type = TYPE_FB_JAVA;\n\tfp->Fname = NULL;\n\tfp->Next = dbuserp->Openlist;\n\tdbuserp->Openlist = fp;\n\tfp->Count = 1;\n\tfp->Length = 0;\n\tfp->Memory = NULL;\n\tfp->Mode = MODE_ANY;\n\tfp->File = this;\n\tfp->Handle = 0;\n\n\tm_Opened = true;\n\treturn false;\n} // end of Open\n\n/***********************************************************************/\n/*  Disconnect connection                                              */\n/***********************************************************************/\nvoid JAVAConn::Close()\n{\n\tjint rc;\n\n\tif (m_Connected) {\n\t\tjmethodID did = nullptr;\n\n\t\t// Could have been detached in case of join\n\t\trc = jvm->AttachCurrentThread((void**)&env, nullptr);\n\n\t\tif (gmID(m_G, did, DiscFunc, \"()I\"))\n\t\t\tprintf(\"%s\\n\", Msg);\n\t\telse if (Check(env->CallIntMethod(job, did)))\n\t\t\tprintf(\"%s: %s\\n\", DiscFunc, Msg);\n\n\t\tm_Connected = false;\n\t}\t// endif m_Connected\n\n\tif ((rc = jvm->DetachCurrentThread()) != JNI_OK)\n\t\tprintf(\"DetachCurrentThread: rc=%d\\n\", (int)rc);\n\n\tif (fp)\n\t\tfp->Count = 0;\n\n\tm_Opened = false;\n} // end of Close\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mycat.cc": "/* Copyright (C) MariaDB Corporation Ab\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; version 2 of the License.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301 USA */\n\n/*************** Mycat CC Program Source Code File (.CC) ***************/\n/* PROGRAM NAME: MYCAT                                                 */\n/* -------------                                                       */\n/*  Version 1.6                                                        */\n/*                                                                     */\n/*  Author: Olivier Bertrand                       2012 - 2017         */\n/*                                                                     */\n/* WHAT THIS PROGRAM DOES:                                             */\n/* -----------------------                                             */\n/*  This program are the DB description related routines.              */\n/***********************************************************************/\n\n/***********************************************************************/\n/*  Include relevant MariaDB header file.                              */\n/***********************************************************************/\n#include <my_config.h>\n\n#if defined(__WIN__)\n//#include <windows.h>\n//#include <sqlext.h>\n#elif defined(UNIX)\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#endif\n#define DONT_DEFINE_VOID\n//#include <mysql/plugin.h>\n#include \"handler.h\"\n#undef  OFFSET\n\n/***********************************************************************/\n/*  Include application header files                                   */\n/*                                                                     */\n/*  global.h     is header containing all global declarations.         */\n/*  plgdbsem.h   is header containing DB application declarations.     */\n/*  tabdos.h     is header containing TDBDOS classes declarations.     */\n/*  MYCAT.h      is header containing DB description declarations.     */\n/***********************************************************************/\n#if defined(UNIX)\n#include \"osutil.h\"\n#endif   // UNIX\n#include \"global.h\"\n#include \"plgdbsem.h\"\n//#include \"reldef.h\"\n#include \"xtable.h\"\n#include \"tabext.h\"\n#include \"tabcol.h\"\n#include \"filamtxt.h\"\n#include \"tabdos.h\"\n#include \"tabfmt.h\"\n#if defined(VCT_SUPPORT)\n#include \"tabvct.h\"\n#endif   // VCT_SUPPORT\n#include \"tabsys.h\"\n#if defined(__WIN__)\n#include \"tabmac.h\"\n#include \"tabwmi.h\"\n#endif   // __WIN__\n//#include \"tabtbl.h\"\n#include \"tabxcl.h\"\n#include \"tabtbl.h\"\n#include \"taboccur.h\"\n#include \"tabmul.h\"\n#include \"tabmysql.h\"\n#if defined(ODBC_SUPPORT)\n#define NODBC\n#include \"tabodbc.h\"\n#endif   // ODBC_SUPPORT\n#if defined(JDBC_SUPPORT)\n#define NJDBC\n#include \"tabjdbc.h\"\n#endif   // JDBC_SUPPORT\n#if defined(PIVOT_SUPPORT)\n#include \"tabpivot.h\"\n#endif   // PIVOT_SUPPORT\n#include \"tabvir.h\"\n#include \"tabjson.h\"\n#include \"ha_connect.h\"\n#if defined(XML_SUPPORT)\n#include \"tabxml.h\"\n#endif   // XML_SUPPORT\n#if defined(MONGO_SUPPORT)\n#include \"mongo.h\"\n#endif   // MONGO_SUPPORT\n#if defined(ZIP_SUPPORT)\n#include \"tabzip.h\"\n#endif   // ZIP_SUPPORT\n#include \"mycat.h\"\n\n/***********************************************************************/\n/*  Extern static variables.                                           */\n/***********************************************************************/\n#if defined(__WIN__)\nextern \"C\" HINSTANCE s_hModule;           // Saved module handle\n#endif  // !__WIN__\n\nPQRYRES OEMColumns(PGLOBAL g, PTOS topt, char *tab, char *db, bool info);\n\n/***********************************************************************/\n/*  Get the plugin directory.                                          */\n/***********************************************************************/\nchar *GetPluginDir(void)\n{\n  return opt_plugin_dir;\n} // end of GetPluginDir\n\n/***********************************************************************/\n/*  Get a unique enum table type ID.                                   */\n/***********************************************************************/\nTABTYPE GetTypeID(const char *type)\n  {\n  return (!type) ? TAB_UNDEF                      \n                 : (!stricmp(type, \"DOS\"))   ? TAB_DOS\n                 : (!stricmp(type, \"FIX\"))   ? TAB_FIX\n                 : (!stricmp(type, \"BIN\"))   ? TAB_BIN\n\t               : (!stricmp(type, \"CSV\"))   ? TAB_CSV\n                 : (!stricmp(type, \"FMT\"))   ? TAB_FMT\n                 : (!stricmp(type, \"DBF\"))   ? TAB_DBF\n#if defined(XML_SUPPORT)\n                 : (!stricmp(type, \"XML\"))   ? TAB_XML\n#endif\n                 : (!stricmp(type, \"INI\"))   ? TAB_INI\n                 : (!stricmp(type, \"VEC\"))   ? TAB_VEC\n#if defined(ODBC_SUPPORT)\n                 : (!stricmp(type, \"ODBC\"))  ? TAB_ODBC\n#endif\n#if defined(JDBC_SUPPORT)\n\t\t\t\t\t\t\t\t : (!stricmp(type, \"JDBC\"))  ? TAB_JDBC\n#endif\n\t\t\t\t\t\t\t\t : (!stricmp(type, \"MYSQL\")) ? TAB_MYSQL\n                 : (!stricmp(type, \"MYPRX\")) ? TAB_MYSQL\n                 : (!stricmp(type, \"DIR\"))   ? TAB_DIR\n#if defined(__WIN__)\n\t               : (!stricmp(type, \"MAC\"))   ? TAB_MAC\n\t               : (!stricmp(type, \"WMI\"))   ? TAB_WMI\n#endif\n\t               : (!stricmp(type, \"TBL\"))   ? TAB_TBL\n\t               : (!stricmp(type, \"XCOL\"))  ? TAB_XCL\n\t               : (!stricmp(type, \"OCCUR\")) ? TAB_OCCUR\n                 : (!stricmp(type, \"CATLG\")) ? TAB_PRX  // Legacy\n                 : (!stricmp(type, \"PROXY\")) ? TAB_PRX\n#if defined(PIVOT_SUPPORT)\n                 : (!stricmp(type, \"PIVOT\")) ? TAB_PIVOT\n#endif\n                 : (!stricmp(type, \"VIR\"))   ? TAB_VIR\n                 : (!stricmp(type, \"JSON\"))  ? TAB_JSON\n#if defined(ZIP_SUPPORT)\n\t\t\t\t\t\t\t\t : (!stricmp(type, \"ZIP\"))   ? TAB_ZIP\n#endif\n#if defined(MONGO_SUPPORT)\n\t\t             : (!stricmp(type, \"MONGO\")) ? TAB_MONGO\n#endif\n\t\t             : (!stricmp(type, \"OEM\"))   ? TAB_OEM : TAB_NIY;\n  } // end of GetTypeID\n\n/***********************************************************************/\n/*  Return true for table types based on file.                         */\n/***********************************************************************/\nbool IsFileType(TABTYPE type)\n  {\n  bool isfile;\n\n  switch (type) {                      \n    case TAB_DOS:\n    case TAB_FIX:\n    case TAB_BIN:\n\t  case TAB_CSV:\n    case TAB_FMT:\n    case TAB_DBF:\n    case TAB_XML:\n    case TAB_INI:\n    case TAB_VEC:\n    case TAB_JSON:\n//\tcase TAB_ZIP:\n      isfile= true;\n      break;\n    default:\n      isfile= false;\n      break;\n    } // endswitch type\n\n  return isfile;\n  } // end of IsFileType\n\n/***********************************************************************/\n/*  Return true for table types returning exact row count.             */\n/***********************************************************************/\nbool IsExactType(TABTYPE type)\n  {\n  bool exact;\n\n  switch (type) {                      \n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_DBF:\n//  case TAB_XML:     depends on Multiple || Xpand || Coltype\n//  case TAB_JSON:    depends on Multiple || Xpand || Coltype\n    case TAB_VEC:\n    case TAB_VIR:\n      exact= true;\n      break;\n    default:\n      exact= false;\n      break;\n    } // endswitch type\n\n  return exact;\n  } // end of IsExactType\n\n/***********************************************************************/\n/*  Return true for table types accepting null fields.                 */\n/***********************************************************************/\nbool IsTypeNullable(TABTYPE type)\n  {\n  bool nullable;\n\n  switch (type) {                      \n    case TAB_MAC:\n    case TAB_DIR:\n      nullable= false;\n      break;\n    default:\n      nullable= true;\n      break;\n    } // endswitch type\n\n  return nullable;\n  } // end of IsTypeNullable\n\n/***********************************************************************/\n/*  Return true for fixed record length tables.                        */\n/***********************************************************************/\nbool IsTypeFixed(TABTYPE type)\n  {\n  bool fix;\n\n  switch (type) {                      \n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_VEC:\n//  case TAB_DBF:         ???\n      fix= true;\n      break;\n    default:\n      fix= false;\n      break;\n    } // endswitch type\n\n  return fix;\n  } // end of IsTypeFixed\n\n/***********************************************************************/\n/*  Return true for table indexable by XINDEX.                         */\n/***********************************************************************/\nbool IsTypeIndexable(TABTYPE type)\n  {\n  bool idx;\n\n  switch (type) {                      \n    case TAB_DOS:\n    case TAB_CSV:\n    case TAB_FMT:\n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_VEC:\n    case TAB_DBF:\n    case TAB_JSON:\n      idx= true;\n      break;\n    default:\n      idx= false;\n      break;\n    } // endswitch type\n\n  return idx;\n  } // end of IsTypeIndexable\n\n/***********************************************************************/\n/*  Return index type: 0 NO, 1 XINDEX, 2 REMOTE.                       */\n/***********************************************************************/\nint GetIndexType(TABTYPE type)\n  {\n  int xtyp;\n\n  switch (type) {                      \n    case TAB_DOS:\n    case TAB_CSV:\n    case TAB_FMT:\n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_VEC:\n    case TAB_DBF:\n    case TAB_JSON:\n      xtyp= 1;\n      break;\n    case TAB_MYSQL:\n    case TAB_ODBC:\n\t\tcase TAB_JDBC:\n\t\tcase TAB_MONGO:\n\t\t\txtyp= 2;\n      break;\n    case TAB_VIR:\n      xtyp= 3;\n      break;\n    default:\n      xtyp= 0;\n      break;\n    } // endswitch type\n\n  return xtyp;\n  } // end of GetIndexType\n\n/***********************************************************************/\n/*  Get a unique enum catalog function ID.                             */\n/***********************************************************************/\nuint GetFuncID(const char *func)\n  {\n  uint fnc;\n\n  if (!func)\n    fnc= FNC_NO;\n  else if (!strnicmp(func, \"col\", 3))\n    fnc= FNC_COL;\n  else if (!strnicmp(func, \"tab\", 3))\n    fnc= FNC_TABLE;\n  else if (!stricmp(func, \"dsn\") ||\n           !strnicmp(func, \"datasource\", 10) ||\n           !strnicmp(func, \"source\", 6) ||\n           !strnicmp(func, \"sqldatasource\", 13))\n    fnc= FNC_DSN;\n  else if (!strnicmp(func, \"driver\", 6) ||\n           !strnicmp(func, \"sqldriver\", 9))\n    fnc= FNC_DRIVER;\n  else\n    fnc= FNC_NIY;\n\n  return fnc;\n  } // end of GetFuncID\n\n/***********************************************************************/\n/*  OEMColumn: Get table column info for an OEM table.                 */\n/***********************************************************************/\nPQRYRES OEMColumns(PGLOBAL g, PTOS topt, char *tab, char *db, bool info)\n  {\n  typedef PQRYRES (__stdcall *XCOLDEF) (PGLOBAL, void*, char*, char*, bool);\n  const char *module, *subtype;\n  char    c, soname[_MAX_PATH], getname[40] = \"Col\";\n#if defined(__WIN__)\n  HANDLE  hdll;               /* Handle to the external DLL            */\n#else   // !__WIN__\n  void   *hdll;               /* Handle for the loaded shared library  */\n#endif  // !__WIN__\n  XCOLDEF coldef = NULL;\n  PQRYRES qrp = NULL;\n\n  module = topt->module;\n  subtype = topt->subtype;\n\n  if (!module || !subtype)\n    return NULL;\n\n  /*********************************************************************/\n  /*  Ensure that the .dll doesn't have a path.                        */\n  /*  This is done to ensure that only approved dll from the system    */\n  /*  directories are used (to make this even remotely secure).        */\n  /*********************************************************************/\n  if (check_valid_path(module, strlen(module))) {\n    strcpy(g->Message, \"Module cannot contain a path\");\n    return NULL;\n  } else\n    PlugSetPath(soname, module, GetPluginDir());\n    \n  // The exported name is always in uppercase\n  for (int i = 0; ; i++) {\n    c = subtype[i];\n    getname[i + 3] = toupper(c);\n    if (!c) break;\n    } // endfor i\n\n#if defined(__WIN__)\n  // Load the Dll implementing the table\n  if (!(hdll = LoadLibrary(soname))) {\n    char  buf[256];\n    DWORD rc = GetLastError();\n\n    sprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n                  FORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n                  (LPTSTR)buf, sizeof(buf), NULL);\n    strcat(strcat(g->Message, \": \"), buf);\n    return NULL;\n    } // endif hDll\n\n  // Get the function returning an instance of the external DEF class\n  if (!(coldef = (XCOLDEF)GetProcAddress((HINSTANCE)hdll, getname))) {\n    sprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), getname);\n    FreeLibrary((HMODULE)hdll);\n    return NULL;\n    } // endif coldef\n#else   // !__WIN__\n  const char *error = NULL;\n\n  // Load the desired shared library\n  if (!(hdll = dlopen(soname, RTLD_LAZY))) {\n    error = dlerror();\n    sprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n    return NULL;\n    } // endif Hdll\n\n  // Get the function returning an instance of the external DEF class\n  if (!(coldef = (XCOLDEF)dlsym(hdll, getname))) {\n    error = dlerror();\n    sprintf(g->Message, MSG(GET_FUNC_ERR), getname, SVP(error));\n    dlclose(hdll);\n    return NULL;\n    } // endif coldef\n#endif  // !__WIN__\n\n  // Just in case the external Get function does not set error messages\n  sprintf(g->Message, \"Error getting column info from %s\", subtype);\n\n  // Get the table column definition\n  qrp = coldef(g, topt, tab, db, info);\n\n#if defined(__WIN__)\n  FreeLibrary((HMODULE)hdll);\n#else   // !__WIN__\n  dlclose(hdll);\n#endif  // !__WIN__\n\n  return qrp;\n  } // end of OEMColumns\n\n/* ------------------------- Class CATALOG --------------------------- */\n\n/***********************************************************************/\n/*  CATALOG Constructor.                                               */\n/***********************************************************************/\nCATALOG::CATALOG(void)\n  {\n#if defined(__WIN__)\n//DataPath= \".\\\\\";\n#else   // !__WIN__\n//DataPath= \"./\";\n#endif  // !__WIN__\n  memset(&Ctb, 0, sizeof(CURTAB));\n  Cbuf= NULL;\n  Cblen= 0;\n\tDefHuge= false;\n  } // end of CATALOG constructor\n\n/* -------------------------- Class MYCAT ---------------------------- */\n\n/***********************************************************************/\n/*  MYCAT Constructor.                                                 */\n/***********************************************************************/\nMYCAT::MYCAT(PHC hc) : CATALOG()\n  {\n\tHc= hc;\n  DefHuge= false;\n  } // end of MYCAT constructor\n\n/***********************************************************************/\n/*  Nothing to do for CONNECT.                                         */\n/***********************************************************************/\nvoid MYCAT::Reset(void)\n  {\n  } // end of Reset\n\n/***********************************************************************/\n/*  GetTableDesc: retrieve a table descriptor.                         */\n/*  Look for a table descriptor matching the name and type.            */\n/***********************************************************************/\nPRELDEF MYCAT::GetTableDesc(PGLOBAL g, PTABLE tablep,\n                                       LPCSTR type, PRELDEF *)\n  {\n\tif (trace)\n\t\tprintf(\"GetTableDesc: name=%s am=%s\\n\", tablep->GetName(), SVP(type));\n\n \t// If not specified get the type of this table\n  if (!type)\n    type= Hc->GetStringOption(\"Type\",\"*\");\n\n  return MakeTableDesc(g, tablep, type);\n  } // end of GetTableDesc\n\n/***********************************************************************/\n/*  MakeTableDesc: make a table/view description.                      */\n/*  Note: caller must check if name already exists before calling it.  */\n/***********************************************************************/\nPRELDEF MYCAT::MakeTableDesc(PGLOBAL g, PTABLE tablep, LPCSTR am)\n  {\n  TABTYPE tc;\n\tLPCSTR  name = (PSZ)PlugDup(g, tablep->GetName());\n\tLPCSTR  schema = (PSZ)PlugDup(g, tablep->GetSchema());\n  PRELDEF tdp= NULL;\n\n\tif (trace)\n\t\tprintf(\"MakeTableDesc: name=%s schema=%s am=%s\\n\",\n\t\t                       name, SVP(schema), SVP(am));\n\n  /*********************************************************************/\n  /*  Get a unique enum identifier for types.                          */\n  /*********************************************************************/\n  tc= GetTypeID(am);\n\n  switch (tc) {\n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_DBF:\n    case TAB_DOS: tdp= new(g) DOSDEF;   break;\n    case TAB_CSV:\n    case TAB_FMT: tdp= new(g) CSVDEF;   break;\n    case TAB_INI: tdp= new(g) INIDEF;   break;\n    case TAB_DIR: tdp= new(g) DIRDEF;   break;\n#if defined(XML_SUPPORT)\n    case TAB_XML: tdp= new(g) XMLDEF;   break;\n#endif   // XML_SUPPORT\n#if defined(VCT_SUPPORT)\n\t\tcase TAB_VEC: tdp = new(g) VCTDEF;  break;\n#endif   // VCT_SUPPORT\n#if defined(ODBC_SUPPORT)\n    case TAB_ODBC: tdp= new(g) ODBCDEF; break;\n#endif   // ODBC_SUPPORT\n#if defined(JDBC_SUPPORT)\n\t\tcase TAB_JDBC: tdp= new(g) JDBCDEF; break;\n#endif   // JDBC_SUPPORT\n#if defined(__WIN__)\n    case TAB_MAC: tdp= new(g) MACDEF;   break;\n    case TAB_WMI: tdp= new(g) WMIDEF;   break;\n#endif   // __WIN__\n    case TAB_OEM: tdp= new(g) OEMDEF;   break;\n\t  case TAB_TBL: tdp= new(g) TBLDEF;   break;\n\t  case TAB_XCL: tdp= new(g) XCLDEF;   break;\n\t  case TAB_PRX: tdp= new(g) PRXDEF;   break;\n\t\tcase TAB_OCCUR: tdp= new(g) OCCURDEF;\tbreak;\n\t\tcase TAB_MYSQL: tdp= new(g) MYSQLDEF;\tbreak;\n#if defined(PIVOT_SUPPORT)\n    case TAB_PIVOT: tdp= new(g) PIVOTDEF; break;\n#endif   // PIVOT_SUPPORT\n    case TAB_VIR: tdp= new(g) VIRDEF;   break;\n    case TAB_JSON: tdp= new(g) JSONDEF; break;\n#if defined(MONGO_SUPPORT)\n\t\tcase TAB_MONGO: tdp = new(g) MGODEF; break;\n#endif   // MONGO_SUPPORT\n#if defined(ZIP_SUPPORT)\n\t\tcase TAB_ZIP: tdp= new(g) ZIPDEF;   break;\n#endif   // ZIP_SUPPORT\n\t\tdefault:\n\t\t\tsprintf(g->Message, MSG(BAD_TABLE_TYPE), am, name);\n    } // endswitch\n\n  // Do make the table/view definition\n  if (tdp && tdp->Define(g, this, name, schema, am))\n    tdp= NULL;\n\n  return tdp;\n  } // end of MakeTableDesc\n\n/***********************************************************************/\n/*  Initialize a Table Description Block construction.                 */\n/***********************************************************************/\nPTDB MYCAT::GetTable(PGLOBAL g, PTABLE tablep, MODE mode, LPCSTR type)\n  {\n  PRELDEF tdp;\n  PTDB    tdbp= NULL;\n//  LPCSTR  name= tablep->GetName();\n\n\tif (trace)\n\t\tprintf(\"GetTableDB: name=%s\\n\", tablep->GetName());\n\n  // Look for the description of the requested table\n  tdp= GetTableDesc(g, tablep, type);\n\n  if (tdp) {\n\t\tif (trace)\n\t\t\tprintf(\"tdb=%p type=%s\\n\", tdp, tdp->GetType());\n\n\t\tif (tablep->GetSchema())\n\t\t\ttdp->Database = SetPath(g, tablep->GetSchema());\n\t\t\n    tdbp= tdp->GetTable(g, mode);\n\t\t} // endif tdp\n\n  if (tdbp) {\n\t\tif (trace)\n\t\t\tprintf(\"tdbp=%p name=%s amtype=%d\\n\", tdbp, tdbp->GetName(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttdbp->GetAmType());\n    tablep->SetTo_Tdb(tdbp);\n    tdbp->SetTable(tablep);\n    tdbp->SetMode(mode);\n    } // endif tdbp\n\n  return (tdbp);\n  } // end of GetTable\n\n/***********************************************************************/\n/*  ClearDB: Terminates Database usage.                                */\n/***********************************************************************/\nvoid MYCAT::ClearDB(PGLOBAL)\n  {\n  } // end of ClearDB\n\n/* ------------------------ End of MYCAT --------------------------- */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/reldef.cpp": "/************* RelDef CPP Program Source Code File (.CPP) **************/\n/* PROGRAM NAME: RELDEF                                                */\n/* -------------                                                       */\n/*  Version 1.6                                                        */\n/*                                                                     */\n/* COPYRIGHT:                                                          */\n/* ----------                                                          */\n/*  (C) Copyright to the author Olivier BERTRAND          2004-2016    */\n/*                                                                     */\n/* WHAT THIS PROGRAM DOES:                                             */\n/* -----------------------                                             */\n/*  This program are the DB definition related routines.               */\n/*                                                                     */\n/***********************************************************************/\n\n/***********************************************************************/\n/*  Include relevant MariaDB header file.                              */\n/***********************************************************************/\n#include \"my_global.h\"\n#if defined(__WIN__)\n#include <sqlext.h>\n#else\n#include <dlfcn.h>          // dlopen(), dlclose(), dlsym() ...\n#include \"osutil.h\"\n//#include \"sqlext.h\"\n#endif\n#include \"handler.h\"\n\n/***********************************************************************/\n/*  Include application header files                                   */\n/*                                                                     */\n/*  global.h     is header containing all global declarations.         */\n/*  plgdbsem.h   is header containing DB application declarations.     */\n/*  catalog.h    is header containing DB description declarations.     */\n/***********************************************************************/\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"reldef.h\"\n#include \"colblk.h\"\n#include \"tabcol.h\"\n#include \"filamap.h\"\n#include \"filamfix.h\"\n#if defined(VCT_SUPPORT)\n#include \"filamvct.h\"\n#endif   // VCT_SUPPORT\n#if defined(GZ_SUPPORT)\n#include \"filamgz.h\"\n#endif   // GZ_SUPPORT\n#include \"tabdos.h\"\n#include \"valblk.h\"\n#include \"tabmul.h\"\n#include \"ha_connect.h\"\n#include \"mycat.h\"\n\n#if !defined(__WIN__)\nextern handlerton *connect_hton;\n#endif   // !__WIN__\n\n/***********************************************************************/\n/*  External function.                                                 */\n/***********************************************************************/\nUSETEMP UseTemp(void);\nchar   *GetPluginDir(void);\n\n/* --------------------------- Class RELDEF -------------------------- */\n\n/***********************************************************************/\n/*  RELDEF Constructor.                                                */\n/***********************************************************************/\nRELDEF::RELDEF(void)\n  {\n  Next = NULL;\n  To_Cols = NULL;\n  Name = NULL;\n  Database = NULL;\n  Cat = NULL;\n  Hc = NULL;\n  } // end of RELDEF constructor\n\n/***********************************************************************/\n/*  This function return a pointer to the Table Option Struct.         */\n/***********************************************************************/\nPTOS RELDEF::GetTopt(void)\n\t{\n\treturn Hc->GetTableOptionStruct();\n\t} // end of GetTopt\n\n/***********************************************************************/\n/*  This function sets an integer table information.                   */\n/***********************************************************************/\nbool RELDEF::SetIntCatInfo(PCSZ what, int n)\n\t{\n\treturn Hc->SetIntegerOption(what, n);\n\t} // end of SetIntCatInfo\n\n/***********************************************************************/\n/*  This function returns integer table information.                   */\n/***********************************************************************/\nint RELDEF::GetIntCatInfo(PCSZ what, int idef)\n\t{\n\tint n= Hc->GetIntegerOption(what);\n\n\treturn (n == NO_IVAL) ? idef : n;\n\t} // end of GetIntCatInfo\n\n/***********************************************************************/\n/*  This function returns Boolean table information.                   */\n/***********************************************************************/\nbool RELDEF::GetBoolCatInfo(PCSZ what, bool bdef)\n\t{\n\tbool b= Hc->GetBooleanOption(what, bdef);\n\n\treturn b;\n\t} // end of GetBoolCatInfo\n\n/***********************************************************************/\n/*  This function returns size catalog information.                    */\n/***********************************************************************/\nint RELDEF::GetSizeCatInfo(PCSZ what, PCSZ sdef)\n\t{\n\tchar c;\n\tPCSZ s;\n  int  i, n= 0;\n\n\tif (!(s= Hc->GetStringOption(what)))\n\t\ts= sdef;\n\n\tif ((i= sscanf(s, \" %d %c \", &n, &c)) == 2)\n    switch (toupper(c)) {\n      case 'M':\n        n *= 1024;\n        // fall through\n      case 'K':\n        n *= 1024;\n      } // endswitch c\n\n  return n;\n} // end of GetSizeCatInfo\n\n/***********************************************************************/\n/*  This function sets char table information in buf.                  */\n/***********************************************************************/\nint RELDEF::GetCharCatInfo(PCSZ what, PCSZ sdef, char *buf, int size)\n\t{\n\tPCSZ s= Hc->GetStringOption(what);\n\n\tstrncpy(buf, ((s) ? s : sdef), size);\n\treturn size;\n\t} // end of GetCharCatInfo\n\n/***********************************************************************/\n/*  To be used by any TDB's.                                           */\n/***********************************************************************/\nbool RELDEF::Partitioned(void)\n\t{\n\treturn Hc->IsPartitioned();\n\t} // end of Partitioned\n\n/***********************************************************************/\n/*  This function returns string table information.                    */\n/*  Default parameter is \"*\" to get the handler default.               */\n/***********************************************************************/\nchar *RELDEF::GetStringCatInfo(PGLOBAL g, PCSZ what, PCSZ sdef)\n\t{\n\tchar *sval = NULL;\n\tPCSZ  name, s= Hc->GetStringOption(what, sdef);\n\t\n\tif (s) {\n    if (!Hc->IsPartitioned() ||\n        (stricmp(what, \"filename\") && stricmp(what, \"tabname\")\n                                   && stricmp(what, \"connect\")))\n\t\t  sval= PlugDup(g, s);\n    else\n      sval= (char*)s;\n\n  } else if (!stricmp(what, \"filename\")) {\n    // Return default file name\n\t\tPCSZ ftype= Hc->GetStringOption(\"Type\", \"*\");\n    int  i, n;\n\n    if (IsFileType(GetTypeID(ftype))) {\n      name= Hc->GetPartName();\n      sval= (char*)PlugSubAlloc(g, NULL, strlen(name) + 12);\n      strcat(strcpy(sval, name), \".\");\n      n= strlen(sval);\n  \n      // Fold ftype to lower case\n      for (i= 0; i < 12; i++)\n        if (!ftype[i]) {\n          sval[n+i]= 0;\n          break;\n        } else\n          sval[n+i]= tolower(ftype[i]);\n\n      } // endif FileType\n\n  } // endif s\n\n\treturn sval;\n\t}\t// end of GetStringCatInfo\n\n/* --------------------------- Class TABDEF -------------------------- */\n\n/***********************************************************************/\n/*  TABDEF Constructor.                                                */\n/***********************************************************************/\nTABDEF::TABDEF(void)\n  {\n  Schema = NULL;\n  Desc = NULL;\n  Catfunc = FNC_NO;\n  Card = 0;\n  Elemt = 0;\n  Sort = 0;\n  Multiple = 0;\n  Degree = 0;\n  Pseudo = 0;\n  Read_Only = false;\n  m_data_charset = NULL;\n  csname = NULL;\n  } // end of TABDEF constructor\n\n/***********************************************************************/\n/*  Define: initialize the table definition block from XDB file.       */\n/***********************************************************************/\nbool TABDEF::Define(PGLOBAL g, PCATLG cat, \n\t                  LPCSTR name, LPCSTR schema, LPCSTR am)\n  {\n  int   poff = 0;\n\n\tHc = ((MYCAT*)cat)->GetHandler();\n\tName = (PSZ)name;\n\tSchema = (PSZ)Hc->GetDBName(schema);\n  Cat = cat;\n  Catfunc = GetFuncID(GetStringCatInfo(g, \"Catfunc\", NULL));\n  Elemt = GetIntCatInfo(\"Elements\", 0);\n  Multiple = GetIntCatInfo(\"Multiple\", 0);\n  Degree = GetIntCatInfo(\"Degree\", 0);\n  Read_Only = GetBoolCatInfo(\"ReadOnly\", false);\n  const char *data_charset_name= GetStringCatInfo(g, \"Data_charset\", NULL);\n  m_data_charset= data_charset_name ?\n                  get_charset_by_csname(data_charset_name, MY_CS_PRIMARY, 0):\n                  NULL;\n  csname = GetStringCatInfo(g, \"Table_charset\", NULL);\n\n  // Get The column definitions\n  if ((poff = GetColCatInfo(g)) < 0)\n    return true;\n\n  // Do the definition of AM specific fields\n  return DefineAM(g, am, poff);\n  } // end of Define\n\n/***********************************************************************/\n/*  This function returns the database data path.                      */\n/***********************************************************************/\nPCSZ TABDEF::GetPath(void)\n  {\n  return (Database) ? Database : (Hc) ? Hc->GetDataPath() : NULL;\n  } // end of GetPath\n\n/***********************************************************************/\n/*  This function returns column table information.                    */\n/***********************************************************************/\nint TABDEF::GetColCatInfo(PGLOBAL g)\n\t{\n\tchar\t\t*type= GetStringCatInfo(g, \"Type\", \"*\");\n  char     c, fty, eds;\n\tint      i, n, loff, poff, nof, nlg;\n\tvoid    *field= NULL;\n  TABTYPE  tc;\n  PCOLDEF  cdp, lcdp= NULL, tocols= NULL;\n\tPCOLINFO pcf= (PCOLINFO)PlugSubAlloc(g, NULL, sizeof(COLINFO));\n\n  memset(pcf, 0, sizeof(COLINFO));\n\n  // Get a unique char identifier for type\n  tc= (Catfunc == FNC_NO) ? GetTypeID(type) : TAB_PRX;\n\n  // Take care of the column definitions\n\ti= poff= nof= nlg= 0;\n\n#if defined(__WIN__)\n\t// Offsets of HTML and DIR tables start from 0, DBF at 1\n\tloff= (tc == TAB_DBF) ? 1 : (tc == TAB_XML || tc == TAB_DIR) ? -1 : 0;\n#else   // !__WIN__\n\t// Offsets of HTML tables start from 0, DIR and DBF at 1\n\tloff = (tc == TAB_DBF || tc == TAB_DIR) ? 1 : (tc == TAB_XML) ? -1 : 0;\n#endif  // !__WIN__\n\n  while (true) {\n\t\t// Default Offset depends on table type\n\t\tswitch (tc) {\n      case TAB_DOS:\n      case TAB_FIX:\n      case TAB_BIN:\n      case TAB_VEC:\n      case TAB_DBF:\n        poff= loff + nof;\t\t\t\t // Default next offset\n\t\t\t\tnlg= MY_MAX(nlg, poff);\t\t // Default lrecl\n        break;\n      case TAB_CSV:\n      case TAB_FMT:\n\t\t\t\tnlg+= nof;\n      case TAB_DIR:\n      case TAB_XML:\n\t\t\t\tpoff= loff + (pcf->Flags & U_VIRTUAL ? 0 : 1);\n        break;\n      case TAB_INI:\n      case TAB_MAC:\n      case TAB_TBL:\n      case TAB_XCL:\n      case TAB_OCCUR:\n      case TAB_PRX:\n      case TAB_OEM:\n        poff = 0;      // Offset represents an independant flag\n        break;\n      default:         // VCT PLG ODBC JDBC MYSQL WMI...\n        poff = 0;\t\t\t // NA\n        break;\n\t\t\t} // endswitch tc\n\n//\t\tdo {\n\t\t\tfield= Hc->GetColumnOption(g, field, pcf);\n//    } while (field && (*pcf->Name =='*' /*|| pcf->Flags & U_VIRTUAL*/));\n\n\t\tif (tc == TAB_DBF && pcf->Type == TYPE_DATE && !pcf->Datefmt) {\n\t\t\t// DBF date format defaults to 'YYYMMDD'\n\t\t\tpcf->Datefmt= \"YYYYMMDD\";\n\t\t\tpcf->Length= 8;\n\t\t\t} // endif tc\n\n\t\tif (!field)\n\t\t\tbreak;\n\n    // Allocate the column description block\n    cdp= new(g) COLDEF;\n\n    if ((nof= cdp->Define(g, NULL, pcf, poff)) < 0)\n      return -1;\t\t\t\t\t\t // Error, probably unhandled type\n\t\telse\n\t\t\tloff= cdp->GetOffset();\n\n\t\tswitch (tc) {\n\t\t\tcase TAB_VEC:\n\t\t\t\tcdp->SetOffset(0);\t\t // Not to have shift\n\t\t\tcase TAB_BIN:\n\t\t\t\t// BIN/VEC are packed by default\n        if (nof) {\n\t\t\t\t\t// Field width is the internal representation width\n\t\t\t\t\t// that can also depend on the column format\n          fty = cdp->Decode ? 'C' : 'X';\n          eds = 0;\n          n = 0;\n\n          if (cdp->Fmt && !cdp->Decode) {\n            for (i = 0; cdp->Fmt[i]; i++) {\n              c = toupper(cdp->Fmt[i]);\n\n              if (isdigit(c))\n                n = (n * 10 + (c - '0'));\n              else if (c == 'L' || c == 'B' || c == 'H')\n                eds = c;\n              else\n                fty = c;\n\n              } // endfor i\n\n          } // endif Fmt\n\n          if (n)\n            nof = n;\n          else switch (fty) {\n\t\t\t\t\t\tcase 'X':\n              if (eds && IsTypeChar(cdp->Buf_Type))\n                nof = sizeof(longlong);\n              else\n                nof= cdp->Clen;\n\n              break;\n\t\t\t\t\t\tcase 'C':                         break;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tcase 'F': nof = sizeof(float);    break;\n\t\t\t\t\t\tcase 'I':\tnof = sizeof(int);      break;\n\t\t\t\t\t\tcase 'D':\tnof = sizeof(double);   break;\n\t\t\t\t\t\tcase 'S':\tnof = sizeof(short);    break;\n\t\t\t\t\t\tcase 'T':\tnof = sizeof(char);     break;\n\t\t\t\t\t\tcase 'G':\tnof = sizeof(longlong); break;\n\t\t\t\t\t\tdefault:  /* Wrong format */\n              sprintf(g->Message, \"Invalid format %c\", fty);\n              return -1;\n\t\t\t\t\t\t} // endswitch fty\n\n          } // endif nof\n\n      default:\n\t\t\t\tbreak;\n\t\t\t} // endswitch tc\n\n\t\tif (lcdp)\n\t    lcdp->SetNext(cdp);\n\t\telse\n\t\t\ttocols= cdp;\n\n\t\tlcdp= cdp;\n    i++;\n    } // endwhile\n\n  // Degree is the the number of defined columns (informational)\n  if (i != GetDegree())\n    SetDegree(i);\n\n\tif (GetDefType() == TYPE_AM_DOS) {\n\t\tint\t\t\tending, recln= 0;\n\n\t\t// Was commented because sometimes ending is 0 even when\n\t\t// not specified (for instance if quoted is specified)\n//\tif ((ending= Hc->GetIntegerOption(\"Ending\")) < 0) {\n\t\tif ((ending= Hc->GetIntegerOption(\"Ending\")) <= 0) {\n      ending= (tc == TAB_BIN || tc == TAB_VEC) ? 0 : CRLF;\n\t\t\tHc->SetIntegerOption(\"Ending\", ending);\n\t\t\t} // endif ending\n\n\t\t// Calculate the default record size\n\t\tswitch (tc) {\n      case TAB_FIX:\n      case TAB_BIN:\n        recln= nlg + ending;     // + length of line ending\n        break;\n      case TAB_VEC:\n        recln= nlg;\n\t\n//      if ((k= (pak < 0) ? 8 : pak) > 1)\n          // See above for detailed comment\n          // Round up lrecl to multiple of 8 or pak\n//        recln= ((recln + k - 1) / k) * k;\n\t\n        break;\n      case TAB_DOS:\n      case TAB_DBF:\n        recln= nlg;\n        break;\n      case TAB_CSV:\n      case TAB_FMT:\n        // The number of separators (assuming an extra one can exist)\n//      recln= poff * ((qotd) ? 3 : 1);\t to be investigated\n\t\t\t\trecln= nlg + poff * 3;     // To be safe\n      default:\n        break;\n      } // endswitch tc\n\n\t\t// lrecl must be at least recln to avoid buffer overflow\n\t\tif (trace)\n\t\t\thtrc(\"Lrecl: Calculated=%d defined=%d\\n\", \n\t\t\t  recln, Hc->GetIntegerOption(\"Lrecl\"));\n\n\t\trecln = MY_MAX(recln, Hc->GetIntegerOption(\"Lrecl\"));\n\t\tHc->SetIntegerOption(\"Lrecl\", recln);\n\t\t((PDOSDEF)this)->SetLrecl(recln);\n\t\t} // endif Lrecl\n\n\t// Attach the column definition to the tabdef\n\tSetCols(tocols);\n\treturn poff;\n\t} // end of GetColCatInfo\n\n/***********************************************************************/\n/*  SetIndexInfo: retrieve index description from the table structure. */\n/***********************************************************************/\nvoid TABDEF::SetIndexInfo(void)\n  {\n  // Attach new index(es)\n  SetIndx(Hc->GetIndexInfo());\n  } // end of SetIndexInfo\n\n/* --------------------------- Class OEMDEF -------------------------- */\n\n/***********************************************************************/\n/*  GetXdef: get the external TABDEF from OEM module.                  */\n/***********************************************************************/\nPTABDEF OEMDEF::GetXdef(PGLOBAL g)\n  {\n  typedef PTABDEF (__stdcall *XGETDEF) (PGLOBAL, void *);\n  char    c, soname[_MAX_PATH], getname[40] = \"Get\";\n  PTABDEF xdefp;\n  XGETDEF getdef = NULL;\n  PCATLG  cat = Cat;\n\n  /*********************************************************************/\n  /*  Ensure that the .dll doesn't have a path.                        */\n  /*  This is done to ensure that only approved dll from the system    */\n  /*  directories are used (to make this even remotely secure).        */\n  /*********************************************************************/\n  if (check_valid_path(Module, strlen(Module))) {\n    strcpy(g->Message, \"Module cannot contain a path\");\n    return NULL;\n  } else\n    PlugSetPath(soname, Module, GetPluginDir());\n    \n#if defined(__WIN__)\n  // Is the DLL already loaded?\n  if (!Hdll && !(Hdll = GetModuleHandle(soname)))\n    // No, load the Dll implementing the function\n    if (!(Hdll = LoadLibrary(soname))) {\n      char  buf[256];\n      DWORD rc = GetLastError();\n\n      sprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n      FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n                    FORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n                    (LPTSTR)buf, sizeof(buf), NULL);\n      strcat(strcat(g->Message, \": \"), buf);\n      return NULL;\n      } // endif hDll\n\n  // The exported name is always in uppercase\n  for (int i = 0; ; i++) {\n    c = Subtype[i];\n    getname[i + 3] = toupper(c);\n    if (!c) break;\n    } // endfor i\n\n  // Get the function returning an instance of the external DEF class\n  if (!(getdef = (XGETDEF)GetProcAddress((HINSTANCE)Hdll, getname))) {\n    sprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), getname);\n    FreeLibrary((HMODULE)Hdll);\n    return NULL;\n    } // endif getdef\n#else   // !__WIN__\n  const char *error = NULL;\n    \n#if 0  // Don't know what all this stuff does\n\tDl_info dl_info;\n\n\t// The OEM lib must retrieve exported CONNECT variables\n  if (dladdr(&connect_hton, &dl_info)) {\n    if (dlopen(dl_info.dli_fname, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL) == 0) {\n      error = dlerror();\n      sprintf(g->Message, \"dlopen failed: %s, OEM not supported\", SVP(error));\n      return NULL;\n      } // endif dlopen\n    \n  } else {\n    error = dlerror();\n    sprintf(g->Message, \"dladdr failed: %s, OEM not supported\", SVP(error));\n    return NULL;\n  } // endif dladdr\n#endif // 0\n\n  // Is the library already loaded?\n  if (!Hdll && !(Hdll = dlopen(soname, RTLD_NOLOAD)))\n    // Load the desired shared library\n    if (!(Hdll = dlopen(soname, RTLD_LAZY))) {\n      error = dlerror();\n      sprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n      return NULL;\n      } // endif Hdll\n\n  // The exported name is always in uppercase\n  for (int i = 0; ; i++) {\n    c = Subtype[i];\n    getname[i + 3] = toupper(c);\n    if (!c) break;\n    } // endfor i\n\n  // Get the function returning an instance of the external DEF class\n  if (!(getdef = (XGETDEF)dlsym(Hdll, getname))) {\n    error = dlerror();\n    sprintf(g->Message, MSG(GET_FUNC_ERR), getname, SVP(error));\n    dlclose(Hdll);\n    return NULL;\n    } // endif getdef\n#endif  // !__WIN__\n\n  // Just in case the external Get function does not set error messages\n  sprintf(g->Message, MSG(DEF_ALLOC_ERROR), Subtype);\n\n  // Get the table definition block\n  if (!(xdefp = getdef(g, NULL)))\n    return NULL;\n\n  // Have the external class do its complete definition\n  if (!cat->Cbuf) {\n    // Suballocate a temporary buffer for the entire column section\n    cat->Cblen = GetSizeCatInfo(\"Colsize\", \"8K\");\n    cat->Cbuf = (char*)PlugSubAlloc(g, NULL, cat->Cblen);\n    } // endif Cbuf\n\n  // Here \"OEM\" should be replace by a more useful value\n  if (xdefp->Define(g, cat, Name, Schema, \"OEM\"))\n    return NULL;\n\n  // Ok, return external block\n  return xdefp;\n  } // end of GetXdef\n\n#if 0\n/***********************************************************************/\n/*  DeleteTableFile: Delete an OEM table file if applicable.           */\n/***********************************************************************/\nbool OEMDEF::DeleteTableFile(PGLOBAL g)\n  {\n  if (!Pxdef)\n    Pxdef = GetXdef(g);\n\n  return (Pxdef) ? Pxdef->DeleteTableFile(g) : true;\n  } // end of DeleteTableFile\n#endif // 0\n\n/***********************************************************************/\n/*  Define: initialize the table definition block from XDB file.       */\n/***********************************************************************/\nbool OEMDEF::DefineAM(PGLOBAL g, LPCSTR, int)\n  {\n  Module = GetStringCatInfo(g, \"Module\", \"\");\n  Subtype = GetStringCatInfo(g, \"Subtype\", Module);\n\n  if (!*Module)\n    Module = Subtype;\n\n  char *desc = (char*)PlugSubAlloc(g, NULL, strlen(Module)\n                                          + strlen(Subtype) + 3);\n  sprintf(desc, \"%s(%s)\", Module, Subtype);\n\tDesc = desc;\n  return false;\n  } // end of DefineAM\n\n/***********************************************************************/\n/*  GetTable: makes a new Table Description Block.                     */\n/***********************************************************************/\nPTDB OEMDEF::GetTable(PGLOBAL g, MODE mode)\n  {\n  RECFM rfm;\n  PTDB  tdbp = NULL;\n\n  // If define block not here yet, get it now\n  if (!Pxdef && !(Pxdef = GetXdef(g)))\n    return NULL;            // Error\n\n  /*********************************************************************/\n  /*  Allocate a TDB of the proper type.                               */\n  /*  Column blocks will be allocated only when needed.                */\n  /*********************************************************************/\n  if (!(tdbp = Pxdef->GetTable(g, mode)))\n    return NULL;\n  else\n    rfm = tdbp->GetFtype();\n\n  if (rfm == RECFM_NAF)\n    return tdbp;\n  else if (rfm == RECFM_OEM) {\n    if (Multiple)\n      tdbp = new(g) TDBMUL(tdbp);       // No block optimization yet\n\n    return tdbp;\n    } // endif OEM\n\n  /*********************************************************************/\n  /*  The OEM table is based on a file type (currently DOS+ only)      */\n  /*********************************************************************/\n  assert (rfm == RECFM_VAR || rfm == RECFM_FIX ||\n          rfm == RECFM_BIN || rfm == RECFM_VCT);\n\n  PTXF    txfp = NULL;\n  PDOSDEF defp = (PDOSDEF)Pxdef;\n  bool    map = defp->Mapped && mode != MODE_INSERT &&\n                !(UseTemp() == TMP_FORCE &&\n                (mode == MODE_UPDATE || mode == MODE_DELETE));\n  int     cmpr = defp->Compressed;\n\n  /*********************************************************************/\n  /*  Allocate table and file processing class of the proper type.     */\n  /*  Column blocks will be allocated only when needed.                */\n  /*********************************************************************/\n  if (!((PTDBDOS)tdbp)->GetTxfp()) {\n    if (cmpr) {\n#if defined(GZ_SUPPORT)\n      if (cmpr == 1)\n        txfp = new(g) GZFAM(defp);\n      else\n        txfp = new(g) ZLBFAM(defp);\n#else   // !GZ_SUPPORT\n      strcpy(g->Message, \"Compress not supported\");\n      return NULL;\n#endif  // !GZ_SUPPORT\n    } else if (rfm == RECFM_VAR) {\n      if (map)\n        txfp = new(g) MAPFAM(defp);\n      else\n        txfp = new(g) DOSFAM(defp);\n\n    } else if (rfm == RECFM_FIX || rfm == RECFM_BIN) {\n      if (map)\n        txfp = new(g) MPXFAM(defp);\n      else\n        txfp = new(g) FIXFAM(defp);\n    } else if (rfm == RECFM_VCT) {\n#if defined(VCT_SUPPORT)\n\t\t\tassert(Pxdef->GetDefType() == TYPE_AM_VCT);\n\n      if (map)\n        txfp = new(g) VCMFAM((PVCTDEF)defp);\n      else\n        txfp = new(g) VCTFAM((PVCTDEF)defp);\n#else   // !VCT_SUPPORT\n\t\t\tstrcpy(g->Message, \"VCT no more supported\");\n\t\t\treturn NULL;\n#endif  // !VCT_SUPPORT\n\t\t} // endif's\n\n    ((PTDBDOS)tdbp)->SetTxfp(txfp);\n    } // endif Txfp\n\n  if (Multiple)\n    tdbp = new(g) TDBMUL(tdbp);\n\n  return tdbp;\n  } // end of GetTable\n\n/* --------------------------- Class COLCRT -------------------------- */\n\n/***********************************************************************/\n/*  COLCRT Constructors.                                               */\n/***********************************************************************/\nCOLCRT::COLCRT(PSZ name)\n  {\n  Next = NULL;\n  Name = name;\n  Desc = NULL;\n  Decode = NULL;\n  Fmt = NULL;\n  Offset = -1;\n  Long = -1;\n  Precision = -1;\n  Freq = -1;\n  Key = -1;\n  Scale = -1;\n  Opt = -1;\n  DataType = '*';\n  } // end of COLCRT constructor for table creation\n\nCOLCRT::COLCRT(void)\n  {\n  Next = NULL;\n  Name = NULL;\n  Desc = NULL;\n  Decode = NULL;\n  Fmt = NULL;\n  Offset = 0;\n  Long = 0;\n  Precision = 0;\n  Freq = 0;\n  Key = 0;\n  Scale = 0;\n  Opt = 0;\n  DataType = '*';\n  } // end of COLCRT constructor for table & view definition\n\n/* --------------------------- Class COLDEF -------------------------- */\n\n/***********************************************************************/\n/*  COLDEF Constructor.                                                */\n/***********************************************************************/\nCOLDEF::COLDEF(void) : COLCRT()\n  {\n  To_Min = NULL;\n  To_Max = NULL;\n  To_Pos = NULL;\n  Xdb2 = FALSE;\n  To_Bmap = NULL;\n  To_Dval = NULL;\n  Ndv = 0;\n  Nbm = 0;\n  Buf_Type = TYPE_ERROR;\n  Clen = 0;\n  Poff = 0;\n  memset(&F, 0, sizeof(FORMAT));\n  Flags = 0;\n  } // end of COLDEF constructor\n\n/***********************************************************************/\n/*  Define: initialize a column definition from a COLINFO structure.   */\n/***********************************************************************/\nint COLDEF::Define(PGLOBAL g, void *, PCOLINFO cfp, int poff)\n  {\n  Name = (PSZ)PlugDup(g, cfp->Name);\n\n  if (!(cfp->Flags & U_SPECIAL)) {\n    Poff = poff;\n    Buf_Type = cfp->Type;\n\n    if ((Clen = GetTypeSize(Buf_Type, cfp->Length)) <= 0) {\n      sprintf(g->Message, MSG(BAD_COL_TYPE), GetTypeName(Buf_Type), Name);\n      return -1;\n      } // endswitch\n\n    strcpy(F.Type, GetFormatType(Buf_Type));\n    F.Length = cfp->Length;\n    F.Prec = cfp->Scale;\n    Offset = (cfp->Offset < 0) ? poff : cfp->Offset;\n    Precision = cfp->Precision;\n    Scale = cfp->Scale;\n    Long = cfp->Length;\n    Opt = cfp->Opt;\n    Key = cfp->Key;\n    Freq = cfp->Freq;\n\n    if (cfp->Remark && *cfp->Remark)\n      Desc = (PSZ)PlugDup(g, cfp->Remark);\n\n    if (cfp->Datefmt)\n      Decode = (PSZ)PlugDup(g, cfp->Datefmt);\n\n  } else\n    Offset = poff;\n\n  if (cfp->Fieldfmt)\n    Fmt = (PSZ)PlugDup(g, cfp->Fieldfmt);\n\n  Flags = cfp->Flags;\n  return (Flags & (U_VIRTUAL|U_SPECIAL)) ? 0 : Long;\n  } // end of Define\n\n/* ------------------------- End of RelDef --------------------------- */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/hatoku_hton.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:\n/* -*- mode: C; c-basic-offset: 4 -*- */\n#ident \"$Id$\"\n/*======\nThis file is part of TokuDB\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    TokuDBis is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    TokuDB is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with TokuDB.  If not, see <http://www.gnu.org/licenses/>.\n\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n#include \"hatoku_hton.h\"\n\n#define TOKU_METADB_NAME \"tokudb_meta\"\n\ntypedef struct savepoint_info {\n    DB_TXN* txn;\n    tokudb_trx_data* trx;\n    bool in_sub_stmt;\n} *SP_INFO, SP_INFO_T;\n\nstatic handler* tokudb_create_handler(\n    handlerton* hton,\n    TABLE_SHARE* table,\n    MEM_ROOT* mem_root);\n\nstatic void tokudb_print_error(\n    const DB_ENV* db_env,\n    const char* db_errpfx,\n    const char* buffer);\nstatic void tokudb_cleanup_log_files(void);\nstatic int tokudb_end(handlerton* hton, ha_panic_function type);\nstatic bool tokudb_flush_logs(handlerton* hton);\nstatic bool tokudb_show_status(\n    handlerton* hton,\n    THD* thd,\n    stat_print_fn* print,\n    enum ha_stat_type);\n#if TOKU_INCLUDE_HANDLERTON_HANDLE_FATAL_SIGNAL\nstatic void tokudb_handle_fatal_signal(handlerton* hton, THD* thd, int sig);\n#endif\nstatic int tokudb_close_connection(handlerton* hton, THD* thd);\nstatic void tokudb_kill_connection(handlerton *hton, THD *thd, enum thd_kill_levels level);\nstatic int tokudb_commit(handlerton* hton, THD* thd, bool all);\nstatic int tokudb_rollback(handlerton* hton, THD* thd, bool all);\n#if TOKU_INCLUDE_XA\nstatic int tokudb_xa_prepare(handlerton* hton, THD* thd, bool all);\nstatic int tokudb_xa_recover(handlerton* hton, XID* xid_list, uint len);\nstatic int tokudb_commit_by_xid(handlerton* hton, XID* xid);\nstatic int tokudb_rollback_by_xid(handlerton* hton, XID* xid);\n#endif\n\nstatic int tokudb_rollback_to_savepoint(\n    handlerton* hton,\n    THD* thd,\n    void* savepoint);\nstatic int tokudb_savepoint(handlerton* hton, THD* thd, void* savepoint);\nstatic int tokudb_release_savepoint(\n    handlerton* hton,\n    THD* thd,\n    void* savepoint);\n#if 100000 <= MYSQL_VERSION_ID\nstatic int tokudb_discover_table(handlerton *hton, THD* thd, TABLE_SHARE *ts);\nstatic int tokudb_discover_table_existence(\n    handlerton* hton,\n    const char* db,\n    const char* name);\n#endif\nstatic int tokudb_discover(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    uchar** frmblob,\n    size_t* frmlen);\nstatic int tokudb_discover2(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    bool translate_name,\n    uchar** frmblob,\n    size_t* frmlen);\nstatic int tokudb_discover3(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    char* path,\n    uchar** frmblob,\n    size_t* frmlen);\nhandlerton* tokudb_hton;\n\nconst char* ha_tokudb_ext = \".tokudb\";\nDB_ENV* db_env;\n\n#if TOKU_THDVAR_MEMALLOC_BUG\nstatic tokudb::thread::mutex_t tokudb_map_mutex;\nstatic TREE tokudb_map;\nstruct tokudb_map_pair {\n    THD* thd;\n    char *last_lock_timeout;\n};\n#if 50500 <= MYSQL_VERSION_ID && MYSQL_VERSION_ID <= 50599\nstatic int tokudb_map_pair_cmp(void *custom_arg, const void *a, const void *b) {\n#else\nstatic int tokudb_map_pair_cmp(\n    const void* custom_arg,\n    const void* a,\n    const void* b) {\n#endif\n\n    const struct tokudb_map_pair *a_key = (const struct tokudb_map_pair *) a;\n    const struct tokudb_map_pair *b_key = (const struct tokudb_map_pair *) b;\n    if (a_key->thd < b_key->thd)\n        return -1;\n    else if (a_key->thd > b_key->thd)\n        return +1;\n    else\n        return 0;\n};\n#endif\n\nstatic PARTITIONED_COUNTER tokudb_primary_key_bytes_inserted;\nvoid toku_hton_update_primary_key_bytes_inserted(uint64_t row_size) {\n    increment_partitioned_counter(tokudb_primary_key_bytes_inserted, row_size);\n}\n\nstatic void tokudb_lock_timeout_callback(\n    DB* db,\n    uint64_t requesting_txnid,\n    const DBT* left_key,\n    const DBT* right_key,\n    uint64_t blocking_txnid);\n\nstatic void tokudb_lock_wait_needed_callback(\n    void* arg,\n    uint64_t requesting_txnid,\n    uint64_t blocking_txnid);\n\n#define ASSERT_MSGLEN 1024\n\nvoid toku_hton_assert_fail(\n    const char* expr_as_string,\n    const char* fun,\n    const char* file,\n    int line,\n    int caller_errno) {\n\n    char msg[ASSERT_MSGLEN];\n    if (db_env) {\n        snprintf(msg, ASSERT_MSGLEN, \"Handlerton: %s \", expr_as_string);\n        db_env->crash(db_env, msg, fun, file, line,caller_errno);\n    } else {\n        snprintf(\n            msg,\n            ASSERT_MSGLEN,\n            \"Handlerton assertion failed, no env, %s, %d, %s, %s (errno=%d)\\n\",\n            file,\n            line,\n            fun,\n            expr_as_string,\n            caller_errno);\n        perror(msg);\n        fflush(stderr);\n    }\n    abort();\n}\n\n//my_bool tokudb_shared_data = false;\nstatic uint32_t tokudb_init_flags = \n    DB_CREATE | DB_THREAD | DB_PRIVATE | \n    DB_INIT_LOCK | \n    DB_INIT_MPOOL |\n    DB_INIT_TXN | \n    DB_INIT_LOG |\n    DB_RECOVER;\nstatic uint32_t tokudb_env_flags = 0;\n// static uint32_t tokudb_lock_type = DB_LOCK_DEFAULT;\n// static ulong tokudb_log_buffer_size = 0;\n// static ulong tokudb_log_file_size = 0;\nstatic char* tokudb_home;\n// static long tokudb_lock_scan_time = 0;\n// static ulong tokudb_region_size = 0;\n// static ulong tokudb_cache_parts = 1;\nconst char* tokudb_hton_name = \"TokuDB\";\n\n#if defined(_WIN32)\nextern \"C\" {\n#include \"ydb.h\"\n}\n#endif\n\n// A flag set if the handlerton is in an initialized, usable state,\n// plus a reader-write lock to protect it without serializing reads.\n// Since we don't have static initializers for the opaque rwlock type,\n// use constructor and destructor functions to create and destroy\n// the lock before and after main(), respectively.\nint tokudb_hton_initialized;\ntokudb::thread::rwlock_t tokudb_hton_initialized_lock;\n\nstatic SHOW_VAR *toku_global_status_variables = NULL;\nstatic uint64_t toku_global_status_max_rows;\nstatic TOKU_ENGINE_STATUS_ROW_S* toku_global_status_rows = NULL;\n\nstatic void handle_ydb_error(int error) {\n    switch (error) {\n    case TOKUDB_HUGE_PAGES_ENABLED:\n        sql_print_error(\"************************************************************\");\n        sql_print_error(\"                                                            \");\n        sql_print_error(\"                        @@@@@@@@@@@                         \");\n        sql_print_error(\"                      @@'         '@@                       \");\n        sql_print_error(\"                     @@    _     _  @@                      \");\n        sql_print_error(\"                     |    (.)   (.)  |                      \");\n        sql_print_error(\"                     |             ` |                      \");\n        sql_print_error(\"                     |        >    ' |                      \");\n        sql_print_error(\"                     |     .----.    |                      \");\n        sql_print_error(\"                     ..   |.----.|  ..                      \");\n        sql_print_error(\"                      ..  '      ' ..                       \");\n        sql_print_error(\"                        .._______,.                         \");\n        sql_print_error(\"                                                            \");\n        sql_print_error(\"%s will not run with transparent huge pages enabled.        \", tokudb_hton_name);\n        sql_print_error(\"Please disable them to continue.                            \");\n        sql_print_error(\"(echo never > /sys/kernel/mm/transparent_hugepage/enabled)  \");\n        sql_print_error(\"                                                            \");\n        sql_print_error(\"************************************************************\");\n        break;\n    case TOKUDB_UPGRADE_FAILURE:\n        sql_print_error(\n            \"%s upgrade failed. A clean shutdown of the previous version is \"\n            \"required.\",\n            tokudb_hton_name);\n        break;\n    default:\n        sql_print_error(\"%s unknown error %d\", tokudb_hton_name, error);\n        break;\n    }\n}\n\nstatic int tokudb_set_product_name(void) {\n    size_t n = strlen(tokudb_hton_name);\n    char tokudb_product_name[n+1];\n    memset(tokudb_product_name, 0, sizeof tokudb_product_name);\n    for (size_t i = 0; i < n; i++)\n        tokudb_product_name[i] = tolower(tokudb_hton_name[i]);\n    int r = db_env_set_toku_product_name(tokudb_product_name);\n    return r;\n}\n\nstatic int tokudb_init_func(void *p) {\n    TOKUDB_DBUG_ENTER(\"%p\", p);\n    int r;\n\n    // 3938: lock the handlerton's initialized status flag for writing\n    tokudb_hton_initialized_lock.lock_write();\n\n    db_env = NULL;\n    tokudb_hton = (handlerton *) p;\n\n    if (tokudb::sysvars::check_jemalloc) {\n        typedef int (*mallctl_type)(\n            const char*,\n            void*,\n            size_t*,\n            void*,\n            size_t);\n        mallctl_type mallctl_func;\n        mallctl_func= (mallctl_type)dlsym(RTLD_DEFAULT, \"mallctl\");\n        if (!mallctl_func) {\n            sql_print_error(\n                \"%s is not initialized because jemalloc is not loaded\",\n                tokudb_hton_name);\n            goto error;\n        }\n        char *ver;\n        size_t len = sizeof(ver);\n        mallctl_func(\"version\", &ver, &len, NULL, 0);\n        /* jemalloc 2.2.5 crashes mysql-test */\n        if (strcmp(ver, \"2.3.\") < 0) {\n            sql_print_error(\n                \"%s is not initialized because jemalloc is older than 2.3.0\",\n                tokudb_hton_name);\n            goto error;\n        }\n    }\n\n    r = tokudb_set_product_name();\n    if (r) {\n        sql_print_error(\n            \"%s can not set product name error %d\",\n            tokudb_hton_name,\n            r);\n        goto error;\n    }\n\n    TOKUDB_SHARE::static_init();\n    tokudb::background::initialize();\n\n    tokudb_hton->state = SHOW_OPTION_YES;\n    // tokudb_hton->flags= HTON_CAN_RECREATE;  // QQQ this came from skeleton\n    tokudb_hton->flags = HTON_CLOSE_CURSORS_AT_COMMIT | HTON_SUPPORTS_EXTENDED_KEYS;\n\n#if defined(TOKU_INCLUDE_EXTENDED_KEYS) && TOKU_INCLUDE_EXTENDED_KEYS\n#if defined(HTON_SUPPORTS_EXTENDED_KEYS)\n    tokudb_hton->flags |= HTON_SUPPORTS_EXTENDED_KEYS;\n#endif\n#if defined(HTON_EXTENDED_KEYS)\n    tokudb_hton->flags |= HTON_EXTENDED_KEYS;\n#endif\n#endif\n#if defined(HTON_SUPPORTS_CLUSTERED_KEYS)\n    tokudb_hton->flags |= HTON_SUPPORTS_CLUSTERED_KEYS;\n#endif\n\n#if defined(TOKU_USE_DB_TYPE_TOKUDB) && TOKU_USE_DB_TYPE_TOKUDB\n    tokudb_hton->db_type = DB_TYPE_TOKUDB;\n#elif defined(TOKU_USE_DB_TYPE_UNKNOWN) && TOKU_USE_DB_TYPE_UNKNOWN\n    tokudb_hton->db_type = DB_TYPE_UNKNOWN;\n#else\n#error\n#endif\n\n    tokudb_hton->create = tokudb_create_handler;\n    tokudb_hton->close_connection = tokudb_close_connection;\n    tokudb_hton->kill_query = tokudb_kill_connection;\n\n    tokudb_hton->savepoint_offset = sizeof(SP_INFO_T);\n    tokudb_hton->savepoint_set = tokudb_savepoint;\n    tokudb_hton->savepoint_rollback = tokudb_rollback_to_savepoint;\n    tokudb_hton->savepoint_release = tokudb_release_savepoint;\n\n#if 100000 <= MYSQL_VERSION_ID\n    tokudb_hton->discover_table = tokudb_discover_table;\n    tokudb_hton->discover_table_existence = tokudb_discover_table_existence;\n#else\n    tokudb_hton->discover = tokudb_discover;\n#if defined(MYSQL_HANDLERTON_INCLUDE_DISCOVER2)\n    tokudb_hton->discover2 = tokudb_discover2;\n#endif\n#endif\n    tokudb_hton->commit = tokudb_commit;\n    tokudb_hton->rollback = tokudb_rollback;\n#if TOKU_INCLUDE_XA\n    tokudb_hton->prepare = tokudb_xa_prepare;\n    tokudb_hton->recover = tokudb_xa_recover;\n    tokudb_hton->commit_by_xid = tokudb_commit_by_xid;\n    tokudb_hton->rollback_by_xid = tokudb_rollback_by_xid;\n#endif\n\n    tokudb_hton->panic = tokudb_end;\n    tokudb_hton->flush_logs = tokudb_flush_logs;\n    tokudb_hton->show_status = tokudb_show_status;\n#if TOKU_INCLUDE_HANDLERTON_HANDLE_FATAL_SIGNAL\n    tokudb_hton->handle_fatal_signal = tokudb_handle_fatal_signal;\n#endif\n\n#if TOKU_INCLUDE_OPTION_STRUCTS\n    tokudb_hton->table_options = tokudb::sysvars::tokudb_table_options;\n    tokudb_hton->index_options = tokudb::sysvars::tokudb_index_options;\n#endif\n\n    if (!tokudb_home)\n        tokudb_home = mysql_real_data_home;\n    DBUG_PRINT(\"info\", (\"tokudb_home: %s\", tokudb_home));\n\n    if ((r = db_env_create(&db_env, 0))) {\n        DBUG_PRINT(\"info\", (\"db_env_create %d\\n\", r));\n        handle_ydb_error(r);\n        goto error;\n    }\n\n    DBUG_PRINT(\"info\", (\"tokudb_env_flags: 0x%x\\n\", tokudb_env_flags));\n    r = db_env->set_flags(db_env, tokudb_env_flags, 1);\n    if (r) { // QQQ\n        TOKUDB_TRACE_FOR_FLAGS(\n            TOKUDB_DEBUG_INIT,\n            \"WARNING: flags=%x r=%d\",\n            tokudb_env_flags,\n            r);\n        // goto error;\n    }\n\n    // config error handling\n    db_env->set_errcall(db_env, tokudb_print_error);\n    db_env->set_errpfx(db_env, tokudb_hton_name);\n\n    // Handle deprecated options\n    if (tokudb::sysvars::pk_insert_mode(NULL) != 1) {\n        TOKUDB_TRACE(\"Using tokudb_pk_insert_mode is deprecated and the \"\n            \"parameter may be removed in future releases. \"\n            \"tokudb_pk_insert_mode=0 is now forbidden. \"\n            \"See documentation and release notes for details\");\n        if (tokudb::sysvars::pk_insert_mode(NULL) < 1)\n           tokudb::sysvars::set_pk_insert_mode(NULL, 1);\n    }\n\n    //\n    // set default comparison functions\n    //\n    r = db_env->set_default_bt_compare(db_env, tokudb_cmp_dbt_key);\n    if (r) {\n        DBUG_PRINT(\"info\", (\"set_default_bt_compare%d\\n\", r));\n        goto error; \n    }\n\n    {\n        char* tmp_dir = tokudb::sysvars::tmp_dir;\n        char* data_dir = tokudb::sysvars::data_dir;\n        if (data_dir == 0) {\n            data_dir = mysql_data_home;\n        }\n        if (tmp_dir == 0) {\n            tmp_dir = data_dir;\n        }\n        DBUG_PRINT(\"info\", (\"tokudb_data_dir: %s\\n\", data_dir));\n        db_env->set_data_dir(db_env, data_dir);\n        DBUG_PRINT(\"info\", (\"tokudb_tmp_dir: %s\\n\", tmp_dir));\n        db_env->set_tmp_dir(db_env, tmp_dir);\n    }\n\n    if (tokudb::sysvars::log_dir) {\n        DBUG_PRINT(\"info\", (\"tokudb_log_dir: %s\\n\", tokudb::sysvars::log_dir));\n        db_env->set_lg_dir(db_env, tokudb::sysvars::log_dir);\n    }\n\n    // config the cache table size to min(1/2 of physical memory, 1/8 of the\n    // process address space)\n    if (tokudb::sysvars::cache_size == 0) {\n        uint64_t physmem, maxdata;\n        physmem = toku_os_get_phys_memory_size();\n        tokudb::sysvars::cache_size = physmem / 2;\n        r = toku_os_get_max_process_data_size(&maxdata);\n        if (r == 0) {\n            if (tokudb::sysvars::cache_size > maxdata / 8)\n                tokudb::sysvars::cache_size = maxdata / 8;\n        }\n    }\n    if (tokudb::sysvars::cache_size) {\n        DBUG_PRINT(\n            \"info\",\n            (\"tokudb_cache_size: %lld\\n\", tokudb::sysvars::cache_size));\n        r = db_env->set_cachesize(\n            db_env,\n            (uint32_t)(tokudb::sysvars::cache_size >> 30),\n            (uint32_t)(tokudb::sysvars::cache_size  %\n                (1024L * 1024L * 1024L)), 1);\n        if (r) {\n            DBUG_PRINT(\"info\", (\"set_cachesize %d\\n\", r));\n            goto error; \n        }\n    }\n    if (tokudb::sysvars::max_lock_memory == 0) {\n        tokudb::sysvars::max_lock_memory = tokudb::sysvars::cache_size/8;\n    }\n    if (tokudb::sysvars::max_lock_memory) {\n        DBUG_PRINT(\n            \"info\",\n            (\"tokudb_max_lock_memory: %lld\\n\",\n            tokudb::sysvars::max_lock_memory));\n        r = db_env->set_lk_max_memory(\n            db_env,\n            tokudb::sysvars::max_lock_memory);\n        if (r) {\n            DBUG_PRINT(\"info\", (\"set_lk_max_memory %d\\n\", r));\n            goto error; \n        }\n    }\n    \n    uint32_t gbytes, bytes; int parts;\n    r = db_env->get_cachesize(db_env, &gbytes, &bytes, &parts);\n    TOKUDB_TRACE_FOR_FLAGS(\n        TOKUDB_DEBUG_INIT,\n        \"tokudb_cache_size=%lld r=%d\",\n        ((unsigned long long) gbytes << 30) + bytes,\n        r);\n\n    r = db_env->set_client_pool_threads(\n        db_env,\n        tokudb::sysvars::client_pool_threads);\n    if (r) {\n        DBUG_PRINT(\"info\", (\"set_client_pool_threads %d\\n\", r));\n        goto error;\n    }\n\n    r = db_env->set_cachetable_pool_threads(\n        db_env,\n        tokudb::sysvars::cachetable_pool_threads);\n    if (r) {\n        DBUG_PRINT(\"info\", (\"set_cachetable_pool_threads %d\\n\", r));\n        goto error;\n    }\n\n    r = db_env->set_checkpoint_pool_threads(\n        db_env,\n        tokudb::sysvars::checkpoint_pool_threads);\n    if (r) {\n        DBUG_PRINT(\"info\", (\"set_checkpoint_pool_threads %d\\n\", r));\n        goto error;\n    }\n\n    if (db_env->set_redzone) {\n        r = db_env->set_redzone(db_env, tokudb::sysvars::fs_reserve_percent);\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_INIT, \"set_redzone r=%d\", r);\n    }\n    TOKUDB_TRACE_FOR_FLAGS(\n        TOKUDB_DEBUG_INIT,\n        \"env open:flags=%x\",\n        tokudb_init_flags);\n\n    r = db_env->set_generate_row_callback_for_put(db_env, generate_row_for_put);\n    assert_always(r == 0);\n\n    r = db_env->set_generate_row_callback_for_del(db_env, generate_row_for_del);\n    assert_always(r == 0);\n\n    db_env->set_update(db_env, tokudb_update_fun);\n\n    db_env_set_direct_io(tokudb::sysvars::directio == TRUE);\n\n    db_env_set_compress_buffers_before_eviction(\n        tokudb::sysvars::compress_buffers_before_eviction == TRUE);\n\n    db_env->change_fsync_log_period(db_env, tokudb::sysvars::fsync_log_period);\n\n    db_env->set_lock_timeout_callback(db_env, tokudb_lock_timeout_callback);\n    db_env->set_dir_per_db(db_env, tokudb::sysvars::dir_per_db);\n    db_env->set_lock_wait_callback(db_env, tokudb_lock_wait_needed_callback);\n\n    db_env->set_loader_memory_size(\n        db_env,\n        tokudb_get_loader_memory_size_callback);\n\n    db_env->set_check_thp(db_env, tokudb::sysvars::check_jemalloc);\n\n    r = db_env->open(\n        db_env,\n        tokudb_home,\n        tokudb_init_flags,\n        S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);\n\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_INIT, \"env opened:return=%d\", r);\n\n    if (r) {\n        DBUG_PRINT(\"info\", (\"env->open %d\", r));\n        handle_ydb_error(r);\n        goto error;\n    }\n\n    r = db_env->checkpointing_set_period(\n        db_env,\n        tokudb::sysvars::checkpointing_period);\n    assert_always(r == 0);\n\n    r = db_env->cleaner_set_period(db_env, tokudb::sysvars::cleaner_period);\n    assert_always(r == 0);\n\n    r = db_env->cleaner_set_iterations(\n        db_env,\n        tokudb::sysvars::cleaner_iterations);\n    assert_always(r == 0);\n\n    r = db_env->set_lock_timeout(\n        db_env,\n        DEFAULT_TOKUDB_LOCK_TIMEOUT,\n        tokudb_get_lock_wait_time_callback);\n    assert_always(r == 0);\n\n    r = db_env->evictor_set_enable_partial_eviction(\n        db_env,\n        tokudb::sysvars::enable_partial_eviction);\n    assert_always(r == 0);\n\n    db_env->set_killed_callback(\n        db_env,\n        DEFAULT_TOKUDB_KILLED_TIME,\n        tokudb_get_killed_time_callback,\n        tokudb_killed_callback);\n\n    r = db_env->get_engine_status_num_rows(\n        db_env,\n        &toku_global_status_max_rows);\n    assert_always(r == 0);\n\n    {\n        const myf mem_flags =\n            MY_FAE|MY_WME|MY_ZEROFILL|MY_ALLOW_ZERO_PTR|MY_FREE_ON_ERROR;\n        toku_global_status_variables =\n            (SHOW_VAR*)tokudb::memory::malloc(\n                sizeof(*toku_global_status_variables) *\n                    toku_global_status_max_rows,\n                mem_flags);\n        toku_global_status_rows =\n            (TOKU_ENGINE_STATUS_ROW_S*)tokudb::memory::malloc(\n                sizeof(*toku_global_status_rows)*\n                    toku_global_status_max_rows,\n                mem_flags);\n    }\n\n    tokudb_primary_key_bytes_inserted = create_partitioned_counter();\n\n#if TOKU_THDVAR_MEMALLOC_BUG\n    init_tree(&tokudb_map, 0, 0, 0, tokudb_map_pair_cmp, true, NULL, NULL);\n#endif\n\n    if (tokudb::sysvars::strip_frm_data) {\n        r = tokudb::metadata::strip_frm_data(db_env);\n        if (r) {\n            DBUG_PRINT(\"info\", (\"env->open %d\", r));\n            handle_ydb_error(r);\n            goto error;\n        }\n    }\n\n    //3938: succeeded, set the init status flag and unlock\n    tokudb_hton_initialized = 1;\n    tokudb_hton_initialized_lock.unlock();\n    DBUG_RETURN(false);\n\nerror:\n    if (db_env) {\n        int rr= db_env->close(db_env, 0);\n        assert_always(rr==0);\n        db_env = 0;\n    }\n\n    // 3938: failed to initialized, drop the flag and lock\n    tokudb_hton_initialized = 0;\n    tokudb_hton_initialized_lock.unlock();\n    DBUG_RETURN(true);\n}\n\nstatic int tokudb_done_func(void* p) {\n    TOKUDB_DBUG_ENTER(\"\");\n    tokudb::memory::free(toku_global_status_variables);\n    toku_global_status_variables = NULL;\n    tokudb::memory::free(toku_global_status_rows);\n    toku_global_status_rows = NULL;\n    TOKUDB_DBUG_RETURN(0);\n}\n\nstatic handler* tokudb_create_handler(\n    handlerton* hton,\n    TABLE_SHARE* table,\n    MEM_ROOT* mem_root) {\n    return new(mem_root) ha_tokudb(hton, table);\n}\n\nint tokudb_end(handlerton* hton, ha_panic_function type) {\n    TOKUDB_DBUG_ENTER(\"\");\n    int error = 0;\n    \n    // 3938: if we finalize the storage engine plugin, it is no longer\n    // initialized. grab a writer lock for the duration of the\n    // call, so we can drop the flag and destroy the mutexes\n    // in isolation.\n    tokudb_hton_initialized_lock.lock_write();\n    assert_always(tokudb_hton_initialized);\n\n    tokudb::background::destroy();\n    TOKUDB_SHARE::static_destroy();\n\n    if (db_env) {\n        if (tokudb_init_flags & DB_INIT_LOG)\n            tokudb_cleanup_log_files();\n\n        // count the total number of prepared txn's that we discard\n        long total_prepared = 0;\n#if TOKU_INCLUDE_XA\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"begin XA cleanup\");\n        while (1) {\n            // get xid's \n            const long n_xid = 1;\n            TOKU_XA_XID xids[n_xid];\n            long n_prepared = 0;\n            error = db_env->txn_xa_recover(\n                db_env,\n                xids,\n                n_xid,\n                &n_prepared,\n                total_prepared == 0 ? DB_FIRST : DB_NEXT);\n            assert_always(error == 0);\n            if (n_prepared == 0) \n                break;\n            // discard xid's\n            for (long i = 0; i < n_xid; i++) {\n                DB_TXN *txn = NULL;\n                error = db_env->get_txn_from_xid(db_env, &xids[i], &txn);\n                assert_always(error == 0);\n                error = txn->discard(txn, 0);\n                assert_always(error == 0);\n            }\n            total_prepared += n_prepared;\n        }\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"end XA cleanup\");\n#endif\n        error = db_env->close(\n            db_env,\n            total_prepared > 0 ? TOKUFT_DIRTY_SHUTDOWN : 0);\n#if TOKU_INCLUDE_XA\n        if (error != 0 && total_prepared > 0) {\n            sql_print_error(\n                \"%s: %ld prepared txns still live, please shutdown, error %d\",\n                tokudb_hton_name,\n                total_prepared,\n                error);\n        } else\n#endif\n        assert_always(error == 0);\n        db_env = NULL;\n    }\n\n    if (tokudb_primary_key_bytes_inserted) {\n        destroy_partitioned_counter(tokudb_primary_key_bytes_inserted);\n        tokudb_primary_key_bytes_inserted = NULL;\n    }\n\n#if TOKU_THDVAR_MEMALLOC_BUG\n    delete_tree(&tokudb_map);\n#endif\n\n    // 3938: drop the initialized flag and unlock\n    tokudb_hton_initialized = 0;\n    tokudb_hton_initialized_lock.unlock();\n\n    TOKUDB_DBUG_RETURN(error);\n}\n\nstatic int tokudb_close_connection(handlerton* hton, THD* thd) {\n    int error = 0;\n    tokudb_trx_data* trx = (tokudb_trx_data*)thd_get_ha_data(thd, tokudb_hton);\n    if (trx && trx->checkpoint_lock_taken) {\n        error = db_env->checkpointing_resume(db_env);\n    }\n    tokudb::memory::free(trx);\n#if TOKU_THDVAR_MEMALLOC_BUG\n    tokudb_map_mutex.lock();\n    struct tokudb_map_pair key = { thd, NULL };\n    struct tokudb_map_pair* found_key =\n        (struct tokudb_map_pair*) tree_search(&tokudb_map, &key, NULL);\n\n    if (found_key) {\n        tokudb::memory::free(found_key->last_lock_timeout);\n        tree_delete(&tokudb_map, found_key, sizeof(*found_key), NULL);\n    }\n    tokudb_map_mutex.unlock();\n#endif\n    return error;\n}\n\nvoid tokudb_kill_connection(handlerton *hton, THD *thd,\n                            enum thd_kill_levels level) {\n    TOKUDB_DBUG_ENTER(\"\");\n    db_env->kill_waiter(db_env, thd);\n    DBUG_VOID_RETURN;\n}\n\nbool tokudb_flush_logs(handlerton * hton) {\n    TOKUDB_DBUG_ENTER(\"\");\n    int error;\n    bool result = 0;\n\n    if (tokudb::sysvars::checkpoint_on_flush_logs) {\n        //\n        // take the checkpoint\n        //\n        error = db_env->txn_checkpoint(db_env, 0, 0, 0);\n        if (error) {\n            my_error(ER_ERROR_DURING_CHECKPOINT, MYF(0), error);\n            result = 1;\n            goto exit;\n        }\n    }\n    else {\n        error = db_env->log_flush(db_env, NULL);\n        assert_always(error == 0);\n    }\n\n    result = 0;\nexit:\n    TOKUDB_DBUG_RETURN(result);\n}\n\n\ntypedef struct txn_progress_info {\n    char status[200];\n    THD* thd;\n} *TXN_PROGRESS_INFO;\n\nstatic void txn_progress_func(TOKU_TXN_PROGRESS progress, void* extra) {\n    TXN_PROGRESS_INFO progress_info = (TXN_PROGRESS_INFO)extra;\n    int r = sprintf(\n        progress_info->status,\n            \"%sprocessing %s of transaction, %\" PRId64 \" out of %\" PRId64,\n            progress->stalled_on_checkpoint ? \"Writing committed changes to disk, \" : \"\",\n            progress->is_commit ? \"commit\" : \"abort\",\n            progress->entries_processed,\n            progress->entries_total);\n    assert_always(r >= 0);\n    thd_proc_info(progress_info->thd, progress_info->status);\n}\n\nstatic void commit_txn_with_progress(DB_TXN* txn, uint32_t flags, THD* thd) {\n    const char *orig_proc_info = tokudb_thd_get_proc_info(thd);\n    struct txn_progress_info info;\n    info.thd = thd;\n    int r = txn->commit_with_progress(txn, flags, txn_progress_func, &info);\n    if (r != 0) {\n        sql_print_error(\n            \"%s: tried committing transaction %p and got error code %d\",\n            tokudb_hton_name,\n            txn,\n            r);\n    }\n    assert_always(r == 0);\n    thd_proc_info(thd, orig_proc_info);\n}\n\nstatic void abort_txn_with_progress(DB_TXN* txn, THD* thd) {\n    const char *orig_proc_info = tokudb_thd_get_proc_info(thd);\n    struct txn_progress_info info;\n    info.thd = thd;\n    int r = txn->abort_with_progress(txn, txn_progress_func, &info);\n    if (r != 0) {\n        sql_print_error(\n            \"%s: tried aborting transaction %p and got error code %d\",\n            tokudb_hton_name,\n            txn,\n            r);\n    }\n    assert_always(r == 0);\n    thd_proc_info(thd, orig_proc_info);\n}\n\nstatic void tokudb_cleanup_handlers(tokudb_trx_data *trx, DB_TXN *txn) {\n    LIST *e;\n    while ((e = trx->handlers)) {\n        trx->handlers = list_delete(trx->handlers, e);\n        ha_tokudb *handler = (ha_tokudb *) e->data;\n        handler->cleanup_txn(txn);\n    }\n}\n\n#if MYSQL_VERSION_ID >= 50600\nextern \"C\" enum durability_properties thd_get_durability_property(\n    const MYSQL_THD thd);\n#endif\n\n// Determine if an fsync is used when a transaction is committed.  \nstatic bool tokudb_sync_on_commit(THD* thd, tokudb_trx_data* trx, DB_TXN* txn) {\n#if MYSQL_VERSION_ID >= 50600\n    // Check the client durability property which is set during 2PC\n    if (thd_get_durability_property(thd) == HA_IGNORE_DURABILITY)\n        return false;\n#endif\n#if defined(MARIADB_BASE_VERSION)\n    // Check is the txn is prepared and the binlog is open\n    if (txn->is_prepared(txn) && mysql_bin_log.is_open())\n        return false;\n#endif\n    if (tokudb::sysvars::fsync_log_period > 0)\n        return false;\n    return tokudb::sysvars::commit_sync(thd) != 0;\n}\n\nstatic int tokudb_commit(handlerton * hton, THD * thd, bool all) {\n    TOKUDB_DBUG_ENTER(\"%u\", all);\n    DBUG_PRINT(\"trans\", (\"ending transaction %s\", all ? \"all\" : \"stmt\"));\n    tokudb_trx_data *trx = (tokudb_trx_data *) thd_get_ha_data(thd, hton);\n    DB_TXN **txn = all ? &trx->all : &trx->stmt;\n    DB_TXN *this_txn = *txn;\n    if (this_txn) {\n        uint32_t syncflag =\n            tokudb_sync_on_commit(thd, trx, this_txn) ? 0 : DB_TXN_NOSYNC;\n        TOKUDB_TRACE_FOR_FLAGS(\n            TOKUDB_DEBUG_TXN,\n            \"commit trx %u txn %p %\" PRIu64 \" syncflag %u\",\n            all,\n            this_txn, this_txn->id64(this_txn),\n            syncflag);\n        // test hook to induce a crash on a debug build\n        DBUG_EXECUTE_IF(\"tokudb_crash_commit_before\", DBUG_SUICIDE(););\n        tokudb_cleanup_handlers(trx, this_txn);\n        commit_txn_with_progress(this_txn, syncflag, thd);\n        // test hook to induce a crash on a debug build\n        DBUG_EXECUTE_IF(\"tokudb_crash_commit_after\", DBUG_SUICIDE(););\n        *txn = NULL;\n        trx->sub_sp_level = NULL;\n        if (this_txn == trx->sp_level || trx->all == NULL) {\n            trx->sp_level = NULL;\n        }\n    } else {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_TXN, \"nothing to commit %d\", all);\n    }\n    reset_stmt_progress(&trx->stmt_progress);\n    TOKUDB_DBUG_RETURN(0);\n}\n\nstatic int tokudb_rollback(handlerton * hton, THD * thd, bool all) {\n    TOKUDB_DBUG_ENTER(\"%u\", all);\n    DBUG_PRINT(\"trans\", (\"aborting transaction %s\", all ? \"all\" : \"stmt\"));\n    tokudb_trx_data *trx = (tokudb_trx_data *) thd_get_ha_data(thd, hton);\n    DB_TXN **txn = all ? &trx->all : &trx->stmt;\n    DB_TXN *this_txn = *txn;\n    if (this_txn) {\n        TOKUDB_TRACE_FOR_FLAGS(\n            TOKUDB_DEBUG_TXN,\n            \"rollback %u txn %p %\" PRIu64,\n            all,\n            this_txn, this_txn->id64(this_txn));\n        tokudb_cleanup_handlers(trx, this_txn);\n        abort_txn_with_progress(this_txn, thd);\n        *txn = NULL;\n        trx->sub_sp_level = NULL;\n        if (this_txn == trx->sp_level || trx->all == NULL) {\n            trx->sp_level = NULL;\n        }\n    } else {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_TXN, \"abort0\");\n    }\n    reset_stmt_progress(&trx->stmt_progress);\n    TOKUDB_DBUG_RETURN(0);\n}\n\n#if TOKU_INCLUDE_XA\nstatic bool tokudb_sync_on_prepare(void) {\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"enter\");\n    // skip sync of log if fsync log period > 0\n    if (tokudb::sysvars::fsync_log_period > 0) {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit\");\n        return false;\n    } else {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit\");\n        return true;\n    }\n}   \n\nstatic int tokudb_xa_prepare(handlerton* hton, THD* thd, bool all) {\n    TOKUDB_DBUG_ENTER(\"\");\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"enter\");\n    int r = 0;\n\n    // if tokudb_support_xa is disable, just return\n    if (!tokudb::sysvars::support_xa(thd)) {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %d\", r);\n        TOKUDB_DBUG_RETURN(r);\n    }\n\n    DBUG_PRINT(\"trans\", (\"preparing transaction %s\", all ? \"all\" : \"stmt\"));\n    tokudb_trx_data *trx = (tokudb_trx_data *) thd_get_ha_data(thd, hton);\n    DB_TXN* txn = all ? trx->all : trx->stmt;\n    if (txn) {\n        uint32_t syncflag = tokudb_sync_on_prepare() ? 0 : DB_TXN_NOSYNC;\n        TOKUDB_TRACE_FOR_FLAGS(\n            TOKUDB_DEBUG_XA,\n            \"doing txn prepare:%d:%p %\" PRIu64,\n            all,\n            txn, txn->id64(txn));\n        // a TOKU_XA_XID is identical to a MYSQL_XID\n        TOKU_XA_XID thd_xid;\n        thd_get_xid(thd, (MYSQL_XID*) &thd_xid);\n        // test hook to induce a crash on a debug build\n        DBUG_EXECUTE_IF(\"tokudb_crash_prepare_before\", DBUG_SUICIDE(););\n        r = txn->xa_prepare(txn, &thd_xid, syncflag);\n        // test hook to induce a crash on a debug build\n        DBUG_EXECUTE_IF(\"tokudb_crash_prepare_after\", DBUG_SUICIDE(););\n    } else {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"nothing to prepare %d\", all);\n    }\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %d\", r);\n    TOKUDB_DBUG_RETURN(r);\n}\n\nstatic int tokudb_xa_recover(handlerton* hton, XID* xid_list, uint len) {\n    TOKUDB_DBUG_ENTER(\"\");\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"enter\");\n    int r = 0;\n    if (len == 0 || xid_list == NULL) {\n        TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %d\", 0);\n        TOKUDB_DBUG_RETURN(0);\n    }\n    long num_returned = 0;\n    r = db_env->txn_xa_recover(\n        db_env,\n        (TOKU_XA_XID*)xid_list,\n        len,\n        &num_returned,\n        DB_NEXT);\n    assert_always(r == 0);\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %ld\", num_returned);\n    TOKUDB_DBUG_RETURN((int)num_returned);\n}\n\nstatic int tokudb_commit_by_xid(handlerton* hton, XID* xid) {\n    TOKUDB_DBUG_ENTER(\"\");\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"enter\");\n    int r = 0;\n    DB_TXN* txn = NULL;\n    TOKU_XA_XID* toku_xid = (TOKU_XA_XID*)xid;\n\n    r = db_env->get_txn_from_xid(db_env, toku_xid, &txn);\n    if (r) { goto cleanup; }\n\n    r = txn->commit(txn, 0);\n    if (r) { goto cleanup; }\n\n    r = 0;\ncleanup:\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %d\", r);\n    TOKUDB_DBUG_RETURN(r);\n}\n\nstatic int tokudb_rollback_by_xid(handlerton* hton, XID*  xid) {\n    TOKUDB_DBUG_ENTER(\"\");\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"enter\");\n    int r = 0;\n    DB_TXN* txn = NULL;\n    TOKU_XA_XID* toku_xid = (TOKU_XA_XID*)xid;\n\n    r = db_env->get_txn_from_xid(db_env, toku_xid, &txn);\n    if (r) { goto cleanup; }\n\n    r = txn->abort(txn);\n    if (r) { goto cleanup; }\n\n    r = 0;\ncleanup:\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_XA, \"exit %d\", r);\n    TOKUDB_DBUG_RETURN(r);\n}\n\n#endif\n\nstatic int tokudb_savepoint(handlerton * hton, THD * thd, void *savepoint) {\n    TOKUDB_DBUG_ENTER(\"%p\", savepoint);\n    int error;\n    SP_INFO save_info = (SP_INFO)savepoint;\n    tokudb_trx_data *trx = (tokudb_trx_data *) thd_get_ha_data(thd, hton);\n    if (thd->in_sub_stmt) {\n        assert_always(trx->stmt);\n        error = txn_begin(\n            db_env,\n            trx->sub_sp_level,\n            &(save_info->txn),\n            DB_INHERIT_ISOLATION,\n            thd);\n        if (error) {\n            goto cleanup;\n        }\n        trx->sub_sp_level = save_info->txn;\n        save_info->in_sub_stmt = true;\n    } else {\n        error = txn_begin(\n            db_env,\n            trx->sp_level,\n            &(save_info->txn),\n            DB_INHERIT_ISOLATION,\n            thd);\n        if (error) {\n            goto cleanup;\n        }\n        trx->sp_level = save_info->txn;\n        save_info->in_sub_stmt = false;\n    }\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_TXN, \"begin txn %p\", save_info->txn);\n    save_info->trx = trx;\n    error = 0;\ncleanup:\n    TOKUDB_DBUG_RETURN(error);\n}\n\nstatic int tokudb_rollback_to_savepoint(\n    handlerton* hton,\n    THD* thd,\n    void* savepoint) {\n\n    TOKUDB_DBUG_ENTER(\"%p\", savepoint);\n    int error;\n    SP_INFO save_info = (SP_INFO)savepoint;\n    DB_TXN* parent = NULL;\n    DB_TXN* txn_to_rollback = save_info->txn;\n\n    tokudb_trx_data* trx = (tokudb_trx_data*)thd_get_ha_data(thd, hton);\n    parent = txn_to_rollback->parent;\n    TOKUDB_TRACE_FOR_FLAGS(\n        TOKUDB_DEBUG_TXN,\n        \"rollback txn %p\",\n        txn_to_rollback);\n    if (!(error = txn_to_rollback->abort(txn_to_rollback))) {\n        if (save_info->in_sub_stmt) {\n            trx->sub_sp_level = parent;\n        }\n        else {\n            trx->sp_level = parent;\n        }\n        error = tokudb_savepoint(hton, thd, savepoint);\n    }\n    TOKUDB_DBUG_RETURN(error);\n}\n\nstatic int tokudb_release_savepoint(\n    handlerton* hton,\n    THD* thd,\n    void* savepoint) {\n\n    TOKUDB_DBUG_ENTER(\"%p\", savepoint);\n    int error = 0;\n    SP_INFO save_info = (SP_INFO)savepoint;\n    DB_TXN* parent = NULL;\n    DB_TXN* txn_to_commit = save_info->txn;\n\n    tokudb_trx_data *trx = (tokudb_trx_data *) thd_get_ha_data(thd, hton);\n    parent = txn_to_commit->parent;\n    TOKUDB_TRACE_FOR_FLAGS(TOKUDB_DEBUG_TXN, \"commit txn %p\", txn_to_commit);\n    DB_TXN *child = txn_to_commit->get_child(txn_to_commit);\n    if (child == NULL && !(error = txn_to_commit->commit(txn_to_commit, 0))) {\n        if (save_info->in_sub_stmt) {\n            trx->sub_sp_level = parent;\n        }\n        else {\n            trx->sp_level = parent;\n        }\n    }\n    save_info->txn = NULL;\n    TOKUDB_DBUG_RETURN(error);\n}\n\n#if 100000 <= MYSQL_VERSION_ID\nstatic int tokudb_discover_table(handlerton *hton, THD* thd, TABLE_SHARE *ts) {\n    uchar *frmblob = 0;\n    size_t frmlen;\n    int res= tokudb_discover3(\n        hton,\n        thd,\n        ts->db.str,\n        ts->table_name.str,\n        ts->normalized_path.str,\n        &frmblob,\n        &frmlen);\n    if (!res)\n        res= ts->init_from_binary_frm_image(thd, true, frmblob, frmlen);\n    \n    my_free(frmblob);\n    // discover_table should returns HA_ERR_NO_SUCH_TABLE for \"not exists\"\n    return res == ENOENT ? HA_ERR_NO_SUCH_TABLE : res;\n}\n\nstatic int tokudb_discover_table_existence(\n    handlerton* hton,\n    const char* db,\n    const char* name) {\n\n    uchar *frmblob = 0;\n    size_t frmlen;\n    int res= tokudb_discover(hton, current_thd, db, name, &frmblob, &frmlen);\n    my_free(frmblob);\n    return res != ENOENT;\n}\n#endif\n\nstatic int tokudb_discover(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    uchar** frmblob,\n    size_t* frmlen) {\n\n    return tokudb_discover2(hton, thd, db, name, true, frmblob, frmlen);\n}\n\nstatic int tokudb_discover2(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    bool translate_name,\n    uchar** frmblob,\n    size_t*frmlen) {\n\n    char path[FN_REFLEN + 1];\n    build_table_filename(\n        path,\n        sizeof(path) - 1,\n        db,\n        name,\n        \"\",\n        translate_name ? 0 : FN_IS_TMP);\n    return tokudb_discover3(hton, thd, db, name, path, frmblob, frmlen);\n}\n\nstatic int tokudb_discover3(\n    handlerton* hton,\n    THD* thd,\n    const char* db,\n    const char* name,\n    char* path,\n    uchar** frmblob,\n    size_t* frmlen) {\n\n    TOKUDB_DBUG_ENTER(\"%s %s %s\", db, name, path);\n    int error;\n    DB* status_db = NULL;\n    DB_TXN* txn = NULL;\n    HA_METADATA_KEY curr_key = hatoku_frm_data;\n    DBT key = {};\n    DBT value = {};\n    bool do_commit = false;\n\n#if 100000 <= MYSQL_VERSION_ID\n    tokudb_trx_data* trx = (tokudb_trx_data*)thd_get_ha_data(thd, tokudb_hton);\n    if (thd_sql_command(thd) == SQLCOM_CREATE_TABLE &&\n        trx &&\n        trx->sub_sp_level) {\n        do_commit = false;\n        txn = trx->sub_sp_level;\n    } else {\n        error = txn_begin(db_env, 0, &txn, 0, thd);\n        if (error) { goto cleanup; }\n        do_commit = true;\n    }\n#else\n    error = txn_begin(db_env, 0, &txn, 0, thd);\n    if (error) { goto cleanup; }\n    do_commit = true;\n#endif\n\n    error = open_status_dictionary(&status_db, path, txn);\n    if (error) { goto cleanup; }\n\n    key.data = &curr_key;\n    key.size = sizeof(curr_key);\n\n    error = status_db->getf_set(\n        status_db, \n        txn,\n        0,\n        &key, \n        smart_dbt_callback_verify_frm,\n        &value);\n    if (error) {\n        goto cleanup;\n    }\n\n    *frmblob = (uchar *)value.data;\n    *frmlen = value.size;\n\n    error = 0;\ncleanup:\n    if (status_db) {\n        status_db->close(status_db,0);\n    }\n    if (do_commit && txn) {\n        commit_txn(txn, 0);\n    }\n    TOKUDB_DBUG_RETURN(error);\n}\n\n\n#define STATPRINT(legend, val) if (legend != NULL && val != NULL) \\\n    stat_print(thd, \\\n        tokudb_hton_name, \\\n        strlen(tokudb_hton_name), \\\n        legend, \\\n        strlen(legend), \\\n        val, \\\n        strlen(val))\n\nextern sys_var* intern_find_sys_var(\n    const char* str,\n    uint length,\n    bool no_error);\n\nstatic bool tokudb_show_engine_status(THD * thd, stat_print_fn * stat_print) {\n    TOKUDB_DBUG_ENTER(\"\");\n    int error;\n    uint64_t panic;\n    const int panic_string_len = 1024;\n    char panic_string[panic_string_len] = {'\\0'};\n    uint64_t num_rows;\n    uint64_t max_rows;\n    fs_redzone_state redzone_state;\n    const int bufsiz = 1024;\n    char buf[bufsiz];\n\n#if MYSQL_VERSION_ID < 50500\n    {\n        sys_var* version = intern_find_sys_var(\"version\", 0, false);\n        snprintf(\n            buf,\n            bufsiz,\n            \"%s\",\n            version->value_ptr(thd,\n            (enum_var_type)0,\n            (LEX_STRING*)NULL));\n        STATPRINT(\"Version\", buf);\n    }\n#endif\n    error = db_env->get_engine_status_num_rows (db_env, &max_rows);\n    TOKU_ENGINE_STATUS_ROW_S mystat[max_rows];\n    error = db_env->get_engine_status(\n        db_env,\n        mystat,\n        max_rows,\n        &num_rows,\n        &redzone_state,\n        &panic,\n        panic_string,\n        panic_string_len,\n        TOKU_ENGINE_STATUS);\n\n    if (strlen(panic_string)) {\n        STATPRINT(\"Environment panic string\", panic_string);\n    }\n    if (error == 0) {\n        if (panic) {\n            snprintf(buf, bufsiz, \"%\" PRIu64, panic);\n            STATPRINT(\"Environment panic\", buf);\n        }\n        \n        if(redzone_state == FS_BLOCKED) {\n            STATPRINT(\n                \"*** URGENT WARNING ***\", \"FILE SYSTEM IS COMPLETELY FULL\");\n            snprintf(buf, bufsiz, \"FILE SYSTEM IS COMPLETELY FULL\");\n        } else if (redzone_state == FS_GREEN) {\n            snprintf(\n                buf,\n                bufsiz,\n                \"more than %d percent of total file system space\",\n                2 * tokudb::sysvars::fs_reserve_percent);\n        } else if (redzone_state == FS_YELLOW) {\n            snprintf(\n                buf,\n                bufsiz,\n                \"*** WARNING *** FILE SYSTEM IS GETTING FULL (less than %d \"\n                \"percent free)\",\n                2 * tokudb::sysvars::fs_reserve_percent);\n        } else if (redzone_state == FS_RED){\n            snprintf(\n                buf,\n                bufsiz,\n                \"*** WARNING *** FILE SYSTEM IS GETTING VERY FULL (less than \"\n                \"%d percent free): INSERTS ARE PROHIBITED\",\n                tokudb::sysvars::fs_reserve_percent);\n        } else {\n            snprintf(\n                buf,\n                bufsiz,\n                \"information unavailable, unknown redzone state %d\",\n                redzone_state);\n        }\n        STATPRINT (\"disk free space\", buf);\n\n        for (uint64_t row = 0; row < num_rows; row++) {\n            switch (mystat[row].type) {\n            case FS_STATE:\n                snprintf(buf, bufsiz, \"%\" PRIu64 \"\", mystat[row].value.num);\n                break;\n            case UINT64:\n                snprintf(buf, bufsiz, \"%\" PRIu64 \"\", mystat[row].value.num);\n                break;\n            case CHARSTR:\n                snprintf(buf, bufsiz, \"%s\", mystat[row].value.str);\n                break;\n            case UNIXTIME: {\n                time_t t = mystat[row].value.num;\n                char tbuf[26];\n                snprintf(buf, bufsiz, \"%.24s\", ctime_r(&t, tbuf));\n                break;\n            }\n            case TOKUTIME: {\n                double t = tokutime_to_seconds(mystat[row].value.num);\n                snprintf(buf, bufsiz, \"%.6f\", t);\n                break;\n            }\n            case PARCOUNT: {\n                uint64_t v = read_partitioned_counter(\n                    mystat[row].value.parcount);\n                snprintf(buf, bufsiz, \"%\" PRIu64, v);\n                break;\n            }\n            case DOUBLE:\n                snprintf(buf, bufsiz, \"%.6f\", mystat[row].value.dnum);\n                break;\n            default:\n                snprintf(\n                    buf,\n                    bufsiz,\n                    \"UNKNOWN STATUS TYPE: %d\",\n                    mystat[row].type);\n                break;\n            }\n            STATPRINT(mystat[row].legend, buf);\n        }\n        uint64_t bytes_inserted = read_partitioned_counter(\n            tokudb_primary_key_bytes_inserted);\n        snprintf(buf, bufsiz, \"%\" PRIu64, bytes_inserted);\n        STATPRINT(\"handlerton: primary key bytes inserted\", buf);\n    }  \n    if (error) { my_errno = error; }\n    TOKUDB_DBUG_RETURN(error);\n}\n\nvoid tokudb_checkpoint_lock(THD * thd) {\n    int error;\n    const char *old_proc_info;\n    tokudb_trx_data* trx = (tokudb_trx_data*)thd_get_ha_data(thd, tokudb_hton);\n    if (!trx) {\n        error = create_tokudb_trx_data_instance(&trx);\n        //\n        // can only fail due to memory allocation, so ok to assert\n        //\n        assert_always(!error);\n        thd_set_ha_data(thd, tokudb_hton, trx);\n    }\n    \n    if (trx->checkpoint_lock_taken) {\n        goto cleanup;\n    }\n    //\n    // This can only fail if environment is not created, which is not possible\n    // in handlerton\n    //\n    old_proc_info = tokudb_thd_get_proc_info(thd);\n    thd_proc_info(thd, \"Trying to grab checkpointing lock.\");\n    error = db_env->checkpointing_postpone(db_env);\n    assert_always(!error);\n    thd_proc_info(thd, old_proc_info);\n\n    trx->checkpoint_lock_taken = true;\ncleanup:\n    return;\n}\n\nvoid tokudb_checkpoint_unlock(THD * thd) {\n    int error;\n    const char *old_proc_info;\n    tokudb_trx_data* trx = (tokudb_trx_data*)thd_get_ha_data(thd, tokudb_hton);\n    if (!trx) {\n        error = 0;\n        goto  cleanup;\n    }\n    if (!trx->checkpoint_lock_taken) {\n        error = 0;\n        goto  cleanup;\n    }\n    //\n    // at this point, we know the checkpoint lock has been taken\n    //\n    old_proc_info = tokudb_thd_get_proc_info(thd);\n    thd_proc_info(thd, \"Trying to release checkpointing lock.\");\n    error = db_env->checkpointing_resume(db_env);\n    assert_always(!error);\n    thd_proc_info(thd, old_proc_info);\n\n    trx->checkpoint_lock_taken = false;\n    \ncleanup:\n    return;\n}\n\nstatic bool tokudb_show_status(\n    handlerton* hton,\n    THD* thd,\n    stat_print_fn* stat_print,\n    enum ha_stat_type stat_type) {\n\n    switch (stat_type) {\n    case HA_ENGINE_STATUS:\n        return tokudb_show_engine_status(thd, stat_print);\n        break;\n    default:\n        break;\n    }\n    return false;\n}\n\n#if TOKU_INCLUDE_HANDLERTON_HANDLE_FATAL_SIGNAL\nstatic void tokudb_handle_fatal_signal(\n    TOKUDB_UNUSED(handlerton* hton),\n    TOKUDB_UNUSD(THD* thd),\n    int sig) {\n\n    if (tokudb_gdb_on_fatal) {\n        db_env_try_gdb_stack_trace(tokudb_gdb_path);\n    }\n}\n#endif\n\nstatic void tokudb_print_error(\n    const DB_ENV* db_env,\n    const char* db_errpfx,\n    const char* buffer) {\n    sql_print_error(\"%s: %s\", db_errpfx, buffer);\n}\n\nstatic void tokudb_cleanup_log_files(void) {\n    TOKUDB_DBUG_ENTER(\"\");\n    char **names;\n    int error;\n\n    if ((error = db_env->txn_checkpoint(db_env, 0, 0, 0)))\n        my_error(ER_ERROR_DURING_CHECKPOINT, MYF(0), error);\n\n    if ((error = db_env->log_archive(db_env, &names, 0)) != 0) {\n        DBUG_PRINT(\"error\", (\"log_archive failed (error %d)\", error));\n        db_env->err(db_env, error, \"log_archive\");\n        DBUG_VOID_RETURN;\n    }\n\n    if (names) {\n        char **np;\n        for (np = names; *np; ++np) {\n#if 1\n            if (TOKUDB_UNLIKELY(tokudb::sysvars::debug))\n                TOKUDB_TRACE(\"cleanup:%s\", *np);\n#else\n            my_delete(*np, MYF(MY_WME));\n#endif\n        }\n\n        free(names);\n    }\n\n    DBUG_VOID_RETURN;\n}\n\n// Split ./database/table-dictionary into database, table and dictionary strings\nvoid tokudb_split_dname(\n    const char* dname,\n    String& database_name,\n    String& table_name,\n    String& dictionary_name) {\n\n    const char *splitter = strchr(dname, '/');\n    if (splitter) {\n        const char *database_ptr = splitter+1;\n        const char *table_ptr = strchr(database_ptr, '/');\n        if (table_ptr) {\n            database_name.append(database_ptr, table_ptr - database_ptr);\n            table_ptr += 1;\n            const char *dictionary_ptr = strchr(table_ptr, '-');\n            if (dictionary_ptr) {\n                table_name.append(table_ptr, dictionary_ptr - table_ptr);\n                dictionary_ptr += 1;\n                dictionary_name.append(dictionary_ptr);\n            } else {\n                table_name.append(table_ptr);\n            }\n        } else {\n            database_name.append(database_ptr);\n        }\n    }\n}\n\nstruct st_mysql_storage_engine tokudb_storage_engine = {\n    MYSQL_HANDLERTON_INTERFACE_VERSION\n};\n\n#if TOKU_INCLUDE_LOCK_TIMEOUT_QUERY_STRING\nstruct tokudb_search_txn_extra {\n    bool match_found;\n    uint64_t match_txn_id;\n    uint64_t match_client_id;\n};\n\nstatic int tokudb_search_txn_callback(\n    DB_TXN* txn,\n    iterate_row_locks_callback iterate_locks,\n    void* locks_extra,\n    void* extra) {\n\n    uint64_t txn_id = txn->id64(txn);\n    uint64_t client_id;\n    void *client_extra;\n    txn->get_client_id(txn, &client_id, &client_extra);\n    struct tokudb_search_txn_extra* e =\n        reinterpret_cast<struct tokudb_search_txn_extra*>(extra);\n    if (e->match_txn_id == txn_id) {\n        e->match_found = true;\n        e->match_client_id = client_id;\n        return 1;\n    }\n    return 0;\n}\n\nstatic bool tokudb_txn_id_to_client_id(\n    THD* thd,\n    uint64_t blocking_txnid,\n    uint64_t* blocking_client_id) {\n\n    struct tokudb_search_txn_extra e = {\n        false,\n        blocking_txnid,\n        0\n    };\n    db_env->iterate_live_transactions(db_env, tokudb_search_txn_callback, &e);\n    if (e.match_found) {\n        *blocking_client_id = e.match_client_id;\n    }\n    return e.match_found;\n}\n#endif\n\nstatic void tokudb_pretty_key(\n    const DB* db,\n    const DBT* key,\n    const char* default_key,\n    String* out) {\n\n    if (key->data == NULL) {\n        out->append(default_key);\n    } else {\n        bool do_hexdump = true;\n        if (do_hexdump) {\n            // hexdump the key\n            const unsigned char* data =\n                reinterpret_cast<const unsigned char*>(key->data);\n            for (size_t i = 0; i < key->size; i++) {\n                char str[3];\n                snprintf(str, sizeof str, \"%2.2x\", data[i]);\n                out->append(str);\n            }\n        }\n    }\n}\n\nvoid tokudb_pretty_left_key(const DB* db, const DBT* key, String* out) {\n    tokudb_pretty_key(db, key, \"-infinity\", out);\n}\n\nvoid tokudb_pretty_right_key(const DB* db, const DBT* key, String* out) {\n    tokudb_pretty_key(db, key, \"+infinity\", out);\n}\n\nconst char* tokudb_get_index_name(DB* db) {\n    if (db != NULL) {\n        return db->get_dname(db);\n    } else {\n        return \"$ydb_internal\";\n    }\n}\n\nstatic int tokudb_equal_key(const DBT *left_key, const DBT *right_key) {\n    if (left_key->data == NULL || right_key->data == NULL ||\n        left_key->size != right_key->size)\n        return 0;\n    else\n        return memcmp(left_key->data, right_key->data, left_key->size) == 0;\n}\n\nstatic void tokudb_lock_timeout_callback(\n    DB* db,\n    uint64_t requesting_txnid,\n    const DBT* left_key,\n    const DBT* right_key,\n    uint64_t blocking_txnid) {\n\n    THD* thd = current_thd;\n    if (!thd)\n        return;\n    ulong lock_timeout_debug = tokudb::sysvars::lock_timeout_debug(thd);\n    if (lock_timeout_debug != 0) {\n        // generate a JSON document with the lock timeout info\n        String log_str;\n        log_str.append(\"{\");\n        uint64_t mysql_thread_id = thd->thread_id;\n        log_str.append(\"\\\"mysql_thread_id\\\":\");\n        log_str.append_ulonglong(mysql_thread_id);\n        log_str.append(\", \\\"dbname\\\":\");\n        log_str.append(\"\\\"\");\n        log_str.append(tokudb_get_index_name(db));\n        log_str.append(\"\\\"\");\n        log_str.append(\", \\\"requesting_txnid\\\":\");\n        log_str.append_ulonglong(requesting_txnid);\n        log_str.append(\", \\\"blocking_txnid\\\":\");\n        log_str.append_ulonglong(blocking_txnid);\n        if (tokudb_equal_key(left_key, right_key)) {\n            String key_str;\n            tokudb_pretty_key(db, left_key, \"?\", &key_str);\n            log_str.append(\", \\\"key\\\":\");\n            log_str.append(\"\\\"\");\n            log_str.append(key_str);\n            log_str.append(\"\\\"\");\n        } else {\n            String left_str;\n            tokudb_pretty_left_key(db, left_key, &left_str);\n            log_str.append(\", \\\"key_left\\\":\");\n            log_str.append(\"\\\"\");\n            log_str.append(left_str);\n            log_str.append(\"\\\"\");\n            String right_str;\n            tokudb_pretty_right_key(db, right_key, &right_str);\n            log_str.append(\", \\\"key_right\\\":\");\n            log_str.append(\"\\\"\");\n            log_str.append(right_str);\n            log_str.append(\"\\\"\");\n        }\n        log_str.append(\"}\");\n        // set last_lock_timeout\n        if (lock_timeout_debug & 1) {\n            char* old_lock_timeout = tokudb::sysvars::last_lock_timeout(thd);\n            char* new_lock_timeout =\n                tokudb::memory::strdup(log_str.c_ptr(), MY_FAE);\n            tokudb::sysvars::set_last_lock_timeout(thd, new_lock_timeout);\n#if TOKU_THDVAR_MEMALLOC_BUG\n            tokudb_map_mutex.lock();\n            struct tokudb_map_pair old_key = { thd, old_lock_timeout };\n            tree_delete(&tokudb_map, &old_key, sizeof old_key, NULL);\n            struct tokudb_map_pair new_key = { thd, new_lock_timeout };\n            tree_insert(&tokudb_map, &new_key, sizeof new_key, NULL);\n            tokudb_map_mutex.unlock();\n#endif\n            tokudb::memory::free(old_lock_timeout);\n        }\n        // dump to stderr\n        if (lock_timeout_debug & 2) {\n            sql_print_error(\n                \"%s: lock timeout %s\",\n                tokudb_hton_name,\n                log_str.c_ptr());\n            LEX_STRING *qs = thd_query_string(thd);\n            sql_print_error(\n                \"%s: requesting_thread_id:%\" PRIu64 \" q:%.*s\",\n                tokudb_hton_name,\n                mysql_thread_id,\n                (int)qs->length,\n                qs->str);\n#if TOKU_INCLUDE_LOCK_TIMEOUT_QUERY_STRING\n            uint64_t blocking_thread_id = 0;\n            if (tokudb_txn_id_to_client_id(\n                    thd,\n                    blocking_txnid,\n                    &blocking_thread_id)) {\n\n                String blocking_qs;\n                if (get_thread_query_string(\n                        blocking_thread_id,\n                        blocking_qs) == 0) {\n\n                    sql_print_error(\n                        \"%s: blocking_thread_id:%\" PRIu64 \" q:%.*s\",\n                        tokudb_hton_name,\n                        blocking_thread_id,\n                        blocking_qs.length(),\n                        blocking_qs.c_ptr());\n                }\n            }\n#endif\n        }\n    }\n}\n\nextern \"C\" int thd_rpl_deadlock_check(MYSQL_THD thd, MYSQL_THD other_thd);\n\nstruct tokudb_search_txn_thd {\n    bool match_found;\n    uint64_t match_txn_id;\n    THD *match_client_thd;\n};\n\nstatic int tokudb_search_txn_thd_callback(\n    DB_TXN* txn,\n    iterate_row_locks_callback iterate_locks,\n    void* locks_extra,\n    void* extra) {\n\n    uint64_t txn_id = txn->id64(txn);\n    uint64_t client_id;\n    void *client_extra;\n    txn->get_client_id(txn, &client_id, &client_extra);\n    struct tokudb_search_txn_thd* e =\n        reinterpret_cast<struct tokudb_search_txn_thd*>(extra);\n    if (e->match_txn_id == txn_id) {\n        e->match_found = true;\n        e->match_client_thd = reinterpret_cast<THD *>(client_extra);\n        return 1;\n    }\n    return 0;\n}\n\nstatic bool tokudb_txn_id_to_thd(\n    uint64_t txnid,\n    THD **out_thd) {\n\n    struct tokudb_search_txn_thd e = {\n        false,\n        txnid,\n        0\n    };\n    db_env->iterate_live_transactions(db_env, tokudb_search_txn_thd_callback, &e);\n    if (e.match_found) {\n        *out_thd = e.match_client_thd;\n    }\n    return e.match_found;\n}\n\nstatic void tokudb_lock_wait_needed_callback(\n    void *arg,\n    uint64_t requesting_txnid,\n    uint64_t blocking_txnid) {\n\n    THD *requesting_thd;\n    THD *blocking_thd;\n    if (tokudb_txn_id_to_thd(requesting_txnid, &requesting_thd) &&\n        tokudb_txn_id_to_thd(blocking_txnid, &blocking_thd)) {\n        thd_rpl_deadlock_check (requesting_thd, blocking_thd);\n    }\n}\n\n// Retrieves variables for information_schema.global_status.\n// Names (columnname) are automatically converted to upper case,\n// and prefixed with \"TOKUDB_\"\nstatic int show_tokudb_vars(THD *thd, SHOW_VAR *var, char *buff) {\n    TOKUDB_DBUG_ENTER(\"\");\n\n    int error;\n    uint64_t panic;\n    const int panic_string_len = 1024;\n    char panic_string[panic_string_len] = {'\\0'};\n    fs_redzone_state redzone_state;\n\n    uint64_t num_rows;\n    error = db_env->get_engine_status(\n        db_env,\n        toku_global_status_rows,\n        toku_global_status_max_rows,\n        &num_rows,\n        &redzone_state,\n        &panic,\n        panic_string,\n        panic_string_len,\n        TOKU_GLOBAL_STATUS);\n    //TODO: Maybe do something with the panic output?\n    if (error == 0) {\n        assert_always(num_rows <= toku_global_status_max_rows);\n        //TODO: Maybe enable some of the items here: (copied from engine status\n\n        //TODO: (optionally) add redzone state, panic, panic string, etc.\n        //Right now it's being ignored.\n\n        for (uint64_t row = 0; row < num_rows; row++) {\n            SHOW_VAR &status_var = toku_global_status_variables[row];\n            TOKU_ENGINE_STATUS_ROW_S &status_row = toku_global_status_rows[row];\n\n            status_var.name = status_row.columnname;\n            switch (status_row.type) {\n            case FS_STATE:\n            case UINT64:\n                status_var.type = SHOW_LONGLONG;\n                status_var.value = (char*)&status_row.value.num;\n                break;\n            case CHARSTR:\n                status_var.type = SHOW_CHAR;\n                status_var.value = (char*)status_row.value.str;\n                break;\n            case UNIXTIME: {\n                status_var.type = SHOW_CHAR;\n                time_t t = status_row.value.num;\n                char tbuf[26];\n                // Reuse the memory in status_row. (It belongs to us).\n                snprintf(\n                    status_row.value.datebuf,\n                    sizeof(status_row.value.datebuf),\n                    \"%.24s\",\n                    ctime_r(&t, tbuf));\n                status_var.value = (char*)&status_row.value.datebuf[0];\n                break;\n            }\n            case TOKUTIME:\n                status_var.type = SHOW_DOUBLE;\n                // Reuse the memory in status_row. (It belongs to us).\n                status_row.value.dnum = tokutime_to_seconds(status_row.value.num);\n                status_var.value = (char*)&status_row.value.dnum;\n                break;\n            case PARCOUNT: {\n                status_var.type = SHOW_LONGLONG;\n                uint64_t v = read_partitioned_counter(status_row.value.parcount);\n                // Reuse the memory in status_row. (It belongs to us).\n                status_row.value.num = v;\n                status_var.value = (char*)&status_row.value.num;\n                break;\n            }\n            case DOUBLE:\n                status_var.type = SHOW_DOUBLE;\n                status_var.value = (char*) &status_row.value.dnum;\n                break;\n            default:\n                status_var.type = SHOW_CHAR;\n                // Reuse the memory in status_row.datebuf. (It belongs to us).\n                // UNKNOWN TYPE: %d fits in 26 bytes (sizeof datebuf) for any integer.\n                snprintf(\n                    status_row.value.datebuf,\n                    sizeof(status_row.value.datebuf),\n                    \"UNKNOWN TYPE: %d\",\n                    status_row.type);\n                status_var.value = (char*)&status_row.value.datebuf[0];\n                break;\n            }\n        }\n        // Sentinel value at end.\n        toku_global_status_variables[num_rows].type = SHOW_LONG;\n        toku_global_status_variables[num_rows].value = (char*)NullS;\n        toku_global_status_variables[num_rows].name = (char*)NullS;\n\n        var->type= SHOW_ARRAY;\n        var->value= (char *) toku_global_status_variables;\n    }\n    if (error) { my_errno = error; }\n    TOKUDB_DBUG_RETURN(error);\n}\n\nstatic SHOW_VAR toku_global_status_variables_export[]= {\n    {\"Tokudb\", (char*)&show_tokudb_vars, SHOW_FUNC},\n    {NullS, NullS, SHOW_LONG}\n};\n\n#if TOKU_INCLUDE_BACKTRACE\n#include <execinfo.h>\nstatic void tokudb_backtrace(void) {\n    const int N_POINTERS = 30;\n    void *backtrace_pointers[N_POINTERS];\n    int n = backtrace(backtrace_pointers, N_POINTERS);\n    backtrace_symbols_fd(backtrace_pointers, n, fileno(stderr));\n}\n#endif\n\n#ifdef MARIA_PLUGIN_INTERFACE_VERSION\nmaria_declare_plugin(tokudb) \n#else\nmysql_declare_plugin(tokudb) \n#endif\n    {\n        MYSQL_STORAGE_ENGINE_PLUGIN,\n        &tokudb_storage_engine,\n        tokudb_hton_name,\n        \"Percona\",\n        \"Percona TokuDB Storage Engine with Fractal Tree(tm) Technology\",\n        PLUGIN_LICENSE_GPL,\n        tokudb_init_func,          /* plugin init */\n        tokudb_done_func,          /* plugin deinit */\n        TOKUDB_PLUGIN_VERSION,\n        toku_global_status_variables_export,  /* status variables */\n        tokudb::sysvars::system_variables,   /* system variables */\n#ifdef MARIA_PLUGIN_INTERFACE_VERSION\n        tokudb::sysvars::version,\n        MariaDB_PLUGIN_MATURITY_STABLE /* maturity */\n#else\n        NULL,                      /* config options */\n        0,                         /* flags */\n#endif\n    },\n    tokudb::information_schema::trx,\n    tokudb::information_schema::lock_waits,\n    tokudb::information_schema::locks,\n    tokudb::information_schema::file_map,\n    tokudb::information_schema::fractal_tree_info,\n    tokudb::information_schema::fractal_tree_block_map,\n    tokudb::information_schema::background_job_status\n#ifdef MARIA_PLUGIN_INTERFACE_VERSION\nmaria_declare_plugin_end;\n#else\nmysql_declare_plugin_end;\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/third_party/snappy-1.1.2/ltmain.sh": "\n# libtool (GNU libtool) 2.4.2\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --no-warn            don't display warning messages\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool) 2.4.2 Debian-2.4.2-1ubuntu1\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n# GNU libtool home page: <http://www.gnu.org/software/libtool/>.\n# General help using GNU software: <http://www.gnu.org/gethelp/>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.2 Debian-2.4.2-1ubuntu1\"\nTIMESTAMP=\"\"\npackage_revision=1.3337\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\nLC_ALL=C\nLANGUAGE=C\nexport LANGUAGE LC_ALL\n\n$lt_unset CDPATH\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\ntest \"${ECHO+set}\" = set || ECHO=${as_echo-'printf %s\\n'}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n    func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n} # func_dirname may be replaced by extended shell implementation\n\n\n# func_basename file\nfunc_basename ()\n{\n    func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n} # func_basename may be replaced by extended shell implementation\n\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n    # Extract subdirectory from the argument.\n    func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n    func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n} # func_dirname_and_basename may be replaced by extended shell implementation\n\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n    case ${2} in\n      .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n    esac\n} # func_stripname may be replaced by extended shell implementation\n\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s,[].[^$\\\\*\\/],\\\\&,g'\n\n# Sed substitution that converts a w32 file name or path\n# which contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nlt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }$*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }\"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname: ${opt_mode+$opt_mode: }warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n# func_tr_sh\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n  case $1 in\n  [0-9]* | *[!a-zA-Z0-9_]*)\n    func_tr_sh_result=`$ECHO \"$1\" | $SED 's/^\\([0-9]\\)/_\\1/; s/[^a-zA-Z0-9_]/_/g'`\n    ;;\n  * )\n    func_tr_sh_result=$1\n    ;;\n  esac\n}\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $opt_debug\n\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# / /\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/^#  *.*--help/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n\t:print\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n\td\n     }\n     /^# .* home page:/b print\n     /^# General help using/b print\n     ' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $opt_debug\n\n    func_error \"missing argument for $1.\"\n    exit_cmd=exit\n}\n\n\n# func_split_short_opt shortopt\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nfunc_split_short_opt ()\n{\n    my_sed_short_opt='1s/^\\(..\\).*$/\\1/;q'\n    my_sed_short_rest='1s/^..\\(.*\\)$/\\1/;q'\n\n    func_split_short_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_short_opt\"`\n    func_split_short_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_short_rest\"`\n} # func_split_short_opt may be replaced by extended shell implementation\n\n\n# func_split_long_opt longopt\n# Set func_split_long_opt_name and func_split_long_opt_arg shell\n# variables after splitting LONGOPT at the `=' sign.\nfunc_split_long_opt ()\n{\n    my_sed_long_opt='1s/^\\(--[^=]*\\)=.*/\\1/;q'\n    my_sed_long_arg='1s/^--[^=]*=//'\n\n    func_split_long_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_long_opt\"`\n    func_split_long_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_long_arg\"`\n} # func_split_long_opt may be replaced by extended shell implementation\n\nexit_cmd=:\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\nnonopt=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n    eval \"${1}=\\$${1}\\${2}\"\n} # func_append may be replaced by extended shell implementation\n\n# func_append_quoted var value\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nfunc_append_quoted ()\n{\n    func_quote_for_eval \"${2}\"\n    eval \"${1}=\\$${1}\\\\ \\$func_quote_for_eval_result\"\n} # func_append_quoted may be replaced by extended shell implementation\n\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n    func_arith_result=`expr \"${@}\"`\n} # func_arith may be replaced by extended shell implementation\n\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n    func_len_result=`expr \"${1}\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n} # func_len may be replaced by extended shell implementation\n\n\n# func_lo2o object\nfunc_lo2o ()\n{\n    func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n} # func_lo2o may be replaced by extended shell implementation\n\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n    func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[^.]*$/.lo/'`\n} # func_xform may be replaced by extended shell implementation\n\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n# Shorthand for --mode=foo, only valid as the first argument\ncase $1 in\nclean|clea|cle|cl)\n  shift; set dummy --mode clean ${1+\"$@\"}; shift\n  ;;\ncompile|compil|compi|comp|com|co|c)\n  shift; set dummy --mode compile ${1+\"$@\"}; shift\n  ;;\nexecute|execut|execu|exec|exe|ex|e)\n  shift; set dummy --mode execute ${1+\"$@\"}; shift\n  ;;\nfinish|finis|fini|fin|fi|f)\n  shift; set dummy --mode finish ${1+\"$@\"}; shift\n  ;;\ninstall|instal|insta|inst|ins|in|i)\n  shift; set dummy --mode install ${1+\"$@\"}; shift\n  ;;\nlink|lin|li|l)\n  shift; set dummy --mode link ${1+\"$@\"}; shift\n  ;;\nuninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n  shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n  ;;\nesac\n\n\n\n# Option defaults:\nopt_debug=:\nopt_dry_run=false\nopt_config=false\nopt_preserve_dup_deps=false\nopt_features=false\nopt_finish=false\nopt_help=false\nopt_help_all=false\nopt_silent=:\nopt_warning=:\nopt_verbose=:\nopt_silent=false\nopt_verbose=false\n\n\n# Parse options once, thoroughly.  This comes as soon as possible in the\n# script to make things like `--version' happen as quickly as we can.\n{\n  # this just eases exit handling\n  while test $# -gt 0; do\n    opt=\"$1\"\n    shift\n    case $opt in\n      --debug|-x)\topt_debug='set -x'\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\t$opt_debug\n\t\t\t;;\n      --dry-run|--dryrun|-n)\n\t\t\topt_dry_run=:\n\t\t\t;;\n      --config)\n\t\t\topt_config=:\nfunc_config\n\t\t\t;;\n      --dlopen|-dlopen)\n\t\t\toptarg=\"$1\"\n\t\t\topt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$optarg\"\n\t\t\tshift\n\t\t\t;;\n      --preserve-dup-deps)\n\t\t\topt_preserve_dup_deps=:\n\t\t\t;;\n      --features)\n\t\t\topt_features=:\nfunc_features\n\t\t\t;;\n      --finish)\n\t\t\topt_finish=:\nset dummy --mode finish ${1+\"$@\"}; shift\n\t\t\t;;\n      --help)\n\t\t\topt_help=:\n\t\t\t;;\n      --help-all)\n\t\t\topt_help_all=:\nopt_help=': help-all'\n\t\t\t;;\n      --mode)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_mode=\"$optarg\"\ncase $optarg in\n  # Valid mode arguments:\n  clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n  # Catch anything else as an error\n  *) func_error \"invalid argument for $opt\"\n     exit_cmd=exit\n     break\n     ;;\nesac\n\t\t\tshift\n\t\t\t;;\n      --no-silent|--no-quiet)\n\t\t\topt_silent=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-warning|--no-warn)\n\t\t\topt_warning=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-verbose)\n\t\t\topt_verbose=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --silent|--quiet)\n\t\t\topt_silent=:\nfunc_append preserve_args \" $opt\"\n        opt_verbose=false\n\t\t\t;;\n      --verbose|-v)\n\t\t\topt_verbose=:\nfunc_append preserve_args \" $opt\"\nopt_silent=false\n\t\t\t;;\n      --tag)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_tag=\"$optarg\"\nfunc_append preserve_args \" $opt $optarg\"\nfunc_enable_tag \"$optarg\"\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t;;\n      --help)\t\tfunc_help\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t;;\n\n      # Separate optargs to long options:\n      --*=*)\n\t\t\tfunc_split_long_opt \"$opt\"\n\t\t\tset dummy \"$func_split_long_opt_name\" \"$func_split_long_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      # Separate non-argument short options:\n      -\\?*|-h*|-n*|-v*)\n\t\t\tfunc_split_short_opt \"$opt\"\n\t\t\tset dummy \"$func_split_short_opt_name\" \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      --)\t\tbreak\t\t\t\t\t;;\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\" ;;\n      *)\t\tset dummy \"$opt\" ${1+\"$@\"};\tshift; break  ;;\n    esac\n  done\n\n  # Validate options:\n\n  # save first non-option argument\n  if test \"$#\" -gt 0; then\n    nonopt=\"$opt\"\n    shift\n  fi\n\n  # preserve --debug\n  test \"$opt_debug\" = : || func_append preserve_args \" --debug\"\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n      ;;\n  esac\n\n  $opt_help || {\n    # Sanity checks first:\n    func_check_version_match\n\n    if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n      func_fatal_configuration \"not configured to build any kind of library\"\n    fi\n\n    # Darwin sucks\n    eval std_shrext=\\\"$shrext_cmds\\\"\n\n    # Only execute mode is allowed to have -dlopen flags.\n    if test -n \"$opt_dlopen\" && test \"$opt_mode\" != execute; then\n      func_error \"unrecognized option \\`-dlopen'\"\n      $ECHO \"$help\" 1>&2\n      exit $EXIT_FAILURE\n    fi\n\n    # Change the help message to a mode-specific one.\n    generic_help=\"$help\"\n    help=\"Try \\`$progname --help --mode=$opt_mode' for more information.\"\n  }\n\n\n  # Bail if the options were screwed\n  $exit_cmd $EXIT_FAILURE\n}\n\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case \"$lt_sysroot:$1\" in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result=\"=$func_stripname_result\"\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $opt_debug\n  func_convert_core_file_wine_to_w32_result=\"$1\"\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"${func_convert_core_file_wine_to_w32_tmp}\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$lt_sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $opt_debug\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\"\"\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\" ; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=\"$func_convert_core_file_wine_to_w32_result\"\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $opt_debug\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: \\`$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $opt_debug\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $opt_debug\n  if test -z \"$2\" && test -n \"$1\" ; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  \\`$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=\"$1\"\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $opt_debug\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  \\`$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=\"$3\"\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $opt_debug\n  case $4 in\n  $1 ) func_to_host_path_result=\"$3$func_to_host_path_result\"\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via `$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $opt_debug\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $opt_debug\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=\"$1\"\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_msys_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_file_wine_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via `$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $opt_debug\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=\"func_convert_path_${func_stripname_result}\"\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $opt_debug\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=\"$1\"\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_msys_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_path_wine_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$opt_mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"\\`$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument \\`$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and \\`=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  sed -e \"${sysroot_cmd} s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the \\`$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest \"$opt_mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from \\`$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\"\"\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\" ; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=\"$func_basename_result\"\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\" ; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n      win32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $opt_debug\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $opt_debug\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive which possess that section. Heuristic: eliminate\n    # all those which have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $opt_debug\n  if func_cygming_gnu_implib_p \"$1\" ; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\" ; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\"\"\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ which is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options which match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"${outputname}:${output}:\\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#if defined(LT_DEBUGWRAPPER)\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nvolatile const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (strcmp (argv[i], debug_opt) == 0)\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps ; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test \"$prefer_static_libs\" = yes ||\n\t     test \"$prefer_static_libs,$installed\" = \"built,no\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=\"$l\"\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$lt_sysroot$libdir\"\n\t    absdir=\"$lt_sysroot$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  case \"$host\" in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      func_append linker_flags \" -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type \\`$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      func_append libobjs \" $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$opt_mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest \"$want_nocaseglob\" = yes && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test \"$want_nocaseglob\" = yes; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\t# Remove ${wl} instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$opt_mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$opt_mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test \"$try_normal_branch\" = yes \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=${output_objdir}/${output_la}.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$opt_mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$opt_mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test \"$build_libtool_libs\" != yes && libobjs=\"$non_pic_objects\"\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" ${wl}-bind_at_load\"\n\t      func_append finalize_command \" ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    func_append oldobjs \" $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$opt_mode\" = link || test \"$opt_mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=yes ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\todir=\"$objdir\"\n      else\n\todir=\"$dir/$objdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$opt_mode\" = uninstall && odir=\"$dir\"\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test \"$opt_mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case \"$opt_mode\" in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$opt_mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      func_append rmfiles \" $odir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$opt_mode\" = uninstall || test \"$opt_mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$opt_mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/third_party/snappy-1.1.2/aclocal.m4": "# generated automatically by aclocal 1.11.3 -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n# Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\nm4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,\n[m4_warning([this file was generated for autoconf 2.68.\nYou have another version of autoconf.  It may work, but is not guaranteed to.\nIf you have problems, you may need to regenerate the build system entirely.\nTo do so, use the procedure documented by the package, typically `autoreconf'.])])\n\n# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 57 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_REPLACE_SHELLFNS\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test $_lt_result -eq 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test \"${lt_cv_aix_libpath+set}\" = set; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=\"/usr/lib:/lib\"\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[  --with-sysroot[=DIR] Search for dependent libraries within DIR\n                        (or the compiler's sysroot if not specified).],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase ${with_sysroot} in #(\n yes)\n   if test \"$GCC\" = yes; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([${with_sysroot}])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and in which our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_i386\"\n\t    ;;\n\t  ppc64-*linux*|powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  ppc*-*linux*|powerpc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\n*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=\"${LD-ld}_sol2\"\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test \"$ac_status\" -eq 0; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test \"$ac_status\" -ne 0; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test \"x$lt_cv_ar_at_file\" = xno; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n    library_names_spec='${libname}.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=\"$LIB\"\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test \"$GCC\" != yes; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh\n  # decide which to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=\"$ECHO\"\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test \"x$lt_cv_path_mainfest_tool\" != xyes; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    sed -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t  else\n\t    sed -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t  fi~\n\t  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t  linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t  lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t  case $lt_outputfile in\n\t    *.exe|*.EXE) ;;\n\t    *)\n\t      lt_outputfile=\"$lt_outputfile.exe\"\n\t      lt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t      ;;\n\t  esac~\n\t  if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t    $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t    $RM \"$lt_outputfile.manifest\";\n\t  fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=\"$LDFLAGS\"\n\t   LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=\"$save_LDFLAGS\"])\n\tif test \"$lt_cv_irix_exported_symbol\" = yes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n\tfi\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=\".dll\"\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      $SED -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t    else\n\t      $SED -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t    fi~\n\t    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t    linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t    lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t    case $lt_outputfile in\n\t      *.exe|*.EXE) ;;\n\t      *)\n\t\tlt_outputfile=\"$lt_outputfile.exe\"\n\t\tlt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t\t;;\n\t    esac~\n\t    func_to_tool_file \"$lt_outputfile\"~\n\t    if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t      $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t      $RM \"$lt_outputfile.manifest\";\n\t    fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file (1st line\n\t    # is EXPORTS), use it as is; otherwise, prepend...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      cp $export_symbols $output_objdir/$soname.def;\n\t    else\n\t      echo EXPORTS > $output_objdir/$soname.def;\n\t      cat $export_symbols >> $output_objdir/$soname.def;\n\t    fi~\n\t    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case ${2} in\n  .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case ${prev}${p} in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case ${prev} in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC* | sunCC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\n  CFLAGS=\"$lt_save_CFLAGS\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,b/c, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)\n# ------------------------------------------------------\n# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and\n# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.\nm4_defun([_LT_PROG_FUNCTION_REPLACE],\n[dnl {\nsed -e '/^$1 ()$/,/^} # $1 /c\\\n$1 ()\\\n{\\\nm4_bpatsubsts([$2], [$], [\\\\], [^\\([\t ]\\)], [\\\\\\1])\n} # Extended-shell $1 implementation' \"$cfgfile\" > $cfgfile.tmp \\\n  && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\ntest 0 -eq $? || _lt_function_replace_fail=:\n])\n\n\n# _LT_PROG_REPLACE_SHELLFNS\n# -------------------------\n# Replace existing portable implementations of several shell functions with\n# equivalent extended shell implementations where those features are available..\nm4_defun([_LT_PROG_REPLACE_SHELLFNS],\n[if test x\"$xsi_shell\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary parameter first.\n    func_stripname_result=${3}\n    func_stripname_result=${func_stripname_result#\"${1}\"}\n    func_stripname_result=${func_stripname_result%\"${2}\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl\n    func_split_long_opt_name=${1%%=*}\n    func_split_long_opt_arg=${1#*=}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl\n    func_split_short_opt_arg=${1#??}\n    func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl\n    case ${1} in\n      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n      *)    func_lo2o_result=${1} ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])\n\n  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])\n\n  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])\nfi\n\nif test x\"$lt_shell_append\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval \"${1}+=\\\\${2}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl\n    func_quote_for_eval \"${2}\"\ndnl m4 expansion turns \\\\\\\\ into \\\\, and then the shell eval turns that into \\\n    eval \"${1}+=\\\\\\\\ \\\\$func_quote_for_eval_result\"])\n\n  # Save a `func_append' function call where possible by direct use of '+='\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1+=\"%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nelse\n  # Save a `func_append' function call even when '+=' is not available\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1=\"$\\1%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nfi\n\nif test x\"$_lt_function_replace_fail\" = x\":\"; then\n  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])\nfi\n])\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine which file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n\n# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,\n#   Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 7 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option `$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl `shared' nor `disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n  \t\t   [_LT_ENABLE_FAST_INSTALL])\n  ])\n])# _LT_SET_OPTIONS\n\n\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [1], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the `shared' and\n# `disable-shared' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the `static' and\n# `disable-static' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the `fast-install'\n# and `disable-fast-install' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the `pic-only' and `no-pic'\n# LT_INIT options.\n# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [lt_p=${PACKAGE-default}\n    case $withval in\n    yes|no) pic_mode=$withval ;;\n    *)\n      pic_mode=default\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for lt_pkg in $withval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$lt_pkg\" = \"X$lt_p\"; then\n\t  pic_mode=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [pic_mode=default])\n\ntest -z \"$pic_mode\" && pic_mode=m4_default([$1], [default])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n\n# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-\n#\n# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n# Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 6 ltsugar.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])\n\n\n# lt_join(SEP, ARG1, [ARG2...])\n# -----------------------------\n# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their\n# associated separator.\n# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier\n# versions in m4sugar had bugs.\nm4_define([lt_join],\n[m4_if([$#], [1], [],\n       [$#], [2], [[$2]],\n       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])\nm4_define([_lt_join],\n[m4_if([$#$2], [2], [],\n       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])\n\n\n# lt_car(LIST)\n# lt_cdr(LIST)\n# ------------\n# Manipulate m4 lists.\n# These macros are necessary as long as will still need to support\n# Autoconf-2.59 which quotes differently.\nm4_define([lt_car], [[$1]])\nm4_define([lt_cdr],\n[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],\n       [$#], 1, [],\n       [m4_dquote(m4_shift($@))])])\nm4_define([lt_unquote], $1)\n\n\n# lt_append(MACRO-NAME, STRING, [SEPARATOR])\n# ------------------------------------------\n# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.\n# Note that neither SEPARATOR nor STRING are expanded; they are appended\n# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).\n# No SEPARATOR is output if MACRO-NAME was previously undefined (different\n# than defined and empty).\n#\n# This macro is needed until we can rely on Autoconf 2.62, since earlier\n# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.\nm4_define([lt_append],\n[m4_define([$1],\n\t   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])\n\n\n\n# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])\n# ----------------------------------------------------------\n# Produce a SEP delimited list of all paired combinations of elements of\n# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list\n# has the form PREFIXmINFIXSUFFIXn.\n# Needed until we can rely on m4_combine added in Autoconf 2.62.\nm4_define([lt_combine],\n[m4_if(m4_eval([$# > 3]), [1],\n       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl\n[[m4_foreach([_Lt_prefix], [$2],\n\t     [m4_foreach([_Lt_suffix],\n\t\t]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,\n\t[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])\n\n\n# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])\n# -----------------------------------------------------------------------\n# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited\n# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.\nm4_define([lt_if_append_uniq],\n[m4_ifdef([$1],\n\t  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],\n\t\t [lt_append([$1], [$2], [$3])$4],\n\t\t [$5])],\n\t  [lt_append([$1], [$2], [$3])$4])])\n\n\n# lt_dict_add(DICT, KEY, VALUE)\n# -----------------------------\nm4_define([lt_dict_add],\n[m4_define([$1($2)], [$3])])\n\n\n# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)\n# --------------------------------------------\nm4_define([lt_dict_add_subkey],\n[m4_define([$1($2:$3)], [$4])])\n\n\n# lt_dict_fetch(DICT, KEY, [SUBKEY])\n# ----------------------------------\nm4_define([lt_dict_fetch],\n[m4_ifval([$3],\n\tm4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),\n    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])\n\n\n# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])\n# -----------------------------------------------------------------\nm4_define([lt_if_dict_fetch],\n[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],\n\t[$5],\n    [$6])])\n\n\n# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])\n# --------------------------------------------------------------\nm4_define([lt_dict_filter],\n[m4_if([$5], [], [],\n  [lt_join(m4_quote(m4_default([$4], [[, ]])),\n           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),\n\t\t      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl\n])\n\n# ltversion.m4 -- version numbers\t\t\t-*- Autoconf -*-\n#\n#   Copyright (C) 2004 Free Software Foundation, Inc.\n#   Written by Scott James Remnant, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# @configure_input@\n\n# serial 3337 ltversion.m4\n# This file is part of GNU Libtool\n\nm4_define([LT_PACKAGE_VERSION], [2.4.2])\nm4_define([LT_PACKAGE_REVISION], [1.3337])\n\nAC_DEFUN([LTVERSION_VERSION],\n[macro_version='2.4.2'\nmacro_revision='1.3337'\n_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])\n_LT_DECL(, macro_revision, 0)\n])\n\n# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n#   Written by Scott James Remnant, 2004.\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 5 lt~obsolete.m4\n\n# These exist entirely to fool aclocal when bootstrapping libtool.\n#\n# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)\n# which have later been changed to m4_define as they aren't part of the\n# exported API, or moved to Autoconf or Automake where they belong.\n#\n# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN\n# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us\n# using a macro with the same name in our local m4/libtool.m4 it'll\n# pull the old libtool.m4 in (it doesn't see our shiny new m4_define\n# and doesn't know about Autoconf macros at all.)\n#\n# So we provide this file, which has a silly filename so it's always\n# included after everything else.  This provides aclocal with the\n# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything\n# because those macros already exist, or will be overwritten later.\n# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. \n#\n# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.\n# Yes, that means every name once taken will need to remain here until\n# we give up compatibility with versions before 1.7, at which point\n# we need to keep only those names which we still refer to.\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])\n\nm4_ifndef([AC_LIBTOOL_LINKER_OPTION],\t[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])\nm4_ifndef([AC_PROG_EGREP],\t\t[AC_DEFUN([AC_PROG_EGREP])])\nm4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],\t[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])\nm4_ifndef([_LT_AC_SHELL_INIT],\t\t[AC_DEFUN([_LT_AC_SHELL_INIT])])\nm4_ifndef([_LT_AC_SYS_LIBPATH_AIX],\t[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])\nm4_ifndef([_LT_PROG_LTMAIN],\t\t[AC_DEFUN([_LT_PROG_LTMAIN])])\nm4_ifndef([_LT_AC_TAGVAR],\t\t[AC_DEFUN([_LT_AC_TAGVAR])])\nm4_ifndef([AC_LTDL_ENABLE_INSTALL],\t[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])\nm4_ifndef([AC_LTDL_PREOPEN],\t\t[AC_DEFUN([AC_LTDL_PREOPEN])])\nm4_ifndef([_LT_AC_SYS_COMPILER],\t[AC_DEFUN([_LT_AC_SYS_COMPILER])])\nm4_ifndef([_LT_AC_LOCK],\t\t[AC_DEFUN([_LT_AC_LOCK])])\nm4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],\t[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])\nm4_ifndef([_LT_AC_TRY_DLOPEN_SELF],\t[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])\nm4_ifndef([AC_LIBTOOL_PROG_CC_C_O],\t[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])\nm4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])\nm4_ifndef([AC_LIBTOOL_OBJDIR],\t\t[AC_DEFUN([AC_LIBTOOL_OBJDIR])])\nm4_ifndef([AC_LTDL_OBJDIR],\t\t[AC_DEFUN([AC_LTDL_OBJDIR])])\nm4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])\nm4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],\t[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])\nm4_ifndef([AC_PATH_MAGIC],\t\t[AC_DEFUN([AC_PATH_MAGIC])])\nm4_ifndef([AC_PROG_LD_GNU],\t\t[AC_DEFUN([AC_PROG_LD_GNU])])\nm4_ifndef([AC_PROG_LD_RELOAD_FLAG],\t[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])\nm4_ifndef([AC_DEPLIBS_CHECK_METHOD],\t[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])\nm4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])\nm4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])\nm4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])\nm4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],\t[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])\nm4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],\t[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])\nm4_ifndef([LT_AC_PROG_EGREP],\t\t[AC_DEFUN([LT_AC_PROG_EGREP])])\nm4_ifndef([LT_AC_PROG_SED],\t\t[AC_DEFUN([LT_AC_PROG_SED])])\nm4_ifndef([_LT_CC_BASENAME],\t\t[AC_DEFUN([_LT_CC_BASENAME])])\nm4_ifndef([_LT_COMPILER_BOILERPLATE],\t[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])\nm4_ifndef([_LT_LINKER_BOILERPLATE],\t[AC_DEFUN([_LT_LINKER_BOILERPLATE])])\nm4_ifndef([_AC_PROG_LIBTOOL],\t\t[AC_DEFUN([_AC_PROG_LIBTOOL])])\nm4_ifndef([AC_LIBTOOL_SETUP],\t\t[AC_DEFUN([AC_LIBTOOL_SETUP])])\nm4_ifndef([_LT_AC_CHECK_DLFCN],\t\t[AC_DEFUN([_LT_AC_CHECK_DLFCN])])\nm4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],\t[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])\nm4_ifndef([_LT_AC_TAGCONFIG],\t\t[AC_DEFUN([_LT_AC_TAGCONFIG])])\nm4_ifndef([AC_DISABLE_FAST_INSTALL],\t[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])\nm4_ifndef([_LT_AC_LANG_CXX],\t\t[AC_DEFUN([_LT_AC_LANG_CXX])])\nm4_ifndef([_LT_AC_LANG_F77],\t\t[AC_DEFUN([_LT_AC_LANG_F77])])\nm4_ifndef([_LT_AC_LANG_GCJ],\t\t[AC_DEFUN([_LT_AC_LANG_GCJ])])\nm4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])\nm4_ifndef([_LT_AC_LANG_C_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])\nm4_ifndef([_LT_AC_LANG_CXX_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])\nm4_ifndef([_LT_AC_LANG_F77_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])\nm4_ifndef([_LT_AC_LANG_GCJ_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])\nm4_ifndef([_LT_AC_LANG_RC_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])\nm4_ifndef([AC_LIBTOOL_CONFIG],\t\t[AC_DEFUN([AC_LIBTOOL_CONFIG])])\nm4_ifndef([_LT_AC_FILE_LTDLL_C],\t[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])\nm4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],\t[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])\nm4_ifndef([_LT_AC_PROG_CXXCPP],\t\t[AC_DEFUN([_LT_AC_PROG_CXXCPP])])\nm4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],\t[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])\nm4_ifndef([_LT_PROG_ECHO_BACKSLASH],\t[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])\nm4_ifndef([_LT_PROG_F77],\t\t[AC_DEFUN([_LT_PROG_F77])])\nm4_ifndef([_LT_PROG_FC],\t\t[AC_DEFUN([_LT_PROG_FC])])\nm4_ifndef([_LT_PROG_CXX],\t\t[AC_DEFUN([_LT_PROG_CXX])])\n\n# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-\n# serial 1 (pkg-config-0.24)\n# \n# Copyright \u00a9 2004 Scott James Remnant <scott@netsplit.com>.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301, USA.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that program.\n\n# PKG_PROG_PKG_CONFIG([MIN-VERSION])\n# ----------------------------------\nAC_DEFUN([PKG_PROG_PKG_CONFIG],\n[m4_pattern_forbid([^_?PKG_[A-Z_]+$])\nm4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])\nm4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])\nAC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])\nAC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])\nAC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])\n\nif test \"x$ac_cv_env_PKG_CONFIG_set\" != \"xset\"; then\n\tAC_PATH_TOOL([PKG_CONFIG], [pkg-config])\nfi\nif test -n \"$PKG_CONFIG\"; then\n\t_pkg_min_version=m4_default([$1], [0.9.0])\n\tAC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])\n\tif $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tPKG_CONFIG=\"\"\n\tfi\nfi[]dnl\n])# PKG_PROG_PKG_CONFIG\n\n# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\n#\n# Check to see whether a particular set of modules exists.  Similar\n# to PKG_CHECK_MODULES(), but does not set variables or print errors.\n#\n# Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])\n# only at the first occurence in configure.ac, so if the first place\n# it's called might be skipped (such as if it is within an \"if\", you\n# have to call PKG_CHECK_EXISTS manually\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_EXISTS],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nif test -n \"$PKG_CONFIG\" && \\\n    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors \"$1\"]); then\n  m4_default([$2], [:])\nm4_ifvaln([$3], [else\n  $3])dnl\nfi])\n\n# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])\n# ---------------------------------------------\nm4_define([_PKG_CONFIG],\n[if test -n \"$$1\"; then\n    pkg_cv_[]$1=\"$$1\"\n elif test -n \"$PKG_CONFIG\"; then\n    PKG_CHECK_EXISTS([$3],\n                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 \"$3\" 2>/dev/null`\n\t\t      test \"x$?\" != \"x0\" && pkg_failed=yes ],\n\t\t     [pkg_failed=yes])\n else\n    pkg_failed=untried\nfi[]dnl\n])# _PKG_CONFIG\n\n# _PKG_SHORT_ERRORS_SUPPORTED\n# -----------------------------\nAC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])\nif $PKG_CONFIG --atleast-pkgconfig-version 0.20; then\n        _pkg_short_errors_supported=yes\nelse\n        _pkg_short_errors_supported=no\nfi[]dnl\n])# _PKG_SHORT_ERRORS_SUPPORTED\n\n\n# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],\n# [ACTION-IF-NOT-FOUND])\n#\n#\n# Note that if there is a possibility the first call to\n# PKG_CHECK_MODULES might not happen, you should be sure to include an\n# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac\n#\n#\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_MODULES],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nAC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl\nAC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl\n\npkg_failed=no\nAC_MSG_CHECKING([for $1])\n\n_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])\n_PKG_CONFIG([$1][_LIBS], [libs], [$2])\n\nm4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS\nand $1[]_LIBS to avoid the need to call pkg-config.\nSee the pkg-config man page for more details.])\n\nif test $pkg_failed = yes; then\n   \tAC_MSG_RESULT([no])\n        _PKG_SHORT_ERRORS_SUPPORTED\n        if test $_pkg_short_errors_supported = yes; then\n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs \"$2\" 2>&1`\n        else \n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs \"$2\" 2>&1`\n        fi\n\t# Put the nasty error message in config.log where it belongs\n\techo \"$$1[]_PKG_ERRORS\" >&AS_MESSAGE_LOG_FD\n\n\tm4_default([$4], [AC_MSG_ERROR(\n[Package requirements ($2) were not met:\n\n$$1_PKG_ERRORS\n\nConsider adjusting the PKG_CONFIG_PATH environment variable if you\ninstalled software in a non-standard prefix.\n\n_PKG_TEXT])[]dnl\n        ])\nelif test $pkg_failed = untried; then\n     \tAC_MSG_RESULT([no])\n\tm4_default([$4], [AC_MSG_FAILURE(\n[The pkg-config script could not be found or is too old.  Make sure it\nis in your PATH or set the PKG_CONFIG environment variable to the full\npath to pkg-config.\n\n_PKG_TEXT\n\nTo get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl\n        ])\nelse\n\t$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS\n\t$1[]_LIBS=$pkg_cv_[]$1[]_LIBS\n        AC_MSG_RESULT([yes])\n\t$3\nfi[]dnl\n])# PKG_CHECK_MODULES\n\n# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n# Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_AUTOMAKE_VERSION(VERSION)\n# ----------------------------\n# Automake X.Y traces this macro to ensure aclocal.m4 has been\n# generated from the m4 files accompanying Automake X.Y.\n# (This private macro should not be called outside this file.)\nAC_DEFUN([AM_AUTOMAKE_VERSION],\n[am__api_version='1.11'\ndnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\ndnl require some minimum version.  Point them to the right macro.\nm4_if([$1], [1.11.3], [],\n      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n])\n\n# _AM_AUTOCONF_VERSION(VERSION)\n# -----------------------------\n# aclocal traces this macro to find the Autoconf version.\n# This is a private macro too.  Using m4_define simplifies\n# the logic in aclocal, which can simply ignore this definition.\nm4_define([_AM_AUTOCONF_VERSION], [])\n\n# AM_SET_CURRENT_AUTOMAKE_VERSION\n# -------------------------------\n# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\nAC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n[AM_AUTOMAKE_VERSION([1.11.3])dnl\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n\n# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n\n# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n#\n# Of course, Automake must honor this variable whenever it calls a\n# tool from the auxiliary directory.  The problem is that $srcdir (and\n# therefore $ac_aux_dir as well) can be either absolute or relative,\n# depending on how configure is run.  This is pretty annoying, since\n# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n# source directory, any form will work fine, but in subdirectories a\n# relative path needs to be adjusted first.\n#\n# $ac_aux_dir/missing\n#    fails when called from a subdirectory if $ac_aux_dir is relative\n# $top_srcdir/$ac_aux_dir/missing\n#    fails if $ac_aux_dir is absolute,\n#    fails when called from a subdirectory in a VPATH build with\n#          a relative $ac_aux_dir\n#\n# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n# are both prefixed by $srcdir.  In an in-source build this is usually\n# harmless because $srcdir is `.', but things will broke when you\n# start a VPATH build or use an absolute $srcdir.\n#\n# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n# and then we would define $MISSING as\n#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n# This will work as long as MISSING is not called from configure, because\n# unfortunately $(top_srcdir) has no meaning in configure.\n# However there are other variables, like CC, which are often used in\n# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n#\n# Another solution, used here, is to always expand $ac_aux_dir to an\n# absolute PATH.  The drawback is that using absolute paths prevent a\n# configured tree to be moved without reconfiguration.\n\nAC_DEFUN([AM_AUX_DIR_EXPAND],\n[dnl Rely on autoconf to set up CDPATH properly.\nAC_PREREQ([2.50])dnl\n# expand $ac_aux_dir to an absolute path\nam_aux_dir=`cd $ac_aux_dir && pwd`\n])\n\n# AM_CONDITIONAL                                            -*- Autoconf -*-\n\n# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 9\n\n# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n# -------------------------------------\n# Define a conditional.\nAC_DEFUN([AM_CONDITIONAL],\n[AC_PREREQ(2.52)dnl\n ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\nAC_SUBST([$1_TRUE])dnl\nAC_SUBST([$1_FALSE])dnl\n_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n_AM_SUBST_NOTMAKE([$1_FALSE])dnl\nm4_define([_AM_COND_VALUE_$1], [$2])dnl\nif $2; then\n  $1_TRUE=\n  $1_FALSE='#'\nelse\n  $1_TRUE='#'\n  $1_FALSE=\nfi\nAC_CONFIG_COMMANDS_PRE(\n[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n  AC_MSG_ERROR([[conditional \"$1\" was never defined.\nUsually this means the macro was only invoked conditionally.]])\nfi])])\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,\n# 2010, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 12\n\n# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n# written in clear, in which case automake, when reading aclocal.m4,\n# will think it sees a *use*, and therefore will trigger all it's\n# C support machinery.  Also note that it means that autoscan, seeing\n# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n\n\n# _AM_DEPENDENCIES(NAME)\n# ----------------------\n# See how the compiler implements dependency checking.\n# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n# We try a few techniques and use that to set a single cache variable.\n#\n# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n# dependency, and given that the user is not expected to run this macro,\n# just rely on AC_PROG_CC.\nAC_DEFUN([_AM_DEPENDENCIES],\n[AC_REQUIRE([AM_SET_DEPDIR])dnl\nAC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\nAC_REQUIRE([AM_MAKE_INCLUDE])dnl\nAC_REQUIRE([AM_DEP_TRACK])dnl\n\nifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n                   [depcc=\"$$1\"   am_compiler_list=])\n\nAC_CACHE_CHECK([dependency style of $depcc],\n               [am_cv_$1_dependencies_compiler_type],\n[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named `D' -- because `-MD' means `put the output\n  # in D'.\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_$1_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n  fi\n  am__universal=false\n  m4_case([$1], [CC],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac],\n    [CXX],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac])\n\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n      # Solaris 8's {/usr,}/bin/sh.\n      touch sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle `-M -o', and we need to detect this.  Also, some Intel\n    # versions had trouble with output in subdirs\n    am__obj=sub/conftest.${OBJEXT-o}\n    am__minus_obj=\"-o $am__obj\"\n    case $depmode in\n    gcc)\n      # This depmode causes a compiler race in universal mode.\n      test \"$am__universal\" = false || continue\n      ;;\n    nosideeffect)\n      # after this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n      # This compiler won't grok `-c -o', but also, the minuso test has\n      # not run yet.  These depmodes are late enough in the game, and\n      # so weak that their functioning should not be impacted.\n      am__obj=conftest.${OBJEXT-o}\n      am__minus_obj=\n      ;;\n    none) break ;;\n    esac\n    if depmode=$depmode \\\n       source=sub/conftest.c object=$am__obj \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thusly:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_$1_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_$1_dependencies_compiler_type=none\nfi\n])\nAC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\nAM_CONDITIONAL([am__fastdep$1], [\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n])\n\n\n# AM_SET_DEPDIR\n# -------------\n# Choose a directory name for dependency files.\n# This macro is AC_REQUIREd in _AM_DEPENDENCIES\nAC_DEFUN([AM_SET_DEPDIR],\n[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\nAC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n])\n\n\n# AM_DEP_TRACK\n# ------------\nAC_DEFUN([AM_DEP_TRACK],\n[AC_ARG_ENABLE(dependency-tracking,\n[  --disable-dependency-tracking  speeds up one-time build\n  --enable-dependency-tracking   do not reject slow dependency extractors])\nif test \"x$enable_dependency_tracking\" != xno; then\n  am_depcomp=\"$ac_aux_dir/depcomp\"\n  AMDEPBACKSLASH='\\'\n  am__nodep='_no'\nfi\nAM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\nAC_SUBST([AMDEPBACKSLASH])dnl\n_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\nAC_SUBST([am__nodep])dnl\n_AM_SUBST_NOTMAKE([am__nodep])dnl\n])\n\n# Generate code to set up dependency tracking.              -*- Autoconf -*-\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n#serial 5\n\n# _AM_OUTPUT_DEPENDENCY_COMMANDS\n# ------------------------------\nAC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n[{\n  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n  # are listed without --file.  Let's play safe and only enable the eval\n  # if we detect the quoting.\n  case $CONFIG_FILES in\n  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n  *)   set x $CONFIG_FILES ;;\n  esac\n  shift\n  for mf\n  do\n    # Strip MF so we end up with the name of the file.\n    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n    # Check whether this is an Automake generated Makefile or not.\n    # We used to match only the files named `Makefile.in', but\n    # some people rename them; so instead we look at the file content.\n    # Grep'ing the first line is not enough: some people post-process\n    # each Makefile.in and add a new line on top of each file to say so.\n    # Grep'ing the whole file is not good either: AIX grep has a line\n    # limit of 2048, but all sed's we know have understand at least 4000.\n    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n      dirpart=`AS_DIRNAME(\"$mf\")`\n    else\n      continue\n    fi\n    # Extract the definition of DEPDIR, am__include, and am__quote\n    # from the Makefile without running `make'.\n    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n    test -z \"$DEPDIR\" && continue\n    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n    test -z \"am__include\" && continue\n    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n    # When using ansi2knr, U may be empty or an underscore; expand it\n    U=`sed -n 's/^U = //p' < \"$mf\"`\n    # Find all dependency output files, they are included files with\n    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n    # simplest approach to changing $(DEPDIR) to its actual value in the\n    # expansion.\n    for file in `sed -n \"\n      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n      # Make sure the directory exists.\n      test -f \"$dirpart/$file\" && continue\n      fdir=`AS_DIRNAME([\"$file\"])`\n      AS_MKDIR_P([$dirpart/$fdir])\n      # echo \"creating $dirpart/$file\"\n      echo '# dummy' > \"$dirpart/$file\"\n    done\n  done\n}\n])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n\n\n# AM_OUTPUT_DEPENDENCY_COMMANDS\n# -----------------------------\n# This macro should only be invoked once -- use via AC_REQUIRE.\n#\n# This code is only required when automatic dependency tracking\n# is enabled.  FIXME.  This creates each `.P' file that we will\n# need in order to bootstrap the dependency handling code.\nAC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n[AC_CONFIG_COMMANDS([depfiles],\n     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n])\n\n# Do all the work for Automake.                             -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 16\n\n# This macro actually does too much.  Some checks are only needed if\n# your package does certain things.  But this isn't really a big deal.\n\n# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n# AM_INIT_AUTOMAKE([OPTIONS])\n# -----------------------------------------------\n# The call with PACKAGE and VERSION arguments is the old style\n# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n# and VERSION should now be passed to AC_INIT and removed from\n# the call to AM_INIT_AUTOMAKE.\n# We support both call styles for the transition.  After\n# the next Automake release, Autoconf can make the AC_INIT\n# arguments mandatory, and then we can depend on a new Autoconf\n# release and drop the old call support.\nAC_DEFUN([AM_INIT_AUTOMAKE],\n[AC_PREREQ([2.62])dnl\ndnl Autoconf wants to disallow AM_ names.  We explicitly allow\ndnl the ones we care about.\nm4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\nAC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\nAC_REQUIRE([AC_PROG_INSTALL])dnl\nif test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n  # is not polluted with repeated \"-I.\"\n  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n  # test to see if srcdir already configured\n  if test -f $srcdir/config.status; then\n    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n  fi\nfi\n\n# test whether we have cygpath\nif test -z \"$CYGPATH_W\"; then\n  if (cygpath --version) >/dev/null 2>/dev/null; then\n    CYGPATH_W='cygpath -w'\n  else\n    CYGPATH_W=echo\n  fi\nfi\nAC_SUBST([CYGPATH_W])\n\n# Define the identity of the package.\ndnl Distinguish between old-style and new-style calls.\nm4_ifval([$2],\n[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n AC_SUBST([PACKAGE], [$1])dnl\n AC_SUBST([VERSION], [$2])],\n[_AM_SET_OPTIONS([$1])dnl\ndnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\nm4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n\n_AM_IF_OPTION([no-define],,\n[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n\n# Some tools Automake needs.\nAC_REQUIRE([AM_SANITY_CHECK])dnl\nAC_REQUIRE([AC_ARG_PROGRAM])dnl\nAM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\nAM_MISSING_PROG(AUTOCONF, autoconf)\nAM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\nAM_MISSING_PROG(AUTOHEADER, autoheader)\nAM_MISSING_PROG(MAKEINFO, makeinfo)\nAC_REQUIRE([AM_PROG_INSTALL_SH])dnl\nAC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\nAC_REQUIRE([AM_PROG_MKDIR_P])dnl\n# We need awk for the \"check\" target.  The system \"awk\" is bad on\n# some platforms.\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([AC_PROG_MAKE_SET])dnl\nAC_REQUIRE([AM_SET_LEADING_DOT])dnl\n_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n\t\t\t     [_AM_PROG_TAR([v7])])])\n_AM_IF_OPTION([no-dependencies],,\n[AC_PROVIDE_IFELSE([AC_PROG_CC],\n\t\t  [_AM_DEPENDENCIES(CC)],\n\t\t  [define([AC_PROG_CC],\n\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_CXX],\n\t\t  [_AM_DEPENDENCIES(CXX)],\n\t\t  [define([AC_PROG_CXX],\n\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_OBJC],\n\t\t  [_AM_DEPENDENCIES(OBJC)],\n\t\t  [define([AC_PROG_OBJC],\n\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n])\n_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\ndnl The `parallel-tests' driver may need to know about EXEEXT, so add the\ndnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\ndnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\nAC_CONFIG_COMMANDS_PRE(dnl\n[m4_provide_if([_AM_COMPILER_EXEEXT],\n  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n])\n\ndnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\ndnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\ndnl mangled by Autoconf and run in a shell conditional statement.\nm4_define([_AC_COMPILER_EXEEXT],\nm4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n\n\n# When config.status generates a header, we must update the stamp-h file.\n# This file resides in the same directory as the config header\n# that is generated.  The stamp files are numbered to have different names.\n\n# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n# loop where config.status creates the headers, so we can generate\n# our stamp files there.\nAC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n[# Compute $1's index in $config_headers.\n_am_arg=$1\n_am_stamp_count=1\nfor _am_header in $config_headers :; do\n  case $_am_header in\n    $_am_arg | $_am_arg:* )\n      break ;;\n    * )\n      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n  esac\ndone\necho \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n\n# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n# Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_INSTALL_SH\n# ------------------\n# Define $install_sh.\nAC_DEFUN([AM_PROG_INSTALL_SH],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nif test x\"${install_sh}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n  *)\n    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n  esac\nfi\nAC_SUBST(install_sh)])\n\n# Copyright (C) 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# Check whether the underlying file-system supports filenames\n# with a leading dot.  For instance MS-DOS doesn't.\nAC_DEFUN([AM_SET_LEADING_DOT],\n[rm -rf .tst 2>/dev/null\nmkdir .tst 2>/dev/null\nif test -d .tst; then\n  am__leading_dot=.\nelse\n  am__leading_dot=_\nfi\nrmdir .tst 2>/dev/null\nAC_SUBST([am__leading_dot])])\n\n# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 4\n\n# AM_MAKE_INCLUDE()\n# -----------------\n# Check to see how make treats includes.\nAC_DEFUN([AM_MAKE_INCLUDE],\n[am_make=${MAKE-make}\ncat > confinc << 'END'\nam__doit:\n\t@echo this is the am__doit target\n.PHONY: am__doit\nEND\n# If we don't find an include directive, just comment out the code.\nAC_MSG_CHECKING([for style of include used by $am_make])\nam__include=\"#\"\nam__quote=\n_am_result=none\n# First try GNU make style include.\necho \"include confinc\" > confmf\n# Ignore all kinds of additional output from `make'.\ncase `$am_make -s -f confmf 2> /dev/null` in #(\n*the\\ am__doit\\ target*)\n  am__include=include\n  am__quote=\n  _am_result=GNU\n  ;;\nesac\n# Now try BSD make style include.\nif test \"$am__include\" = \"#\"; then\n   echo '.include \"confinc\"' > confmf\n   case `$am_make -s -f confmf 2> /dev/null` in #(\n   *the\\ am__doit\\ target*)\n     am__include=.include\n     am__quote=\"\\\"\"\n     _am_result=BSD\n     ;;\n   esac\nfi\nAC_SUBST([am__include])\nAC_SUBST([am__quote])\nAC_MSG_RESULT([$_am_result])\nrm -f confinc confmf\n])\n\n# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n\n# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 6\n\n# AM_MISSING_PROG(NAME, PROGRAM)\n# ------------------------------\nAC_DEFUN([AM_MISSING_PROG],\n[AC_REQUIRE([AM_MISSING_HAS_RUN])\n$1=${$1-\"${am_missing_run}$2\"}\nAC_SUBST($1)])\n\n\n# AM_MISSING_HAS_RUN\n# ------------------\n# Define MISSING if not defined so far and test if it supports --run.\n# If it does, set am_missing_run to use it, otherwise, to nothing.\nAC_DEFUN([AM_MISSING_HAS_RUN],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([missing])dnl\nif test x\"${MISSING+set}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n  *)\n    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n  esac\nfi\n# Use eval to expand $SHELL\nif eval \"$MISSING --run true\"; then\n  am_missing_run=\"$MISSING --run \"\nelse\n  am_missing_run=\n  AC_MSG_WARN([`missing' script is too old or missing])\nfi\n])\n\n# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n# Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_MKDIR_P\n# ---------------\n# Check for `mkdir -p'.\nAC_DEFUN([AM_PROG_MKDIR_P],\n[AC_PREREQ([2.60])dnl\nAC_REQUIRE([AC_PROG_MKDIR_P])dnl\ndnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\ndnl while keeping a definition of mkdir_p for backward compatibility.\ndnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\ndnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\ndnl Makefile.ins that do not define MKDIR_P, so we do our own\ndnl adjustment using top_builddir (which is defined more often than\ndnl MKDIR_P).\nAC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\ncase $mkdir_p in\n  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\nesac\n])\n\n# Helper functions for option handling.                     -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n# Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# _AM_MANGLE_OPTION(NAME)\n# -----------------------\nAC_DEFUN([_AM_MANGLE_OPTION],\n[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n\n# _AM_SET_OPTION(NAME)\n# --------------------\n# Set option NAME.  Presently that only means defining a flag for this option.\nAC_DEFUN([_AM_SET_OPTION],\n[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n\n# _AM_SET_OPTIONS(OPTIONS)\n# ------------------------\n# OPTIONS is a space-separated list of Automake options.\nAC_DEFUN([_AM_SET_OPTIONS],\n[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n\n# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n# -------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nAC_DEFUN([_AM_IF_OPTION],\n[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n\n# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# AM_SANITY_CHECK\n# ---------------\nAC_DEFUN([AM_SANITY_CHECK],\n[AC_MSG_CHECKING([whether build environment is sane])\n# Just in case\nsleep 1\necho timestamp > conftest.file\n# Reject unsafe characters in $srcdir or the absolute working directory\n# name.  Accept space and tab only in the latter.\nam_lf='\n'\ncase `pwd` in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n    AC_MSG_ERROR([unsafe absolute working directory name]);;\nesac\ncase $srcdir in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\nesac\n\n# Do `set' in a subshell so we don't clobber the current shell's\n# arguments.  Must try -L first in case configure is actually a\n# symlink; some systems play weird games with the mod time of symlinks\n# (eg FreeBSD returns the mod time of the symlink's containing\n# directory).\nif (\n   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n   if test \"$[*]\" = \"X\"; then\n      # -L didn't work.\n      set X `ls -t \"$srcdir/configure\" conftest.file`\n   fi\n   rm -f conftest.file\n   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n\n      # If neither matched, then we have a broken ls.  This can happen\n      # if, for instance, CONFIG_SHELL is bash and it inherits a\n      # broken ls alias from the environment.  This has actually\n      # happened.  Such a system could not be considered \"sane\".\n      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\nalias in your environment])\n   fi\n\n   test \"$[2]\" = conftest.file\n   )\nthen\n   # Ok.\n   :\nelse\n   AC_MSG_ERROR([newly created file is older than distributed files!\nCheck your system clock])\nfi\nAC_MSG_RESULT(yes)])\n\n# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_INSTALL_STRIP\n# ---------------------\n# One issue with vendor `install' (even GNU) is that you can't\n# specify the program used to strip binaries.  This is especially\n# annoying in cross-compiling environments, where the build's strip\n# is unlikely to handle the host's binaries.\n# Fortunately install-sh will honor a STRIPPROG variable, so we\n# always use install-sh in `make install-strip', and initialize\n# STRIPPROG with the value of the STRIP variable (set by the user).\nAC_DEFUN([AM_PROG_INSTALL_STRIP],\n[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n# Installed binaries are usually stripped using `strip' when the user\n# run `make install-strip'.  However `strip' might not be the right\n# tool to use in cross-compilation environments, therefore Automake\n# will honor the `STRIP' environment variable to overrule this program.\ndnl Don't test for $cross_compiling = yes, because it might be `maybe'.\nif test \"$cross_compiling\" != no; then\n  AC_CHECK_TOOL([STRIP], [strip], :)\nfi\nINSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\nAC_SUBST([INSTALL_STRIP_PROGRAM])])\n\n# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 3\n\n# _AM_SUBST_NOTMAKE(VARIABLE)\n# ---------------------------\n# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n# This macro is traced by Automake.\nAC_DEFUN([_AM_SUBST_NOTMAKE])\n\n# AM_SUBST_NOTMAKE(VARIABLE)\n# --------------------------\n# Public sister of _AM_SUBST_NOTMAKE.\nAC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n\n# Check how to create a tarball.                            -*- Autoconf -*-\n\n# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# _AM_PROG_TAR(FORMAT)\n# --------------------\n# Check how to create a tarball in format FORMAT.\n# FORMAT should be one of `v7', `ustar', or `pax'.\n#\n# Substitute a variable $(am__tar) that is a command\n# writing to stdout a FORMAT-tarball containing the directory\n# $tardir.\n#     tardir=directory && $(am__tar) > result.tar\n#\n# Substitute a variable $(am__untar) that extract such\n# a tarball read from stdin.\n#     $(am__untar) < result.tar\nAC_DEFUN([_AM_PROG_TAR],\n[# Always define AMTAR for backward compatibility.  Yes, it's still used\n# in the wild :-(  We should find a proper way to deprecate it ...\nAC_SUBST([AMTAR], ['$${TAR-tar}'])\nm4_if([$1], [v7],\n     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n     [m4_case([$1], [ustar],, [pax],,\n              [m4_fatal([Unknown tar format])])\nAC_MSG_CHECKING([how to create a $1 tar archive])\n# Loop over all known methods to create a tar archive until one works.\n_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n# Do not fold the above two line into one, because Tru64 sh and\n# Solaris sh will not grok spaces in the rhs of `-'.\nfor _am_tool in $_am_tools\ndo\n  case $_am_tool in\n  gnutar)\n    for _am_tar in tar gnutar gtar;\n    do\n      AM_RUN_LOG([$_am_tar --version]) && break\n    done\n    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n    am__untar=\"$_am_tar -xf -\"\n    ;;\n  plaintar)\n    # Must skip GNU tar: if it does not support --format= it doesn't create\n    # ustar tarball either.\n    (tar --version) >/dev/null 2>&1 && continue\n    am__tar='tar chf - \"$$tardir\"'\n    am__tar_='tar chf - \"$tardir\"'\n    am__untar='tar xf -'\n    ;;\n  pax)\n    am__tar='pax -L -x $1 -w \"$$tardir\"'\n    am__tar_='pax -L -x $1 -w \"$tardir\"'\n    am__untar='pax -r'\n    ;;\n  cpio)\n    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n    am__untar='cpio -i -H $1 -d'\n    ;;\n  none)\n    am__tar=false\n    am__tar_=false\n    am__untar=false\n    ;;\n  esac\n\n  # If the value was cached, stop now.  We just wanted to have am__tar\n  # and am__untar set.\n  test -n \"${am_cv_prog_tar_$1}\" && break\n\n  # tar/untar a dummy directory, and stop if the command works\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  echo GrepMe > conftest.dir/file\n  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n  rm -rf conftest.dir\n  if test -s conftest.tar; then\n    AM_RUN_LOG([$am__untar <conftest.tar])\n    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n  fi\ndone\nrm -rf conftest.dir\n\nAC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\nAC_MSG_RESULT([$am_cv_prog_tar_$1])])\nAC_SUBST([am__tar])\nAC_SUBST([am__untar])\n]) # _AM_PROG_TAR\n\nm4_include([m4/gtest.m4])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 56 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"X$cc_temp\" | $Xsed -e 's%.*/%%' -e \"s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n_LT_PROG_ECHO_BACKSLASH\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"X$][$1\" | $Xsed -e \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"X$<var>\" | $Xsed -e \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Fix-up fallback echo if it was mangled by the above quoting rules.\ncase \\$lt_ECHO in\n*'\\\\\\[$]0 --fallback-echo\"')dnl \"\n  lt_ECHO=\\`\\$ECHO \"X\\$lt_ECHO\" | \\$Xsed -e 's/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[$]0 --fallback-echo\"\\[$]/\\[$]0 --fallback-echo\"/'\\`\n  ;;\nesac\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\ncat >\"$CONFIG_LT\" <<_LTEOF\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate a libtool stub with the current configuration.\n\nlt_cl_silent=false\nSHELL=\\${CONFIG_SHELL-$SHELL}\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAS_SHELL_SANITIZE\n_AS_PREPARE\n\nexec AS_MESSAGE_FD>&1\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2008 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nif test \"$no_create\" != yes; then\n  lt_cl_success=:\n  test \"$silent\" = yes &&\n    lt_config_lt_args=\"$lt_config_lt_args --quiet\"\n  exec AS_MESSAGE_LOG_FD>/dev/null\n  $SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\n  exec AS_MESSAGE_LOG_FD>>config.log\n  $lt_cl_success || AS_EXIT(1)\nfi\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '/^# Generated shell functions inserted here/q' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_XSI_SHELLFNS\n\n  sed -n '/^# Generated shell functions inserted here/,$p' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\tif test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES\n# --------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=echo\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX\n# -----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nAC_LINK_IFELSE(AC_LANG_PROGRAM,[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[ifdef([AC_DIVERSION_NOTICE],\n\t     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],\n\t [AC_DIVERT_PUSH(NOTICE)])\n$1\nAC_DIVERT_POP\n])# _LT_SHELL_INIT\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Add some code to the start of the generated configure script which\n# will find an echo command which doesn't interpret backslashes.\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[_LT_SHELL_INIT([\n# Check that we are running under the correct shell.\nSHELL=${CONFIG_SHELL-/bin/sh}\n\ncase X$lt_ECHO in\nX*--fallback-echo)\n  # Remove one level of quotation (which was required for Make).\n  ECHO=`echo \"$lt_ECHO\" | sed 's,\\\\\\\\\\[$]\\\\[$]0,'[$]0','`\n  ;;\nesac\n\nECHO=${lt_ECHO-echo}\nif test \"X[$]1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X[$]1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' ; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell.\n  exec $SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\nfi\n\nif test \"X[$]1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<_LT_EOF\n[$]*\n_LT_EOF\n  exit 0\nfi\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nif test -z \"$lt_ECHO\"; then\n  if test \"X${echo_test_string+set}\" != Xset; then\n    # find a string as large as possible, as long as the shell can cope with it\n    for cmd in 'sed 50q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 2q \"[$]0\"' 'echo test'; do\n      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...\n      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&\n\t { test \"X$echo_test_string\" = \"X$echo_test_string\"; } 2>/dev/null\n      then\n        break\n      fi\n    done\n  fi\n\n  if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n     echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n    :\n  else\n    # The Solaris, AIX, and Digital Unix default echo programs unquote\n    # backslashes.  This makes it impossible to quote backslashes using\n    #   echo \"$something\" | sed 's/\\\\/\\\\\\\\/g'\n    #\n    # So, first we look for a working echo in the user's PATH.\n\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for dir in $PATH /usr/ucb; do\n      IFS=\"$lt_save_ifs\"\n      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&\n         test \"X`($dir/echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`($dir/echo \"$echo_test_string\") 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        ECHO=\"$dir/echo\"\n        break\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n\n    if test \"X$ECHO\" = Xecho; then\n      # We didn't find a better echo, so look for alternatives.\n      if test \"X`{ print -r '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`{ print -r \"$echo_test_string\"; } 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        # This shell has a builtin print -r that does the trick.\n        ECHO='print -r'\n      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&\n\t   test \"X$CONFIG_SHELL\" != X/bin/ksh; then\n        # If we have ksh, try running configure again with it.\n        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n        export ORIGINAL_CONFIG_SHELL\n        CONFIG_SHELL=/bin/ksh\n        export CONFIG_SHELL\n        exec $CONFIG_SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\n      else\n        # Try using printf.\n        ECHO='printf %s\\n'\n        if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n\t   echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  # Cool, printf works\n\t  :\n        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL\n\t  export CONFIG_SHELL\n\t  SHELL=\"$CONFIG_SHELL\"\n\t  export SHELL\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        elif echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        else\n\t  # maybe with a smaller string...\n\t  prev=:\n\n\t  for cmd in 'echo test' 'sed 2q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 50q \"[$]0\"'; do\n\t    if { test \"X$echo_test_string\" = \"X`eval $cmd`\"; } 2>/dev/null\n\t    then\n\t      break\n\t    fi\n\t    prev=\"$cmd\"\n\t  done\n\n\t  if test \"$prev\" != 'sed 50q \"[$]0\"'; then\n\t    echo_test_string=`eval $prev`\n\t    export echo_test_string\n\t    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} \"[$]0\" ${1+\"[$]@\"}\n\t  else\n\t    # Oops.  We lost completely, so just stick with echo.\n\t    ECHO=echo\n\t  fi\n        fi\n      fi\n    fi\n  fi\nfi\n\n# Copy echo and quote the copy suitably for passing to libtool from\n# the Makefile, instead of quoting the original, which is used later.\nlt_ECHO=$ECHO\nif test \"X$lt_ECHO\" = \"X$CONFIG_SHELL [$]0 --fallback-echo\"; then\n   lt_ECHO=\"$CONFIG_SHELL \\\\\\$\\[$]0 --fallback-echo\"\nfi\n\nAC_SUBST(lt_ECHO)\n])\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1],\n    [An echo program that does not interpret backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_i386\"\n\t    ;;\n\t  ppc64-*linux*|powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  ppc*-*linux*|powerpc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[AC_CHECK_TOOL(AR, ar, false)\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1])\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"X$_lt_linker_boilerplate\" | $Xsed -e '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring$teststring\" 2>/dev/null` \\\n\t         = \"XX$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\nvoid fnord() { int i=42;}\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else if (dlsym( self,\"_fnord\")) status = $lt_dlneed_uscore;\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n  if $ECHO \"$lt_search_path_spec\" | $GREP ';' >/dev/null ; then\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED -e 's/;/ /g'`\n  else\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n  fi\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO \"X$lib\" | $Xsed -e '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=\"/usr/lib /lib/w32api /lib /usr/local/lib\"\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP \"^libraries:\" | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH printed by\n        # mingw gcc, but we are running on Cygwin. Gcc prints its search\n        # path with ; separators, and with drive letters. We can handle the\n        # drive letters (cygwin fileutils understands them), so leave them,\n        # especially as we might pass files found there to a mingw objdump,\n        # which wouldn't understand a cygwinified path. Ahh.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd1*)\n  dynamic_linker=no\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[123]]*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555.\n  postinstall_cmds='chmod 555 $lib'\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  # Some binutils ld are patched to set DT_RUNPATH\n  save_LDFLAGS=$LDFLAGS\n  save_libdir=$libdir\n  eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n       LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n    [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n       [shlibpath_overrides_runpath=yes])])\n  LDFLAGS=$save_LDFLAGS\n  libdir=$save_libdir\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_DECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_DECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method == \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  AC_CHECK_TOOLS(DUMPBIN, [\"dumpbin -symbols\" \"link -dump -symbols\"], :)\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:__oline__: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| $lt_cv_sys_global_symbol_pipe \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nconst struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC*)\n\t    # IBM XL 8.0 on PPC\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl*)\n\t# IBM XL C 8.0/Fortran 10.1 on PPC\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\t*Sun\\ F*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\nAC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw* | cegcc*)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n  if test \"$with_gnu_ld\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.9.1, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to modify your PATH\n*** so that a non-GNU linker is found, and then restart.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95*)\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]*)\t\t\t# IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  # Exported symbols can be pulled into shared objects from archives\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `$ECHO \"X$deplibs\" | $Xsed -e '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    freebsd1*)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n        save_LDFLAGS=\"$LDFLAGS\"\n        LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n        AC_LINK_IFELSE(int foo(void) {},\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n        )\n        LDFLAGS=\"$save_LDFLAGS\"\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_MSG_CHECKING([whether -lc should be explicitly linked in])\n      $RM conftest*\n      echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n        soname=conftest\n        lib=conftest\n        libobjs=conftest.$ac_objext\n        deplibs=\n        wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\tpic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n        compiler_flags=-v\n        linker_flags=-v\n        verstring=\n        output_objdir=.\n        libname=conftest\n        lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n        _LT_TAGVAR(allow_undefined_flag, $1)=\n        if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n        then\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        else\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n        fi\n        _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n      else\n        cat conftest.err 1>&5\n      fi\n      $RM conftest*\n      AC_MSG_RESULT([$_LT_TAGVAR(archive_cmds_need_lc, $1)])\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],\n    [[If ld is used when linking, flag to hardcode $libdir into a binary\n    during linking.  This must work even if $libdir does not exist]])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [fix_srcfile_path], [1],\n    [Fix the shell variable $srcfile for the compiler])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_PROG_CXX\n# ------------\n# Since AC_PROG_CXX is broken, in that it returns g++ if there is no c++\n# compiler, we have our own version here.\nm4_defun([_LT_PROG_CXX],\n[\npushdef([AC_MSG_ERROR], [_lt_caught_CXX_error=yes])\nAC_PROG_CXX\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_CXX\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_CXX], [])\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[AC_REQUIRE([_LT_PROG_CXX])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n        # as there is no search path for DLLs.\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n        _LT_TAGVAR(always_export_symbols, $1)=no\n        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n          # If the export-symbols file already is a .def file (1st line\n          # is EXPORTS), use it as is; otherwise, prepend...\n          _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    cp $export_symbols $output_objdir/$soname.def;\n          else\n\t    echo EXPORTS > $output_objdir/$soname.def;\n\t    cat $export_symbols >> $output_objdir/$soname.def;\n          fi~\n          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n        else\n          _LT_TAGVAR(ld_shlibs, $1)=no\n        fi\n        ;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd[[12]]*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]]* | *pgcpp\\ [[1-5]]*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 will use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  xl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='echo'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=echo\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='echo'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_PROG_F77\n# ------------\n# Since AC_PROG_F77 is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_F77],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_F77=yes])\nAC_PROG_F77\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_F77\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_F77], [])\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_REQUIRE([_LT_PROG_F77])dnl\nAC_LANG_PUSH(Fortran 77)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${F77-\"f77\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_PROG_FC\n# -----------\n# Since AC_PROG_FC is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_FC],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_FC=yes])\nAC_PROG_FC\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_FC\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_FC], [])\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_REQUIRE([_LT_PROG_FC])dnl\nAC_LANG_PUSH(Fortran)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${FC-\"f95\"}\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_XSI_SHELLFNS\n# ---------------------\n# Bourne and XSI compatible variants of some useful shell functions.\nm4_defun([_LT_PROG_XSI_SHELLFNS],\n[case $xsi_shell in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nfunc_stripname ()\n{\n  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n  # positional parameters, so assign one to ordinary parameter first.\n  func_stripname_result=${3}\n  func_stripname_result=${func_stripname_result#\"${1}\"}\n  func_stripname_result=${func_stripname_result%\"${2}\"}\n}\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=${1%%=*}\n  func_opt_split_arg=${1#*=}\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  case ${1} in\n    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n    *)    func_lo2o_result=${1} ;;\n  esac\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=${1%.*}.lo\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=$(( $[*] ))\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=${#1}\n}\n\n_LT_EOF\n    ;;\n  *) # Bourne compatible functions.\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\ndnl func_dirname_and_basename\ndnl A portable version of this function is already defined in general.m4sh\ndnl so there is no need for it here.\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n  case ${2} in\n    .*) func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%\\\\\\\\${2}\\$%%\"`;;\n    *)  func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%${2}\\$%%\"`;;\n  esac\n}\n\n# sed scripts:\nmy_sed_long_opt='1s/^\\(-[[^=]]*\\)=.*/\\1/;q'\nmy_sed_long_arg='1s/^-[[^=]]*=//'\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_opt\"`\n  func_opt_split_arg=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_arg\"`\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  func_lo2o_result=`$ECHO \"X${1}\" | $Xsed -e \"$lo2o\"`\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=`$ECHO \"X${1}\" | $Xsed -e 's/\\.[[^.]]*$/.lo/'`\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=`expr \"$[@]\"`\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=`expr \"$[1]\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n}\n\n_LT_EOF\nesac\n\ncase $lt_shell_append in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]+=\\$[2]\"\n}\n_LT_EOF\n    ;;\n  *)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]=\\$$[1]\\$[2]\"\n}\n\n_LT_EOF\n    ;;\n  esac\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/build-aux/ltmain.sh": "# Generated from ltmain.m4sh.\n\n# ltmain.sh (GNU libtool) 2.2.6\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#     --config             show all configuration variables\n#     --debug              enable verbose shell tracing\n# -n, --dry-run            display commands without modifying any files\n#     --features           display basic configuration information and exit\n#     --mode=MODE          use operation mode MODE\n#     --preserve-dup-deps  don't remove duplicate dependency libraries\n#     --quiet, --silent    don't print informational messages\n#     --tag=TAG            use configuration variables from tag TAG\n# -v, --verbose            print informational messages (default)\n#     --version            print version information\n# -h, --help               print short or long help message\n#\n# MODE must be one of the following:\n#\n#       clean              remove files from the build directory\n#       compile            compile a source file into a libtool object\n#       execute            automatically set library path, then run a program\n#       finish             complete the installation of libtool libraries\n#       install            install libraries or executables\n#       link               create a library or an executable\n#       uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#       host-triplet:\t$host\n#       shell:\t\t$SHELL\n#       compiler:\t\t$LTCC\n#       compiler flags:\t\t$LTCFLAGS\n#       linker:\t\t$LD (gnu? $with_gnu_ld)\n#       $progname:\t\t(GNU libtool) 2.2.6\n#       automake:\t\t$automake_version\n#       autoconf:\t\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n\nPROGRAM=ltmain.sh\nPACKAGE=libtool\nVERSION=2.2.6\nTIMESTAMP=\"\"\npackage_revision=1.3012\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# NLS nuisances: We save the old values to restore during execute mode.\n# Only set LANG and LC_ALL to C if already set.\n# These must not be set unconditionally because not all systems understand\n# e.g. LANG=C (notably SCO).\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\n\n$lt_unset CDPATH\n\n\n\n\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"echo\"}\n: ${EGREP=\"/usr/bin/grep -E\"}\n: ${FGREP=\"/usr/bin/grep -F\"}\n: ${GREP=\"/usr/bin/grep\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SED=\"/opt/local/bin/gsed\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\n# Generated shell functions inserted here.\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n# The name of this program:\n# In the unlikely event $progname began with a '-', it would play havoc with\n# func_echo (imagine progname=-n), so we prepend ./ in that case:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\ncase $progname in\n  -*) progname=./$progname ;;\nesac\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=:\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname${mode+: }$mode: $*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname${mode+: }$mode: \"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname${mode+: }$mode: warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"X$my_directory_path\" | $Xsed -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"X$my_dir_list\" | $Xsed -e 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"X$my_tmpdir\" | $Xsed\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"X$1\" | $Xsed -e \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"X$1\" | $Xsed \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $SED -n '/^# Usage:/,/# -h/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    $ECHO\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(automake --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(autoconf --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n     }' < \"$progpath\"\n    exit $?\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    func_error \"missing argument for $1\"\n    exit_cmd=exit\n}\n\nexit_cmd=:\n\n\n\n\n\n# Check that we have a working $ECHO.\nif test \"X$1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X$1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t'; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell, and then maybe $ECHO will work.\n  exec $SHELL \"$progpath\" --no-reexec ${1+\"$@\"}\nfi\n\nif test \"X$1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<EOF\n$*\nEOF\n  exit $EXIT_SUCCESS\nfi\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\n# $mode is unset\nnonopt=\nexecute_dlfiles=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\nopt_dry_run=false\nopt_duplicate_deps=false\nopt_silent=false\nopt_debug=:\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    $ECHO \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      $ECHO \"enable shared libraries\"\n    else\n      $ECHO \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      $ECHO \"enable static libraries\"\n    else\n      $ECHO \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# Parse options once, thoroughly.  This comes as soon as possible in\n# the script to make things like `libtool --version' happen quickly.\n{\n\n  # Shorthand for --mode=foo, only valid as the first argument\n  case $1 in\n  clean|clea|cle|cl)\n    shift; set dummy --mode clean ${1+\"$@\"}; shift\n    ;;\n  compile|compil|compi|comp|com|co|c)\n    shift; set dummy --mode compile ${1+\"$@\"}; shift\n    ;;\n  execute|execut|execu|exec|exe|ex|e)\n    shift; set dummy --mode execute ${1+\"$@\"}; shift\n    ;;\n  finish|finis|fini|fin|fi|f)\n    shift; set dummy --mode finish ${1+\"$@\"}; shift\n    ;;\n  install|instal|insta|inst|ins|in|i)\n    shift; set dummy --mode install ${1+\"$@\"}; shift\n    ;;\n  link|lin|li|l)\n    shift; set dummy --mode link ${1+\"$@\"}; shift\n    ;;\n  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n    shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n    ;;\n  esac\n\n  # Parse non-mode specific arguments:\n  while test \"$#\" -gt 0; do\n    opt=\"$1\"\n    shift\n\n    case $opt in\n      --config)\t\tfunc_config\t\t\t\t\t;;\n\n      --debug)\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\topt_debug='set -x'\n\t\t\t$opt_debug\n\t\t\t;;\n\n      -dlopen)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\texecute_dlfiles=\"$execute_dlfiles $1\"\n\t\t\tshift\n\t\t\t;;\n\n      --dry-run | -n)\topt_dry_run=:\t\t\t\t\t;;\n      --features)       func_features\t\t\t\t\t;;\n      --finish)\t\tmode=\"finish\"\t\t\t\t\t;;\n\n      --mode)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tcase $1 in\n\t\t\t  # Valid mode arguments:\n\t\t\t  clean)\t;;\n\t\t\t  compile)\t;;\n\t\t\t  execute)\t;;\n\t\t\t  finish)\t;;\n\t\t\t  install)\t;;\n\t\t\t  link)\t\t;;\n\t\t\t  relink)\t;;\n\t\t\t  uninstall)\t;;\n\n\t\t\t  # Catch anything else as an error\n\t\t\t  *) func_error \"invalid argument for $opt\"\n\t\t\t     exit_cmd=exit\n\t\t\t     break\n\t\t\t     ;;\n\t\t        esac\n\n\t\t\tmode=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\n      --preserve-dup-deps)\n\t\t\topt_duplicate_deps=:\t\t\t\t;;\n\n      --quiet|--silent)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=:\n\t\t\t;;\n\n      --verbose| -v)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\t;;\n\n      --tag)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tpreserve_args=\"$preserve_args $opt $1\"\n\t\t\tfunc_enable_tag \"$1\"\t# tagname is set here\n\t\t\tshift\n\t\t\t;;\n\n      # Separate optargs to long options:\n      -dlopen=*|--mode=*|--tag=*)\n\t\t\tfunc_opt_split \"$opt\"\n\t\t\tset dummy \"$func_opt_split_opt\" \"$func_opt_split_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t\t;;\n      --help)\t\topt_help=:\t\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t\t;;\n\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\"\t;;\n\n      *)\t\tnonopt=\"$opt\"\n\t\t\tbreak\n\t\t\t;;\n    esac\n  done\n\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps\n      ;;\n  esac\n\n  # Having warned about all mis-specified options, bail out if\n  # anything was wrong.\n  $exit_cmd $EXIT_FAILURE\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n$opt_help || {\n  # Sanity checks first:\n  func_check_version_match\n\n  if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n    func_fatal_configuration \"not configured to build any kind of library\"\n  fi\n\n  test -z \"$mode\" && func_fatal_error \"error: you must specify a MODE.\"\n\n\n  # Darwin sucks\n  eval std_shrext=\\\"$shrext_cmds\\\"\n\n\n  # Only execute mode is allowed to have -dlopen flags.\n  if test -n \"$execute_dlfiles\" && test \"$mode\" != execute; then\n    func_error \"unrecognized option \\`-dlopen'\"\n    $ECHO \"$help\" 1>&2\n    exit $EXIT_FAILURE\n  fi\n\n  # Change the help message to a mode-specific one.\n  generic_help=\"$help\"\n  help=\"Try \\`$progname --help --mode=$mode' for more information.\"\n}\n\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_ltwrapper_scriptname_result=\"\"\n    if func_ltwrapper_executable_p \"$1\"; then\n\tfunc_dirname_and_basename \"$1\" \"\" \".\"\n\tfunc_stripname '' '.exe' \"$func_basename_result\"\n\tfunc_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n    fi\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n        func_quote_for_eval \"$arg\"\n\tCC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n      done\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_quote_for_eval \"$arg\"\n\t      CC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n\t    done\n\t    case \"$@ \" in\n\t      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          pie_flag=\"$pie_flag $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  later=\"$later $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_quote_for_eval \"$arg\"\n\t    lastarg=\"$lastarg $func_quote_for_eval_result\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  base_compile=\"$base_compile $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_quote_for_eval \"$lastarg\"\n      base_compile=\"$base_compile $func_quote_for_eval_result\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.obj | *.sx)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"X$srcfile\" | $Xsed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      removelist=\"$removelist $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    removelist=\"$removelist $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    if test -n \"$fix_srcfile_path\"; then\n      eval srcfile=\\\"$fix_srcfile_path\\\"\n    fi\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tcommand=\"$command -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tcommand=\"$command -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      command=\"$command$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\ntest \"$mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to building PIC objects only\n  -prefer-non-pic   try to building non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$mode'\"\n        ;;\n    esac\n\n    $ECHO\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n\n    exit $?\n}\n\n  # Now that we've collected a possible --mode arg, show help if necessary\n  $opt_help && func_mode_help\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $execute_dlfiles; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  dir=\"$dir/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -*) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_quote_for_eval \"$file\"\n      args=\"$args $func_quote_for_eval_result\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\t$ECHO \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libdirs=\"$nonopt\"\n    admincmds=\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for dir\n      do\n\tlibdirs=\"$libdirs $dir\"\n      done\n\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || admincmds=\"$admincmds\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    $ECHO \"Libraries have been installed in:\"\n    for libdir in $libdirs; do\n      $ECHO \"   $libdir\"\n    done\n    $ECHO\n    $ECHO \"If you ever happen to want to link against installed libraries\"\n    $ECHO \"in a given directory, LIBDIR, you must either use libtool, and\"\n    $ECHO \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n    $ECHO \"flag during linking and do at least one of the following:\"\n    if test -n \"$shlibpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n      $ECHO \"     during execution\"\n    fi\n    if test -n \"$runpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n      $ECHO \"     during linking\"\n    fi\n    if test -n \"$hardcode_libdir_flag_spec\"; then\n      libdir=LIBDIR\n      eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n      $ECHO \"   - use the \\`$flag' linker flag\"\n    fi\n    if test -n \"$admincmds\"; then\n      $ECHO \"   - have your system administrator run these commands:$admincmds\"\n    fi\n    if test -f /etc/ld.so.conf; then\n      $ECHO \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n    fi\n    $ECHO\n\n    $ECHO \"See any operating system documentation about shared libraries for\"\n    case $host in\n      solaris2.[6789]|solaris2.1[0-9])\n        $ECHO \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t$ECHO \"pages.\"\n\t;;\n      *)\n        $ECHO \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n        ;;\n    esac\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    exit $EXIT_SUCCESS\n}\n\ntest \"$mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       $ECHO \"X$nonopt\" | $GREP shtool >/dev/null; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    install_prog=\"$install_prog$func_quote_for_eval_result\"\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    for arg\n    do\n      if test -n \"$dest\"; then\n\tfiles=\"$files $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tcase \" $install_prog \" in\n\t*[\\\\\\ /]cp\\ *) ;;\n\t*) prev=$arg ;;\n\tesac\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      install_prog=\"$install_prog $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tstaticlibs=\"$staticlibs $file\"\n\t;;\n\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) current_libdirs=\"$current_libdirs $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) future_libdirs=\"$future_libdirs $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tdir=\"$dir$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"X$destdir\" | $Xsed -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && staticlibs=\"$staticlibs $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"X$lib\" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"X$relink_command\" | $Xsed -e 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"X$file$stripped_ext\" | $Xsed -e \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"X$objs$old_deplibs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_verbose \"extracting global C symbols from \\`$progfile'\"\n\t    $opt_dry_run || eval \"$NM $progfile | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n\t  $opt_dry_run || {\n\t    eval '$ECHO \": $name \" >> \"$nlist\"'\n\t    eval \"$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t  }\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    $ECHO '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\n\"\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* )\n\t    $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n/* DATA imports from DLLs on WIN32 con't be const, because\n   runtime relocations are performed -- see ld's documentation\n   on pseudo-relocs.  */\"\n\t    lt_dlsym_const= ;;\n\t  *osf5*)\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* This system does not cope well with relocations in const data */\"\n\t    lt_dlsym_const= ;;\n\t  *)\n\t    lt_dlsym_const=const ;;\n\t  esac\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\nextern $lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\n$lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) symtab_cflags=\"$symtab_cflags $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then\n      win32_nmres=`eval $NM -f posix -A $1 |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" 'exit $?'\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n\n# func_emit_wrapper_part1 [arg=no]\n#\n# Emit the first part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part1 ()\n{\n\tfunc_emit_wrapper_part1_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part1_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed='${SED} -e 1s/^X//'\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    ECHO=\\\"$qecho\\\"\n    file=\\\"\\$0\\\"\n    # Make sure echo works.\n    if test \\\"X\\$1\\\" = X--no-reexec; then\n      # Discard the --no-reexec flag, and continue.\n      shift\n    elif test \\\"X\\`{ \\$ECHO '\\t'; } 2>/dev/null\\`\\\" = 'X\\t'; then\n      # Yippee, \\$ECHO works!\n      :\n    else\n      # Restart under the correct shell, and then maybe \\$ECHO will work.\n      exec $SHELL \\\"\\$0\\\" --no-reexec \\${1+\\\"\\$@\\\"}\n    fi\n  fi\\\n\"\n\t$ECHO \"\\\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  done\n\"\n}\n# end: func_emit_wrapper_part1\n\n# func_emit_wrapper_part2 [arg=no]\n#\n# Emit the second part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part2 ()\n{\n\tfunc_emit_wrapper_part2_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part2_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"X\\$thisdir\\\" | \\$Xsed -e 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"X\\$$shlibpath_var\\\" | \\$Xsed -e 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t# fixup the dll searchpath if we need to.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n\"\n\tcase $host in\n\t# Backslashes separate directories on plain windows\n\t*-*-mingw | *-*-os2* | *-cegcc*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\n\t*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\tesac\n\t$ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    $ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n# end: func_emit_wrapper_part2\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_arg1=$1\n\tfi\n\n\t# split this up so that func_emit_cwrapperexe_src\n\t# can call each part independently.\n\tfunc_emit_wrapper_part1 \"${func_emit_wrapper_arg1}\"\n\tfunc_emit_wrapper_part2 \"${func_emit_wrapper_arg1}\"\n}\n\n\n# func_to_host_path arg\n#\n# Convert paths to host format when used with build tools.\n# Intended for use with \"native\" mingw (where libtool itself\n# is running under the msys shell), or in the following cross-\n# build environments:\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n# where wine is equipped with the `winepath' executable.\n# In the native mingw case, the (msys) shell automatically\n# converts paths for any non-msys applications it launches,\n# but that facility isn't available from inside the cwrapper.\n# Similar accommodations are necessary for $host mingw and\n# $build cygwin.  Calling this function does no harm for other\n# $host/$build combinations not listed above.\n#\n# ARG is the path (on $build) that should be converted to\n# the proper representation for $host. The result is stored\n# in $func_to_host_path_result.\nfunc_to_host_path ()\n{\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        case $build in\n          *mingw* ) # actually, msys\n            # awkward: cmd appends spaces to result\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_path_tmp1=`( cmd //c echo \"$1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_path_tmp1=`cygpath -w \"$1\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # Unfortunately, winepath does not exit with a non-zero\n            # error code, so we are forced to check the contents of\n            # stdout. On the other hand, if the command is not\n            # found, the shell will set an exit code of 127 and print\n            # *an error message* to stdout. So we must check for both\n            # error code of zero AND non-empty stdout, which explains\n            # the odd construction:\n            func_to_host_path_tmp1=`winepath -w \"$1\" 2>/dev/null`\n            if test \"$?\" -eq 0 && test -n \"${func_to_host_path_tmp1}\"; then\n              func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n                $SED -e \"$lt_sed_naive_backslashify\"`\n            else\n              # Allow warning below.\n              func_to_host_path_result=\"\"\n            fi\n            ;;\n        esac\n        if test -z \"$func_to_host_path_result\" ; then\n          func_error \"Could not determine host path corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback:\n          func_to_host_path_result=\"$1\"\n        fi\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_path\n\n# func_to_host_pathlist arg\n#\n# Convert pathlists to host format when used with build tools.\n# See func_to_host_path(), above. This function supports the\n# following $build/$host combinations (but does no harm for\n# combinations not listed here):\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n#\n# Path separators are also converted from $build format to\n# $host format. If ARG begins or ends with a path separator\n# character, it is preserved (but converted to $host format)\n# on output.\n#\n# ARG is a pathlist (on $build) that should be converted to\n# the proper representation on $host. The result is stored\n# in $func_to_host_pathlist_result.\nfunc_to_host_pathlist ()\n{\n  func_to_host_pathlist_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        # Remove leading and trailing path separator characters from\n        # ARG. msys behavior is inconsistent here, cygpath turns them\n        # into '.;' and ';.', and winepath ignores them completely.\n        func_to_host_pathlist_tmp2=\"$1\"\n        # Once set for this call, this variable should not be\n        # reassigned. It is used in tha fallback case.\n        func_to_host_pathlist_tmp1=`echo \"$func_to_host_pathlist_tmp2\" |\\\n          $SED -e 's|^:*||' -e 's|:*$||'`\n        case $build in\n          *mingw* ) # Actually, msys.\n            # Awkward: cmd appends spaces to result.\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_pathlist_tmp2=`( cmd //c echo \"$func_to_host_pathlist_tmp1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_pathlist_tmp2=`cygpath -w -p \"$func_to_host_pathlist_tmp1\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # unfortunately, winepath doesn't convert pathlists\n            func_to_host_pathlist_result=\"\"\n            func_to_host_pathlist_oldIFS=$IFS\n            IFS=:\n            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do\n              IFS=$func_to_host_pathlist_oldIFS\n              if test -n \"$func_to_host_pathlist_f\" ; then\n                func_to_host_path \"$func_to_host_pathlist_f\"\n                if test -n \"$func_to_host_path_result\" ; then\n                  if test -z \"$func_to_host_pathlist_result\" ; then\n                    func_to_host_pathlist_result=\"$func_to_host_path_result\"\n                  else\n                    func_to_host_pathlist_result=\"$func_to_host_pathlist_result;$func_to_host_path_result\"\n                  fi\n                fi\n              fi\n              IFS=:\n            done\n            IFS=$func_to_host_pathlist_oldIFS\n            ;;\n        esac\n        if test -z \"$func_to_host_pathlist_result\" ; then\n          func_error \"Could not determine the host path(s) corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback. This may break if $1 contains DOS-style drive\n          # specifications. The fix is not to complicate the expression\n          # below, but for the user to provide a working wine installation\n          # with winepath so that path translation in the cross-to-mingw\n          # case works properly.\n          lt_replace_pathsep_nix_to_dos=\"s|:|;|g\"\n          func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp1\" |\\\n            $SED -e \"$lt_replace_pathsep_nix_to_dos\"`\n        fi\n        # Now, add the leading and trailing path separators back\n        case \"$1\" in\n          :* ) func_to_host_pathlist_result=\";$func_to_host_pathlist_result\"\n            ;;\n        esac\n        case \"$1\" in\n          *: ) func_to_host_pathlist_result=\"$func_to_host_pathlist_result;\"\n            ;;\n        esac\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_pathlist\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n\n   Currently, it simply execs the wrapper *script* \"$SHELL $output\",\n   but could eventually absorb all of the scripts functionality and\n   exec $objdir/$outputname directly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n# define setmode _setmode\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n#  define HAVE_SETENV\n#  ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n#  endif\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n#ifdef _MSC_VER\n# define S_IXUSR _S_IEXEC\n# define stat _stat\n# ifndef _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifdef __CYGWIN__\n# define FOPEN_WB \"wb\"\n#endif\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#undef LTWRAPPER_DEBUGPRINTF\n#if defined DEBUGWRAPPER\n# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args\nstatic void\nltwrapper_debugprintf (const char *fmt, ...)\n{\n    va_list args;\n    va_start (args, fmt);\n    (void) vfprintf (stderr, fmt, args);\n    va_end (args);\n}\n#else\n# define LTWRAPPER_DEBUGPRINTF(args)\n#endif\n\nconst char *program_name = NULL;\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_fatal (const char *message, ...);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_opt_process_env_set (const char *arg);\nvoid lt_opt_process_env_prepend (const char *arg);\nvoid lt_opt_process_env_append (const char *arg);\nint lt_split_name_value (const char *arg, char** name, char** value);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\n\nstatic const char *script_text_part1 =\nEOF\n\n\t    func_emit_wrapper_part1 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\t    cat <<EOF\n\nstatic const char *script_text_part2 =\nEOF\n\t    func_emit_wrapper_part2 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\n\t    cat <<EOF\nconst char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_pathlist \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_pathlist \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n#define LTWRAPPER_OPTION_PREFIX_LENGTH  5\n\nstatic const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\n\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\n\nstatic const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;\nstatic const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX \"env-set\";\n  /* argument is putenv-style \"foo=bar\", value of foo is set to bar */\n\nstatic const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;\nstatic const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX \"env-prepend\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is bar${foo} */\n\nstatic const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;\nstatic const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX \"env-append\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is ${foo}bar */\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) argv[0]      : %s\\n\", argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) program_name : %s\\n\", program_name));\n\n  /* very simple arg parsing; don't want to rely on getopt */\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  printf (\"%s\", script_text_part1);\n\t  printf (\"%s\", script_text_part2);\n\t  return 0;\n\t}\n    }\n\n  newargz = XMALLOC (char *, argc + 1);\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (\"Couldn't find %s\", argv[0]);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (before symlink chase) at : %s\\n\",\n\t\t\t  tmp_pathspec));\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (after symlink chase) at : %s\\n\",\n\t\t\t  actual_cwrapper_path));\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(main) libtool target name: %s\\n\",\n\t\t\t  target_name));\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)\n        {\n          if (argv[i][env_set_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_set_opt_len + 1;\n              lt_opt_process_env_set (p);\n            }\n          else if (argv[i][env_set_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_set (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_set_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)\n        {\n          if (argv[i][env_prepend_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_prepend_opt_len + 1;\n              lt_opt_process_env_prepend (p);\n            }\n          else if (argv[i][env_prepend_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_prepend (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_prepend_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)\n        {\n          if (argv[i][env_append_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_append_opt_len + 1;\n              lt_opt_process_env_append (p);\n            }\n          else if (argv[i][env_append_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_append (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_append_opt);\n          continue;\n        }\n      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (\"Unrecognized option in %s namespace: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\n  LTWRAPPER_DEBUGPRINTF     ((\"(main) lt_argv_zero : %s\\n\", (lt_argv_zero ? lt_argv_zero : \"<NULL>\")));\n  for (i = 0; i < newargc; i++)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"(main) newargz[%d]   : %s\\n\", i, (newargz[i] ? newargz[i] : \"<NULL>\")));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      LTWRAPPER_DEBUGPRINTF ((\"(main) failed to launch target \\\"%s\\\": errno = %d\\n\", lt_argv_zero, errno));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (\"Memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(check_executable)  : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(make_executable)   : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(find_executable)   : %s\\n\",\n\t\t\t  wrapper ? (*wrapper ? wrapper : \"EMPTY!\") : \"NULL!\"));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (\"getcwd failed\");\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (\"getcwd failed\");\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"checking path component for symlinks: %s\\n\",\n\t\t\t      tmp_pathspec));\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  char *errstr = strerror (errno);\n\t  lt_fatal (\"Error accessing file %s (%s)\", tmp_pathspec, errstr);\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (\"Could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nstatic void\nlt_error_core (int exit_status, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s: %s: \", program_name, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_setenv) setting '%s' to '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nint\nlt_split_name_value (const char *arg, char** name, char** value)\n{\n  const char *p;\n  int len;\n  if (!arg || !*arg)\n    return 1;\n\n  p = strchr (arg, (int)'=');\n\n  if (!p)\n    return 1;\n\n  *value = xstrdup (++p);\n\n  len = strlen (arg) - strlen (*value);\n  *name = XMALLOC (char, len);\n  strncpy (*name, arg, len-1);\n  (*name)[len - 1] = '\\0';\n\n  return 0;\n}\n\nvoid\nlt_opt_process_env_set (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_set_opt, arg);\n    }\n\n  lt_setenv (name, value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_prepend (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_prepend_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 0);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_append (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_append_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 1);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\n\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      dlfiles=\"$dlfiles $arg\"\n\t    else\n\t      dlprefiles=\"$dlprefiles $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) deplibs=\"$deplibs $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      moreargs=\"$moreargs $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      dlfiles=\"$dlfiles $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    dlprefiles=\"$dlprefiles $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) rpath=\"$rpath $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) xrpath=\"$xrpath $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  weak_libs=\"$weak_libs $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname '-L' '' \"$arg\"\n\tdir=$func_stripname_result\n\tif test -z \"$dir\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"*) ;;\n\t*)\n\t  deplibs=\"$deplibs -L$dir\"\n\t  lib_search_path=\"$lib_search_path $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"X$dir\" | $Xsed -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tdeplibs=\"$deplibs $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) xrpath=\"$xrpath $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $wl$func_quote_for_eval_result\"\n\t  linker_flags=\"$linker_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler\n      # -r[0-9][0-9]* specifies the processor on the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler\n      # +DA*, +DD* enable 64-bit mode on the HP compiler\n      # -q* pass through compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* pass through architecture-specific\n      # compiler args for GCC\n      # -F/path gives path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC\n      # @file GCC response files\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        compiler_flags=\"$compiler_flags $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tobjs=\"$objs $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tdlfiles=\"$dlfiles $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      dlprefiles=\"$dlprefiles $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tdeplibs=\"$deplibs $arg\"\n\told_deplibs=\"$old_deplibs $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  dlfiles=\"$dlfiles $arg\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  dlprefiles=\"$dlprefiles $arg\"\n\t  prev=\n\telse\n\t  deplibs=\"$deplibs $arg\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"X\\${$shlibpath_var}\\\" \\| \\$Xsed -e \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_duplicate_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\tesac\n      fi\n      libs=\"$libs $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) specialdeplibs=\"$specialdeplibs $pre_post_deps\" ;;\n\t  esac\n\t  pre_post_deps=\"$pre_post_deps $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  case $lib in\n\t  *.la)\tfunc_source \"$lib\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n            deplib_base=`$ECHO \"X$deplib\" | $Xsed -e \"$basename\"`\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) deplibs=\"$deplibs $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    compiler_flags=\"$compiler_flags $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    dir=$func_stripname_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) xrpath=\"$xrpath $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la) lib=\"$deplib\" ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"X$deplib\\\"\" 2>/dev/null | $Xsed -e 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\t$ECHO \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      newdlprefiles=\"$newdlprefiles $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      newdlfiles=\"$newdlfiles $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"X$inherited_linker_flags\" | $Xsed -e 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) new_inherited_linker_flags=\"$new_inherited_linker_flags $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \"X $dependency_libs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && dlfiles=\"$dlfiles $dlopen\"\n\t  test -n \"$dlpreopen\" && dlprefiles=\"$dlprefiles $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    convenience=\"$convenience $ladir/$objdir/$old_library\"\n\t    old_convenience=\"$old_convenience $ladir/$objdir/$old_library\"\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tfor l in $old_library $library_names; do\n\t  linklib=\"$l\"\n\tdone\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    dlprefiles=\"$dlprefiles $lib $dependency_libs\"\n\t  else\n\t    newdlfiles=\"$newdlfiles $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$libdir\"\n\t    absdir=\"$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t  # are required to link).\n\t  if test -n \"$old_library\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$old_library\"\n\t    # Keep a list of preopened convenience libraries to check\n\t    # that they are being used correctly in the link pass.\n\t    test -z \"$libdir\" && \\\n\t\tdlpreconveniencelibs=\"$dlpreconveniencelibs $dir/$old_library\"\n\t  # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t  elif test -n \"$dlname\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$dlname\"\n\t  else\n\t    newdlprefiles=\"$newdlprefiles $dir/$linklib\"\n\t  fi\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  newlib_search_path=\"$newlib_search_path $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) temp_rpath=\"$temp_rpath$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    $ECHO\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  $ECHO\n\t\t\t  $ECHO \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  $ECHO \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$dir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) compile_shlibpath=\"$compile_shlibpath$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    $ECHO\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t    $ECHO \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      $ECHO \"*** But as you try to build a module library, libtool will still create \"\n\t      $ECHO \"*** a static module, that should work as long as the dlopening application\"\n\t      $ECHO \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\t$ECHO\n\t\t$ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t\t$ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\t$ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t\t$ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) xrpath=\"$xrpath $temp_xrpath\";;\n\t\t   esac;;\n\t      *) temp_deplibs=\"$temp_deplibs $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  newlib_search_path=\"$newlib_search_path $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=\"$func_dirname_result\"\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      compiler_flags=\"$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      linker_flags=\"$linker_flags -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) lib_search_path=\"$lib_search_path $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  tmp_libs=\"$tmp_libs $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      objs=\"$objs$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  $ECHO\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  libobjs=\"$libobjs $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  verstring=\"$verstring:${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      libobjs=\"$libobjs $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       removelist=\"$removelist $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\toldlibs=\"$oldlibs $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}'$/d' -e \"$lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"X$lib_search_path \" | $Xsed -e \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"X$deplibs \" | $Xsed -e \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"X$dependency_libs \" | $Xsed -e \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  temp_xrpath=\"$temp_xrpath -R$libdir\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlfiles=\"$dlfiles $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlprefiles=\"$dlprefiles $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      deplibs=\"$deplibs -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    $ECHO\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    $ECHO \"*** shared version of the library, which I believe you do not have\"\n\t\t    $ECHO \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    $ECHO \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      $ECHO\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t      $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      $ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t      $ECHO \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      $ECHO \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  $ECHO\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  $ECHO \"*** make it link in!  You will probably need to install it or some\"\n\t\t  $ECHO \"*** library that it depends on before this library will be fully\"\n\t\t  $ECHO \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"X$potlib\" | $Xsed -e 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tnewdeplibs=\"$newdeplibs $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"X$potent_lib\\\"\" 2>/dev/null | $Xsed -e 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \"X $deplibs\" | $Xsed \\\n\t      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \"X $tmp_deplibs\" | $Xsed -e \"s,$i,,\"`\n\t    done\n\t  fi\n\t  if $ECHO \"X $tmp_deplibs\" | $Xsed -e 's/[\t ]//g' |\n\t     $GREP . >/dev/null; then\n\t    $ECHO\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      $ECHO \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      $ECHO \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    $ECHO \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t  fi\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    $ECHO\n\t    $ECHO \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    $ECHO \"*** a static module, that should work as long as the dlopening\"\n\t    $ECHO \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      $ECHO\n\t      $ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t      $ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      $ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t      $ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    $ECHO \"*** The inter-library dependencies that have been dropped here will be\"\n\t    $ECHO \"*** automatically added whenever a program is linked with this library\"\n\t    $ECHO \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      $ECHO\n\t      $ECHO \"*** Since this library must not contain undefined symbols,\"\n\t      $ECHO \"*** because either the platform does not support them or\"\n\t      $ECHO \"*** it was explicitly requested with -no-undefined,\"\n\t      $ECHO \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \"X $deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    hardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tdep_rpath=\"$dep_rpath $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    if test -n \"$hardcode_libdir_flag_spec_ld\"; then\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec_ld\\\"\n\t    else\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\n\t    fi\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      rpath=\"$rpath$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  linknames=\"$linknames $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  delfiles=\"$delfiles $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      eval cmd=\\\"$cmd\\\"\n\t      func_len \" $cmd\"\n\t      len=$func_len_result\n\t      if test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    tmp_deplibs=\"$tmp_deplibs $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    generated=\"$generated $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    libobjs=\"$libobjs $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  linker_flags=\"$linker_flags $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  output_la=`$ECHO \"X$output\" | $Xsed -e \"$basename\"`\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    $ECHO 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    $ECHO ')' >> $output\n\t    delfiles=\"$delfiles $output\"\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    delfiles=\"$delfiles $output\"\n\t    output=$firstobj\\\"$file_list_spec$output\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    eval concat_cmds=\\\"$reload_cmds $objlist $last_robj\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds $objlist $last_robj~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=$obj\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds $objlist $last_robj\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      delfiles=\"$delfiles $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  libobjs=\"$libobjs $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"X$tmp_whole_archive_flags\" | $Xsed -e 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}$'/d' -e '/\\.lib$/d' -e \"$lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      compile_command=\"$compile_command ${wl}-bind_at_load\"\n\t      finalize_command=\"$finalize_command ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      compile_command=\"$compile_command $compile_deplibs\"\n      finalize_command=\"$finalize_command $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_perm_rpath=\"$finalize_perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"X$compile_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"X$finalize_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *cegcc)\n        # Disable wrappers for cegcc, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"X$compile_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"X$compile_var$compile_command$compile_rpath\" | $Xsed -e 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Quote $ECHO for shipping.\n      if test \"X$ECHO\" = \"X$SHELL $progpath --fallback-echo\"; then\n\tcase $progpath in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) qecho=\"$SHELL $progpath --fallback-echo\";;\n\t*) qecho=\"$SHELL `pwd`/$progpath --fallback-echo\";;\n\tesac\n\tqecho=`$ECHO \"X$qecho\" | $Xsed -e \"$sed_quote_subst\"`\n      else\n\tqecho=`$ECHO \"X$ECHO\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    oldobjs=\"$oldobjs $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tgenerated=\"$generated $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\toldobjs=\"$oldobjs $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  oldobjs=\"$oldobjs $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  $ECHO \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      oldobjs=\"$oldobjs $gentop/$newobj\"\n\t      ;;\n\t    *) oldobjs=\"$oldobjs $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tnewdependency_libs=\"$newdependency_libs $libdir/$name\"\n\t\t;;\n\t      *) newdependency_libs=\"$newdependency_libs $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlfiles=\"$newdlfiles $libdir/$name\"\n\t\t;;\n\t      *) newdlfiles=\"$newdlfiles $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlprefiles=\"$newdlprefiles $libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlfiles=\"$newdlfiles $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlprefiles=\"$newdlprefiles $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$mode\" = link || test \"$mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) RM=\"$RM $arg\"; rmforce=yes ;;\n      -*) RM=\"$RM $arg\" ;;\n      *) files=\"$files $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    origobjdir=\"$objdir\"\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\tobjdir=\"$origobjdir\"\n      else\n\tobjdir=\"$dir/$origobjdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$mode\" = uninstall && objdir=\"$dir\"\n\n      # Remember objdir for removal later, being careful to avoid duplicates\n      if test \"$mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $objdir \"*) ;;\n\t  *) rmdirs=\"$rmdirs $objdir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    rmfiles=\"$rmfiles $objdir/$n\"\n\t  done\n\t  test -n \"$old_library\" && rmfiles=\"$rmfiles $objdir/$old_library\"\n\n\t  case \"$mode\" in\n\t  clean)\n\t    case \"  $library_names \" in\n\t    # \"  \" in the beginning catches empty $dlname\n\t    *\" $dlname \"*) ;;\n\t    *) rmfiles=\"$rmfiles $objdir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && rmfiles=\"$rmfiles $objdir/$name $objdir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    rmfiles=\"$rmfiles $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      rmfiles=\"$rmfiles $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    rmfiles=\"$rmfiles $objdir/$name $objdir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      rmfiles=\"$rmfiles $objdir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      rmfiles=\"$rmfiles $objdir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n    objdir=\"$origobjdir\"\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$mode\" = uninstall || test \"$mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/portability/memory.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n#include <portability/toku_config.h>\n\n#include <toku_portability.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#if defined(HAVE_MALLOC_H)\n# include <malloc.h>\n#elif defined(HAVE_SYS_MALLOC_H)\n# include <sys/malloc.h>\n#endif\n#include <dlfcn.h>\n#include <toku_race_tools.h>\n#include \"memory.h\"\n#include \"toku_assert.h\"\n#include <portability/toku_atomic.h>\n\nstatic malloc_fun_t  t_malloc  = 0;\nstatic malloc_aligned_fun_t t_malloc_aligned = 0;\nstatic malloc_fun_t  t_xmalloc = 0;\nstatic malloc_aligned_fun_t t_xmalloc_aligned = 0;\nstatic free_fun_t    t_free    = 0;\nstatic realloc_fun_t t_realloc = 0;\nstatic realloc_aligned_fun_t t_realloc_aligned = 0;\nstatic realloc_fun_t t_xrealloc = 0;\n\nstatic LOCAL_MEMORY_STATUS_S status;\nint toku_memory_do_stats = 0;\n\nstatic bool memory_startup_complete;\n\nint\ntoku_memory_startup(void) {\n    if (memory_startup_complete) {\n        return 0;\n    }\n    memory_startup_complete = true;\n\n    int result = 0;\n\n#if defined(HAVE_M_MMAP_THRESHOLD)\n    // initialize libc malloc\n    size_t mmap_threshold = 64 * 1024; // 64K and larger should be malloced with mmap().\n    int success = mallopt(M_MMAP_THRESHOLD, mmap_threshold);\n    if (success) {\n        status.mallocator_version = \"libc\";\n        status.mmap_threshold = mmap_threshold;\n    } else\n        result = EINVAL;\n#else\n    // just a guess\n    status.mallocator_version = \"darwin\";\n    status.mmap_threshold = 16 * 1024;\n#endif\n\n    // jemalloc has a mallctl function, while libc malloc does not.  we can check if jemalloc \n    // is loaded by checking if the mallctl function can be found.  if it can, we call it \n    // to get version and mmap threshold configuration.\n    typedef int (*mallctl_fun_t)(const char *, void *, size_t *, void *, size_t);\n    mallctl_fun_t mallctl_f;\n    mallctl_f = (mallctl_fun_t) dlsym(RTLD_DEFAULT, \"mallctl\");\n    if (mallctl_f) { // jemalloc is loaded\n        size_t version_length = sizeof status.mallocator_version;\n        result = mallctl_f(\"version\", &status.mallocator_version, &version_length, NULL, 0);\n        if (result == 0) {\n            size_t lg_chunk; // log2 of the mmap threshold\n            size_t lg_chunk_length = sizeof lg_chunk;\n            result  = mallctl_f(\"opt.lg_chunk\", &lg_chunk, &lg_chunk_length, NULL, 0);\n            if (result == 0)\n                status.mmap_threshold = 1 << lg_chunk;\n        }\n    }\n\n    return result;\n}\n\nstatic bool memory_shutdown_complete;\n\nvoid\ntoku_memory_shutdown(void) {\n    if (memory_shutdown_complete) {\n        return;\n    }\n    memory_shutdown_complete = true;\n}\n\nvoid \ntoku_memory_get_status(LOCAL_MEMORY_STATUS s) {\n    *s = status;\n}\n\n// jemalloc's malloc_usable_size does not work with a NULL pointer, so we implement a version that works\nstatic size_t\nmy_malloc_usable_size(void *p) {\n    return p == NULL ? 0 : os_malloc_usable_size(p);\n}\n\n// Note that max_in_use may be slightly off because use of max_in_use is not thread-safe.\n// It is not worth the overhead to make it completely accurate, but\n// this logic is intended to guarantee that it increases monotonically.\n// Note that status.sum_used and status.sum_freed increase monotonically\n// and that status.max_in_use is declared volatile.\nstatic inline void \nset_max(uint64_t sum_used, uint64_t sum_freed) {\n    if (sum_used >= sum_freed) {\n        uint64_t in_use = sum_used - sum_freed;\n        uint64_t old_max;\n        do {\n            old_max = status.max_in_use;\n        } while (old_max < in_use &&\n                 !toku_sync_bool_compare_and_swap(&status.max_in_use, old_max, in_use));\n    }\n}\n\n// Effect: Like toku_memory_footprint, except instead of passing p,\n//   we pass toku_malloc_usable_size(p).\nsize_t \ntoku_memory_footprint_given_usable_size(size_t touched, size_t usable)\n{\n    size_t pagesize = toku_os_get_pagesize();\n    if (usable >= status.mmap_threshold) {\n        int num_pages = (touched + pagesize) / pagesize;\n        return num_pages * pagesize;\n    }\n    return usable;\n}\n\n// Effect: Return an estimate how how much space an object is using, possibly by\n//   using toku_malloc_usable_size(p).\n//   If p is NULL then returns 0.\nsize_t\ntoku_memory_footprint(void * p, size_t touched)\n{\n    if (!p) return 0;\n    return toku_memory_footprint_given_usable_size(touched,\n                                                   my_malloc_usable_size(p));\n}\n\nvoid *\ntoku_malloc(size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    void *p = t_malloc ? t_malloc(size) : os_malloc(size);\n    if (p) {\n        TOKU_ANNOTATE_NEW_MEMORY(p, size); // see #4671 and https://bugs.kde.org/show_bug.cgi?id=297147\n        if (toku_memory_do_stats) {\n            size_t used = my_malloc_usable_size(p);\n            toku_sync_add_and_fetch(&status.malloc_count, 1);\n            toku_sync_add_and_fetch(&status.requested,size);\n            toku_sync_add_and_fetch(&status.used, used);\n            set_max(status.used, status.freed);\n        }\n    } else {\n        toku_sync_add_and_fetch(&status.malloc_fail, 1);\n        status.last_failed_size = size;\n    }\n  return p;\n}\n\nvoid *toku_malloc_aligned(size_t alignment, size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    void *p = t_malloc_aligned ? t_malloc_aligned(alignment, size) : os_malloc_aligned(alignment, size);\n    if (p) {\n        TOKU_ANNOTATE_NEW_MEMORY(p, size); // see #4671 and https://bugs.kde.org/show_bug.cgi?id=297147\n        if (toku_memory_do_stats) {\n            size_t used = my_malloc_usable_size(p);\n            toku_sync_add_and_fetch(&status.malloc_count, 1);\n            toku_sync_add_and_fetch(&status.requested,size);\n            toku_sync_add_and_fetch(&status.used, used);\n            set_max(status.used, status.freed);\n        }\n    } else {\n        toku_sync_add_and_fetch(&status.malloc_fail, 1);\n        status.last_failed_size = size;\n    }\n  return p;\n}\n\nvoid *\ntoku_calloc(size_t nmemb, size_t size) {\n    size_t newsize = nmemb * size;\n    void *p = toku_malloc(newsize);\n    if (p) memset(p, 0, newsize);\n    return p;\n}\n\nvoid *\ntoku_realloc(void *p, size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        if (p != nullptr) {\n            toku_free(p);\n        }\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    size_t used_orig = p ? my_malloc_usable_size(p) : 0;\n    void *q = t_realloc ? t_realloc(p, size) : os_realloc(p, size);\n    if (q) {\n        if (toku_memory_do_stats) {\n            size_t used = my_malloc_usable_size(q);\n            toku_sync_add_and_fetch(&status.realloc_count, 1);\n            toku_sync_add_and_fetch(&status.requested, size);\n            toku_sync_add_and_fetch(&status.used, used);\n            toku_sync_add_and_fetch(&status.freed, used_orig);\n            set_max(status.used, status.freed);\n        }\n    } else {\n        toku_sync_add_and_fetch(&status.realloc_fail, 1);\n        status.last_failed_size = size;\n    }\n    return q;\n}\n\nvoid *toku_realloc_aligned(size_t alignment, void *p, size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        if (p != nullptr) {\n            toku_free(p);\n        }\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    size_t used_orig = p ? my_malloc_usable_size(p) : 0;\n    void *q = t_realloc_aligned ? t_realloc_aligned(alignment, p, size) : os_realloc_aligned(alignment, p, size);\n    if (q) {\n        if (toku_memory_do_stats) {\n            size_t used = my_malloc_usable_size(q);\n            toku_sync_add_and_fetch(&status.realloc_count, 1);\n            toku_sync_add_and_fetch(&status.requested, size);\n            toku_sync_add_and_fetch(&status.used, used);\n            toku_sync_add_and_fetch(&status.freed, used_orig);\n            set_max(status.used, status.freed);\n        }\n    } else {\n        toku_sync_add_and_fetch(&status.realloc_fail, 1);\n        status.last_failed_size = size;\n    }\n    return q;\n}\n\n\nvoid *\ntoku_memdup(const void *v, size_t len) {\n    void *p = toku_malloc(len);\n    if (p) memcpy(p, v,len);\n    return p;\n}\n\nchar *\ntoku_strdup(const char *s) {\n    return (char *) toku_memdup(s, strlen(s)+1);\n}\n\nchar *toku_strndup(const char *s, size_t n) {\n    size_t s_size = strlen(s);\n    size_t bytes_to_copy = n > s_size ? s_size : n;\n    ++bytes_to_copy;\n    char *result = (char *)toku_memdup(s, bytes_to_copy);\n    result[bytes_to_copy - 1] = 0;\n    return result;\n}\n\nvoid\ntoku_free(void *p) {\n    if (p) {\n        if (toku_memory_do_stats) {\n            size_t used = my_malloc_usable_size(p);\n            toku_sync_add_and_fetch(&status.free_count, 1);\n            toku_sync_add_and_fetch(&status.freed, used);\n        }\n        if (t_free)\n            t_free(p);\n        else\n            os_free(p);\n    }\n}\n\nvoid *\ntoku_xmalloc(size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    void *p = t_xmalloc ? t_xmalloc(size) : os_malloc(size);\n    if (p == NULL) {  // avoid function call in common case\n        status.last_failed_size = size;\n        resource_assert(p);\n    }\n    TOKU_ANNOTATE_NEW_MEMORY(p, size); // see #4671 and https://bugs.kde.org/show_bug.cgi?id=297147\n    if (toku_memory_do_stats) {\n        size_t used = my_malloc_usable_size(p);\n        toku_sync_add_and_fetch(&status.malloc_count, 1);\n        toku_sync_add_and_fetch(&status.requested, size);\n        toku_sync_add_and_fetch(&status.used, used);\n        set_max(status.used, status.freed);\n    }\n    return p;\n}\n\nvoid* toku_xmalloc_aligned(size_t alignment, size_t size)\n// Effect: Perform a malloc(size) with the additional property that the returned pointer is a multiple of ALIGNMENT.\n//  Fail with a resource_assert if the allocation fails (don't return an error code).\n// Requires: alignment is a power of two.\n{\n#if __APPLE__\n    if (size == 0) {\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    void *p = t_xmalloc_aligned ? t_xmalloc_aligned(alignment, size) : os_malloc_aligned(alignment,size);\n    if (p == NULL && size != 0) {\n        status.last_failed_size = size;\n        resource_assert(p);\n    }\n    if (toku_memory_do_stats) {\n        size_t used = my_malloc_usable_size(p);\n        toku_sync_add_and_fetch(&status.malloc_count, 1);\n        toku_sync_add_and_fetch(&status.requested, size);\n        toku_sync_add_and_fetch(&status.used, used);\n        set_max(status.used, status.freed);\n    }\n    return p;\n}\n\nvoid *\ntoku_xcalloc(size_t nmemb, size_t size) {\n    size_t newsize = nmemb * size;\n    void *vp = toku_xmalloc(newsize);\n    if (vp) memset(vp, 0, newsize);\n    return vp;\n}\n\nvoid *\ntoku_xrealloc(void *v, size_t size) {\n#if __APPLE__\n    if (size == 0) {\n        if (v != nullptr) {\n            toku_free(v);\n        }\n        return nullptr;\n    }\n#endif\n\n    if (size > status.max_requested_size) {\n        status.max_requested_size = size;\n    }\n    size_t used_orig = v ? my_malloc_usable_size(v) : 0;\n    void *p = t_xrealloc ? t_xrealloc(v, size) : os_realloc(v, size);\n    if (p == 0) {  // avoid function call in common case\n        status.last_failed_size = size;\n        resource_assert(p);\n    }\n    if (toku_memory_do_stats) {\n        size_t used = my_malloc_usable_size(p);\n        toku_sync_add_and_fetch(&status.realloc_count, 1);\n        toku_sync_add_and_fetch(&status.requested, size);\n        toku_sync_add_and_fetch(&status.used, used);\n        toku_sync_add_and_fetch(&status.freed, used_orig);\n        set_max(status.used, status.freed);\n    }\n    return p;\n}\n\nsize_t \ntoku_malloc_usable_size(void *p) {\n    return my_malloc_usable_size(p);\n}\n\nvoid *\ntoku_xmemdup (const void *v, size_t len) {\n    void *p = toku_xmalloc(len);\n    memcpy(p, v, len);\n    return p;\n}\n\nchar *\ntoku_xstrdup (const char *s) {\n    return (char *) toku_xmemdup(s, strlen(s)+1);\n}\n\nvoid\ntoku_set_func_malloc(malloc_fun_t f) {\n    t_malloc = f;\n    t_xmalloc = f;\n}\n\nvoid\ntoku_set_func_xmalloc_only(malloc_fun_t f) {\n    t_xmalloc = f;\n}\n\nvoid\ntoku_set_func_malloc_only(malloc_fun_t f) {\n    t_malloc = f;\n}\n\nvoid\ntoku_set_func_realloc(realloc_fun_t f) {\n    t_realloc = f;\n    t_xrealloc = f;\n}\n\nvoid\ntoku_set_func_xrealloc_only(realloc_fun_t f) {\n    t_xrealloc = f;\n}\n\nvoid\ntoku_set_func_realloc_only(realloc_fun_t f) {\n    t_realloc = f;\n\n}\n\nvoid\ntoku_set_func_free(free_fun_t f) {\n    t_free = f;\n}\n\n#include <toku_race_tools.h>\nvoid __attribute__((constructor)) toku_memory_helgrind_ignore(void);\nvoid\ntoku_memory_helgrind_ignore(void) {\n    TOKU_VALGRIND_HG_DISABLE_CHECKING(&status, sizeof status);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/portability/toku_assert.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n#include <portability/toku_config.h>\n\n#include <toku_portability.h>\n#include \"toku_assert.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#if defined(HAVE_MALLOC_H)\n# include <malloc.h>\n#elif defined(HAVE_SYS_MALLOC_H)\n# include <sys/malloc.h>\n#endif\n#include <dlfcn.h>\n#include <execinfo.h>\n\n// These are statically allocated so that the backtrace can run without any calls to malloc()\n#define N_POINTERS 1000\nstatic void *backtrace_pointers[N_POINTERS];\n\nstatic uint64_t engine_status_num_rows = 0;\n\ntypedef void (*malloc_stats_fun_t)(void);\nstatic malloc_stats_fun_t malloc_stats_f;\n\nvoid\ntoku_assert_init(void)\n{\n    malloc_stats_f = (malloc_stats_fun_t) dlsym(RTLD_DEFAULT, \"malloc_stats\");\n}\n\n// Function pointers are zero by default so asserts can be used by ft-layer tests without an environment.\nstatic int (*toku_maybe_get_engine_status_text_p)(char* buff, int buffsize) = 0;\nstatic int (*toku_maybe_err_engine_status_p)(void) = 0;\nstatic void (*toku_maybe_set_env_panic_p)(int code, const char* msg) = 0;\n\nvoid toku_assert_set_fpointers(int (*toku_maybe_get_engine_status_text_pointer)(char*, int),\n                               int (*toku_maybe_err_engine_status_pointer)(void),\n\t\t\t       void (*toku_maybe_set_env_panic_pointer)(int, const char*),\n                               uint64_t num_rows) {\n    toku_maybe_get_engine_status_text_p = toku_maybe_get_engine_status_text_pointer;\n    toku_maybe_err_engine_status_p = toku_maybe_err_engine_status_pointer;\n    toku_maybe_set_env_panic_p = toku_maybe_set_env_panic_pointer;\n    engine_status_num_rows = num_rows;\n}\n\nbool toku_gdb_dump_on_assert = false;\nvoid (*do_assert_hook)(void) = NULL;\n\nvoid db_env_do_backtrace_errfunc(toku_env_err_func errfunc, const void *env) {\n    // backtrace\n    int n = backtrace(backtrace_pointers, N_POINTERS);\n    errfunc(env, 0, \"Backtrace: (Note: toku_do_assert=0x%p)\\n\", toku_do_assert);\n    char **syms = backtrace_symbols(backtrace_pointers, n);\n    if (syms) {\n        for (char **symstr = syms; symstr != NULL && (symstr - syms) < n; ++symstr) {\n            errfunc(env, 0, *symstr);\n        }\n        free(syms);\n    }\n\n    if (engine_status_num_rows && toku_maybe_err_engine_status_p) {\n\ttoku_maybe_err_engine_status_p();\n    } else {\n\terrfunc(env, 0, \"Engine status function not available\\n\");\n    }\n    errfunc(env, 0, \"Memory usage:\\n\");\n    if (malloc_stats_f) {\n        malloc_stats_f();\n    }\n\n    if (do_assert_hook) do_assert_hook();\n    if (toku_gdb_dump_on_assert) {\n        toku_try_gdb_stack_trace(nullptr);\n    }\n}\n\nvoid db_env_do_backtrace(FILE *outf) {\n    // backtrace\n    int n = backtrace(backtrace_pointers, N_POINTERS);\n    fprintf(outf, \"Backtrace: (Note: toku_do_assert=0x%p)\\n\", toku_do_assert); fflush(outf);\n    backtrace_symbols_fd(backtrace_pointers, n, fileno(outf));\n\n    fflush(outf);\n    \n    if (engine_status_num_rows && toku_maybe_get_engine_status_text_p) {\n\tint buffsize = engine_status_num_rows * 128;  // assume 128 characters per row (gross overestimate, should be safe)\n\tchar buff[buffsize];\t\n\ttoku_maybe_get_engine_status_text_p(buff, buffsize);  \n\tfprintf(outf, \"Engine status:\\n%s\\n\", buff);\n    } else {\n\tfprintf(outf, \"Engine status function not available\\n\");\n    }\n    fprintf(outf, \"Memory usage:\\n\");\n    fflush(outf);\t    // just in case malloc_stats() crashes, we still want engine status (and to know that malloc_stats() failed)\n    if (malloc_stats_f) {\n        malloc_stats_f();\n    }\n    fflush(outf);\n\n    if (do_assert_hook) do_assert_hook();\n    if (toku_gdb_dump_on_assert) {\n        toku_try_gdb_stack_trace(nullptr);\n    }\n}\n\n__attribute__((noreturn))\nstatic void toku_do_backtrace_abort(void) {\n    db_env_do_backtrace(stderr);\n    abort();\n}\n\n\nstatic void\nset_panic_if_not_panicked(int caller_errno, char * msg) {\n    int code = caller_errno ? caller_errno : -1;\n    if (toku_maybe_set_env_panic_p) {\n\ttoku_maybe_set_env_panic_p(code, msg);\n    }\n}\n\n\n#define MSGLEN 1024\n\nvoid \ntoku_do_assert_fail (const char *expr_as_string, const char *function, const char *file, int line, int caller_errno) {\n    char msg[MSGLEN];\n    snprintf(msg, MSGLEN, \"%s:%d %s: Assertion `%s' failed (errno=%d)\\n\", file, line, function, expr_as_string, caller_errno);\n    perror(msg);\n    set_panic_if_not_panicked(caller_errno, msg);\n    toku_do_backtrace_abort();\n}\n\nvoid \ntoku_do_assert_zero_fail (uintptr_t expr, const char *expr_as_string, const char *function, const char *file, int line, int caller_errno) {\n    char msg[MSGLEN];\n    snprintf(msg, MSGLEN, \"%s:%d %s: Assertion `%s == 0' failed (errno=%d) (%s=%\" PRIuPTR \")\\n\", file, line, function, expr_as_string, caller_errno, expr_as_string, expr);\n    perror(msg);\n    set_panic_if_not_panicked(caller_errno, msg);\n    toku_do_backtrace_abort();\n}\n\nvoid\ntoku_do_assert_expected_fail (uintptr_t expr, uintptr_t expected, const char *expr_as_string, const char *function, const char *file, int line, int caller_errno) {\n    char msg[MSGLEN];\n    snprintf(msg, MSGLEN, \"%s:%d %s: Assertion `%s == %\" PRIuPTR \"' failed (errno=%d) (%s=%\" PRIuPTR \")\\n\", file, line, function, expr_as_string, expected, caller_errno, expr_as_string, expr);\n    perror(msg);\n    set_panic_if_not_panicked(caller_errno, msg);\n    toku_do_backtrace_abort();\n}\n\nvoid \ntoku_do_assert(int expr, const char *expr_as_string, const char *function, const char* file, int line, int caller_errno) {\n    if (expr == 0)\n        toku_do_assert_fail(expr_as_string, function, file, line, caller_errno);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/portability/os_malloc.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n#include <portability/toku_config.h>\n\n#include <toku_portability.h>\n#include <stdlib.h>\n#if defined(HAVE_MALLOC_H)\n# include <malloc.h>\n#elif defined(HAVE_SYS_MALLOC_H)\n# include <sys/malloc.h>\n#endif\n#include <dlfcn.h>\n\n#include <string.h>\n\n// #define this to use a version of os_malloc that helps to debug certain features.\n// This version uses the real malloc (so that valgrind should still work) but it forces things to be slightly\n// misaligned (in particular, avoiding 512-byte alignment if possible, to find situations where O_DIRECT will fail.\n// #define USE_DEBUGGING_MALLOCS\n\n#ifdef USE_DEBUGGING_MALLOCS\n#include <pthread.h>\n\n// Make things misaligned on 512-byte boundaries\nstatic size_t malloced_now_count=0, malloced_now_size=0;\nstruct malloc_pair {\n    void *returned_pointer;\n    void *true_pointer;\n    size_t requested_size = 0;\n};\nstatic struct malloc_pair *malloced_now;\nstatic pthread_mutex_t malloc_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void malloc_lock(void) {\n    int r = pthread_mutex_lock(&malloc_mutex);\n    assert(r==0);\n}\nstatic void malloc_unlock(void) {\n    int r = pthread_mutex_unlock(&malloc_mutex);\n    assert(r==0);\n}\n\nstatic void push_to_malloced_memory(void *returned_pointer, void *true_pointer, size_t requested_size) {\n    malloc_lock();\n    if (malloced_now_count == malloced_now_size) {\n        malloced_now_size = 2*malloced_now_size + 1;\n        malloced_now = (struct malloc_pair *)realloc(malloced_now, malloced_now_size * sizeof(*malloced_now));\n    }\n    malloced_now[malloced_now_count].returned_pointer = returned_pointer;\n    malloced_now[malloced_now_count].true_pointer     = true_pointer;\n    malloced_now[malloced_now_count].requested_size   = requested_size;\n    malloced_now_count++;\n    malloc_unlock();\n}\n\nstatic struct malloc_pair *find_malloced_pair(const void *p)\n// Requires: Lock must be held before calling.\n{\n    for (size_t i=0; i<malloced_now_count; i++) {\n        if (malloced_now[i].returned_pointer==p) return &malloced_now[i];\n    }\n    return 0;\n}\n\nvoid *os_malloc(size_t size) {\n    void  *raw_ptr   = malloc(size+16); // allocate 16 extra bytes\n    size_t raw_ptr_i = (size_t) raw_ptr; \n    if (raw_ptr_i%512==0) {\n        push_to_malloced_memory(16+(char*)raw_ptr, raw_ptr, size);\n        return 16+(char*)raw_ptr;\n    } else {\n        push_to_malloced_memory(raw_ptr,    raw_ptr, size);\n        return raw_ptr;\n    }\n}\n\nvoid *os_malloc_aligned(size_t alignment, size_t size)\n// Effect: Perform a malloc(size) with the additional property that the returned pointer is a multiple of ALIGNMENT.\n// Requires: alignment is a power of two.\n{\n    void *p;\n    int r = posix_memalign(&p, alignment, size);\n    if (r != 0) {\n        errno = r;\n        p = nullptr;\n    }\n    return p;\n    if (alignment%512==0) {\n        void *raw_ptr;\n        int r = posix_memalign(&raw_ptr, alignment, size);\n        if (r != 0) {\n            errno = r;\n            return nullptr;\n        }\n        push_to_malloced_memory(raw_ptr, raw_ptr, size);\n        return raw_ptr;\n    } else {\n        // Make sure it isn't 512-byte aligned\n        void *raw_ptr;\n        int r = posix_memalign(&raw_ptr, alignment, size+alignment);\n        if (r != 0) {\n            errno = r;\n            return nullptr;\n        }\n        size_t raw_ptr_i = (size_t) raw_ptr;\n        if (raw_ptr_i%512==0) {\n            push_to_malloced_memory(alignment+(char*)raw_ptr, raw_ptr, size);\n            return alignment+(char*)raw_ptr;\n        } else {\n            push_to_malloced_memory(raw_ptr,    raw_ptr, size);\n            return raw_ptr;\n        }\n    }\n}\n\nstatic size_t min(size_t a, size_t b) {\n    if (a<b) return a;\n    else return b;\n}\n\nvoid *os_realloc(void *p, size_t size) {\n    size_t alignment;\n    if (size<4) {\n        alignment = 1;\n    } else if (size<8) {\n        alignment = 4;\n    } else if (size<16) {\n        alignment = 8;\n    } else {\n        alignment = 16;\n    }\n    return os_realloc_aligned(alignment, p, size);\n}\n\nvoid * os_realloc_aligned(size_t alignment, void *p, size_t size)\n// Effect: Perform a realloc(p, size) with the additional property that the returned pointer is a multiple of ALIGNMENT.\n// Requires: alignment is a power of two.\n{\n    if (p==NULL) {\n        return os_malloc_aligned(alignment, size);\n    } else {\n        void *result = os_malloc_aligned(alignment, size);\n        malloc_lock();\n        struct malloc_pair *mp = find_malloced_pair(p);\n        assert(mp);\n        // now copy all the good stuff from p to result\n        memcpy(result, p, min(size, mp->requested_size));\n        malloc_unlock();\n        os_free(p);\n        return result;\n    }\n}\n\n\nvoid os_free(void* p) {\n    malloc_lock();\n    struct malloc_pair *mp = find_malloced_pair(p);\n    assert(mp);\n    free(mp->true_pointer);\n    *mp = malloced_now[--malloced_now_count];\n    malloc_unlock();\n}\n\nsize_t os_malloc_usable_size(const void *p) {\n    malloc_lock();\n    struct malloc_pair *mp = find_malloced_pair(p);\n    assert(mp);\n    size_t size = mp->requested_size;\n    malloc_unlock();\n    return size;\n}\n\n#else\n\nvoid *\nos_malloc(size_t size)\n{\n    return malloc(size);\n}\n\nvoid *os_malloc_aligned(size_t alignment, size_t size)\n// Effect: Perform a malloc(size) with the additional property that the returned pointer is a multiple of ALIGNMENT.\n// Requires: alignment is a power of two.\n{\n    void *p;\n    int r = posix_memalign(&p, alignment, size);\n    if (r != 0) {\n        errno = r;\n        p = nullptr;\n    }\n    return p;\n}\n\nvoid *\nos_realloc(void *p, size_t size)\n{\n    return realloc(p, size);\n}\n\nvoid * os_realloc_aligned(size_t alignment, void *p, size_t size)\n// Effect: Perform a realloc(p, size) with the additional property that the returned pointer is a multiple of ALIGNMENT.\n// Requires: alignment is a power of two.\n{\n#if 1\n    if (p==NULL) {\n        return os_malloc_aligned(alignment, size);\n    } else {\n        void *newp = realloc(p, size);\n        if (0!=((long long)newp%alignment)) {\n            // it's not aligned, so align it ourselves.\n            void *newp2 = os_malloc_aligned(alignment, size);\n            memcpy(newp2, newp, size);\n            free(newp);\n            newp = newp2;\n        }\n        return newp;\n    }\n#else\n    // THIS STUFF SEEMS TO FAIL VALGRIND\n    if (p==NULL) {\n        return os_malloc_aligned(alignment, size);\n    } else {\n        size_t ignore;\n        int r = rallocm(&p,        // returned pointer\n                        &ignore,   // actual size of returned object.\n                        size,      // the size we want\n                        0,         // extra bytes to \"try\" to allocate at the end\n                        ALLOCM_ALIGN(alignment));\n        if (r!=0) return NULL;\n        else return p;\n    }\n#endif\n}\n\n\nvoid\nos_free(void* p)\n{\n    free(p);\n}\n\ntypedef size_t (*malloc_usable_size_fun_t)(const void *);\nstatic malloc_usable_size_fun_t malloc_usable_size_f = NULL;\n\nsize_t os_malloc_usable_size(const void *p) {\n    if (p==NULL) return 0;\n    if (!malloc_usable_size_f) {\n        malloc_usable_size_f = (malloc_usable_size_fun_t) dlsym(RTLD_DEFAULT, \"malloc_usable_size\");\n        if (!malloc_usable_size_f) {\n            malloc_usable_size_f = (malloc_usable_size_fun_t) dlsym(RTLD_DEFAULT, \"malloc_size\"); // darwin\n            if (!malloc_usable_size_f) {\n                abort(); // couldn't find a malloc size function\n            }\n        }\n    }\n    return malloc_usable_size_f(p);\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/src/tests/loader-stress-del.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n// Need to use malloc for the malloc instrumentation tests\n#ifndef TOKU_ALLOW_DEPRECATED\n#define TOKU_ALLOW_DEPRECATED\n#endif\n\n#include \"test.h\"\n#include \"toku_pthread.h\"\n#include <db.h>\n#include <sys/stat.h>\n#include \"ydb-internal.h\"\n#include <memory.h>\n#include <dlfcn.h>\n\nDB_ENV *env;\nenum {MAX_NAME=128};\nenum {MAX_DBS=1024};\nint NUM_DBS=1;\nint NUM_ROWS=1000000;\nint CHECK_RESULTS=1;\nint DISALLOW_PUTS=0;\nint COMPRESS=0;\nenum { old_default_cachesize=1024 }; // MB\nint CACHESIZE=old_default_cachesize;\nint ALLOW_DUPS=0;\nenum {MAGIC=311};\nchar *datadir = NULL;\nbool check_est = true; // do check the estimates by default\nbool footprint_print = false; // print memory footprint info \nbool upgrade_test = false;   \n\n// Code for showing memory footprint information.\npthread_mutex_t my_lock = PTHREAD_MUTEX_INITIALIZER;\nsize_t hiwater;\nsize_t water;\nsize_t hiwater_start;\nstatic long long mcount = 0, fcount=0;\n\n\nstatic void my_free(void*p) {\n    if (p) {\n        water-=toku_malloc_usable_size(p);\n    }\n    free(p);\n}\n\nstatic void *my_malloc(size_t size) {\n    void *r = malloc(size);\n    if (r) {\n        water += toku_malloc_usable_size(r);\n        if (water>hiwater) hiwater=water;\n    }\n    return r;\n}\n\nstatic void *my_realloc(void *p, size_t size) {\n    size_t old_usable = p ? toku_malloc_usable_size(p) : 0;\n    void *r = realloc(p, size);\n    if (r) {\n        water -= old_usable;\n        water += toku_malloc_usable_size(r);\n    }\n    return r;\n}\n\n//\n//   Functions to create unique key/value pairs, row generators, checkers, ... for each of NUM_DBS\n//\n\n//   a is the bit-wise permute table.  For DB[i], permute bits as described in a[i] using 'twiddle32'\n// inv is the inverse bit-wise permute of a[].  To get the original value from a twiddled value, twiddle32 (again) with inv[]\nint   a[MAX_DBS][32];\nint inv[MAX_DBS][32];\n\n\nstatic const char *loader_temp_prefix = \"tokuld\"; // #2536\n\n// return number of temp files\nstatic int\ncount_temp(char * dirname) {\n    int n = 0;\n    \n    DIR * dir = opendir(dirname);\n    \n    struct dirent *ent;\n    while ((ent=readdir(dir))) {\n\tif ((ent->d_type==DT_REG || ent->d_type==DT_UNKNOWN) && strncmp(ent->d_name, loader_temp_prefix, 6)==0) {\n\t    n++;\n\t    if (verbose) {\n\t\tprintf(\"Temp files (%d)\\n\", n);\n\t\tprintf(\"  %s/%s\\n\", dirname, ent->d_name);\n\t    } \n\t}\n    }\n    closedir(dir);\n    return n;\n}\n\n// rotate right and left functions\nstatic inline unsigned int rotr32(const unsigned int x, const unsigned int num) {\n    if (num == 0) {\n        return x;\n    } else {\n        const unsigned int n = num % 32;\n        return (x >> n) | ( x << (32 - n));\n    }\n}\nstatic inline unsigned int rotl32(const unsigned int x, const unsigned int num) {\n    if (num == 0) {\n        return x;\n    } else {\n        const unsigned int n = num % 32;\n        return (x << n) | ( x >> (32 - n));\n    }\n}\n\nstatic void generate_permute_tables(void) {\n    int i, j, tmp;\n    for(int db=0;db<MAX_DBS;db++) {\n        for(i=0;i<32;i++) {\n            a[db][i] = i;\n        }\n        for(i=0;i<32;i++) {\n            j = random() % (i + 1);\n            tmp = a[db][j];\n            a[db][j] = a[db][i];\n            a[db][i] = tmp;\n        }\n//        if(db < NUM_DBS){ printf(\"a[%d] = \", db); for(i=0;i<32;i++) { printf(\"%2d \", a[db][i]); } printf(\"\\n\");}\n        for(i=0;i<32;i++) {\n            inv[db][a[db][i]] = i;\n        }\n    }\n}\n\n// permute bits of x based on permute table bitmap\nstatic unsigned int twiddle32(unsigned int x, int db)\n{\n    unsigned int b = 0;\n    for(int i=0;i<32;i++) {\n        b |= (( x >> i ) & 1) << a[db][i];\n    }\n    return b;\n}\n\n// permute bits of x based on inverse permute table bitmap\nstatic unsigned int inv_twiddle32(unsigned int x, int db)\n{\n    unsigned int b = 0;\n    for(int i=0;i<32;i++) {\n        b |= (( x >> i ) & 1) << inv[db][i];\n    }\n    return b;\n}\n\n// generate val from key, index\nstatic unsigned int generate_val(int key, int i) {\n    return rotl32((key + MAGIC), i);\n}\nstatic unsigned int pkey_for_val(int key, int i) {\n    return rotr32(key, i) - MAGIC;\n}\n\n// There is no handlerton in this test, so this function is a local replacement\n// for the handlerton's generate_row_for_put().\nstatic int put_multiple_generate(DB *dest_db, DB *src_db, DBT_ARRAY *dest_keys, DBT_ARRAY *dest_vals, const DBT *src_key, const DBT *src_val) {\n    toku_dbt_array_resize(dest_keys, 1);\n    toku_dbt_array_resize(dest_vals, 1);\n    DBT *dest_key = &dest_keys->dbts[0];\n    DBT *dest_val = &dest_vals->dbts[0];\n\n    (void) src_db;\n\n    uint32_t which = *(uint32_t*)dest_db->app_private;\n\n    if ( which == 0 ) {\n        if (dest_key->flags==DB_DBT_REALLOC) {\n            if (dest_key->data) toku_free(dest_key->data);\n            dest_key->flags = 0;\n            dest_key->ulen  = 0;\n        }\n        if (dest_val->flags==DB_DBT_REALLOC) {\n            if (dest_val->data) toku_free(dest_val->data);\n            dest_val->flags = 0;\n            dest_val->ulen  = 0;\n        }\n        dbt_init(dest_key, src_key->data, src_key->size);\n        dbt_init(dest_val, src_val->data, src_val->size);\n    }\n    else {\n        assert(dest_key->flags==DB_DBT_REALLOC);\n        if (dest_key->ulen < sizeof(unsigned int)) {\n            dest_key->data = toku_xrealloc(dest_key->data, sizeof(unsigned int));\n            dest_key->ulen = sizeof(unsigned int);\n        }\n        assert(dest_val->flags==DB_DBT_REALLOC);\n        if (dest_val->ulen < sizeof(unsigned int)) {\n            dest_val->data = toku_xrealloc(dest_val->data, sizeof(unsigned int));\n            dest_val->ulen = sizeof(unsigned int);\n        }\n        unsigned int *new_key = (unsigned int *)dest_key->data;\n        unsigned int *new_val = (unsigned int *)dest_val->data;\n\n        *new_key = twiddle32(*(unsigned int*)src_key->data, which);\n        *new_val = generate_val(*(unsigned int*)src_key->data, which);\n\n        dest_key->size = sizeof(unsigned int);\n        dest_val->size = sizeof(unsigned int);\n        //data is already set above\n    }\n\n//    printf(\"dest_key.data = %d\\n\", *(int*)dest_key->data);\n//    printf(\"dest_val.data = %d\\n\", *(int*)dest_val->data);\n\n    return 0;\n}\n\n\nstatic int uint_cmp(const void *ap, const void *bp) {\n    unsigned int an = *(unsigned int *)ap;\n    unsigned int bn = *(unsigned int *)bp;\n    if (an < bn) \n        return -1;\n    if (an > bn)\n        return +1;\n    return 0;\n}\n\nstatic void check_results(DB **dbs) {\n    for(int j=0;j<NUM_DBS;j++) {\n        unsigned int prev_k = 0;\n\n        DBT key, val;\n        unsigned int k=0, v=0;\n        dbt_init(&key, &k, sizeof(unsigned int));\n        dbt_init(&val, &v, sizeof(unsigned int));\n\n        int r;\n\n        DB_TXN *txn;\n        r = env->txn_begin(env, NULL, &txn, 0);\n        CKERR(r);\n\n        DBC *cursor;\n        r = dbs[j]->cursor(dbs[j], txn, &cursor, 0);\n        CKERR(r);\n\n        // generate the expected keys\n        unsigned int *expected_key = (unsigned int *) toku_malloc(NUM_ROWS * sizeof (unsigned int));\n        for (int i = 0; i < NUM_ROWS; i++) {\n            expected_key[i] = j == 0 ? (unsigned int)(i+1) : twiddle32(i+1, j);\n        }\n        // sort the keys\n        qsort(expected_key, NUM_ROWS, sizeof (unsigned int), uint_cmp);\n\n        for (int i = 0; i < NUM_ROWS+1; i++) {\n            r = cursor->c_get(cursor, &key, &val, DB_NEXT);\n            if (DISALLOW_PUTS) {\n                CKERR2(r, DB_NOTFOUND);\n                break;\n            }\n            if (r == DB_NOTFOUND) {\n                assert(i == NUM_ROWS); // check that there are exactly NUM_ROWS in the dictionary\n                break;\n            }\n            CKERR(r);\n\n            k = *(unsigned int*)key.data;\n\n            unsigned int pkey_for_db_key = (j == 0) ? k : inv_twiddle32(k, j);\n            v = *(unsigned int*)val.data;\n            // test that we have the expected keys and values\n            assert((unsigned int)pkey_for_db_key == (unsigned int)pkey_for_val(v, j));\n//            printf(\" DB[%d] key = %10u, val = %10u, pkey_for_db_key = %10u, pkey_for_val=%10d\\n\", j, v, k, pkey_for_db_key, pkey_for_val(v, j));\n\n            // check the expected keys\n            assert(k == expected_key[i]);\n\n            // check prev_key < key\n            if (i > 0) \n                assert(prev_k < k);\n\n            // update prev = current\n            prev_k = k;\n        }\n\n        toku_free(expected_key);\n\n        if ( verbose ) {printf(\".\"); fflush(stdout);}\n        r = cursor->c_close(cursor);\n        CKERR(r);\n\n        r = txn->commit(txn, 0);\n        CKERR(r);\n    }\n    if ( verbose ) printf(\"\\nCheck OK\\n\");\n}\n\nstatic void delete_all(DB **dbs) {\n    for(int j=0;j<NUM_DBS;j++) {\n\n        int r;\n\n        DB_TXN *txn;\n        r = env->txn_begin(env, NULL, &txn, 0);\n        CKERR(r);\n\n        // generate the expected keys\n        unsigned int *expected_key = (unsigned int *) toku_malloc(NUM_ROWS * sizeof (unsigned int));\n        for (int i = 0; i < NUM_ROWS; i++)\n            expected_key[i] = j == 0 ? (unsigned int)(i+1) : twiddle32(i+1, j);\n        // sort the keys\n        qsort(expected_key, NUM_ROWS, sizeof (unsigned int), uint_cmp);\n\n        // delete all of the keys\n        for (int i = 0; i < NUM_ROWS; i++) {\n            DBT key;\n            dbt_init(&key, &expected_key[i], sizeof expected_key[i]);\n            r = dbs[j]->del(dbs[j], txn, &key, DB_DELETE_ANY);\n            assert(r == 0);\n        }\n\n        // verify empty\n        DBC *cursor;\n        r = dbs[j]->cursor(dbs[j], txn, &cursor, 0);\n        CKERR(r);\n\n        DBT key, val;\n        unsigned int k=0, v=0;\n        dbt_init(&key, &k, sizeof(unsigned int));\n        dbt_init(&val, &v, sizeof(unsigned int));\n\n        r = cursor->c_get(cursor, &key, &val, DB_NEXT);\n        assert(r == DB_NOTFOUND);\n\n        toku_free(expected_key);\n\n        if ( verbose ) {printf(\".\"); fflush(stdout);}\n        r = cursor->c_close(cursor);\n        CKERR(r);\n\n        r = txn->commit(txn, 0);\n        CKERR(r);\n    }\n    if ( verbose ) printf(\"\\nCheck OK\\n\");\n}\n\nstatic void *expect_poll_void = &expect_poll_void;\nstatic uint64_t poll_count=0;\nstatic uint64_t bomb_after_poll_count=UINT64_MAX;\n\nstatic struct progress_info {\n    double time;\n    double progress;\n} *progress_infos=NULL;\nstatic int progress_infos_count=0;\nstatic int progress_infos_limit=0;\n\n// timing\nstatic bool did_start=false;\nstatic struct timeval start;\n\nstatic int poll_function (void *extra, float progress) {\n    if (verbose>=2) {\n\tassert(did_start);\n\tstruct timeval now;\n\tgettimeofday(&now, 0);\n\tdouble elapsed = now.tv_sec - start.tv_sec + 1e-6*(now.tv_usec - start.tv_usec);\n\tprintf(\"Progress: %6.6fs %5.1f%%\\n\", elapsed, progress*100);\n\tif (progress_infos_count>=progress_infos_limit) {\n\t    progress_infos_limit = 2*progress_infos_limit + 1;\n\t    XREALLOC_N(progress_infos_limit, progress_infos);\n\t}\n\tprogress_infos[progress_infos_count++] = (struct progress_info){elapsed, progress};\t    \n    }\n    assert(extra==expect_poll_void);\n    assert(0.0<=progress && progress<=1.0);\n    poll_count++; // Calls to poll_function() are protected by a lock, so we don't have to do this atomically.\n    if (poll_count>bomb_after_poll_count)\n\treturn TOKUDB_CANCELED;\n    else\n\treturn 0;\n}\n\nstatic struct timeval starttime;\nstatic double elapsed_time (void) {\n    struct timeval now;\n    gettimeofday(&now, NULL);\n    return now.tv_sec - starttime.tv_sec + 1e-6*(now.tv_usec - starttime.tv_usec);\n}\n\nstatic void test_loader(DB **dbs)\n{\n    gettimeofday(&starttime, NULL);\n    int r;\n    DB_TXN    *txn;\n    DB_LOADER *loader;\n    uint32_t db_flags[MAX_DBS];\n    uint32_t dbt_flags[MAX_DBS];\n    uint32_t flags = DB_NOOVERWRITE;\n    if ( (DISALLOW_PUTS != 0) && (ALLOW_DUPS == 1) ) flags = 0;\n    for(int i=0;i<MAX_DBS;i++) { \n        db_flags[i] = flags;\n        dbt_flags[i] = 0;\n    }\n    \n    uint32_t loader_flags = DISALLOW_PUTS | COMPRESS; // set with -p option\n\n    // create and initialize loader\n    r = env->txn_begin(env, NULL, &txn, 0);\n    CKERR(r);\n    hiwater_start = hiwater;\n    if (footprint_print)  printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = env->create_loader(env, txn, &loader, dbs[0], NUM_DBS, dbs, db_flags, dbt_flags, loader_flags);\n    CKERR(r);\n    if (footprint_print)  printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = loader->set_error_callback(loader, NULL, NULL);\n    CKERR(r);\n    r = loader->set_poll_function(loader, poll_function, expect_poll_void);\n    CKERR(r);\n\n    // using loader->put, put values into DB\n    DBT key, val;\n    unsigned int k, v;\n    for(int i=1;i<=NUM_ROWS;i++) {\n        k = i;\n        v = generate_val(i, 0);\n        dbt_init(&key, &k, sizeof(unsigned int));\n        dbt_init(&val, &v, sizeof(unsigned int));\n        r = loader->put(loader, &key, &val);\n        if (DISALLOW_PUTS) {\n            CKERR2(r, EINVAL);\n        } else {\n            CKERR(r);\n        }\n        if ( verbose) { if((i%10000) == 0){printf(\".\"); fflush(stdout);} }\n    }\n    if ( verbose ) {printf(\"\\n\"); fflush(stdout);}        \n        \n    poll_count=0;\n\n    int n = count_temp(env->i->real_data_dir);\n    if (verbose) printf(\"Num temp files = %d\\n\", n);\n\n    did_start = true;\n    gettimeofday(&start, 0);\n\n    // close the loader\n    if ( verbose ) printf(\"%9.6fs closing\\n\", elapsed_time());\n    if (footprint_print) printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = loader->close(loader);\n    if (footprint_print) printf(\"%s:%d Hiwater=%ld water=%ld (extra hiwater=%ldM)\\n\", __FILE__, __LINE__, hiwater, water, (hiwater-hiwater_start)/(1024*1024));\n    if ( verbose ) printf(\"%9.6fs done\\n\",    elapsed_time());\n    CKERR2s(r,0,TOKUDB_CANCELED);\n\n    if (r==0) {\n\tif ( DISALLOW_PUTS == 0 ) {\n\t    if (poll_count == 0) printf(\"%s:%d\\n\", __FILE__, __LINE__);\n\t    assert(poll_count>0);\n\t}\n\n\tr = txn->commit(txn, 0);\n\tCKERR(r);\n\n\t// verify the DBs\n\tif ( CHECK_RESULTS ) {\n\t    check_results(dbs);\n            delete_all(dbs);\n\t}\n\n    } else {\n\tr = txn->abort(txn);\n\tCKERR(r);\n    }\n}\n\nstatic const char *envdir = TOKU_TEST_FILENAME;\nconst char *tmp_subdir = \"tmp.subdir\";\n\n#define OLDDATADIR \"../../../../tokudb.data/\"\nconst char *db_v4_dir        = OLDDATADIR \"env_preload.4.1.1.emptydictionaries.cleanshutdown\";\n\nstatic void setup(void) {\n    int r;\n    int len = 256;\n    char syscmd[len];\n    const char * src_db_dir;\n\n    src_db_dir = db_v4_dir;\n\n    r = snprintf(syscmd, len, \"cp -r %s %s\", src_db_dir, envdir);\n    assert(r<len);\n    r = system(syscmd);                                                                                 \n    CKERR(r);\n}\n\nstatic void run_test(void) \n{\n    int r;\n    \n    int cmdlen = strlen(envdir) + strlen(tmp_subdir) + 10;\n    char tmpdir[cmdlen];\n    r = snprintf(tmpdir, cmdlen, \"%s/%s\", envdir, tmp_subdir);\n    assert(r<cmdlen);\n    \n    // first delete anything left from previous run of this test\n    {\n\tint len = strlen(envdir) + 20;\n\tchar syscmd[len];\n\tr = snprintf(syscmd, len, \"rm -rf %s\", envdir);\n\tassert(r<len);\n\tr = system(syscmd);                                                                                   CKERR(r);\n    }\n    if (upgrade_test) {\n\tsetup();\n    }\n    else {\n\tr = toku_os_mkdir(envdir, S_IRWXU+S_IRWXG+S_IRWXO);                                                      CKERR(r);\n\tr = toku_os_mkdir(tmpdir, S_IRWXU+S_IRWXG+S_IRWXO);                                                   CKERR(r);\n    }\n\n    r = db_env_create(&env, 0);                                                                           CKERR(r);\n    r = env->set_tmp_dir(env, tmp_subdir);                                                                CKERR(r);\n    \n    r = env->set_default_bt_compare(env, uint_dbt_cmp);                                                       CKERR(r);\n    if ( verbose ) printf(\"CACHESIZE = %d MB\\n\", CACHESIZE);\n    r = env->set_cachesize(env, CACHESIZE / 1024, (CACHESIZE % 1024)*1024*1024, 1);                           CKERR(r);\n    if (datadir) {\n        r = env->set_data_dir(env, datadir);                                                                  CKERR(r);\n    }\n    r = env->set_generate_row_callback_for_put(env, put_multiple_generate);\n    CKERR(r);\n    int envflags = DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_CREATE | DB_PRIVATE;\n    r = env->open(env, envdir, envflags, S_IRWXU+S_IRWXG+S_IRWXO);                                            CKERR(r);\n    env->set_errfile(env, stderr);\n    r = env->checkpointing_set_period(env, 60);                                                                CKERR(r);\n\n    DBT desc;\n    dbt_init(&desc, \"foo\", sizeof(\"foo\"));\n    char name[MAX_NAME*2];\n\n    DB **dbs = (DB**)toku_malloc(sizeof(DB*) * NUM_DBS);\n    assert(dbs != NULL);\n    int idx[MAX_DBS];\n    for(int i=0;i<NUM_DBS;i++) {\n        idx[i] = i;\n        r = db_create(&dbs[i], env, 0);                                                                       CKERR(r);\n        dbs[i]->app_private = &idx[i];\n        snprintf(name, sizeof(name), \"db_%04x\", i);\n        r = dbs[i]->open(dbs[i], NULL, name, NULL, DB_BTREE, DB_CREATE, 0666);                                CKERR(r);\n        IN_TXN_COMMIT(env, NULL, txn_desc, 0, {\n                { int chk_r = dbs[i]->change_descriptor(dbs[i], txn_desc, &desc, 0); CKERR(chk_r); }\n        });\n    }\n\n    generate_permute_tables();\n\n    // -------------------------- //\n    test_loader(dbs);\n    // -------------------------- //\n\n    for(int i=0;i<NUM_DBS;i++) {\n        dbs[i]->close(dbs[i], 0);                                                                             CKERR(r);\n        dbs[i] = NULL;\n    }\n    if (verbose >= 2)\n\tprint_engine_status(env);\n    r = env->close(env, 0);                                                                                   CKERR(r);\n    toku_free(dbs);\n}\n\n\n// ------------ infrastructure ----------\nstatic void do_args(int argc, char * const argv[]);\n\nint test_main(int argc, char * const *argv) {\n    do_args(argc, argv);\n\n    run_test();\n\n    if (progress_infos) {\n\tif (verbose>=2) {\n\t    double ratio=progress_infos[progress_infos_count-1].time/progress_infos[progress_infos_count-1].progress;\n\t    printf(\"Progress ratios:\\n\");\n\t    for (int i=0; i<progress_infos_count; i++) {\n\t\tprintf(\" %5.3f\\n\", (progress_infos[i].time/progress_infos[i].progress)/ratio);\n\t    }\n\t}\n\ttoku_free(progress_infos);\n    }\n    if (footprint_print) {\n        printf(\"%s:%d Hiwater=%ld water=%ld (extra hiwater=%ldM) mcount=%lld fcount=%lld\\n\", __FILE__, __LINE__, hiwater, water, (hiwater-hiwater_start)/(1024*1024), mcount, fcount);\n        typedef void (*malloc_stats_fun_t)(void);\n        malloc_stats_fun_t malloc_stats_f = (malloc_stats_fun_t) dlsym(RTLD_DEFAULT, \"malloc_stats\");\n        if (malloc_stats_f) {\n            malloc_stats_f();\n        }\n    }\n    return 0;\n}\n\nstatic void do_args(int argc, char * const argv[]) {\n\n    // Must look for \"-f\" right away before we malloc anything.\n    for (int i=1; i<argc; i++)  {\n\n\tif (strcmp(argv[i], \"-f\")) {\n\t    db_env_set_func_malloc(my_malloc);\n\t    db_env_set_func_realloc(my_realloc);\n\t    db_env_set_func_free(my_free);\n\t}\n    }\n\n    int resultcode;\n    char *cmd = argv[0];\n    argc--; argv++;\n    \n    CACHESIZE = (toku_os_get_phys_memory_size() / (1024*1024))/2; //MB\n\n    while (argc>0) {\n\tif (strcmp(argv[0], \"-v\")==0) {\n\t    verbose++;\n\t} else if (strcmp(argv[0],\"-q\")==0) {\n\t    verbose--;\n\t    if (verbose<0) verbose=0;\n        } else if (strcmp(argv[0], \"-h\")==0) {\n\t    resultcode=0;\n\tdo_usage:\n\t    fprintf(stderr, \"Usage: -h -c -d <num_dbs> -r <num_rows> [ -b <num_calls> ] [-m <megabytes>] [-M]\\n%s\\n\", cmd);\n\t    fprintf(stderr, \"  where -d <num_dbs>     is the number of dictionaries to build (primary & secondary).  (Default=%d)\\n\", NUM_DBS);\n\t    fprintf(stderr, \"        -b <num_calls>   causes the poll function to return nonzero after <num_calls>\\n\");\n\t    fprintf(stderr, \"        -e <env>         uses <env> to construct the directory (so that different tests can run concurrently)\\n\");\n\t    fprintf(stderr, \"        -m <m>           use m MB of memory for the cachetable (default is %d MB)\\n\", CACHESIZE);\n            fprintf(stderr, \"        -M               use %d MB of memory for the cachetable\\n\", old_default_cachesize);\n\t    fprintf(stderr, \"        -s               use size factor of 1 and count temporary files\\n\");\n\t    fprintf(stderr,  \"        -f               print memory footprint information at various points in the load\\n\");\n\t    exit(resultcode);\n        } else if (strcmp(argv[0], \"-d\")==0) {\n            argc--; argv++;\n            NUM_DBS = atoi(argv[0]);\n            if ( NUM_DBS > MAX_DBS ) {\n                fprintf(stderr, \"max value for -d field is %d\\n\", MAX_DBS);\n                resultcode=1;\n                goto do_usage;\n            }\n\t} else if (strcmp(argv[0], \"-e\")==0) {\n            argc--; argv++;\n            envdir = argv[0];\n        } else if (strcmp(argv[0], \"-v\")==0) {\n\t    verbose++;\n\t} else if (strcmp(argv[0],\"-q\")==0) {\n\t    verbose--;\n\t    if (verbose<0) verbose=0;\n\t} else if (strcmp(argv[0], \"-f\")==0) {\n\t    footprint_print = true;\n        } else if (strcmp(argv[0], \"-r\")==0) {\n            argc--; argv++;\n            NUM_ROWS = atoi(argv[0]);\n        } else if (strcmp(argv[0], \"-c\")==0) {\n            CHECK_RESULTS = 1;\n        } else if (strcmp(argv[0], \"-p\")==0) {\n            DISALLOW_PUTS = LOADER_DISALLOW_PUTS;\n        } else if (strcmp(argv[0], \"-z\")==0) {\n            COMPRESS = LOADER_COMPRESS_INTERMEDIATES;\n        } else if (strcmp(argv[0], \"-m\")==0) {\n            argc--; argv++;\n            CACHESIZE = atoi(argv[0]);\n        } else if (strcmp(argv[0], \"-M\")==0) {\n\t    CACHESIZE = old_default_cachesize;\n        } else if (strcmp(argv[0], \"-y\")==0) {\n            ALLOW_DUPS = 1;\n        } else if (strcmp(argv[0], \"-s\")==0) {\n\t    //printf(\"\\nTesting loader with size_factor=1\\n\");\n\t    db_env_set_loader_size_factor(1);            \n\t} else if (strcmp(argv[0], \"-b\")==0) {\n\t    argc--; argv++;\n\t    char *end;\n\t    errno=0;\n\t    bomb_after_poll_count = strtoll(argv[0], &end, 10);\n\t    assert(errno==0);\n\t    assert(*end==0); // make sure we consumed the whole integer.\n        } else if (strcmp(argv[0], \"--datadir\") == 0 && argc > 1) {\n            argc--; argv++;\n            datadir = argv[0];\n\t} else if (strcmp(argv[0], \"--dont_check_est\") == 0) {\n\t    check_est = false;\n        } else if (strcmp(argv[0], \"-u\")==0) {\n            upgrade_test = true;\n\t} else {\n\t    fprintf(stderr, \"Unknown arg: %s\\n\", argv[0]);\n\t    resultcode=1;\n\t    goto do_usage;\n\t}\n\targc--;\n\targv++;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/src/tests/loader-stress-test.cc": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n/**************\n *\n * NOTE: This test is used for upgrade testing as well as for exercising the loader.\n *       Changes should not be made gratuitously.\n *       The 4.2.0 version of this test was used to create many of the preloaded\n *       environments in the <svn-top>/tokudb/tokudb.data directory.\n */\n\n\n// Need to use malloc for the malloc instrumentation tests\n#ifndef TOKU_ALLOW_DEPRECATED\n#define TOKU_ALLOW_DEPRECATED\n#endif\n\n#include \"test.h\"\n#include \"toku_pthread.h\"\n#include <db.h>\n#include <sys/stat.h>\n#include \"ydb-internal.h\"\n#include <memory.h>\n#include <dlfcn.h>\n\nDB_ENV *env;\nenum {MAX_NAME=128};\nenum {MAX_DBS=1024};\nint NUM_DBS=5;\nint NUM_ROWS=100000;\nint VALSIZE=sizeof(unsigned int);\nint CHECK_RESULTS=0;\nint DISALLOW_PUTS=0;\nint COMPRESS=0;\nenum { old_default_cachesize=1024 }; // MB\nint CACHESIZE=old_default_cachesize;\nint ALLOW_DUPS=0;\nenum {MAGIC=311};\nchar *datadir = NULL;\nbool check_est = true; // do check the estimates by default\nbool footprint_print = false; // print memory footprint info \nbool upgrade_test = false;   \n\n// Code for showing memory footprint information.\npthread_mutex_t my_lock = PTHREAD_MUTEX_INITIALIZER;\nsize_t hiwater;\nsize_t water;\nsize_t hiwater_start;\nstatic long long mcount = 0, fcount=0;\n\nstatic void my_free(void*p) {\n    if (p) {\n        water-=toku_malloc_usable_size(p);\n    }\n    free(p);\n}\n\nstatic void *my_malloc(size_t size) {\n    void *r = malloc(size);\n    if (r) {\n        water += toku_malloc_usable_size(r);\n        if (water>hiwater) hiwater=water;\n    }\n    return r;\n}\n\nstatic void *my_realloc(void *p, size_t size) {\n    size_t old_usable = p ? toku_malloc_usable_size(p) : 0;\n    void *r = realloc(p, size);\n    if (r) {\n        water -= old_usable;\n        water += toku_malloc_usable_size(r);\n    }\n    return r;\n}\n\n//\n//   Functions to create unique key/value pairs, row generators, checkers, ... for each of NUM_DBS\n//\n\n//   a is the bit-wise permute table.  For DB[i], permute bits as described in a[i] using 'twiddle32'\n// inv is the inverse bit-wise permute of a[].  To get the original value from a twiddled value, twiddle32 (again) with inv[]\nint   a[MAX_DBS][32];\nint inv[MAX_DBS][32];\n\nstatic const char *loader_temp_prefix = \"tokuld\"; // #2536\n\n// return number of temp files\nstatic int\ncount_temp(char * dirname) {\n    int n = 0;\n    \n    DIR * dir = opendir(dirname);\n    \n    struct dirent *ent;\n    while ((ent=readdir(dir))) {\n\tif ((ent->d_type==DT_REG || ent->d_type==DT_UNKNOWN) && strncmp(ent->d_name, loader_temp_prefix, 6)==0) {\n\t    n++;\n\t    if (verbose) {\n\t\tprintf(\"Temp files (%d)\\n\", n);\n\t\tprintf(\"  %s/%s\\n\", dirname, ent->d_name);\n\t    } \n\t}\n    }\n    closedir(dir);\n    return n;\n}\n\n// rotate right and left functions\nstatic inline unsigned int rotr32(const unsigned int x, const unsigned int num) {\n    if (num == 0) {\n        return x;\n    } else {\n        const unsigned int n = num % 32;\n        return (x >> n) | ( x << (32 - n));\n    }\n}\nstatic inline unsigned int rotl32(const unsigned int x, const unsigned int num) {\n    if (num == 0) {\n        return x;\n    } else {\n        const unsigned int n = num % 32;\n        return (x << n) | ( x >> (32 - n));\n    }\n}\n\nstatic void generate_permute_tables(void) {\n    int i, j, tmp;\n    for(int db=0;db<MAX_DBS;db++) {\n        for(i=0;i<32;i++) {\n            a[db][i] = i;\n        }\n        for(i=0;i<32;i++) {\n            j = random() % (i + 1);\n            tmp = a[db][j];\n            a[db][j] = a[db][i];\n            a[db][i] = tmp;\n        }\n//        if(db < NUM_DBS){ printf(\"a[%d] = \", db); for(i=0;i<32;i++) { printf(\"%2d \", a[db][i]); } printf(\"\\n\");}\n        for(i=0;i<32;i++) {\n            inv[db][a[db][i]] = i;\n        }\n    }\n}\n\n// permute bits of x based on permute table bitmap\nstatic unsigned int twiddle32(unsigned int x, int db)\n{\n    unsigned int b = 0;\n    for(int i=0;i<32;i++) {\n        b |= (( x >> i ) & 1) << a[db][i];\n    }\n    return b;\n}\n\n// permute bits of x based on inverse permute table bitmap\nstatic unsigned int inv_twiddle32(unsigned int x, int db)\n{\n    unsigned int b = 0;\n    for(int i=0;i<32;i++) {\n        b |= (( x >> i ) & 1) << inv[db][i];\n    }\n    return b;\n}\n\n// generate val from key, index\nstatic void generate_val(int key, int i, unsigned int*v) {\n    v[0] = rotl32((key + MAGIC), i);\n    for (unsigned w = 1; w < VALSIZE/sizeof(unsigned int); w++) {\n        v[w] = rotr32(v[w-1], 1);\n    }\n}\n\nstatic unsigned int pkey_for_val(int key, int i) {\n    return rotr32(key, i) - MAGIC;\n}\n\n// There is no handlerton in this test, so this function is a local replacement\n// for the handlerton's generate_row_for_put().\nstatic int put_multiple_generate(DB *dest_db, DB *src_db, DBT_ARRAY *dest_keys, DBT_ARRAY *dest_vals, const DBT *src_key, const DBT *UU(src_val)) {\n    toku_dbt_array_resize(dest_keys, 1);\n    toku_dbt_array_resize(dest_vals, 1);\n    DBT *dest_key = &dest_keys->dbts[0];\n    DBT *dest_val = &dest_vals->dbts[0];\n\n    assert(src_db);\n    assert(dest_db != src_db);\n\n    uint32_t which = *(uint32_t*)dest_db->app_private;\n    assert(which != 0);\n\n    {\n        assert(dest_key->flags==DB_DBT_REALLOC);\n        if (dest_key->ulen < sizeof(unsigned int)) {\n            dest_key->data = toku_xrealloc(dest_key->data, sizeof(unsigned int));\n            dest_key->ulen = sizeof(unsigned int);\n        }\n        assert(dest_val->flags==DB_DBT_REALLOC);\n        if (dest_val->ulen < (unsigned)VALSIZE) {\n            dest_val->data = toku_xrealloc(dest_val->data, VALSIZE);\n            dest_val->ulen = VALSIZE;\n        }\n        unsigned int *new_key = (unsigned int *)dest_key->data;\n\n        *new_key = twiddle32(*(unsigned int*)src_key->data, which);\n        generate_val(*(unsigned int*)src_key->data, which, (unsigned int*)dest_val->data);\n\n        dest_key->size = sizeof(unsigned int);\n        dest_val->size = VALSIZE;\n        //data is already set above\n    }\n\n//    printf(\"dest_key.data = %d\\n\", *(int*)dest_key->data);\n//    printf(\"dest_val.data = %d\\n\", *(int*)dest_val->data);\n\n    return 0;\n}\n\nstatic int uint_cmp(const void *ap, const void *bp) {\n    unsigned int an = *(unsigned int *)ap;\n    unsigned int bn = *(unsigned int *)bp;\n    if (an < bn) \n        return -1;\n    if (an > bn)\n        return +1;\n    return 0;\n}\n\nstatic void check_results(DB **dbs) {\n    // verify trees\n    for (int j = 0;j < NUM_DBS; j++) {\n        int r = dbs[j]->verify_with_progress(dbs[j], NULL, NULL, 0, 0);\n        assert(r == 0);\n    }\n\n    // verify rows\n    for (int j = 0;j < NUM_DBS; j++) {\n        unsigned int prev_k = 0;\n\n        DBT key, val;\n        unsigned int k=0, v=0;\n        dbt_init(&key, &k, sizeof(unsigned int));\n        dbt_init(&val, &v, sizeof(unsigned int));\n\n        int r;\n\n        DB_TXN *txn;\n        r = env->txn_begin(env, NULL, &txn, 0);\n        CKERR(r);\n\n        DBC *cursor;\n        r = dbs[j]->cursor(dbs[j], txn, &cursor, 0);\n        CKERR(r);\n\n        // generate the expected keys\n        unsigned int *expected_key = (unsigned int *) toku_malloc(NUM_ROWS * sizeof (unsigned int));\n        for (int i = 0; i < NUM_ROWS; i++)\n            expected_key[i] = j == 0 ? (unsigned int)(i+1) : twiddle32(i+1, j);\n        // sort the keys\n        qsort(expected_key, NUM_ROWS, sizeof (unsigned int), uint_cmp);\n\n        unsigned int valcheck[VALSIZE/sizeof(unsigned int)];\n        for (int i = 0; i < NUM_ROWS+1; i++) {\n            r = cursor->c_get(cursor, &key, &val, DB_NEXT);\n            if (DISALLOW_PUTS) {\n                CKERR2(r, DB_NOTFOUND);\n                break;\n            }\n            if (r == DB_NOTFOUND) {\n                assert(i == NUM_ROWS); // check that there are exactly NUM_ROWS in the dictionary\n                break;\n            }\n            CKERR(r);\n\n            k = *(unsigned int*)key.data;\n\n            unsigned int pkey_for_db_key = (j == 0) ? k : inv_twiddle32(k, j);\n            v = *(unsigned int*)val.data;\n            // test that we have the expected keys and values\n            assert((unsigned int)pkey_for_db_key == (unsigned int)pkey_for_val(v, j));\n\n\n//            printf(\" DB[%d] key = %10u, val = %10u, pkey_for_db_key = %10u, pkey_for_val=%10d\\n\", j, v, k, pkey_for_db_key, pkey_for_val(v, j));\n\n            // check the expected keys\n            assert(k == expected_key[i]);\n            generate_val(pkey_for_db_key, j, &valcheck[0]);\n            assert(val.size == (unsigned)VALSIZE);\n            assert(memcmp(val.data, &valcheck[0], VALSIZE)==0);\n\n            // check prev_key < key\n            if (i > 0) \n                assert(prev_k < k);\n\n            // update prev = current\n            prev_k = k;\n        }\n\n        toku_free(expected_key);\n\n        if ( verbose ) {printf(\".\"); fflush(stdout);}\n        r = cursor->c_close(cursor);\n        CKERR(r);\n\n        r = txn->commit(txn, 0);\n        CKERR(r);\n    }\n    if ( verbose ) printf(\"\\nCheck OK\\n\");\n}\n\nstatic void *expect_poll_void = &expect_poll_void;\nstatic uint64_t poll_count=0;\nstatic uint64_t bomb_after_poll_count=UINT64_MAX;\n\nstatic struct progress_info {\n    double time;\n    double progress;\n} *progress_infos=NULL;\nstatic int progress_infos_count=0;\nstatic int progress_infos_limit=0;\n\n// timing\nstatic bool did_start=false;\nstatic struct timeval start;\n\nstatic int poll_function (void *extra, float progress) {\n    if (verbose>=2) {\n\tassert(did_start);\n\tstruct timeval now;\n\tgettimeofday(&now, 0);\n\tdouble elapsed = now.tv_sec - start.tv_sec + 1e-6*(now.tv_usec - start.tv_usec);\n\tprintf(\"Progress: %6.6fs %5.1f%%\\n\", elapsed, progress*100);\n\tif (progress_infos_count>=progress_infos_limit) {\n\t    progress_infos_limit = 2*progress_infos_limit + 1;\n\t    XREALLOC_N(progress_infos_limit, progress_infos);\n\t}\n\tprogress_infos[progress_infos_count++] = (struct progress_info){elapsed, progress};\t    \n    }\n    assert(extra==expect_poll_void);\n    assert(0.0<=progress && progress<=1.0);\n    poll_count++; // Calls to poll_function() are protected by a lock, so we don't have to do this atomically.\n    if (poll_count>bomb_after_poll_count)\n\treturn TOKUDB_CANCELED;\n    else\n\treturn 0;\n}\n\nstatic struct timeval starttime;\nstatic double elapsed_time (void) {\n    struct timeval now;\n    gettimeofday(&now, NULL);\n    return now.tv_sec - starttime.tv_sec + 1e-6*(now.tv_usec - starttime.tv_usec);\n}\n\nstatic void test_loader(DB **dbs)\n{\n    gettimeofday(&starttime, NULL);\n    int r;\n    DB_TXN    *txn;\n    DB_LOADER *loader;\n    uint32_t db_flags[MAX_DBS];\n    uint32_t dbt_flags[MAX_DBS];\n    uint32_t flags = DB_NOOVERWRITE;\n    if ( (DISALLOW_PUTS) && (ALLOW_DUPS == 1) ) flags = 0;\n    for(int i=0;i<MAX_DBS;i++) { \n        db_flags[i] = flags;\n        dbt_flags[i] = 0;\n    }\n    \n    uint32_t loader_flags = DISALLOW_PUTS | COMPRESS; // set with -p option\n\n    // create and initialize loader\n    r = env->txn_begin(env, NULL, &txn, 0);\n    CKERR(r);\n    hiwater_start = hiwater;\n    if (footprint_print)  printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = env->create_loader(env, txn, &loader, dbs[0], NUM_DBS, dbs, db_flags, dbt_flags, loader_flags);\n    CKERR(r);\n    if (footprint_print)  printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = loader->set_error_callback(loader, NULL, NULL);\n    CKERR(r);\n    r = loader->set_poll_function(loader, poll_function, expect_poll_void);\n    CKERR(r);\n\n    // using loader->put, put values into DB\n    DBT key, val;\n    unsigned int k;\n    unsigned int v[VALSIZE/sizeof(unsigned int)];\n    for(int i=1;i<=NUM_ROWS;i++) {\n        k = i;\n        generate_val(i, 0, &v[0]);\n        dbt_init(&key, &k, sizeof(unsigned int));\n        dbt_init(&val, &v[0], VALSIZE);\n        r = loader->put(loader, &key, &val);\n        if (DISALLOW_PUTS) {\n            CKERR2(r, EINVAL);\n        } else {\n            CKERR(r);\n        }\n        if ( verbose) { if((i%10000) == 0){printf(\".\"); fflush(stdout);} }\n    }\n    if ( verbose ) {printf(\"\\n\"); fflush(stdout);}        \n        \n    poll_count=0;\n\n    int n = count_temp(env->i->real_data_dir);\n    if (verbose) printf(\"Num temp files = %d\\n\", n);\n\n    did_start = true;\n    gettimeofday(&start, 0);\n\n    // close the loader\n    if ( verbose ) printf(\"%9.6fs closing\\n\", elapsed_time());\n    if (footprint_print) printf(\"%s:%d Hiwater=%ld water=%ld\\n\", __FILE__, __LINE__, hiwater, water);\n    r = loader->close(loader);\n    if (footprint_print) printf(\"%s:%d Hiwater=%ld water=%ld (extra hiwater=%ldM)\\n\", __FILE__, __LINE__, hiwater, water, (hiwater-hiwater_start)/(1024*1024));\n    if ( verbose ) printf(\"%9.6fs done\\n\",    elapsed_time());\n    CKERR2s(r,0,TOKUDB_CANCELED);\n\n    if (r==0) {\n\tif (!DISALLOW_PUTS) {\n\t    if (poll_count == 0) printf(\"%s:%d\\n\", __FILE__, __LINE__);\n\t    assert(poll_count>0);\n\t}\n\n\tr = txn->commit(txn, 0);\n\tCKERR(r);\n\n\t// verify the DBs\n\tif ( CHECK_RESULTS ) {\n\t    check_results(dbs);\n\t}\n\n\tif ( check_est ) {\n\t    for (int i=0; i<NUM_DBS; i++) {\n\t\tr = env->txn_begin(env, NULL, &txn, 0);                                                               \n\t\tCKERR(r);\n\t\tDB_BTREE_STAT64 stats;\n\t\tr = dbs[i]->stat64(dbs[i], txn, &stats);\n\t\tCKERR(r);\n                if (verbose)\n                    printf(\"NUM_ROWS=%d n_keys=%\" PRIu64 \" n_data=%\" PRIu64 \" dsize=%\" PRIu64 \" fsize=%\" PRIu64 \"\\n\",\n                           NUM_ROWS, stats.bt_nkeys, stats.bt_ndata, stats.bt_dsize, stats.bt_fsize);\n                if (DISALLOW_PUTS) {\n                    assert(stats.bt_nkeys == 0);  // Fix as part of #4129.  Was ==\n                    assert(stats.bt_ndata == 0);\n                    assert(stats.bt_dsize == 0);\n                } else {\n                    assert(stats.bt_nkeys <= (uint64_t)NUM_ROWS);  // Fix as part of #4129.  Was ==\n                    assert(stats.bt_ndata <= (uint64_t)NUM_ROWS);\n                    assert(stats.bt_dsize == ((uint64_t)NUM_ROWS) * (sizeof(unsigned int) + VALSIZE));\n                }\n\t\tr = txn->commit(txn, 0);\n\t\tCKERR(r);\n\t    }\n\t}\n    } else {\n\tr = txn->abort(txn);\n\tCKERR(r);\n    }\n}\n\nstatic const char *envdir = TOKU_TEST_FILENAME;\nconst char *tmp_subdir = \"tmp.subdir\";\n\nstatic void run_test(void) \n{\n    int r;\n\n    if (upgrade_test) {\n        // cmake set up the environment\n    }\n    else {\n        toku_os_recursive_delete(envdir);\n\tr = toku_os_mkdir(envdir, S_IRWXU+S_IRWXG+S_IRWXO);                                                      CKERR(r);\n        char tmpdir[TOKU_PATH_MAX+1];\n        toku_path_join(tmpdir, 2, envdir, tmp_subdir);\n        r = toku_os_mkdir(tmpdir, S_IRWXU+S_IRWXG+S_IRWXO);                                                   CKERR(r);\n    }\n\n    r = db_env_create(&env, 0);                                                                           CKERR(r);\n    r = env->set_redzone(env, 0);                                                                         CKERR(r);\n    r = env->set_tmp_dir(env, tmp_subdir);                                                                CKERR(r);\n    \n    r = env->set_default_bt_compare(env, uint_dbt_cmp);                                                       CKERR(r);\n    if ( verbose ) printf(\"CACHESIZE = %d MB\\n\", CACHESIZE);\n    r = env->set_cachesize(env, CACHESIZE / 1024, (CACHESIZE % 1024)*1024*1024, 1);                           CKERR(r);\n    if (datadir) {\n        r = env->set_data_dir(env, datadir);                                                                  CKERR(r);\n    }\n    r = env->set_generate_row_callback_for_put(env, put_multiple_generate);\n    CKERR(r);\n    int envflags = DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_CREATE | DB_PRIVATE;\n    r = env->open(env, envdir, envflags, S_IRWXU+S_IRWXG+S_IRWXO);                                            CKERR(r);\n    env->set_errfile(env, stderr);\n    r = env->checkpointing_set_period(env, 60);                                                                CKERR(r);\n\n    DBT desc;\n    dbt_init(&desc, \"foo\", sizeof(\"foo\"));\n    char name[MAX_NAME*2];\n\n    DB **dbs = (DB**)toku_malloc(sizeof(DB*) * NUM_DBS);\n    assert(dbs != NULL);\n    int idx[MAX_DBS];\n    for(int i=0;i<NUM_DBS;i++) {\n        idx[i] = i;\n        r = db_create(&dbs[i], env, 0);                                                                       CKERR(r);\n        dbs[i]->app_private = &idx[i];\n        snprintf(name, sizeof(name), \"db_%04x\", i);\n        r = dbs[i]->open(dbs[i], NULL, name, NULL, DB_BTREE, DB_CREATE, 0666);                                CKERR(r);\n        IN_TXN_COMMIT(env, NULL, txn_desc, 0, {\n                { int chk_r = dbs[i]->change_descriptor(dbs[i], txn_desc, &desc, 0); CKERR(chk_r); }\n        });\n    }\n\n    generate_permute_tables();\n\n    // -------------------------- //\n    test_loader(dbs);\n    // -------------------------- //\n\n    for(int i=0;i<NUM_DBS;i++) {\n        dbs[i]->close(dbs[i], 0);                                                                             CKERR(r);\n        dbs[i] = NULL;\n    }\n    if (verbose >= 2)\n\tprint_engine_status(env);\n    r = env->close(env, 0);                                                                                   CKERR(r);\n    toku_free(dbs);\n}\n\n\n// ------------ infrastructure ----------\nstatic void do_args(int argc, char * const argv[]);\n\nint test_main(int argc, char * const *argv) {\n    do_args(argc, argv);\n\n    run_test();\n\n    if (progress_infos) {\n\tif (verbose>=2) {\n\t    double ratio=progress_infos[progress_infos_count-1].time/progress_infos[progress_infos_count-1].progress;\n\t    printf(\"Progress ratios:\\n\");\n\t    for (int i=0; i<progress_infos_count; i++) {\n\t\tprintf(\" %5.3f\\n\", (progress_infos[i].time/progress_infos[i].progress)/ratio);\n\t    }\n\t}\n\ttoku_free(progress_infos);\n    }\n    if (footprint_print) {\n        printf(\"%s:%d Hiwater=%ld water=%ld (extra hiwater=%ldM) mcount=%lld fcount=%lld\\n\", __FILE__, __LINE__, hiwater, water, (hiwater-hiwater_start)/(1024*1024), mcount, fcount);\n        typedef void (*malloc_stats_fun_t)(void);\n        malloc_stats_fun_t malloc_stats_f = (malloc_stats_fun_t) dlsym(RTLD_DEFAULT, \"malloc_stats\");\n        if (malloc_stats_f) {\n            malloc_stats_f();\n        }\n    }\n    return 0;\n}\n\nstatic void do_args(int argc, char * const argv[]) {\n\n    // Must look for \"-f\" right away before we malloc anything.\n    for (int i=1; i<argc; i++)  {\n\n\tif (strcmp(argv[i], \"-f\")) {\n\t    db_env_set_func_malloc(my_malloc);\n\t    db_env_set_func_realloc(my_realloc);\n\t    db_env_set_func_free(my_free);\n\t}\n    }\n\n    int resultcode;\n    char *cmd = argv[0];\n    argc--; argv++;\n    \n    CACHESIZE = (toku_os_get_phys_memory_size() / (1024*1024))/2; //MB\n\n    while (argc>0) {\n\tif (strcmp(argv[0], \"-v\")==0) {\n\t    verbose++;\n\t} else if (strcmp(argv[0],\"-q\")==0) {\n\t    verbose--;\n\t    if (verbose<0) verbose=0;\n        } else if (strcmp(argv[0], \"-h\")==0) {\n\t    resultcode=0;\n\tdo_usage:\n\t    fprintf(stderr, \"Usage: -h -c -d <num_dbs> -r <num_rows> [ -b <num_calls> ] [-m <megabytes>] [-M]\\n%s\\n\", cmd);\n\t    fprintf(stderr, \"  where -d <num_dbs>     is the number of dictionaries to build (primary & secondary).  (Default=%d)\\n\", NUM_DBS);\n\t    fprintf(stderr, \"        -b <num_calls>   causes the poll function to return nonzero after <num_calls>\\n\");\n\t    fprintf(stderr, \"        -m <m>           use m MB of memory for the cachetable (default is %d MB)\\n\", CACHESIZE);\n            fprintf(stderr, \"        -M               use %d MB of memory for the cachetable\\n\", old_default_cachesize);\n\t    fprintf(stderr, \"        -s               use size factor of 1 and count temporary files\\n\");\n\t    fprintf(stderr,  \"        -f               print memory footprint information at various points in the load\\n\");\n\t    exit(resultcode);\n        } else if (strcmp(argv[0], \"-d\")==0) {\n            argc--; argv++;\n            NUM_DBS = atoi(argv[0]);\n            if ( NUM_DBS > MAX_DBS ) {\n                fprintf(stderr, \"max value for -d field is %d\\n\", MAX_DBS);\n                resultcode=1;\n                goto do_usage;\n            }\n        } else if (strcmp(argv[0], \"-v\")==0) {\n\t    verbose++;\n\t} else if (strcmp(argv[0],\"-q\")==0) {\n\t    verbose--;\n\t    if (verbose<0) verbose=0;\n\t} else if (strcmp(argv[0], \"-f\")==0) {\n\t    footprint_print = true;\n        } else if (strcmp(argv[0], \"--valsize\")==0) {\n            argc--; argv++;\n            VALSIZE=atoi(argv[0]);\n            VALSIZE -= VALSIZE % sizeof(unsigned int);\n            if ( VALSIZE < (int)sizeof(unsigned int) ) {\n                fprintf(stderr, \"--valsize must be multiple of %d\\n\", (int)sizeof(unsigned int));\n                resultcode=1;\n                goto do_usage;\n            }\n        } else if (strcmp(argv[0], \"-r\")==0) {\n            argc--; argv++;\n            NUM_ROWS = atoi(argv[0]);\n        } else if (strcmp(argv[0], \"-c\")==0) {\n            CHECK_RESULTS = 1;\n        } else if (strcmp(argv[0], \"-p\")==0) {\n            DISALLOW_PUTS = LOADER_DISALLOW_PUTS;\n        } else if (strcmp(argv[0], \"-z\")==0) {\n            COMPRESS = LOADER_COMPRESS_INTERMEDIATES;\n        } else if (strcmp(argv[0], \"-m\")==0) {\n            argc--; argv++;\n            CACHESIZE = atoi(argv[0]);\n        } else if (strcmp(argv[0], \"-M\")==0) {\n\t    CACHESIZE = old_default_cachesize;\n        } else if (strcmp(argv[0], \"-y\")==0) {\n            ALLOW_DUPS = 1;\n        } else if (strcmp(argv[0], \"-s\")==0) {\n\t    //printf(\"\\nTesting loader with size_factor=1\\n\");\n\t    db_env_set_loader_size_factor(1);            \n\t} else if (strcmp(argv[0], \"-b\")==0) {\n\t    argc--; argv++;\n\t    char *end;\n\t    errno=0;\n\t    bomb_after_poll_count = strtoll(argv[0], &end, 10);\n\t    assert(errno==0);\n\t    assert(*end==0); // make sure we consumed the whole integer.\n        } else if (strcmp(argv[0], \"--datadir\") == 0 && argc > 1) {\n            argc--; argv++;\n            datadir = argv[0];\n\t} else if (strcmp(argv[0], \"--dont_check_est\") == 0) {\n\t    check_est = false;\n        } else if (strcmp(argv[0], \"-u\")==0) {\n            upgrade_test = true;\n\t} else {\n\t    fprintf(stderr, \"Unknown arg: %s\\n\", argv[0]);\n\t    resultcode=1;\n\t    goto do_usage;\n\t}\n\targc--;\n\targv++;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/valgrind.suppressions": "{\n   compress_is_still_not_valgrind_clean_in_ubuntu_3\n   Memcheck:Param\n   write(buf)\n   obj:/lib/libpthread-2.10.1.so\n   fun:toku_os_write\n   fun:write_nonleaf_node\n}\n{\n   compress_is_still_not_valgrind_clean_in_ubuntu_2\n   Memcheck:Param\n   write(buf)\n   obj:/lib/libpthread-2.10.1.so\n   fun:toku_os_write\n   fun:finish_leafnode\n}\n{\n   compress_is_still_not_valgrind_clean_in_ubuntu\n   Memcheck:Param\n   pwrite64(buf)\n   obj:/lib/libpthread-2.10.1.so\n   fun:toku_os_full_pwrite\n   fun:toku_serialize_ftnode_to\n}\n{\n   compress_is_not_valgrind_clean\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   compress_is_not_valgrind_clean2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_fast\n   fun:deflate\n   fun:compress2\n}\n\n{\n   compress_is_not_valgrind_clean3\n   Memcheck:Cond\n   obj:/usr/lib64/libz.so.1.2.3\n   obj:/usr/lib64/libz.so.1.2.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean3_32\n   Memcheck:Cond\n   obj:/usr/lib/libz.so.1.2.3\n   obj:/usr/lib/libz.so.1.2.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean3_fedora9\n   Memcheck:Cond\n   obj:/lib64/libz.so.1.2.3\n   obj:/lib64/libz.so.1.2.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean_ubuntu804\n   Memcheck:Cond\n   obj:/usr/lib/libz.so.1.2.3.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean_ubuntu810\n   Memcheck:Value8\n   obj:/usr/lib/libz.so.1.2.3.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean2_ubuntu810\n   Memcheck:Cond\n   obj:/usr/lib/libz.so.1.2.3.3\n   obj:/usr/lib/libz.so.1.2.3.3\n   fun:deflate\n   fun:compress2\n}\n{\n   compress_is_not_valgrind_clean3_ubuntu810\n   Memcheck:Value8\n   obj:/usr/lib/libz.so.1.2.3.3\n   obj:/usr/lib/libz.so.1.2.3.3\n   obj:/usr/lib/libz.so.1.2.3.3\n   fun:deflate\n   fun:compress2\n}\n{\n   qlz_is_not_valgrind_clean\n   Memcheck:Cond\n   fun:qlz_compress_core\n}\n{\n   qlz_is_not_valgrind_clean\n   Memcheck:Value8\n   fun:qlz_compress_core\n}\n{\n   qlz_is_not_valgrind_clean\n   Memcheck:Cond\n   fun:qlz_compress\n}\n{\n   qlz_is_not_valgrind_clean\n   Memcheck:Value8\n   fun:qlz_compress\n}\n{\n   dlsym_on_centos\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   obj:/lib64/libdl-2.5.so\n}\n{\n   dlsym_on_centos\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_signal_error\n   obj:/lib64/ld-2.5.so\n}\n{\n   dlsym_on_FC12\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n}\n{\n   dlsym_on_FC12\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_signal_error\n   fun:_dl_signal_cerror\n   fun:_dl_lookup_symbol_x\n   fun:do_sym\n   fun:dlsym_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlsym\n}\n{\n   dyld_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/dyld\n}\n{\n   dyld_on_OSX\n   Memcheck:Value8\n   ...\n   obj:/usr/lib/dyld\n}\n{\n   dyld_on_OSX\n   Memcheck:Cond\n   ...\n   obj:/usr/lib/dyld\n}\n{\n   ctime_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   ...\n   fun:asctime_r\n}\n{\n   ctime_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   ...\n   fun:ctime\n}\n{\n   pthread_join_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   fun:pthread_join\n}\n{\n   pthread_start_on_OSX\n   Memcheck:Leak\n   ...\n   fun:_pthread_start\n   obj:/usr/lib/system/libsystem_c.dylib\n}\n{\n   printf_etc_on_OSX\n   Memcheck:Leak\n   ...\n   fun:__dtoa\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n}\n{\n   printf_etc_on_OSX\n   Memcheck:Leak\n   ...\n   fun:__smakebuf\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n}\n{\n   fopen_on_OSX\n   Memcheck:Leak\n   ...\n   fun:fopen$DARWIN_EXTSN\n}\n{\n   popen_on_OSX\n   Memcheck:Leak\n   ...\n   fun:popen$DARWIN_EXTSN\n}\n{\n   gettimeofday_on_OSX\n   Memcheck:Leak\n   ...\n   fun:tzsetwall_basic\n   obj:/usr/lib/system/libsystem_c.dylib\n}\n{\n   setenv_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   fun:setenv\n}\n{\n   unsetenv_on_OSX\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   fun:unsetenv\n}\n{\n   loadlocale_on_osx\n   Memcheck:Leak\n   ...\n   obj:/usr/lib/system/libsystem_c.dylib\n   fun:loadlocale\n}\n{\n   <ld_is_not_valgrind_clean_in_ubuntu_13.04_1>\n   Memcheck:Cond\n   fun:index\n   fun:expand_dynamic_string_token\n   fun:_dl_map_object\n   fun:map_doit\n   fun:_dl_catch_error\n   fun:do_preload\n   fun:dl_main\n   fun:_dl_sysdep_start\n   fun:_dl_start\n   obj:/lib/x86_64-linux-gnu/ld-2.17.so\n}\n{\n   <ld_is_not_valgrind_clean_in_ubuntu_13.04_2>\n   Memcheck:Cond\n   fun:index\n   fun:expand_dynamic_string_token\n   fun:_dl_map_object\n   fun:map_doit\n   fun:_dl_catch_error\n   fun:do_preload\n   fun:dl_main\n   fun:_dl_sysdep_start\n   fun:_dl_start\n   obj:/lib/x86_64-linux-gnu/ld-2.17.so\n}\n{\n    <ld_is_not_clean_on_arch_linux_june_2014>\n    Memcheck:Leak\n    match-leak-kinds: reachable\n    fun:calloc\n    ...\n    fun:dlsym\n    ...\n    fun:_dl_init\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/cmake_modules/TokuFeatureDetection.cmake": "## feature detection\nfind_package(Threads)\nfind_package(ZLIB REQUIRED)\n\noption(USE_VALGRIND \"Build to run safely under valgrind (often slower).\" ON)\nif(USE_VALGRIND)\n  find_package(Valgrind REQUIRED)\nendif()\n\noption(TOKU_DEBUG_PARANOID \"Enable paranoid asserts.\" ON)\n\ninclude(CheckIncludeFiles)\n\n## check for some include files\ncheck_include_files(alloca.h HAVE_ALLOCA_H)\ncheck_include_files(arpa/inet.h HAVE_ARPA_INET_H)\ncheck_include_files(bits/functexcept.h HAVE_BITS_FUNCTEXCEPT_H)\ncheck_include_files(byteswap.h HAVE_BYTESWAP_H)\ncheck_include_files(endian.h HAVE_ENDIAN_H)\ncheck_include_files(fcntl.h HAVE_FCNTL_H)\ncheck_include_files(inttypes.h HAVE_INTTYPES_H)\ncheck_include_files(libkern/OSAtomic.h HAVE_LIBKERN_OSATOMIC_H)\ncheck_include_files(libkern/OSByteOrder.h HAVE_LIBKERN_OSBYTEORDER_H)\ncheck_include_files(limits.h HAVE_LIMITS_H)\ncheck_include_files(machine/endian.h HAVE_MACHINE_ENDIAN_H)\ncheck_include_files(malloc.h HAVE_MALLOC_H)\ncheck_include_files(malloc/malloc.h HAVE_MALLOC_MALLOC_H)\ncheck_include_files(malloc_np.h HAVE_MALLOC_NP_H)\ncheck_include_files(pthread.h HAVE_PTHREAD_H)\ncheck_include_files(pthread_np.h HAVE_PTHREAD_NP_H)\ncheck_include_files(stdint.h HAVE_STDINT_H)\ncheck_include_files(stdlib.h HAVE_STDLIB_H)\ncheck_include_files(string.h HAVE_STRING_H)\ncheck_include_files(syscall.h HAVE_SYSCALL_H)\ncheck_include_files(sys/endian.h HAVE_SYS_ENDIAN_H)\ncheck_include_files(sys/file.h HAVE_SYS_FILE_H)\ncheck_include_files(sys/malloc.h HAVE_SYS_MALLOC_H)\ncheck_include_files(sys/prctl.h HAVE_SYS_PRCTL_H)\ncheck_include_files(sys/resource.h HAVE_SYS_RESOURCE_H)\ncheck_include_files(sys/statvfs.h HAVE_SYS_STATVFS_H)\ncheck_include_files(sys/syscall.h HAVE_SYS_SYSCALL_H)\ncheck_include_files(sys/sysctl.h HAVE_SYS_SYSCTL_H)\ncheck_include_files(sys/syslimits.h HAVE_SYS_SYSLIMITS_H)\ncheck_include_files(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_files(unistd.h HAVE_UNISTD_H)\n\ninclude(CheckSymbolExists)\n\n## check whether we can set the mmap threshold like we can in gnu libc's malloc\ncheck_symbol_exists(M_MMAP_THRESHOLD \"malloc.h\" HAVE_M_MMAP_THRESHOLD)\n## check whether we have CLOCK_REALTIME\ncheck_symbol_exists(CLOCK_REALTIME \"time.h\" HAVE_CLOCK_REALTIME)\n## check how to do direct I/O\nif (NOT CMAKE_SYSTEM_NAME STREQUAL FreeBSD)\n  set(CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\nendif ()\ncheck_symbol_exists(O_DIRECT \"fcntl.h\" HAVE_O_DIRECT)\ncheck_symbol_exists(F_NOCACHE \"fcntl.h\" HAVE_F_NOCACHE)\ncheck_symbol_exists(MAP_ANONYMOUS \"sys/mman.h\" HAVE_MAP_ANONYMOUS)\ncheck_symbol_exists(PR_SET_PTRACER \"sys/prctl.h\" HAVE_PR_SET_PTRACER)\ncheck_symbol_exists(PR_SET_PTRACER_ANY \"sys/prctl.h\" HAVE_PR_SET_PTRACER_ANY)\n\ninclude(CheckFunctionExists)\n\n## check for the right way to get the actual allocation size of a pointer\ncheck_function_exists(malloc_size HAVE_MALLOC_SIZE)\ncheck_function_exists(malloc_usable_size HAVE_MALLOC_USABLE_SIZE)\n## check whether we have memalign or valloc (a weak substitute for memalign on darwin)\ncheck_function_exists(memalign HAVE_MEMALIGN)\ncheck_function_exists(valloc HAVE_VALLOC)\n## check whether we have random_r or nrand48 to use as a reentrant random function\ncheck_function_exists(nrand48 HAVE_NRAND48)\ncheck_function_exists(random_r HAVE_RANDOM_R)\ncheck_function_exists(mincore HAVE_MINCORE)\n\n## clear this out in case mysql modified it\nset(CMAKE_REQUIRED_LIBRARIES \"\")\nset(EXTRA_SYSTEM_LIBS \"\")\ncheck_function_exists(dlsym HAVE_DLSYM_WITHOUT_DL)\nif (NOT HAVE_DLSYM_WITHOUT_DL)\n  set(CMAKE_REQUIRED_LIBRARIES dl)\n  check_function_exists(dlsym HAVE_DLSYM_WITH_DL)\n  if (HAVE_DLSYM_WITH_DL)\n    list(APPEND EXTRA_SYSTEM_LIBS dl)\n  else ()\n    message(FATAL_ERROR \"Cannot find dlsym(), even with -ldl.\")\n  endif ()\nendif ()\ncheck_function_exists(backtrace HAVE_BACKTRACE_WITHOUT_EXECINFO)\nif (NOT HAVE_BACKTRACE_WITHOUT_EXECINFO)\n  set(CMAKE_REQUIRED_LIBRARIES execinfo)\n  check_function_exists(backtrace HAVE_BACKTRACE_WITH_EXECINFO)\n  if (HAVE_BACKTRACE_WITH_EXECINFO)\n    list(APPEND EXTRA_SYSTEM_LIBS execinfo)\n  else ()\n    message(WARNING \"Cannot find backtrace(), even with -lexecinfo.\")\n  endif ()\nendif ()\n\nif(HAVE_CLOCK_REALTIME AND (NOT APPLE))\n  list(APPEND EXTRA_SYSTEM_LIBS rt)\nelse()\n  list(APPEND EXTRA_SYSTEM_LIBS System)\nendif()\n\nset(CMAKE_REQUIRED_LIBRARIES pthread)\n## check whether we can change rwlock preference\ncheck_function_exists(pthread_rwlockattr_setkind_np HAVE_PTHREAD_RWLOCKATTR_SETKIND_NP)\n## check for the right way to yield using pthreads\ncheck_function_exists(pthread_yield HAVE_PTHREAD_YIELD)\ncheck_function_exists(pthread_yield_np HAVE_PTHREAD_YIELD_NP)\n## check if we have pthread_threadid_np() (i.e. osx)\ncheck_function_exists(pthread_threadid_np HAVE_PTHREAD_THREADID_NP)\n## check if we have pthread_getthreadid_np() (i.e. freebsd)\ncheck_function_exists(pthread_getthreadid_np HAVE_PTHREAD_GETTHREADID_NP)\ncheck_function_exists(sched_getcpu HAVE_SCHED_GETCPU)\n\ninclude(CheckCSourceCompiles)\n\nif (HAVE_PTHREAD_YIELD)\n  include(CheckPrototypeDefinition)\n\n  check_prototype_definition(pthread_yield \"void pthread_yield(void)\" \"(void)0\" \"pthread.h\" PTHREAD_YIELD_RETURNS_VOID)\n  check_c_source_compiles(\"#include <pthread.h>\nint main(void) {\n  int r = pthread_yield();\n  return r;\n}\" PTHREAD_YIELD_RETURNS_INT)\nendif (HAVE_PTHREAD_YIELD)\n\n## check whether we have gcc-style thread-local storage using a storage class modifier\ncheck_c_source_compiles(\"#include <pthread.h>\nstatic __thread int tlsvar = 0;\nint main(void) { return tlsvar; }\" HAVE_GNU_TLS)\n\n## set TOKUDB_REVISION\nset(CMAKE_TOKUDB_REVISION 0 CACHE INTEGER \"Revision of tokudb.\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/wsrep/wsrep_loader.c": "/* Copyright (C) 2009-2011 Codership Oy <info@codersihp.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301 USA\n */\n\n/*! @file wsrep implementation loader */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"wsrep_api.h\"\n\n// Logging stuff for the loader\nstatic const char* log_levels[] = {\"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"};\n\nstatic void default_logger (wsrep_log_level_t lvl, const char* msg)\n{\n    fprintf (stderr, \"wsrep loader: [%s] %s\\n\", log_levels[lvl], msg);\n}\n\nstatic wsrep_log_cb_t logger = default_logger;\n\n/**************************************************************************\n * Library loader\n **************************************************************************/\n\nstatic int wsrep_check_iface_version(const char* found, const char* iface_ver)\n{\n    const size_t msg_len = 128;\n    char msg[128];\n\n    if (strcmp(found, iface_ver)) {\n        snprintf (msg, msg_len,\n                  \"provider interface version mismatch: need '%s', found '%s'\",\n                  iface_ver, found);\n        logger (WSREP_LOG_ERROR, msg);\n        return EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int verify(const wsrep_t *wh, const char *iface_ver)\n{\n    char msg[128];\n\n#define VERIFY(_p) if (!(_p)) {                                       \\\n        snprintf(msg, sizeof(msg), \"wsrep_load(): verify(): %s\\n\", # _p); \\\n        logger (WSREP_LOG_ERROR, msg);                                \\\n        return EINVAL;                                                \\\n    }\n\n    VERIFY(wh);\n    VERIFY(wh->version);\n\n    if (wsrep_check_iface_version(wh->version, iface_ver))\n        return EINVAL;\n\n    VERIFY(wh->init);\n    VERIFY(wh->options_set);\n    VERIFY(wh->options_get);\n    VERIFY(wh->connect);\n    VERIFY(wh->disconnect);\n    VERIFY(wh->recv);\n    VERIFY(wh->pre_commit);\n    VERIFY(wh->post_commit);\n    VERIFY(wh->post_rollback);\n    VERIFY(wh->replay_trx);\n    VERIFY(wh->abort_pre_commit);\n    VERIFY(wh->append_key);\n    VERIFY(wh->append_data);\n    VERIFY(wh->free_connection);\n    VERIFY(wh->to_execute_start);\n    VERIFY(wh->to_execute_end);\n    VERIFY(wh->preordered_collect);\n    VERIFY(wh->preordered_commit);\n    VERIFY(wh->sst_sent);\n    VERIFY(wh->sst_received);\n    VERIFY(wh->stats_get);\n    VERIFY(wh->stats_free);\n    VERIFY(wh->stats_reset);\n    VERIFY(wh->pause);\n    VERIFY(wh->resume);\n    VERIFY(wh->desync);\n    VERIFY(wh->resync);\n    VERIFY(wh->lock);\n    VERIFY(wh->unlock);\n    VERIFY(wh->is_locked);\n    VERIFY(wh->provider_name);\n    VERIFY(wh->provider_version);\n    VERIFY(wh->provider_vendor);\n    VERIFY(wh->free);\n    return 0;\n}\n\ntypedef int (*wsrep_loader_fun)(wsrep_t*);\n\nstatic wsrep_loader_fun wsrep_dlf(void *dlh, const char *sym)\n{\n    union {\n        wsrep_loader_fun dlfun;\n        void *obj;\n    } alias;\n    alias.obj = dlsym(dlh, sym);\n    return alias.dlfun;\n}\n\nstatic int wsrep_check_version_symbol(void *dlh)\n{\n    char** dlversion = NULL;\n    dlversion = (char**) dlsym(dlh, \"wsrep_interface_version\");\n    if (dlversion == NULL)\n        return 0;\n    return wsrep_check_iface_version(*dlversion, WSREP_INTERFACE_VERSION);\n}\n\nextern int wsrep_dummy_loader(wsrep_t *w);\n\nint wsrep_load(const char *spec, wsrep_t **hptr, wsrep_log_cb_t log_cb)\n{\n    int ret = 0;\n    void *dlh = NULL;\n    wsrep_loader_fun dlfun;\n    char msg[1025];\n    msg[sizeof(msg)-1] = 0;\n\n    if (NULL != log_cb)\n        logger = log_cb;\n\n    if (!(spec && hptr))\n        return EINVAL;\n\n    snprintf (msg, sizeof(msg)-1,\n              \"wsrep_load(): loading provider library '%s'\", spec);\n    logger (WSREP_LOG_INFO, msg);\n\n    if (!(*hptr = malloc(sizeof(wsrep_t)))) {\n        logger (WSREP_LOG_FATAL, \"wsrep_load(): out of memory\");\n        return ENOMEM;\n    }\n\n    if (!spec || strcmp(spec, WSREP_NONE) == 0) {\n        if ((ret = wsrep_dummy_loader(*hptr)) != 0) {\n            free (*hptr);\n            *hptr = NULL;\n        }\n        return ret;\n    }\n\n    if (!(dlh = dlopen(spec, RTLD_NOW | RTLD_LOCAL))) {\n        snprintf(msg, sizeof(msg)-1, \"wsrep_load(): dlopen(): %s\", dlerror());\n        logger (WSREP_LOG_ERROR, msg);\n        ret = EINVAL;\n        goto out;\n    }\n\n    if (!(dlfun = wsrep_dlf(dlh, \"wsrep_loader\"))) {\n        ret = EINVAL;\n        goto out;\n    }\n\n    if (wsrep_check_version_symbol(dlh) != 0) {\n        ret = EINVAL;\n        goto out;\n    }\n\n    if ((ret = (*dlfun)(*hptr)) != 0) {\n        snprintf(msg, sizeof(msg)-1, \"wsrep_load(): loader failed: %s\",\n                 strerror(ret));\n        logger (WSREP_LOG_ERROR, msg);\n        goto out;\n    }\n\n    if ((ret = verify(*hptr, WSREP_INTERFACE_VERSION)) != 0) {\n        snprintf (msg, sizeof(msg)-1,\n                  \"wsrep_load(): interface version mismatch: my version %s, \"\n                  \"provider version %s\", WSREP_INTERFACE_VERSION,\n                  (*hptr)->version);\n        logger (WSREP_LOG_ERROR, msg);\n        goto out;\n    }\n\n    (*hptr)->dlh = dlh;\n\nout:\n    if (ret != 0) {\n        if (dlh) dlclose(dlh);\n        free(*hptr);\n        *hptr = NULL;\n    } else {\n        snprintf (msg, sizeof(msg)-1,\n                  \"wsrep_load(): %s %s by %s loaded successfully.\",\n                  (*hptr)->provider_name, (*hptr)->provider_version,\n                  (*hptr)->provider_vendor);\n        logger (WSREP_LOG_INFO, msg);\n    }\n\n    return ret;\n}\n\nvoid wsrep_unload(wsrep_t *hptr)\n{\n    if (!hptr) {\n        logger (WSREP_LOG_WARN, \"wsrep_unload(): null pointer.\");\n    } else {\n        if (hptr->free)\n            hptr->free(hptr);\n        if (hptr->dlh)\n            dlclose(hptr->dlh);\n        free(hptr);\n    }\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/include/my_global.h": "/*\n   Copyright (c) 2001, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2009, 2017, MariaDB Corporation\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n/* This is the include file that should be included 'first' in every C file. */\n\n#ifndef MY_GLOBAL_INCLUDED\n#define MY_GLOBAL_INCLUDED\n\n/* Client library users on Windows need this macro defined here. */\n#if !defined(__WIN__) && defined(_WIN32)\n#define __WIN__\n#endif\n\n/*\n  InnoDB depends on some MySQL internals which other plugins should not\n  need.  This is because of InnoDB's foreign key support, \"safe\" binlog\n  truncation, and other similar legacy features.\n\n  We define accessors for these internals unconditionally, but do not\n  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for\n  InnoDB's use.\n*/\n#define INNODB_COMPATIBILITY_HOOKS\n\n#ifdef __CYGWIN__\n/* We use a Unix API, so pretend it's not Windows */\n#undef WIN\n#undef WIN32\n#undef _WIN\n#undef _WIN32\n#undef _WIN64\n#undef __WIN__\n#undef __WIN32__\n#define HAVE_ERRNO_AS_DEFINE\n#define _POSIX_MONOTONIC_CLOCK\n#define _POSIX_THREAD_CPUTIME\n#endif /* __CYGWIN__ */\n\n#if defined(__OpenBSD__) && (OpenBSD >= 200411)\n#define HAVE_ERRNO_AS_DEFINE\n#endif\n\n#if defined(i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n/* Macros to make switching between C and C++ mode easier */\n#ifdef __cplusplus\n#define C_MODE_START    extern \"C\" {\n#define C_MODE_END\t}\n#else\n#define C_MODE_START\n#define C_MODE_END\n#endif\n\n#ifdef __cplusplus\n#define CPP_UNNAMED_NS_START  namespace {\n#define CPP_UNNAMED_NS_END    }\n#endif\n\n#include <my_config.h>\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#define HAVE_PSI_INTERFACE\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n/* Make it easier to add conditional code in _expressions_ */\n#ifdef __WIN__\n#define IF_WIN(A,B) A\n#else\n#define IF_WIN(A,B) B\n#endif\n\n#ifdef EMBEDDED_LIBRARY\n#define IF_EMBEDDED(A,B) A\n#else\n#define IF_EMBEDDED(A,B) B\n#endif\n\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n#define IF_PARTITIONING(A,B) A\n#else\n#define IF_PARTITIONING(A,B) B\n#endif\n\n#if defined (_WIN32)\n/*\n off_t is 32 bit long. We do not use C runtime functions\n with off_t but native Win32 file IO APIs, that work with\n 64 bit offsets.\n*/\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T 8\n\n/*\n Prevent inclusion of  Windows GDI headers - they define symbol\n ERROR that conflicts with mysql headers.\n*/\n#ifndef NOGDI\n#define NOGDI\n#endif\n\n/* Include common headers.*/\n#include <winsock2.h>\n#include <ws2tcpip.h> /* SOCKET */\n#include <io.h>       /* access(), chmod() */\n#include <process.h>  /* getpid() */\n\n#define sleep(a) Sleep((a)*1000)\n\n/* Define missing access() modes. */\n#define F_OK 0\n#define W_OK 2\n#define R_OK 4                        /* Test for read permission.  */\n\n/* Define missing file locking constants. */\n#define F_RDLCK 1\n#define F_WRLCK 2\n#define F_UNLCK 3\n#define F_TO_EOF 0x3FFFFFFF\n\n/* Shared memory and named pipe connections are supported. */\n#define HAVE_SMEM 1\n#define HAVE_NAMED_PIPE 1\n#define shared_memory_buffer_length 16000\n#define default_shared_memory_base_name \"MYSQL\"\n#endif /* _WIN32*/\n\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n/*\n  The macros below are used to allow build of Universal/fat binaries of\n  MySQL and MySQL applications under darwin. \n*/\n#if defined(__APPLE__) && defined(__MACH__)\n#  undef SIZEOF_CHARP \n#  undef SIZEOF_INT \n#  undef SIZEOF_LONG \n#  undef SIZEOF_LONG_LONG \n#  undef SIZEOF_OFF_T \n#  undef WORDS_BIGENDIAN\n#  define SIZEOF_INT 4\n#  define SIZEOF_LONG_LONG 8\n#  define SIZEOF_OFF_T 8\n#  if defined(__i386__) || defined(__ppc__)\n#    define SIZEOF_CHARP 4\n#    define SIZEOF_LONG 4\n#  elif defined(__x86_64__) || defined(__ppc64__)\n#    define SIZEOF_CHARP 8\n#    define SIZEOF_LONG 8\n#  else\n#    error Building FAT binary for an unknown architecture.\n#  endif\n#  if defined(__ppc__) || defined(__ppc64__)\n#    define WORDS_BIGENDIAN\n#  endif\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n/*\n  The macros below are borrowed from include/linux/compiler.h in the\n  Linux kernel. Use them to indicate the likelyhood of the truthfulness\n  of a condition. This serves two purposes - newer versions of gcc will be\n  able to optimize for branch predication, which could yield siginficant\n  performance gains in frequently executed sections of the code, and the\n  other reason to use them is for documentation\n*/\n\n#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)\n#define __builtin_expect(x, expected_value) (x)\n#endif\n\n/**\n  The semantics of builtin_expect() are that\n  1) its two arguments are long\n  2) it's likely that they are ==\n  Those of our likely(x) are that x can be bool/int/longlong/pointer.\n*/\n#define likely(x)\t__builtin_expect(((x) != 0),1)\n#define unlikely(x)\t__builtin_expect(((x) != 0),0)\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(TARGET_OS_LINUX) || defined(__GLIBC__)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/*\n  Temporary solution to solve bug#7156. Include \"sys/types.h\" before\n  the thread headers, else the function madvise() will not be defined\n*/\n#if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )\n#include <sys/types.h>\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n/*\n  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document\n\n    System Interfaces and Headers, Issue 5\n\n  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,\n  but apparently other systems (namely FreeBSD) don't agree.\n\n  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.\n  Furthermore, it tests that if a program requires older standard\n  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be\n  run on a new compiler (that defines _STDC_C99) and issues an #error.\n  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600\n  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.\n\n  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while\n  C++ compiler does not!\n\n  So, in a desperate attempt to get correct prototypes for both\n  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500\n  depending on the compiler's announced C standard support.\n\n  Cleaner solutions are welcome.\n*/\n#ifdef __sun\n#if __STDC_VERSION__ - 0 >= 199901L\n#define _XOPEN_SOURCE 600\n#else\n#define _XOPEN_SOURCE 500\n#endif\n#endif\n\n\n#ifdef _AIX\n/*\n  AIX includes inttypes.h from sys/types.h\n  Explicitly request format macros before the first inclusion of inttypes.h\n*/\n#define __STDC_FORMAT_MACROS  \n#endif\n\n\n#if !defined(__WIN__)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#if defined(HPUX10) || defined(HPUX11)\nC_MODE_START\t\t\t/* HPUX needs this, signal.h bug */\n#include <pthread.h>\nC_MODE_END\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* !defined(__WIN__) */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n/* #define _AIX32_CURSES */\t/* XXX: this breaks AIX 4.3.3 (others?). */\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\nC_MODE_START\ninline double my_ulonglong2double(unsigned long long A) { return (double)A; }\nC_MODE_END\n#endif /* _AIX */\n\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* gcc/egcs issues */\n\n#if defined(__GNUC) && defined(__EXCEPTIONS)\n#error \"Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile\"\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#include <stdarg.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n#ifdef HAVE_FENV_H\n#include <fenv.h> /* For fesetround() */\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n/* We need the following to go around a problem with openssl on solaris */\n#if defined(HAVE_CRYPT_H)\n#include <crypt.h>\n#endif\n\n/*\n  A lot of our programs uses asserts, so better to always include it\n  This also fixes a problem when people uses DBUG_ASSERT without including\n  assert.h\n*/\n#include <assert.h>\n\n/* an assert that works at compile-time. only for constant expression */\n#ifdef _some_old_compiler_that_does_not_understand_the_construct_below_\n#define compile_time_assert(X)  do { } while(0)\n#else\n#define compile_time_assert(X)                                  \\\n  do                                                            \\\n  {                                                             \\\n    typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused)); \\\n  } while(0)\n#endif\n\n/* Go around some bugs in different OS and compilers */\n#if defined (HPUX11) && defined(_LARGEFILE_SOURCE)\n#ifndef _LARGEFILE64_SOURCE\n#define _LARGEFILE64_SOURCE\n#endif\n#endif\n\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n/* Declare madvise where it is not declared for C++, like Solaris */\n#if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)\nextern \"C\" int madvise(void *addr, size_t len, int behav);\n#endif\n\n#define QUOTE_ARG(x)\t\t#x\t/* Quote argument (before cpp) */\n#define STRINGIFY_ARG(x) QUOTE_ARG(x)\t/* Quote argument, after cpp */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* Does the system remember a signal handler after a signal ? */\n#if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)\n#define SIGNAL_HANDLER_RESET_ON_DELIVERY\n#endif\n\n/* don't assume that STDERR_FILENO is 2, mysqld can freopen */\n#undef STDERR_FILENO\n\n#ifndef SO_EXT\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#else\n#define SO_EXT \".so\"\n#endif\n#endif\n\n/*\n   Suppress uninitialized variable warning without generating code.\n*/\n#if defined(__GNUC__)\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#elif defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define UNINIT_VAR(x) x= 0\n#else\n#define UNINIT_VAR(x) x\n#endif\n\n/* This is only to be used when reseting variables in a class constructor */\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define LINT_INIT(x) x= 0\n#else\n#define LINT_INIT(x)\n#endif\n\n#if !defined(HAVE_UINT)\n#undef HAVE_UINT\n#define HAVE_UINT\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define swap_variables(t, a, b) do { t dummy; dummy= a; a= b; b= dummy; } while(0)\n#define MY_TEST(a) ((a) ? 1 : 0)\n#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)\n#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)\n#define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#include <my_compiler.h>\n\n/*\n  Wen using the embedded library, users might run into link problems,\n  duplicate declaration of __cxa_pure_virtual, solved by declaring it a\n  weak symbol.\n*/\n#if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)\nC_MODE_START\nint __cxa_pure_virtual () __attribute__ ((weak));\nC_MODE_END\n#endif\n\n/* The DBUG_ON flag always takes precedence over default DBUG_OFF */\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n/* We might be forced to turn debug off, if not turned off already */\n#if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)\n#  define DBUG_OFF\n#  ifdef DBUG_ON\n#    undef DBUG_ON\n#  endif\n#endif\n\n#ifdef DBUG_OFF\n#undef EXTRA_DEBUG\n#endif\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifdef _WIN32\ntypedef SOCKET my_socket;\n#else\ntypedef int\tmy_socket;\t/* File descriptor for sockets */\n#define INVALID_SOCKET -1\n#endif\n/* Type for fuctions that handles signals */\n#define sig_handler RETSIGTYPE\nC_MODE_START\n#ifdef HAVE_SIGHANDLER_T\n#define sig_return sighandler_t\n#else\ntypedef void (*sig_return)(void); /* Returns type from signal */\n#endif\nC_MODE_END\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\nC_MODE_START\ntypedef int\t(*qsort_cmp)(const void *,const void *);\ntypedef int\t(*qsort_cmp2)(void*, const void *,const void *);\nC_MODE_END\n#define qsort_t RETQSORTTYPE\t/* Broken GCC cant handle typedef !!!! */\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\t\t\t/* Probably not windows */\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#ifndef FILE_BINARY\n#define FILE_BINARY\tO_BINARY /* Flag to my_fopen for binary streams */\n#endif\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n#ifndef O_NOFOLLOW\n#define O_NOFOLLOW      0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC       0\n#endif\n#ifndef SOCK_CLOEXEC\n#define SOCK_CLOEXEC    0\n#endif\n\n/* additional file share flags for win32 */\n#ifdef __WIN__\n#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */\n#define _SH_DENYWRD     0x120    /* deny write mode & delete      */\n#define _SH_DENYRDD     0x130    /* deny read mode & delete       */\n#define _SH_DENYDEL     0x140    /* deny delete only              */\n#endif /* __WIN__ */\n\n\n/* General constants */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parent directory; Must be a string */\n\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\\\\\"               /* Valid directory separators */\n#define FN_EXEEXT   \".exe\"\n#define FN_SOEXT    \".dll\"\n#define FN_ROOTDIR\t\"\\\\\"\n#define FN_DEVCHAR\t':'\n#define FN_NETWORK_DRIVES\t/* Uses \\\\ to indicate network drives */\n#define FN_NO_CASE_SENCE\t/* Files are not case-sensitive */\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\"     /* Valid directory separators */\n#define FN_EXEEXT   \"\"\n#define FN_SOEXT    \".so\"\n#define FN_ROOTDIR\t\"/\"\n#endif\n\n/* \n  MY_FILE_MIN is  Windows speciality and is used to quickly detect\n  the mismatch of CRT and mysys file IO usage on Windows at runtime.\n  CRT file descriptors can be in the range 0-2047, whereas descriptors returned\n  by my_open() will start with 2048. If a file descriptor with value less then\n  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from\n  open()/fileno() and not my_open()/my_fileno.\n\n  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN\n  is logically 0.\n*/\n\n#ifdef _WIN32\n#define MY_FILE_MIN  2048\n#else\n#define MY_FILE_MIN  0\n#endif\n\n/* \n  MY_NFILE is the default size of my_file_info array.\n\n  It is larger on Windows, because it all file handles are stored in my_file_info\n  Default size is 16384 and this should be enough for most cases.If it is not \n  enough, --max-open-files with larger value can be used.\n\n  For Posix , my_file_info array is only used to store filenames for\n  error reporting and its size is not a limitation for number of open files.\n*/ \n#ifdef _WIN32\n#define MY_NFILE (16384 + MY_FILE_MIN)\n#else\n#define MY_NFILE 64\n#endif\n\n#ifndef OS_FILE_LIMIT\n#define OS_FILE_LIMIT\tUINT_MAX\n#endif\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096U\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) 4096\n\t/* Typical record cache */\n#define RECORD_CACHE_SIZE\t(uint) (128*1024)\n\t/* Typical key cache */\n#define KEY_CACHE_SIZE\t\t(uint) (128L*1024L*1024L)\n\t/* Default size of a key cache block  */\n#define KEY_CACHE_BLOCK_SIZE\t(uint) 1024\n\n\t/* Some things that this system doesn't have */\n\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#endif\n\n/* Some defines of functions for portability */\n\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef __WIN__\n#define closesocket(A)\tclose(A)\n#endif\n\n#if (_MSC_VER)\n#if !defined(_WIN64)\ninline double my_ulonglong2double(unsigned long long value)\n{\n  long long nr=(long long) value;\n  if (nr >= 0)\n    return (double) nr;\n  return (18446744073709551616.0 + (double) nr);\n}\n#define ulonglong2double my_ulonglong2double\n#define my_off_t2double  my_ulonglong2double\n#endif /* _WIN64 */\ninline unsigned long long my_double2ulonglong(double d)\n{\n  double t= d - (double) 0x8000000000000000ULL;\n\n  if (t >= 0)\n    return  ((unsigned long long) t) + 0x8000000000000000ULL;\n  return (unsigned long long) d;\n}\n#define double2ulonglong my_double2ulonglong\n#endif\n\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (ulonglong) (A))\n#define my_off_t2double(A)  ((double) (my_off_t) (A))\n#endif\n#ifndef double2ulonglong\n#define double2ulonglong(A) ((ulonglong) (double) (A))\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n\n#ifndef STACK_DIRECTION\n#error \"please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS\"\n#endif\n\n#if !defined(HAVE_STRTOK_R)\n#define strtok_r(A,B,C) strtok((A),(B))\n#endif\n\n#if SIZEOF_LONG_LONG >= 8\n#define HAVE_LONG_LONG 1\n#else\n#error WHAT? sizeof(long long) < 8 ???\n#endif\n\n/*\n  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define\n  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.\n*/\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX      (~((size_t) 0))\n#endif\n\n#ifndef isfinite\n#ifdef HAVE_FINITE\n#define isfinite(x) finite(x)\n#else\n#define finite(x) (1.0 / fabs(x) > 0.0)\n#endif /* HAVE_FINITE */\n#elif (__cplusplus >= 201103L)\n#include <cmath>\nstatic inline bool isfinite(double x) { return std::isfinite(x); }\n#endif /* isfinite */\n\n#ifndef HAVE_ISNAN\n#define isnan(x) ((x) != (x))\n#endif\n#define my_isnan(x) isnan(x)\n\n#ifdef HAVE_ISINF\n#define my_isinf(X) isinf(X)\n#else /* !HAVE_ISINF */\n#define my_isinf(X) (!finite(X) && !isnan(X))\n#endif\n\n/* Define missing math constants. */\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.7182818284590452354\n#endif\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n\n#ifndef HAVE_LOG2\n/*\n  This will be slightly slower and perhaps a tiny bit less accurate than\n  doing it the IEEE754 way but log2() should be available on C99 systems.\n*/\nstatic inline double log2(double x)\n{\n  return (log(x) / M_LN2);\n}\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  adressable obj.\n*/\n#if SIZEOF_CHARP == 4\ntypedef long\t\tmy_ptrdiff_t;\n#else\ntypedef long long\tmy_ptrdiff_t;\n#endif\n\n#define MY_ALIGN(A,L)\t   (((A) + (L) - 1) & ~((L) - 1))\n#define MY_ALIGN_DOWN(A,L) ((A) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n#define ALIGN_MAX_UNIT  (sizeof(double))\n/* Size to make adressable obj. */\n#define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A), sizeof(double)))\n#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))\n#define PREV_BITS(type,A)\t((type) (((type) 1 << (A)) -1))\n\n/*\n  Custom version of standard offsetof() macro which can be used to get\n  offsets of members in class for non-POD types (according to the current\n  version of C++ standard offsetof() macro can't be used in such cases and\n  attempt to do so causes warnings to be emitted, OTOH in many cases it is\n  still OK to assume that all instances of the class has the same offsets\n  for the same members).\n\n  This is temporary solution which should be removed once File_parser class\n  and related routines are refactored.\n*/\n\n#define my_offsetof(TYPE, MEMBER) PTR_BYTE_DIFF(&((TYPE *)0x10)->MEMBER, 0x10)\n\n#define NullS\t\t(char *) 0\n\n#ifdef STDCALL\n#undef STDCALL\n#endif\n\n#ifdef _WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\n\n#ifndef HAVE_INT8\ntypedef signed char int8;       /* Signed integer >= 8  bits */\n#endif\n#ifndef HAVE_UINT8\ntypedef unsigned char uint8;    /* Unsigned integer >= 8  bits */\n#endif\n#ifndef HAVE_INT16\ntypedef short int16;\n#endif\n#ifndef HAVE_UINT16\ntypedef unsigned short uint16;\n#endif\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT32\ntypedef int int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned int uint32;\n#endif\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT32\ntypedef long int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned long uint32;\n#endif\n#else\n#error Neither int or long is of 4 bytes width\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t\t  /* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n/* \n  Using [unsigned] long long is preferable as [u]longlong because we use \n  [unsigned] long long unconditionally in many places, \n  for example in constants with [U]LL suffix.\n*/\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int\tlonglong;\n#else\ntypedef unsigned long\tulonglong;\t  /* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#endif\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#if defined(NO_CLIENT_LONG_LONG)\ntypedef unsigned long my_ulonglong;\n#elif defined (__WIN__)\ntypedef unsigned __int64 my_ulonglong;\n#else\ntypedef unsigned long long my_ulonglong;\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef unsigned int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef unsigned long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef unsigned long long intptr;\n#else\n#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)\n#endif\n\n#define MY_ERRPTR ((void*)(intptr)1)\n\n#if defined(_WIN32)\ntypedef unsigned long long my_off_t;\ntypedef unsigned long long os_off_t;\n#else\ntypedef off_t os_off_t;\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#endif /*_WIN32*/\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n\n/*\n  TODO Convert these to use Bitmap class.\n */\ntypedef ulonglong table_map;          /* Used for table bits in join */\ntypedef ulong nesting_map;  /* Used for flags of nesting constructs */\n\n/* often used type names - opaque declarations */\ntypedef const struct charset_info_st CHARSET_INFO;\ntypedef struct st_mysql_lex_string LEX_STRING;\n\n#if defined(__WIN__)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR\n#define SOCKET_EAGAIN\tWSAEINPROGRESS\n#define SOCKET_ETIMEDOUT WSAETIMEDOUT\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#define SOCKET_EADDRINUSE WSAEADDRINUSE\n#define SOCKET_ECONNRESET WSAECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_EADDRINUSE EADDRINUSE\n#define SOCKET_ETIMEDOUT ETIMEDOUT\n#define SOCKET_ECONNRESET ECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\n#include <mysql/plugin.h>  /* my_bool */\n\ntypedef ulong\t\tmyf;\t/* Type of MyFlags in my_funcs */\n\n#define MYF(v)\t\t(myf) (v)\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n#include <my_dbug.h>\n\n/* Some helper macros */\n#define YESNO(X) ((X) ? \"yes\" : \"no\")\n\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t10000\t/* How often we want info on screen */\n\n#include <my_byteorder.h>\n\n#ifdef HAVE_CHARSET_utf8\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8\"\n#else\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME\n#endif\n\n#if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)\n#define NO_EMBEDDED_ACCESS_CHECKS\n#endif\n\n#ifdef _WIN32\n#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define RTLD_DEFAULT GetModuleHandle(NULL)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\nstatic inline char *dlerror(void)\n{\n  static char win_errormsg[2048];\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n    0, GetLastError(), 0, win_errormsg, 2048, NULL);\n  return win_errormsg;\n}\n#define HAVE_DLOPEN 1\n#define HAVE_DLERROR 1\n#endif\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#ifdef HAVE_DLOPEN\n#ifndef HAVE_DLERROR\n#define dlerror() \"\"\n#endif\n#else\n#define dlerror() \"No support for dynamic loading (static build?)\"\n#define dlopen(A,B) 0\n#define dlsym(A,B) 0\n#define dlclose(A) 0\n#endif\n\n/*\n *  Include standard definitions of operator new and delete.\n */\n#ifdef __cplusplus\n#include <new>\n#endif\n\n/* Length of decimal number represented by INT32. */\n#define MY_INT32_NUM_DECIMAL_DIGITS 11\n\n/* Length of decimal number represented by INT64. */\n#define MY_INT64_NUM_DECIMAL_DIGITS 21\n\n#ifdef __cplusplus\n#include <limits> /* should be included before min/max macros */\n#endif\n\n/* Define some useful general macros (should be done after all headers). */\n#define MY_MAX(a, b)\t((a) > (b) ? (a) : (b))\n#define MY_MIN(a, b)\t((a) < (b) ? (a) : (b))\n\n#define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)\n\n/*\n  Only Linux is known to need an explicit sync of the directory to make sure a\n  file creation/deletion/renaming in(from,to) this directory durable.\n*/\n#ifdef TARGET_OS_LINUX\n#define NEED_EXPLICIT_SYNC_DIR 1\n#else\n/*\n  On linux default rwlock scheduling policy is good enough for\n  waiting_threads.c, on other systems use our special implementation\n  (which is slower).\n\n  QQ perhaps this should be tested in configure ? how ?\n*/\n#define WT_RWLOCKS_USE_MUTEXES 1\n#endif\n\n#if !defined(__cplusplus) && !defined(bool)\n#define bool In_C_you_should_use_my_bool_instead()\n#endif\n\n/* Provide __func__ macro definition for platforms that miss it. */\n#if !defined (__func__)\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"<unknown>\"\n#  endif\n#elif defined(_MSC_VER)\n#  if _MSC_VER < 1300\n#    define __func__ \"<unknown>\"\n#  else\n#    define __func__ __FUNCTION__\n#  endif\n#elif defined(__BORLANDC__)\n#  define __func__ __FUNC__\n#else\n#  define __func__ \"<unknown>\"\n#endif\n#endif /* !defined(__func__) */\n\n#ifndef HAVE_RINT\n/**\n   All integers up to this number can be represented exactly as double precision\n   values (DBL_MANT_DIG == 53 for IEEE 754 hardware).\n*/\n#define MAX_EXACT_INTEGER ((1LL << DBL_MANT_DIG) - 1)\n\n/**\n   rint(3) implementation for platforms that do not have it.\n   Always rounds to the nearest integer with ties being rounded to the nearest\n   even integer to mimic glibc's rint() behavior in the \"round-to-nearest\"\n   FPU mode. Hardware-specific optimizations are possible (frndint on x86).\n   Unlike this implementation, hardware will also honor the FPU rounding mode.\n*/\n\nstatic inline double rint(double x)\n{\n  double f, i;\n  f = modf(x, &i);\n  /*\n    All doubles with absolute values > MAX_EXACT_INTEGER are even anyway,\n    no need to check it.\n  */\n  if (x > 0.0)\n    i += (double) ((f > 0.5) || (f == 0.5 &&\n                                 i <= (double) MAX_EXACT_INTEGER &&\n                                 (longlong) i % 2));\n  else\n    i -= (double) ((f < -0.5) || (f == -0.5 &&\n                                  i >= (double) -MAX_EXACT_INTEGER &&\n                                  (longlong) i % 2));\n  return i;\n}\n#endif /* HAVE_RINT */\n\n/* \n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#ifndef MYSQL_PLUGIN_IMPORT\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n#endif\n\n/* Defines that are unique to the embedded version of MySQL */\n\n#ifdef EMBEDDED_LIBRARY\n\n/* Things we don't need in the embedded version of MySQL */\n/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */\n\n#undef HAVE_SMEM\t\t\t\t/* No shared memory */\n\n#else\n#define HAVE_REPLICATION\n#define HAVE_EXTERNAL_CLIENT\n#endif /* EMBEDDED_LIBRARY */\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n/*\n  Provide defaults for the CPU cache line size, if it has not been detected by\n  CMake using getconf\n*/\n#if !defined(CPU_LEVEL1_DCACHE_LINESIZE) || CPU_LEVEL1_DCACHE_LINESIZE == 0\n  #if CPU_LEVEL1_DCACHE_LINESIZE == 0\n    #undef CPU_LEVEL1_DCACHE_LINESIZE\n  #endif\n\n  #if defined(__s390__)\n    #define CPU_LEVEL1_DCACHE_LINESIZE 256\n  #elif defined(__powerpc__) || defined(__aarch64__)\n    #define CPU_LEVEL1_DCACHE_LINESIZE 128\n  #else\n    #define CPU_LEVEL1_DCACHE_LINESIZE 64\n  #endif\n#endif\n\n#define FLOATING_POINT_DECIMALS 31\n\n/* Keep client compatible with earlier versions */\n#ifdef MYSQL_SERVER\n#define NOT_FIXED_DEC           DECIMAL_NOT_SPECIFIED\n#else\n#define NOT_FIXED_DEC           FLOATING_POINT_DECIMALS\n#endif\n\n#endif /* my_global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/plugin/auth_dialog/dialog.c": "/* Copyright (C) 2010 Sergei Golubchik and Monty Program Ab\n   Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.\n\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as\n    published by the Free Software Foundation; version 2 of the\n    License.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA */\n\n/**\n  @file\n\n  dialog client authentication plugin with examples\n\n  dialog is a general purpose client authentication plugin, it simply\n  asks the user the question, as provided by the server and reports\n  the answer back to the server. No encryption is involved,\n  the answers are sent in clear text.\n*/\n#define _GNU_SOURCE 1 /* for RTLD_DEFAULT */\n\n#include <my_global.h>\n#include <mysql/client_plugin.h>\n#include <mysql.h>\n#include <string.h>\n\n#if defined (_WIN32)\n# define RTLD_DEFAULT GetModuleHandle(NULL)\n#endif\n\n/*\n  This plugin performs a dialog with the user, asking questions and\n  reading answers. Depending on the client it may be desirable to do it\n  using GUI, or console, with or without curses, or read answers\n  from a smartcard, for example.\n\n  To support all this variety, the dialog plugin has a callback function\n  \"authentication_dialog_ask\". If the client has a function of this name\n  dialog plugin will use it for communication with the user. Otherwise\n  a default implementation will be used.\n*/\nstatic mysql_authentication_dialog_ask_t ask;\n\nstatic char *builtin_ask(MYSQL *mysql __attribute__((unused)),\n                         int type __attribute__((unused)),\n                         const char *prompt,\n                         char *buf, int buf_len)\n{\n  fputs(prompt, stdout);\n  fputc(' ', stdout);\n\n  if (type == 2) /* password */\n  {\n    get_tty_password_buff(\"\", buf, buf_len);\n    buf[buf_len-1]= 0;\n  }\n  else\n  {\n    if (!fgets(buf, buf_len-1, stdin))\n      buf[0]= 0;\n    else\n    {\n      int len= strlen(buf);\n      if (len && buf[len-1] == '\\n')\n        buf[len-1]= 0;\n    }\n  }\n\n  return buf;\n}\n\n/**\n  The main function of the dialog plugin.\n\n  Read the prompt, ask the question, send the reply, repeat until\n  the server is satisfied.\n\n  @note\n   1. this plugin shows how a client authentication plugin\n      may read a MySQL protocol OK packet internally - which is important\n      where a number of packets is not known in advance.\n   2. the first byte of the prompt is special. it is not\n      shown to the user, but signals whether it is the last question\n      (prompt[0] & 1 == 1) or not last (prompt[0] & 1 == 0),\n      and whether the input is a password (not echoed).\n   3. the prompt is expected to be sent zero-terminated\n*/\nstatic int perform_dialog(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)\n{\n  unsigned char *pkt, cmd= 0;\n  int pkt_len, res;\n  char reply_buf[1024], *reply;\n  int first = 1;\n\n  do\n  {\n    /* read the prompt */\n    pkt_len= vio->read_packet(vio, &pkt);\n    if (pkt_len < 0)\n      return CR_ERROR;\n\n    if (pkt == 0 && first)\n    {\n      /*\n        in mysql_change_user() the client sends the first packet, so\n        the first vio->read_packet() does nothing (pkt == 0).\n\n        We send the \"password\", assuming the client knows what its doing.\n        (in other words, the dialog plugin should be only set as a default\n        authentication plugin on the client if the first question\n        asks for a password - which will be sent in clear text, by the way)\n      */\n      reply= mysql->passwd;\n    }\n    else\n    {\n      cmd= *pkt++;\n\n      /* is it MySQL protocol packet ? */\n      if (cmd == 0 || cmd == 254)\n        return CR_OK_HANDSHAKE_COMPLETE; /* yes. we're done */\n\n      /*\n        asking for a password in the first packet mean mysql->password, if it's set\n        otherwise we ask the user and read the reply\n      */\n      if ((cmd >> 1) == 2 && first && mysql->passwd[0])\n        reply= mysql->passwd;\n      else\n        reply= ask(mysql, cmd >> 1, (const char *) pkt, \n\t\t\t\t   reply_buf, sizeof(reply_buf));\n      if (!reply)\n        return CR_ERROR;\n    }\n    /* send the reply to the server */\n    res= vio->write_packet(vio, (const unsigned char *) reply, \n\t\t\t\t\t\t   strlen(reply)+1);\n\n    if (reply != mysql->passwd && reply != reply_buf)\n      free(reply);\n\n    if (res)\n      return CR_ERROR;\n\n    first= 0;\n\n    /* repeat unless it was the last question */\n  } while ((cmd & 1) != 1);\n\n  /* the job of reading the ok/error packet is left to the server */\n  return CR_OK;\n}\n\n/**\n  initialization function of the dialog plugin\n\n  Pick up the client's authentication_dialog_ask() function, if exists,\n  or fall back to the default implementation.\n*/\n\nstatic int init_dialog(char *unused1   __attribute__((unused)), \n                       size_t unused2  __attribute__((unused)), \n                       int unused3     __attribute__((unused)), \n                       va_list unused4 __attribute__((unused)))\n{\n  void *sym= dlsym(RTLD_DEFAULT, \"mysql_authentication_dialog_ask\");\n  ask= sym ? (mysql_authentication_dialog_ask_t) sym : builtin_ask;\n  return 0;\n}\n\nmysql_declare_client_plugin(AUTHENTICATION)\n  \"dialog\",\n  \"Sergei Golubchik\",\n  \"Dialog Client Authentication Plugin\",\n  {0,1,0},\n  \"GPL\",\n  NULL,\n  init_dialog,\n  NULL,\n  NULL,\n  perform_dialog\nmysql_end_client_plugin;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/plugin/server_audit/server_audit.c": "/* Copyright (C) 2013, 2015, Alexey Botchkov and SkySQL Ab\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301 USA */\n\n\n#define PLUGIN_VERSION 0x104\n#define PLUGIN_STR_VERSION \"1.4.1\"\n\n#define _my_thread_var loc_thread_var\n\n#include <my_config.h>\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <fcntl.h>\n\n#ifndef _WIN32\n#include <syslog.h>\n#else\n#define syslog(PRIORITY, FORMAT, INFO, MESSAGE_LEN, MESSAGE) do {}while(0)\nstatic void closelog() {}\n#define openlog(IDENT, LOG_NOWAIT, LOG_USER)  do {}while(0)\n\n/* priorities */\n#define LOG_EMERG       0       /* system is unusable */\n#define LOG_ALERT       1       /* action must be taken immediately */\n#define LOG_CRIT        2       /* critical conditions */\n#define LOG_ERR         3       /* error conditions */\n#define LOG_WARNING     4       /* warning conditions */\n#define LOG_NOTICE      5       /* normal but significant condition */\n#define LOG_INFO        6       /* informational */\n#define LOG_DEBUG       7       /* debug-level messages */\n\n#define LOG_MAKEPRI(fac, pri)   (((fac) << 3) | (pri))\n\n/* facility codes */\n#define LOG_KERN        (0<<3)  /* kernel messages */\n#define LOG_USER        (1<<3)  /* random user-level messages */\n#define LOG_MAIL        (2<<3)  /* mail system */\n#define LOG_DAEMON      (3<<3)  /* system daemons */\n#define LOG_AUTH        (4<<3)  /* security/authorization messages */\n#define LOG_SYSLOG      (5<<3)  /* messages generated internally by syslogd */\n#define LOG_LPR         (6<<3)  /* line printer subsystem */\n#define LOG_NEWS        (7<<3)  /* network news subsystem */\n#define LOG_UUCP        (8<<3)  /* UUCP subsystem */\n#define LOG_CRON        (9<<3)  /* clock daemon */\n#define LOG_AUTHPRIV    (10<<3) /* security/authorization messages (private) */\n#define LOG_FTP         (11<<3) /* ftp daemon */\n#define LOG_LOCAL0      (16<<3) /* reserved for local use */\n#define LOG_LOCAL1      (17<<3) /* reserved for local use */\n#define LOG_LOCAL2      (18<<3) /* reserved for local use */\n#define LOG_LOCAL3      (19<<3) /* reserved for local use */\n#define LOG_LOCAL4      (20<<3) /* reserved for local use */\n#define LOG_LOCAL5      (21<<3) /* reserved for local use */\n#define LOG_LOCAL6      (22<<3) /* reserved for local use */\n#define LOG_LOCAL7      (23<<3) /* reserved for local use */\n\n#endif /*!_WIN32*/\n\n/*\n   Defines that can be used to reshape the pluging:\n   #define MARIADB_ONLY\n   #define USE_MARIA_PLUGIN_INTERFACE\n*/\n\n#if !defined(MYSQL_DYNAMIC_PLUGIN) && !defined(MARIADB_ONLY)\n#define MARIADB_ONLY\n#endif /*MYSQL_PLUGIN_DYNAMIC*/\n\n#ifndef MARIADB_ONLY\n#define MYSQL_SERVICE_LOGGER_INCLUDED\n#endif /*MARIADB_ONLY*/\n\n#include <my_base.h>\n//#include <my_dir.h>\n#include <typelib.h>\n#include <mysql/plugin.h>\n#include <mysql/plugin_audit.h>\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT NULL\n#endif\n\n#ifndef MARIADB_ONLY\n#undef MYSQL_SERVICE_LOGGER_INCLUDED\n#undef MYSQL_DYNAMIC_PLUGIN\n#define FLOGGER_NO_PSI\n\n/* How to access the pthread_mutex in mysql_mutex_t */\n#ifdef SAFE_MUTEX\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex.mutex\n#else\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex\n#endif\n\n#define flogger_mutex_init(A,B,C) do{}while(0)\n#define flogger_mutex_destroy(A) do{}while(0)\n#define flogger_mutex_lock(A) do{}while(0)\n#define flogger_mutex_unlock(A) do{}while(0)\n\nstatic char **int_mysql_data_home;\nstatic char *default_home= (char *)\".\";\n#define mysql_data_home (*int_mysql_data_home)\n\n#define FLOGGER_SKIP_INCLUDES\n#define my_open(A, B, C) loc_open(A, B)\n#define my_close(A, B) loc_close(A)\n#define my_rename(A, B, C) loc_rename(A, B)\n#define my_tell(A, B) loc_tell(A)\n#define my_write(A, B, C, D) loc_write(A, B, C)\n#define my_malloc(A, B) malloc(A)\n#define my_free(A) free(A)\n#ifdef my_errno\n  #undef my_errno\n#endif\nstatic int loc_file_errno;\n#define my_errno loc_file_errno\n#ifdef my_vsnprintf\n  #undef my_vsnprintf\n#endif\n#define my_vsnprintf vsnprintf\n#define logger_open loc_logger_open\n#define logger_close loc_logger_close\n#define logger_write loc_logger_write\n#define logger_rotate loc_logger_rotate\n#define logger_init_mutexts loc_logger_init_mutexts\n\n\nstatic size_t loc_write(File Filedes, const uchar *Buffer, size_t Count)\n{\n  size_t writtenbytes;\n#ifdef _WIN32\n  writtenbytes= my_win_write(Filedes, Buffer, Count);\n#else\n  writtenbytes= write(Filedes, Buffer, Count);\n#endif\n  return writtenbytes;\n}\n\n\nstatic File loc_open(const char *FileName, int Flags)\n\t\t\t\t/* Path-name of file */\n\t\t\t\t/* Read | write .. */\n\t\t\t\t/* Special flags */\n{\n  File fd;\n#if defined(_WIN32)\n  fd= my_win_open(FileName, Flags);\n#else\n  fd = open(FileName, Flags, my_umask);\n#endif\n  my_errno= errno;\n  return fd;\n} \n\n\nstatic int loc_close(File fd)\n{\n  int err;\n#ifndef _WIN32\n  do\n  {\n    err= close(fd);\n  } while (err == -1 && errno == EINTR);\n#else\n  err= my_win_close(fd);\n#endif\n  my_errno=errno;\n  return err;\n}\n\n\nstatic int loc_rename(const char *from, const char *to)\n{\n  int error = 0;\n\n#if defined(__WIN__)\n  if (!MoveFileEx(from, to, MOVEFILE_COPY_ALLOWED |\n                            MOVEFILE_REPLACE_EXISTING))\n  {\n    my_osmaperr(GetLastError());\n#elif defined(HAVE_RENAME)\n  if (rename(from,to))\n  {\n#else\n  if (link(from, to) || unlink(from))\n  {\n#endif\n    my_errno=errno;\n    error = -1;\n  }\n  return error;\n}\n\n\nstatic my_off_t loc_seek(File fd, my_off_t pos, int whence)\n{\n  os_off_t newpos= -1;\n#ifdef _WIN32\n  newpos= my_win_lseek(fd, pos, whence);\n#else\n  newpos= lseek(fd, pos, whence);\n#endif\n  if (newpos == (os_off_t) -1)\n  {\n    my_errno= errno;\n    return MY_FILEPOS_ERROR;\n  }\n\n  return (my_off_t) newpos;\n}\n\n\nstatic my_off_t loc_tell(File fd)\n{\n  os_off_t pos;\n#if defined (HAVE_TELL) && !defined (_WIN32)\n  pos= tell(fd);\n#else\n  pos= loc_seek(fd, 0L, MY_SEEK_CUR);\n#endif\n  if (pos == (os_off_t) -1)\n  {\n    my_errno= errno;\n  }\n  return (my_off_t) pos;\n}\n\n#ifdef HAVE_PSI_INTERFACE\n#undef HAVE_PSI_INTERFACE\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#define HAVE_PSI_INTERFACE\n#else\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#endif\n#endif /*!MARIADB_ONLY*/\n\n#undef flogger_mutex_init\n#undef flogger_mutex_destroy\n#undef flogger_mutex_lock\n#undef flogger_mutex_unlock\n\n#define flogger_mutex_init(A,B,C) pthread_mutex_init(mysql_mutex_real_mutex(B), C)\n#define flogger_mutex_destroy(A) pthread_mutex_destroy(mysql_mutex_real_mutex(A))\n#define flogger_mutex_lock(A) pthread_mutex_lock(mysql_mutex_real_mutex(A))\n#define flogger_mutex_unlock(A) pthread_mutex_unlock(mysql_mutex_real_mutex(A))\n\n#ifndef DBUG_OFF\n#define PLUGIN_DEBUG_VERSION \"-debug\"\n#else\n#define PLUGIN_DEBUG_VERSION \"\"\n#endif /*DBUG_OFF*/\n/*\n Disable __attribute__() on non-gcc compilers.\n*/\n#if !defined(__attribute__) && !defined(__GNUC__)\n#define __attribute__(A)\n#endif\n\n#ifdef _WIN32\n#define localtime_r(a, b) localtime_s(b, a)\n#endif /*WIN32*/\n\n\nextern char server_version[];\nstatic const char *serv_ver= NULL;\nstatic int started_mysql= 0;\nstatic int mysql_57_started= 0;\nstatic int debug_server_started= 0;\nstatic int use_event_data_for_disconnect= 0;\nstatic int started_mariadb= 0;\nstatic int maria_55_started= 0;\nstatic int maria_above_5= 0;\nstatic char *incl_users, *excl_users,\n            *file_path, *syslog_info;\nstatic char path_buffer[FN_REFLEN];\nstatic unsigned int mode, mode_readonly= 0;\nstatic ulong output_type;\nstatic ulong syslog_facility, syslog_priority;\n\nstatic ulonglong events; /* mask for events to log */\nstatic unsigned long long file_rotate_size;\nstatic unsigned int rotations;\nstatic my_bool rotate= TRUE;\nstatic char logging;\nstatic int internal_stop_logging= 0;\nstatic char incl_user_buffer[1024];\nstatic char excl_user_buffer[1024];\nstatic char *big_buffer= NULL;\nstatic size_t big_buffer_alloced= 0;\nstatic unsigned int query_log_limit= 0;\n\nstatic char servhost[256];\nstatic size_t servhost_len;\nstatic char *syslog_ident;\nstatic char syslog_ident_buffer[128]= \"mysql-server_auditing\";\n\nstruct connection_info\n{\n  int header;\n  unsigned long thread_id;\n  unsigned long long query_id;\n  char db[256];\n  int db_length;\n  char user[64];\n  int user_length;\n  char host[64];\n  int host_length;\n  char ip[64];\n  int ip_length;\n  const char *query;\n  int query_length;\n  char query_buffer[1024];\n  time_t query_time;\n  int log_always;\n};\n\n#define DEFAULT_FILENAME_LEN 16\nstatic char default_file_name[DEFAULT_FILENAME_LEN+1]= \"server_audit.log\";\n\nstatic void update_file_path(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                             void *var_ptr, const void *save);\nstatic void update_file_rotate_size(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                    void *var_ptr, const void *save);\nstatic void update_file_rotations(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                  void *var_ptr, const void *save);\nstatic void update_incl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic void update_excl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic void update_output_type(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                               void *var_ptr, const void *save);\nstatic void update_syslog_facility(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_syslog_priority(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_mode(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                        void *var_ptr, const void *save);\nstatic void update_logging(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                           void *var_ptr, const void *save);\nstatic void update_syslog_ident(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                void *var_ptr, const void *save);\nstatic void rotate_log(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                       void *var_ptr, const void *save);\n\nstatic MYSQL_SYSVAR_STR(incl_users, incl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to monitor.\",\n       NULL, update_incl_users, NULL);\nstatic MYSQL_SYSVAR_STR(excl_users, excl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to exclude from auditing.\",\n       NULL, update_excl_users, NULL);\n/* bits in the event filter. */\n#define EVENT_CONNECT 1\n#define EVENT_QUERY_ALL 2\n#define EVENT_QUERY 58\n#define EVENT_TABLE 4\n#define EVENT_QUERY_DDL 8\n#define EVENT_QUERY_DML 16\n#define EVENT_QUERY_DCL 32\n\nstatic const char *event_names[]=\n{\n  \"CONNECT\", \"QUERY\", \"TABLE\", \"QUERY_DDL\", \"QUERY_DML\", \"QUERY_DCL\",\n  NULL\n};\nstatic TYPELIB events_typelib=\n{\n  array_elements(event_names) - 1, \"\", event_names, NULL\n};\nstatic MYSQL_SYSVAR_SET(events, events, PLUGIN_VAR_RQCMDARG,\n       \"Specifies the set of events to monitor. Can be CONNECT, QUERY, TABLE,\"\n           \" QUERY_DDL, QUERY_DML, QUERY_DCL.\",\n       NULL, NULL, 0, &events_typelib);\n#define OUTPUT_SYSLOG 0\n#define OUTPUT_FILE 1\n#define OUTPUT_NO 0xFFFF\nstatic const char *output_type_names[]= { \"syslog\", \"file\", 0 };\nstatic TYPELIB output_typelib=\n{\n    array_elements(output_type_names) - 1, \"output_typelib\",\n    output_type_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(output_type, output_type, PLUGIN_VAR_RQCMDARG,\n       \"Desired output type. Possible values - 'syslog', 'file'\"\n       \" or 'null' as no output.\", 0, update_output_type, OUTPUT_FILE,\n       &output_typelib);\nstatic MYSQL_SYSVAR_STR(file_path, file_path, PLUGIN_VAR_RQCMDARG,\n       \"Path to the log file.\", NULL, update_file_path, default_file_name);\nstatic MYSQL_SYSVAR_ULONGLONG(file_rotate_size, file_rotate_size,\n       PLUGIN_VAR_RQCMDARG, \"Maximum size of the log to start the rotation.\",\n       NULL, update_file_rotate_size,\n       1000000, 100, ((long long) 0x7FFFFFFFFFFFFFFFLL), 1);\nstatic MYSQL_SYSVAR_UINT(file_rotations, rotations,\n       PLUGIN_VAR_RQCMDARG, \"Number of rotations before log is removed.\",\n       NULL, update_file_rotations, 9, 0, 999, 1);\nstatic MYSQL_SYSVAR_BOOL(file_rotate_now, rotate, PLUGIN_VAR_OPCMDARG,\n       \"Force log rotation now.\", NULL, rotate_log, FALSE);\nstatic MYSQL_SYSVAR_BOOL(logging, logging,\n       PLUGIN_VAR_OPCMDARG, \"Turn on/off the logging.\", NULL,\n       update_logging, 0);\nstatic MYSQL_SYSVAR_UINT(mode, mode,\n       PLUGIN_VAR_OPCMDARG, \"Auditing mode.\", NULL, update_mode, 0, 0, 1, 1);\nstatic MYSQL_SYSVAR_STR(syslog_ident, syslog_ident, PLUGIN_VAR_RQCMDARG,\n       \"The SYSLOG identifier - the beginning of each SYSLOG record.\",\n       NULL, update_syslog_ident, syslog_ident_buffer);\nstatic MYSQL_SYSVAR_STR(syslog_info, syslog_info,\n       PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n       \"The <info> string to be added to the SYSLOG record.\", NULL, NULL, \"\");\nstatic MYSQL_SYSVAR_UINT(query_log_limit, query_log_limit,\n       PLUGIN_VAR_OPCMDARG, \"Limit on the length of the query string in a record.\",\n       NULL, NULL, 1024, 0, 0x7FFFFFFF, 1);\n\nchar locinfo_ini_value[sizeof(struct connection_info)+4];\n\nstatic MYSQL_THDVAR_STR(loc_info,\n                        PLUGIN_VAR_NOSYSVAR | PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_MEMALLOC,\n                        \"Internal info\", NULL, NULL, locinfo_ini_value);\n\nstatic const char *syslog_facility_names[]=\n{\n  \"LOG_USER\", \"LOG_MAIL\", \"LOG_DAEMON\", \"LOG_AUTH\",\n  \"LOG_SYSLOG\", \"LOG_LPR\", \"LOG_NEWS\", \"LOG_UUCP\",\n  \"LOG_CRON\",\n#ifdef LOG_AUTHPRIV\n \"LOG_AUTHPRIV\",\n#endif\n#ifdef LOG_FTP\n \"LOG_FTP\",\n#endif\n  \"LOG_LOCAL0\", \"LOG_LOCAL1\", \"LOG_LOCAL2\", \"LOG_LOCAL3\",\n  \"LOG_LOCAL4\", \"LOG_LOCAL5\", \"LOG_LOCAL6\", \"LOG_LOCAL7\",\n  0\n};\nstatic unsigned int syslog_facility_codes[]=\n{\n  LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH,\n  LOG_SYSLOG, LOG_LPR, LOG_NEWS, LOG_UUCP,\n  LOG_CRON,\n#ifdef LOG_AUTHPRIV\n LOG_AUTHPRIV,\n#endif\n#ifdef LOG_FTP\n  LOG_FTP,\n#endif\n  LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3,\n  LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7,\n};\nstatic TYPELIB syslog_facility_typelib=\n{\n    array_elements(syslog_facility_names) - 1, \"syslog_facility_typelib\",\n    syslog_facility_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_facility, syslog_facility, PLUGIN_VAR_RQCMDARG,\n       \"The 'facility' parameter of the SYSLOG record.\"\n       \" The default is LOG_USER.\", 0, update_syslog_facility, 0/*LOG_USER*/,\n       &syslog_facility_typelib);\n\nstatic const char *syslog_priority_names[]=\n{\n  \"LOG_EMERG\", \"LOG_ALERT\", \"LOG_CRIT\", \"LOG_ERR\",\n  \"LOG_WARNING\", \"LOG_NOTICE\", \"LOG_INFO\", \"LOG_DEBUG\",\n  0\n};\n\nstatic unsigned int syslog_priority_codes[]=\n{\n  LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,\n  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG,\n};\n\nstatic TYPELIB syslog_priority_typelib=\n{\n    array_elements(syslog_priority_names) - 1, \"syslog_priority_typelib\",\n    syslog_priority_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_priority, syslog_priority, PLUGIN_VAR_RQCMDARG,\n       \"The 'priority' parameter of the SYSLOG record.\"\n       \" The default is LOG_INFO.\", 0, update_syslog_priority, 6/*LOG_INFO*/,\n       &syslog_priority_typelib);\n\n\nstatic struct st_mysql_sys_var* vars[] = {\n    MYSQL_SYSVAR(incl_users),\n    MYSQL_SYSVAR(excl_users),\n    MYSQL_SYSVAR(events),\n    MYSQL_SYSVAR(output_type),\n    MYSQL_SYSVAR(file_path),\n    MYSQL_SYSVAR(file_rotate_size),\n    MYSQL_SYSVAR(file_rotations),\n    MYSQL_SYSVAR(file_rotate_now),\n    MYSQL_SYSVAR(logging),\n    MYSQL_SYSVAR(mode),\n    MYSQL_SYSVAR(syslog_info),\n    MYSQL_SYSVAR(syslog_ident),\n    MYSQL_SYSVAR(syslog_facility),\n    MYSQL_SYSVAR(syslog_priority),\n    MYSQL_SYSVAR(query_log_limit),\n    MYSQL_SYSVAR(loc_info),\n    NULL\n};\n\n\n/* Status variables for SHOW STATUS */\nstatic int is_active= 0;\nstatic long log_write_failures= 0;\nstatic char current_log_buf[FN_REFLEN]= \"\";\nstatic char last_error_buf[512]= \"\";\n\nextern void *mysql_v4_descriptor;\n\nstatic struct st_mysql_show_var audit_status[]=\n{\n  {\"server_audit_active\", (char *)&is_active, SHOW_BOOL},\n  {\"server_audit_current_log\", current_log_buf, SHOW_CHAR},\n  {\"server_audit_writes_failed\", (char *)&log_write_failures, SHOW_LONG},\n  {\"server_audit_last_error\", last_error_buf, SHOW_CHAR},\n  {0,0,0}\n};\n\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n/* These belong to the service initialization */\nstatic PSI_mutex_key key_LOCK_operations;\nstatic PSI_mutex_key key_LOCK_bigbuffer;\nstatic PSI_mutex_info mutex_key_list[]=\n{\n  { &key_LOCK_operations, \"SERVER_AUDIT_plugin::lock_operations\",\n    PSI_FLAG_GLOBAL},\n  { &key_LOCK_bigbuffer, \"SERVER_AUDIT_plugin::lock_bigbuffer\",\n    PSI_FLAG_GLOBAL}\n};\n#endif\nstatic mysql_mutex_t lock_operations;\nstatic mysql_mutex_t lock_bigbuffer;\n\n/* The Percona server and partly MySQL don't support         */\n/* launching client errors in the 'update_variable' methods. */\n/* So the client errors just disabled for them.              */\n/* The possible solution is to implement the 'check_variable'*/\n/* methods there properly, but at the moment i'm not sure it */\n/* worths doing.                                             */\n#define CLIENT_ERROR if (!started_mysql) my_printf_error\n\nstatic uchar *getkey_user(const char *entry, size_t *length,\n                          my_bool nu __attribute__((unused)) )\n{\n  const char *e= entry;\n  while (*e && *e != ' ' && *e != ',')\n    ++e;\n  *length= e - entry;\n  return (uchar *) entry;\n}\n\n\nstatic void blank_user(char *user)\n{\n  for (; *user && *user != ','; user++)\n    *user= ' ';\n}\n\n\nstatic void remove_user(char *user)\n{\n  char *start_user= user;\n  while (*user != ',')\n  {\n    if (*user == 0)\n    {\n      *start_user= 0;\n      return;\n    }\n    user++;\n  }\n  user++;\n  while (*user == ' ')\n    user++;\n\n  do {\n    *(start_user++)= *user;\n  } while (*(user++));\n}\n\n\nstatic void remove_blanks(char *user)\n{\n  char *user_orig= user;\n  char *user_to= user;\n  char *start_tok;\n  int blank_name;\n\n  while (*user != 0)\n  {\n    start_tok= user;\n    blank_name= 1;\n    while (*user !=0 && *user != ',')\n    {\n      if (*user != ' ')\n        blank_name= 0;\n      user++;\n    }\n    if (!blank_name)\n    {\n      while (start_tok <= user)\n        *(user_to++)= *(start_tok++);\n    }\n    if (*user == ',')\n      user++;\n  }\n  if (user_to > user_orig && user_to[-1] == ',')\n    user_to--;\n  *user_to= 0;\n}\n\n\nstruct user_name\n{\n  int name_len;\n  char *name;\n};\n\n\nstruct user_coll\n{\n  int n_users;\n  struct user_name *users;\n  int n_alloced;\n};\n\n\nstatic void coll_init(struct user_coll *c)\n{\n  c->n_users= 0;\n  c->users= 0;\n  c->n_alloced= 0;\n}\n\n\nstatic void coll_free(struct user_coll *c)\n{\n  if (c->users)\n  {\n    free(c->users);\n    coll_init(c);\n  }\n}\n\n\nstatic int cmp_users(const void *ia, const void *ib)\n{\n  const struct user_name *a= (const struct user_name *) ia;\n  const struct user_name *b= (const struct user_name *) ib;\n  int dl= a->name_len - b->name_len;\n  if (dl != 0)\n    return dl;\n\n  return strncmp(a->name, b->name, a->name_len);\n}\n\n\nstatic char *coll_search(struct user_coll *c, const char *n, int len)\n{\n  struct user_name un;\n  struct user_name *found;\n  un.name_len= len;\n  un.name= (char *) n;\n  found= (struct user_name*)  bsearch(&un, c->users, c->n_users,\n                                      sizeof(c->users[0]), cmp_users);\n  return found ? found->name : 0;\n}\n\n\nstatic int coll_insert(struct user_coll *c, char *n, int len)\n{\n  if (c->n_users >= c->n_alloced)\n  {\n    c->n_alloced+= 128;\n    if (c->users == NULL)\n      c->users= malloc(c->n_alloced * sizeof(c->users[0]));\n    else\n      c->users= realloc(c->users, c->n_alloced * sizeof(c->users[0]));\n\n    if (c->users == NULL)\n      return 1;\n  }\n  c->users[c->n_users].name= n;\n  c->users[c->n_users].name_len= len;\n  c->n_users++;\n  return 0;\n}\n\n\nstatic void coll_sort(struct user_coll *c)\n{\n  qsort(c->users, c->n_users, sizeof(c->users[0]), cmp_users);\n}\n\n\nstatic int user_coll_fill(struct user_coll *c, char *users,\n                          struct user_coll *cmp_c, int take_over_cmp)\n{\n  char *orig_users= users;\n  char *cmp_user= 0;\n  size_t cmp_length;\n  int refill_cmp_coll= 0;\n\n  c->n_users= 0;\n\n  while (*users)\n  {\n    while (*users == ' ')\n      users++;\n    if (!*users)\n      return 0;\n\n    (void) getkey_user(users, &cmp_length, FALSE);\n    if (cmp_c)\n    {\n      cmp_user= coll_search(cmp_c, users, cmp_length);\n\n      if (cmp_user && take_over_cmp)\n      {\n        internal_stop_logging= 1;\n        CLIENT_ERROR(1, \"User '%.*s' was removed from the\"\n            \" server_audit_excl_users.\",\n            MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        internal_stop_logging= 0;\n        blank_user(cmp_user);\n        refill_cmp_coll= 1;\n      }\n      else if (cmp_user)\n      {\n        internal_stop_logging= 1;\n        CLIENT_ERROR(1, \"User '%.*s' is in the server_audit_incl_users, \"\n            \"so wasn't added.\", MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        internal_stop_logging= 0;\n        remove_user(users);\n        continue;\n      }\n    }\n    if (coll_insert(c, users, cmp_length))\n      return 1;\n    while (*users && *users != ',')\n      users++;\n    if (!*users)\n      break;\n    users++;\n  }\n\n  if (refill_cmp_coll)\n  {\n    remove_blanks(excl_users);\n    return user_coll_fill(cmp_c, excl_users, 0, 0);\n  }\n\n  if (users > orig_users && users[-1] == ',')\n    users[-1]= 0;\n\n  coll_sort(c);\n\n  return 0;\n}\n\n\nenum sa_keywords\n{\n  SQLCOM_NOTHING=0,\n  SQLCOM_DDL,\n  SQLCOM_DML,\n  SQLCOM_GRANT,\n  SQLCOM_CREATE_USER,\n  SQLCOM_CHANGE_MASTER,\n  SQLCOM_CREATE_SERVER,\n  SQLCOM_SET_OPTION,\n  SQLCOM_ALTER_SERVER,\n  SQLCOM_TRUNCATE,\n  SQLCOM_QUERY_ADMIN,\n  SQLCOM_DCL,\n};\n\nstruct sa_keyword\n{\n  int length;\n  const char *wd;\n  struct sa_keyword *next;\n  enum sa_keywords type;\n};\n\n\nstruct sa_keyword xml_word=   {3, \"XML\", 0, SQLCOM_NOTHING};\nstruct sa_keyword user_word=   {4, \"USER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword data_word=   {4, \"DATA\", 0, SQLCOM_NOTHING};\nstruct sa_keyword server_word= {6, \"SERVER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword master_word= {6, \"MASTER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword password_word= {8, \"PASSWORD\", 0, SQLCOM_NOTHING};\nstruct sa_keyword function_word= {8, \"FUNCTION\", 0, SQLCOM_NOTHING};\nstruct sa_keyword statement_word= {9, \"STATEMENT\", 0, SQLCOM_NOTHING};\nstruct sa_keyword procedure_word= {9, \"PROCEDURE\", 0, SQLCOM_NOTHING};\n\n\nstruct sa_keyword keywords_to_skip[]=\n{\n  {3, \"SET\", &statement_word, SQLCOM_QUERY_ADMIN},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword not_ddl_keywords[]=\n{\n  {4, \"DROP\", &function_word, SQLCOM_QUERY_ADMIN},\n  {4, \"DROP\", &procedure_word, SQLCOM_QUERY_ADMIN},\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {6, \"CREATE\", &function_word, SQLCOM_QUERY_ADMIN},\n  {6, \"CREATE\", &procedure_word, SQLCOM_QUERY_ADMIN},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword ddl_keywords[]=\n{\n  {4, \"DROP\", 0, SQLCOM_DDL},\n  {5, \"ALTER\", 0, SQLCOM_DDL},\n  {6, \"CREATE\", 0, SQLCOM_DDL},\n  {6, \"RENAME\", 0, SQLCOM_DDL},\n  {8, \"TRUNCATE\", 0, SQLCOM_DDL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword dml_keywords[]=\n{\n  {2, \"DO\", 0, SQLCOM_DML},\n  {4, \"CALL\", 0, SQLCOM_DML},\n  {4, \"LOAD\", &data_word, SQLCOM_DML},\n  {4, \"LOAD\", &xml_word, SQLCOM_DML},\n  {6, \"DELETE\", 0, SQLCOM_DML},\n  {6, \"INSERT\", 0, SQLCOM_DML},\n  {6, \"SELECT\", 0, SQLCOM_DML},\n  {6, \"UPDATE\", 0, SQLCOM_DML},\n  {7, \"HANDLER\", 0, SQLCOM_DML},\n  {7, \"REPLACE\", 0, SQLCOM_DML},\n  {0, NULL, 0, SQLCOM_DML}\n};\n\n\nstruct sa_keyword dcl_keywords[]=\n{\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {5, \"GRANT\", 0, SQLCOM_DCL},\n  {6, \"REVOKE\", 0, SQLCOM_DCL},\n  {3, \"SET\", &password_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword passwd_keywords[]=\n{\n  {3, \"SET\", &password_word, SQLCOM_SET_OPTION},\n  {5, \"ALTER\", &server_word, SQLCOM_ALTER_SERVER},\n  {5, \"GRANT\", 0, SQLCOM_GRANT},\n  {6, \"CREATE\", &user_word, SQLCOM_CREATE_USER},\n  {6, \"CREATE\", &server_word, SQLCOM_CREATE_SERVER},\n  {6, \"CHANGE\", &master_word, SQLCOM_CHANGE_MASTER},\n  {0, NULL, 0, SQLCOM_NOTHING}\n};\n\n#define MAX_KEYWORD 9\n\n\nstatic void error_header()\n{\n  struct tm tm_time;\n  time_t curtime;\n\n  (void) time(&curtime);\n  (void) localtime_r(&curtime, &tm_time);\n\n  (void) fprintf(stderr,\"%02d%02d%02d %2d:%02d:%02d server_audit: \",\n    tm_time.tm_year % 100, tm_time.tm_mon + 1,\n    tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);\n}\n\n\nstatic LOGGER_HANDLE *logfile;\nstatic struct user_coll incl_user_coll, excl_user_coll;\nstatic unsigned long long query_counter= 1;\n\n\nstatic struct connection_info *get_loc_info(MYSQL_THD thd)\n{\n  return (struct connection_info *) THDVAR(thd, loc_info);\n}\n\n\nstatic int ci_needs_setup(const struct connection_info *ci)\n{\n  return ci->header != 0;\n}\n\n\nstatic void get_str_n(char *dest, int *dest_len, size_t dest_size,\n                      const char *src, size_t src_len)\n{\n  if (src_len >= dest_size)\n    src_len= dest_size - 1;\n\n  memcpy(dest, src, src_len);\n  dest[src_len]= 0;\n  *dest_len= src_len;\n}\n\n\nstatic int get_user_host(const char *uh_line, unsigned int uh_len,\n                         char *buffer, size_t buf_len,\n                         size_t *user_len, size_t *host_len, size_t *ip_len)\n{\n  const char *buf_end= buffer + buf_len - 1;\n  const char *buf_start;\n  const char *uh_end= uh_line + uh_len;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  if (uh_line == uh_end)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ']')\n  {\n    if (buffer == buf_end)\n      return 1;\n    *(buffer++)= *(uh_line++);\n  }\n  if (uh_line == uh_end)\n    return 1;\n  *user_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '@')\n    ++uh_line;\n  if (uh_line == uh_end || *(++uh_line) == 0)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ' ' && *uh_line != '[')\n  {\n    if (buffer == buf_end)\n      break;\n    *(buffer++)= *(uh_line++);\n  }\n  *host_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  buf_start= buffer;\n  if (*uh_line == '[')\n  {\n    ++uh_line;\n    while (uh_line < uh_end && *uh_line != ']')\n      *(buffer++)= *(uh_line++);\n  }\n  *ip_len= buffer - buf_start;\n  return 0;\n}\n\n#if defined(__WIN__) && !defined(S_ISDIR)\n#define S_ISDIR(x) ((x) & _S_IFDIR)\n#endif /*__WIN__ && !S_ISDIR*/\n\nstatic int start_logging()\n{\n  last_error_buf[0]= 0;\n  log_write_failures= 0;\n  if (output_type == OUTPUT_FILE)\n  {\n    char alt_path_buffer[FN_REFLEN+1+DEFAULT_FILENAME_LEN];\n    MY_STAT *f_stat;\n    const char *alt_fname= file_path;\n\n    while (*alt_fname == ' ')\n      alt_fname++;\n\n    if (*alt_fname == 0)\n    {\n      /* Empty string means the default file name. */\n      alt_fname= default_file_name;\n    }\n    else\n    {\n      /* See if the directory exists with the name of file_path.    */\n      /* Log file name should be [file_path]/server_audit.log then. */\n      if ((f_stat= my_stat(file_path, (MY_STAT *)alt_path_buffer, MYF(0))) &&\n          S_ISDIR(f_stat->st_mode))\n      {\n        size_t p_len= strlen(file_path);\n        memcpy(alt_path_buffer, file_path, p_len);\n        if (alt_path_buffer[p_len-1] != FN_LIBCHAR)\n        {\n          alt_path_buffer[p_len]= FN_LIBCHAR;\n          p_len++;\n        }\n        memcpy(alt_path_buffer+p_len, default_file_name, DEFAULT_FILENAME_LEN);\n        alt_path_buffer[p_len+DEFAULT_FILENAME_LEN]= 0;\n        alt_fname= alt_path_buffer;\n      }\n    }\n\n    logfile= logger_open(alt_fname, file_rotate_size, rotations);\n\n    if (logfile == NULL)\n    {\n      error_header();\n      fprintf(stderr, \"Could not create file '%s'.\\n\",\n              alt_fname);\n      logging= 0;\n      my_snprintf(last_error_buf, sizeof(last_error_buf),\n                  \"Could not create file '%s'.\", alt_fname);\n      is_active= 0;\n      CLIENT_ERROR(1, \"SERVER AUDIT plugin can't create file '%s'.\",\n          MYF(ME_JUST_WARNING), alt_fname);\n      return 1;\n    }\n    error_header();\n    fprintf(stderr, \"logging started to the file %s.\\n\", alt_fname);\n    strncpy(current_log_buf, alt_fname, sizeof(current_log_buf));\n    current_log_buf[sizeof(current_log_buf)-1]= 0;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    openlog(syslog_ident, LOG_NOWAIT, syslog_facility_codes[syslog_facility]);\n    error_header();\n    fprintf(stderr, \"logging started to the syslog.\\n\");\n    strncpy(current_log_buf, \"[SYSLOG]\", sizeof(current_log_buf));\n  }\n  is_active= 1;\n  return 0;\n}\n\n\nstatic int stop_logging()\n{\n  last_error_buf[0]= 0;\n  if (output_type == OUTPUT_FILE && logfile)\n  {\n    logger_close(logfile);\n    logfile= NULL;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    closelog();\n  }\n  error_header();\n  fprintf(stderr, \"logging was stopped.\\n\");\n  is_active= 0;\n  return 0;\n}\n\n\nstatic void setup_connection_simple(struct connection_info *ci)\n{\n  ci->db_length= 0;\n  ci->user_length= 0;\n  ci->host_length= 0;\n  ci->ip_length= 0;\n  ci->query_length= 0;\n  ci->header= 0;\n}\n\n\nstatic void setup_connection_connect(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  cn->query_id= 0;\n  cn->log_always= 0;\n  cn->thread_id= event->thread_id;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, event->user_length);\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, event->host_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n  cn->header= 0;\n}\n\n\n#define SAFE_STRLEN(s) (s ? strlen(s) : 0)\nstatic char empty_str[1]= { 0 };\n\n\nstatic int is_space(char c)\n{\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';\n}\n\n\n#define SKIP_SPACES(str) \\\ndo { \\\n  while (is_space(*str)) \\\n    ++str; \\\n} while(0)\n\n\n\n\nstatic void setup_connection_initdb(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= 0;\n  cn->log_always= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->general_query, event->general_query_length);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_table(struct connection_info *cn,\n    const struct mysql_event_table *event)\n{\n  cn->thread_id= event->thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, SAFE_STRLEN(event->user));\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, SAFE_STRLEN(event->host));\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, SAFE_STRLEN(event->ip));\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_query(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db), \"\", 0);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void change_connection(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n            event->user, event->user_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n}\n\nstatic int write_log(const char *message, int len)\n{\n  if (output_type == OUTPUT_FILE)\n  {\n    if (logfile &&\n        (is_active= (logger_write(logfile, message, len) == len)))\n      return 0;\n    ++log_write_failures;\n    return 1;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    syslog(syslog_facility_codes[syslog_facility] |\n           syslog_priority_codes[syslog_priority],\n           \"%s %.*s\", syslog_info, len, message);\n  }\n  return 0;\n}\n\n\nstatic size_t log_header(char *message, size_t message_len,\n                      time_t *ts,\n                      const char *serverhost, unsigned int serverhost_len,\n                      const char *username, unsigned int username_len,\n                      const char *host, unsigned int host_len,\n                      const char *userip, unsigned int userip_len,\n                      unsigned int connection_id, long long query_id,\n                      const char *operation)\n{\n  struct tm tm_time;\n\n  if (host_len == 0 && userip_len != 0)\n  {\n    host_len= userip_len;\n    host= userip;\n  }\n\n  if (output_type == OUTPUT_SYSLOG)\n    return my_snprintf(message, message_len,\n        \"%.*s,%.*s,%.*s,%d,%lld,%s\",\n        serverhost_len, serverhost,\n        username_len, username,\n        host_len, host,\n        connection_id, query_id, operation);\n\n  (void) localtime_r(ts, &tm_time);\n  return my_snprintf(message, message_len,\n      \"%04d%02d%02d %02d:%02d:%02d,%.*s,%.*s,%.*s,%d,%lld,%s\",\n      tm_time.tm_year+1900, tm_time.tm_mon+1, tm_time.tm_mday,\n      tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,\n      serverhost_len, serverhost,\n      username_len, username,\n      host_len, host,\n      connection_id, query_id, operation);\n}\n\n\nstatic int log_connection(const struct connection_info *cn,\n                          const struct mysql_event_connection *event,\n                          const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,\n                    cn->host, cn->host_length,\n                    cn->ip, cn->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", cn->db_length, cn->db, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1);\n}\n\n\nstatic int log_connection_event(const struct mysql_event_connection *event,\n                                const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, event->user_length,\n                    event->host, event->host_length,\n                    event->ip, event->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", event->database_length, event->database, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1);\n}\n\n\nstatic size_t escape_string(const char *str, unsigned int len,\n                          char *result, size_t result_len)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  while (len)\n  {\n    if (result >= res_end)\n      break;\n    if (*str == '\\'')\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= '\\'';\n    }\n    else if (*str == '\\\\')\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= '\\\\';\n    }\n    else if (is_space(*str))\n      *(result++)= ' ';\n    else\n      *(result++)= *str;\n    str++;\n    len--;\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\nstatic size_t escape_string_hide_passwords(const char *str, unsigned int len,\n    char *result, size_t result_len,\n    const char *word1, size_t word1_len,\n    const char *word2, size_t word2_len,\n    int next_text_string)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  size_t d_len;\n  char b_char;\n\n  while (len)\n  {\n    if (len > word1_len + 1 && strncasecmp(str, word1, word1_len) == 0)\n    {\n      const char *next_s= str + word1_len;\n      size_t c;\n\n      if (next_text_string)\n      {\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n      else\n      {\n        if (word2)\n        {\n          SKIP_SPACES(next_s);\n          if (len < (next_s - str) + word2_len + 1 ||\n              strncasecmp(next_s, word2, word2_len) != 0)\n            goto no_password;\n          next_s+= word2_len;\n        }\n\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n\n      d_len= next_s - str;\n      if (result + d_len + 5 > res_end)\n        break;\n\n      for (c=0; c<d_len; c++)\n        result[c]= is_space(str[c]) ? ' ' : str[c];\n\n      if (*next_s)\n      {\n        memmove(result + d_len, \"*****\", 5);\n        result+= d_len + 5;\n        b_char= *(next_s++);\n      }\n      else\n        result+= d_len;\n\n      while (*next_s)\n      {\n        if (*next_s == b_char)\n        {\n          ++next_s;\n          break;\n        }\n        if (*next_s == '\\\\')\n        {\n          if (next_s[1])\n            next_s++;\n        }\n        next_s++;\n      }\n      len-= next_s - str;\n      str= next_s;\n      continue;\n    }\nno_password:\n    if (result >= res_end)\n      break;\n    if (*str == '\\'')\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= '\\'';\n    }\n    else if (*str == '\\\\')\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= '\\\\';\n    }\n    else if (is_space(*str))\n      *(result++)= ' ';\n    else\n      *(result++)= *str;\n    str++;\n    len--;\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\n\nstatic int do_log_user(const char *name)\n{\n  size_t len;\n\n  if (!name)\n    return 0;\n  len= strlen(name);\n\n  if (incl_user_coll.n_users)\n    return coll_search(&incl_user_coll, name, len) != 0;\n\n  if (excl_user_coll.n_users)\n    return coll_search(&excl_user_coll, name, len) == 0;\n\n  return 1;\n}\n\n\nstatic int get_next_word(const char *query, char *word)\n{\n  int len= 0;\n  char c;\n  while ((c= query[len]))\n  {\n    if (c >= 'a' && c <= 'z')\n      word[len]= 'A' + (c-'a');\n    else if (c >= 'A' && c <= 'Z')\n      word[len]= c;\n    else\n      break;\n\n    if (len++ == MAX_KEYWORD)\n      return 0;\n  }\n  word[len]= 0;\n  return len;\n}\n\n\nstatic int filter_query_type(const char *query, struct sa_keyword *kwd)\n{\n  int qwe_in_list;\n  char fword[MAX_KEYWORD + 1], nword[MAX_KEYWORD + 1];\n  int len, nlen= 0;\n  const struct sa_keyword *l_keywords;\n\n  while (*query && (is_space(*query) || *query == '(' || *query == '/'))\n  {\n    /* comment handling */\n    if (*query == '/' && query[1] == '*')\n    {\n      if (query[2] == '!')\n      {\n        query+= 3;\n        while (*query >= '0' && *query <= '9')\n          query++;\n        continue;\n      }\n      query+= 2;\n      while (*query)\n      {\n        if (*query=='*' && query[1] == '/')\n        {\n          query+= 2;\n          break;\n        }\n        query++;\n      }\n      continue;\n    }\n    query++;\n  }\n\n  qwe_in_list= 0;\n  if (!(len= get_next_word(query, fword)))\n    goto not_in_list;\n  query+= len+1;\n\n  l_keywords= kwd;\n  while (l_keywords->length)\n  {\n    if (l_keywords->length == len && strncmp(l_keywords->wd, fword, len) == 0)\n    {\n      if (l_keywords->next)\n      {\n        if (nlen == 0)\n        {\n          while (*query && is_space(*query))\n            query++;\n          nlen= get_next_word(query, nword);\n        }\n        if (l_keywords->next->length != nlen ||\n            strncmp(l_keywords->next->wd, nword, nlen) != 0)\n          goto do_loop;\n      }\n\n      qwe_in_list= l_keywords->type;\n      break;\n    };\ndo_loop:\n    l_keywords++;\n  }\n\nnot_in_list:\n  return qwe_in_list;\n}\n\n\nstatic int log_statement_ex(const struct connection_info *cn,\n                            time_t ev_time, unsigned long thd_id,\n                            const char *query, unsigned int query_len,\n                            int error_code, const char *type)\n{\n  size_t csize;\n  char message_loc[1024];\n  char *message= message_loc;\n  size_t message_size= sizeof(message_loc);\n  char *uh_buffer;\n  size_t uh_buffer_size;\n  const char *db;\n  unsigned int db_length;\n  long long query_id;\n  int result;\n\n  if ((db= cn->db))\n    db_length= cn->db_length;\n  else\n  {\n    db= \"\";\n    db_length= 0;\n  }\n\n  if (!(query_id= cn->query_id))\n    query_id= query_counter++;\n\n  if (query == 0)\n  {\n    /* Can happen after the error in mysqld_prepare_stmt() */\n    query= cn->query;\n    query_len= cn->query_length;\n    if (query == 0 || query_len == 0)\n      return 0;\n  }\n\n  if (query && !(events & EVENT_QUERY_ALL) &&\n      (events & EVENT_QUERY))\n  {\n    const char *orig_query= query;\n\n    if (filter_query_type(query, keywords_to_skip))\n    {\n      char fword[MAX_KEYWORD + 1];\n      int len;\n      do\n      {\n        len= get_next_word(query, fword);\n        query+= len ? len : 1;\n        if (len == 3 && strncmp(fword, \"FOR\", 3) == 0)\n          break;\n      } while (*query);\n\n      if (*query == 0)\n        return 0;\n    }\n\n    if (events & EVENT_QUERY_DDL)\n    {\n      if (!filter_query_type(query, not_ddl_keywords) &&\n          filter_query_type(query, ddl_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DML)\n    {\n      if (filter_query_type(query, dml_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DCL)\n    {\n      if (filter_query_type(query, dcl_keywords))\n        goto do_log_query;\n    }\n\n    return 0;\ndo_log_query:\n    query= orig_query;\n  }\n\n  csize= log_header(message, message_size-1, &ev_time,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,cn->host, cn->host_length,\n                    cn->ip, cn->ip_length, thd_id, query_id, type);\n\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n      \",%.*s,\\'\", db_length, db);\n\n  if (query_log_limit > 0 && query_len > query_log_limit)\n    query_len= query_log_limit;\n\n  if (query_len > (message_size - csize)/2)\n  {\n    flogger_mutex_lock(&lock_bigbuffer);\n    if (big_buffer_alloced < (query_len * 2 + csize))\n    {\n      big_buffer_alloced= (query_len * 2 + csize + 4095) & ~4095L;\n      big_buffer= realloc(big_buffer, big_buffer_alloced);\n      if (big_buffer == NULL)\n      {\n        big_buffer_alloced= 0;\n        return 0;\n      }\n    }\n\n    memcpy(big_buffer, message, csize);\n    message= big_buffer;\n    message_size= big_buffer_alloced;\n  }\n\n  uh_buffer= message + csize;\n  uh_buffer_size= message_size - csize;\n  if (query_log_limit > 0 && uh_buffer_size > query_log_limit+2)\n    uh_buffer_size= query_log_limit+2;\n\n  switch (filter_query_type(query, passwd_keywords))\n  {\n    case SQLCOM_GRANT:\n    case SQLCOM_CREATE_USER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"IDENTIFIED\", 10, \"BY\", 2, 0);\n      break;\n    case SQLCOM_CHANGE_MASTER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"MASTER_PASSWORD\", 15, \"=\", 1, 0);\n      break;\n    case SQLCOM_CREATE_SERVER:\n    case SQLCOM_ALTER_SERVER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"PASSWORD\", 8, NULL, 0, 0);\n      break;\n    case SQLCOM_SET_OPTION:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"=\", 1, NULL, 0, 1);\n      break;\n    default:\n      csize+= escape_string(query, query_len,\n                               uh_buffer, uh_buffer_size); \n      break;\n  }\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n                      \"\\',%d\", error_code);\n  message[csize]= '\\n';\n  result= write_log(message, csize + 1);\n  if (message == big_buffer)\n    flogger_mutex_unlock(&lock_bigbuffer);\n\n  return result;\n}\n\n\nstatic int log_statement(const struct connection_info *cn,\n                         const struct mysql_event_general *event,\n                         const char *type)\n{\n  return log_statement_ex(cn, event->general_time, event->general_thread_id,\n                          event->general_query, event->general_query_length,\n                          event->general_error_code, type);\n}\n\n\nstatic int log_table(const struct connection_info *cn,\n                     const struct mysql_event_table *event, const char *type)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN(event->user),\n                    event->host, SAFE_STRLEN(event->host),\n                    event->ip, SAFE_STRLEN(event->ip),\n                    event->thread_id, cn->query_id, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s,\",event->database_length, event->database,\n                          event->table_length, event->table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1);\n}\n\n\nstatic int log_rename(const struct connection_info *cn,\n                      const struct mysql_event_table *event)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN(event->user),\n                    event->host, SAFE_STRLEN(event->host),\n                    event->ip, SAFE_STRLEN(event->ip),\n                    event->thread_id, cn->query_id, \"RENAME\");\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s|%.*s.%.*s,\",event->database_length, event->database,\n                         event->table_length, event->table,\n                         event->new_database_length, event->new_database,\n                         event->new_table_length, event->new_table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1);\n}\n\n\nstatic int event_query_command(const struct mysql_event_general *event)\n{\n  return (event->general_command_length == 5 &&\n           strncmp(event->general_command, \"Query\", 5) == 0) ||\n         (event->general_command_length == 7 &&\n           (strncmp(event->general_command, \"Execute\", 7) == 0 ||\n             (event->general_error_code != 0 &&\n              strncmp(event->general_command, \"Prepare\", 7) == 0)));\n}\n\n\nstatic void update_general_user(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  char uh_buffer[768];\n  size_t user_len, host_len, ip_len;\n  if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0 &&\n      get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len) == 0)\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user), \n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host), \n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip), \n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n\n}\n\n\nstatic struct connection_info ci_disconnect_buffer;\n\n#define AA_FREE_CONNECTION 1\n#define AA_CHANGE_USER 2\n\nstatic void update_connection_info(struct connection_info *cn,\n    unsigned int event_class, const void *ev, int *after_action)\n{\n  *after_action= 0;\n\n  switch (event_class) {\n  case MYSQL_AUDIT_GENERAL_CLASS:\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n    switch (event->event_subclass) {\n      case MYSQL_AUDIT_GENERAL_LOG:\n      {\n        int init_db_command= event->general_command_length == 7 &&\n          strncmp(event->general_command, \"Init DB\", 7) == 0;\n        if (!ci_needs_setup(cn))\n        {\n          if (init_db_command)\n          {\n            /* Change DB */\n            if (mysql_57_started)\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->database, event->database_length);\n            else\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->general_query, event->general_query_length);\n          }\n          cn->query_id= mode ? query_counter++ : event->query_id;\n          cn->query= event->general_query;\n          cn->query_length= event->general_query_length;\n          cn->query_time= (time_t) event->general_time;\n          update_general_user(cn, event);\n        }\n        else if (init_db_command)\n          setup_connection_initdb(cn, event);\n        else if (event_query_command(event))\n          setup_connection_query(cn, event);\n        else\n          setup_connection_simple(cn);\n        break;\n      }\n\n      case MYSQL_AUDIT_GENERAL_STATUS:\n        if (event_query_command(event))\n        {\n          if (ci_needs_setup(cn))\n            setup_connection_query(cn, event);\n\n          if (mode == 0 && cn->db_length == 0 && event->database_length > 0)\n            get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                      event->database, event->database_length);\n\n          if (event->general_error_code == 0)\n          {\n            /* We need to check if it's the USE command to change the DB */\n            int use_command= event->general_query_length > 4 &&\n              strncasecmp(event->general_query, \"use \", 4) == 0;\n            if (use_command)\n            {\n              /* Change DB */\n              if (mode)\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->general_query + 4, event->general_query_length - 4);\n              else\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->database, event->database_length);\n            }\n          }\n          update_general_user(cn, event);\n        }\n        break;\n      case MYSQL_AUDIT_GENERAL_ERROR:\n        /*\n          We need this because the MariaDB returns NULL query field for the\n          MYSQL_AUDIT_GENERAL_STATUS in the mysqld_stmt_prepare.\n          As a result we get empty QUERY field for errors.\n        */\n        if (ci_needs_setup(cn))\n          setup_connection_query(cn, event);\n        cn->query_id= mode ? query_counter++ : event->query_id;\n        get_str_n(cn->query_buffer, &cn->query_length, sizeof(cn->query_buffer),\n            event->general_query, event->general_query_length);\n        cn->query= cn->query_buffer;\n        cn->query_time= (time_t) event->general_time;\n        break;\n      default:;\n    }\n    break;\n  }\n  case MYSQL_AUDIT_TABLE_CLASS:\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (ci_needs_setup(cn))\n      setup_connection_table(cn, event);\n\n    if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0)\n    {\n      get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n                event->user, SAFE_STRLEN(event->user));\n      get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n                event->host, SAFE_STRLEN(event->host));\n      get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n                event->ip, SAFE_STRLEN(event->ip));\n    }\n\n    if (cn->db_length == 0 && event->database_length != 0)\n      get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                event->database, event->database_length);\n\n    if (mode == 0)\n      cn->query_id= event->query_id;\n    break;\n  }\n  case MYSQL_AUDIT_CONNECTION_CLASS:\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        setup_connection_connect(cn, event);\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        *after_action= AA_CHANGE_USER;\n        break;\n      default:;\n    }\n    break;\n  }\n  default:\n    break;\n  }\n}\n\n\nstruct connection_info cn_error_buffer;\n\n\n#define FILTER(MASK) (events == 0 || (events & MASK))\nvoid auditing(MYSQL_THD thd, unsigned int event_class, const void *ev)\n{\n  struct connection_info *cn= 0;\n  int after_action= 0;\n\n  /* That one is important as this function can be called with      */\n  /* &lock_operations locked when the server logs an error reported */\n  /* by this plugin.                                                */\n  if (!thd || internal_stop_logging)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n\n  if (maria_55_started && debug_server_started &&\n      event_class == MYSQL_AUDIT_GENERAL_CLASS)\n  {\n    /*\n      There's a bug in MariaDB 5.5 that prevents using thread local\n      variables in some cases.\n      The 'select * from notexisting_table;' query produces such case.\n      So just use the static buffer in this case.\n    */\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_ERROR ||\n        (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS && \n         event->general_query_length == 0 &&\n         cn_error_buffer.query_id == event->query_id))\n    {\n      cn= &cn_error_buffer;\n      cn->header= 1;\n    }\n    else\n      cn= get_loc_info(thd);\n  }\n  else\n  {\n    cn= get_loc_info(thd);\n  }\n\n  update_connection_info(cn, event_class, ev, &after_action);\n\n  if (!logging)\n    goto exit_func;\n\n  if (event_class == MYSQL_AUDIT_GENERAL_CLASS && FILTER(EVENT_QUERY) &&\n      cn && do_log_user(cn->user))\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    /*\n      Only one subclass is logged.\n    */\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS &&\n        event_query_command(event))\n    {\n      log_statement(cn, event, \"QUERY\");\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_TABLE_CLASS && FILTER(EVENT_TABLE) && cn)\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (do_log_user(event->user))\n    {\n      switch (event->event_subclass)\n      {\n        case MYSQL_AUDIT_TABLE_LOCK:\n          log_table(cn, event, event->read_only ? \"READ\" : \"WRITE\");\n          break;\n        case MYSQL_AUDIT_TABLE_CREATE:\n          log_table(cn, event, \"CREATE\");\n          break;\n        case MYSQL_AUDIT_TABLE_DROP:\n          log_table(cn, event, \"DROP\");\n          break;\n        case MYSQL_AUDIT_TABLE_RENAME:\n          log_rename(cn, event);\n          break;\n        case MYSQL_AUDIT_TABLE_ALTER:\n          log_table(cn, event, \"ALTER\");\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_CONNECTION_CLASS &&\n           FILTER(EVENT_CONNECT) && cn)\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        log_connection(cn, event, event->status ? \"FAILED_CONNECT\": \"CONNECT\");\n        break;\n      case MYSQL_AUDIT_CONNECTION_DISCONNECT:\n        if (use_event_data_for_disconnect)\n          log_connection_event(event, \"DISCONNECT\");\n        else\n          log_connection(&ci_disconnect_buffer, event, \"DISCONNECT\");\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        log_connection(cn, event, \"CHANGEUSER\");\n        break;\n      default:;\n    }\n  }\nexit_func:\n  /*\n    This must work always, whether logging is ON or not.\n  */\n  if (after_action)\n  {\n    switch (after_action) {\n    case AA_CHANGE_USER:\n    {\n      const struct mysql_event_connection *event =\n        (const struct mysql_event_connection *) ev;\n      change_connection(cn, event);\n      break;\n    }\n    default:\n      break;\n    }\n  }\n  if (cn)\n    cn->log_always= 0;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstruct mysql_event_general_v8\n{\n  unsigned int event_class;\n  unsigned int event_subclass;\n  int general_error_code;\n  unsigned long general_thread_id;\n  const char *general_user;\n  unsigned int general_user_length;\n  const char *general_command;\n  unsigned int general_command_length;\n  const char *general_query;\n  unsigned int general_query_length;\n  struct charset_info_st *general_charset;\n  unsigned long long general_time;\n  unsigned long long general_rows;\n};\n\n\nstatic void auditing_v8(MYSQL_THD thd, struct mysql_event_general_v8 *ev_v8)\n{\n#ifdef DBUG_OFF\n  #ifdef __x86_64__\n  static const int cmd_off= 4200;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2668;\n  static const int db_off= 60;\n  static const int db_len_off= 64;\n  #endif /*x86_64*/\n#else\n  #ifdef __x86_64__\n  static const int cmd_off= 4432;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2808;\n  static const int db_off= 64;\n  static const int db_len_off= 68;\n  #endif /*x86_64*/\n#endif /*DBUG_OFF*/\n\n  struct mysql_event_general event;\n\n  if (ev_v8->event_class != MYSQL_AUDIT_GENERAL_CLASS)\n    return;\n\n  event.event_subclass= ev_v8->event_subclass;\n  event.general_error_code= ev_v8->general_error_code;\n  event.general_thread_id= ev_v8->general_thread_id;\n  event.general_user= ev_v8->general_user;\n  event.general_user_length= ev_v8->general_user_length;\n  event.general_command= ev_v8->general_command;\n  event.general_command_length= ev_v8->general_command_length;\n  event.general_query= ev_v8->general_query;\n  event.general_query_length= ev_v8->general_query_length;\n  event.general_charset= ev_v8->general_charset;\n  event.general_time= ev_v8->general_time;\n  event.general_rows= ev_v8->general_rows;\n  event.database= 0;\n  event.database_length= 0;\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n#ifdef __linux__\n    event.database= *(char **) (((char *) thd) + db_off);\n    event.database_length= *(size_t *) (((char *) thd) + db_len_off);\n#endif /*__linux*/\n  }\n#ifdef __linux__\n  else if (*((int *) (((char *)thd) + cmd_off)) == 2)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_LOG;\n    event.general_command= \"Init DB\";\n    event.general_command_length= 7;\n    event.general_query= *(char **) (((char *) thd) + db_off);\n    event.general_query_length= *(size_t *) (((char *) thd) + db_len_off);\n  }\n#endif /*__linux*/\n  auditing(thd, ev_v8->event_class, &event);\n}\n\n\nstatic void auditing_v13(MYSQL_THD thd, unsigned int *ev_v0)\n{\n  struct mysql_event_general event= *(const struct mysql_event_general *) (ev_v0+1);\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n  }\n  auditing(thd, ev_v0[0], &event);\n}\n\n\nint get_db_mysql57(MYSQL_THD thd, char **name, int *len)\n{\n  int db_off;\n  int db_len_off;\n  if (debug_server_started)\n  {\n#ifdef __x86_64__\n    db_off= 608;\n    db_len_off= 616;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n  else\n  {\n#ifdef __x86_64__\n    db_off= 536;\n    db_len_off= 544;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n\n#ifdef __linux__\n  *name= *(char **) (((char *) thd) + db_off);\n  *len= *((int *) (((char*) thd) + db_len_off));\n  if (*name && (*name)[*len] != 0)\n    return 1;\n  return 0;\n#else\n  return 1;\n#endif\n}\n/*\n   As it's just too difficult to #include \"sql_class.h\",\n   let's just copy the necessary part of the system_variables\n   structure here.\n*/\ntypedef struct loc_system_variables\n{\n  ulong dynamic_variables_version;\n  char* dynamic_variables_ptr;\n  uint dynamic_variables_head;    /* largest valid variable offset */\n  uint dynamic_variables_size;    /* how many bytes are in use */\n  \n  ulonglong max_heap_table_size;\n  ulonglong tmp_table_size;\n  ulonglong long_query_time;\n  ulonglong optimizer_switch;\n  ulonglong sql_mode; ///< which non-standard SQL behaviour should be enabled\n  ulonglong option_bits; ///< OPTION_xxx constants, e.g. OPTION_PROFILING\n  ulonglong join_buff_space_limit;\n  ulonglong log_slow_filter; \n  ulonglong log_slow_verbosity; \n  ulonglong bulk_insert_buff_size;\n  ulonglong join_buff_size;\n  ulonglong sortbuff_size;\n  ulonglong group_concat_max_len;\n  ha_rows select_limit;\n  ha_rows max_join_size;\n  ha_rows expensive_subquery_limit;\n  ulong auto_increment_increment, auto_increment_offset;\n  ulong lock_wait_timeout;\n  ulong join_cache_level;\n  ulong max_allowed_packet;\n  ulong max_error_count;\n  ulong max_length_for_sort_data;\n  ulong max_sort_length;\n  ulong max_tmp_tables;\n  ulong max_insert_delayed_threads;\n  ulong min_examined_row_limit;\n  ulong multi_range_count;\n  ulong net_buffer_length;\n  ulong net_interactive_timeout;\n  ulong net_read_timeout;\n  ulong net_retry_count;\n  ulong net_wait_timeout;\n  ulong net_write_timeout;\n  ulong optimizer_prune_level;\n  ulong optimizer_search_depth;\n  ulong preload_buff_size;\n  ulong profiling_history_size;\n  ulong read_buff_size;\n  ulong read_rnd_buff_size;\n  ulong mrr_buff_size;\n  ulong div_precincrement;\n  /* Total size of all buffers used by the subselect_rowid_merge_engine. */\n  ulong rowid_merge_buff_size;\n  ulong max_sp_recursion_depth;\n  ulong default_week_format;\n  ulong max_seeks_for_key;\n  ulong range_alloc_block_size;\n  ulong query_alloc_block_size;\n  ulong query_prealloc_size;\n  ulong trans_alloc_block_size;\n  ulong trans_prealloc_size;\n  ulong log_warnings;\n  /* Flags for slow log filtering */\n  ulong log_slow_rate_limit; \n  ulong binlog_format; ///< binlog format for this thd (see enum_binlog_format)\n  ulong progress_report_time;\n  my_bool binlog_annotate_row_events;\n  my_bool binlog_direct_non_trans_update;\n  my_bool sql_log_bin;\n  ulong completion_type;\n  ulong query_cache_type;\n} LOC_SV;\n\n\nstatic int init_done= 0;\n\nstatic int server_audit_init(void *p __attribute__((unused)))\n{\n  if (!serv_ver)\n  {\n#ifdef _WIN32\n    serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\n    serv_ver= server_version;\n#endif /*_WIN32*/\n  }\n  if (!mysql_57_started)\n  {\n    const void *my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"_my_hash_init\");\n    if (!my_hash_init_ptr)\n    {\n      maria_above_5= 1;\n      my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"my_hash_init2\");\n    }\n    if (!my_hash_init_ptr)\n      return 1;\n  }\n\n  if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"mysql_data_home\")))\n  {\n    if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"?mysql_data_home@@3PADA\")))\n      int_mysql_data_home= &default_home;\n  }\n\n  if (!serv_ver)\n    return 1;\n\n  if (!started_mysql)\n  {\n    if (!maria_above_5 && serv_ver[4]=='3' && serv_ver[5]<'3')\n    {\n      mode= 1;\n      mode_readonly= 1;\n    }\n  }\n\n  if (gethostname(servhost, sizeof(servhost)))\n    strcpy(servhost, \"unknown\");\n\n  servhost_len= strlen(servhost);\n\n  logger_init_mutexes();\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n  if (PSI_server)\n    PSI_server->register_mutex(\"server_audit\", mutex_key_list, 1);\n#endif\n  flogger_mutex_init(key_LOCK_operations, &lock_operations, MY_MUTEX_INIT_FAST);\n  flogger_mutex_init(key_LOCK_operations, &lock_bigbuffer, MY_MUTEX_INIT_FAST);\n\n  coll_init(&incl_user_coll);\n  coll_init(&excl_user_coll);\n\n  if (incl_users)\n  {\n    if (excl_users)\n    {\n      incl_users= excl_users= NULL;\n      error_header();\n      fprintf(stderr, \"INCL_DML_USERS and EXCL_DML_USERS specified\"\n                      \" simultaneously - both set to empty\\n\");\n    }\n    update_incl_users(NULL, NULL, NULL, &incl_users);\n  }\n  else if (excl_users)\n  {\n    update_excl_users(NULL, NULL, NULL, &excl_users);\n  }\n\n  error_header();\n  fprintf(stderr, \"MariaDB Audit Plugin version %s%s STARTED.\\n\",\n          PLUGIN_STR_VERSION, PLUGIN_DEBUG_VERSION);\n\n  /* The Query Cache shadows TABLE events if the result is taken from it */\n  /* so we warn users if both Query Cashe and TABLE events enabled.      */\n  if (!started_mysql && FILTER(EVENT_TABLE))\n  {\n    ulonglong *qc_size= (ulonglong *) dlsym(RTLD_DEFAULT, \"query_cache_size\");\n    if (qc_size == NULL || *qc_size != 0)\n    {\n      struct loc_system_variables *g_sys_var=\n        (struct loc_system_variables *) dlsym(RTLD_DEFAULT,\n                                          \"global_system_variables\");\n      if (g_sys_var && g_sys_var->query_cache_type != 0)\n      {\n        error_header();\n        fprintf(stderr, \"Query cache is enabled with the TABLE events.\"\n                        \" Some table reads can be veiled.\");\n      }\n    }\n  }\n\n  ci_disconnect_buffer.header= 10;\n  ci_disconnect_buffer.thread_id= 0;\n  ci_disconnect_buffer.query_id= 0;\n  ci_disconnect_buffer.db_length= 0;\n  ci_disconnect_buffer.user_length= 0;\n  ci_disconnect_buffer.host_length= 0;\n  ci_disconnect_buffer.ip_length= 0;\n  ci_disconnect_buffer.query= empty_str;\n  ci_disconnect_buffer.query_length= 0;\n\n  if (logging)\n    start_logging();\n\n  init_done= 1;\n  return 0;\n}\n\n\nstatic int server_audit_init_mysql(void *p)\n{\n  started_mysql= 1;\n  mode= 1;\n  mode_readonly= 1;\n  return server_audit_init(p);\n}\n\n\nstatic int server_audit_deinit(void *p __attribute__((unused)))\n{\n  if (!init_done)\n    return 0;\n\n  init_done= 0;\n  coll_free(&incl_user_coll);\n  coll_free(&excl_user_coll);\n\n  if (output_type == OUTPUT_FILE && logfile)\n    logger_close(logfile);\n  else if (output_type == OUTPUT_SYSLOG)\n    closelog();\n\n  (void) free(big_buffer);\n  flogger_mutex_destroy(&lock_operations);\n  flogger_mutex_destroy(&lock_bigbuffer);\n\n  error_header();\n  fprintf(stderr, \"STOPPED\\n\");\n  return 0;\n}\n\n\nstatic void rotate_log(MYSQL_THD thd  __attribute__((unused)),\n                       struct st_mysql_sys_var *var  __attribute__((unused)),\n                       void *var_ptr  __attribute__((unused)),\n                       const void *save  __attribute__((unused)))\n{\n  if (output_type == OUTPUT_FILE && logfile && *(my_bool*) save)\n    (void) logger_rotate(logfile);\n}\n\n\nstatic struct st_mysql_audit mysql_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK | MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\n\n\nmysql_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &mysql_descriptor,\n  \"SERVER_AUDIT\",\n  \" Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init_mysql,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  NULL,\n  0\n}\nmysql_declare_plugin_end;\n\n\nstatic struct st_mysql_audit maria_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK |\n    MYSQL_AUDIT_TABLE_CLASSMASK |\n    MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\nmaria_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &maria_descriptor,\n  \"SERVER_AUDIT\",\n  \"Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  PLUGIN_STR_VERSION,\n  MariaDB_PLUGIN_MATURITY_STABLE\n}\nmaria_declare_plugin_end;\n\n\nstatic void mark_always_logged(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (thd && (cn= get_loc_info(thd)))\n    cn->log_always= 1;\n}\n\n\nstatic void log_current_query(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (!thd)\n    return;\n  cn= get_loc_info(thd);\n  if (!ci_needs_setup(cn) && FILTER(EVENT_QUERY) && do_log_user(cn->user))\n  {\n    log_statement_ex(cn, cn->query_time, thd_get_thread_id(thd),\n        cn->query, cn->query_length, 0, \"QUERY\");\n    cn->log_always= 1;\n  }\n}\n\n\nstatic void update_file_path(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_name= (*(char **) save) ? *(char **) save : empty_str;\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  internal_stop_logging= 1;\n  error_header();\n  fprintf(stderr, \"Log file name was changed to '%s'.\\n\", new_name);\n\n  if (logging)\n    log_current_query(thd);\n\n  if (logging && output_type == OUTPUT_FILE)\n  {\n    char *sav_path= file_path;\n\n    file_path= new_name;\n    internal_stop_logging= 1;\n    stop_logging();\n    if (start_logging())\n    {\n      file_path= sav_path;\n      error_header();\n      fprintf(stderr, \"Reverting log filename back to '%s'.\\n\", file_path);\n      logging= (start_logging() == 0);\n      if (!logging)\n      {\n        error_header();\n        fprintf(stderr, \"Logging was disabled..\\n\");\n        CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n      }\n      goto exit_func;\n    }\n    internal_stop_logging= 0;\n  }\n\n  strncpy(path_buffer, new_name, sizeof(path_buffer));\n  path_buffer[sizeof(path_buffer)-1]= 0;\n  file_path= path_buffer;\nexit_func:\n  internal_stop_logging= 0;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_file_rotations(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  rotations= *(unsigned int *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotations was changed to '%d'.\\n\", rotations);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->rotations= rotations;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_file_rotate_size(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  file_rotate_size= *(unsigned long long *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotate size was changed to '%lld'.\\n\",\n          file_rotate_size);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->size_limit= file_rotate_size;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_incl_users(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  strncpy(incl_user_buffer, new_users, sizeof(incl_user_buffer));\n  incl_user_buffer[sizeof(incl_user_buffer)-1]= 0;\n  incl_users= incl_user_buffer;\n  user_coll_fill(&incl_user_coll, incl_users, &excl_user_coll, 1);\n  error_header();\n  fprintf(stderr, \"server_audit_incl_users set to '%s'.\\n\", incl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_excl_users(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  strncpy(excl_user_buffer, new_users, sizeof(excl_user_buffer));\n  excl_user_buffer[sizeof(excl_user_buffer)-1]= 0;\n  excl_users= excl_user_buffer;\n  user_coll_fill(&excl_user_coll, excl_users, &incl_user_coll, 0);\n  error_header();\n  fprintf(stderr, \"server_audit_excl_users set to '%s'.\\n\", excl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_output_type(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_output_type= *((ulong *) save);\n  if (output_type == new_output_type)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  internal_stop_logging= 1;\n  if (logging)\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  output_type= new_output_type;\n  error_header();\n  fprintf(stderr, \"Output was redirected to '%s'\\n\",\n          output_type_names[output_type]);\n\n  if (logging)\n    start_logging();\n  internal_stop_logging= 0;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_syslog_facility(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_facility= *((ulong *) save);\n  if (syslog_facility == new_facility)\n    return;\n\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"SysLog facility was changed from '%s' to '%s'.\\n\",\n          syslog_facility_names[syslog_facility],\n          syslog_facility_names[new_facility]);\n  syslog_facility= new_facility;\n}\n\n\nstatic void update_syslog_priority(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_priority= *((ulong *) save);\n  if (syslog_priority == new_priority)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  flogger_mutex_unlock(&lock_operations);\n  error_header();\n  fprintf(stderr, \"SysLog priority was changed from '%s' to '%s'.\\n\",\n          syslog_priority_names[syslog_priority],\n          syslog_priority_names[new_priority]);\n  syslog_priority= new_priority;\n}\n\n\nstatic void update_logging(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char new_logging= *(char *) save;\n  if (new_logging == logging)\n    return;\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  internal_stop_logging= 1;\n  if ((logging= new_logging))\n  {\n    start_logging();\n    if (!logging)\n    {\n      CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n    }\n  }\n  else\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  internal_stop_logging= 0;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_mode(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  unsigned int new_mode= *(unsigned int *) save;\n  if (mode_readonly || new_mode == mode)\n    return;\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  internal_stop_logging= 1;\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"Logging mode was changed from %d to %d.\\n\", mode, new_mode);\n  mode= new_mode;\n  internal_stop_logging= 0;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_syslog_ident(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_ident= (*(char **) save) ? *(char **) save : empty_str;\n  strncpy(syslog_ident_buffer, new_ident, sizeof(syslog_ident_buffer));\n  syslog_ident_buffer[sizeof(syslog_ident_buffer)-1]= 0;\n  syslog_ident= syslog_ident_buffer;\n  error_header();\n  fprintf(stderr, \"SYSYLOG ident was changed to '%s'\\n\", syslog_ident);\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  if (logging && output_type == OUTPUT_SYSLOG)\n  {\n    stop_logging();\n    start_logging();\n  }\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstruct st_my_thread_var *loc_thread_var(void)\n{\n  return 0;\n}\n\n\n\n#ifdef _WIN32\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n  if (fdwReason != DLL_PROCESS_ATTACH)\n    return 1;\n\n  serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\nvoid __attribute__ ((constructor)) audit_plugin_so_init(void)\n{\n  serv_ver= server_version;\n#endif /*_WIN32*/\n\n  if (!serv_ver)\n    goto exit;\n\n  started_mariadb= strstr(serv_ver, \"MariaDB\") != 0;\n  debug_server_started= strstr(serv_ver, \"debug\") != 0;\n\n  if (started_mariadb)\n  {\n    if (serv_ver[0] == '1')\n      use_event_data_for_disconnect= 1;\n    else\n      maria_55_started= 1;\n  }\n  else\n  {\n    /* Started MySQL. */\n    if (serv_ver[0] == '5' && serv_ver[2] == '5')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc <= 10)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v8;\n      }\n      else if (sc < 14)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v13;\n      }\n    }\n    else if (serv_ver[0] == '5' && serv_ver[2] == '6')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc >= 24)\n        use_event_data_for_disconnect= 1;\n    }\n    else if ((serv_ver[0] == '5' && serv_ver[2] == '7') ||\n             (serv_ver[0] == '8' && serv_ver[2] == '0'))\n    {\n      mysql_57_started= 1;\n      _mysql_plugin_declarations_[0].info= mysql_v4_descriptor;\n      use_event_data_for_disconnect= 1;\n    }\n    MYSQL_SYSVAR_NAME(loc_info).flags= PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL |\n      PLUGIN_VAR_READONLY | PLUGIN_VAR_MEMALLOC;\n  }\n\n  memset(locinfo_ini_value, 'O', sizeof(locinfo_ini_value)-1);\n  locinfo_ini_value[sizeof(locinfo_ini_value)-1]= 0;\n\nexit:\n#ifdef _WIN32\n  return 1;\n#else\n  return;\n#endif\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-common/client_plugin.c": "/* Copyright (C) 2010 Sergei Golubchik and Monty Program Ab\n   Copyright (c) 2010, 2011, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#if _MSC_VER\n/* Silence warnings about variable 'unused' being used. */\n#define FORCE_INIT_OF_VARS 1\n#endif\n\n#include <my_global.h>\n#include \"mysql.h\"\n#include <my_sys.h>\n#include <m_string.h>\n#include <my_pthread.h>\n\n#include <sql_common.h>\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MEM_ROOT mem_root;\n\n#define plugin_declarations_sym \"_mysql_client_plugin_declaration_\"\n\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS]=\n{\n  0, /* these two are taken by Connector/C */\n  0, /* these two are taken by Connector/C */\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic mysql_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  DBUG_ENTER(\"is_not_initialized\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                           unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                           name, \"not initialized\");\n  DBUG_RETURN(1);\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nfind_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n  DBUG_ENTER(\"find_plugin\");\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n    DBUG_RETURN(0);\n\n  for (p= plugin_list[type]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      DBUG_RETURN(p->plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n  DBUG_ENTER(\"add_plugin\");\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) >\n       (plugin_version[plugin->type] >> 8))\n  {\n    errmsg= \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    memdup_root(&mem_root, &plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n  mysql_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next= plugin_list[plugin->type];\n  plugin_list[plugin->type]= p;\n  net_clear_error(&mysql->net);\n\n  DBUG_RETURN(plugin);\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle)\n    (void)dlclose(dlhandle);\n  DBUG_RETURN(NULL);\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n  DBUG_ENTER(\"load_env_plugins\");\n\n  /* no plugins to load */\n  if (!s)\n    DBUG_VOID_RETURN;\n\n  free_env= plugs= my_strdup(s, MYF(MY_WME));\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  my_free(free_env);\n  DBUG_VOID_RETURN;\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occurred\n*/\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n  va_list unused;\n  DBUG_ENTER(\"mysql_client_plugin_init\");\n  LINT_INIT_STRUCT(unused);\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  bzero(&mysql, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  mysql_mutex_init(0, &LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  init_alloc_root(&mem_root, 128, 128, MYF(0));\n\n  bzero(&plugin_list, sizeof(plugin_list));\n\n  initialized= 1;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, unused);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  DBUG_RETURN(0);\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n  DBUG_ENTER(\"mysql_client_plugin_deinit\");\n\n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        (void)dlclose(p->dlhandle);\n    }\n\n  bzero(&plugin_list, sizeof(plugin_list));\n  initialized= 0;\n  free_root(&mem_root, MYF(0));\n  mysql_mutex_destroy(&LOCK_load_client_plugin);\n  DBUG_VOID_RETURN;\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  va_list unused;\n  DBUG_ENTER(\"mysql_client_register_plugin\");\n  LINT_INIT_STRUCT(unused);\n\n  if (is_not_initialized(mysql, plugin->name))\n    DBUG_RETURN(NULL);\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, unused);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_RETURN(plugin);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  DBUG_ENTER(\"mysql_load_plugin_v\");\n\n  DBUG_PRINT (\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name))\n  {\n    DBUG_PRINT (\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN (NULL);\n  }\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1,\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n           name, SO_EXT, NullS);\n   \n  DBUG_PRINT (\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))\n  {\n    DBUG_PRINT (\"info\", (\"failed to dlopen\"));\n    errmsg= dlerror();\n    goto err;\n  }\n\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    goto errc;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto errc;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto errc;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto errc;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT (\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN (plugin);\n\nerrc:\n  dlclose(dlhandle);\nerr:\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT (\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN (NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  DBUG_ENTER(\"mysql_load_plugin\");\n\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  DBUG_RETURN(p);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n  DBUG_ENTER(\"mysql_client_find_plugin\");\n\n  DBUG_PRINT (\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name))\n    DBUG_RETURN (NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                             \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n  {\n    DBUG_PRINT (\"leave\", (\"found %p\", p));\n    DBUG_RETURN (p);\n  }\n\n  /* not found, load it */\n  p= mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT (\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN (p);\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                                 const char *option,\n                                 const void *value)\n{\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options)\n    DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2015, Oracle and/or its affiliates.\n# Copyright (c) 2008, 2017, MariaDB\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation; version 2\n# of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{  \n   somewhere in ld.so, when loading mysqld\n   Memcheck:Cond\n   ...\n   fun:dl_main\n   fun:_dl_sysdep_start\n   fun:_dl_start\n}\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz longest_match called from btr_store_big_rec_extern_fields\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields\n}\n\n{\n   libz longest_match called from page_zip_compress\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   libz longest_match2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match 3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzclose\n}\n\n{\n   libz longest_match 4 \n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azclose\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz inflatereset2\n   Memcheck:Cond\n   fun:inflateReset2\n   fun:inflateInit2_\n   fun:uncompress\n}\n\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# dl_init reports leaked memory in memalign on OpenSuse 12.3\n\n{\n   memory \"loss\" from _dl_init\n   Memcheck:Leak\n   fun:memalign\n   ...\n   fun:call_init*\n   fun:_dl_init\n}\n\n# This one is on OpenSuse 10.3 with gcc 5.4\n{\n   memory \"loss\" from _dl_init 2\n   Memcheck:Leak\n   fun:malloc\n   fun:pool\n   ...\n   fun:call_init*\n   fun:_dl_init\n}\n\n#\n#  dlclose can allocate memory for error message, the memory will be\n#  freed by dlerror or other dl* function.\n#\n{\n   memory \"loss\" from dlclose error messages\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:dlclose\n}\n\n\n#\n#  dlsym can allocate memory for error message, the memory will be\n#  freed by dlerror or other dl* function.\n#\n{\n   memory \"loss\" from dlclose error messages\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:dlsym\n}\n\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit ver 1\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit ver 2\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n\n#\n# Reading wrong addresses on SuSe Linux 10.3 32 bit\n#\n\n{\n   Reading wrong data in libc_dlopen\n   Memcheck:Addr4\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc do_lookup_x\n   Memcheck:Leak\n   fun:calloc\n   fun:do_lookup_x\n   fun:_dl_lookup_symbol_x\n   ...\n   fun:_dl_catch_error \n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n{\n   Aria checkpoint background thread not dying fast enough\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:ma_checkpoint_background\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n#\n# In glibc (checked version 2.7), inet_ntoa allocates an 18-byte\n# per-thread static buffer for the return value. That memory is freed\n# at thread exit, however if called from the main thread, Valgrind\n# does not see the free (test main.no-threads).\n#\n# Since inet_ntoa() does not allocate memory dynamically per-call, this\n# suppression is safe.\n#\n\n{\n   inet_ntoa thread local storage\n   Memcheck:Leak\n   fun:malloc\n   fun:inet_ntoa\n}\n\n\n#\n# Some problem inside glibc on Ubuntu 9.04, x86 (but not amd64):\n# \n# ==5985== 19 bytes in 1 blocks are still reachable in loss record 1 of 6\n# ==5985==    at 0x7AF3FDE: malloc (vg_replace_malloc.c:207) \n#               ... 11,12, or 13 functions w/o symbols ...\n# ==5985==    by 0x8717185: nptl_pthread_exit_hack_handler (my_thr_init.c:55)\n#\n# Since valgrind 3.3.0 doesn't support '...' multi-function pattern, using\n# multiple suppressions:\n#\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n#\n# BUG#45630\n# Suppress valgrind failures within nptl_pthread_exit_hack_handler on Ubuntu 9.04, x86 (but not amd64)\n#\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 1\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 2\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 3\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 4\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 5\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n#\n# Problem with glibc and gethostbyaddr_r\n#\n\n{\n   libc_res_nsend: Conditional jump or move depends on uninitialised value\n   Memcheck:Cond\n   fun: __libc_res_nsend\n   fun: __libc_res_nquery\n   obj: /lib64/libnss_dns-*so)\n   obj: /lib64/libnss_dns-*so)\n   fun: gethostbyaddr_r\n}\n\n# suppressions for glibc 2.6.1 64 bit\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 6\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 7\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Invalid read within nptl_pthread_exit_hack_handler\n   Memcheck:Addr8\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   memory \"leak\" in backtrace() of glibc 2.9 (not present in 2.13)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:pthread_once\n   fun:backtrace\n}\n\n{\n   memory leak in mysqld_exit\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n}\n\n#\n# Bug in Glibc 2.9: http://sourceware.org/bugzilla/show_bug.cgi?id=10391\n# Fixed in latest Glibc, but suppressed here for running tests on hosts\n# with older Glibc version.\n#\n{\n   Glibc bug in __libc_res_nsend\n   Memcheck:Cond\n   fun:__libc_res_nsend\n   fun:__libc_res_nquery\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' and\n# 'fun:find_all_keys' which *may* be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_my_b_write\n   fun:_Z*10write_keysP13st_sort_paramPPhjP11st_io_cacheS4_\n   ...\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / two\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z15merge_many_buffP13st_sort_paramPhP10st_buffpekPjP11st_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:*libssl*\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   obj:*libssl*\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   libcrypto 2.2.1 leak\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:ERR_get_state\n}\n\n{\n  Problem with udf and libresolve\n  Memcheck:Cond\n   obj:*/libresolv*.so\n   fun:__libc_res_nquery\n   fun:_nss_dns_gethostbyaddr2_r\n   fun:_nss_dns_gethostbyaddr_r\n   fun:gethostbyaddr_r\n}\n\n#\n# Detached threads may not complete deiniitialization by the time shutdown\n# thread calls exit. This is unfortunate property of detached threads, which\n# we currently can only ignore. Unfortunately there is no way to distinguish\n# between false positives generated by detached threads and real memory leaks\n# generated by not joined joinable threads. So we hide both cases.\n#\n# To avoid enumeration of the whole variety of possible traces we ignore all\n# \"possibly lost\" blocks allocated by pthread_create (and it's callees).\n#\n{\n   Detached threads memory loss\n   Memcheck:Leak\n   match-leak-kinds:possible\n   ...\n   fun:pthread_create*\n}\n\n{\n   Memory Leak in loader and valgrind malloc\n   Memcheck:Leak\n   match-leak-kinds:reachable\n   obj:*/vgpreload_memcheck*.so\n   ...\n   obj:*/ld-*.so\n   ...\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   fun:strdup\n   ...\n   obj:*/libodbc.so*\n   fun:_ZN7ODBConn10GetDriversEP7_qryres\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:calloc\n   ...\n   obj:*/libodbc.so*\n   fun:_ZN7ODBConn10GetDriversEP7_qryres\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leavs some \"still reachable\" pointers\n  Memcheck:Leak\n  fun:malloc\n  fun:strdup\n  ...\n  obj:*/libodbc.so*\n  fun:_ZN7ODBConn14GetDataSourcesEP7_qryres\n}\n\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leavs some \"still reachable\" pointers\n  Memcheck:Leak\n  fun:calloc\n  ...\n  obj:*/libodbc.so*\n  fun:_ZN7ODBConn14GetDataSourcesEP7_qryres\n}\n\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   fun:strdup\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:calloc\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC dlopen leaves some \"still reachable\"\n  Memcheck:Leak\n  fun:malloc\n  fun:expand_dynamic_string_token\n  ...\n  obj:*/libltdl.so*\n  ...\n  obj:*/libodbc.so*\n}\n\n{\n  XtraDB uses gcc __thread variables\n  Memcheck:Leak\n  fun:memalign\n  fun:*\n  fun:__tls_get_addr\n}\n\n{\n  Mroonga: dlopen leaves some \"still reachable\"\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:dl_open_worker\n  fun:_dl_catch_error\n  fun:_dl_open\n  fun:dlopen_doit\n  fun:_dl_catch_error\n  fun:_dlerror_run\n  fun:dlopen@@GLIBC_2.2.5\n}\n\n# \n# MDEV-11061: OpenSSL 0.9.8 problems\n#\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:is_overlap\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread-2.9.so*\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n  vasprintf in OpenSuse 12.3\n  Memcheck:Leak\n  fun:malloc\n  fun:vasprintf\n  fun:asprintf\n  fun:dlerror\n}\n\n{\n   GitHub codership/galera#330\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/usr/lib64/libssl.so.1.0.1e\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_initC1Ev\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_init8instanceEv\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EEC1Ev\n   fun:_Z41__static_initialization_and_destruction_0ii.constprop.120\n   fun:call_init.part.0\n   fun:_dl_init\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n}\n{\n   GitHub codership/galera#330\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/usr/lib64/libssl.so.1.0.1e\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_initC1Ev\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_init8instanceEv\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EEC1Ev\n   fun:_Z41__static_initialization_and_destruction_0ii.constprop.120\n   fun:call_init.part.0\n   fun:_dl_init\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n}\n\n{\n   GitHub codership/mysql-wsrep#175\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:do_lookup_x\n   fun:_dl_lookup_symbol_x\n   fun:_dl_relocate_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:wsrep_load\n   fun:_Z10wsrep_initv\n   fun:_Z18wsrep_init_startupb\n   fun:_ZL22init_server_componentsv\n   fun:_Z11mysqld_mainiPPc\n}\n\n{\n   galera/mysql-wsrep#147\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:_ZNK6galera13ReplicatorSMM9stats_getEv\n   fun:_ZL28export_wsrep_status_to_mysqlP3THD\n   fun:_Z17wsrep_show_statusP3THDP17st_mysql_show_varPc\n   fun:_ZL17show_status_arrayP3THDPKcP17st_mysql_show_var13enum_var_typeP17system_status_varS2_P5TABLEbP4Item\n   fun:_Z11fill_statusP3THDP10TABLE_LISTP4Item\n   fun:_ZL13do_fill_tableP3THDP10TABLE_LISTP13st_join_table\n   fun:_Z24get_schema_tables_resultP4JOIN23enum_schema_table_state\n   fun:_ZN4JOIN14prepare_resultEPP4ListI4ItemE\n   fun:_ZN4JOIN4execEv\n   fun:_ZL20mysql_execute_selectP3THDP13st_select_lexb\n   fun:_Z12mysql_selectP3THDP10TABLE_LISTjR4ListI4ItemEPS4_P10SQL_I_ListI8st_orderESB_S7_yP13select_resultP18st_select_lex_unitP13st_select_lex\n   fun:_Z13handle_selectP3THDP13select_resultm\n   fun:_ZL21execute_sqlcom_selectP3THDP10TABLE_LIST\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:ListParse\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:state_map_insert\n   fun:code_state\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:StrDup\n   fun:ListParse\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:code_state\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n   fun:handle_one_connection\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:PushState\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/galera#331\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:state_map_insert\n   fun:code_state\n   fun:_gu_db_keyword_\n   fun:_ZN6galera3ist6Sender4sendEll\n   fun:run_async_sender\n   fun:start_thread\n   fun:clone\n}\n\n{\n   codership/galera#331\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:code_state\n   fun:_gu_db_keyword_\n   fun:_ZN6galera3ist6Sender4sendEll\n   fun:run_async_sender\n   fun:start_thread\n   fun:clone\n}\n\n# \n# MDEV-11061: OpenSSL 0.9.8 problems\n#\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:is_overlap\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread-2.9.so*\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/include/ma_global.h": "/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not, write to the Free\n   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n   MA 02111-1301, USA */\n\n/* This is the main include file that should included 'first' in every\n   C file. */\n\n#ifndef _global_h\n#define _global_h\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <Windows.h>\n#include <stdlib.h>\n#define strcasecmp _stricmp\n#define sleep(x) Sleep(1000*(x))\n#ifdef _MSC_VER\n#define inline __inline\n#if _MSC_VER < 1900\n#define snprintf _snprintf\n#endif\n#endif\n#define STDCALL __stdcall \n#endif\n\n#include <ma_config.h>\n#include <assert.h>\n#ifndef __GNUC__\n#define  __attribute(A)\n#endif\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(HAVE_LINUXTHREADS)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/* The client defines this to avoid all thread code */\n#if defined(UNDEF_THREADS_HACK)\n#undef THREAD\n#undef HAVE_mit_thread\n#undef HAVE_LINUXTHREADS\n#undef HAVE_UNIXWARE7_THREADS\n#endif\n\n#ifdef HAVE_THREADS_WITHOUT_SOCKETS\n/* MIT pthreads does not work with unix sockets */\n#undef HAVE_SYS_UN_H\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n#if defined(THREAD) && !defined(_WIN32)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n/* was #if defined(HAVE_LINUXTHREADS) || defined(HAVE_DEC_THREADS) || defined(HPUX) */\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#ifndef HAVE_mit_thread\n#ifdef HAVE_UNIXWARE7_THREADS\n#include <thread.h>\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif /* HAVE_UNIXWARE7_THREADS */\n#endif /* HAVE_mit_thread */\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* THREAD */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n#define _AIX32_CURSES\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\ndouble my_ulonglong2double(unsigned long long A);\n#ifdef\t__cplusplus\n}\n#endif\n#endif /* _AIX */\n\n#ifdef HAVE_BROKEN_SNPRINTF\t/* HPUX 10.20 don't have this defined */\n#undef HAVE_SNPRINTF\n#endif\n#ifdef HAVE_BROKEN_PREAD\t/* These doesn't work on HPUX 11.x */\n#undef HAVE_PREAD\n#undef HAVE_PWRITE\n#endif\n#if defined(HAVE_BROKEN_INLINE) && !defined(__cplusplus)\n#undef inline\n#define inline\n#endif\n\n#ifdef UNDEF_HAVE_GETHOSTBYNAME_R\t\t/* For OSF4.x */\n#undef HAVE_GETHOSTBYNAME_R\n#endif\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* Fix a bug in gcc 2.8.0 on IRIX 6.2 */\n#if SIZEOF_LONG == 4 && defined(__LONG_MAX__)\n#undef __LONG_MAX__             /* Is a longlong value in gcc 2.8.0 ??? */\n#define __LONG_MAX__ 2147483647\n#endif\n\n/* Fix problem when linking c++ programs with gcc 3.x */\n#ifdef DEFINE_CXA_PURE_VIRTUAL\n#define FIX_GCC_LINKING_PROBLEM extern \"C\" { int __cxa_pure_virtual() {return 0;} }\n#else\n#define FIX_GCC_LINKING_PROBLEM\n#endif\n\n/* egcs 1.1.2 has a problem with memcpy on Alpha */\n#if defined(__GNUC__) && defined(__alpha__) && ! (__GNUC__ > 2 || (__GNUC__ == 2 &&  __GNUC_MINOR__ >= 95))\n#define BAD_MEMCPY\n#endif\n\n/* In Linux-alpha we have atomic.h if we are using gcc */\n#if defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && defined(__alpha__) && (__GNUC__ > 2 || ( __GNUC__ == 2 &&  __GNUC_MINOR__ >= 95)) && !defined(HAVE_ATOMIC_ADD)\n#define HAVE_ATOMIC_ADD\n#define HAVE_ATOMIC_SUB\n#endif\n\n/* In Linux-ia64 including atomic.h will give us an error */\n#if (defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && (defined(__ia64__) || defined(__powerpc64__))) || !defined(THREAD)\n#undef HAVE_ATOMIC_ADD\n#undef HAVE_ATOMIC_SUB\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_ATOMIC_ADD\n#define __SMP__\n#define CONFIG_SMP\n#include <asm/atomic.h>\n#endif\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n#include <assert.h>\n\n/* Go around some bugs in different OS and compilers */\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#ifdef DONT_USE_FINITE\t\t/* HPUX 11.x has is_finite() */\n#undef HAVE_FINITE\n#endif\n#if defined(HPUX) && defined(_LARGEFILE64_SOURCE) && defined(THREAD)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n\n/* We can not live without these */\n\n#define USE_MYFUNC 1\t\t/* Must use syscall indirection */\n#define MASTER 1\t\t/* Compile without unireg */\n#define ENGLISH 1\t\t/* Messages in English */\n#define POSIX_MISTAKE 1\t\t/* regexp: Fix stupid spec error */\n#define USE_REGEX 1\t\t/* We want the use the regex library */\n/* Do not define for ultra sparcs */\n#define USE_BMOVE512 1\t\t/* Use this unless the system bmove is faster */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* #define USE_some_charset 1 was deprecated by changes to configure */\n/* my_ctype my_to_upper, my_to_lower, my_sort_order gain theit right value */\n/* automagically during configuration */\n\n/* Does the system remember a signal handler after a signal ? */\n#ifndef HAVE_BSD_SIGNALS\n#define DONT_REMEMBER_SIGNAL\n#endif\n\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define LINT_INIT(var)\tvar=0\t\t\t/* No uninitialize-warning */\n#define LINT_INIT_STRUCT(var) memset(&var, 0, sizeof(var)) /* No uninitialize-warning */\n#else\n#define LINT_INIT(var)\n#define LINT_INIT_STRUCT(var)\n#endif\n\n/* Define some useful general macros */\n#if defined(__cplusplus) && defined(__GNUC__)\n#define max(a, b)\t((a) >? (b))\n#define min(a, b)\t((a) <? (b))\n#elif !defined(max)\n#define max(a, b)\t((a) > (b) ? (a) : (b))\n#define min(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n\n#if defined(__EMX__) || !defined(HAVE_UINT)\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define sgn(a)\t\t(((a) < 0) ? -1 : ((a) > 0) ? 1 : 0)\n#define swap(t,a,b)\t{ register t dummy; dummy = a; a = b; b = dummy; }\n#define test(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  { if ((a) < (b)) (a)=(b); }\n#define set_if_smaller(a,b) { if ((a) > (b)) (a)=(b); }\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n#ifndef HAVE_RINT\n#define rint(A) floor((A)+0.5)\n#endif\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#if defined(__GNUC__)\n#define function_volatile\tvolatile\n#ifndef my_reinterpret_cast\n#define my_reinterpret_cast(A) reinterpret_cast<A>\n#endif\n#define my_const_cast(A) const_cast<A>\n#elif !defined(my_reinterpret_cast)\n#define my_reinterpret_cast(A) (A)\n#define my_const_cast(A) (A)\n#endif\n#if !defined(__attribute__) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)\n#define __attribute__(A)\n#endif\n\n/* From old s-system.h */\n\n/*\n  Support macros for non ansi & other old compilers. Since such\n  things are no longer supported we do nothing. We keep then since\n  some of our code may still be needed to upgrade old customers.\n*/\n#define _VARARGS(X) X\n#define _STATIC_VARARGS(X) X\n\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n#if defined(_lint) && !defined(DBUG_OFF)\n#define DBUG_OFF\n#endif\n\n#define MIN_ARRAY_SIZE\t0\t/* Zero or One. Gcc allows zero*/\n#define ASCII_BITS_USED 8\t/* Bit char used */\n#define NEAR_F\t\t\t/* No near function handling */\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifndef my_socket_defined\n#define my_socket_defined\n#if defined(_WIN64)\n#define my_socket unsigned long long\n#elif defined(_WIN32)\n#define my_socket unsigned int\n#else\ntypedef int my_socket;\n#endif\n#define my_socket_defined\n#endif\n#ifndef INVALID_SOCKET\n#define INVALID_SOCKET -1\n#endif\n/* Type for fuctions that handles signals */\n#define sig_handler RETSIGTYPE\ntypedef void\t(*sig_return)(void);/* Returns type from signal */\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\ntypedef int\t(*qsort_cmp)(const void *,const void *);\n#ifdef HAVE_mit_thread\n#define qsort_t void\n#undef QSORT_TYPE_IS_VOID\n#define QSORT_TYPE_IS_VOID\n#else\n#define qsort_t RETQSORTTYPE\t/* Broken GCC cant handle typedef !!!! */\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#define FILE_BINARY\t0\t/* Flag to my_fopen for binary streams */\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n\n/* #define USE_RECORD_LOCK\t*/\n\n\t/* Unsigned types supported by the compiler */\n#define UNSINT8\t\t\t/* unsigned int8 (char) */\n#define UNSINT16\t\t/* unsigned int16 */\n#define UNSINT32\t\t/* unsigned int32 */\n\n\t/* General constants */\n#define SC_MAXWIDTH\t256\t/* Max width of screen (for error messages) */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parentdirectory; Must be a string */\n#define FN_DEVCHAR\t':'\n\n#ifndef FN_LIBCHAR\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_ROOTDIR\t\"\\\\\"\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_ROOTDIR\t\"/\"\n#endif\n#define MY_NFILE\t1024\t/* This is only used to save filenames */\n#endif\n\n/* #define EXT_IN_LIBNAME     */\n/* #define FN_NO_CASE_SENCE   */\n/* #define FN_UPPER_CASE TRUE */\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024-MALLOC_OVERHEAD)\n\n\t/* Some things that this system doesn't have */\n\n#define ONLY_OWN_DATABASES\t/* We are using only databases by monty */\n#define NO_PISAM\t\t/* Not needed anymore */\n#define NO_MISAM\t\t/* Not needed anymore */\n#define NO_HASH\t\t\t/* Not needed anymore */\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standar dir-library */\n#define USE_MY_STAT_STRUCT\t/* For my_lib */\n#ifdef _MSC_VER\ntypedef SSIZE_T ssize_t;\n#endif\n#endif\n\n/* Some things that this system does have */\n\n#ifndef HAVE_ITOA\n#define USE_MY_ITOA\t\t/* There is no itoa */\n#endif\n\n/* Some defines of functions for portability */\n\n#ifndef HAVE_ATOD\n#define atod\t\tatof\n#endif\n#ifdef USE_MY_ATOF\n#define atof\t\tmy_atof\nextern void\t\tinit_my_atof(void);\nextern double\t\tmy_atof(const char*);\n#endif\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef _WIN32\n#define closesocket(A)\tclose(A)\n#endif\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (A))\n#define my_off_t2double(A)  ((double) (A))\n#endif\n\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n#define SET_STACK_SIZE(X)\t/* Not needed on real machines */\n\n#if !defined(HAVE_mit_thread) && !defined(HAVE_STRTOK_R)\n#define strtok_r(A,B,C) strtok((A),(B))\n#endif\n\n#ifdef HAVE_LINUXTHREADS\n/* #define pthread_sigmask(A,B,C) sigprocmask((A),(B),(C)) */\n/* #define sigset(A,B) signal((A),(B)) */\n#endif\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    defined(__cplusplus) || !defined(__GNUC__)\n#define UNINIT_VAR(x) x= 0\n#else\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#endif\n\n/* Remove some things that mit_thread break or doesn't support */\n#if defined(HAVE_mit_thread) && defined(THREAD)\n#undef HAVE_PREAD\n#undef HAVE_REALPATH\n#undef HAVE_MLOCK\n#undef HAVE_TEMPNAM\t\t\t\t/* Use ours */\n#undef HAVE_PTHREAD_SETPRIO\n#undef HAVE_FTRUNCATE\n#undef HAVE_READLINK\n#endif\n\n/* This is from the old m-machine.h file */\n\n#if SIZEOF_LONG_LONG > 4\n#define HAVE_LONG_LONG 1\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n#ifndef ULL\n#ifdef HAVE_LONG_LONG\n#define ULL(A) A ## ULL\n#else\n#define ULL(A) A ## UL\n#endif\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  adressable obj.\n*/\ntypedef long my_ptrdiff_t;\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make adressable obj. */\n#define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A),sizeof(t)))\n\t\t\t /* Offset of filed f in structure t */\n#define OFFSET(t, f)\t((size_t)(char *)&((t *)0)->f)\n#define ADD_TO_PTR(ptr,size,type) (type) ((unsigned char*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((unsigned char*) (A) - (unsigned char*) (B))\n\n#define NullS\t\t(char *) 0\n/* Nowdays we do not support MessyDos */\n#ifndef NEAR\n#define NEAR\t\t\t\t/* Who needs segments ? */\n#define FAR\t\t\t\t/* On a good machine */\n#ifndef HUGE_PTR\n#define HUGE_PTR\n#endif\n#endif\n#if defined(__IBMC__) || defined(__IBMCPP__)\n#define STDCALL _System _Export\n#elif !defined( STDCALL)\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#if defined(VOIDTYPE)\ntypedef void\t*gptr;\t\t/* Generic pointer */\n#else\ntypedef char\t*gptr;\t\t/* Generic pointer */\n#endif\n#ifndef HAVE_INT_8_16_32\ntypedef char\tint8;\t\t/* Signed integer >= 8\tbits */\ntypedef short\tint16;\t\t/* Signed integer >= 16 bits */\n#endif\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\ntypedef unsigned char\tuint8;\t/* Short for unsigned integer >= 8  bits */\ntypedef unsigned short\tuint16; /* Short for unsigned integer >= 16 bits */\n\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT_8_16_32\ntypedef int\t\tint32;\n#endif\ntypedef unsigned int\tuint32; /* Short for unsigned integer >= 32 bits */\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT_8_16_32\ntypedef long\t\tint32;\n#endif\ntypedef unsigned long\tuint32; /* Short for unsigned integer >= 32 bits */\n#else\n#error \"Neither int or long is of 4 bytes width\"\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(HAVE_LINUXTHREADS) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t/* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG != 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int longlong;\n#else\ntypedef unsigned long\tulonglong;\t/* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#define longlong_defined\n#endif\n\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#ifndef MIN\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#endif\n#ifndef MAX\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#endif\n#define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)\n#ifdef USE_RAID\n/*\n  The following is done with a if to not get problems with pre-processors\n  with late define evaluation\n*/\n#if SIZEOF_OFF_T == 4\n#define SYSTEM_SIZEOF_OFF_T 4\n#else\n#define SYSTEM_SIZEOF_OFF_T 8\n#endif\n#undef  SIZEOF_OFF_T\n#define SIZEOF_OFF_T\t    8\n#else\n#define SYSTEM_SIZEOF_OFF_T SIZEOF_OFF_T\n#endif /* USE_RAID */\n\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n#ifndef _WIN32\ntypedef off_t os_off_t;\n#endif\n\n#if defined(_WIN32)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR \n#define SOCKET_EAGAIN\tWSAEWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef uint8\t\tint7;\t/* Most effective integer 0 <= x <= 127 */\ntypedef short\t\tint15;\t/* Most effective integer 0 <= x <= 32767 */\ntypedef char\t\t*my_string; /* String of characters */\ntypedef unsigned long\tsize_s; /* Size of strings (In string-funcs) */\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\ntypedef unsigned long long my_ulonglong;\n#if !defined(bool) && !defined(bool_defined) && (!defined(HAVE_BOOL) || !defined(__cplusplus))\ntypedef char\t\tbool;\t/* Ordinary boolean values 0 1 */\n#endif\n\t/* Macros for converting *constants* to the right type */\n#define INT8(v)\t\t(int8) (v)\n#define INT16(v)\t(int16) (v)\n#define INT32(v)\t(int32) (v)\n#define MYF(v)\t\t(myf) (v)\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n/* Defines for time function */\n#define SCALE_SEC\t100\n#define SCALE_USEC\t10000\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n#define NOT_FIXED_DEC 31\n\n#if defined(_WIN32) && defined(_MSVC)\n#define MYSQLND_LLU_SPEC \"%I64u\"\n#define MYSQLND_LL_SPEC \"%I64d\"\n#ifndef L64\n#define L64(x) x##i64\n#endif\n#else\n#define MYSQLND_LLU_SPEC \"%llu\"\n#define MYSQLND_LL_SPEC \"%lld\"\n#ifndef L64\n#define L64(x) x##LL\n#endif /* L64 */\n#endif /* _WIN32 */\n/*\n** Define-funktions for reading and storing in machine independent format\n**  (low byte first)\n*/\n\n/* Optimized store functions for Intel x86 */\n#define int1store(T,A) *((int8*) (T)) = (A)\n#define uint1korr(A)   (*(((uint8*)(A))))\n#if defined(__i386__) || defined(_WIN32)\n#define sint2korr(A)\t(*((int16 *) (A)))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(*((long *) (A)))\n#define uint2korr(A)\t(*((uint16 *) (A)))\n#if defined(HAVE_purify) && !defined(_WIN32)\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#else\n/*\n   ATTENTION !\n   \n    Please, note, uint3korr reads 4 bytes (not 3) !\n    It means, that you have to provide enough allocated space !\n*/\n#define uint3korr(A)\t(long) (*((unsigned int *) (A)) & 0xFFFFFF)\n#endif /* HAVE_purify && !_WIN32 */\n#define uint4korr(A)\t(*((uint32 *) (A)))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t(*((ulonglong *) (A)))\n#define sint8korr(A)\t(*((longlong *) (A)))\n#define int2store(T,A)\t*((uint16*) (T))= (uint16) (A)\n#define int3store(T,A)  do { *(T)=  (uchar) ((A));\\\n                            *(T+1)=(uchar) (((uint) (A) >> 8));\\\n                            *(T+2)=(uchar) (((A) >> 16)); } while (0)\n#define int4store(T,A)\t*((long *) (T))= (long) (A)\n#define int5store(T,A)  do { *(T)= (uchar)((A));\\\n                             *((T)+1)=(uchar) (((A) >> 8));\\\n                             *((T)+2)=(uchar) (((A) >> 16));\\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)\n#define int6store(T,A)  do { *(T)=    (uchar)((A));          \\\n                             *((T)+1)=(uchar) (((A) >> 8));  \\\n                             *((T)+2)=(uchar) (((A) >> 16)); \\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); \\\n                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)\n#define int8store(T,A)\t*((ulonglong *) (T))= (ulonglong) (A)\n\ntypedef union {\n  double v;\n  long m[2];\n} doubleget_union;\n#define doubleget(V,M)\t\\\ndo { doubleget_union _tmp; \\\n     _tmp.m[0] = *((long*)(M)); \\\n     _tmp.m[1] = *(((long*) (M))+1); \\\n     (V) = _tmp.v; } while(0)\n#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \\\n\t\t\t     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \\\n                         } while (0)\n#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)\n#define float8get(V,M)   doubleget((V),(M))\n#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))\n#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))\n#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))\n#define float8store(V,M) doublestore((V),(M))\n#else\n\n/*\n  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines\n  were done before)\n*/\n#define sint2korr(A)\t(int16) (((int16) ((uchar) (A)[0])) +\\\n\t\t\t\t ((int16) ((int16) (A)[1]) << 8))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(int32) (((int32) ((uchar) (A)[0])) +\\\n\t\t\t\t(((int32) ((uchar) (A)[1]) << 8)) +\\\n\t\t\t\t(((int32) ((uchar) (A)[2]) << 16)) +\\\n\t\t\t\t(((int32) ((int16) (A)[3]) << 24)))\n#define sint8korr(A)\t(longlong) uint8korr(A)\n#define uint2korr(A)\t(uint16) (((uint16) ((uchar) (A)[0])) +\\\n\t\t\t\t  ((uint16) ((uchar) (A)[1]) << 8))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[3])) << 24))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t(((ulonglong) (((uint32) ((uchar) (A)[4])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[5])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[6])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[7])) << 24))) <<\\\n\t\t\t\t    32))\n#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\\\n                                  *((uchar*) (T))=  (uchar)(def_temp); \\\n                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \\\n                             } while(0)\n#define int3store(T,A)       do { /*lint -save -e734 */\\\n                                  *((uchar*)(T))=(uchar) ((A));\\\n                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\\\n                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \\\n                                  /*lint -restore */} while(0)\n#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\\\n                                  *(((char *)(T))+1)=(char) (((A) >> 8));\\\n                                  *(((char *)(T))+2)=(char) (((A) >> 16));\\\n                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)\n#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n\t\t                } while(0)\n#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \\\n                                } while(0)\n#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \\\n                                  int4store((T),def_temp); \\\n                                  int4store((T+4),def_temp2); } while(0)\n#ifdef HAVE_BIGENDIAN\n#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\\\n                              *((T)+1)=(char) ((uchar *) &A)[2];\\\n                              *((T)+2)=(char) ((uchar *) &A)[1];\\\n                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)\n\n#define float4get(V,M)   do { float def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[3];\\\n                              ((uchar*) &def_temp)[1]=(M)[2];\\\n                              ((uchar*) &def_temp)[2]=(M)[1];\\\n                              ((uchar*) &def_temp)[3]=(M)[0];\\\n                              (V)=def_temp; } while(0)\n#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\\\n                              *((T)+1)=(char) ((uchar *) &V)[6];\\\n                              *((T)+2)=(char) ((uchar *) &V)[5];\\\n                              *((T)+3)=(char) ((uchar *) &V)[4];\\\n                              *((T)+4)=(char) ((uchar *) &V)[3];\\\n                              *((T)+5)=(char) ((uchar *) &V)[2];\\\n                              *((T)+6)=(char) ((uchar *) &V)[1];\\\n                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)\n\n#define float8get(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[7];\\\n                              ((uchar*) &def_temp)[1]=(M)[6];\\\n                              ((uchar*) &def_temp)[2]=(M)[5];\\\n                              ((uchar*) &def_temp)[3]=(M)[4];\\\n                              ((uchar*) &def_temp)[4]=(M)[3];\\\n                              ((uchar*) &def_temp)[5]=(M)[2];\\\n                              ((uchar*) &def_temp)[6]=(M)[1];\\\n                              ((uchar*) &def_temp)[7]=(M)[0];\\\n                              (V) = def_temp; } while(0)\n#else\n#define float4get(V,M)   memcpy(&V, (M), sizeof(float))\n#define float4store(V,M) memcpy(V, (&M), sizeof(float))\n\n#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)\n#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\\\n                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\\\n                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\\\n                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\\\n                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\\\n                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\\\n                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\\\n                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\\\n                         while(0)\n#define doubleget(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[4];\\\n                              ((uchar*) &def_temp)[1]=(M)[5];\\\n                              ((uchar*) &def_temp)[2]=(M)[6];\\\n                              ((uchar*) &def_temp)[3]=(M)[7];\\\n                              ((uchar*) &def_temp)[4]=(M)[0];\\\n                              ((uchar*) &def_temp)[5]=(M)[1];\\\n                              ((uchar*) &def_temp)[6]=(M)[2];\\\n                              ((uchar*) &def_temp)[7]=(M)[3];\\\n                              (V) = def_temp; } while(0)\n#endif /* __FLOAT_WORD_ORDER */\n\n#define float8get(V,M)   doubleget((V),(M))\n#define float8store(V,M) doublestore((V),(M))\n#endif /* WORDS_BIGENDIAN */\n\n#endif /* __i386__ OR _WIN32 */\n\n/*\n  Macro for reading 32-bit integer from network byte order (big-endian)\n  from unaligned memory location.\n*/\n#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 8)  |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 16) |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[0])) << 24))\n/*\n  Define-funktions for reading and storing in machine format from/to\n  short/long to/from some place in memory V should be a (not\n  register) variable, M is a pointer to byte\n*/\n\n#ifdef HAVE_BIGENDIAN\n\n#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\\\n                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)\n#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\\\n                                 ((short) ((short) (M)[0]) << 8)); } while(0)\n#define longget(V,M)    do { int32 def_temp;\\\n                             ((uchar*) &def_temp)[0]=(M)[0];\\\n                             ((uchar*) &def_temp)[1]=(M)[1];\\\n                             ((uchar*) &def_temp)[2]=(M)[2];\\\n                             ((uchar*) &def_temp)[3]=(M)[3];\\\n                             (V)=def_temp; } while(0)\n#define ulongget(V,M)   do { uint32 def_temp;\\\n                            ((uchar*) &def_temp)[0]=(M)[0];\\\n                            ((uchar*) &def_temp)[1]=(M)[1];\\\n                            ((uchar*) &def_temp)[2]=(M)[2];\\\n                            ((uchar*) &def_temp)[3]=(M)[3];\\\n                            (V)=def_temp; } while(0)\n#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\\\n                             *(((char*)T)+1)=(char)(def_temp); \\\n                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)\n#define longstore(T,A)  do { *(((char*)T)+3)=((A));\\\n                             *(((char*)T)+2)=(((A) >> 8));\\\n                             *(((char*)T)+1)=(((A) >> 16));\\\n                             *(((char*)T)+0)=(((A) >> 24)); } while(0)\n\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#else\n\n#define ushortget(V,M)\tdo { V = uint2korr(M); } while(0)\n#define shortget(V,M)\tdo { V = sint2korr(M); } while(0)\n#define longget(V,M)\tdo { V = sint4korr(M); } while(0)\n#define ulongget(V,M)   do { V = uint4korr(M); } while(0)\n#define shortstore(T,V) int2store(T,V)\n#define longstore(T,V)\tint4store(T,V)\n#ifndef floatstore\n#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#endif\n#ifndef doubleget\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#endif /* doubleget */\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifndef THREAD\n#define thread_safe_increment(V,L) (V)++\n#define thread_safe_add(V,C,L)     (V)+=(C)\n#define thread_safe_sub(V,C,L)     (V)-=(C)\n#define statistic_increment(V,L)   (V)++\n#define statistic_add(V,C,L)       (V)+=(C)\n#endif\n\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#else\n#define SO_EXT \".so\"\n#endif\n\n#ifndef DBUG_OFF\n#define dbug_assert(A) assert(A)\n#define DBUG_ASSERT(A) assert(A)\n#else\n#define dbug_assert(A)\n#define DBUG_ASSERT(A)\n#endif\n\n#ifdef HAVE_DLOPEN\n#ifdef _WIN32\n#define dlsym(lib, name) GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#elif defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n#ifndef HAVE_DLERROR\n#define dlerror() \"\"\n#endif\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef unsigned int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef unsigned long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef unsigned long long intptr;\n#else\n#error sizeof(void *) is not sizeof(int, long or long long)\n#endif\n\n#ifdef _WIN32\n#define IF_WIN(A,B) A \n#else\n#define IF_WIN(A,B) B \n#endif\n\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n\n#endif /* _global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/plugins/auth/dialog.c": "/************************************************************************************\n   Copyright (C) 2014 MariaDB Corporation AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n*************************************************************************************/\n#ifndef _WIN32\n#define _GNU_SOURCE 1\n#endif\n\n#include <ma_global.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <string.h>\n#include <memory.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n\n/* function prototypes */\nextern char *get_tty_password(char *opt_message, char *buff, int bufflen);\nstatic int auth_dialog_open(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql);\nstatic int auth_dialog_init(char *unused1, \n                            size_t unused2, \n                            int unused3, \n                            va_list);\n\nmysql_authentication_dialog_ask_t auth_dialog_func;\n\n#ifndef HAVE_DIALOG_DYNAMIC\nstruct st_mysql_client_plugin_AUTHENTICATION auth_dialog_plugin=\n#else\nstruct st_mysql_client_plugin_AUTHENTICATION _mysql_client_plugin_declaration_ =\n#endif\n{\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN,\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,\n  \"dialog\",\n  \"Sergei Golubchik, Georg Richter\",\n  \"Dialog Client Authentication Plugin\",\n  {0,1,0},\n  \"LGPL\",\n  NULL,\n  auth_dialog_init,\n  NULL,\n  NULL,\n  auth_dialog_open\n};\n\n\n/* {{{ static char *auth_dialog_native_prompt */\n/*\n   Native dialog prompt via stdin\n\n   SYNOPSIS\n     auth_dialog_native_prompt\n     mysql            connection handle\n     type             input type\n     prompt           prompt\n     buffer           Input buffer\n     buffer_len       Input buffer length\n\n  DESCRIPTION\n    \n  RETURNS\n    Input buffer\n*/\nstatic char *auth_dialog_native_prompt(MYSQL *mysql __attribute__((unused)),\n                                       int type,\n                                       const char *prompt,\n                                       char *buffer,\n                                       int buffer_len)\n{\n  /* display prompt */\n  fprintf(stdout, \"%s\", prompt);\n\n  memset(buffer, 0, buffer_len);\n\n  /* for type 2 (password) don't display input */\n  if (type != 2)\n  {\n    if (fgets(buffer, buffer_len - 1, stdin))\n    {\n      /* remove trailing line break */\n      size_t length= strlen(buffer);\n      if (length && buffer[length - 1] == '\\n')\n        buffer[length - 1]= 0;\n    }\n  }\n  else\n  {\n    get_tty_password((char *)\"\", buffer, buffer_len - 1);\n  }\n  return buffer;\n}\n/* }}} */\n\n/* {{{ static int auth_dialog_open */\n/*\n   opens dialog\n\n   SYNOPSIS\n     vio           Vio\n     mysql         connection handle\n\n   DESCRIPTION\n     reads prompt from server, waits for input and sends\n     input to server.\n     Note that first byte of prompt indicates if we have a \n     password which should not be echoed to stdout.\n\n   RETURN\n     CR_ERROR      if an error occurs\n     CR_OK\n     CR_OK_HANDSHAKE_COMPLETE\n*/\nstatic int auth_dialog_open(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)\n{\n  uchar *packet;\n  uchar type= 0;\n  char dialog_buffer[1024];\n  char *response;\n  int packet_length;\n  my_bool first_loop= TRUE;\n\n  do {\n    if ((packet_length= vio->read_packet(vio, &packet)) == -1)\n      /* read error */\n      return CR_ERROR;\n\n    if (packet_length > 0)\n    {\n      type= *packet;\n      packet++;\n\n      /* check for protocol packet */\n      if (!type || type == 254)\n        return CR_OK_HANDSHAKE_COMPLETE;\n\n      if ((type >> 1) == 2 &&\n          first_loop &&\n          mysql->passwd && mysql->passwd[0])\n        response= mysql->passwd;\n      else\n        response= auth_dialog_func(mysql, type >> 1,\n                                  (const char *)packet,\n                                  dialog_buffer, 1024);\n    }\n    else\n    {\n      /* in case mysql_change_user was called the client needs\n         to send packet first */\n      response= mysql->passwd;\n    }\n    if (!response ||\n        vio->write_packet(vio, (uchar *)response, (int)strlen(response) + 1))\n      return CR_ERROR;\n\n    first_loop= FALSE;\n\n  } while((type & 1) != 1);\n  return CR_OK;\n}\n/* }}} */\n\n/* {{{ static int auth_dialog_init */\n/* \n  Initialization routine\n\n  SYNOPSIS\n    auth_dialog_init\n      unused1\n      unused2\n      unused3\n      unused4\n\n  DESCRIPTION\n    Init function checks if the caller provides own dialog function.\n    The function name must be mariadb_auth_dialog or\n    mysql_authentication_dialog_ask. If the function cannot be found,\n    we will use owr own simple command line input.\n\n  RETURN\n    0           success\n*/\nstatic int auth_dialog_init(char *unused1 __attribute__((unused)), \n                            size_t unused2  __attribute__((unused)), \n                            int unused3     __attribute__((unused)), \n                            va_list unused4 __attribute__((unused)))\n{\n  void *func;\n#ifdef WIN32\n  if (!(func= GetProcAddress(GetModuleHandle(NULL), \"mariadb_auth_dialog\")))\n    /* for MySQL users */\n    func= GetProcAddress(GetModuleHandle(NULL), \"mysql_authentication_dialog_ask\");\n#else\n  if (!(func= dlsym(RTLD_DEFAULT, \"mariadb_auth_dialog\")))\n    /* for MySQL users */\n    func= dlsym(RTLD_DEFAULT, \"mysql_authentication_dialog_ask\");\n#endif\n  if (func)\n    auth_dialog_func= (mysql_authentication_dialog_ask_t)func;\n  else\n    auth_dialog_func= auth_dialog_native_prompt;\n\n  return 0;\n}\n/* }}} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/plugins/trace/trace_example.c": "/************************************************************************************\n   Copyright (C) 2015 MariaDB Corporation AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n*************************************************************************************/\n#ifndef _WIN32\n#define _GNU_SOURCE 1\n#endif\n\n#include <ma_global.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <string.h>\n#include <memory.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n#define READ  0\n#define WRITE 1\n\n/* function prototypes */\nstatic int trace_init(char *errormsg, \n                      size_t errormsg_size,\n                      int unused      __attribute__((unused)), \n                      va_list unused1 __attribute__((unused)));\nstatic int trace_deinit(void);\n\nint (*register_callback)(my_bool register_callback, \n                         void (*callback_function)(int mode, MYSQL *mysql, const uchar *buffer, size_t length));\nvoid trace_callback(int mode, MYSQL *mysql, const uchar *buffer, size_t length);\n\n#ifndef HAVE_TRACE_EXAMPLE_PLUGIN_DYNAMIC\nstruct st_mysql_client_plugin trace_example_plugin=\n#else\nstruct st_mysql_client_plugin _mysql_client_plugin_declaration_ =\n#endif\n{\n  MARIADB_CLIENT_TRACE_PLUGIN,\n  MARIADB_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION,\n  \"trace_example\",\n  \"Georg Richter\",\n  \"Trace example plugin\",\n  {1,0,0},\n  \"LGPL\",\n  NULL,\n  &trace_init,\n  &trace_deinit,\n  NULL\n};\n\nstatic const char *commands[]= {\n  \"COM_SLEEP\",\n  \"COM_QUIT\",\n  \"COM_INIT_DB\",\n  \"COM_QUERY\",\n  \"COM_FIELD_LIST\",\n  \"COM_CREATE_DB\",\n  \"COM_DROP_DB\",\n  \"COM_REFRESH\",\n  \"COM_SHUTDOWN\",\n  \"COM_STATISTICS\",\n  \"COM_PROCESS_INFO\",\n  \"COM_CONNECT\",\n  \"COM_PROCESS_KILL\",\n  \"COM_DEBUG\",\n  \"COM_PING\",\n  \"COM_TIME\",\n  \"COM_DELAYED_INSERT\",\n  \"COM_CHANGE_USER\",\n  \"COM_BINLOG_DUMP\",\n  \"COM_TABLE_DUMP\",\n  \"COM_CONNECT_OUT\",\n  \"COM_REGISTER_SLAVE\",\n  \"COM_STMT_PREPARE\",\n  \"COM_STMT_EXECUTE\",\n  \"COM_STMT_SEND_LONG_DATA\",\n  \"COM_STMT_CLOSE\",\n  \"COM_STMT_RESET\",\n  \"COM_SET_OPTION\",\n  \"COM_STMT_FETCH\",\n  \"COM_DAEMON\",\n  \"COM_MULTI\",\n  \"COM_END\"\n};\n\ntypedef struct {\n  unsigned long thread_id;\n  int last_command; /* COM_* values, -1 for handshake */\n  unsigned int max_packet_size;\n  unsigned int num_commands;\n  size_t total_size[2];\n  unsigned int client_flags;\n  char *username;\n  char *db;\n  char *command;\n  char *filename;\n  unsigned long refid; /* stmt_id, thread_id for kill */\n  uchar charset;\n  void *next;\n  int local_infile;\n  unsigned long pkt_length;\n} TRACE_INFO;\n\n#define TRACE_STATUS(a) (!a) ? \"ok\" : \"error\"\n\nTRACE_INFO *trace_info= NULL;\n\nstatic TRACE_INFO *get_trace_info(unsigned long thread_id)\n{\n  TRACE_INFO *info= trace_info;\n\n  /* search connection */\n  while (info)\n  {\n    if (info->thread_id == thread_id)\n      return info;\n    else\n      info= (TRACE_INFO *)info->next;\n  }\n\n  if (!(info= (TRACE_INFO *)calloc(sizeof(TRACE_INFO), 1)))\n    return NULL;\n  info->thread_id= thread_id;\n  info->next= trace_info;\n  trace_info= info;\n  return info;\n}\n\nstatic void delete_trace_info(unsigned long thread_id)\n{\n  TRACE_INFO *last= NULL, *current;\n  current= trace_info;\n\n  while (current)\n  {\n    if (current->thread_id == thread_id)\n    {\n      printf(\"deleting thread %lu\\n\", thread_id);\n\n      if (last)\n        last->next= current->next;\n      else\n        trace_info= (TRACE_INFO *)current->next;\n      if (current->command)\n        free(current->command);\n      if (current->db)\n        free(current->db);\n      if (current->username)\n        free(current->username);\n      if (current->filename)\n        free(current->filename);\n      free(current);\n    }\n    last= current;\n    current= (TRACE_INFO *)current->next;\n  }\n\n}\n\n\n/* {{{ static int trace_init */\n/* \n  Initialization routine\n\n  SYNOPSIS\n    trace_init\n      unused1\n      unused2\n      unused3\n      unused4\n\n  DESCRIPTION\n    Init function registers a callback handler for PVIO interface.\n\n  RETURN\n    0           success\n*/\nstatic int trace_init(char *errormsg, \n                      size_t errormsg_size,\n                      int unused1 __attribute__((unused)), \n                      va_list unused2 __attribute__((unused)))\n{\n  void *func;\n\n#ifdef WIN32\n  if (!(func= GetProcAddress(GetModuleHandle(NULL), \"ma_pvio_register_callback\")))\n#else\n  if (!(func= dlsym(RTLD_DEFAULT, \"ma_pvio_register_callback\")))\n#endif\n  {\n    strncpy(errormsg, \"Can't find ma_pvio_register_callback function\", errormsg_size);\n    return 1;\n  }\n  register_callback= func;\n  register_callback(TRUE, trace_callback);\n\n  return 0;\n}\n/* }}} */\n\nstatic int trace_deinit()\n{\n  /* unregister plugin */\n  while(trace_info)\n  {\n    printf(\"Warning: Connection for thread %lu not properly closed\\n\", trace_info->thread_id);\n    trace_info= (TRACE_INFO *)trace_info->next;\n  }\n  register_callback(FALSE, trace_callback);\n  return 0;\n}\n\nstatic void trace_set_command(TRACE_INFO *info, char *buffer, size_t size)\n{\n  if (info->command)\n    free(info->command);\n\n  info->command= calloc(1, size + 1);\n  memcpy(info->command, buffer, size);\n}\n\nvoid dump_buffer(uchar *buffer, size_t len)\n{\n  uchar *p= buffer;\n  while (p < buffer + len)\n  {\n    printf(\"%02x \", *p);\n    p++;\n  }\n  printf(\"\\n\");\n}\n\nstatic void dump_simple(TRACE_INFO *info, my_bool is_error)\n{\n  printf(\"%8lu: %s %s\\n\", info->thread_id, commands[info->last_command], TRACE_STATUS(is_error));\n}\n\nstatic void dump_reference(TRACE_INFO *info, my_bool is_error)\n{\n  printf(\"%8lu: %s(%lu) %s\\n\", info->thread_id, commands[info->last_command], (long)info->refid, TRACE_STATUS(is_error));\n}\n\nstatic void dump_command(TRACE_INFO *info, my_bool is_error)\n{\n  size_t i;\n  printf(\"%8lu: %s(\",  info->thread_id, commands[info->last_command]);\n  for (i= 0; info->command && i < strlen(info->command); i++)\n    if (info->command[i] == '\\n')\n      printf(\"\\\\n\");\n    else if (info->command[i] == '\\r')\n      printf(\"\\\\r\");\n    else if (info->command[i] == '\\t')\n      printf(\"\\\\t\");\n    else\n      printf(\"%c\", info->command[i]);\n  printf(\") %s\\n\", TRACE_STATUS(is_error));\n}\n\nvoid trace_callback(int mode, MYSQL *mysql, const uchar *buffer, size_t length)\n{\n  unsigned long thread_id= mysql->thread_id;\n  TRACE_INFO *info;\n\n  /* check if package is server greeting package,\n   * and set thread_id */\n  if (!thread_id && mode == READ)\n  {\n    char *p= (char *)buffer;\n    p+= 4; /* packet length */\n    if ((uchar)*p != 0xFF) /* protocol version 0xFF indicates error */\n    {\n      p+= strlen(p + 1) + 2;\n      thread_id= uint4korr(p);\n    }\n    info= get_trace_info(thread_id);\n    info->last_command= -1;\n  }\n  else\n  {\n    char *p= (char *)buffer;\n    info= get_trace_info(thread_id);\n\n    if (info->last_command == -1)\n    {\n      if (mode == WRITE)\n      {\n        /* client authentication reply packet:\n         * \n         *  ofs description        length\n         *  ------------------------\n         *  0   length             3\n         *  3   packet_no          1\n         *  4   client capab.      4\n         *  8   max_packet_size    4\n         *  12  character set      1\n         *  13  reserved          23\n         *  ------------------------\n         *  36  username (zero terminated)\n         *      len (1 byte) + password or\n         */\n\n        p+= 4;\n        info->client_flags= uint4korr(p);\n        p+= 4;\n        info->max_packet_size= uint4korr(p);\n        p+= 4;\n        info->charset= *p;\n        p+= 24;\n        info->username= strdup(p);\n        p+= strlen(p) + 1;\n        if (*p) /* we are not interested in authentication data */\n          p+= *p;\n        p++;\n        if (info->client_flags & CLIENT_CONNECT_WITH_DB)\n          info->db= strdup(p);\n      }\n      else\n      {\n        p++;\n        if ((uchar)*p == 0xFF)\n          printf(\"%8lu: CONNECT_ERROR(%d)\\n\", info->thread_id, uint4korr(p+1));\n        else\n          printf(\"%8lu: CONNECT_SUCCESS(host=%s,user=%s,db=%s)\\n\", info->thread_id, \n                 mysql->host, info->username, info->db ? info->db : \"'none'\");\n        info->last_command= COM_SLEEP;\n      }\n    }\n    else {\n      char *p= (char *)buffer;\n      int len;\n\n      if (mode == WRITE)\n      {\n        if (info->pkt_length > 0)\n        {\n          info->pkt_length-= length;\n          return;\n        }\n        len= uint3korr(p);\n        info->pkt_length= len + 4 - length;\n        p+= 4;\n        info->last_command= *p;\n        p++;\n\n        switch (info->last_command) {\n        case COM_INIT_DB:\n        case COM_DROP_DB:\n        case COM_CREATE_DB:\n        case COM_DEBUG:\n        case COM_QUERY:\n        case COM_STMT_PREPARE:\n          trace_set_command(info, p, len - 1);\n          break;\n        case COM_PROCESS_KILL:\n          info->refid= uint4korr(p);\n          break;\n        case COM_QUIT:\n          printf(\"%8lu: COM_QUIT\\n\", info->thread_id);\n          delete_trace_info(info->thread_id);\n          break;\n        case COM_PING:\n          printf(\"%8lu: COM_PING\\n\", info->thread_id);\n          break;\n        case COM_STMT_EXECUTE:\n        case COM_STMT_RESET:\n        case COM_STMT_CLOSE:\n          info->refid= uint4korr(p);\n          break;\n        case COM_CHANGE_USER:\n          break;\n        default:\n          if (info->local_infile == 1)\n          {\n            printf(\"%8lu: SEND_LOCAL_INFILE(%s) \", info->thread_id, info->filename);\n            if (len)\n              printf(\"sent %d bytes\\n\", len);\n            else\n              printf(\"- error\\n\");\n            info->local_infile= 2;\n          }\n          else\n            printf(\"%8lu: UNKNOWN_COMMAND: %d\\n\", info->thread_id, info->last_command);\n          break;\n        }\n      }\n      else\n      {\n        my_bool is_error;\n\n        len= uint3korr(p);\n        p+= 4;\n\n        is_error= (len == -1);\n\n        switch(info->last_command) {\n        case COM_STMT_EXECUTE:\n        case COM_STMT_RESET:\n        case COM_STMT_CLOSE:\n        case COM_PROCESS_KILL:\n          dump_reference(info, is_error);\n          info->refid= 0;\n          info->last_command= 0;\n          break;\n        case COM_QUIT:\n          dump_simple(info, is_error);\n          break;\n        case COM_QUERY:\n        case COM_INIT_DB:\n        case COM_DROP_DB:\n        case COM_CREATE_DB:\n        case COM_DEBUG:\n        case COM_CHANGE_USER:\n          if (info->last_command == COM_QUERY && (uchar)*p == 251)\n          {\n            info->local_infile= 1;\n            p++;\n            info->filename= (char *)malloc(len);\n            strncpy(info->filename, (char *)p, len);\n            dump_command(info, is_error);\n            break;\n          }\n          dump_command(info, is_error);\n          if (info->local_infile != 1)\n          {\n            free(info->command);\n            info->command= NULL;\n          }\n          break;\n        case COM_STMT_PREPARE:\n          printf(\"%8lu: COM_STMT_PREPARE(%s) \", info->thread_id, info->command);\n          if (!*p)\n          {\n            unsigned long stmt_id= uint4korr(p+1);\n            printf(\"-> stmt_id(%lu)\\n\", stmt_id);\n          }\n          else\n            printf(\"error\\n\");\n          break;\n        }\n      }\n    }\n  }\n  info->total_size[mode]+= length;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/libmariadb/ma_client_plugin.c.in": "/* Copyright (C) 2010 - 2012 Sergei Golubchik and Monty Program Ab\n                 2015-2016 MariaDB Corporation AB\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmariadb) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#if _MSC_VER\n/* Silence warnings about variable 'unused' being used. */\n#define FORCE_INIT_OF_VARS 1\n#endif\n\n#include <ma_global.h>\n#include <ma_sys.h>\n#include <ma_common.h> \n#include <ma_string.h>\n#include <ma_pthread.h>\n\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MA_MEM_ROOT mem_root;\n\nstatic uint valid_plugins[][2]= {\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_PVIO_PLUGIN, MARIADB_CLIENT_PVIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_TRACE_PLUGIN, MARIADB_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, MARIADB_CLIENT_REMOTEIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, MARIADB_CLIENT_CONNECTION_PLUGIN_INTERFACE_VERSION},\n  {0, 0}\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\n\n\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS + MARIADB_CLIENT_MAX_PLUGINS];\n#ifdef THREAD\nstatic pthread_mutex_t LOCK_load_client_plugin;\n#endif\n\n@EXTERNAL_PLUGINS@\n\nstruct st_mysql_client_plugin *mysql_client_builtins[]=\n{\n  @BUILTIN_PLUGINS@\n  0\n};\n\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n               SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n               name, \"not initialized\");\n  return 1;\n}\n\nstatic int get_plugin_nr(uint type)\n{\n  uint i= 0;\n  for(; valid_plugins[i][1]; i++)\n    if (valid_plugins[i][0] == type)\n      return i;\n  return -1;\n}\n\nstatic const char *check_plugin_version(struct st_mysql_client_plugin *plugin, unsigned int version)\n{\n  if (plugin->interface_version < version ||\n      (plugin->interface_version >> 8) > (version >> 8))\n    return \"Incompatible client plugin interface\";\n  return 0;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *find_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  DBUG_ASSERT(initialized);\n  if (plugin_nr == -1)\n    return 0;\n\n  if (!name)\n    return plugin_list[plugin_nr]->plugin;\n\n  for (p= plugin_list[plugin_nr]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\n\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n  int plugin_nr;\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if ((plugin_nr= get_plugin_nr(plugin->type)) == -1)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n  if ((errmsg= check_plugin_version(plugin, valid_plugins[plugin_nr][1])))\n    goto err1;\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    ma_memdup_root(&mem_root, (char *)&plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n#ifdef THREAD\n  safe_mutex_assert_owner(&LOCK_load_client_plugin);\n#endif\n\n  p->next= plugin_list[plugin_nr];\n  plugin_list[plugin_nr]= p;\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name, errmsg);\n  if (dlhandle)\n    (void)dlclose(dlhandle);\n  return NULL;\n}\n\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\n\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n\n  /* no plugins to load */\n  if (!s)\n    return;\n\n  free_env= plugs= strdup(s);\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  free(free_env);\n}\n\n/********** extern functions to be used by libmariadb *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occured\n*/\n\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (initialized)\n    return 0;\n\n  memset(&mysql, 0, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  pthread_mutex_init(&LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  ma_init_alloc_root(&mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized= 1;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  return 0;\n}\n\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\n\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        (void)dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized= 0;\n  ma_free_root(&mem_root, MYF(0));\n  pthread_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                 SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                 plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n#ifdef _WIN32\n  char errbuf[255];\n#endif\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n\n  CLEAR_CLIENT_ERROR(mysql);\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : (env_plugin_dir) ? env_plugin_dir :\n           MARIADB_PLUGINDIR, name, SO_EXT);\n\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n#ifdef _WIN32\n   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                 NULL,\n                 GetLastError(),\n                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                 (LPTSTR)&errbuf, 255, NULL);\n   errmsg= errbuf;\n#else\n    errmsg= dlerror();\n#endif\n    goto err;\n  }\n\n\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    (void)dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  return plugin;\n\nerr:\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  return NULL;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  if (plugin_nr == -1)\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n                 ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n    return p;\n\n  /* not found, load it */\n  return mysql_load_plugin(mysql, name, type, 0);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/client/ma_plugin_info.c": "\n#include <my_global.h>\n#include <my_sys.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <my_dir.h>\n#include <ma_string.h>\n\n#define CLIENT_PLUGIN_INFO_VERSION \"1.0.0\"\n\nstatic struct option long_options[]=\n{\n  {\"all\", no_argument, 0, 'a'},\n  {\"builtin\", no_argument, 0, 'b'},\n  {\"dynamic\", no_argument, 0, 'd'},\n  {\"directory\", 1, 0, 'p'},\n  {\"plugin_name\", 1, 0, 'n'},\n  {\"version\", no_argument, 0, 'v'},\n  {\"help\", no_argument, 0, '?'},\n  {NULL, 0, 0, 0}\n};\n\nstatic char *values[] =\n{\n  \"show information for all plugins\",\n  \"show informaion for builtin plugins\",\n  \"show information for dynamic plugins\",\n  \"show information for dynamic plugins in specified directory\",\n  \"show information for specified plugin\",\n  \"show version information\",\n  \"display this help and exit\",\n  NULL\n};\n\nstruct st_plugin_type\n{\n  int type;\n  char *typename;\n};\n\n#ifndef _WIN32\nint my_errno=0;\n#endif\n\nstatic struct st_plugin_type plugin_types[]=\n{\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, \"authentication\"},\n  {MARIADB_CLIENT_PVIO_PLUGIN, \"virtual IO\"},\n  {MARIADB_CLIENT_TRACE_PLUGIN, \"trace\"},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, \"remote file access\"},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, \"connection handler\"},\n  {0, \"unknown\"}\n};\n\nstatic void version()\n{\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n}\n\nstatic void usage(void)\n{\n  int i=0;\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n  puts(\"Copyright 2015 MariaDB Corporation AB\");\n  puts(\"Show client plugin information for MariaDB Connector/C.\");\n  printf(\"Usage: %s [OPTIONS] [plugin_name]\\n\", ma_progname);\n  while (long_options[i].name)\n  {\n    printf(\"  --%-12s -%s\\n\", long_options[i].name, values[i]);\n    i++;\n  }\n}\n\nstatic char *ma_get_type_name(int type)\n{\n  int i=0;\n  while (plugin_types[i].type)\n  {\n    if (type== plugin_types[i].type)\n      return plugin_types[i].typename;\n    i++;\n  }\n  return plugin_types[i].typename;\n}\n\nstatic void show_plugin_info(struct st_mysql_client_plugin *plugin, my_bool builtin)\n{\n  printf(\"Name: %s\\n\", plugin->name);\n  printf(\"Type: %s\\n\", ma_get_type_name(plugin->type));\n  printf(\"Desc: %s\\n\", plugin->desc);\n  printf(\"Author: %s\\n\", plugin->author);\n  printf(\"License: %s\\n\", plugin->license);\n  printf(\"Version: %d.%d.%d\\n\", plugin->version[0], plugin->version[1], plugin->version[2]);\n  printf(\"API Version: 0x%04X\\n\", plugin->interface_version);\n  printf(\"Build type: %s\\n\", builtin ? \"builtin\" : \"dynamic\");\n  printf(\"\\n\");\n}\n\nstatic void show_builtin()\n{\n  struct st_mysql_client_plugin **builtin;\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    show_plugin_info(*builtin, TRUE);\n}\n\nstatic void show_file(char *filename)\n{\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n  char *has_so_ext= strstr(filename, SO_EXT);\n\n  if (!strchr(filename, FN_LIBCHAR))\n    snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n             (env_plugin_dir) ? env_plugin_dir : PLUGINDIR, \n             filename, \n             has_so_ext ? \"\" : SO_EXT);\n  else\n    strcpy(dlpath, filename);\n  if ((dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n    if (sym= dlsym(dlhandle, plugin_declarations_sym))\n    {\n      plugin= (struct st_mysql_client_plugin *)sym;\n      show_plugin_info(plugin, 0);\n    }\n    dlclose(dlhandle);\n  }\n}\n\nstatic void show_dynamic(const char *directory)\n{\n  MY_DIR *dir= NULL;\n  unsigned int i;\n  char *plugin_dir= directory ? (char *)directory : getenv(\"MARIADB_PLUGIN_DIR\");\n\n  if (!plugin_dir)\n    plugin_dir= PLUGINDIR;\n\n  printf(\"plugin_dir %s\\n\", plugin_dir);\n\n  dir= my_dir(plugin_dir, 0);\n\n  if (!dir || !dir->number_off_files)\n  {\n    printf(\"No plugins found in %s\\n\", plugin_dir);\n    goto end;\n  }\n\n  for (i=0; i < dir->number_off_files; i++)\n  {\n    char *p= strstr(dir->dir_entry[i].name, SO_EXT);\n    if (p)\n      show_file(dir->dir_entry[i].name);\n  }\nend:\n  if (dir)\n    my_dirend(dir);\n}\n\nint main(int argc, char *argv[])\n{\n  int option_index= 0;\n  int c;\n  ma_progname= argv[0];\n\n  mysql_server_init(0, NULL, NULL);\n\n  if (argc <= 1)\n  {\n    usage();\n    exit(1);\n  }\n\n  c= getopt_long(argc, argv, \"bdapnvh?\", long_options, &option_index);\n\n  switch(c) {\n  case 'a': /* all */\n    show_builtin();\n    show_dynamic(NULL);\n    break;\n  case 'b': /* builtin */\n    show_builtin();\n    break;\n  case 'd': /* dynamic */\n    show_dynamic(NULL);\n    break;\n  case 'v':\n    version();\n    break;\n  case 'n':\n    if (argc > 2)\n      show_file(argv[2]);\n    break;\n  case 'p':\n    if (argc > 2)\n      show_dynamic(argv[2]);\n    break;\n  case '?':\n    usage();\n    break;\n  default:\n    printf(\"unrecocognized option: %s\", argv[1]);\n    exit(1);\n  }\n  exit(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql/sys_vars.cc": "/* Copyright (c) 2002, 2015, Oracle and/or its affiliates.\n   Copyright (c) 2012, 2017, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  Definitions of all server's session or global variables.\n\n  How to add new variables:\n\n  1. copy one of the existing variables, and edit the declaration.\n  2. if you need special behavior on assignment or additional checks\n     use ON_CHECK and ON_UPDATE callbacks.\n  3. *Don't* add new Sys_var classes or uncle Occam will come\n     with his razor to haunt you at nights\n\n  Note - all storage engine variables (for example myisam_whatever)\n  should go into the corresponding storage engine sources\n  (for example in storage/myisam/ha_myisam.cc) !\n*/\n\n#include \"sql_plugin.h\"                         // Includes my_global.h\n#include \"sql_priv.h\"\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars.ic\"\n\n#include \"events.h\"\n#include <thr_alarm.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"transaction.h\"\n#include \"mysqld.h\"\n#include \"lock.h\"\n#include \"sql_time.h\"                       // known_date_time_formats\n#include \"sql_acl.h\" // SUPER_ACL,\n                     // mysql_user_table_is_in_short_password_format\n#include \"derror.h\"  // read_texts\n#include \"sql_base.h\"                           // close_cached_tables\n#include \"hostname.h\"                           // host_cache_size\n#include <myisam.h>\n#include \"log_slow.h\"\n#include \"debug_sync.h\"                         // DEBUG_SYNC\n#include \"sql_show.h\"\n\n#include \"log_event.h\"\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n#include \"threadpool.h\"\n#include \"sql_repl.h\"\n#include \"opt_range.h\"\n#include \"rpl_parallel.h\"\n\n/*\n  The rule for this file: everything should be 'static'. When a sys_var\n  variable or a function from this file is - in very rare cases - needed\n  elsewhere it should be explicitly declared 'export' here to show that it's\n  not a mistakenly forgotten 'static' keyword.\n*/\n#define export /* not static */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n\nstatic Sys_var_mybool Sys_pfs_enabled(\n       \"performance_schema\",\n       \"Enable the performance schema.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_long Sys_pfs_events_waits_history_long_size(\n       \"performance_schema_events_waits_history_long_size\",\n       \"Number of rows in EVENTS_WAITS_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY\n       GLOBAL_VAR(pfs_param.m_events_waits_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_waits_history_size(\n       \"performance_schema_events_waits_history_size\",\n       \"Number of rows per thread in EVENTS_WAITS_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_cond_classes(\n       \"performance_schema_max_cond_classes\",\n       \"Maximum number of condition instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_cond_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_COND_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_cond_instances(\n       \"performance_schema_max_cond_instances\",\n       \"Maximum number of instrumented condition objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_cond_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_file_classes(\n       \"performance_schema_max_file_classes\",\n       \"Maximum number of file instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_FILE_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_file_handles(\n       \"performance_schema_max_file_handles\",\n       \"Maximum number of opened instrumented files.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_handle_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_FILE_HANDLE), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_file_instances(\n       \"performance_schema_max_file_instances\",\n       \"Maximum number of instrumented files.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_sockets(\n       \"performance_schema_max_socket_instances\",\n       \"Maximum number of opened instrumented sockets.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_socket_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_socket_classes(\n       \"performance_schema_max_socket_classes\",\n       \"Maximum number of socket instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_socket_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_SOCKET_CLASS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_classes(\n       \"performance_schema_max_mutex_classes\",\n       \"Maximum number of mutex instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_MUTEX_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_mutex_instances(\n       \"performance_schema_max_mutex_instances\",\n       \"Maximum number of instrumented MUTEX objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_classes(\n       \"performance_schema_max_rwlock_classes\",\n       \"Maximum number of rwlock instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_RWLOCK_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_rwlock_instances(\n       \"performance_schema_max_rwlock_instances\",\n       \"Maximum number of instrumented RWLOCK objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_table_handles(\n       \"performance_schema_max_table_handles\",\n       \"Maximum number of opened instrumented tables.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_table_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_table_instances(\n       \"performance_schema_max_table_instances\",\n       \"Maximum number of instrumented tables.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_table_share_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_thread_classes(\n       \"performance_schema_max_thread_classes\",\n       \"Maximum number of thread instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_thread_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_THREAD_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_thread_instances(\n       \"performance_schema_max_thread_instances\",\n       \"Maximum number of instrumented threads.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_thread_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_setup_actors_size(\n       \"performance_schema_setup_actors_size\",\n       \"Maximum number of rows in SETUP_ACTORS.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_setup_actor_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024),\n       DEFAULT(PFS_MAX_SETUP_ACTOR),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_setup_objects_size(\n       \"performance_schema_setup_objects_size\",\n       \"Maximum number of rows in SETUP_OBJECTS.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_setup_object_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_SETUP_OBJECT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_accounts_size(\n       \"performance_schema_accounts_size\",\n       \"Maximum number of instrumented user@host accounts.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_account_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_hosts_size(\n       \"performance_schema_hosts_size\",\n       \"Maximum number of instrumented hosts.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_host_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_users_size(\n       \"performance_schema_users_size\",\n       \"Maximum number of instrumented users.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_user_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_stage_classes(\n       \"performance_schema_max_stage_classes\",\n       \"Maximum number of stage instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_stage_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_STAGE_CLASS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_stages_history_long_size(\n       \"performance_schema_events_stages_history_long_size\",\n       \"Number of rows in EVENTS_STAGES_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_stages_history_size(\n       \"performance_schema_events_stages_history_size\",\n       \"Number of rows per thread in EVENTS_STAGES_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\n/**\n  Variable performance_schema_max_statement_classes.\n  The default number of statement classes is the sum of:\n  - (COM_END - mariadb gap) for all regular \"statement/com/...\",\n  - 1 for \"statement/com/new_packet\", for unknown enum_server_command\n  - 1 for \"statement/com/Error\", for invalid enum_server_command\n  - SQLCOM_END for all regular \"statement/sql/...\",\n  - 1 for \"statement/sql/error\", for invalid enum_sql_command\n  - 1 for \"statement/rpl/relay_log\", for replicated statements.\n*/\nstatic Sys_var_ulong Sys_pfs_max_statement_classes(\n       \"performance_schema_max_statement_classes\",\n       \"Maximum number of statement instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_statement_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT((ulong) SQLCOM_END +\n               (ulong) (COM_END -(COM_MDB_GAP_END - COM_MDB_GAP_BEG + 1)) + 4),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_statements_history_long_size(\n       \"performance_schema_events_statements_history_long_size\",\n       \"Number of rows in EVENTS_STATEMENTS_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_statements_history_size(\n       \"performance_schema_events_statements_history_size\",\n       \"Number of rows per thread in EVENTS_STATEMENTS_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_digest_size(\n       \"performance_schema_digests_size\",\n       \"Size of the statement digest.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_digest_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 200),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_digest_length(\n       \"performance_schema_max_digest_length\",\n       \"Maximum length considered for digest text, when stored in performance_schema tables.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_max_digest_length),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n       DEFAULT(1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_connect_attrs_size(\n       \"performance_schema_session_connect_attrs_size\",\n       \"Size of session attribute string buffer per thread.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY\n       GLOBAL_VAR(pfs_param.m_session_connect_attrs_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic Sys_var_ulong Sys_auto_increment_increment(\n       \"auto_increment_increment\",\n       \"Auto-increment columns are incremented by this\",\n       SESSION_VAR(auto_increment_increment),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_ulong Sys_auto_increment_offset(\n       \"auto_increment_offset\",\n       \"Offset added to Auto-increment columns. Used when \"\n       \"auto-increment-increment != 1\",\n       SESSION_VAR(auto_increment_offset),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_mybool Sys_automatic_sp_privileges(\n       \"automatic_sp_privileges\",\n       \"Creating and dropping stored procedures alters ACLs\",\n       GLOBAL_VAR(sp_automatic_privileges),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_back_log(\n       \"back_log\", \"The number of outstanding connection requests \"\n       \"MariaDB can have. This comes into play when the main MariaDB thread \"\n       \"gets very many connection requests in a very short time\",\n       AUTO_SET READ_ONLY GLOBAL_VAR(back_log), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(150), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_basedir(\n       \"basedir\", \"Path to installation directory. All paths are \"\n       \"usually resolved relative to this\",\n       READ_ONLY GLOBAL_VAR(mysql_home_ptr), CMD_LINE(REQUIRED_ARG, 'b'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_binlog_cache_size(\n       \"binlog_cache_size\", \"The size of the transactional cache for \"\n       \"updates to transactional engines for the binary log. \"\n       \"If you often use transactions containing many statements, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong Sys_binlog_stmt_cache_size(\n       \"binlog_stmt_cache_size\", \"The size of the statement cache for \"\n       \"updates to non-transactional engines for the binary log. \"\n       \"If you often use statements updating a great number of rows, \"\n       \"you can increase this to get more performance.\",\n       GLOBAL_VAR(binlog_stmt_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\n/*\n  Some variables like @sql_log_bin and @binlog_format change how/if binlogging\n  is done. We must not change them inside a running transaction or statement,\n  otherwise the event group eventually written to the binlog may become\n  incomplete or otherwise garbled.\n\n  This function does the appropriate check.\n\n  It returns true if an error is caused by incorrect usage, false if ok.\n*/\nstatic bool\nerror_if_in_trans_or_substatement(THD *thd, int in_substatement_error,\n                                  int in_transaction_error)\n{\n  if (thd->in_sub_stmt)\n  {\n    my_error(in_substatement_error, MYF(0));\n    return true;\n  }\n\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(in_transaction_error, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool check_has_super(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ASSERT(self->scope() != sys_var::GLOBAL);// don't abuse check_has_super()\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (!(thd->security_ctx->master_access & SUPER_ACL))\n  {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), \"SUPER\");\n    return true;\n  }\n#endif\n  return false;\n}\nstatic bool binlog_format_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  /*\n    MariaDB Galera does not support STATEMENT or MIXED binlog format currently.\n  */\n  if ((WSREP(thd) || opt_support_flashback) &&\n      var->save_result.ulonglong_value != BINLOG_FORMAT_ROW)\n  {\n    // Push a warning to the error log.\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN, ER_UNKNOWN_ERROR,\n                        \"MariaDB Galera and flashback do not support binlog format: %s\",\n                        binlog_format_names[var->save_result.ulonglong_value]);\n    /*\n      We allow setting up binlog_format other then ROW for session scope when\n      wsrep/flasback is enabled.This is done because of 2 reasons\n      1. User might want to run pt-table-checksum.\n      2. SuperUser knows what is doing :-)\n\n      For refrence:- MDEV-7322\n    */\n    if (var->type == OPT_GLOBAL)\n    {\n      if (WSREP(thd))\n        WSREP_ERROR(\"MariaDB Galera does not support binlog format: %s\",\n                    binlog_format_names[var->save_result.ulonglong_value]);\n      else\n        my_error(ER_FLASHBACK_NOT_SUPPORTED,MYF(0),\"binlog_format\",\n                 binlog_format_names[var->save_result.ulonglong_value]);\n      return true;\n    }\n  }\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  /*\n     If RBR and open temporary tables, their CREATE TABLE may not be in the\n     binlog, so we can't toggle to SBR in this connection.\n\n     If binlog_format=MIXED, there are open temporary tables, and an unsafe\n     statement is executed, then subsequent statements are logged in row\n     format and hence changes to temporary tables may be lost. So we forbid\n     switching @@SESSION.binlog_format from MIXED to STATEMENT when there are\n     open temp tables and we are logging in row format.\n  */\n  if (thd->has_thd_temporary_tables() &&\n      var->type == OPT_SESSION &&\n      var->save_result.ulonglong_value == BINLOG_FORMAT_STMT &&\n      ((thd->variables.binlog_format == BINLOG_FORMAT_MIXED &&\n        thd->is_current_stmt_binlog_format_row()) ||\n       thd->variables.binlog_format == BINLOG_FORMAT_ROW))\n  {\n    my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR, MYF(0));\n    return true;\n  }\n\n  if (error_if_in_trans_or_substatement(thd,\n         ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT,\n         ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT))\n    return true;\n\n  return false;\n}\n\nstatic bool fix_binlog_format_after_update(sys_var *self, THD *thd,\n                                           enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->reset_current_stmt_binlog_format_row();\n  return false;\n}\n\nstatic Sys_var_enum Sys_binlog_format(\n       \"binlog_format\", \"What form of binary logging the master will \"\n       \"use: either ROW for row-based binary logging, STATEMENT \"\n       \"for statement-based binary logging, or MIXED. MIXED is statement-\"\n       \"based binary logging except for those statements where only row-\"\n       \"based is correct: those which involve user-defined functions (i.e. \"\n       \"UDFs) or the UUID() function; for those, row-based binary logging is \"\n       \"automatically used.\",\n       SESSION_VAR(binlog_format), CMD_LINE(REQUIRED_ARG, OPT_BINLOG_FORMAT),\n       binlog_format_names, DEFAULT(BINLOG_FORMAT_MIXED),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_format_check),\n       ON_UPDATE(fix_binlog_format_after_update));\n\nstatic bool binlog_direct_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  if (error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT))\n     return true;\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_binlog_direct(\n       \"binlog_direct_non_transactional_updates\",\n       \"Causes updates to non-transactional engines using statement format to \"\n       \"be written directly to binary log. Before using this option make sure \"\n       \"that there are no dependencies between transactional and \"\n       \"non-transactional tables such as in the statement INSERT INTO t_myisam \"\n       \"SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.\",\n       SESSION_VAR(binlog_direct_non_trans_update),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_direct_check));\n\n\nstatic Sys_var_mybool Sys_explicit_defaults_for_timestamp(\n       \"explicit_defaults_for_timestamp\",\n       \"This option causes CREATE TABLE to create all TIMESTAMP columns \"\n       \"as NULL with DEFAULT NULL attribute, Without this option, \"\n       \"TIMESTAMP columns are NOT NULL and have implicit DEFAULT clauses. \"\n       \"The old behavior is deprecated.\",\n       READ_ONLY GLOBAL_VAR(opt_explicit_defaults_for_timestamp),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\n\nstatic Sys_var_ulonglong Sys_bulk_insert_buff_size(\n       \"bulk_insert_buffer_size\", \"Size of tree cache used in bulk \"\n       \"insert optimisation. Note that this is a limit per thread!\",\n       SESSION_VAR(bulk_insert_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(8192*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_character_sets_dir(\n       \"character_sets_dir\", \"Directory where character sets are\",\n       READ_ONLY GLOBAL_VAR(charsets_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool check_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return var->value && var->value->is_null();\n}\nstatic bool check_charset(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0' terminated string */\n      if (!(var->save_result.ptr= get_charset_by_csname(err.ptr(),\n                                                         MY_CS_PRIMARY,\n                                                         MYF(0))) &&\n          !(var->save_result.ptr= get_old_charset_by_name(err.ptr())))\n      {\n        my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return false;\n}\nstatic bool check_charset_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return check_charset(self, thd, var) || check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_character_set_system(\n       \"character_set_system\", \"The character set used by the server \"\n       \"for storing identifiers\",\n       READ_ONLY GLOBAL_VAR(system_charset_info), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(0));\n\nstatic Sys_var_struct Sys_character_set_server(\n       \"character_set_server\", \"The default character set\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null));\n\nstatic bool check_charset_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_database(\n       \"character_set_database\",\n       \"The character set used by the default database\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_db));\n\nstatic bool check_cs_client(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n\n  // Currently, UCS-2 cannot be used as a client character set\n  if (!is_supported_parser_charset((CHARSET_INFO *)(var->save_result.ptr)))\n    return true;\n\n  return false;\n}\nstatic bool fix_thd_charset(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_charset();\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_client(\n       \"character_set_client\", \"The character set for statements \"\n       \"that arrive from the client\",\n       NO_SET_STMT SESSION_VAR(character_set_client), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_cs_client),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_connection(\n       \"character_set_connection\", \"The character set used for \"\n       \"literals that do not have a character set introducer and for \"\n       \"number-to-string conversion\",\n       NO_SET_STMT SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_results(\n       \"character_set_results\", \"The character set used for returning \"\n       \"query results to the client\",\n       SESSION_VAR(character_set_results), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset));\n\nstatic Sys_var_struct Sys_character_set_filesystem(\n       \"character_set_filesystem\", \"The filesystem character set\",\n       NO_SET_STMT SESSION_VAR(character_set_filesystem), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&character_set_filesystem),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic const char *completion_type_names[]= {\"NO_CHAIN\", \"CHAIN\", \"RELEASE\", 0};\nstatic Sys_var_enum Sys_completion_type(\n       \"completion_type\", \"The transaction completion type\",\n       SESSION_VAR(completion_type), CMD_LINE(REQUIRED_ARG),\n       completion_type_names, DEFAULT(0));\n\nstatic bool check_collation_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0'-terminated string */\n      if (!(var->save_result.ptr= get_charset_by_name(err.ptr(), MYF(0))))\n      {\n        my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_collation_connection(\n       \"collation_connection\", \"The collation of the connection \"\n       \"character set\",\n       NO_SET_STMT SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic bool check_collation_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_collation_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_collation_database(\n       \"collation_database\", \"The collation of the database \"\n       \"character set\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_db));\n\nstatic Sys_var_struct Sys_collation_server(\n       \"collation_server\", \"The server default collation\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null));\n\nstatic const char *concurrent_insert_names[]= {\"NEVER\", \"AUTO\", \"ALWAYS\", 0};\nstatic Sys_var_enum Sys_concurrent_insert(\n       \"concurrent_insert\", \"Use concurrent insert with MyISAM\",\n       GLOBAL_VAR(myisam_concurrent_insert), CMD_LINE(OPT_ARG),\n       concurrent_insert_names, DEFAULT(1));\n\nstatic Sys_var_ulong Sys_connect_timeout(\n       \"connect_timeout\",\n       \"The number of seconds the mysqld server is waiting for a connect \"\n       \"packet before responding with 'Bad handshake'\",\n       GLOBAL_VAR(connect_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(CONNECT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_datadir(\n       \"datadir\", \"Path to the database root directory\",\n       READ_ONLY GLOBAL_VAR(mysql_real_data_home_ptr),\n       CMD_LINE(REQUIRED_ARG, 'h'), IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\n#ifndef DBUG_OFF\nstatic Sys_var_dbug Sys_dbug(\n       \"debug\", \"Built-in DBUG debugger\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super), ON_UPDATE(0),\n       DEPRECATED(\"'@@debug_dbug'\"));\n\nstatic Sys_var_dbug Sys_debug_dbug(\n       \"debug_dbug\", \"Built-in DBUG debugger\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super));\n#endif\n\n/**\n  @todo\n    When updating myisam_delay_key_write, we should do a 'flush tables'\n    of all MyISAM tables to ensure that they are reopen with the\n    new attribute.\n*/\nexport bool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type)\n{\n  switch (delay_key_write_options) {\n  case DELAY_KEY_WRITE_NONE:\n    myisam_delay_key_write=0;\n    ha_open_options&= ~HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  case DELAY_KEY_WRITE_ON:\n    myisam_delay_key_write=1;\n    ha_open_options&= ~HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  case DELAY_KEY_WRITE_ALL:\n    myisam_delay_key_write=1;\n    ha_open_options|= HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  }\n#ifdef WITH_ARIA_STORAGE_ENGINE\n  maria_delay_key_write= myisam_delay_key_write;\n#endif\n  return false;\n}\nstatic const char *delay_key_write_names[]= { \"OFF\", \"ON\", \"ALL\", NullS };\nstatic Sys_var_enum Sys_delay_key_write(\n       \"delay_key_write\", \"Specifies how MyISAM tables handles CREATE \"\n       \"TABLE DELAY_KEY_WRITE. If set to ON, the default, any DELAY KEY \"\n       \"WRITEs are honored. The key buffer is then flushed only when the \"\n       \"table closes, speeding up writes. MyISAM tables should be \"\n       \"automatically checked upon startup in this case, and \"\n       \"--external locking should not be used, as it can lead to index \"\n       \"corruption. If set to OFF, DELAY KEY WRITEs are ignored, while if \"\n       \"set to ALL, all new opened tables are treated as if created with \"\n       \"DELAY KEY WRITEs enabled.\",\n       GLOBAL_VAR(delay_key_write_options), CMD_LINE(OPT_ARG),\n       delay_key_write_names, DEFAULT(DELAY_KEY_WRITE_ON),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_delay_key_write));\n\nstatic Sys_var_ulong Sys_delayed_insert_limit(\n       \"delayed_insert_limit\",\n       \"After inserting delayed_insert_limit rows, the INSERT DELAYED \"\n       \"handler will check if there are any SELECT statements pending. \"\n       \"If so, it allows these to execute before continuing.\",\n       GLOBAL_VAR(delayed_insert_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(DELAYED_LIMIT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_insert_timeout(\n       \"delayed_insert_timeout\",\n       \"How long a INSERT DELAYED thread should wait for INSERT statements \"\n       \"before terminating\",\n       GLOBAL_VAR(delayed_insert_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(DELAYED_WAIT_TIMEOUT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_queue_size(\n       \"delayed_queue_size\",\n       \"What size queue (in rows) should be allocated for handling INSERT \"\n       \"DELAYED. If the queue becomes full, any client that does INSERT \"\n       \"DELAYED will wait until there is room in the queue again\",\n       GLOBAL_VAR(delayed_queue_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(DELAYED_QUEUE_SIZE), BLOCK_SIZE(1));\n\n#ifdef HAVE_EVENT_SCHEDULER\nstatic const char *event_scheduler_names[]= { \"OFF\", \"ON\", \"DISABLED\",\n                                              \"ORIGINAL\", NullS };\nstatic bool event_scheduler_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (Events::opt_event_scheduler == Events::EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0),\n             \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    return true;\n  }\n  /* DISABLED is only accepted on the command line */\n  if (var->save_result.ulonglong_value == Events::EVENTS_DISABLED)\n    return true;\n  return false;\n}\n\nstatic bool event_scheduler_update(sys_var *self, THD *thd, enum_var_type type)\n{\n  int err_no= 0;\n  bool ret;\n  uint opt_event_scheduler_value= Events::opt_event_scheduler;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /*\n    Events::start() is heavyweight. In particular it creates a new THD,\n    which takes LOCK_global_system_variables internally.\n    Thus we have to release it here.\n    We need to re-take it before returning, though.\n\n    Note that since we release LOCK_global_system_variables before calling\n    start/stop, there is a possibility that the server variable\n    can become out of sync with the real event scheduler state.\n\n    This can happen with two concurrent statments if the first gets\n    interrupted after start/stop but before retaking\n    LOCK_global_system_variables. However, this problem should be quite\n    rare and it's difficult to avoid it without opening up possibilities\n    for deadlocks. See bug#51160.\n  */\n\n  /* EVENTS_ORIGINAL means we should revert back to the startup state */\n  if (opt_event_scheduler_value == Events::EVENTS_ORIGINAL)\n  {\n    opt_event_scheduler_value= Events::opt_event_scheduler=\n      Events::startup_state;\n  }\n \n  /*\n    If the scheduler was not properly inited (because of wrong system tables),\n    try to init it again. This is needed for mysql_upgrade to work properly if\n    the event tables where upgraded.\n  */\n  if (!Events::inited && (Events::init(thd, 0) || !Events::inited))\n    ret= 1;\n  else\n    ret= opt_event_scheduler_value == Events::EVENTS_ON ?\n      Events::start(&err_no) :\n      Events::stop();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (ret)\n  {\n    Events::opt_event_scheduler= Events::EVENTS_OFF;\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), err_no);\n  }\n  return ret;\n}\n\nstatic Sys_var_enum Sys_event_scheduler(\n       \"event_scheduler\", \"Enable the event scheduler. Possible values are \"\n       \"ON, OFF, and DISABLED (keep the event scheduler completely \"\n       \"deactivated, it cannot be activated run-time)\",\n       GLOBAL_VAR(Events::opt_event_scheduler), CMD_LINE(OPT_ARG),\n       event_scheduler_names, DEFAULT(Events::EVENTS_OFF),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(event_scheduler_check), ON_UPDATE(event_scheduler_update));\n#endif\n\nstatic Sys_var_ulong Sys_expire_logs_days(\n       \"expire_logs_days\",\n       \"If non-zero, binary logs will be purged after expire_logs_days \"\n       \"days; possible purges happen at startup and at binary log rotation\",\n       GLOBAL_VAR(expire_logs_days),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 99), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_flush(\n       \"flush\", \"Flush MyISAM tables to disk between SQL commands\",\n       GLOBAL_VAR(myisam_flush),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_flush_time(\n       \"flush_time\",\n       \"A dedicated thread is created to flush all tables at the \"\n       \"given interval\",\n       GLOBAL_VAR(flush_time),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic bool check_ftb_syntax(sys_var *self, THD *thd, set_var *var)\n{\n  return ft_boolean_check_syntax_string((uchar*)\n                      (var->save_result.string_value.str));\n}\nstatic bool query_cache_flush(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifdef HAVE_QUERY_CACHE\n  query_cache.flush();\n#endif /* HAVE_QUERY_CACHE */\n  return false;\n}\n/// @todo make SESSION_VAR (usability enhancement and a fix for a race condition)\nstatic Sys_var_charptr Sys_ft_boolean_syntax(\n       \"ft_boolean_syntax\", \"List of operators for \"\n       \"MATCH ... AGAINST ( ... IN BOOLEAN MODE)\",\n       GLOBAL_VAR(ft_boolean_syntax),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_ftb_syntax), ON_UPDATE(query_cache_flush));\n\nstatic Sys_var_ulong Sys_ft_max_word_len(\n       \"ft_max_word_len\",\n       \"The maximum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_max_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, HA_FT_MAXCHARLEN), DEFAULT(HA_FT_MAXCHARLEN),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_ft_min_word_len(\n       \"ft_min_word_len\",\n       \"The minimum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_min_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_FT_MAXCHARLEN), DEFAULT(4), BLOCK_SIZE(1));\n\n/// @todo make it an updatable SESSION_VAR\nstatic Sys_var_ulong Sys_ft_query_expansion_limit(\n       \"ft_query_expansion_limit\",\n       \"Number of best matches to use for query expansion\",\n       READ_ONLY GLOBAL_VAR(ft_query_expansion_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_ft_stopword_file(\n       \"ft_stopword_file\",\n       \"Use stopwords from this file instead of built-in list\",\n       READ_ONLY GLOBAL_VAR(ft_stopword_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_ignore_builtin_innodb(\n       \"ignore_builtin_innodb\",\n       \"Disable initialization of builtin InnoDB plugin\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_builtin_innodb),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_init_string(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->save_result.string_value.str == 0)\n  {\n    var->save_result.string_value.str= const_cast<char*>(\"\");\n    var->save_result.string_value.length= 0;\n  }\n  return false;\n}\nstatic PolyLock_rwlock PLock_sys_init_connect(&LOCK_sys_init_connect);\nstatic Sys_var_lexstring Sys_init_connect(\n       \"init_connect\", \"Command(s) that are executed for each \"\n       \"new connection (unless the user has SUPER privilege)\",\n       GLOBAL_VAR(opt_init_connect), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_connect, NOT_IN_BINLOG,\n       ON_CHECK(check_init_string));\n\n#ifdef HAVE_REPLICATION\nstatic bool check_master_connection(sys_var *self, THD *thd, set_var *var)\n{\n  LEX_STRING tmp;\n  tmp.str= var->save_result.string_value.str;\n  tmp.length= var->save_result.string_value.length;\n  if (!tmp.str || check_master_connection_name(&tmp))\n    return true;\n\n  return false;\n}\n\nstatic Sys_var_session_lexstring Sys_default_master_connection(\n       \"default_master_connection\",\n       \"Master connection to use for all slave variables and slave commands\",\n       SESSION_ONLY(default_master_connection),\n       NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), MAX_CONNECTION_NAME, ON_CHECK(check_master_connection));\n#endif\n\nstatic Sys_var_charptr Sys_init_file(\n       \"init_file\", \"Read SQL commands from this file at startup\",\n       READ_ONLY GLOBAL_VAR(opt_init_file),\n#ifdef DISABLE_GRANT_OPTIONS\n       NO_CMD_LINE,\n#else\n       CMD_LINE(REQUIRED_ARG),\n#endif\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic PolyLock_rwlock PLock_sys_init_slave(&LOCK_sys_init_slave);\nstatic Sys_var_lexstring Sys_init_slave(\n       \"init_slave\", \"Command(s) that are executed by a slave server \"\n       \"each time the SQL thread starts\", GLOBAL_VAR(opt_init_slave),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_slave,\n       NOT_IN_BINLOG, ON_CHECK(check_init_string));\n\nstatic Sys_var_ulong Sys_interactive_timeout(\n       \"interactive_timeout\",\n       \"The number of seconds the server waits for activity on an interactive \"\n       \"connection before closing it\",\n       NO_SET_STMT SESSION_VAR(net_interactive_timeout),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_join_buffer_size(\n       \"join_buffer_size\",\n       \"The size of the buffer that is used for joins\",\n       SESSION_VAR(join_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128, SIZE_T_MAX), DEFAULT(256*1024), BLOCK_SIZE(128));\n\nstatic Sys_var_keycache Sys_key_buffer_size(\n       \"key_buffer_size\", \"The size of the buffer used for \"\n       \"index blocks for MyISAM tables. Increase this to get better index \"\n       \"handling (for all reads and multiple writes) to as much as you can \"\n       \"afford\",\n       KEYCACHE_VAR(param_buff_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_BUFFER_SIZE),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(KEY_CACHE_SIZE),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_buffer_size));\n\nstatic Sys_var_keycache Sys_key_cache_block_size(\n       \"key_cache_block_size\", \"The default size of key cache blocks\",\n       KEYCACHE_VAR(param_block_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_BLOCK_SIZE),\n       VALID_RANGE(512, 1024*16), DEFAULT(KEY_CACHE_BLOCK_SIZE),\n       BLOCK_SIZE(512), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(resize_keycache));\n\nstatic Sys_var_keycache Sys_key_cache_division_limit(\n       \"key_cache_division_limit\",\n       \"The minimum percentage of warm blocks in key cache\",\n       KEYCACHE_VAR(param_division_limit),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_DIVISION_LIMIT),\n       VALID_RANGE(1, 100), DEFAULT(100),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(change_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_age_threshold(\n       \"key_cache_age_threshold\", \"This characterizes the number of \"\n       \"hits a hot block has to be untouched until it is considered aged \"\n       \"enough to be downgraded to a warm block. This specifies the \"\n       \"percentage ratio of that number of hits to the total number of \"\n       \"blocks in key cache\",\n       KEYCACHE_VAR(param_age_threshold),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_AGE_THRESHOLD),\n       VALID_RANGE(100, UINT_MAX), DEFAULT(300),\n       BLOCK_SIZE(100), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(change_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_file_hash_size(\n       \"key_cache_file_hash_size\",\n       \"Number of hash buckets for open and changed files.  If you have a lot of MyISAM \"\n       \"files open you should increase this for faster flush of changes. A good \"\n       \"value is probably 1/10 of number of possible open MyISAM files.\",\n       KEYCACHE_VAR(changed_blocks_hash_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_CHANGED_BLOCKS_HASH_SIZE),\n       VALID_RANGE(128, 16384), DEFAULT(512),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(resize_keycache));\n\nstatic Sys_var_mybool Sys_large_files_support(\n       \"large_files_support\",\n       \"Whether mysqld was compiled with options for large file support\",\n       READ_ONLY GLOBAL_VAR(opt_large_files),\n       CMD_LINE_HELP_ONLY, DEFAULT(sizeof(my_off_t) > 4));\n\nstatic Sys_var_uint Sys_large_page_size(\n       \"large_page_size\",\n       \"If large page support is enabled, this shows the size of memory pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_page_size), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_large_pages(\n       \"large_pages\", \"Enable support for large pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_pages),\n       IF_WIN(NO_CMD_LINE, CMD_LINE(OPT_ARG)), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_language(\n       \"lc_messages_dir\", \"Directory where error messages are\",\n       READ_ONLY GLOBAL_VAR(lc_messages_dir_ptr), CMD_LINE(REQUIRED_ARG, 'L'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_local_infile(\n       \"local_infile\", \"Enable LOAD DATA LOCAL INFILE\",\n       GLOBAL_VAR(opt_local_infile), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_lock_wait_timeout(\n       \"lock_wait_timeout\",\n       \"Timeout in seconds to wait for a lock before returning an error.\",\n       SESSION_VAR(lock_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(24 * 60 * 60), BLOCK_SIZE(1));\n\n#ifdef HAVE_MLOCKALL\nstatic Sys_var_mybool Sys_locked_in_memory(\n       \"locked_in_memory\",\n       \"Whether mysqld was locked in memory with --memlock\",\n       READ_ONLY GLOBAL_VAR(locked_in_memory), NO_CMD_LINE, DEFAULT(FALSE));\n#endif\n\n/* this says NO_CMD_LINE, as command-line option takes a string, not a bool */\nstatic Sys_var_mybool Sys_log_bin(\n       \"log_bin\", \"Whether the binary log is enabled\",\n       READ_ONLY GLOBAL_VAR(opt_bin_log), NO_CMD_LINE, DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_log_bin_compress(\n  \"log_bin_compress\", \"Whether the binary log can be compressed\",\n  GLOBAL_VAR(opt_bin_log_compress), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n/* the min length is 10, means that Begin/Commit/Rollback would never be compressed!   */\nstatic Sys_var_uint Sys_log_bin_compress_min_len(\n  \"log_bin_compress_min_len\",\n  \"Minimum length of sql statement(in statement mode) or record(in row mode)\"\n  \"that can be compressed.\",\n  GLOBAL_VAR(opt_bin_log_compress_min_len),\n  CMD_LINE(OPT_ARG), VALID_RANGE(10, 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_trust_function_creators(\n       \"log_bin_trust_function_creators\",\n       \"If set to FALSE (the default), then when --log-bin is used, creation \"\n       \"of a stored function (or trigger) is allowed only to users having the \"\n       \"SUPER privilege and only if this stored function (trigger) may not \"\n       \"break binary logging. Note that if ALL connections to this server \"\n       \"ALWAYS use row-based binary logging, the security issues do not \"\n       \"exist and the binary logging cannot break, so you can safely set \"\n       \"this to TRUE\",\n       GLOBAL_VAR(trust_function_creators),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_log_error(\n       \"log_error\",\n       \"Log errors to file (instead of stdout).  If file name is not specified \"\n       \"then 'datadir'/'log-basename'.err or the 'pid-file' path with extension \"\n       \".err is used\",\n       READ_ONLY GLOBAL_VAR(log_error_file_ptr),\n       CMD_LINE(OPT_ARG, OPT_LOG_ERROR),\n       IN_FS_CHARSET, DEFAULT(disabled_my_option));\n\nstatic Sys_var_mybool Sys_log_queries_not_using_indexes(\n       \"log_queries_not_using_indexes\",\n       \"Log queries that are executed without benefit of any index to the \"\n       \"slow log if it is open\",\n       GLOBAL_VAR(opt_log_queries_not_using_indexes),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_log_slow_admin_statements(\n       \"log_slow_admin_statements\",\n       \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements to \"\n       \"the slow log if it is open.\",\n       GLOBAL_VAR(opt_log_slow_admin_statements),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_log_slow_slave_statements(\n       \"log_slow_slave_statements\",\n       \"Log slow statements executed by slave thread to the slow log if it is open.\",\n       GLOBAL_VAR(opt_log_slow_slave_statements),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_log_warnings(\n       \"log_warnings\",\n       \"Log some not critical warnings to the general log file.\"\n       \"Value can be between 0 and 11. Higher values mean more verbosity\",\n       SESSION_VAR(log_warnings),\n       CMD_LINE(OPT_ARG, 'W'),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic bool update_cached_long_query_time(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.long_query_time=\n      double2ulonglong(thd->variables.long_query_time_double * 1e6);\n  else\n    global_system_variables.long_query_time=\n      double2ulonglong(global_system_variables.long_query_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_long_query_time(\n       \"long_query_time\",\n       \"Log all queries that have taken more than long_query_time seconds \"\n       \"to execute to file. The argument will be treated as a decimal value \"\n       \"with microsecond precision\",\n       SESSION_VAR(long_query_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_long_query_time));\n\n\nstatic bool update_cached_max_statement_time(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.max_statement_time=\n      double2ulonglong(thd->variables.max_statement_time_double * 1e6);\n  else\n    global_system_variables.max_statement_time=\n      double2ulonglong(global_system_variables.max_statement_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_max_statement_time(\n       \"max_statement_time\",\n       \"A query that has taken more than max_statement_time seconds \"\n       \"will be aborted. The argument will be treated as a decimal value \"\n       \"with microsecond precision. A value of 0 (default) means no timeout\",\n       SESSION_VAR(max_statement_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_max_statement_time));\n\nstatic bool fix_low_prio_updates(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_lock_default= (thd->variables.low_priority_updates ?\n                               TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  else\n    thr_upgraded_concurrent_insert_lock=\n      (global_system_variables.low_priority_updates ?\n       TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  return false;\n}\nstatic Sys_var_mybool Sys_low_priority_updates(\n       \"low_priority_updates\",\n       \"INSERT/DELETE/UPDATE has lower priority than selects\",\n       SESSION_VAR(low_priority_updates),\n       CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_low_prio_updates));\n\nstatic Sys_var_mybool Sys_lower_case_file_system(\n       \"lower_case_file_system\",\n       \"Case sensitivity of file names on the file system where the \"\n       \"data directory is located\",\n       READ_ONLY GLOBAL_VAR(lower_case_file_system),\n       CMD_LINE_HELP_ONLY,\n       DEFAULT(FALSE));\n\nstatic Sys_var_uint Sys_lower_case_table_names(\n       \"lower_case_table_names\",\n       \"If set to 1 table names are stored in lowercase on disk and table \"\n       \"names will be case-insensitive.  Should be set to 2 if you are using \"\n       \"a case insensitive file system\",\n       READ_ONLY GLOBAL_VAR(lower_case_table_names),\n       CMD_LINE(OPT_ARG, OPT_LOWER_CASE_TABLE_NAMES),\n       VALID_RANGE(0, 2),\n#ifdef FN_NO_CASE_SENSE\n    DEFAULT(1),\n#else\n    DEFAULT(0),\n#endif\n       BLOCK_SIZE(1));\n\nstatic bool session_readonly(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_GLOBAL)\n    return false;\n  my_error(ER_VARIABLE_IS_READONLY, MYF(0), \"SESSION\",\n           self->name.str, \"GLOBAL\");\n  return true;\n}\n\nstatic bool check_max_allowed_packet(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val < (longlong) global_system_variables.net_buffer_length)\n  {\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\n\n\nstatic Sys_var_ulong Sys_max_allowed_packet(\n       \"max_allowed_packet\",\n       \"Max packet length to send to or receive from the server\",\n       SESSION_VAR(max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_allowed_packet));\n\nstatic Sys_var_ulong Sys_slave_max_allowed_packet(\n       \"slave_max_allowed_packet\",\n       \"The maximum packet length to sent successfully from the master to slave.\",\n       GLOBAL_VAR(slave_max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, MAX_MAX_ALLOWED_PACKET),\n       DEFAULT(MAX_MAX_ALLOWED_PACKET),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_ulonglong Sys_max_binlog_cache_size(\n       \"max_binlog_cache_size\",\n       \"Sets the total size of the transactional cache\",\n       GLOBAL_VAR(max_binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX),\n       DEFAULT((SIZE_T_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong Sys_max_binlog_stmt_cache_size(\n       \"max_binlog_stmt_cache_size\",\n       \"Sets the total size of the statement cache\",\n       GLOBAL_VAR(max_binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX),\n       DEFAULT((SIZE_T_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool fix_max_binlog_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_bin_log.set_max_size(max_binlog_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_max_binlog_size(\n       \"max_binlog_size\",\n       \"Binary log will be rotated automatically when the size exceeds this \"\n       \"value.\",\n       GLOBAL_VAR(max_binlog_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, 1024*1024L*1024L), DEFAULT(1024*1024L*1024L),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_binlog_size));\n\nstatic bool fix_max_connections(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifndef EMBEDDED_LIBRARY\n  resize_thr_alarm(max_connections + extra_max_connections +\n                   global_system_variables.max_insert_delayed_threads + 10);\n#endif\n  return false;\n}\n\n// Default max_connections of 151 is larger than Apache's default max\n// children, to avoid \"too many connections\" error in a common setup\nstatic Sys_var_ulong Sys_max_connections(\n       \"max_connections\", \"The number of simultaneous clients allowed\",\n       PARSED_EARLY GLOBAL_VAR(max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 100000),\n       DEFAULT(MAX_CONNECTIONS_DEFAULT), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_connect_errors(\n       \"max_connect_errors\",\n       \"If there is more than this number of interrupted connections from \"\n       \"a host this host will be blocked from further connections\",\n       GLOBAL_VAR(max_connect_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(MAX_CONNECT_ERRORS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_max_digest_length(\n       \"max_digest_length\", \"Maximum length considered for digest text.\",\n       READ_ONLY GLOBAL_VAR(max_digest_length),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024 * 1024), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic bool check_max_delayed_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return var->type != OPT_GLOBAL &&\n         var->save_result.ulonglong_value != 0 &&\n         var->save_result.ulonglong_value !=\n                           global_system_variables.max_insert_delayed_threads;\n}\n\n// Alias for max_delayed_threads\nstatic Sys_var_ulong Sys_max_insert_delayed_threads(\n       \"max_insert_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       NO_CMD_LINE, VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_delayed_threads(\n       \"max_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_error_count(\n       \"max_error_count\",\n       \"Max number of errors/warnings to store for a statement\",\n       SESSION_VAR(max_error_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(DEFAULT_ERROR_COUNT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_max_heap_table_size(\n       \"max_heap_table_size\",\n       \"Don't allow creation of heap tables bigger than this\",\n       SESSION_VAR(max_heap_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(16384, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024));\n\nstatic ulong mdl_locks_cache_size;\nstatic Sys_var_ulong Sys_metadata_locks_cache_size(\n       \"metadata_locks_cache_size\", \"Unused\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024*1024), DEFAULT(1024),\n       BLOCK_SIZE(1));\n\nstatic ulong mdl_locks_hash_partitions;\nstatic Sys_var_ulong Sys_metadata_locks_hash_instances(\n       \"metadata_locks_hash_instances\", \"Unused\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_hash_partitions), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024), DEFAULT(8),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_pseudo_thread_id(\n       \"pseudo_thread_id\",\n       \"This variable is for internal server use\",\n       SESSION_ONLY(pseudo_thread_id),\n       NO_CMD_LINE, VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n       ON_CHECK(check_has_super));\n\nstatic bool\ncheck_gtid_domain_id(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n  if (var->type != OPT_GLOBAL &&\n      error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO))\n    return true;\n\n  return false;\n}\n\n\nstatic Sys_var_uint Sys_gtid_domain_id(\n       \"gtid_domain_id\",\n       \"Used with global transaction ID to identify logically independent \"\n       \"replication streams. When events can propagate through multiple \"\n       \"parallel paths (for example multiple masters), each independent \"\n       \"source server must use a distinct domain_id. For simple tree-shaped \"\n       \"replication topologies, it can be left at its default, 0.\",\n       SESSION_VAR(gtid_domain_id),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, UINT_MAX32), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_gtid_domain_id));\n\n\nstatic bool check_gtid_seq_no(sys_var *self, THD *thd, set_var *var)\n{\n  uint32 domain_id, server_id;\n  uint64 seq_no;\n\n  if (check_has_super(self, thd, var))\n    return true;\n  if (error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO))\n    return true;\n\n  domain_id= thd->variables.gtid_domain_id;\n  server_id= thd->variables.server_id;\n  seq_no= (uint64)var->value->val_uint();\n  DBUG_EXECUTE_IF(\"ignore_set_gtid_seq_no_check\", return 0;);\n  if (opt_gtid_strict_mode && opt_bin_log &&\n      mysql_bin_log.check_strict_gtid_sequence(domain_id, server_id, seq_no))\n    return true;\n\n  return false;\n}\n\n\nstatic Sys_var_ulonglong Sys_gtid_seq_no(\n       \"gtid_seq_no\",\n       \"Internal server usage, for replication with global transaction id. \"\n       \"When set, next event group logged to the binary log will use this \"\n       \"sequence number, not generate a new one, thus allowing to preserve \"\n       \"master's GTID in slave's binlog.\",\n       SESSION_ONLY(gtid_seq_no),\n       NO_CMD_LINE, VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_gtid_seq_no));\n\n\n#ifdef HAVE_REPLICATION\nstatic unsigned char opt_gtid_binlog_pos_dummy;\nstatic Sys_var_gtid_binlog_pos Sys_gtid_binlog_pos(\n       \"gtid_binlog_pos\", \"Last GTID logged to the binary log, per replication\"\n       \"domain\",\n       READ_ONLY GLOBAL_VAR(opt_gtid_binlog_pos_dummy), NO_CMD_LINE);\n\n\nuchar *\nSys_var_gtid_binlog_pos::global_value_ptr(THD *thd, const LEX_STRING *base)\n{\n  char buf[128];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n\n  str.length(0);\n  if ((opt_bin_log && mysql_bin_log.append_state_pos(&str)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_current_pos_dummy;\nstatic Sys_var_gtid_current_pos Sys_gtid_current_pos(\n       \"gtid_current_pos\", \"Current GTID position of the server. Per \"\n       \"replication domain, this is either the last GTID replicated by a \"\n       \"slave thread, or the GTID logged to the binary log, whichever is \"\n       \"most recent.\",\n       READ_ONLY GLOBAL_VAR(opt_gtid_current_pos_dummy), NO_CMD_LINE);\n\n\nuchar *\nSys_var_gtid_current_pos::global_value_ptr(THD *thd, const LEX_STRING *base)\n{\n  String str;\n  char *p;\n\n  str.length(0);\n  if (rpl_append_gtid_state(&str, true) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nbool\nSys_var_gtid_slave_pos::do_check(THD *thd, set_var *var)\n{\n  String str, *res;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (rpl_load_gtid_slave_state(thd))\n  {\n    my_error(ER_CANNOT_LOAD_SLAVE_GTID_STATE, MYF(0), \"mysql\",\n             rpl_gtid_slave_state_table_name.str);\n    return true;\n  }\n\n  if (give_error_if_slave_running(0))\n    return true;\n  if (!(res= var->value->val_str(&str)))\n    return true;\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_CANT_DO_THIS_DURING_AN_TRANSACTION, MYF(0));\n    return true;\n  }\n  if (rpl_gtid_pos_check(thd, &((*res)[0]), res->length()))\n    return true;\n\n  if (!(var->save_result.string_value.str=\n        thd->strmake(res->ptr(), res->length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return true;\n  }\n  var->save_result.string_value.length= res->length();\n  return false;\n}\n\n\nbool\nSys_var_gtid_slave_pos::global_update(THD *thd, set_var *var)\n{\n  bool err;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n  if (give_error_if_slave_running(1))\n    err= true;\n  else\n    err= rpl_gtid_pos_update(thd, var->save_result.string_value.str,\n                             var->save_result.string_value.length);\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return err;\n}\n\n\nuchar *\nSys_var_gtid_slave_pos::global_value_ptr(THD *thd, const LEX_STRING *base)\n{\n  String str;\n  char *p;\n\n  str.length(0);\n  /*\n    If the mysql.rpl_slave_pos table could not be loaded, then we cannot\n    easily automatically try to reload it here - we may be inside a statement\n    that already has tables locked and so opening more tables is problematic.\n\n    But if the table is not loaded (eg. missing mysql_upgrade_db or some such),\n    then the slave state must be empty anyway.\n  */\n  if ((rpl_global_gtid_slave_state->loaded &&\n       rpl_append_gtid_state(&str, false)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_slave_pos_dummy;\nstatic Sys_var_gtid_slave_pos Sys_gtid_slave_pos(\n       \"gtid_slave_pos\",\n       \"The list of global transaction IDs that were last replicated on the \"\n       \"server, one for each replication domain.\",\n       GLOBAL_VAR(opt_gtid_slave_pos_dummy), NO_CMD_LINE);\n\n\nstatic Sys_var_mybool Sys_gtid_strict_mode(\n       \"gtid_strict_mode\",\n       \"Enforce strict seq_no ordering of events in the binary log. Slave \"\n       \"stops with an error if it encounters an event that would cause it to \"\n       \"generate an out-of-order binlog if executed.\",\n       GLOBAL_VAR(opt_gtid_strict_mode),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n\nstruct gtid_binlog_state_data { rpl_gtid *list; uint32 list_len; };\n\nbool\nSys_var_gtid_binlog_state::do_check(THD *thd, set_var *var)\n{\n  String str, *res;\n  struct gtid_binlog_state_data *data;\n  rpl_gtid *list;\n  uint32 list_len;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!(res= var->value->val_str(&str)))\n    return true;\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_CANT_DO_THIS_DURING_AN_TRANSACTION, MYF(0));\n    return true;\n  }\n  if (!mysql_bin_log.is_open())\n  {\n    my_error(ER_FLUSH_MASTER_BINLOG_CLOSED, MYF(0));\n    return true;\n  }\n  if (!mysql_bin_log.is_empty_state())\n  {\n    my_error(ER_BINLOG_MUST_BE_EMPTY, MYF(0));\n    return true;\n  }\n  if (res->length() == 0)\n  {\n    list= NULL;\n    list_len= 0;\n  }\n  else if (!(list= gtid_parse_string_to_list(res->ptr(), res->length(),\n                                             &list_len)))\n  {\n    my_error(ER_INCORRECT_GTID_STATE, MYF(0));\n    return true;\n  }\n  if (!(data= (gtid_binlog_state_data *)my_malloc(sizeof(*data), MYF(0))))\n  {\n    my_free(list);\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return true;\n  }\n  data->list= list;\n  data->list_len= list_len;\n  var->save_result.ptr= data;\n  return false;\n}\n\n\nbool\nSys_var_gtid_binlog_state::global_update(THD *thd, set_var *var)\n{\n  bool res;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  struct gtid_binlog_state_data *data=\n    (struct gtid_binlog_state_data *)var->save_result.ptr;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  res= (reset_master(thd, data->list, data->list_len, 0) != 0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  my_free(data->list);\n  my_free(data);\n  return res;\n}\n\n\nuchar *\nSys_var_gtid_binlog_state::global_value_ptr(THD *thd, const LEX_STRING *base)\n{\n  char buf[512];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n\n  str.length(0);\n  if ((opt_bin_log && mysql_bin_log.append_state(&str)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_binlog_state_dummy;\nstatic Sys_var_gtid_binlog_state Sys_gtid_binlog_state(\n       \"gtid_binlog_state\",\n       \"The internal GTID state of the binlog, used to keep track of all \"\n       \"GTIDs ever logged to the binlog.\",\n       GLOBAL_VAR(opt_gtid_binlog_state_dummy), NO_CMD_LINE);\n\n\nstatic Sys_var_last_gtid Sys_last_gtid(\n       \"last_gtid\", \"The GTID of the last commit (if binlogging was enabled), \"\n       \"or the empty string if none.\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE);\n\n\nuchar *\nSys_var_last_gtid::session_value_ptr(THD *thd, const LEX_STRING *base)\n{\n  char buf[10+1+10+1+20+1];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n  bool first= true;\n\n  str.length(0);\n  if ((thd->last_commit_gtid.seq_no > 0 &&\n       rpl_slave_state_tostring_helper(&str, &thd->last_commit_gtid, &first)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic bool\ncheck_slave_parallel_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_slave_parallel_threads(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool err;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  err= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return err;\n}\n\n\nstatic Sys_var_ulong Sys_slave_parallel_threads(\n       \"slave_parallel_threads\",\n       \"If non-zero, number of threads to spawn to apply in parallel events \"\n       \"on the slave that were group-committed on the master or were logged \"\n       \"with GTID in different replication domains. Note that these threads \"\n       \"are in addition to the IO and SQL threads, which are always created \"\n       \"by a replication slave\",\n       GLOBAL_VAR(opt_slave_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_parallel_threads),\n       ON_UPDATE(fix_slave_parallel_threads));\n\n/* Alias for @@slave_parallel_threads to match what MySQL 5.7 uses. */\nstatic Sys_var_ulong Sys_slave_parallel_workers(\n       \"slave_parallel_workers\",\n       \"Alias for slave_parallel_threads\",\n       GLOBAL_VAR(opt_slave_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_parallel_threads),\n       ON_UPDATE(fix_slave_parallel_threads));\n\n\nstatic bool\ncheck_slave_domain_parallel_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_slave_domain_parallel_threads(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool running;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  running= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return running;\n}\n\n\nstatic Sys_var_ulong Sys_slave_domain_parallel_threads(\n       \"slave_domain_parallel_threads\",\n       \"Maximum number of parallel threads to use on slave for events in a \"\n       \"single replication domain. When using multiple domains, this can be \"\n       \"used to limit a single domain from grabbing all threads and thus \"\n       \"stalling other domains. The default of 0 means to allow a domain to \"\n       \"grab as many threads as it wants, up to the value of \"\n       \"slave_parallel_threads.\",\n       GLOBAL_VAR(opt_slave_domain_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_domain_parallel_threads),\n       ON_UPDATE(fix_slave_domain_parallel_threads));\n\n\nstatic Sys_var_ulong Sys_slave_parallel_max_queued(\n       \"slave_parallel_max_queued\",\n       \"Limit on how much memory SQL threads should use per parallel \"\n       \"replication thread when reading ahead in the relay log looking for \"\n       \"opportunities for parallel replication. Only used when \"\n       \"--slave-parallel-threads > 0.\",\n       GLOBAL_VAR(opt_slave_parallel_max_queued), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,2147483647), DEFAULT(131072), BLOCK_SIZE(1));\n\n\nbool\nSys_var_slave_parallel_mode::global_update(THD *thd, set_var *var)\n{\n  enum_slave_parallel_mode new_value=\n    (enum_slave_parallel_mode)var->save_result.ulonglong_value;\n  LEX_STRING *base_name= &var->base;\n  Master_info *mi;\n  bool res= false;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n\n  mi= master_info_index->\n    get_master_info(base_name, !base_name->length ?\n                    Sql_condition::WARN_LEVEL_ERROR :\n                    Sql_condition::WARN_LEVEL_WARN);\n\n  if (mi)\n  {\n    if (mi->rli.slave_running)\n    {\n      my_error(ER_SLAVE_MUST_STOP, MYF(0),\n          mi->connection_name.length, mi->connection_name.str);\n      res= true;\n    }\n    else\n    {\n      mi->parallel_mode= new_value;\n      if (!base_name->length)\n      {\n        /* Use as default value for new connections */\n        opt_slave_parallel_mode= new_value;\n      }\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return res;\n}\n\n\nuchar *\nSys_var_slave_parallel_mode::global_value_ptr(THD *thd,\n                                              const LEX_STRING *base_name)\n{\n  Master_info *mi;\n  enum_slave_parallel_mode val=\n    (enum_slave_parallel_mode)opt_slave_parallel_mode;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n\n  mi= master_info_index->\n    get_master_info(base_name, !base_name->length ?\n                    Sql_condition::WARN_LEVEL_ERROR :\n                    Sql_condition::WARN_LEVEL_WARN);\n  if (mi)\n    val= mi->parallel_mode;\n\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (!mi)\n    return 0;\n\n  return valptr(thd, val);\n}\n\n\n/* The order here must match enum_slave_parallel_mode in mysqld.h. */\nstatic const char *slave_parallel_mode_names[] = {\n  \"none\", \"minimal\", \"conservative\", \"optimistic\", \"aggressive\", NULL\n};\nexport TYPELIB slave_parallel_mode_typelib = {\n  array_elements(slave_parallel_mode_names)-1,\n  \"\",\n  slave_parallel_mode_names,\n  NULL\n};\n\nstatic Sys_var_slave_parallel_mode Sys_slave_parallel_mode(\n       \"slave_parallel_mode\",\n       \"Controls what transactions are applied in parallel when using \"\n       \"--slave-parallel-threads. Possible values: \\\"optimistic\\\" tries to \"\n       \"apply most transactional DML in parallel, and handles any conflicts \"\n       \"with rollback and retry. \\\"conservative\\\" limits parallelism in an \"\n       \"effort to avoid any conflicts. \\\"aggressive\\\" tries to maximise the \"\n       \"parallelism, possibly at the cost of increased conflict rate. \"\n       \"\\\"minimal\\\" only parallelizes the commit steps of transactions. \"\n       \"\\\"none\\\" disables parallel apply completely.\",\n       GLOBAL_VAR(opt_slave_parallel_mode), NO_CMD_LINE,\n       slave_parallel_mode_names, DEFAULT(SLAVE_PARALLEL_CONSERVATIVE));\n\n\nstatic Sys_var_bit Sys_skip_parallel_replication(\n       \"skip_parallel_replication\",\n       \"If set when a transaction is written to the binlog, parallel apply of \"\n       \"that transaction will be avoided on a slave where slave_parallel_mode \"\n       \"is not \\\"aggressive\\\". Can be used to avoid unnecessary rollback and \"\n       \"retry for transactions that are likely to cause a conflict if \"\n       \"replicated in parallel.\",\n       SESSION_ONLY(option_bits), NO_CMD_LINE, OPTION_RPL_SKIP_PARALLEL,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\n\nstatic bool\ncheck_gtid_ignore_duplicates(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_gtid_ignore_duplicates(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool running;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  running= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return running;\n}\n\n\nstatic Sys_var_mybool Sys_gtid_ignore_duplicates(\n       \"gtid_ignore_duplicates\",\n       \"When set, different master connections in multi-source replication are \"\n       \"allowed to receive and process event groups with the same GTID (when \"\n       \"using GTID mode). Only one will be applied, any others will be \"\n       \"ignored. Within a given replication domain, just the sequence number \"\n       \"will be used to decide whether a given GTID has been already applied; \"\n       \"this means it is the responsibility of the user to ensure that GTID \"\n       \"sequence numbers are strictly increasing.\",\n       GLOBAL_VAR(opt_gtid_ignore_duplicates), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_gtid_ignore_duplicates),\n       ON_UPDATE(fix_gtid_ignore_duplicates));\n#endif\n\n\nstatic Sys_var_ulong Sys_binlog_commit_wait_count(\n       \"binlog_commit_wait_count\",\n       \"If non-zero, binlog write will wait at most binlog_commit_wait_usec \"\n       \"microseconds for at least this many commits to queue up for group \"\n       \"commit to the binlog. This can reduce I/O on the binlog and provide \"\n       \"increased opportunity for parallel apply on the slave, but too high \"\n       \"a value will decrease commit throughput.\",\n       GLOBAL_VAR(opt_binlog_commit_wait_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n\nstatic Sys_var_ulong Sys_binlog_commit_wait_usec(\n       \"binlog_commit_wait_usec\",\n       \"Maximum time, in microseconds, to wait for more commits to queue up \"\n       \"for binlog group commit. Only takes effect if the value of \"\n       \"binlog_commit_wait_count is non-zero.\",\n       GLOBAL_VAR(opt_binlog_commit_wait_usec), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(100000), BLOCK_SIZE(1));\n\n\nstatic bool fix_max_join_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  if (sv->max_join_size == HA_POS_ERROR)\n    sv->option_bits|= OPTION_BIG_SELECTS;\n  else\n    sv->option_bits&= ~OPTION_BIG_SELECTS;\n  return false;\n}\nstatic Sys_var_harows Sys_max_join_size(\n       \"max_join_size\",\n       \"Joins that are probably going to read more than max_join_size \"\n       \"records return an error\",\n       SESSION_VAR(max_join_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_join_size));\n\nstatic Sys_var_ulong Sys_max_seeks_for_key(\n       \"max_seeks_for_key\",\n       \"Limit assumed max number of seeks when looking up rows based on a key\",\n       SESSION_VAR(max_seeks_for_key), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_length_for_sort_data(\n       \"max_length_for_sort_data\",\n       \"Max number of bytes in sorted records\",\n       SESSION_VAR(max_length_for_sort_data), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_long_data_size(\n       \"max_long_data_size\",\n       \"The maximum BLOB length to send to server from \"\n       \"mysql_send_long_data API. Deprecated option; \"\n       \"use max_allowed_packet instead.\",\n       READ_ONLY GLOBAL_VAR(max_long_data_size),\n       CMD_LINE(REQUIRED_ARG, OPT_MAX_LONG_DATA_SIZE),\n       VALID_RANGE(1024, UINT_MAX32), DEFAULT(1024*1024),\n       BLOCK_SIZE(1));\n\nstatic PolyLock_mutex PLock_prepared_stmt_count(&LOCK_prepared_stmt_count);\nstatic Sys_var_ulong Sys_max_prepared_stmt_count(\n       \"max_prepared_stmt_count\",\n       \"Maximum number of prepared statements in the server\",\n       GLOBAL_VAR(max_prepared_stmt_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024*1024), DEFAULT(16382), BLOCK_SIZE(1),\n       &PLock_prepared_stmt_count);\n\nstatic Sys_var_ulong Sys_max_recursive_iterations(\n       \"max_recursive_iterations\",\n       \"Maximum number of iterations when executing recursive queries\",\n       SESSION_VAR(max_recursive_iterations), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sort_length(\n       \"max_sort_length\",\n       \"The number of bytes to use when sorting BLOB or TEXT values (only \"\n       \"the first max_sort_length bytes of each value are used; the rest \"\n       \"are ignored)\",\n       SESSION_VAR(max_sort_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sp_recursion_depth(\n       \"max_sp_recursion_depth\",\n       \"Maximum stored procedure recursion depth\",\n       SESSION_VAR(max_sp_recursion_depth), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, 255), DEFAULT(0), BLOCK_SIZE(1));\n\n\nstatic bool if_checking_enabled(sys_var *self, THD *thd,  set_var *var)\n{\n  if (session_readonly(self, thd, var))\n    return true;\n  \n  if (!max_user_connections_checking)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--max-user-connections=0\");\n    return true;\n  }\n\n  return false;\n}\n// non-standard session_value_ptr() here\nstatic Sys_var_max_user_conn Sys_max_user_connections(\n       \"max_user_connections\",\n       \"The maximum number of active connections for a single user \"\n       \"(0 = no limit)\",\n       SESSION_VAR(max_user_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(-1, INT_MAX), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(if_checking_enabled));\n\nstatic Sys_var_ulong Sys_max_tmp_tables(\n       \"max_tmp_tables\", \"Unused, will be removed.\",\n       SESSION_VAR(max_tmp_tables), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(32), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_write_lock_count(\n       \"max_write_lock_count\",\n       \"After this many write locks, allow some read locks to run in between\",\n       GLOBAL_VAR(max_write_lock_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_min_examined_row_limit(\n       \"min_examined_row_limit\",\n       \"Don't write queries to slow log that examine fewer rows \"\n       \"than that\",\n       SESSION_VAR(min_examined_row_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef _WIN32\nstatic Sys_var_mybool Sys_named_pipe(\n       \"named_pipe\", \"Enable the named pipe (NT)\",\n       READ_ONLY GLOBAL_VAR(opt_enable_named_pipe), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif\n\n\nstatic bool check_net_buffer_length(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val > (longlong) global_system_variables.max_allowed_packet)\n  {\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_buffer_length(\n       \"net_buffer_length\",\n       \"Buffer length for TCP/IP and socket communication\",\n       SESSION_VAR(net_buffer_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024), DEFAULT(16384), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_net_buffer_length));\n\nstatic bool fix_net_read_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_read_timeout(&thd->net, thd->variables.net_read_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_read_timeout(\n       \"net_read_timeout\",\n       \"Number of seconds to wait for more data from a connection before \"\n       \"aborting the read\",\n       SESSION_VAR(net_read_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_READ_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_read_timeout));\n\nstatic bool fix_net_write_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_write_timeout(&thd->net, thd->variables.net_write_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_write_timeout(\n       \"net_write_timeout\",\n       \"Number of seconds to wait for a block to be written to a connection \"\n       \"before aborting the write\",\n       SESSION_VAR(net_write_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WRITE_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_write_timeout));\n\nstatic bool fix_net_retry_count(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    thd->net.retry_count=thd->variables.net_retry_count;\n  return false;\n}\nstatic Sys_var_ulong Sys_net_retry_count(\n       \"net_retry_count\",\n       \"If a read on a communication port is interrupted, retry this \"\n       \"many times before giving up\",\n       SESSION_VAR(net_retry_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(MYSQLD_NET_RETRY_COUNT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_retry_count));\n\nstatic Sys_var_mybool Sys_old_mode(\n       \"old\", \"Use compatible behavior from previous MariaDB version. See also --old-mode\",\n       SESSION_VAR(old_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_old_alter_table(\n       \"old_alter_table\", \"Use old, non-optimized alter table\",\n       SESSION_VAR(old_alter_table), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_old_passwords(sys_var *self, THD *thd, set_var *var)\n{\n  return mysql_user_table_is_in_short_password_format;\n}\nstatic Sys_var_mybool Sys_old_passwords(\n       \"old_passwords\",\n       \"Use old password encryption method (needed for 4.0 and older clients)\",\n       SESSION_VAR(old_passwords), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_old_passwords));\nexport sys_var *Sys_old_passwords_ptr= &Sys_old_passwords; // for sql_acl.cc\n\nstatic Sys_var_ulong Sys_open_files_limit(\n       \"open_files_limit\",\n       \"If this is not 0, then mysqld will use this value to reserve file \"\n       \"descriptors to use with setrlimit(). If this value is 0 then mysqld \"\n       \"will reserve max_connections*5 or max_connections + table_cache*2 \"\n       \"(whichever is larger) number of file descriptors\",\n       READ_ONLY GLOBAL_VAR(open_files_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, OS_FILE_LIMIT), DEFAULT(0), BLOCK_SIZE(1));\n\n/// @todo change to enum\nstatic Sys_var_ulong Sys_optimizer_prune_level(\n       \"optimizer_prune_level\",\n       \"Controls the heuristic(s) applied during query optimization to prune \"\n       \"less-promising partial plans from the optimizer search space. \"\n       \"Meaning: 0 - do not apply any heuristic, thus perform exhaustive \"\n       \"search; 1 - prune plans based on number of retrieved rows\",\n       SESSION_VAR(optimizer_prune_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_selectivity_sampling_limit(\n       \"optimizer_selectivity_sampling_limit\",\n       \"Controls number of record samples to check condition selectivity\",\n       SESSION_VAR(optimizer_selectivity_sampling_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(SELECTIVITY_SAMPLING_THRESHOLD, UINT_MAX),\n       DEFAULT(SELECTIVITY_SAMPLING_LIMIT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_use_condition_selectivity(\n       \"optimizer_use_condition_selectivity\",\n       \"Controls selectivity of which conditions the optimizer takes into \"\n       \"account to calculate cardinality of a partial join when it searches \"\n       \"for the best execution plan \"\n       \"Meaning: \"\n       \"1 - use selectivity of index backed range conditions to calculate \"\n       \"the cardinality of a partial join if the last joined table is \"\n       \"accessed by full table scan or an index scan, \"\n       \"2 - use selectivity of index backed range conditions to calculate \"\n       \"the cardinality of a partial join in any case, \"\n       \"3 - additionally always use selectivity of range conditions that are \"\n       \"not backed by any index to calculate the cardinality of a partial join, \"\n       \"4 - use histograms to calculate selectivity of range conditions that \"\n       \"are not backed by any index to calculate the cardinality of \"\n       \"a partial join.\"\n       \"5 - additionally use selectivity of certain non-range predicates \"\n       \"calculated on record samples\",\n       SESSION_VAR(optimizer_use_condition_selectivity), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 5), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_search_depth(\n       \"optimizer_search_depth\",\n       \"Maximum depth of search performed by the query optimizer. Values \"\n       \"larger than the number of relations in a query result in better \"\n       \"query plans, but take longer to compile a query. Values smaller \"\n       \"than the number of tables in a relation result in faster \"\n       \"optimization, but may produce very bad query plans. If set to 0, \"\n       \"the system will automatically pick a reasonable value.\",\n       SESSION_VAR(optimizer_search_depth), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, MAX_TABLES+1), DEFAULT(MAX_TABLES+1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0));\n\n/* this is used in the sigsegv handler */\nexport const char *optimizer_switch_names[]=\n{\n  \"index_merge\",\"index_merge_union\",\"index_merge_sort_union\",\n  \"index_merge_intersection\",\"index_merge_sort_intersection\",\n  \"engine_condition_pushdown\",\n  \"index_condition_pushdown\",\n  \"derived_merge\", \"derived_with_keys\",\n  \"firstmatch\",\"loosescan\",\"materialization\",\"in_to_exists\",\"semijoin\",\n  \"partial_match_rowid_merge\",\n  \"partial_match_table_scan\",\n  \"subquery_cache\",\n  \"mrr\",\n  \"mrr_cost_based\",\n  \"mrr_sort_keys\",\n  \"outer_join_with_cache\",\n  \"semijoin_with_cache\",\n  \"join_cache_incremental\",\n  \"join_cache_hashed\",\n  \"join_cache_bka\",\n  \"optimize_join_buffer_size\",\n  \"table_elimination\",\n  \"extended_keys\",\n  \"exists_to_in\",\n  \"orderby_uses_equalities\",\n  \"condition_pushdown_for_derived\",\n  \"default\", \n  NullS\n};\nstatic bool fix_optimizer_switch(sys_var *self, THD *thd,\n                                 enum_var_type type)\n{\n  SV *sv= (type == OPT_GLOBAL) ? &global_system_variables : &thd->variables;\n  if (sv->optimizer_switch & deprecated_ENGINE_CONDITION_PUSHDOWN)\n    push_warning_printf(current_thd, Sql_condition::WARN_LEVEL_WARN,\n                        ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,\n                        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),\n                        \"engine_condition_pushdown=on\");\n  return false;\n}\nstatic Sys_var_flagset Sys_optimizer_switch(\n       \"optimizer_switch\",\n       \"Fine-tune the optimizer behavior\",\n       SESSION_VAR(optimizer_switch), CMD_LINE(REQUIRED_ARG),\n       optimizer_switch_names, DEFAULT(OPTIMIZER_SWITCH_DEFAULT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_optimizer_switch));\n\nstatic Sys_var_charptr Sys_pid_file(\n       \"pid_file\", \"Pid file used by safe_mysqld\",\n       READ_ONLY GLOBAL_VAR(pidfile_name_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_plugin_dir(\n       \"plugin_dir\", \"Directory for plugins\",\n       READ_ONLY GLOBAL_VAR(opt_plugin_dir_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_port(\n       \"port\",\n       \"Port number to use for connection or 0 to default to, \"\n       \"my.cnf, $MYSQL_TCP_PORT, \"\n#if MYSQL_PORT_DEFAULT == 0\n       \"/etc/services, \"\n#endif\n       \"built-in default (\" STRINGIFY_ARG(MYSQL_PORT) \"), whatever comes first\",\n       READ_ONLY GLOBAL_VAR(mysqld_port), CMD_LINE(REQUIRED_ARG, 'P'),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_preload_buff_size(\n       \"preload_buffer_size\",\n       \"The size of the buffer that is allocated when preloading indexes\",\n       SESSION_VAR(preload_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(32768), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_protocol_version(\n       \"protocol_version\",\n       \"The version of the client/server protocol used by the MariaDB server\",\n       READ_ONLY GLOBAL_VAR(protocol_version), CMD_LINE_HELP_ONLY,\n       VALID_RANGE(0, ~0U), DEFAULT(PROTOCOL_VERSION), BLOCK_SIZE(1));\n\nstatic Sys_var_proxy_user Sys_proxy_user(\n       \"proxy_user\", \"The proxy user account name used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_external_user Sys_exterenal_user(\n       \"external_user\", \"The external user account used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_ulong Sys_read_buff_size(\n       \"read_buffer_size\",\n       \"Each thread that does a sequential scan allocates a buffer of \"\n       \"this size for each table it scans. If you do many sequential scans, \"\n       \"you may want to increase this value\",\n       SESSION_VAR(read_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(128*1024),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  /* Prevent self dead-lock */\n  if (thd->locked_tables_mode || thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n    return true;\n  }\n  return false;\n}\nstatic bool fix_read_only(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool result= true;\n  my_bool new_read_only= read_only; // make a copy before releasing a mutex\n  DBUG_ENTER(\"sys_var_opt_readonly::update\");\n\n  if (read_only == FALSE || read_only == opt_readonly)\n  {\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  if (check_read_only(self, thd, 0)) // just in case\n    goto end;\n\n  if (thd->global_read_lock.is_acquired())\n  {\n    /*\n      This connection already holds the global read lock.\n      This can be the case with:\n      - FLUSH TABLES WITH READ LOCK\n      - SET GLOBAL READ_ONLY = 1\n    */\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  /*\n    READ_ONLY=1 prevents write locks from being taken on tables and\n    blocks transactions from committing. We therefore should make sure\n    that no such events occur while setting the read_only variable.\n    This is a 2 step process:\n    [1] lock_global_read_lock()\n      Prevents connections from obtaining new write locks on\n      tables. Note that we can still have active rw transactions.\n    [2] make_global_read_lock_block_commit()\n      Prevents transactions from committing.\n  */\n\n  read_only= opt_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result= thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n\n  /* Change the opt_readonly system variable, safe because the lock is held */\n  opt_readonly= new_read_only;\n  result= false;\n\n end_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\n end_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\n end:\n  read_only= opt_readonly;\n  DBUG_RETURN(result);\n}\n\n\n/**\n  The read_only boolean is always equal to the opt_readonly boolean except\n  during fix_read_only(); when that function is entered, opt_readonly is\n  the pre-update value and read_only is the post-update value.\n  fix_read_only() compares them and runs needed operations for the\n  transition (especially when transitioning from false to true) and\n  synchronizes both booleans in the end.\n*/\nstatic Sys_var_mybool Sys_readonly(\n       \"read_only\",\n       \"Make all non-temporary tables read-only, with the exception for \"\n       \"replication (slave) threads and users with the SUPER privilege\",\n       GLOBAL_VAR(read_only), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_read_only), ON_UPDATE(fix_read_only));\n\n// Small lower limit to be able to test MRR\nstatic Sys_var_ulong Sys_read_rnd_buff_size(\n       \"read_rnd_buffer_size\",\n       \"When reading rows in sorted order after a sort, the rows are read \"\n       \"through this buffer to avoid a disk seeks\",\n       SESSION_VAR(read_rnd_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_div_precincrement(\n       \"div_precision_increment\", \"Precision of the result of '/' \"\n       \"operator will be increased on that value\",\n       SESSION_VAR(div_precincrement), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, DECIMAL_MAX_SCALE), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_alloc_block_size(\n       \"range_alloc_block_size\",\n       \"Allocation block size for storing ranges during optimization\",\n       SESSION_VAR(range_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(RANGE_ALLOC_BLOCK_SIZE, UINT_MAX),\n       DEFAULT(RANGE_ALLOC_BLOCK_SIZE), BLOCK_SIZE(1024));\n\nstatic Sys_var_ulong Sys_multi_range_count(\n       \"multi_range_count\", \"Ignored. Use mrr_buffer_size instead\",\n       SESSION_VAR(multi_range_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(256), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"'@@mrr_buffer_size'\"));\n\nstatic bool fix_thd_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(thd->mem_root,\n                        thd->variables.query_alloc_block_size,\n                        thd->variables.query_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_alloc_block_size(\n       \"query_alloc_block_size\",\n       \"Allocation block size for query parsing and execution\",\n       SESSION_VAR(query_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, UINT_MAX), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\nstatic Sys_var_ulong Sys_query_prealloc_size(\n       \"query_prealloc_size\",\n       \"Persistent buffer for query parsing and execution\",\n       SESSION_VAR(query_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, UINT_MAX),\n       DEFAULT(QUERY_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\n#ifdef HAVE_SMEM\nstatic Sys_var_mybool Sys_shared_memory(\n       \"shared_memory\", \"Enable the shared memory\",\n       READ_ONLY GLOBAL_VAR(opt_enable_shared_memory), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_shared_memory_base_name(\n       \"shared_memory_base_name\", \"Base name of shared memory\",\n       READ_ONLY GLOBAL_VAR(shared_memory_base_name), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n#endif\n\n// this has to be NO_CMD_LINE as the command-line option has a different name\nstatic Sys_var_mybool Sys_skip_external_locking(\n       \"skip_external_locking\", \"Don't use system (external) locking\",\n       READ_ONLY GLOBAL_VAR(my_disable_locking), NO_CMD_LINE, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_skip_networking(\n       \"skip_networking\", \"Don't allow connection with TCP/IP\",\n       READ_ONLY GLOBAL_VAR(opt_disable_networking), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_name_resolve(\n       \"skip_name_resolve\",\n       \"Don't resolve hostnames. All hostnames are IP's or 'localhost'.\",\n       READ_ONLY GLOBAL_VAR(opt_skip_name_resolve),\n       CMD_LINE(OPT_ARG, OPT_SKIP_RESOLVE),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_show_database(\n       \"skip_show_database\", \"Don't allow 'SHOW DATABASE' commands\",\n       READ_ONLY GLOBAL_VAR(opt_skip_show_db), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_socket(\n       \"socket\", \"Socket file to use for connection\",\n       READ_ONLY GLOBAL_VAR(mysqld_unix_port), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/* \n  thread_concurrency is a no-op on all platforms since\n  MySQL 5.1.  It will be removed in the context of\n  WL#5265\n*/\nstatic Sys_var_ulong Sys_thread_concurrency(\n       \"thread_concurrency\",\n       \"Permits the application to give the threads system a hint for \"\n       \"the desired number of threads that should be run at the same time.\"\n       \"This variable has no effect, and is deprecated. \"\n       \"It will be removed in a future release.\",\n       READ_ONLY GLOBAL_VAR(concurrency),\n       CMD_LINE(REQUIRED_ARG, OPT_THREAD_CONCURRENCY),\n       VALID_RANGE(1, 512), DEFAULT(DEFAULT_CONCURRENCY), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulonglong Sys_thread_stack(\n       \"thread_stack\", \"The stack size for each thread\",\n       READ_ONLY GLOBAL_VAR(my_thread_stack_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128*1024, ULONGLONG_MAX), DEFAULT(DEFAULT_THREAD_STACK),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_charptr Sys_tmpdir(\n       \"tmpdir\", \"Path for temporary files. Several paths may \"\n       \"be specified, separated by a \"\n#if defined(__WIN__)\n       \"semicolon (;)\"\n#else\n       \"colon (:)\"\n#endif\n       \", in this case they are used in a round-robin fashion\",\n       READ_ONLY GLOBAL_VAR(opt_mysql_tmpdir), CMD_LINE(REQUIRED_ARG, 't'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_trans_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(&thd->transaction.mem_root,\n                        thd->variables.trans_alloc_block_size,\n                        thd->variables.trans_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_trans_alloc_block_size(\n       \"transaction_alloc_block_size\",\n       \"Allocation block size for transactions to be stored in binary log\",\n       SESSION_VAR(trans_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024 * 1024), DEFAULT(TRANS_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic Sys_var_ulong Sys_trans_prealloc_size(\n       \"transaction_prealloc_size\",\n       \"Persistent buffer for transactions to be stored in binary log\",\n       SESSION_VAR(trans_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024 * 1024), DEFAULT(TRANS_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic const char *thread_handling_names[]=\n{\n  \"one-thread-per-connection\", \"no-threads\",\n#ifdef HAVE_POOL_OF_THREADS\n  \"pool-of-threads\",\n#endif\n  0\n};\n\n#if defined (_WIN32) && defined (HAVE_POOL_OF_THREADS)\n/* Windows is using OS threadpool, so we're pretty sure it works well */\n#define DEFAULT_THREAD_HANDLING 2\n#else\n#define DEFAULT_THREAD_HANDLING 0\n#endif\n\nstatic Sys_var_enum Sys_thread_handling(\n       \"thread_handling\",\n       \"Define threads usage for handling queries\",\n       READ_ONLY GLOBAL_VAR(thread_handling), CMD_LINE(REQUIRED_ARG),\n       thread_handling_names, \n       DEFAULT(DEFAULT_THREAD_HANDLING)\n );\n\n#ifdef HAVE_QUERY_CACHE\nstatic bool fix_query_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  ulong new_cache_size= query_cache.resize(query_cache_size);\n  /*\n     Note: query_cache_size is a global variable reflecting the\n     requested cache size. See also query_cache_size_arg\n  */\n  if (query_cache_size != new_cache_size)\n    push_warning_printf(current_thd, Sql_condition::WARN_LEVEL_WARN,\n                        ER_WARN_QC_RESIZE, ER_THD(thd, ER_WARN_QC_RESIZE),\n                        query_cache_size, new_cache_size);\n\n  query_cache_size= new_cache_size;\n\n  return false;\n}\n\nstatic bool fix_query_cache_limit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache.result_size_limit(query_cache_limit);\n  return false;\n}\nstatic Sys_var_ulonglong Sys_query_cache_size(\n       \"query_cache_size\",\n       \"The memory allocated to store results from old queries\",\n       GLOBAL_VAR(query_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, NULL,\n       ON_UPDATE(fix_query_cache_size));\n\nstatic Sys_var_ulong Sys_query_cache_limit(\n       \"query_cache_limit\",\n       \"Don't cache results that are bigger than this\",\n       GLOBAL_VAR(query_cache_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_query_cache_limit));\n\nstatic bool fix_qcache_min_res_unit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache_min_res_unit=\n    query_cache.set_min_res_unit(query_cache_min_res_unit);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_min_res_unit(\n       \"query_cache_min_res_unit\",\n       \"The minimum size for blocks allocated by the query cache\",\n       GLOBAL_VAR(query_cache_min_res_unit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(QUERY_CACHE_MIN_RESULT_DATA_SIZE),\n       BLOCK_SIZE(8), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_qcache_min_res_unit));\n\nstatic const char *query_cache_type_names[]= { \"OFF\", \"ON\", \"DEMAND\", 0 };\n\nstatic bool check_query_cache_type(sys_var *self, THD *thd, set_var *var)\n{\n  if (query_cache.is_disable_in_progress())\n  {\n    my_error(ER_QUERY_CACHE_IS_DISABLED, MYF(0));\n    return true;\n  }\n\n  if (var->type != OPT_GLOBAL && global_system_variables.query_cache_type == 0)\n  {\n    if (var->value)\n    {\n      if (var->save_result.ulonglong_value != 0)\n      {\n        my_error(ER_QUERY_CACHE_IS_GLOBALY_DISABLED, MYF(0));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\nstatic bool fix_query_cache_type(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    return false;\n\n  if (global_system_variables.query_cache_type != 0 &&\n      query_cache.is_disabled())\n  {\n    /* if disabling in progress variable will not be set */\n    DBUG_ASSERT(!query_cache.is_disable_in_progress());\n    /* Enable query cache because it was disabled */\n    fix_query_cache_size(0, thd, type);\n  }\n  else if (global_system_variables.query_cache_type == 0)\n    query_cache.disable_query_cache(thd);\n  return false;\n}\nstatic Sys_var_enum Sys_query_cache_type(\n       \"query_cache_type\",\n       \"OFF = Don't cache or retrieve results. ON = Cache all results \"\n       \"except SELECT SQL_NO_CACHE ... queries. DEMAND = Cache only \"\n       \"SELECT SQL_CACHE ... queries\",\n       NO_SET_STMT SESSION_VAR(query_cache_type), CMD_LINE(REQUIRED_ARG),\n       query_cache_type_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_query_cache_type),\n       ON_UPDATE(fix_query_cache_type));\n\nstatic Sys_var_mybool Sys_query_cache_wlock_invalidate(\n       \"query_cache_wlock_invalidate\",\n       \"Invalidate queries in query cache on LOCK for write\",\n       SESSION_VAR(query_cache_wlock_invalidate), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif /* HAVE_QUERY_CACHE */\n\nstatic Sys_var_mybool Sys_secure_auth(\n       \"secure_auth\",\n       \"Disallow authentication for accounts that have old (pre-4.1) \"\n       \"passwords\",\n       GLOBAL_VAR(opt_secure_auth), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic Sys_var_charptr Sys_secure_file_priv(\n       \"secure_file_priv\",\n       \"Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files \"\n       \"within specified directory\",\n       PREALLOCATED READ_ONLY GLOBAL_VAR(opt_secure_file_priv),\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_server_id(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    thd->variables.server_id= global_system_variables.server_id;\n    /*\n      Historically, server_id was a global variable that is exported to\n      plugins. Now it is a session variable, and lives in the\n      global_system_variables struct, but we still need to export the\n      value for reading to plugins for backwards compatibility reasons.\n    */\n    ::server_id= global_system_variables.server_id;\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_server_id(\n       \"server_id\",\n       \"Uniquely identifies the server instance in the community of \"\n       \"replication partners\",\n       SESSION_VAR(server_id), CMD_LINE(REQUIRED_ARG, OPT_SERVER_ID),\n       VALID_RANGE(1, UINT_MAX32), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_has_super), ON_UPDATE(fix_server_id));\n\nstatic Sys_var_mybool Sys_slave_compressed_protocol(\n       \"slave_compressed_protocol\",\n       \"Use compression on master/slave protocol\",\n       GLOBAL_VAR(opt_slave_compressed_protocol), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n#ifdef HAVE_REPLICATION\nstatic const char *slave_exec_mode_names[]= {\"STRICT\", \"IDEMPOTENT\", 0};\nstatic Sys_var_enum Slave_exec_mode(\n       \"slave_exec_mode\",\n       \"How replication events should be executed. Legal values \"\n       \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n       \"replication will not stop for operations that are idempotent. \"\n       \"For example, in row based replication attempts to delete rows that \"\n       \"doesn't exist will be ignored. \"\n       \"In STRICT mode, replication will stop on any unexpected difference \"\n       \"between the master and the slave.\",\n       GLOBAL_VAR(slave_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(SLAVE_EXEC_MODE_STRICT));\n\nstatic Sys_var_enum Slave_ddl_exec_mode(\n       \"slave_ddl_exec_mode\",\n       \"How replication events should be executed. Legal values \"\n       \"are STRICT and IDEMPOTENT (default). In IDEMPOTENT mode, \"\n       \"replication will not stop for DDL operations that are idempotent. \"\n       \"This means that CREATE TABLE is treated as CREATE TABLE OR REPLACE and \"\n       \"DROP TABLE is treated as DROP TABLE IF EXISTS.\",\n       GLOBAL_VAR(slave_ddl_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(SLAVE_EXEC_MODE_IDEMPOTENT));\n\nstatic const char *slave_run_triggers_for_rbr_names[]=\n  {\"NO\", \"YES\", \"LOGGING\", 0};\nstatic Sys_var_enum Slave_run_triggers_for_rbr(\n       \"slave_run_triggers_for_rbr\",\n       \"Modes for how triggers in row-base replication on slave side will be \"\n       \"executed. Legal values are NO (default), YES and LOGGING. NO means \"\n       \"that trigger for RBR will not be running on slave. YES and LOGGING \"\n       \"means that triggers will be running on slave, if there was not \"\n       \"triggers running on the master for the statement. LOGGING also means \"\n       \"results of that the executed triggers work will be written to \"\n       \"the binlog.\",\n       GLOBAL_VAR(slave_run_triggers_for_rbr), CMD_LINE(REQUIRED_ARG),\n       slave_run_triggers_for_rbr_names,\n       DEFAULT(SLAVE_RUN_TRIGGERS_FOR_RBR_NO));\n\nstatic const char *slave_type_conversions_name[]= {\"ALL_LOSSY\", \"ALL_NON_LOSSY\", 0};\nstatic Sys_var_set Slave_type_conversions(\n       \"slave_type_conversions\",\n       \"Set of slave type conversions that are enabled.\"\n       \" If the variable is empty, no conversions are\"\n       \" allowed and it is expected that the types match exactly\",\n       GLOBAL_VAR(slave_type_conversions_options), CMD_LINE(REQUIRED_ARG),\n       slave_type_conversions_name,\n       DEFAULT(0));\n\nstatic Sys_var_mybool Sys_slave_sql_verify_checksum(\n       \"slave_sql_verify_checksum\",\n       \"Force checksum verification of replication events after reading them \"\n       \"from relay log. Note: Events are always checksum-verified by slave on \"\n       \"receiving them from the network before writing them to the relay log\",\n       GLOBAL_VAR(opt_slave_sql_verify_checksum), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_master_verify_checksum(\n       \"master_verify_checksum\",\n       \"Force checksum verification of logged events in the binary log before \"\n       \"sending them to slaves or printing them in the output of \"\n       \"SHOW BINLOG EVENTS\",\n       GLOBAL_VAR(opt_master_verify_checksum), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n/* These names must match RPL_SKIP_XXX #defines in slave.h. */\nstatic const char *replicate_events_marked_for_skip_names[]= {\n  \"REPLICATE\", \"FILTER_ON_SLAVE\", \"FILTER_ON_MASTER\", 0\n};\n\nbool\nSys_var_replicate_events_marked_for_skip::global_update(THD *thd, set_var *var)\n{\n  bool result= true;                            // Assume error\n  DBUG_ENTER(\"Sys_var_replicate_events_marked_for_skip::global_update\");\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (!give_error_if_slave_running(0))\n    result= Sys_var_enum::global_update(thd, var);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  DBUG_RETURN(result);\n}\n\nstatic Sys_var_replicate_events_marked_for_skip Replicate_events_marked_for_skip\n   (\"replicate_events_marked_for_skip\",\n   \"Whether the slave should replicate events that were created with \"\n   \"@@skip_replication=1 on the master. Default REPLICATE (no events are \"\n   \"skipped). Other values are FILTER_ON_SLAVE (events will be sent by the \"\n   \"master but ignored by the slave) and FILTER_ON_MASTER (events marked with \"\n   \"@@skip_replication=1 will be filtered on the master and never be sent to \"\n   \"the slave).\",\n   GLOBAL_VAR(opt_replicate_events_marked_for_skip), CMD_LINE(REQUIRED_ARG),\n   replicate_events_marked_for_skip_names, DEFAULT(RPL_SKIP_REPLICATE));\n#endif\n\n\nstatic Sys_var_ulong Sys_slow_launch_time(\n       \"slow_launch_time\",\n       \"If creating the thread takes longer than this value (in seconds), \"\n       \"the Slow_launch_threads counter will be incremented\",\n       GLOBAL_VAR(slow_launch_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_sort_buffer(\n       \"sort_buffer_size\",\n       \"Each thread that needs to do a sort allocates a buffer of this size\",\n       SESSION_VAR(sortbuff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(MIN_SORT_MEMORY, SIZE_T_MAX), DEFAULT(MAX_SORT_MEMORY),\n       BLOCK_SIZE(1));\n\nexport sql_mode_t expand_sql_mode(sql_mode_t sql_mode)\n{\n  if (sql_mode & MODE_ANSI)\n  {\n    /*\n      Note that we dont set\n      MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS | MODE_NO_FIELD_OPTIONS\n      to allow one to get full use of MySQL in this mode.\n\n      MODE_ONLY_FULL_GROUP_BY was removed from ANSI mode because it is\n      currently overly restrictive (see BUG#8510).\n    */\n    sql_mode|= (MODE_REAL_AS_FLOAT | MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE);\n  }\n  if (sql_mode & MODE_ORACLE)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MSSQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_POSTGRESQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_DB2)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_MAXDB)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MYSQL40)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_MYSQL323)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_TRADITIONAL)\n    sql_mode|= (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES |\n                MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n                MODE_ERROR_FOR_DIVISION_BY_ZERO | MODE_NO_AUTO_CREATE_USER |\n                MODE_NO_ENGINE_SUBSTITUTION);\n  return sql_mode;\n}\nstatic bool check_sql_mode(sys_var *self, THD *thd, set_var *var)\n{\n  var->save_result.ulonglong_value=\n    (ulonglong) expand_sql_mode(var->save_result.ulonglong_value);\n  return false;\n}\nstatic bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    /* Update thd->server_status */\n    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)\n      thd->server_status|= SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    else\n      thd->server_status&= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    if (thd->variables.sql_mode & MODE_ANSI_QUOTES)\n      thd->server_status|= SERVER_STATUS_ANSI_QUOTES;\n    else\n      thd->server_status&= ~SERVER_STATUS_ANSI_QUOTES;\n  }\n  return false;\n}\n/*\n  WARNING: When adding new SQL modes don't forget to update the\n  tables definitions that stores it's value (ie: mysql.event, mysql.proc)\n*/\nstatic const char *sql_mode_names[]=\n{\n  \"REAL_AS_FLOAT\", \"PIPES_AS_CONCAT\", \"ANSI_QUOTES\", \"IGNORE_SPACE\",\n  \"IGNORE_BAD_TABLE_OPTIONS\",\n  \"ONLY_FULL_GROUP_BY\", \"NO_UNSIGNED_SUBTRACTION\", \"NO_DIR_IN_CREATE\",\n  \"POSTGRESQL\", \"ORACLE\", \"MSSQL\", \"DB2\", \"MAXDB\", \"NO_KEY_OPTIONS\",\n  \"NO_TABLE_OPTIONS\", \"NO_FIELD_OPTIONS\", \"MYSQL323\", \"MYSQL40\", \"ANSI\",\n  \"NO_AUTO_VALUE_ON_ZERO\", \"NO_BACKSLASH_ESCAPES\", \"STRICT_TRANS_TABLES\",\n  \"STRICT_ALL_TABLES\", \"NO_ZERO_IN_DATE\", \"NO_ZERO_DATE\",\n  \"ALLOW_INVALID_DATES\", \"ERROR_FOR_DIVISION_BY_ZERO\", \"TRADITIONAL\",\n  \"NO_AUTO_CREATE_USER\", \"HIGH_NOT_PRECEDENCE\", \"NO_ENGINE_SUBSTITUTION\",\n  \"PAD_CHAR_TO_FULL_LENGTH\",\n  0\n};\n\nexport bool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                           LEX_STRING *ls)\n{\n  set_to_string(thd, ls, sql_mode, sql_mode_names);\n  return ls->str == 0;\n}\n/*\n  sql_mode should *not* be IN_BINLOG: even though it is written to the binlog,\n  the slave ignores the MODE_NO_DIR_IN_CREATE variable, so slave's value\n  differs from master's (see log_event.cc: Query_log_event::do_apply_event()).\n*/\nstatic Sys_var_set Sys_sql_mode(\n       \"sql_mode\",\n       \"Sets the sql mode\",\n       SESSION_VAR(sql_mode), CMD_LINE(REQUIRED_ARG),\n       sql_mode_names,\n       DEFAULT(MODE_STRICT_TRANS_TABLES |\n               MODE_ERROR_FOR_DIVISION_BY_ZERO |\n               MODE_NO_ENGINE_SUBSTITUTION |\n               MODE_NO_AUTO_CREATE_USER),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_sql_mode), ON_UPDATE(fix_sql_mode));\n\nstatic const char *old_mode_names[]=\n{\n  \"NO_DUP_KEY_WARNINGS_WITH_IGNORE\",\n  \"NO_PROGRESS_INFO\",\n  \"ZERO_DATE_TIME_CAST\",\n  0\n};\n\n/*\n  sql_mode should *not* be IN_BINLOG as the slave can't remember this\n  anyway on restart.\n*/\nstatic Sys_var_set Sys_old_behavior(\n       \"old_mode\",\n       \"Used to emulate old behavior from earlier MariaDB or MySQL versions\",\n       SESSION_VAR(old_behavior), CMD_LINE(REQUIRED_ARG),\n       old_mode_names, DEFAULT(0));\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n#define SSL_OPT(X) CMD_LINE(REQUIRED_ARG,X)\n#else\n#define SSL_OPT(X) NO_CMD_LINE\n#endif\n\nstatic Sys_var_charptr Sys_ssl_ca(\n       \"ssl_ca\",\n       \"CA file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_ca), SSL_OPT(OPT_SSL_CA),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_capath(\n       \"ssl_capath\",\n       \"CA directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_capath), SSL_OPT(OPT_SSL_CAPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cert(\n       \"ssl_cert\", \"X509 cert in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cert), SSL_OPT(OPT_SSL_CERT),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cipher(\n       \"ssl_cipher\", \"SSL cipher to use (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cipher), SSL_OPT(OPT_SSL_CIPHER),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_key(\n       \"ssl_key\", \"X509 key in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_key), SSL_OPT(OPT_SSL_KEY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crl(\n       \"ssl_crl\",\n       \"CRL file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crl), SSL_OPT(OPT_SSL_CRL),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crlpath(\n       \"ssl_crlpath\",\n       \"CRL directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crlpath), SSL_OPT(OPT_SSL_CRLPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_standard_compliant_cte(\n       \"standard_compliant_cte\",\n       \"Allow only CTEs compliant to SQL standard\",\n       SESSION_VAR(only_standard_compliant_cte), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\n\n// why ENUM and not BOOL ?\nstatic const char *updatable_views_with_limit_names[]= {\"NO\", \"YES\", 0};\nstatic Sys_var_enum Sys_updatable_views_with_limit(\n       \"updatable_views_with_limit\",\n       \"YES = Don't issue an error message (warning only) if a VIEW without \"\n       \"presence of a key of the underlying table is used in queries with a \"\n       \"LIMIT clause for updating. NO = Prohibit update of a VIEW, which \"\n       \"does not contain a key of the underlying table and the query uses \"\n       \"a LIMIT clause (usually get from GUI tools)\",\n       SESSION_VAR(updatable_views_with_limit), CMD_LINE(REQUIRED_ARG),\n       updatable_views_with_limit_names, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_sync_frm(\n       \"sync_frm\", \"Sync .frm files to disk on creation\",\n       GLOBAL_VAR(opt_sync_frm), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic char *system_time_zone_ptr;\nstatic Sys_var_charptr Sys_system_time_zone(\n       \"system_time_zone\", \"The server system time zone\",\n       READ_ONLY GLOBAL_VAR(system_time_zone_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(system_time_zone));\n\nstatic Sys_var_ulong Sys_table_def_size(\n       \"table_definition_cache\",\n       \"The number of cached table definitions\",\n       GLOBAL_VAR(tdc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(TABLE_DEF_CACHE_MIN, 512*1024),\n       DEFAULT(TABLE_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\n\nstatic bool fix_table_open_cache(sys_var *, THD *, enum_var_type)\n{\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  tc_purge();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return false;\n}\n\n\nstatic Sys_var_ulong Sys_table_cache_size(\n       \"table_open_cache\", \"The number of cached open tables\",\n       GLOBAL_VAR(tc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024*1024), DEFAULT(TABLE_OPEN_CACHE_DEFAULT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_table_open_cache));\n\nstatic Sys_var_uint Sys_table_cache_instances(\n       \"table_open_cache_instances\", \"Maximum number of table cache instances\",\n       READ_ONLY GLOBAL_VAR(tc_instances), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 64), DEFAULT(8), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_thread_cache_size(\n       \"thread_cache_size\",\n       \"How many threads we should keep in a cache for reuse. These are freed after 5 minutes of idle time\",\n       GLOBAL_VAR(thread_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 16384), DEFAULT(256), BLOCK_SIZE(1));\n\n#ifdef HAVE_POOL_OF_THREADS\nstatic bool fix_tp_max_threads(sys_var *, THD *, enum_var_type)\n{\n  tp_set_max_threads(threadpool_max_threads);\n  return false;\n}\n\n\n#ifdef _WIN32\nstatic bool fix_tp_min_threads(sys_var *, THD *, enum_var_type)\n{\n  tp_set_min_threads(threadpool_min_threads);\n  return false;\n}\n#endif\n\nstatic bool check_threadpool_size(sys_var *self, THD *thd, set_var *var)\n{\n  ulonglong v= var->save_result.ulonglong_value;\n  if (v > threadpool_max_size)\n  {\n    var->save_result.ulonglong_value= threadpool_max_size;\n    return throw_bounds_warning(thd, self->name.str, true, true, v);\n  }\n  return false;\n}\n\n\nstatic bool fix_threadpool_size(sys_var*, THD*, enum_var_type)\n{\n  tp_set_threadpool_size(threadpool_size);\n  return false;\n}\n\n\nstatic bool fix_threadpool_stall_limit(sys_var*, THD*, enum_var_type)\n{\n  tp_set_threadpool_stall_limit(threadpool_stall_limit);\n  return false;\n}\n\n#ifdef _WIN32\nstatic Sys_var_uint Sys_threadpool_min_threads(\n  \"thread_pool_min_threads\",\n  \"Minimum number of threads in the thread pool.\",\n  GLOBAL_VAR(threadpool_min_threads), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, 256), DEFAULT(1), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n  ON_UPDATE(fix_tp_min_threads)\n  );\n\nstatic const char *threadpool_mode_names[]={ \"windows\", \"generic\", 0 };\nstatic Sys_var_enum Sys_threadpool_mode(\n  \"thread_pool_mode\",\n  \"Chose implementation of the threadpool\",\n  READ_ONLY GLOBAL_VAR(threadpool_mode), CMD_LINE(REQUIRED_ARG),\n  threadpool_mode_names, DEFAULT(TP_MODE_WINDOWS)\n  );\n#endif\n\nstatic const char *threadpool_priority_names[]={ \"high\", \"low\", \"auto\", 0 };\nstatic Sys_var_enum Sys_thread_pool_priority(\n  \"thread_pool_priority\",\n  \"Threadpool priority. High priority connections usually start executing earlier than low priority.\"\n  \"If priority set to 'auto', the the actual priority(low or high) is determined based on whether or not connection is inside transaction.\",\n  SESSION_VAR(threadpool_priority), CMD_LINE(REQUIRED_ARG),\n  threadpool_priority_names, DEFAULT(TP_PRIORITY_AUTO));\n\nstatic Sys_var_uint Sys_threadpool_idle_thread_timeout(\n  \"thread_pool_idle_timeout\",\n  \"Timeout in seconds for an idle thread in the thread pool.\"\n  \"Worker thread will be shut down after timeout\",\n  GLOBAL_VAR(threadpool_idle_timeout), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, UINT_MAX), DEFAULT(60), BLOCK_SIZE(1)\n);\nstatic Sys_var_uint Sys_threadpool_oversubscribe(\n  \"thread_pool_oversubscribe\",\n  \"How many additional active worker threads in a group are allowed.\",\n  GLOBAL_VAR(threadpool_oversubscribe), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, 1000), DEFAULT(3), BLOCK_SIZE(1)\n);\nstatic Sys_var_uint Sys_threadpool_size(\n \"thread_pool_size\",\n \"Number of thread groups in the pool. \"\n \"This parameter is roughly equivalent to maximum number of concurrently \"\n \"executing threads (threads in a waiting state do not count as executing).\",\n  GLOBAL_VAR(threadpool_size), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, MAX_THREAD_GROUPS), DEFAULT(8), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_threadpool_size),\n  ON_UPDATE(fix_threadpool_size)\n);\nstatic Sys_var_uint Sys_threadpool_stall_limit(\n \"thread_pool_stall_limit\",\n \"Maximum query execution time in milliseconds,\"\n \"before an executing non-yielding thread is considered stalled.\"\n \"If a worker thread is stalled, additional worker thread \"\n \"may be created to handle remaining clients.\",\n  GLOBAL_VAR(threadpool_stall_limit), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(10, UINT_MAX), DEFAULT(500), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), \n  ON_UPDATE(fix_threadpool_stall_limit)\n);\n\nstatic Sys_var_uint Sys_threadpool_max_threads(\n  \"thread_pool_max_threads\",\n  \"Maximum allowed number of worker threads in the thread pool\",\n   GLOBAL_VAR(threadpool_max_threads), CMD_LINE(REQUIRED_ARG),\n   VALID_RANGE(1, 65536), DEFAULT(65536), BLOCK_SIZE(1),\n   NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), \n   ON_UPDATE(fix_tp_max_threads)\n);\n\nstatic Sys_var_uint Sys_threadpool_threadpool_prio_kickup_timer(\n \"thread_pool_prio_kickup_timer\",\n \"The number of milliseconds before a dequeued low-priority statement is moved to the high-priority queue\",\n  GLOBAL_VAR(threadpool_prio_kickup_timer), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(0, UINT_MAX), DEFAULT(1000), BLOCK_SIZE(1)\n);\n#endif /* HAVE_POOL_OF_THREADS */\n\n/**\n  Can't change the 'next' tx_isolation if we are already in a\n  transaction.\n*/\n\nstatic bool check_tx_isolation(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && thd->in_active_multi_stmt_transaction())\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode());\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return TRUE;\n  }\n  return FALSE;\n}\n\n// NO_CMD_LINE - different name of the option\nstatic Sys_var_tx_isolation Sys_tx_isolation(\n       \"tx_isolation\", \"Default transaction isolation level\",\n       NO_SET_STMT SESSION_VAR(tx_isolation), NO_CMD_LINE,\n       tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_tx_isolation));\n\n\n/**\n  Can't change the tx_read_only state if we are already in a\n  transaction.\n*/\n\nstatic bool check_tx_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && thd->in_active_multi_stmt_transaction())\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode());\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n\nbool Sys_var_tx_read_only::session_update(THD *thd, set_var *var)\n{\n  if (var->type == OPT_SESSION && Sys_var_mybool::session_update(thd, var))\n    return true;\n  if (var->type == OPT_DEFAULT || !thd->in_active_multi_stmt_transaction())\n  {\n    // @see Sys_var_tx_isolation::session_update() above for the rules.\n    thd->tx_read_only= var->save_result.ulonglong_value;\n\n#ifndef EMBEDDED_LIBRARY\n    if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)\n    {\n      Transaction_state_tracker *tst= (Transaction_state_tracker *)\n             thd->session_tracker.get_tracker(TRANSACTION_INFO_TRACKER);\n\n      if (var->type == OPT_DEFAULT)\n        tst->set_read_flags(thd,\n                            thd->tx_read_only ? TX_READ_ONLY : TX_READ_WRITE);\n      else\n        tst->set_read_flags(thd, TX_READ_INHERIT);\n    }\n#endif //EMBEDDED_LIBRARY\n  }\n  return false;\n}\n\n\nstatic Sys_var_tx_read_only Sys_tx_read_only(\n       \"tx_read_only\", \"Default transaction access mode. If set to OFF, \"\n       \"the default, access is read/write. If set to ON, access is read-only. \"\n       \"The SET TRANSACTION statement can also change the value of this variable. \"\n       \"See SET TRANSACTION and START TRANSACTION.\",\n       SESSION_VAR(tx_read_only), NO_CMD_LINE, DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_tx_read_only));\n\nstatic Sys_var_ulonglong Sys_tmp_table_size(\n       \"tmp_table_size\",\n       \"Alias for tmp_memory_table_size. \"\n       \"If an internal in-memory temporary table exceeds this size, MariaDB \"\n       \"will automatically convert it to an on-disk MyISAM or Aria table.\",\n       SESSION_VAR(tmp_memory_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_tmp_memory_table_size(\n       \"tmp_memory_table_size\",\n       \"If an internal in-memory temporary table exceeds this size, MariaDB \"\n       \"will automatically convert it to an on-disk MyISAM or Aria table. \"\n       \"Same as tmp_table_size.\",\n       SESSION_VAR(tmp_memory_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_tmp_disk_table_size(\n       \"tmp_disk_table_size\",\n       \"Max size for data for an internal temporary on-disk MyISAM or Aria table.\",\n       SESSION_VAR(tmp_disk_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0),\n       DEFAULT((ulonglong)~(intptr)0),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_timed_mutexes(\n       \"timed_mutexes\",\n       \"Specify whether to time mutexes. Deprecated, has no effect.\",\n       GLOBAL_VAR(timed_mutexes), CMD_LINE(OPT_ARG), DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_version(\n       \"version\", \"Server version number. It may also include a suffix \"\n       \"with configuration or build information. -debug indicates \"\n       \"debugging support was enabled on the server, and -log indicates \"\n       \"at least one of the binary log, general log or slow query log are \"\n       \"enabled, for example 10.1.1-MariaDB-mariadb1precise-log.\",\n       READ_ONLY GLOBAL_VAR(server_version_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(server_version));\n\nstatic char *server_version_comment_ptr;\nstatic Sys_var_charptr Sys_version_comment(\n       \"version_comment\", \"Value of the COMPILATION_COMMENT option \"\n       \"specified by CMake when building MariaDB, for example \"\n       \"mariadb.org binary distribution.\",\n       READ_ONLY GLOBAL_VAR(server_version_comment_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(MYSQL_COMPILATION_COMMENT));\n\nstatic char *server_version_compile_machine_ptr;\nstatic Sys_var_charptr Sys_version_compile_machine(\n       \"version_compile_machine\", \"The machine type or architecture \"\n       \"MariaDB was built on, for example i686.\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_machine_ptr),\n       CMD_LINE_HELP_ONLY, IN_SYSTEM_CHARSET, DEFAULT(DEFAULT_MACHINE));\n\nstatic char *server_version_compile_os_ptr;\nstatic Sys_var_charptr Sys_version_compile_os(\n       \"version_compile_os\", \"Operating system that MariaDB was built \"\n       \"on, for example debian-linux-gnu.\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_os_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(SYSTEM_TYPE));\n\nstatic char *guess_malloc_library()\n{\n  if (strcmp(MALLOC_LIBRARY, \"system\") == 0)\n  {\n#ifdef HAVE_DLOPEN\n    typedef int (*mallctl_type)(const char*, void*, size_t*, void*, size_t);\n    mallctl_type mallctl_func;\n    mallctl_func= (mallctl_type)dlsym(RTLD_DEFAULT, \"mallctl\");\n    if (mallctl_func)\n    {\n      static char buf[128];\n      char *ver;\n      size_t len = sizeof(ver);\n      mallctl_func(\"version\", &ver, &len, NULL, 0);\n      strxnmov(buf, sizeof(buf)-1, \"jemalloc \", ver, NULL);\n      return buf;\n    }\n#endif\n  }\n  return const_cast<char*>(MALLOC_LIBRARY);\n}\nstatic char *malloc_library;\nstatic Sys_var_charptr Sys_malloc_library(\n       \"version_malloc_library\", \"Version of the used malloc library\",\n       READ_ONLY GLOBAL_VAR(malloc_library), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(guess_malloc_library()));\n\n#ifdef HAVE_YASSL\n#include <openssl/ssl.h>\n#define SSL_LIBRARY \"YaSSL \" YASSL_VERSION\n#elif HAVE_OPENSSL\n#include <openssl/crypto.h>\n#define SSL_LIBRARY SSLeay_version(SSLEAY_VERSION)\n#else\n#error No SSL?\n#endif\n\nstatic char *ssl_library;\nstatic Sys_var_charptr Sys_ssl_library(\n       \"version_ssl_library\", \"Version of the used SSL library\",\n       READ_ONLY GLOBAL_VAR(ssl_library), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(SSL_LIBRARY));\n\nstatic Sys_var_ulong Sys_net_wait_timeout(\n       \"wait_timeout\",\n       \"The number of seconds the server waits for activity on a \"\n       \"connection before closing it\",\n       NO_SET_STMT SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_plugin Sys_default_storage_engine(\n       \"default_storage_engine\", \"The default storage engine for new tables\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\n//  Alias for @@default_storage_engine\nstatic Sys_var_plugin Sys_storage_engine(\n       \"storage_engine\", \"Alias for @@default_storage_engine. Deprecated\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\nstatic Sys_var_plugin Sys_default_tmp_storage_engine(\n       \"default_tmp_storage_engine\", \"The default storage engine for user-created temporary tables\",\n       SESSION_VAR(tmp_table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_tmp_storage_engine));\n\nstatic Sys_var_plugin Sys_enforce_storage_engine(\n       \"enforce_storage_engine\", \"Force the use of a storage engine for new tables\",\n       SESSION_VAR(enforced_table_plugin),\n       NO_CMD_LINE, MYSQL_STORAGE_ENGINE_PLUGIN,\n       DEFAULT(&enforced_storage_engine), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n#if defined(ENABLED_DEBUG_SYNC)\n/*\n  Variable can be set for the session only.\n\n  This could be changed later. Then we need to have a global array of\n  actions in addition to the thread local ones. SET GLOBAL would\n  manage the global array, SET [SESSION] the local array. A sync point\n  would need to look for a local and a global action. Setting and\n  executing of global actions need to be protected by a mutex.\n\n  The purpose of global actions could be to allow synchronizing with\n  connectionless threads that cannot execute SET statements.\n*/\nstatic Sys_var_debug_sync Sys_debug_sync(\n       \"debug_sync\", \"Debug Sync Facility\",\n       NO_SET_STMT sys_var::ONLY_SESSION, NO_CMD_LINE,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n/**\n \"time_format\" \"date_format\" \"datetime_format\"\n\n  the following three variables are unused, and the source of confusion\n  (bug reports like \"I've changed date_format, but date format hasn't changed.\n  I've made them read-only, to alleviate the situation somewhat.\n\n  @todo make them NO_CMD_LINE ?\n*/\nstatic Sys_var_charptr Sys_date_format(\n       \"date_format\", \"The DATE format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_date_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].date_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_datetime_format(\n       \"datetime_format\", \"The DATETIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_datetime_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].datetime_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_time_format(\n       \"time_format\", \"The TIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_time_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].time_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic bool fix_autocommit(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    if (global_system_variables.option_bits & OPTION_AUTOCOMMIT)\n      global_system_variables.option_bits&= ~OPTION_NOT_AUTOCOMMIT;\n    else\n      global_system_variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  if (test_all_bits(thd->variables.option_bits,\n                    (OPTION_AUTOCOMMIT | OPTION_NOT_AUTOCOMMIT)))\n  {\n    // activating autocommit\n    if (trans_commit_stmt(thd) || trans_commit(thd))\n    {\n      thd->variables.option_bits&= ~OPTION_AUTOCOMMIT;\n      thd->mdl_context.release_transactional_locks();\n      WSREP_DEBUG(\"autocommit, MDL TRX lock released: %lld\",\n                  (longlong) thd->thread_id);\n      return true;\n    }\n    /*\n      Don't close thread tables or release metadata locks: if we do so, we\n      risk releasing locks/closing tables of expressions used to assign\n      other variables, as in:\n      set @var=my_stored_function1(), @@autocommit=1, @var2=(select MY_MAX(a)\n      from my_table), ...\n      The locks will be released at statement end anyway, as SET\n      statement that assigns autocommit is marked to commit\n      transaction implicitly at the end (@sa stmt_causes_implicitcommit()).\n    */\n    thd->variables.option_bits&=\n                 ~(OPTION_BEGIN | OPTION_KEEP_LOG | OPTION_NOT_AUTOCOMMIT |\n                   OPTION_GTID_BEGIN);\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->transaction.all.m_unsafe_rollback_flags&= ~THD_TRANS::DID_WAIT;\n    thd->server_status|= SERVER_STATUS_AUTOCOMMIT;\n    return false;\n  }\n\n  if ((thd->variables.option_bits &\n       (OPTION_AUTOCOMMIT |OPTION_NOT_AUTOCOMMIT)) == 0)\n  {\n    // disabling autocommit\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->transaction.all.m_unsafe_rollback_flags&= ~THD_TRANS::DID_WAIT;\n    thd->server_status&= ~SERVER_STATUS_AUTOCOMMIT;\n    thd->variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  return false; // autocommit value wasn't changed\n}\n\nstatic Sys_var_bit Sys_autocommit(\n       \"autocommit\", \"If set to 1, the default, all queries are committed \"\n       \"immediately. If set to 0, they are only committed upon a COMMIT statement\"\n       \", or rolled back with a ROLLBACK statement. If autocommit is set to 0, \"\n       \"and then changed to 1, all open transactions are immediately committed.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE,\n       OPTION_AUTOCOMMIT, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_autocommit));\nexport sys_var *Sys_autocommit_ptr= &Sys_autocommit; // for sql_yacc.yy\n\nstatic Sys_var_mybool Sys_big_tables(\n       \"big_tables\", \"Old variable, which if set to 1, allows large result sets \"\n       \"by saving all temporary sets to disk, avoiding 'table full' errors. No \"\n       \"longer needed, as the server now handles this automatically. \"\n       \"sql_big_tables is a synonym.\",\n       SESSION_VAR(big_tables), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_big_selects(\n       \"sql_big_selects\", \"If set to 0, MariaDB will not perform large SELECTs.\"\n       \" See max_join_size for details. If max_join_size is set to anything but \"\n       \"DEFAULT, sql_big_selects is automatically set to 0. If sql_big_selects \"\n       \"is again set, max_join_size will be ignored.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BIG_SELECTS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_log_off(\n       \"sql_log_off\", \"If set to 1 (0 is the default), no logging to the general \"\n       \"query log is done for the client. Only clients with the SUPER privilege \"\n       \"can update this variable.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_LOG_OFF,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n/**\n  This function sets the session variable thd->variables.sql_log_bin \n  to reflect changes to @@session.sql_log_bin.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] type   The type either session or global.\n\n  @return @c FALSE.\n*/\nstatic bool fix_sql_log_bin_after_update(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ASSERT(type == OPT_SESSION);\n\n  if (thd->variables.sql_log_bin)\n    thd->variables.option_bits |= OPTION_BIN_LOG;\n  else\n    thd->variables.option_bits &= ~OPTION_BIN_LOG;\n\n  return FALSE;\n}\n\n/**\n  This function checks if the sql_log_bin can be changed,\n  what is possible if:\n    - the user is a super user;\n    - the set is not called from within a function/trigger;\n    - there is no on-going transaction.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] var    A pointer to the set_var created by the parser.\n\n  @return @c FALSE if the change is allowed, otherwise @c TRUE.\n*/\nstatic bool check_sql_log_bin(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return TRUE;\n\n  if (var->type == OPT_GLOBAL)\n  {\n    my_error(ER_INCORRECT_GLOBAL_LOCAL_VAR, MYF(0), self->name.str, \"SESSION\");\n    return TRUE;\n  }\n\n  if (error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN))\n    return TRUE;\n\n  return FALSE;\n}\n\nstatic Sys_var_mybool Sys_log_binlog(\t\n       \"sql_log_bin\", \"If set to 0 (1 is the default), no logging to the binary \"\n       \"log is done for the client. Only clients with the SUPER privilege can \"\n       \"update this variable. Can have unintended consequences if set globally, \"\n       \"see SET SQL_LOG_BIN. Starting MariaDB 10.1.7, this variable does not \"\n       \"affect the replication of events in a Galera cluster.\",\n       SESSION_VAR(sql_log_bin), NO_CMD_LINE, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_sql_log_bin),\n       ON_UPDATE(fix_sql_log_bin_after_update));\n\nstatic Sys_var_bit Sys_sql_warnings(\n       \"sql_warnings\", \"If set to 1, single-row INSERTs will produce a string \"\n       \"containing warning information if a warning occurs.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_WARNINGS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_sql_notes(\n       \"sql_notes\", \"If set to 1, the default, warning_count is incremented each \"\n       \"time a Note warning is encountered. If set to 0, Note warnings are not \"\n       \"recorded. mysqldump has outputs to set this variable to 0 so that no \"\n       \"unnecessary increments occur when data is reloaded.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SQL_NOTES,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_auto_is_null(\n       \"sql_auto_is_null\", \"If set to 1, the query SELECT * FROM table_name WHERE \"\n       \"auto_increment_column IS NULL will return an auto-increment that has just \"\n       \"been successfully inserted, the same as the LAST_INSERT_ID() function. Some\"\n       \" ODBC programs make use of this IS NULL comparison.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTO_IS_NULL,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_safe_updates(\n       \"sql_safe_updates\", \"If set to 1, UPDATEs and DELETEs need either a key in \"\n       \"the WHERE clause, or a LIMIT clause, or else they will aborted. Prevents \"\n       \"the common mistake of accidentally deleting or updating every row in a table.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SAFE_UPDATES,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_buffer_results(\n       \"sql_buffer_result\", \"If set to 1 (0 is default), results from SELECT \"\n       \"statements are always placed into temporary tables. This can help the \"\n       \"server when it takes a long time to send the results to the client by \"\n       \"allowing the table locks to be freed early.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BUFFER_RESULT,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_quote_show_create(\n       \"sql_quote_show_create\", \"If set to 1, the default, the server will \"\n       \"quote identifiers for SHOW CREATE DATABASE, SHOW CREATE TABLE and \"\n       \"SHOW CREATE VIEW statements. Quoting is disabled if set to 0. Enable \"\n       \"to ensure replications works when identifiers require quoting.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_QUOTE_SHOW_CREATE,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_foreign_key_checks(\n       \"foreign_key_checks\", \"If set to 1 (the default) foreign key constraints\"\n       \" (including ON UPDATE and ON DELETE behavior) InnoDB tables are checked,\"\n       \" while if set to 0, they are not checked. 0 is not recommended for normal \"\n       \"use, though it can be useful in situations where you know the data is \"\n       \"consistent, but want to reload data in a different order from that that \"\n       \"specified by parent/child relationships. Setting this variable to 1 does \"\n       \"not retrospectively check for inconsistencies introduced while set to 0.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_FOREIGN_KEY_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_unique_checks(\n       \"unique_checks\", \"If set to 1, the default, secondary indexes in InnoDB \"\n       \"tables are performed. If set to 0, storage engines can (but are not \"\n       \"required to) assume that duplicate keys are not present in input data. \"\n       \"Set to 0 to speed up imports of large tables to InnoDB. The storage \"\n       \"engine will still issue a duplicate key error if it detects one, even \"\n       \"if set to 0.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_RELAXED_UNIQUE_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_no_check_constraint(\n       \"check_constraint_checks\", \"check_constraint_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_CHECK_CONSTRAINT_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef ENABLED_PROFILING\nstatic bool update_profiling(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->profiling.reset();\n  return false;\n}\n\nstatic Sys_var_bit Sys_profiling(\n       \"profiling\", \"If set to 1 (0 is default), statement profiling will be \"\n       \"enabled. See SHOW PROFILES and SHOW PROFILE.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_PROFILING,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_profiling));\n\nstatic Sys_var_ulong Sys_profiling_history_size(\n       \"profiling_history_size\", \"Number of statements about which profiling \"\n       \"information is maintained. If set to 0, no profiles are stored. \"\n       \"See SHOW PROFILES.\",\n       NO_SET_STMT SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1));\n#endif\n\n/*\n  When this is set by a connection, binlogged events will be marked with a\n  corresponding flag. The slave can be configured to not replicate events\n  so marked.\n  In the binlog dump thread on the master, this variable is re-used for a\n  related purpose: The slave sets this flag when connecting to the master to\n  request that the master filter out (ie. not send) any events with the flag\n  set, thus saving network traffic on events that would be ignored by the\n  slave anyway.\n*/\nstatic bool check_skip_replication(sys_var *self, THD *thd, set_var *var)\n{\n  /*\n    We must not change @@skip_replication in the middle of a transaction or\n    statement, as that could result in only part of the transaction / statement\n    being replicated.\n    (This would be particularly serious if we were to replicate eg.\n    Rows_log_event without Table_map_log_event or transactional updates without\n    the COMMIT).\n  */\n  if (error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_SKIP_REPLICATION,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SKIP_REPLICATION))\n    return 1;\n\n  return 0;\n}\n\nstatic Sys_var_bit Sys_skip_replication(\n       \"skip_replication\", \"Changes are logged into the binary log with the \"\n       \"@@skip_replication flag set. Such events will not be replicated by \"\n       \"slaves that run with --replicate-events-marked-for-skip set different \"\n       \"from its default of REPLICATE. See Selectively skipping replication \"\n       \"of binlog events for more information.\",\n       NO_SET_STMT SESSION_ONLY(option_bits),\n       NO_CMD_LINE, OPTION_SKIP_REPLICATION,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_skip_replication));\n\nstatic Sys_var_harows Sys_select_limit(\n       \"sql_select_limit\",\n       \"The maximum number of rows to return from SELECT statements\",\n       SESSION_VAR(select_limit), NO_CMD_LINE,\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1));\n\nstatic Sys_var_timestamp Sys_timestamp(\n       \"timestamp\", \"Set the time for this client\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, TIMESTAMP_MAX_VALUE),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic bool update_last_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->first_successful_insert_id_in_prev_stmt=\n    var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_last_insert_id(THD *thd)\n{\n  return (ulonglong) thd->read_first_successful_insert_id_in_prev_stmt();\n}\nstatic Sys_var_session_special Sys_last_insert_id(\n       \"last_insert_id\", \"The value to be returned from LAST_INSERT_ID()\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n// alias for last_insert_id(), Sybase-style\nstatic Sys_var_session_special Sys_identity(\n       \"identity\", \"Synonym for the last_insert_id variable\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n/*\n  insert_id should *not* be marked as written to the binlog (i.e., it\n  should *not* be IN_BINLOG), because we want any statement that\n  refers to insert_id explicitly to be unsafe.  (By \"explicitly\", we\n  mean using @@session.insert_id, whereas insert_id is used\n  \"implicitly\" when NULL value is inserted into an auto_increment\n  column).\n\n  We want statements referring explicitly to @@session.insert_id to be\n  unsafe, because insert_id is modified internally by the slave sql\n  thread when NULL values are inserted in an AUTO_INCREMENT column.\n  This modification interfers with the value of the\n  @@session.insert_id variable if @@session.insert_id is referred\n  explicitly by an insert statement (as is seen by executing \"SET\n  @@session.insert_id=0; CREATE TABLE t (a INT, b INT KEY\n  AUTO_INCREMENT); INSERT INTO t(a) VALUES (@@session.insert_id);\" in\n  statement-based logging mode: t will be different on master and\n  slave).\n*/\nstatic bool update_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->force_one_auto_inc_interval(var->save_result.ulonglong_value);\n  return false;\n}\n\nstatic ulonglong read_insert_id(THD *thd)\n{\n  return thd->auto_inc_intervals_forced.minimum();\n}\nstatic Sys_var_session_special Sys_insert_id(\n       \"insert_id\", \"The value to be used by the following INSERT \"\n       \"or ALTER TABLE statement when inserting an AUTO_INCREMENT value\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_insert_id), ON_READ(read_insert_id));\n\nstatic bool update_rand_seed1(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed1= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed1(THD *thd)\n{\n  return thd->rand.seed1;\n}\nstatic Sys_var_session_special Sys_rand_seed1(\n       \"rand_seed1\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed1), ON_READ(read_rand_seed1));\n\nstatic bool update_rand_seed2(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed2= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed2(THD *thd)\n{\n  return thd->rand.seed2;\n}\nstatic Sys_var_session_special Sys_rand_seed2(\n       \"rand_seed2\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed2), ON_READ(read_rand_seed2));\n\nstatic ulonglong read_error_count(THD *thd)\n{\n  return thd->get_stmt_da()->error_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_error_count(\n       \"error_count\", \"The number of errors that resulted from the \"\n       \"last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_error_count));\n\nstatic ulonglong read_warning_count(THD *thd)\n{\n  return thd->get_stmt_da()->warn_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_warning_count(\n       \"warning_count\", \"The number of errors, warnings, and notes \"\n       \"that resulted from the last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_warning_count));\n\nstatic Sys_var_ulong Sys_default_week_format(\n       \"default_week_format\",\n       \"The default week format used by WEEK() functions\",\n       SESSION_VAR(default_week_format), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 7), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_group_concat_max_len(\n       \"group_concat_max_len\",\n       \"The maximum length of the result of function GROUP_CONCAT()\",\n       SESSION_VAR(group_concat_max_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, SIZE_T_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1));\n\nstatic char *glob_hostname_ptr;\nstatic Sys_var_charptr Sys_hostname(\n       \"hostname\", \"Server host name\",\n       READ_ONLY GLOBAL_VAR(glob_hostname_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(glob_hostname));\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_charptr Sys_repl_report_host(\n       \"report_host\",\n       \"Hostname or IP of the slave to be reported to the master during \"\n       \"slave registration. Will appear in the output of SHOW SLAVE HOSTS. \"\n       \"Leave unset if you do not want the slave to register itself with the \"\n       \"master. Note that it is not sufficient for the master to simply read \"\n       \"the IP of the slave off the socket once the slave connects. Due to \"\n       \"NAT and other routing issues, that IP may not be valid for connecting \"\n       \"to the slave from the master or other hosts\",\n       READ_ONLY GLOBAL_VAR(report_host), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_user(\n       \"report_user\",\n       \"The account user name of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_user), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_password(\n       \"report_password\",\n       \"The account password of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_password), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_repl_report_port(\n       \"report_port\",\n       \"Port for connecting to slave reported to the master during slave \"\n       \"registration. Set it only if the slave is listening on a non-default \"\n       \"port or if you have a special tunnel from the master or other clients \"\n       \"to the slave. If not sure, leave this option unset\",\n       READ_ONLY GLOBAL_VAR(report_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_mybool Sys_keep_files_on_create(\n       \"keep_files_on_create\",\n       \"Don't overwrite stale .MYD and .MYI even if no directory is specified\",\n       SESSION_VAR(keep_files_on_create), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic char *license;\nstatic Sys_var_charptr Sys_license(\n       \"license\", \"The type of license the server has\",\n       READ_ONLY GLOBAL_VAR(license), NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(STRINGIFY_ARG(LICENSE)));\n\nstatic bool check_log_path(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false; // DEFAULT is ok\n\n  if (!var->save_result.string_value.str)\n    return true;\n\n  LEX_STRING *val= &var->save_result.string_value;\n\n  if (val->length > FN_REFLEN)\n  { // path is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  char path[FN_REFLEN];\n  size_t path_length= unpack_filename(path, val->str);\n\n  if (!path_length)\n    return true;\n\n  if (!is_filename_allowed(var->save_result.string_value.str, \n                           var->save_result.string_value.length, TRUE))\n  {\n     my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \n              self->name.str, var->save_result.string_value.str);\n     return true;\n  }\n\n  static const LEX_CSTRING my_cnf= { STRING_WITH_LEN(\"my.cnf\") };\n  static const LEX_CSTRING my_ini= { STRING_WITH_LEN(\"my.ini\") };\n  if (path_length >= my_cnf.length)\n  {\n    if (strcasecmp(path + path_length - my_cnf.length, my_cnf.str) == 0)\n      return true; // log file name ends with \"my.cnf\"\n    DBUG_ASSERT(my_cnf.length == my_ini.length);\n    if (strcasecmp(path + path_length - my_ini.length, my_ini.str) == 0)\n      return true; // log file name ends with \"my.ini\"\n  }\n\n  MY_STAT f_stat;\n\n  if (my_stat(path, &f_stat, MYF(0)))\n  {\n    if (!MY_S_ISREG(f_stat.st_mode) || !(f_stat.st_mode & MY_S_IWRITE))\n      return true; // not a regular writable file\n    return false;\n  }\n\n  (void) dirname_part(path, val->str, &path_length);\n\n  if (val->length - path_length >= FN_LEN)\n  { // filename is too long\n      my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n      return true;\n  }\n\n  if (!path_length) // no path is good path (remember, relative to datadir)\n    return false;\n\n  if (my_access(path, (F_OK|W_OK)))\n    return true; // directory is not writable\n\n  return false;\n}\nstatic bool fix_log(char** logname, const char* default_logname,\n                    const char*ext, bool enabled, void (*reopen)(char*))\n{\n  if (!*logname) // SET ... = DEFAULT\n  {\n    make_default_log_name(logname, ext, false);\n    if (!*logname)\n      return true;\n  }\n  logger.lock_exclusive();\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (enabled)\n    reopen(*logname);\n  logger.unlock();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return false;\n}\nstatic void reopen_general_log(char* name)\n{\n  logger.get_log_file_handler()->close(0);\n  logger.get_log_file_handler()->open_query_log(name);\n}\nstatic bool fix_general_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_logname,  opt_log_basename, \".log\", opt_log,\n                 reopen_general_log);\n}\nstatic Sys_var_charptr Sys_general_log_path(\n       \"general_log_file\", \"Log connections and queries to given file\",\n       PREALLOCATED GLOBAL_VAR(opt_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_general_log_file));\n\nstatic void reopen_slow_log(char* name)\n{\n  logger.get_slow_log_file_handler()->close(0);\n  logger.get_slow_log_file_handler()->open_slow_log(name);\n}\nstatic bool fix_slow_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_slow_logname, opt_log_basename, \"-slow.log\",\n                 global_system_variables.sql_log_slow, reopen_slow_log);\n}\nstatic Sys_var_charptr Sys_slow_log_path(\n       \"slow_query_log_file\", \"Log slow queries to given log file. \"\n       \"Defaults logging to 'hostname'-slow.log. Must be enabled to activate \"\n       \"other slow log options\",\n       PREALLOCATED GLOBAL_VAR(opt_slow_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_slow_log_file));\n\nstatic Sys_var_have Sys_have_compress(\n       \"have_compress\", \"If the zlib compression library is accessible to the \"\n       \"server, this will be set to YES, otherwise it will be NO. The COMPRESS() \"\n       \"and UNCOMPRESS() functions will only be available if set to YES.\",\n       READ_ONLY GLOBAL_VAR(have_compress), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_crypt(\n       \"have_crypt\", \"If the crypt() system call is available this variable will \"\n       \"be set to YES, otherwise it will be set to NO. If set to NO, the \"\n       \"ENCRYPT() function cannot be used.\",\n       READ_ONLY GLOBAL_VAR(have_crypt), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_dlopen(\n       \"have_dynamic_loading\", \"If the server supports dynamic loading of plugins, \"\n       \"will be set to YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_dlopen), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_geometry(\n       \"have_geometry\", \"If the server supports spatial data types, will be set to \"\n       \"YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_geometry), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_openssl(\n       \"have_openssl\", \"Comparing have_openssl with have_ssl will indicate whether \"\n       \"YaSSL or openssl was used. If YaSSL, have_ssl will be YES, but have_openssl \"\n       \"will be NO.\",\n       READ_ONLY GLOBAL_VAR(have_openssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_profiling(\n       \"have_profiling\", \"If statement profiling is available, will be set to YES, \"\n       \"otherwise will be set to NO. See SHOW PROFILES and SHOW PROFILE.\",\n       READ_ONLY GLOBAL_VAR(have_profiling), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_query_cache(\n       \"have_query_cache\", \"If the server supports the query cache, will be set to \"\n       \"YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_query_cache), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_rtree_keys(\n       \"have_rtree_keys\", \"If RTREE indexes (used for spatial indexes) \"\n       \"are available, will be set to YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_rtree_keys), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_ssl(\n       \"have_ssl\", \"If the server supports secure connections, will be set to YES, \"\n       \"otherwise will be set to NO. If set to DISABLED, the server was compiled with \"\n       \"TLS support, but was not started with TLS support (see the mysqld options). \"\n       \"See also have_openssl.\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_symlink(\n       \"have_symlink\", \"If symbolic link support is enabled, will be set to YES, \"\n       \"otherwise will be set to NO. Required for the INDEX DIRECTORY and DATA \"\n       \"DIRECTORY table options (see CREATE TABLE) and Windows symlink support. \"\n       \"Will be set to DISABLED if the server is started with the \"\n       \"--skip-symbolic-links option.\",\n       READ_ONLY GLOBAL_VAR(have_symlink), NO_CMD_LINE);\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type);\n\nstatic Sys_var_mybool Sys_general_log(\n       \"general_log\", \"Log connections and queries to a table or log file. \"\n       \"Defaults logging to a file 'hostname'.log or a table mysql.general_log\"\n       \"if --log-output=TABLE is used.\",\n       GLOBAL_VAR(opt_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state));\n\nstatic Sys_var_mybool Sys_slow_query_log(\n       \"slow_query_log\",\n       \"Log slow queries to a table or log file. Defaults logging to a file \"\n       \"'hostname'-slow.log or a table mysql.slow_log if --log-output=TABLE is \"\n       \"used. Must be enabled to activate other slow log options.\",\n       SESSION_VAR(sql_log_slow), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(fix_log_state));\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool res;\n  my_bool *UNINIT_VAR(newvalptr), newval, UNINIT_VAR(oldval);\n  uint UNINIT_VAR(log_type);\n\n  if (type != OPT_GLOBAL)\n    return 0;\n\n  if (self == &Sys_general_log)\n  {\n    newvalptr= &opt_log;\n    oldval=    logger.get_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_GENERAL;\n  }\n  else if (self == &Sys_slow_query_log)\n  {\n    newvalptr= &global_system_variables.sql_log_slow;\n    oldval=    logger.get_slow_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_SLOW;\n  }\n  else\n    DBUG_ASSERT(FALSE);\n\n  newval= *newvalptr;\n  if (oldval == newval)\n    return false;\n\n  *newvalptr= oldval; // [de]activate_log_handler works that way (sigh)\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (!newval)\n  {\n    logger.deactivate_log_handler(thd, log_type);\n    res= false;\n  }\n  else\n    res= logger.activate_log_handler(thd, log_type);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n\nstatic bool check_not_empty_set(sys_var *self, THD *thd, set_var *var)\n{\n  return var->save_result.ulonglong_value == 0;\n}\nstatic bool fix_log_output(sys_var *self, THD *thd, enum_var_type type)\n{\n  logger.lock_exclusive();\n  logger.init_slow_log(log_output_options);\n  logger.init_general_log(log_output_options);\n  logger.unlock();\n  return false;\n}\n\nstatic const char *log_output_names[] = { \"NONE\", \"FILE\", \"TABLE\", NULL};\n\nstatic Sys_var_set Sys_log_output(\n       \"log_output\", \"How logs should be written\",\n       GLOBAL_VAR(log_output_options), CMD_LINE(REQUIRED_ARG),\n       log_output_names, DEFAULT(LOG_FILE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_not_empty_set), ON_UPDATE(fix_log_output));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_log_slave_updates(\n       \"log_slave_updates\", \"Tells the slave to log the updates from \"\n       \"the slave thread to the binary log. You will need to turn it on if \"\n       \"you plan to daisy-chain the slaves.\",\n       READ_ONLY GLOBAL_VAR(opt_log_slave_updates), CMD_LINE(OPT_ARG),\n       DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log(\n       \"relay_log\", \"The location and name to use for relay logs.\",\n       READ_ONLY GLOBAL_VAR(opt_relay_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --relay-log-index option set\n  opt_relaylog_index_name variable and computes a value for the\n  relay_log_index variable.\n*/\nstatic Sys_var_charptr Sys_relay_log_index(\n       \"relay_log_index\", \"The location and name to use for the file \"\n       \"that keeps a list of the last relay logs.\",\n       READ_ONLY GLOBAL_VAR(relay_log_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --log-bin-index option set\n  opt_binlog_index_name variable and computes a value for the\n  log_bin_index variable.\n*/\nstatic Sys_var_charptr Sys_binlog_index(\n       \"log_bin_index\", \"File that holds the names for last binary log files.\",\n       READ_ONLY GLOBAL_VAR(log_bin_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_basename(\n       \"relay_log_basename\",\n       \"The full path of the relay log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(relay_log_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_log_bin_basename(\n       \"log_bin_basename\",\n       \"The full path of the binary log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(log_bin_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_info_file(\n       \"relay_log_info_file\", \"The location and name of the file that \"\n       \"remembers where the SQL replication thread is in the relay logs.\",\n       READ_ONLY GLOBAL_VAR(relay_log_info_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_relay_log_purge(\n       \"relay_log_purge\", \"if disabled - do not purge relay logs. \"\n       \"if enabled - purge them as soon as they are no more needed.\",\n       GLOBAL_VAR(relay_log_purge), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_relay_log_recovery(\n       \"relay_log_recovery\", \"Enables automatic relay log recovery \"\n       \"right after the database startup, which means that the IO Thread \"\n       \"starts re-fetching from the master right after the last transaction \"\n       \"processed.\",\n       GLOBAL_VAR(relay_log_recovery), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n\nbool Sys_var_rpl_filter::global_update(THD *thd, set_var *var)\n{\n  bool result= true;                            // Assume error\n  LEX_STRING *base_name= &var->base;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (Master_info *mi= get_master_info(base_name, !var->base.length ?\n                                       Sql_condition::WARN_LEVEL_ERROR :\n                                       Sql_condition::WARN_LEVEL_WARN))\n  {\n    if (mi->rli.slave_running)\n    {\n      my_error(ER_SLAVE_MUST_STOP, MYF(0), \n               mi->connection_name.length,\n               mi->connection_name.str);\n      result= true;\n    }\n    else\n    {\n      result= set_filter_value(var->save_result.string_value.str, mi);\n    }\n    mi->release();\n  }\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return result;\n}\n\nbool Sys_var_rpl_filter::set_filter_value(const char *value, Master_info *mi)\n{\n  bool status= true;\n  Rpl_filter* rpl_filter= mi->rpl_filter;\n\n  /* Proctect against other threads */\n  mysql_mutex_lock(&LOCK_active_mi);\n  switch (opt_id) {\n  case OPT_REPLICATE_DO_DB:\n    status= rpl_filter->set_do_db(value);\n    break;\n  case OPT_REPLICATE_DO_TABLE:\n    status= rpl_filter->set_do_table(value);\n    break;\n  case OPT_REPLICATE_IGNORE_DB:\n    status= rpl_filter->set_ignore_db(value);\n    break;\n  case OPT_REPLICATE_IGNORE_TABLE:\n    status= rpl_filter->set_ignore_table(value);\n    break;\n  case OPT_REPLICATE_WILD_DO_TABLE:\n    status= rpl_filter->set_wild_do_table(value);\n    break;\n  case OPT_REPLICATE_WILD_IGNORE_TABLE:\n    status= rpl_filter->set_wild_ignore_table(value);\n    break;\n  }\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return status;\n}\n\nuchar *Sys_var_rpl_filter::global_value_ptr(THD *thd,\n                                            const LEX_STRING *base_name)\n{\n  char buf[256];\n  String tmp(buf, sizeof(buf), &my_charset_bin);\n  uchar *ret;\n  Master_info *mi;\n  Rpl_filter *rpl_filter;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mi= get_master_info(base_name, !base_name->length ?\n                      Sql_condition::WARN_LEVEL_ERROR :\n                      Sql_condition::WARN_LEVEL_WARN);\n\n  if (!mi)\n  {\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    return 0;\n  }\n\n  rpl_filter= mi->rpl_filter;\n  tmp.length(0);\n\n  mysql_mutex_lock(&LOCK_active_mi);\n  switch (opt_id) {\n  case OPT_REPLICATE_DO_DB:\n    rpl_filter->get_do_db(&tmp);\n    break;\n  case OPT_REPLICATE_DO_TABLE:\n    rpl_filter->get_do_table(&tmp);\n    break;\n  case OPT_REPLICATE_IGNORE_DB:\n    rpl_filter->get_ignore_db(&tmp);\n    break;\n  case OPT_REPLICATE_IGNORE_TABLE:\n    rpl_filter->get_ignore_table(&tmp);\n    break;\n  case OPT_REPLICATE_WILD_DO_TABLE:\n    rpl_filter->get_wild_do_table(&tmp);\n    break;\n  case OPT_REPLICATE_WILD_IGNORE_TABLE:\n    rpl_filter->get_wild_ignore_table(&tmp);\n    break;\n  }\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mi->release();\n\n  ret= (uchar *) thd->strmake(tmp.ptr(), tmp.length());\n\n  return ret;\n}\n\nstatic Sys_var_rpl_filter Sys_replicate_do_db(\n       \"replicate_do_db\", OPT_REPLICATE_DO_DB,\n       \"Tell the slave to restrict replication to updates of tables \"\n       \"whose names appear in the comma-separated list. For \"\n       \"statement-based replication, only the default database (that \"\n       \"is, the one selected by USE) is considered, not any explicitly \"\n       \"mentioned tables in the query. For row-based replication, the \"\n       \"actual names of table(s) being updated are checked.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_do_table(\n       \"replicate_do_table\", OPT_REPLICATE_DO_TABLE,\n       \"Tells the slave to restrict replication to tables in the \"\n       \"comma-separated list.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_ignore_db(\n       \"replicate_ignore_db\", OPT_REPLICATE_IGNORE_DB,\n       \"Tell the slave to restrict replication to updates of tables \"\n       \"whose names do not appear in the comma-separated list. For \"\n       \"statement-based replication, only the default database (that \"\n       \"is, the one selected by USE) is considered, not any explicitly \"\n       \"mentioned tables in the query. For row-based replication, the \"\n       \"actual names of table(s) being updated are checked.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_ignore_table(\n       \"replicate_ignore_table\", OPT_REPLICATE_IGNORE_TABLE,\n       \"Tells the slave thread not to replicate any statement that \"\n       \"updates the specified table, even if any other tables might be \"\n       \"updated by the same statement.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_wild_do_table(\n       \"replicate_wild_do_table\", OPT_REPLICATE_WILD_DO_TABLE,\n       \"Tells the slave thread to restrict replication to statements \"\n       \"where any of the updated tables match the specified database \"\n       \"and table name patterns.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_wild_ignore_table(\n       \"replicate_wild_ignore_table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n       \"Tells the slave thread to not replicate to the tables that \"\n       \"match the given wildcard pattern.\");\n\nstatic Sys_var_charptr Sys_slave_load_tmpdir(\n       \"slave_load_tmpdir\", \"The location where the slave should put \"\n       \"its temporary files when replicating a LOAD DATA INFILE command\",\n       READ_ONLY GLOBAL_VAR(slave_load_tmpdir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_slave_net_timeout(\n       \"slave_net_timeout\", \"Number of seconds to wait for more data \"\n       \"from any master/slave connection before aborting the read\",\n       GLOBAL_VAR(slave_net_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(SLAVE_NET_TIMEOUT), BLOCK_SIZE(1));\n\n\n/*\n  Access a multi_source variable\n  Return 0 + warning if it doesn't exist\n*/\n\nulonglong Sys_var_multi_source_ulonglong::\nget_master_info_ulonglong_value(THD *thd, ptrdiff_t offset)\n{\n  Master_info *mi;\n  ulonglong res= 0;                                  // Default value\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if ((mi= get_master_info(&thd->variables.default_master_connection,\n                           Sql_condition::WARN_LEVEL_WARN)))\n  {\n    res= *((ulonglong*) (((uchar*) mi) + master_info_offset));\n    mi->release();\n  }\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n  \n\nbool update_multi_source_variable(sys_var *self_var, THD *thd,\n                                  enum_var_type type)\n{\n  Sys_var_multi_source_ulonglong *self= (Sys_var_multi_source_ulonglong*) self_var;\n  bool result= true;\n  Master_info *mi;\n\n  if (type == OPT_GLOBAL)\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n  if ((mi= (get_master_info(&thd->variables.default_master_connection,\n                            Sql_condition::WARN_LEVEL_ERROR))))\n  {\n    mysql_mutex_lock(&mi->rli.run_lock);\n    mysql_mutex_lock(&mi->rli.data_lock);\n    result= self->update_variable(thd, mi);\n    mysql_mutex_unlock(&mi->rli.data_lock);\n    mysql_mutex_unlock(&mi->rli.run_lock);\n    mi->release();\n  }\n  if (type == OPT_GLOBAL)\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  return result;\n}\n\nstatic bool update_slave_skip_counter(sys_var *self, THD *thd, Master_info *mi)\n{\n  if (mi->rli.slave_running)\n  {\n    my_error(ER_SLAVE_MUST_STOP, MYF(0), mi->connection_name.length,\n             mi->connection_name.str);\n    return true;\n  }\n  if (mi->using_gtid != Master_info::USE_GTID_NO && mi->using_parallel())\n  {\n    ulong domain_count;\n    mysql_mutex_lock(&rpl_global_gtid_slave_state->LOCK_slave_state);\n    domain_count= rpl_global_gtid_slave_state->count();\n    mysql_mutex_unlock(&rpl_global_gtid_slave_state->LOCK_slave_state);\n    if (domain_count > 1)\n    {\n      /*\n        With domain-based parallel replication, the slave position is\n        multi-dimensional, so the relay log position is not very meaningful.\n        It might not even correspond to the next GTID to execute in _any_\n        domain (the case after error stop). So slave_skip_counter will most\n        likely not do what the user intends. Instead give an error, with a\n        suggestion to instead set @@gtid_slave_pos past the point of error;\n        this works reliably also in the case of multiple domains.\n      */\n      my_error(ER_SLAVE_SKIP_NOT_IN_GTID, MYF(0));\n      return true;\n    }\n  }\n\n  /* The value was stored temporarily in thd */\n  mi->rli.slave_skip_counter= thd->variables.slave_skip_counter;\n  return false;\n}\n\nstatic Sys_var_multi_source_ulonglong Sys_slave_skip_counter(\n       \"sql_slave_skip_counter\", \"Skip the next N events from the master log\",\n       SESSION_VAR(slave_skip_counter), NO_CMD_LINE,\n       MASTER_INFO_VAR(rli.slave_skip_counter),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       ON_UPDATE(update_slave_skip_counter));\n\nstatic bool update_max_relay_log_size(sys_var *self, THD *thd, Master_info *mi)\n{\n  mi->rli.max_relay_log_size= thd->variables.max_relay_log_size;\n  mi->rli.relay_log.set_max_size(mi->rli.max_relay_log_size);\n  return false;\n}\n\nstatic Sys_var_multi_source_ulonglong Sys_max_relay_log_size(\n       \"max_relay_log_size\",\n       \"relay log will be rotated automatically when the size exceeds this \"\n       \"value.  If 0 at startup, it's set to max_binlog_size\",\n       SESSION_VAR(max_relay_log_size), CMD_LINE(REQUIRED_ARG),\n       MASTER_INFO_VAR(rli.max_relay_log_size),\n       VALID_RANGE(0, 1024L*1024*1024), DEFAULT(0), BLOCK_SIZE(IO_SIZE),\n       ON_UPDATE(update_max_relay_log_size));\n\nstatic Sys_var_charptr Sys_slave_skip_errors(\n       \"slave_skip_errors\", \"Tells the slave thread to continue \"\n       \"replication when a query event returns an error from the \"\n       \"provided list\",\n       READ_ONLY GLOBAL_VAR(opt_slave_skip_errors), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_read_binlog_speed_limit(\n       \"read_binlog_speed_limit\", \"Maximum speed(KB/s) to read binlog from\"\n       \" master (0 = no limit)\",\n       GLOBAL_VAR(opt_read_binlog_speed_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_relay_log_space_limit(\n       \"relay_log_space_limit\", \"Maximum space to use for all relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relaylog_period(\n       \"sync_relay_log\", \"Synchronously flush relay log to disk after \"\n       \"every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_relaylog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relayloginfo_period(\n       \"sync_relay_log_info\", \"Synchronously flush relay log info \"\n       \"to disk after every #th transaction. Use 0 to disable \"\n       \"synchronous flushing\",\n       GLOBAL_VAR(sync_relayloginfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_uint Sys_sync_binlog_period(\n       \"sync_binlog\", \"Synchronously flush binary log to disk after \"\n       \"every #th event. Use 0 (default) to disable synchronous flushing\",\n       GLOBAL_VAR(sync_binlog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_masterinfo_period(\n       \"sync_master_info\", \"Synchronously flush master info to disk \"\n       \"after every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_masterinfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_ulong Sys_slave_trans_retries(\n       \"slave_transaction_retries\", \"Number of times the slave SQL \"\n       \"thread will retry a transaction in case it failed with a deadlock \"\n       \"or elapsed lock wait timeout, before giving up and stopping\",\n       GLOBAL_VAR(slave_trans_retries), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10), BLOCK_SIZE(1));\n#endif\n\nstatic bool check_locale(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  MY_LOCALE *locale;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == INT_RESULT)\n  {\n    int lcno= (int)var->value->val_int();\n    if (!(locale= my_locale_by_number(lcno)))\n    {\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), llstr(lcno, buff));\n      return true;\n    }\n    if (check_not_null(self, thd, var))\n      return true;\n  }\n  else // STRING_RESULT\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res=var->value->val_str(&str)))\n      return true;\n    else if (!(locale= my_locale_by_name(res->c_ptr_safe())))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), err.ptr());\n      return true;\n    }\n  }\n\n  var->save_result.ptr= locale;\n\n  if (!locale->errmsgs->errmsgs)\n  {\n    bool res;\n    mysql_mutex_lock(&LOCK_error_messages);\n    res= (!locale->errmsgs->errmsgs &&\n          read_texts(ERRMSG_FILE, locale->errmsgs->language,\n                     &locale->errmsgs->errmsgs));\n    mysql_mutex_unlock(&LOCK_error_messages);\n    if (res)\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN, ER_UNKNOWN_ERROR,\n                          \"Can't process error message file for locale '%s'\",\n                          locale->name);\n      return true;\n    }\n  }\n  status_var_increment(thd->status_var.feature_locale);\n  return false;\n}\n\nstatic bool update_locale(sys_var *self, THD* thd, enum_var_type type)\n{\n  /* Cache pointer to error messages */\n  if (type == OPT_SESSION)\n    thd->variables.errmsgs= thd->variables.lc_messages->errmsgs->errmsgs;\n  else\n    global_system_variables.errmsgs=\n      global_system_variables.lc_messages->errmsgs->errmsgs;\n  return false;\n}\n  \nstatic Sys_var_struct Sys_lc_messages(\n       \"lc_messages\", \"Set the language used for the error messages\",\n       SESSION_VAR(lc_messages), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_messages),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_locale), ON_UPDATE(update_locale));\n\nstatic Sys_var_struct Sys_lc_time_names(\n       \"lc_time_names\", \"Set the language used for the month \"\n       \"names and the days of the week\",\n       SESSION_VAR(lc_time_names), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_time_names),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_tz Sys_time_zone(\n       \"time_zone\", \"The current time zone, used to initialize the time \"\n       \"zone for a client when it connects. Set to SYSTEM by default, in \"\n       \"which the client uses the system time zone value.\",\n       SESSION_VAR(time_zone), NO_CMD_LINE,\n       DEFAULT(&default_tz), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef WITH_WSREP\n#include \"wsrep_var.h\"\n#include \"wsrep_sst.h\"\n#include \"wsrep_binlog.h\"\n\nstatic Sys_var_charptr Sys_wsrep_provider(\n       \"wsrep_provider\", \"Path to replication provider library\",\n       PREALLOCATED GLOBAL_VAR(wsrep_provider), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(WSREP_NONE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_provider_check), ON_UPDATE(wsrep_provider_update));\n\nstatic Sys_var_charptr Sys_wsrep_provider_options(\n       \"wsrep_provider_options\", \"Semicolon (;) separated list of wsrep \"\n       \"options (see wsrep_provider_options documentation).\",\n       PREALLOCATED GLOBAL_VAR(wsrep_provider_options), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_provider_options_check), \n       ON_UPDATE(wsrep_provider_options_update));\n\nstatic Sys_var_charptr Sys_wsrep_data_home_dir(\n       \"wsrep_data_home_dir\", \"home directory for wsrep provider\",\n       READ_ONLY GLOBAL_VAR(wsrep_data_home_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\nstatic Sys_var_charptr Sys_wsrep_cluster_name(\n       \"wsrep_cluster_name\", \"Name for the cluster\",\n       PREALLOCATED GLOBAL_VAR(wsrep_cluster_name), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_CLUSTER_NAME),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_cluster_name_check),\n       ON_UPDATE(wsrep_cluster_name_update));\n\nstatic PolyLock_mutex PLock_wsrep_slave_threads(&LOCK_wsrep_slave_threads);\nstatic Sys_var_charptr Sys_wsrep_cluster_address (\n       \"wsrep_cluster_address\", \"Address to initially connect to cluster\",\n       PREALLOCATED GLOBAL_VAR(wsrep_cluster_address), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"),\n       &PLock_wsrep_slave_threads, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_cluster_address_check), \n       ON_UPDATE(wsrep_cluster_address_update));\n\nstatic Sys_var_charptr Sys_wsrep_node_name (\n       \"wsrep_node_name\", \"Name of this node. This name can be used in \"\n       \"wsrep_sst_donor as a preferred donor. Note that multiple nodes \"\n       \"in a cluster can have the same name.\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_name), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(glob_hostname), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       wsrep_node_name_check, wsrep_node_name_update);\n\nstatic Sys_var_charptr Sys_wsrep_node_address (\n       \"wsrep_node_address\", \"Specifies the node's network address, in \"\n       \"the format ip address[:port]. Used in situations where autoguessing \"\n       \"is not reliable. As of MariaDB 10.1.8, supports IPv6.\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_address), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_node_address_check),\n       ON_UPDATE(wsrep_node_address_update));\n\nstatic Sys_var_charptr Sys_wsrep_node_incoming_address(\n       \"wsrep_node_incoming_address\", \"Client connection address\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_incoming_address),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_NODE_INCOMING_AUTO));\n\nstatic Sys_var_ulong Sys_wsrep_slave_threads(\n       \"wsrep_slave_threads\", \"Number of slave appliers to launch\",\n       GLOBAL_VAR(wsrep_slave_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 512), DEFAULT(1), BLOCK_SIZE(1),\n       &PLock_wsrep_slave_threads, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_slave_threads_check), \n       ON_UPDATE(wsrep_slave_threads_update));\n\nstatic Sys_var_charptr Sys_wsrep_dbug_option(\n       \"wsrep_dbug_option\", \"DBUG options to provider library\",\n       GLOBAL_VAR(wsrep_dbug_option),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic Sys_var_mybool Sys_wsrep_debug(\n       \"wsrep_debug\", \"To enable debug level logging\",\n       GLOBAL_VAR(wsrep_debug), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_convert_LOCK_to_trx(\n       \"wsrep_convert_LOCK_to_trx\", \"To convert locking sessions \"\n       \"into transactions\",\n       GLOBAL_VAR(wsrep_convert_LOCK_to_trx), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_wsrep_retry_autocommit(\n      \"wsrep_retry_autocommit\", \"Max number of times to retry \"\n      \"a failed autocommit statement\",\n       SESSION_VAR(wsrep_retry_autocommit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 10000), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_wsrep_auto_increment_control(\n       \"wsrep_auto_increment_control\", \"To automatically control the \"\n       \"assignment of autoincrement variables\",\n       GLOBAL_VAR(wsrep_auto_increment_control), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_wsrep_drupal_282555_workaround(\n       \"wsrep_drupal_282555_workaround\", \"Enable a workaround to handle the \"\n       \"cases where inserting a DEFAULT value into an auto-increment column \"\n       \"could fail with duplicate key error\",\n       GLOBAL_VAR(wsrep_drupal_282555_workaround),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr sys_wsrep_sst_method(\n       \"wsrep_sst_method\", \"State snapshot transfer method\",\n       GLOBAL_VAR(wsrep_sst_method),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_SST_DEFAULT), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_method_check),\n       ON_UPDATE(wsrep_sst_method_update)); \n\nstatic Sys_var_charptr Sys_wsrep_sst_receive_address( \n       \"wsrep_sst_receive_address\", \"Address where node is waiting for \"\n       \"SST contact\", \n       GLOBAL_VAR(wsrep_sst_receive_address),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_SST_ADDRESS_AUTO), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_receive_address_check),\n       ON_UPDATE(wsrep_sst_receive_address_update)); \n\nstatic Sys_var_charptr Sys_wsrep_sst_auth(\n       \"wsrep_sst_auth\", \"Authentication for SST connection\",\n       PREALLOCATED GLOBAL_VAR(wsrep_sst_auth), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(NULL), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_auth_check),\n       ON_UPDATE(wsrep_sst_auth_update)); \n\nstatic Sys_var_charptr Sys_wsrep_sst_donor(\n       \"wsrep_sst_donor\", \"preferred donor node for the SST\",\n       GLOBAL_VAR(wsrep_sst_donor),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_donor_check),\n       ON_UPDATE(wsrep_sst_donor_update)); \n\nstatic Sys_var_mybool Sys_wsrep_sst_donor_rejects_queries(\n       \"wsrep_sst_donor_rejects_queries\", \"Reject client queries \"\n       \"when donating state snapshot transfer\", \n       GLOBAL_VAR(wsrep_sst_donor_rejects_queries), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_on (\n       \"wsrep_on\", \"To enable wsrep replication \",\n       SESSION_VAR(wsrep_on), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(wsrep_on_update));\n\nstatic Sys_var_charptr Sys_wsrep_start_position (\n       \"wsrep_start_position\", \"global transaction position to start from \",\n       PREALLOCATED GLOBAL_VAR(wsrep_start_position), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_START_POSITION_ZERO),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_start_position_check), \n       ON_UPDATE(wsrep_start_position_update));\n\nstatic Sys_var_ulong Sys_wsrep_max_ws_size (\n       \"wsrep_max_ws_size\", \"Max write set size (bytes)\",\n       GLOBAL_VAR(wsrep_max_ws_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, WSREP_MAX_WS_SIZE), DEFAULT(WSREP_MAX_WS_SIZE),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_max_ws_size_check), ON_UPDATE(wsrep_max_ws_size_update));\n\nstatic Sys_var_ulong Sys_wsrep_max_ws_rows (\n       \"wsrep_max_ws_rows\", \"Max number of rows in write set\",\n       GLOBAL_VAR(wsrep_max_ws_rows), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1048576), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_wsrep_notify_cmd(\n       \"wsrep_notify_cmd\", \"\",\n       GLOBAL_VAR(wsrep_notify_cmd),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic Sys_var_mybool Sys_wsrep_certify_nonPK(\n       \"wsrep_certify_nonPK\", \"Certify tables with no primary key\",\n       GLOBAL_VAR(wsrep_certify_nonPK), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic bool fix_wsrep_causal_reads(sys_var *self, THD* thd, enum_var_type var_type)\n{\n  if (var_type == OPT_GLOBAL)\n    wsrep_causal_reads_update(&global_system_variables);\n  else\n    wsrep_causal_reads_update(&thd->variables);\n  return false;\n}\nstatic Sys_var_mybool Sys_wsrep_causal_reads(\n       \"wsrep_causal_reads\", \"Setting this variable is equivalent \"\n       \"to setting wsrep_sync_wait READ flag\",\n       SESSION_VAR(wsrep_causal_reads),\n       CMD_LINE(OPT_ARG, OPT_WSREP_CAUSAL_READS), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_wsrep_causal_reads),\n       DEPRECATED(\"'@@wsrep_sync_wait=1'\"));\n\nstatic Sys_var_uint Sys_wsrep_sync_wait(\n       \"wsrep_sync_wait\", \"Ensure \\\"synchronous\\\" read view before executing \"\n       \"an operation of the type specified by bitmask: 1 - READ(includes \"\n       \"SELECT, SHOW and BEGIN/START TRANSACTION); 2 - UPDATE and DELETE; 4 - \"\n       \"INSERT and REPLACE\",\n       SESSION_VAR(wsrep_sync_wait), CMD_LINE(OPT_ARG, OPT_WSREP_SYNC_WAIT),\n       VALID_RANGE(WSREP_SYNC_WAIT_NONE, WSREP_SYNC_WAIT_MAX),\n       DEFAULT(WSREP_SYNC_WAIT_NONE), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(wsrep_sync_wait_update));\n\nstatic const char *wsrep_OSU_method_names[]= { \"TOI\", \"RSU\", NullS };\nstatic Sys_var_enum Sys_wsrep_OSU_method(\n       \"wsrep_OSU_method\", \"Method for Online Schema Upgrade\",\n       SESSION_VAR(wsrep_OSU_method), CMD_LINE(OPT_ARG),\n       wsrep_OSU_method_names, DEFAULT(WSREP_OSU_TOI),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(0));\n\nstatic PolyLock_mutex PLock_wsrep_desync(&LOCK_wsrep_desync);\nstatic Sys_var_mybool Sys_wsrep_desync (\n       \"wsrep_desync\", \"To desynchronize the node from the cluster\",\n       GLOBAL_VAR(wsrep_desync), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       &PLock_wsrep_desync, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_desync_check),\n       ON_UPDATE(wsrep_desync_update));\n\nstatic const char *wsrep_binlog_format_names[]=\n       {\"MIXED\", \"STATEMENT\", \"ROW\", \"NONE\", NullS};\nstatic Sys_var_enum Sys_wsrep_forced_binlog_format(\n       \"wsrep_forced_binlog_format\", \"binlog format to take effect over user's choice\",\n       GLOBAL_VAR(wsrep_forced_binlog_format), CMD_LINE(REQUIRED_ARG),\n       wsrep_binlog_format_names, DEFAULT(BINLOG_FORMAT_UNSPEC));\n\nstatic Sys_var_mybool Sys_wsrep_recover_datadir(\n       \"wsrep_recover\", \"Recover database state after crash and exit\",\n       READ_ONLY GLOBAL_VAR(wsrep_recovery),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_replicate_myisam(\n       \"wsrep_replicate_myisam\", \"To enable myisam replication\",\n       GLOBAL_VAR(wsrep_replicate_myisam), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_log_conflicts(\n       \"wsrep_log_conflicts\", \"To log multi-master conflicts\",\n       GLOBAL_VAR(wsrep_log_conflicts), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_wsrep_mysql_replication_bundle(\n      \"wsrep_mysql_replication_bundle\", \"mysql replication group commit \",\n       GLOBAL_VAR(wsrep_mysql_replication_bundle), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_wsrep_load_data_splitting(\n       \"wsrep_load_data_splitting\", \"To commit LOAD DATA \"\n       \"transaction after every 10K rows inserted\",\n       GLOBAL_VAR(wsrep_load_data_splitting), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_wsrep_slave_FK_checks(\n       \"wsrep_slave_FK_checks\", \"Should slave thread do \"\n       \"foreign key constraint checks\",\n       GLOBAL_VAR(wsrep_slave_FK_checks), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_wsrep_slave_UK_checks(\n       \"wsrep_slave_UK_checks\", \"Should slave thread do \"\n       \"secondary index uniqueness checks\",\n       GLOBAL_VAR(wsrep_slave_UK_checks), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_restart_slave(\n       \"wsrep_restart_slave\", \"Should MariaDB slave be restarted automatically, when node joins back to cluster\",\n       GLOBAL_VAR(wsrep_restart_slave), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_dirty_reads(\n       \"wsrep_dirty_reads\",\n       \"Allow reads even when the node is not in the primary component.\",\n       SESSION_VAR(wsrep_dirty_reads), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_uint Sys_wsrep_gtid_domain_id(\n       \"wsrep_gtid_domain_id\", \"When wsrep_gtid_mode is set, this value is \"\n       \"used as gtid_domain_id for galera transactions and also copied to the \"\n       \"joiner nodes during state transfer. It is ignored, otherwise.\",\n       GLOBAL_VAR(wsrep_gtid_domain_id), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG);\n\nstatic Sys_var_mybool Sys_wsrep_gtid_mode(\n       \"wsrep_gtid_mode\", \"Automatically update the (joiner) node's \"\n       \"wsrep_gtid_domain_id value with that of donor's (received during \"\n       \"state transfer) and use it in place of gtid_domain_id for all galera \"\n       \"transactions. When OFF (default), wsrep_gtid_domain_id is simply \"\n       \"ignored (backward compatibility).\",\n       GLOBAL_VAR(wsrep_gtid_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic char *wsrep_patch_version_ptr;\nstatic Sys_var_charptr Sys_wsrep_patch_version(\n       \"wsrep_patch_version\", \"Wsrep patch version, for example wsrep_25.10.\",\n       READ_ONLY GLOBAL_VAR(wsrep_patch_version_ptr), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_PATCH_VERSION));\n\n#endif /* WITH_WSREP */\n\nstatic bool fix_host_cache_size(sys_var *, THD *, enum_var_type)\n{\n  hostname_cache_resize((uint) host_cache_size);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_host_cache_size(\n       \"host_cache_size\",\n       \"How many host names should be cached to avoid resolving.\",\n       AUTO_SET GLOBAL_VAR(host_cache_size),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 65536),\n       DEFAULT(HOST_CACHE_SIZE),\n       BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_host_cache_size));\n\nstatic Sys_var_charptr Sys_ignore_db_dirs(\n       \"ignore_db_dirs\",\n       \"Specifies a directory to add to the ignore list when collecting \"\n       \"database names from the datadir. Put a blank argument to reset \"\n       \"the list accumulated so far.\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_db_dirs), \n       CMD_LINE(REQUIRED_ARG, OPT_IGNORE_DB_DIRECTORY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulong Sys_sp_cache_size(\n       \"stored_program_cache\",\n       \"The soft upper limit for number of cached stored routines for \"\n       \"one connection.\",\n       GLOBAL_VAR(stored_program_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 512 * 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nexport const char *plugin_maturity_names[]=\n{ \"unknown\", \"experimental\", \"alpha\", \"beta\", \"gamma\", \"stable\", 0 };\nstatic Sys_var_enum Sys_plugin_maturity(\n       \"plugin_maturity\",\n       \"The lowest desirable plugin maturity. \"\n       \"Plugins less mature than that will not be installed or loaded\",\n       READ_ONLY GLOBAL_VAR(plugin_maturity), CMD_LINE(REQUIRED_ARG),\n       plugin_maturity_names, DEFAULT(MariaDB_PLUGIN_MATURITY_UNKNOWN));\n\nstatic Sys_var_ulong Sys_deadlock_search_depth_short(\n       \"deadlock_search_depth_short\",\n       \"Short search depth for the two-step deadlock detection\",\n       SESSION_VAR(wt_deadlock_search_depth_short), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 32), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_search_depth_long(\n       \"deadlock_search_depth_long\",\n       \"Long search depth for the two-step deadlock detection\",\n       SESSION_VAR(wt_deadlock_search_depth_long), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 33), DEFAULT(15), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_timeout_depth_short(\n       \"deadlock_timeout_short\",\n       \"Short timeout for the two-step deadlock detection (in microseconds)\",\n       SESSION_VAR(wt_timeout_short), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_timeout_depth_long(\n       \"deadlock_timeout_long\",\n       \"Long timeout for the two-step deadlock detection (in microseconds)\",\n       SESSION_VAR(wt_timeout_long), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(50000000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_extra_port(\n       \"extra_port\",\n       \"Extra port number to use for tcp connections in a \"\n       \"one-thread-per-connection manner. 0 means don't use another port\",\n       READ_ONLY GLOBAL_VAR(mysqld_extra_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_extra_max_connections(\n       \"extra_max_connections\", \"The number of connections on extra-port\",\n       GLOBAL_VAR(extra_max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 100000), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_max_connections));\n\n#ifdef SAFE_MUTEX\nstatic Sys_var_mybool Sys_mutex_deadlock_detector(\n       \"debug_mutex_deadlock_detector\", \"Enable checking of wrong mutex usage\",\n       READ_ONLY GLOBAL_VAR(safe_mutex_deadlock_detector),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n#endif\n\nstatic Sys_var_keycache Sys_key_cache_segments(\n       \"key_cache_segments\", \"The number of segments in a key cache\",\n       KEYCACHE_VAR(param_partitions),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_PARTITIONS),\n       VALID_RANGE(0, MAX_KEY_CACHE_PARTITIONS),\n       DEFAULT(DEFAULT_KEY_CACHE_PARTITIONS),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(repartition_keycache));\n\nstatic const char *log_slow_filter_names[]= \n{ \"admin\", \"filesort\", \"filesort_on_disk\", \"full_join\", \"full_scan\",\n  \"query_cache\", \"query_cache_miss\", \"tmp_table\", \"tmp_table_on_disk\", 0\n};\nstatic Sys_var_set Sys_log_slow_filter(\n       \"log_slow_filter\",\n       \"Log only certain types of queries\",\n       SESSION_VAR(log_slow_filter), CMD_LINE(REQUIRED_ARG),\n       log_slow_filter_names,\n       DEFAULT(my_set_bits(array_elements(log_slow_filter_names)-1)));\n\nstatic const char *default_regex_flags_names[]= \n{\n  \"DOTALL\",    // (?s)  . matches anything including NL\n  \"DUPNAMES\",  // (?J)  Allow duplicate names for subpatterns\n  \"EXTENDED\",  // (?x)  Ignore white space and # comments\n  \"EXTRA\",     // (?X)  extra features (e.g. error on unknown escape character)\n  \"MULTILINE\", // (?m)  ^ and $ match newlines within data\n  \"UNGREEDY\",  // (?U)  Invert greediness of quantifiers\n  0\n};\nstatic const int default_regex_flags_to_pcre[]=\n{\n  PCRE_DOTALL,\n  PCRE_DUPNAMES,\n  PCRE_EXTENDED,\n  PCRE_EXTRA,\n  PCRE_MULTILINE,\n  PCRE_UNGREEDY,\n  0\n};\nint default_regex_flags_pcre(const THD *thd)\n{\n  ulonglong src= thd->variables.default_regex_flags;\n  int i, res;\n  for (i= res= 0; default_regex_flags_to_pcre[i]; i++)\n  {\n    if (src & (1ULL << i))\n      res|= default_regex_flags_to_pcre[i];\n  }\n  return res;\n}\nstatic Sys_var_set Sys_default_regex_flags(\n       \"default_regex_flags\",\n       \"Default flags for the regex library\",\n       SESSION_VAR(default_regex_flags), CMD_LINE(REQUIRED_ARG),\n       default_regex_flags_names,\n       DEFAULT(0));\n\nstatic Sys_var_ulong Sys_log_slow_rate_limit(\n       \"log_slow_rate_limit\",\n       \"Write to slow log every #th slow query. Set to 1 to log everything. \"\n       \"Increase it to reduce the size of the slow or the performance impact \"\n       \"of slow logging\",\n       SESSION_VAR(log_slow_rate_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic const char *log_slow_verbosity_names[]= { \"innodb\", \"query_plan\", \n                                                 \"explain\", 0 };\nstatic Sys_var_set Sys_log_slow_verbosity(\n       \"log_slow_verbosity\",\n       \"Verbosity level for the slow log\",\n       SESSION_VAR(log_slow_verbosity), CMD_LINE(REQUIRED_ARG),\n       log_slow_verbosity_names, DEFAULT(LOG_SLOW_VERBOSITY_INIT));\n\nstatic Sys_var_ulong Sys_join_cache_level(\n       \"join_cache_level\",\n       \"Controls what join operations can be executed with join buffers. Odd \"\n       \"numbers are used for plain join buffers while even numbers are used \"\n       \"for linked buffers\",\n       SESSION_VAR(join_cache_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 8), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_mrr_buffer_size(\n       \"mrr_buffer_size\",\n       \"Size of buffer to use when using MRR with range access\",\n       SESSION_VAR(mrr_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_rowid_merge_buff_size(\n       \"rowid_merge_buff_size\",\n       \"The size of the buffers used [NOT] IN evaluation via partial matching\",\n       SESSION_VAR(rowid_merge_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ((ulonglong)~(intptr)0)/2), DEFAULT(8*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_userstat(\n       \"userstat\",\n       \"Enables statistics gathering for USER_STATISTICS, CLIENT_STATISTICS, \"\n       \"INDEX_STATISTICS and TABLE_STATISTICS tables in the INFORMATION_SCHEMA\",\n       GLOBAL_VAR(opt_userstat_running),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_binlog_annotate_row_events(\n       \"binlog_annotate_row_events\",\n       \"Tells the master to annotate RBR events with the statement that \"\n       \"caused these events\",\n       SESSION_VAR(binlog_annotate_row_events), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_replicate_annotate_row_events(\n       \"replicate_annotate_row_events\",\n       \"Tells the slave to write annotate rows events received from the master \"\n       \"to its own binary log. Ignored if log_slave_updates is not set\",\n       READ_ONLY GLOBAL_VAR(opt_replicate_annotate_row_events),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n#endif\n\nstatic Sys_var_ulonglong Sys_join_buffer_space_limit(\n       \"join_buffer_space_limit\",\n       \"The limit of the space for all join buffers used by a query\",\n       SESSION_VAR(join_buff_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2048, ULONGLONG_MAX), DEFAULT(16*128*1024),\n       BLOCK_SIZE(2048));\n\nstatic Sys_var_ulong Sys_progress_report_time(\n       \"progress_report_time\",\n       \"Seconds between sending progress reports to the client for \"\n       \"time-consuming statements. Set to 0 to disable progress reporting.\",\n       SESSION_VAR(progress_report_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(5), BLOCK_SIZE(1));\n\nconst char *use_stat_tables_modes[] =\n           {\"NEVER\", \"COMPLEMENTARY\", \"PREFERABLY\", 0};\nstatic Sys_var_enum Sys_optimizer_use_stat_tables(\n       \"use_stat_tables\",\n       \"Specifies how to use system statistics tables\",\n       SESSION_VAR(use_stat_tables), CMD_LINE(REQUIRED_ARG),\n       use_stat_tables_modes, DEFAULT(0));\n\nstatic Sys_var_ulong Sys_histogram_size(\n       \"histogram_size\",\n       \"Number of bytes used for a histogram. \"\n       \"If set to 0, no histograms are created by ANALYZE.\",\n       SESSION_VAR(histogram_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 255), DEFAULT(0), BLOCK_SIZE(1));\n\nextern const char *histogram_types[];\nstatic Sys_var_enum Sys_histogram_type(\n       \"histogram_type\",\n       \"Specifies type of the histograms created by ANALYZE. \"\n       \"Possible values are: \"\n       \"SINGLE_PREC_HB - single precision height-balanced, \"\n       \"DOUBLE_PREC_HB - double precision height-balanced.\",\n       SESSION_VAR(histogram_type), CMD_LINE(REQUIRED_ARG),\n       histogram_types, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_no_thread_alarm(\n       \"debug_no_thread_alarm\",\n       \"Disable system thread alarm calls. Disabling it may be useful \"\n       \"in debugging or testing, never do it in production\",\n       READ_ONLY GLOBAL_VAR(my_disable_thr_alarm), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_query_cache_strip_comments(\n       \"query_cache_strip_comments\",\n       \"Strip all comments from a query before storing it \"\n       \"in the query cache\",\n       SESSION_VAR(query_cache_strip_comments), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic ulonglong in_transaction(THD *thd)\n{\n  return MY_TEST(thd->in_active_multi_stmt_transaction());\n}\nstatic Sys_var_session_special Sys_in_transaction(\n       \"in_transaction\", \"Whether there is an active transaction\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, 1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(in_transaction));\n\n#ifndef DBUG_OFF\nstatic Sys_var_ulong Sys_debug_binlog_fsync_sleep(\n       \"debug_binlog_fsync_sleep\",\n       \"Extra sleep (in microseconds) to add to binlog fsync(), for debugging\",\n       GLOBAL_VAR(opt_binlog_dbug_fsync_sleep),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_harows Sys_expensive_subquery_limit(\n       \"expensive_subquery_limit\",\n       \"The maximum number of rows a subquery may examine in order to be \"\n       \"executed during optimization and used for constant optimization\",\n       SESSION_VAR(expensive_subquery_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(100), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_encrypt_tmp_disk_tables(\n       \"encrypt_tmp_disk_tables\",\n       \"Encrypt temporary on-disk tables (created as part of query execution)\",\n       GLOBAL_VAR(encrypt_tmp_disk_tables),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_encrypt_tmp_files(\n       \"encrypt_tmp_files\",\n       \"Encrypt temporary files (created for filesort, binary log cache, etc)\",\n       READ_ONLY GLOBAL_VAR(encrypt_tmp_files),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_binlog_encryption(\n       \"encrypt_binlog\", \"Encrypt binary logs (including relay logs)\",\n       READ_ONLY GLOBAL_VAR(encrypt_binlog), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic const char *binlog_row_image_names[]= {\"MINIMAL\", \"NOBLOB\", \"FULL\", NullS};\nstatic Sys_var_enum Sys_binlog_row_image(\n       \"binlog_row_image\",\n       \"Controls whether rows should be logged in 'FULL', 'NOBLOB' or \"\n       \"'MINIMAL' formats. 'FULL', means that all columns in the before \"\n       \"and after image are logged. 'NOBLOB', means that mysqld avoids logging \"\n       \"blob columns whenever possible (eg, blob column was not changed or \"\n       \"is not part of primary key). 'MINIMAL', means that a PK equivalent (PK \"\n       \"columns or full row if there is no PK in the table) is logged in the \"\n       \"before image, and only changed columns are logged in the after image. \"\n       \"(Default: FULL).\",\n       SESSION_VAR(binlog_row_image), CMD_LINE(REQUIRED_ARG),\n       binlog_row_image_names, DEFAULT(BINLOG_ROW_IMAGE_FULL),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(NULL));\n\nstatic bool check_pseudo_slave_mode(sys_var *self, THD *thd, set_var *var)\n{\n  longlong previous_val= thd->variables.pseudo_slave_mode;\n  longlong val= (longlong) var->save_result.ulonglong_value;\n  bool rli_fake= false;\n\n#ifndef EMBEDDED_LIBRARY\n  rli_fake= thd->rli_fake ? true : false;\n#endif\n\n  if (rli_fake)\n  {\n    if (!val)\n    {\n#ifndef EMBEDDED_LIBRARY\n      delete thd->rli_fake;\n      thd->rli_fake= NULL;\n      delete thd->rgi_fake;\n      thd->rgi_fake= NULL;\n#endif\n    }\n    else if (previous_val && val)\n      goto ineffective;\n    else if (!previous_val && val)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"'pseudo_slave_mode' is already ON.\");\n  }\n  else\n  {\n    if (!previous_val && !val)\n      goto ineffective;\n    else if (previous_val && !val)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"Slave applier execution mode not active, \"\n                   \"statement ineffective.\");\n  }\n  goto end;\n\nineffective:\n  push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n               ER_WRONG_VALUE_FOR_VAR,\n               \"'pseudo_slave_mode' change was ineffective.\");\n\nend:\n  return FALSE;\n}\nstatic Sys_var_mybool Sys_pseudo_slave_mode(\n       \"pseudo_slave_mode\",\n       \"SET pseudo_slave_mode= 0,1 are commands that mysqlbinlog \"\n       \"adds to beginning and end of binary log dumps. While zero \"\n       \"value indeed disables, the actual enabling of the slave \"\n       \"applier execution mode is done implicitly when a \"\n       \"Format_description_event is sent through the session.\",\n       SESSION_ONLY(pseudo_slave_mode), NO_CMD_LINE, DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_pseudo_slave_mode));\n\nstatic Sys_var_mybool Sys_mysql56_temporal_format(\n       \"mysql56_temporal_format\",\n       \"Use MySQL-5.6 (instead of MariaDB-5.3) format for TIME, DATETIME, TIMESTAMP columns.\",\n       GLOBAL_VAR(opt_mysql56_temporal_format),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_mybool Sys_strict_password_validation(\n       \"strict_password_validation\",\n       \"When password validation plugins are enabled, reject passwords \"\n       \"that cannot be validated (passwords specified as a hash)\",\n       GLOBAL_VAR(strict_password_validation),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\n#ifdef HAVE_MMAP\nstatic Sys_var_ulong Sys_log_tc_size(\n       \"log_tc_size\",\n       \"Size of transaction coordinator log.\",\n       READ_ONLY GLOBAL_VAR(opt_tc_log_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(my_getpagesize() * 3, ULONG_MAX),\n       DEFAULT(my_getpagesize() * 6),\n       BLOCK_SIZE(my_getpagesize()));\n#endif\n\nstatic Sys_var_ulonglong Sys_max_thread_mem(\n       \"max_session_mem_used\", \"Amount of memory a single user session \"\n       \"is allowed to allocate. This limits the value of the \"\n       \"session variable MEM_USED\", SESSION_VAR(max_mem_used),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(8192,  ULONGLONG_MAX),\n       DEFAULT(LONGLONG_MAX), BLOCK_SIZE(1));\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic Sys_var_sesvartrack Sys_track_session_sys_vars(\n       \"session_track_system_variables\",\n       \"Track changes in registered system variables. \"\n       \"For compatibility with MySQL defaults this variable should be set to \"\n       \"\\\"autocommit, character_set_client, character_set_connection, \"\n       \"character_set_results, time_zone\\\"\",\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"),\n       NO_MUTEX_GUARD);\n\nstatic bool update_session_track_schema(sys_var *self, THD *thd,\n                                        enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_schema\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)->\n              update(thd, NULL));\n}\n\nstatic Sys_var_mybool Sys_session_track_schema(\n       \"session_track_schema\",\n       \"Track changes to the default schema.\",\n       SESSION_VAR(session_track_schema),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_schema));\n\n\nstatic bool update_session_track_tx_info(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_tx_info\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(TRANSACTION_INFO_TRACKER)->\n              update(thd, NULL));\n}\n\nstatic const char *session_track_transaction_info_names[]=\n  { \"OFF\", \"STATE\", \"CHARACTERISTICS\", NullS };\n\nstatic Sys_var_enum Sys_session_track_transaction_info(\n       \"session_track_transaction_info\",\n       \"Track changes to the transaction attributes. OFF to disable; \"\n       \"STATE to track just transaction state (Is there an active transaction? \"\n       \"Does it have any data? etc.); CHARACTERISTICS to track transaction \"\n       \"state and report all statements needed to start a transaction with\"\n       \"the same characteristics (isolation level, read only/read write,\"\n       \"snapshot - but not any work done / data modified within the \"\n       \"transaction).\",\n       SESSION_VAR(session_track_transaction_info),\n       CMD_LINE(REQUIRED_ARG), session_track_transaction_info_names,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_session_track_tx_info));\n\n\nstatic bool update_session_track_state_change(sys_var *self, THD *thd,\n                                              enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_state_change\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)->\n              update(thd, NULL));\n}\n\nstatic Sys_var_mybool Sys_session_track_state_change(\n       \"session_track_state_change\",\n       \"Track changes to the session state.\",\n       SESSION_VAR(session_track_state_change),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_state_change));\n\n#endif //EMBEDDED_LIBRARY\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2012, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/* This implements 'user defined functions' */\n\n/*\n   Known bugs:\n  \n   Memory for functions is never freed!\n   Shared libraries are not closed before mysqld exits;\n     - This is because we can't be sure if some threads are using\n       a function.\n  \n   The bugs only affect applications that create and free a lot of\n   dynamic functions, so this shouldn't be a real problem.\n*/\n\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#pragma implementation\t\t\t\t// gcc: Class implementation\n#endif\n\n#include <my_global.h>\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"sql_parse.h\"                        // check_identifier_name\n#include \"sql_table.h\"                        // write_bin_log\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n\n#ifdef HAVE_DLOPEN\nextern \"C\"\n{\n#include <stdarg.h>\n#include <hash.h>\n}\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic HASH udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret,\n                         char *dl, Item_udftype typ);\nstatic void del_udf(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm)\n{\n  char *end;\n\n  if (!((tmp->func= (Udf_func_any) dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end=strmov(nm,tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE)\n  {\n    (void)strmov(end, \"_clear\");\n    if (!((tmp->func_clear= (Udf_func_clear) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)strmov(end, \"_add\");\n    if (!((tmp->func_add= (Udf_func_add) dlsym(tmp->dlhandle, nm))))\n      return nm;\n  }\n\n  (void) strmov(end,\"_deinit\");\n  tmp->func_deinit= (Udf_func_deinit) dlsym(tmp->dlhandle, nm);\n\n  (void) strmov(end,\"_init\");\n  tmp->func_init= (Udf_func_init) dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prefent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE)\n  {\n    THD *thd= current_thd;\n    if (!opt_allow_suspicious_udfs)\n      return nm;\n    if (thd->variables.log_warnings)\n      sql_print_warning(ER_THD(thd, ER_CANT_FIND_DL_ENTRY), nm);\n  }\n  return 0;\n}\n\n\nextern \"C\" uchar* get_hash_key(const uchar *buff, size_t *length,\n\t\t\t      my_bool not_used __attribute__((unused)))\n{\n  udf_func *udf=(udf_func*) buff;\n  *length=(uint) udf->name.length;\n  return (uchar*) udf->name.str;\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[]=\n{\n  { &key_rwlock_THR_LOCK_udf, \"THR_LOCK_udf\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_udf_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_udf_rwlocks);\n  PSI_server->register_rwlock(category, all_udf_rwlocks, count);\n}\n#endif\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n*/\n\nvoid udf_init()\n{\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_init\");\n  char db[]= \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized || opt_noacl)\n    DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n\n  init_sql_alloc(&mem, UDF_ALLOC_BLOCK_SIZE, 0, MYF(0));\n  THD *new_thd = new THD(0);\n  if (!new_thd ||\n      my_hash_init(&udf_hash,system_charset_info,32,0,0,get_hash_key, NULL, 0))\n  {\n    sql_print_error(\"Can't allocate memory for udf structures\");\n    my_hash_free(&udf_hash);\n    free_root(&mem,MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  initialized = 1;\n  new_thd->thread_stack= (char*) &new_thd;\n  new_thd->store_globals();\n  new_thd->set_db(db, sizeof(db)-1);\n\n  tables.init_one_table(db, sizeof(db)-1, \"func\", 4, \"func\", TL_READ);\n\n  if (open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT))\n  {\n    DBUG_PRINT(\"error\",(\"Can't open udf table\"));\n    sql_print_error(\"Can't open the mysql.func table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n\n  table= tables.table;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, NULL, 1, 0,\n                       FALSE))\n  {\n    sql_print_error(\"Could not initialize init_read_record; udf's not \"\n                    \"loaded\");\n    goto end;\n  }\n\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\",(\"init udf record\"));\n    LEX_STRING name;\n    name.str=get_field(&mem, table->field[0]);\n    name.length = (uint) strlen(name.str);\n    char *dl_name= get_field(&mem, table->field[2]);\n    bool new_dl=0;\n    Item_udftype udftype=UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)\t\t\t// New func table\n      udftype=(Item_udftype) table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(&name, 0, NAME_CHAR_LEN,\n                                 system_charset_info, 1))\n    {\n      sql_print_error(\"Invalid row in mysql.func table for function '%.64s'\",\n                      name.str);\n      continue;\n    }\n\n    if (!(tmp= add_udf(&name,(Item_result) table->field[1]->val_int(),\n                       dl_name, udftype)))\n    {\n      sql_print_error(\"Can't alloc memory for udf function: '%.64s'\", name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL)\n    {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl, NullS);\n      (void) unpack_filename(dlpath, dlpath);\n      if (!(dl= dlopen(dlpath, RTLD_NOW)))\n      {\n\t/* Print warning to log */\n        sql_print_error(ER_THD(new_thd, ER_CANT_OPEN_LIBRARY),\n                        tmp->dl, errno, my_dlerror(dlpath));\n\t/* Keep the udf in the hash so that we can remove it later */\n\tcontinue;\n      }\n      new_dl=1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[SAFE_NAME_LEN+16], *missing;\n      if ((missing= init_syms(tmp, buf)))\n      {\n        sql_print_error(ER_THD(new_thd, ER_CANT_FIND_DL_ENTRY), missing);\n        del_udf(tmp);\n        if (new_dl)\n          dlclose(dl);\n      }\n    }\n  }\n  if (error > 0)\n    sql_print_error(\"Got unknown error: %d\", my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\nend:\n  close_mysql_tables(new_thd);\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n\nvoid udf_free()\n{\n  /* close all shared libraries */\n  DBUG_ENTER(\"udf_free\");\n  if (opt_noacl)\n    DBUG_VOID_RETURN;\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (udf->dlhandle)\t\t\t\t// Not closed before\n    {\n      /* Mark all versions using the same handler as closed */\n      for (uint j=idx+1 ;  j < udf_hash.records ; j++)\n      {\n\tudf_func *tmp=(udf_func*) my_hash_element(&udf_hash,j);\n\tif (udf->dlhandle == tmp->dlhandle)\n\t  tmp->dlhandle=0;\t\t\t// Already closed\n      }\n      dlclose(udf->dlhandle);\n    }\n  }\n  my_hash_free(&udf_hash);\n  free_root(&mem,MYF(0));\n  if (initialized)\n  {\n    initialized= 0;\n    mysql_rwlock_destroy(&THR_LOCK_udf);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void del_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"del_udf\");\n  if (!--udf->usage_count)\n  {\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n  }\n  else\n  {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    char *name= udf->name.str;\n    uint name_length=udf->name.length;\n    udf->name.str=(char*) \"*\";\n    udf->name.length=1;\n    my_hash_update(&udf_hash,(uchar*) udf,(uchar*) name,name_length);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nvoid free_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"free_udf\");\n  \n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count)\n  {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n    if (!find_udf_dl(udf->dl))\n      dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name,uint length,bool mark_used)\n{\n  udf_func *udf=0;\n  DBUG_ENTER(\"find_udf\");\n\n  if (!initialized)\n    DBUG_RETURN(NULL);\n\n  DEBUG_SYNC(current_thd, \"find_udf_before_lock\");\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf);  /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf);  /* Called during parsing */\n\n  if ((udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) name,\n                                      length ? length : (uint) strlen(name))))\n  {\n    if (!udf->dlhandle)\n      udf=0;\t\t\t\t\t// Could not be opened\n    else if (mark_used)\n      udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\n\nstatic void *find_udf_dl(const char *dl)\n{\n  DBUG_ENTER(\"find_udf_dl\");\n\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (!strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n\t\t\t Item_udftype type)\n{\n  if (!name || !dl || !(uint) type || (uint) type > (uint) UDFTYPE_AGGREGATE)\n    return 0;\n  udf_func *tmp= (udf_func*) alloc_root(&mem, sizeof(udf_func));\n  if (!tmp)\n    return 0;\n  bzero((char*) tmp,sizeof(*tmp));\n  tmp->name = *name; //dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count=1;\n  if (my_hash_insert(&udf_hash,(uchar*)  tmp))\n    return 0;\n  using_udf_functions=1;\n  return tmp;\n}\n\n/*\n  Drop user defined function.\n\n  @param thd    Thread handler.\n  @param udf    Existing udf_func pointer which is to be deleted.\n  @param table  mysql.func table reference (opened and locked)\n\n  Assumption\n\n  - udf is not null.\n  - table is already opened and locked\n*/\nstatic int mysql_drop_function_internal(THD *thd, udf_func *udf, TABLE *table)\n{\n  DBUG_ENTER(\"mysql_drop_function_internal\");\n\n  char *exact_name_str= udf->name.str;\n  uint exact_name_len= udf->name.length;\n\n  del_udf(udf);\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl))\n    dlclose(udf->dlhandle);\n\n  if (!table)\n    DBUG_RETURN(1);\n\n  table->use_all_columns();\n  table->field[0]->store(exact_name_str, exact_name_len, &my_charset_bin);\n  if (!table->file->ha_index_read_idx_map(table->record[0], 0,\n                                          (uchar*) table->field[0]->ptr,\n                                          HA_WHOLE_KEY,\n                                          HA_READ_KEY_EXACT))\n  {\n    int error;\n    if ((error= table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(error, MYF(0));\n  }\n  DBUG_RETURN(0);\n}\n\n\n/**\n  Create a user defined function. \n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nint mysql_create_function(THD *thd,udf_func *udf)\n{\n  int error;\n  void *dl=0;\n  bool new_dl=0;\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *u_d;\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0),\n               udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER_THD(thd, ER_OUT_OF_RESOURCES),\n                 MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl)))\n  {\n    my_message(ER_UDF_NO_PATHS, ER_THD(thd, ER_UDF_NO_PATHS), MYF(0));\n    DBUG_RETURN(1);\n  }\n  if (check_ident_length(&udf->name))\n    DBUG_RETURN(1);\n\n  tables.init_one_table(STRING_WITH_LEN(\"mysql\"), STRING_WITH_LEN(\"func\"),\n                        \"func\", TL_WRITE);\n  table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  DEBUG_SYNC(current_thd, \"mysql_create_function_after_lock\");\n  if ((u_d= (udf_func*) my_hash_search(&udf_hash, (uchar*) udf->name.str,\n                                                  udf->name.length)))\n  {\n    if (thd->lex->create_info.or_replace())\n    {\n      if ((error= mysql_drop_function_internal(thd, u_d, table)))\n        goto err;\n    }\n    else if (thd->lex->create_info.if_not_exists())\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE, ER_UDF_EXISTS,\n                          ER_THD(thd, ER_UDF_EXISTS), udf->name.str);\n\n      goto done;\n    }\n    else\n    {\n      my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n      goto err;\n    }\n  }\n  if (!(dl = find_udf_dl(udf->dl)))\n  {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void) unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW)))\n    {\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0),\n               udf->dl, errno, my_dlerror(dlpath));\n      DBUG_PRINT(\"error\",(\"dlopen of %s failed, error: %d (%s)\",\n                          udf->dl, errno, dlerror()));\n      goto err;\n    }\n    new_dl=1;\n  }\n  udf->dlhandle=dl;\n  {\n    char buf[SAFE_NAME_LEN+16], *missing;\n    if ((missing= init_syms(udf, buf)))\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      goto err;\n    }\n  }\n  udf->name.str= strdup_root(&mem,udf->name.str);\n  udf->dl= strdup_root(&mem,udf->dl);\n  if (!(u_d=add_udf(&udf->name,udf->returns,udf->dl,udf->type)))\n    goto err;\n  u_d->dlhandle= dl;\n  u_d->func= udf->func;\n  u_d->func_init= udf->func_init;\n  u_d->func_deinit= udf->func_deinit;\n  u_d->func_clear= udf->func_clear;\n  u_d->func_add= udf->func_add;\n\n  /* create entry in mysql.func table */\n\n  /* Allow creation of functions even if we can't open func table */\n  if (!table)\n    goto err;\n  table->use_all_columns();\n  restore_record(table, s->default_values);\t// Default values for fields\n  table->field[0]->store(u_d->name.str, u_d->name.length, system_charset_info);\n  table->field[1]->store((longlong) u_d->returns, TRUE);\n  table->field[2]->store(u_d->dl,(uint) strlen(u_d->dl), system_charset_info);\n  if (table->s->fields >= 4)\t\t\t// If not old func format\n    table->field[3]->store((longlong) u_d->type, TRUE);\n  error = table->file->ha_write_row(table->record[0]);\n\n  if (error)\n  {\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error);\n    del_udf(u_d);\n    goto err;\n  }\n\ndone:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /* Binlog the create function. */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n\nerr:\n  if (new_dl)\n    dlclose(dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(1);\n}\n\n\nint mysql_drop_function(THD *thd,const LEX_STRING *udf_name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER_THD(thd, ER_OUT_OF_RESOURCES),\n                 MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  tables.init_one_table(STRING_WITH_LEN(\"mysql\"), STRING_WITH_LEN(\"func\"),\n                        \"func\", TL_WRITE);\n  table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  DEBUG_SYNC(current_thd, \"mysql_drop_function_after_lock\");\n  if (!(udf= (udf_func*) my_hash_search(&udf_hash, (uchar*) udf_name->str,\n                                        (uint) udf_name->length)) )\n  {\n    if (thd->lex->check_exists)\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE,\n                          ER_FUNCTION_NOT_DEFINED,\n                          ER_THD(thd, ER_FUNCTION_NOT_DEFINED),\n                          udf_name->str);\n      goto done;\n    }\n\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    goto err;\n  }\n\n  if (mysql_drop_function_internal(thd, udf, table))\n    goto err;\n\ndone:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n\nerr:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(1);\n}\n\n#endif /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql/sql_plugin.cc": "/*\n   Copyright (c) 2005, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2010, 2017, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */\n\n#include \"sql_plugin.h\"                         // Includes my_global.h\n#include \"sql_priv.h\"                         // SHOW_MY_BOOL\n#include \"unireg.h\"\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars_shared.h\"\n#include \"sql_locale.h\"\n#include \"sql_plugin.h\"\n#include \"sql_parse.h\"          // check_table_access\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"key.h\"                                // key_copy\n#include \"sql_table.h\"\n#include \"sql_show.h\"           // remove_status_vars, add_status_vars\n#include \"strfunc.h\"            // find_set\n#include \"sql_acl.h\"                       // *_ACL\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include <my_getopt.h>\n#include \"sql_audit.h\"\n#include <mysql/plugin_auth.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n#include <mysql/plugin_auth.h>\n#include <mysql/plugin_password_validation.h>\n#include <mysql/plugin_encryption.h>\n#include \"sql_plugin_compat.h\"\n\n#define REPORT_TO_LOG  1\n#define REPORT_TO_USER 2\n\n#ifdef HAVE_LINK_H\n#include <link.h>\n#endif\n\nextern struct st_maria_plugin *mysql_optional_plugins[];\nextern struct st_maria_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[]=\n  { \"OFF\", \"ON\", \"FORCE\", \"FORCE_PLUS_PERMANENT\", NULL };\nstatic TYPELIB global_plugin_typelib=\n  { array_elements(global_plugin_typelib_names)-1,\n    \"\", global_plugin_typelib_names, NULL };\n\nstatic I_List<i_string> opt_plugin_load_list;\nI_List<i_string> *opt_plugin_load_list_ptr= &opt_plugin_load_list;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\nulong plugin_maturity;\n\n/*\n  not really needed now, this map will become essential when we add more\n  maturity levels. We cannot change existing maturity constants,\n  so the next value - even if it will be MariaDB_PLUGIN_MATURITY_VERY_BUGGY -\n  will inevitably be larger than MariaDB_PLUGIN_MATURITY_STABLE.\n  To be able to compare them we use this mapping array\n*/\nuint plugin_maturity_map[]=\n{ 0, 1, 2, 3, 4, 5, 6 };\n\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_STRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  { C_STRING_WITH_LEN(\"UDF\") },\n  { C_STRING_WITH_LEN(\"STORAGE ENGINE\") },\n  { C_STRING_WITH_LEN(\"FTPARSER\") },\n  { C_STRING_WITH_LEN(\"DAEMON\") },\n  { C_STRING_WITH_LEN(\"INFORMATION SCHEMA\") },\n  { C_STRING_WITH_LEN(\"AUDIT\") },\n  { C_STRING_WITH_LEN(\"REPLICATION\") },\n  { C_STRING_WITH_LEN(\"AUTHENTICATION\") },\n  { C_STRING_WITH_LEN(\"PASSWORD VALIDATION\") },\n  { C_STRING_WITH_LEN(\"ENCRYPTION\") }\n};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\nextern int initialize_audit_plugin(st_plugin_int *plugin);\nextern int finalize_audit_plugin(st_plugin_int *plugin);\n\nextern int initialize_encryption_plugin(st_plugin_int *plugin);\nextern int finalize_encryption_plugin(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0, ha_initialize_handlerton, 0, 0,initialize_schema_table,\n  initialize_audit_plugin, 0, 0, 0, initialize_encryption_plugin\n};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0, ha_finalize_handlerton, 0, 0, finalize_schema_table,\n  finalize_audit_plugin, 0, 0, 0, finalize_encryption_plugin\n};\n\n/*\n  Defines in which order plugin types have to be initialized.\n  Essentially, we want to initialize MYSQL_KEY_MANAGEMENT_PLUGIN before\n  MYSQL_STORAGE_ENGINE_PLUGIN, and that before MYSQL_INFORMATION_SCHEMA_PLUGIN\n*/\nstatic int plugin_type_initialization_order[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  MYSQL_DAEMON_PLUGIN,\n  MariaDB_ENCRYPTION_PLUGIN,\n  MYSQL_STORAGE_ENGINE_PLUGIN,\n  MYSQL_INFORMATION_SCHEMA_PLUGIN,\n  MYSQL_FTPARSER_PLUGIN,\n  MYSQL_AUTHENTICATION_PLUGIN,\n  MariaDB_PASSWORD_VALIDATION_PLUGIN,\n  MYSQL_AUDIT_PLUGIN,\n  MYSQL_REPLICATION_PLUGIN,\n  MYSQL_UDF_PLUGIN\n};\n\n#ifdef HAVE_DLOPEN\nstatic const char *plugin_interface_version_sym=\n                   \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym=\n                   \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym= \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version= MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\nstatic const char *maria_plugin_interface_version_sym=\n                   \"_maria_plugin_interface_version_\";\nstatic const char *maria_sizeof_st_plugin_sym=\n                   \"_maria_sizeof_struct_st_plugin_\";\nstatic const char *maria_plugin_declarations_sym=\n                   \"_maria_plugin_declarations_\";\nstatic int min_maria_plugin_interface_version=\n                   MARIA_PLUGIN_INTERFACE_VERSION & ~0xFF;\n#endif\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000,\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MIN_AUTHENTICATION_INTERFACE_VERSION,\n  MariaDB_PASSWORD_VALIDATION_INTERFACE_VERSION,\n  MariaDB_ENCRYPTION_INTERFACE_VERSION\n};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000, /* UDF: not implemented */\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  MariaDB_PASSWORD_VALIDATION_INTERFACE_VERSION,\n  MariaDB_ENCRYPTION_INTERFACE_VERSION\n};\n\nstatic struct\n{\n  const char *plugin_name;\n  enum enum_plugin_load_option override;\n} override_plugin_load_policy[]={\n  /*\n    If the performance schema is compiled in,\n    treat the storage engine plugin as 'mandatory',\n    to suppress any plugin-level options such as '--performance-schema'.\n    This is specific to the performance schema, and is done on purpose:\n    the server-level option '--performance-schema' controls the overall\n    performance schema initialization, which consists of much more that\n    the underlying storage engine initialization.\n    See mysqld.cc, set_vars.cc.\n    Suppressing ways to interfere directly with the storage engine alone\n    prevents awkward situations where:\n    - the user wants the performance schema functionality, by using\n      '--enable-performance-schema' (the server option),\n    - yet disable explicitly a component needed for the functionality\n      to work, by using '--skip-performance-schema' (the plugin)\n  */\n  { \"performance_schema\", PLUGIN_FORCE }\n\n  /* we disable few other plugins by default */\n  ,{ \"feedback\", PLUGIN_OFF }\n};\n\n/* support for Services */\n\n#include \"sql_plugin_services.ic\"\n\n/*\n  A mutex LOCK_plugin must be acquired before accessing the\n  following variables/structures.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n*/\nmysql_mutex_t LOCK_plugin;\nstatic DYNAMIC_ARRAY plugin_dl_array;\nstatic DYNAMIC_ARRAY plugin_array;\nstatic HASH plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM];\nstatic MEM_ROOT plugin_mem_root;\nstatic bool reap_needed= false;\nstatic int plugin_array_version=0;\n\nstatic bool initialized= 0;\nulong dlopen_count;\n\n\n/*\n  write-lock on LOCK_system_variables_hash is required before modifying\n  the following variables/structures\n*/\nstatic MEM_ROOT plugin_vars_mem_root;\nstatic uint global_variables_dynamic_size= 0;\nstatic HASH bookmark_hash;\n\n\n/*\n  hidden part of opaque value passed to variable check functions.\n  Used to provide a object-like structure to non C++ consumers.\n*/\nstruct st_item_value_holder : public st_mysql_value\n{\n  Item *item;\n};\n\n\n/*\n  stored in bookmark_hash, this structure is never removed from the\n  hash and is used to mark a single offset for a thd local variable\n  even if plugins have been uninstalled and reinstalled, repeatedly.\n  This structure is allocated from plugin_mem_root.\n\n  The key format is as follows:\n    1 byte         - variable type code\n    name_len bytes - variable name\n    '\\0'           - end of key\n*/\nstruct st_bookmark\n{\n  uint name_len;\n  int offset;\n  uint version;\n  bool loaded;\n  char key[1];\n};\n\n\n/*\n  skeleton of a plugin variable - portion of structure common to all.\n*/\nstruct st_mysql_sys_var\n{\n  MYSQL_PLUGIN_VAR_HEADER;\n};\n\n/*\n  sys_var class for access to all plugin variables visible to the user\n*/\nclass sys_var_pluginvar: public sys_var, public Sql_alloc\n{\npublic:\n  struct st_plugin_int *plugin;\n  struct st_mysql_sys_var *plugin_var;\n\n  sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n                    st_plugin_int *p, st_mysql_sys_var *plugin_var_arg);\n  sys_var_pluginvar *cast_pluginvar() { return this; }\n  uchar* real_value_ptr(THD *thd, enum_var_type type);\n  TYPELIB* plugin_var_typelib(void);\n  uchar* do_value_ptr(THD *thd, enum_var_type type, const LEX_STRING *base);\n  uchar* session_value_ptr(THD *thd, const LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_SESSION, base); }\n  uchar* global_value_ptr(THD *thd, const LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_GLOBAL, base); }\n  uchar *default_value_ptr(THD *thd)\n  { return do_value_ptr(thd, OPT_DEFAULT, 0); }\n  bool do_check(THD *thd, set_var *var);\n  virtual void session_save_default(THD *thd, set_var *var) {}\n  virtual void global_save_default(THD *thd, set_var *var) {}\n  bool session_update(THD *thd, set_var *var);\n  bool global_update(THD *thd, set_var *var);\n  bool session_is_default(THD *thd);\n};\n\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root);\nstatic bool plugin_load_list(MEM_ROOT *, const char *);\nstatic int test_plugin_options(MEM_ROOT *, struct st_plugin_int *,\n                               int *, char **);\nstatic bool register_builtin(struct st_maria_plugin *, struct st_plugin_int *,\n                             struct st_plugin_int **);\nstatic void unlock_variables(THD *thd, struct system_variables *vars);\nstatic void cleanup_variables(struct system_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic void restore_ptr_backup(uint n, st_ptr_backup *backup);\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nbool plugin_is_forced(struct st_plugin_int *p)\n{\n  return p->load_option == PLUGIN_FORCE ||\n         p->load_option == PLUGIN_FORCE_PLUS_PERMANENT;\n}\n\nstatic void report_error(int where_to, uint error, ...)\n{\n  va_list args;\n  DBUG_ASSERT(where_to & (REPORT_TO_USER | REPORT_TO_LOG));\n  if (where_to & REPORT_TO_USER)\n  {\n    va_start(args, error);\n    my_printv_error(error, ER(error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG)\n  {\n    va_start(args, error);\n    error_log_print(ERROR_LEVEL, ER_DEFAULT(error), args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len)\n{\n  size_t prefix= my_strcspn(files_charset_info, path, path + len, FN_DIRSEP);\n  return  prefix < len;\n}\n\nstatic void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}\n\n\n/****************************************************************************\n  Value type thunks, allows the C world to play in the C++ world\n****************************************************************************/\n\nstatic int item_value_type(struct st_mysql_value *value)\n{\n  switch (((st_item_value_holder*)value)->item->result_type()) {\n  case INT_RESULT:\n    return MYSQL_VALUE_TYPE_INT;\n  case REAL_RESULT:\n    return MYSQL_VALUE_TYPE_REAL;\n  default:\n    return MYSQL_VALUE_TYPE_STRING;\n  }\n}\n\nstatic const char *item_val_str(struct st_mysql_value *value,\n                                char *buffer, int *length)\n{\n  String str(buffer, *length, system_charset_info), *res;\n  if (!(res= ((st_item_value_holder*)value)->item->val_str(&str)))\n    return NULL;\n  *length= res->length();\n  if (res->c_ptr_quick() == buffer)\n    return buffer;\n\n  /*\n    Lets be nice and create a temporary string since the\n    buffer was too small\n  */\n  return current_thd->strmake(res->ptr(), res->length());\n}\n\n\nstatic int item_val_int(struct st_mysql_value *value, long long *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_int();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\nstatic int item_is_unsigned(struct st_mysql_value *value)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  return item->unsigned_flag;\n}\n\nstatic int item_val_real(struct st_mysql_value *value, double *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_real();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\n#ifdef HAVE_DLOPEN\n\nstatic struct st_plugin_dl *plugin_dl_find(const LEX_STRING *dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(0);\n}\n\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(struct st_plugin_dl *plugin_dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (! tmp->ref_count)\n    {\n      memcpy(tmp, plugin_dl, sizeof(struct st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_dl_array, (uchar*)&plugin_dl))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_dl_array, plugin_dl_array.elements - 1,\n                        struct st_plugin_dl **)=\n      (struct st_plugin_dl *) memdup_root(&plugin_mem_root, (uchar*)plugin_dl,\n                                           sizeof(struct st_plugin_dl));\n  DBUG_RETURN(tmp);\n}\n#endif /* HAVE_DLOPEN */\n\n\nstatic void free_plugin_mem(struct st_plugin_dl *p)\n{\n#ifdef HAVE_DLOPEN\n  if (p->ptr_backup)\n  {\n    DBUG_ASSERT(p->nbackups);\n    DBUG_ASSERT(p->handle);\n    restore_ptr_backup(p->nbackups, p->ptr_backup);\n    my_free(p->ptr_backup);\n  }\n  if (p->handle)\n    dlclose(p->handle);\n#endif\n  my_free(p->dl.str);\n  if (p->allocated)\n    my_free(p->plugins);\n}\n\n\n/**\n  Reads data from mysql plugin interface\n\n  @param plugin_dl       Structure where the data should be put\n  @param sym             Reverence on version info\n  @param dlpath          Path to the module\n  @param report          What errors should be reported\n\n  @retval FALSE OK\n  @retval TRUE  ERROR\n*/\n\n#ifdef HAVE_DLOPEN\nstatic my_bool read_mysql_plugin_info(struct st_plugin_dl *plugin_dl,\n                                      void *sym, char *dlpath,\n                                      int report)\n{\n  DBUG_ENTER(\"read_maria_plugin_info\");\n  /* Determine interface version */\n  if (!sym)\n  {\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    DBUG_RETURN(TRUE);\n  }\n  plugin_dl->mariaversion= 0;\n  plugin_dl->mysqlversion= *(int *)sym;\n  /* Versioning */\n  if (plugin_dl->mysqlversion < min_plugin_interface_version ||\n      (plugin_dl->mysqlversion >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, ENOEXEC,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(TRUE);\n  }\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl->handle, plugin_declarations_sym)))\n  {\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    DBUG_RETURN(TRUE);\n  }\n\n  /* convert mysql declaration to maria one */\n  {\n    int i;\n    uint sizeof_st_plugin;\n    struct st_mysql_plugin *old;\n    struct st_maria_plugin *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl->handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin= (int)offsetof(struct st_mysql_plugin, version);\n    }\n\n    for (i= 0;\n         ((struct st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n      /* no op */;\n\n    cur= (struct st_maria_plugin*)\n          my_malloc((i + 1) * sizeof(struct st_maria_plugin),\n                    MYF(MY_ZEROFILL|MY_WME));\n    if (!cur)\n    {\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl->dl.length));\n      DBUG_RETURN(TRUE);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i=0;\n         (old= (struct st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n    {\n\n      cur[i].type= old->type;\n      cur[i].info= old->info;\n      cur[i].name= old->name;\n      cur[i].author= old->author;\n      cur[i].descr= old->descr;\n      cur[i].license= old->license;\n      cur[i].init= old->init;\n      cur[i].deinit= old->deinit;\n      cur[i].version= old->version;\n      cur[i].status_vars= old->status_vars;\n      cur[i].system_vars= old->system_vars;\n      /*\n        Something like this should be added to process\n        new mysql plugin versions:\n        if (plugin_dl->mysqlversion > 0x0101)\n        {\n           cur[i].newfield= CONSTANT_MEANS_UNKNOWN;\n        }\n        else\n        {\n           cur[i].newfield= old->newfield;\n        }\n      */\n      /* Maria only fields */\n      cur[i].version_info= \"Unknown\";\n      cur[i].maturity= MariaDB_PLUGIN_MATURITY_UNKNOWN;\n    }\n    plugin_dl->allocated= true;\n    plugin_dl->plugins= (struct st_maria_plugin *)cur;\n  }\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Reads data from maria plugin interface\n\n  @param plugin_dl       Structure where the data should be put\n  @param sym             Reverence on version info\n  @param dlpath          Path to the module\n  @param report          what errors should be reported\n\n  @retval FALSE OK\n  @retval TRUE  ERROR\n*/\n\nstatic my_bool read_maria_plugin_info(struct st_plugin_dl *plugin_dl,\n                                      void *sym, char *dlpath,\n                                      int report)\n{\n  DBUG_ENTER(\"read_maria_plugin_info\");\n\n  /* Determine interface version */\n  if (!(sym))\n  {\n    /*\n      Actually this branch impossible because in case of absence of maria\n      version we try mysql version.\n    */\n    report_error(report, ER_CANT_FIND_DL_ENTRY,\n                 maria_plugin_interface_version_sym);\n    DBUG_RETURN(TRUE);\n  }\n  plugin_dl->mariaversion= *(int *)sym;\n  plugin_dl->mysqlversion= 0;\n  /* Versioning */\n  if (plugin_dl->mariaversion < min_maria_plugin_interface_version ||\n      (plugin_dl->mariaversion >> 8) > (MARIA_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, ENOEXEC,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(TRUE);\n  }\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl->handle, maria_plugin_declarations_sym)))\n  {\n    report_error(report, ER_CANT_FIND_DL_ENTRY, maria_plugin_declarations_sym);\n    DBUG_RETURN(TRUE);\n  }\n  if (plugin_dl->mariaversion != MARIA_PLUGIN_INTERFACE_VERSION)\n  {\n    uint sizeof_st_plugin;\n    struct st_maria_plugin *old, *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl->handle, maria_sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n      report_error(report, ER_CANT_FIND_DL_ENTRY, maria_sizeof_st_plugin_sym);\n      DBUG_RETURN(TRUE);\n    }\n\n    if (sizeof_st_plugin != sizeof(st_mysql_plugin))\n    {\n      int i;\n      for (i= 0;\n           ((struct st_maria_plugin *)(ptr + i * sizeof_st_plugin))->info;\n           i++)\n        /* no op */;\n\n      cur= (struct st_maria_plugin*)\n        my_malloc((i + 1) * sizeof(struct st_maria_plugin),\n                  MYF(MY_ZEROFILL|MY_WME));\n      if (!cur)\n      {\n        report_error(report, ER_OUTOFMEMORY,\n                     static_cast<int>(plugin_dl->dl.length));\n        DBUG_RETURN(TRUE);\n      }\n      /*\n        All st_plugin fields not initialized in the plugin explicitly, are\n        set to 0. It matches C standard behaviour for struct initializers that\n        have less values than the struct definition.\n      */\n      for (i=0;\n           (old= (struct st_maria_plugin *)(ptr + i * sizeof_st_plugin))->info;\n           i++)\n        memcpy(cur + i, old, MY_MIN(sizeof(cur[i]), sizeof_st_plugin));\n\n      sym= cur;\n      plugin_dl->allocated= true;\n    }\n    else\n      sym= ptr;\n  }\n  plugin_dl->plugins= (struct st_maria_plugin *)sym;\n\n  DBUG_RETURN(FALSE);\n}\n#endif /* HAVE_DLOPEN */\n\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report)\n{\n#ifdef HAVE_DLOPEN\n  char dlpath[FN_REFLEN];\n  uint plugin_dir_len, dummy_errors, i;\n  struct st_plugin_dl *tmp= 0, plugin_dl;\n  void *sym;\n  st_ptr_backup tmp_backup[array_elements(list_of_services)];\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\", (\"dl->str: '%s', dl->length: %d\",\n                       dl->str, (int) dl->length));\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  plugin_dir_len= strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length((LEX_STRING *) dl, 0, NAME_CHAR_LEN,\n                               system_charset_info, 1) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN)\n  {\n    report_error(report, ER_UDF_NO_PATHS);\n    DBUG_RETURN(0);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp= plugin_dl_find(dl)))\n  {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  bzero(&plugin_dl, sizeof(plugin_dl));\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str, NullS);\n  (void) unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count= 1;\n  /* Open new dll handle */\n  if (!(plugin_dl.handle= dlopen(dlpath, RTLD_NOW)))\n  {\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, errno, my_dlerror(dlpath));\n    goto ret;\n  }\n  dlopen_count++;\n\n#ifdef HAVE_LINK_H\n  if (global_system_variables.log_warnings > 2)\n  {\n    struct link_map *lm = (struct link_map*) plugin_dl.handle;\n    sql_print_information(\"Loaded '%s' with offset 0x%lx\", dl->str, lm->l_addr);\n  }\n#endif\n\n  /* Checks which plugin interface present and reads info */\n  if (!(sym= dlsym(plugin_dl.handle, maria_plugin_interface_version_sym)))\n  {\n    if (read_mysql_plugin_info(&plugin_dl,\n                               dlsym(plugin_dl.handle,\n                                     plugin_interface_version_sym),\n                               dlpath,\n                               report))\n      goto ret;\n  }\n  else\n  {\n    if (read_maria_plugin_info(&plugin_dl, sym, dlpath, report))\n      goto ret;\n  }\n\n  /* link the services in */\n  for (i= 0; i < array_elements(list_of_services); i++)\n  {\n    if ((sym= dlsym(plugin_dl.handle, list_of_services[i].name)))\n    {\n      void **ptr= (void **)sym;\n      uint ver= (uint)(intptr)*ptr;\n      if (ver > list_of_services[i].version ||\n        (ver >> 8) < (list_of_services[i].version >> 8))\n      {\n        char buf[MYSQL_ERRMSG_SIZE];\n        my_snprintf(buf, sizeof(buf),\n                    \"service '%s' interface version mismatch\",\n                    list_of_services[i].name);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, ENOEXEC, buf);\n        goto ret;\n      }\n      tmp_backup[plugin_dl.nbackups++].save(ptr);\n      *ptr= list_of_services[i].service;\n    }\n  }\n\n  if (plugin_dl.nbackups)\n  {\n    size_t bytes= plugin_dl.nbackups * sizeof(plugin_dl.ptr_backup[0]);\n    plugin_dl.ptr_backup= (st_ptr_backup *)my_malloc(bytes, MYF(0));\n    if (!plugin_dl.ptr_backup)\n    {\n      restore_ptr_backup(plugin_dl.nbackups, tmp_backup);\n      report_error(report, ER_OUTOFMEMORY, bytes);\n      goto ret;\n    }\n    memcpy(plugin_dl.ptr_backup, tmp_backup, bytes);\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length= dl->length * files_charset_info->mbmaxlen + 1;\n  if (! (plugin_dl.dl.str= (char*) my_malloc(plugin_dl.dl.length, MYF(0))))\n  {\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(plugin_dl.dl.length));\n    goto ret;\n  }\n  plugin_dl.dl.length= copy_and_convert(plugin_dl.dl.str, plugin_dl.dl.length,\n    files_charset_info, dl->str, dl->length, system_charset_info,\n    &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length]= 0;\n  /* Add this dll to array */\n  if (! (tmp= plugin_dl_insert_or_reuse(&plugin_dl)))\n  {\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(struct st_plugin_dl)));\n    goto ret;\n  }\n\nret:\n  if (!tmp)\n    free_plugin_mem(&plugin_dl);\n\n  DBUG_RETURN(tmp);\n\n#else\n  DBUG_ENTER(\"plugin_dl_add\");\n  report_error(report, ER_FEATURE_DISABLED, \"plugin\", \"HAVE_DLOPEN\");\n  DBUG_RETURN(0);\n#endif\n}\n\n\nstatic void plugin_dl_del(struct st_plugin_dl *plugin_dl)\n{\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  if (!plugin_dl)\n    DBUG_VOID_RETURN;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  /* Do not remove this element, unless no other plugin uses this dll. */\n  if (! --plugin_dl->ref_count)\n  {\n    free_plugin_mem(plugin_dl);\n    bzero(plugin_dl, sizeof(struct st_plugin_dl));\n  }\n\n  DBUG_VOID_RETURN;\n}\n\n\nstatic struct st_plugin_int *plugin_find_internal(const LEX_STRING *name, int type)\n{\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (! initialized)\n    DBUG_RETURN(0);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      struct st_plugin_int *plugin= (st_plugin_int *)\n        my_hash_search(&plugin_hash[i], (const uchar *)name->str, name->length);\n      if (plugin)\n        DBUG_RETURN(plugin);\n    }\n  }\n  else\n    DBUG_RETURN((st_plugin_int *)\n        my_hash_search(&plugin_hash[type], (const uchar *)name->str,\n                       name->length));\n  DBUG_RETURN(0);\n}\n\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_STRING *name, int type)\n{\n  SHOW_COMP_OPTION rc= SHOW_OPTION_NO;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n  {\n    rc= SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY)\n      rc= SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nbool plugin_is_ready(const LEX_STRING *name, int type)\n{\n  bool rc= FALSE;\n  if (plugin_status(name, type) == SHOW_OPTION_YES)\n    rc= TRUE;\n  return rc;\n}\n\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type)\n{\n  LEX_STRING plugin_name= { (char *) name, len };\n  return plugin_status(&plugin_name, type);\n}\n\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc)\n{\n  st_plugin_int *pi= plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED |\n                   PLUGIN_IS_DELETED))\n  {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /*\n      In optimized builds we don't do reference counting for built-in\n      (plugin->plugin_dl == 0) plugins.\n    */\n    if (!pi->plugin_dl)\n      DBUG_RETURN(pi);\n\n    plugin= pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin= (plugin_ref) my_malloc(sizeof(pi), MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin= pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"lock\",(\"thd: 0x%lx  plugin: \\\"%s\\\" LOCK ref_count: %d\",\n                       (long) current_thd, pi->name.str, pi->ref_count));\n\n    if (lex)\n      insert_dynamic(&lex->plugins, (uchar*)&plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\nplugin_ref plugin_lock(THD *thd, plugin_ref ptr)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n\n#ifdef DBUG_OFF\n  /*\n    In optimized builds we don't do reference counting for built-in\n    (plugin->plugin_dl == 0) plugins.\n\n    Note that we access plugin->plugin_dl outside of LOCK_plugin, and for\n    dynamic plugins a 'plugin' could correspond to plugin that was unloaded\n    meanwhile!  But because st_plugin_int is always allocated on\n    plugin_mem_root, the pointer can never be invalid - the memory is never\n    freed.\n    Of course, the memory that 'plugin' points to can be overwritten by\n    another plugin being loaded, but plugin->plugin_dl can never change\n    from zero to non-zero or vice versa.\n    That is, it's always safe to check for plugin->plugin_dl==0 even\n    without a mutex.\n  */\n  if (! plugin_dlib(ptr))\n  {\n    plugin_ref_to_int(ptr)->locks_total++;\n    DBUG_RETURN(ptr);\n  }\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin_ref_to_int(ptr)->locks_total++;\n  rc= intern_plugin_lock(lex, ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_STRING *name, int type)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc= NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n    rc= intern_plugin_lock(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nstatic st_plugin_int *plugin_insert_or_reuse(struct st_plugin_int *plugin)\n{\n  uint i;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (tmp->state == PLUGIN_IS_FREED)\n    {\n      memcpy(tmp, plugin, sizeof(struct st_plugin_int));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_array, (uchar*)&plugin))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                        struct st_plugin_int **)=\n       (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)plugin,\n                                            sizeof(struct st_plugin_int));\n  DBUG_RETURN(tmp);\n}\n\n\n/*\n  NOTE\n    Requires that a write-lock is held on LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root,\n                       const LEX_STRING *name, LEX_STRING *dl, int report)\n{\n  struct st_plugin_int tmp, *maybe_dupe;\n  struct st_maria_plugin *plugin;\n  uint oks= 0, errs= 0, dupes= 0;\n  DBUG_ENTER(\"plugin_add\");\n  DBUG_PRINT(\"enter\", (\"name: %s  dl: %s\", name->str, dl->str));\n\n  if (name->str && plugin_find_internal(name, MYSQL_ANY_PLUGIN))\n  {\n    report_error(report, ER_PLUGIN_INSTALLED, name->str);\n    DBUG_RETURN(TRUE);\n  }\n  /* Clear the whole struct to catch future extensions. */\n  bzero((char*) &tmp, sizeof(tmp));\n  fix_dl_name(tmp_root, dl);\n  if (! (tmp.plugin_dl= plugin_dl_add(dl, report)))\n    DBUG_RETURN(TRUE);\n  /* Find plugin by name */\n  for (plugin= tmp.plugin_dl->plugins; plugin->info; plugin++)\n  {\n    tmp.name.str= (char *)plugin->name;\n    tmp.name.length= strlen(plugin->name);\n\n    if (plugin->type < 0 || plugin->type >= MYSQL_MAX_PLUGIN_TYPE_NUM)\n      continue; // invalid plugin type\n\n    if (plugin->type == MYSQL_UDF_PLUGIN ||\n        (plugin->type == MariaDB_PASSWORD_VALIDATION_PLUGIN &&\n         tmp.plugin_dl->mariaversion == 0))\n      continue; // unsupported plugin type\n\n    if (name->str && my_strnncoll(system_charset_info,\n                                  (const uchar *)name->str, name->length,\n                                  (const uchar *)tmp.name.str, tmp.name.length))\n      continue; // plugin name doesn't match\n\n    if (!name->str &&\n        (maybe_dupe= plugin_find_internal(&tmp.name, MYSQL_ANY_PLUGIN)))\n    {\n      if (plugin->name != maybe_dupe->plugin->name)\n      {\n        report_error(report, ER_UDF_EXISTS, plugin->name);\n        DBUG_RETURN(TRUE);\n      }\n      dupes++;\n      continue; // already installed\n    }\n    struct st_plugin_int *tmp_plugin_ptr;\n    if (*(int*)plugin->info <\n        min_plugin_info_interface_version[plugin->type] ||\n        ((*(int*)plugin->info) >> 8) >\n        (cur_plugin_info_interface_version[plugin->type] >> 8))\n    {\n      char buf[256];\n      strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n               plugin_type_names[plugin->type].str,\n               \" plugin \", tmp.name.str,\n               \" not supported by this version of the server\", NullS);\n      report_error(report, ER_CANT_OPEN_LIBRARY, dl->str, ENOEXEC, buf);\n      goto err;\n    }\n    if (plugin_maturity_map[plugin->maturity] < plugin_maturity)\n    {\n      char buf[256];\n      strxnmov(buf, sizeof(buf) - 1, \"Loading of \",\n               plugin_maturity_names[plugin->maturity],\n               \" plugin \", tmp.name.str,\n               \" is prohibited by --plugin-maturity=\",\n               plugin_maturity_names[plugin_maturity],\n               NullS);\n      report_error(report, ER_CANT_OPEN_LIBRARY, dl->str, EPERM, buf);\n      goto err;\n    }\n    tmp.plugin= plugin;\n    tmp.ref_count= 0;\n    tmp.state= PLUGIN_IS_UNINITIALIZED;\n    tmp.load_option= PLUGIN_ON;\n\n    if (!(tmp_plugin_ptr= plugin_insert_or_reuse(&tmp)))\n      goto err;\n    plugin_array_version++;\n    if (my_hash_insert(&plugin_hash[plugin->type], (uchar*)tmp_plugin_ptr))\n      tmp_plugin_ptr->state= PLUGIN_IS_FREED;\n    init_alloc_root(&tmp_plugin_ptr->mem_root, 4096, 4096, MYF(0));\n\n    if (name->str)\n      DBUG_RETURN(FALSE); // all done\n\n    oks++;\n    tmp.plugin_dl->ref_count++;\n    continue; // otherwise - go on\n\nerr:\n    errs++;\n    if (name->str)\n      break;\n  }\n\n  DBUG_ASSERT(!name->str || !dupes); // dupes is ONLY for name->str == 0\n\n  if (errs == 0 && oks == 0 && !dupes) // no plugin was found\n    report_error(report, ER_CANT_FIND_DL_ENTRY, name->str);\n\n  plugin_dl_del(tmp.plugin_dl);\n  DBUG_RETURN(errs > 0 || oks + dupes == 0);\n}\n\nstatic void plugin_variables_deinit(struct st_plugin_int *plugin)\n{\n\n  for (sys_var *var= plugin->system_vars; var; var= var->next)\n    (*var->test_load)= FALSE;\n  mysql_del_sys_var_chain(plugin->system_vars);\n}\n\nstatic void plugin_deinitialize(struct st_plugin_int *plugin, bool ref_check)\n{\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars)\n  {\n    /*\n      historical ndb behavior caused MySQL plugins to specify\n      status var names in full, with the plugin name prefix.\n      this was never fixed in MySQL.\n      MariaDB fixes that but supports MySQL style too.\n    */\n    SHOW_VAR *show_vars= plugin->plugin->status_vars;\n    SHOW_VAR tmp_array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (strncasecmp(show_vars->name, plugin->name.str, plugin->name.length))\n      show_vars= tmp_array;\n\n    remove_status_vars(show_vars);\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' of type %s failed deinitialization\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n    }\n  }\n  else if (plugin->plugin->deinit)\n  {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin))\n    {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state= PLUGIN_IS_UNINITIALIZED;\n\n  if (ref_check && plugin->ref_count)\n    sql_print_error(\"Plugin '%s' has ref_count=%d after deinitialization.\",\n                    plugin->name.str, plugin->ref_count);\n  plugin_variables_deinit(plugin);\n}\n\nstatic void plugin_del(struct st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_del\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  /* Free allocated strings before deleting the plugin. */\n  plugin_vars_free_values(plugin->system_vars);\n  restore_ptr_backup(plugin->nbackups, plugin->ptr_backup);\n  if (plugin->plugin_dl)\n  {\n    my_hash_delete(&plugin_hash[plugin->plugin->type], (uchar*)plugin);\n    plugin_dl_del(plugin->plugin_dl);\n    plugin->state= PLUGIN_IS_FREED;\n    plugin_array_version++;\n    free_root(&plugin->mem_root, MYF(0));\n  }\n  else\n    plugin->state= PLUGIN_IS_UNINITIALIZED;\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void)\n{\n  uint count;\n  struct st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed)\n    return;\n\n  reap_needed= false;\n  count= plugin_array.elements;\n  reap= (struct st_plugin_int **)my_alloca(sizeof(plugin)*(count+1));\n  *(reap++)= NULL;\n\n  for (uint i=0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    HASH *hash= plugin_hash + plugin_type_initialization_order[i];\n    for (uint j= 0; j < hash->records; j++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, j);\n      if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count)\n      {\n        /* change the status flag to prevent reaping by another thread */\n        plugin->state= PLUGIN_IS_DYING;\n        *(reap++)= plugin;\n      }\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list= reap;\n  while ((plugin= *(--list)))\n      plugin_deinitialize(plugin, true);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin= *(--reap)))\n    plugin_del(plugin);\n\n  my_afree(reap);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin)\n{\n  int i;\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin)\n    DBUG_VOID_RETURN;\n\n  pi= plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl)\n    DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  if (lex)\n  {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    for (i= lex->plugins.elements - 1; i >= 0; i--)\n      if (plugin == *dynamic_element(&lex->plugins, i, plugin_ref*))\n      {\n        delete_dynamic_element(&lex->plugins, i);\n        break;\n      }\n    DBUG_ASSERT(i >= 0);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  DBUG_PRINT(\"lock\",(\"thd: 0x%lx  plugin: \\\"%s\\\" UNLOCK ref_count: %d\",\n                     (long) current_thd, pi->name.str, pi->ref_count));\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count)\n    reap_needed= true;\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin)\n    DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin))\n    DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, uint count)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  if (count == 0)\n    DBUG_VOID_RETURN;\n\n  DBUG_ASSERT(list);\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--)\n    intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic int plugin_initialize(MEM_ROOT *tmp_root, struct st_plugin_int *plugin,\n                             int *argc, char **argv, bool options_only)\n{\n  int ret= 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state= plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  if (test_plugin_options(tmp_root, plugin, argc, argv))\n    state= PLUGIN_IS_DISABLED;\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n\n  if (options_only || state == PLUGIN_IS_DISABLED)\n  {\n    ret= !options_only && plugin_is_forced(plugin);\n    state= PLUGIN_IS_DISABLED;\n    goto err;\n  }\n\n  if (plugin_type_initialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' registration as a %s failed.\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n  }\n  else if (plugin->plugin->init)\n  {\n    if (plugin->plugin->init(plugin))\n    {\n      sql_print_error(\"Plugin '%s' init function returned error.\",\n                      plugin->name.str);\n      goto err;\n    }\n  }\n  state= PLUGIN_IS_READY; // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars)\n  {\n    /*\n      historical ndb behavior caused MySQL plugins to specify\n      status var names in full, with the plugin name prefix.\n      this was never fixed in MySQL.\n      MariaDB fixes that but supports MySQL style too.\n    */\n    SHOW_VAR *show_vars= plugin->plugin->status_vars;\n    SHOW_VAR tmp_array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (strncasecmp(show_vars->name, plugin->name.str, plugin->name.length))\n      show_vars= tmp_array;\n\n    if (add_status_vars(show_vars))\n      goto err;\n  }\n\n  ret= 0;\n\nerr:\n  if (ret)\n    plugin_variables_deinit(plugin);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state= state;\n\n  DBUG_RETURN(ret);\n}\n\n\nextern \"C\" uchar *get_plugin_hash_key(const uchar *, size_t *, my_bool);\nextern \"C\" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);\n\n\nuchar *get_plugin_hash_key(const uchar *buff, size_t *length,\n                           my_bool not_used __attribute__((unused)))\n{\n  struct st_plugin_int *plugin= (st_plugin_int *)buff;\n  *length= (uint)plugin->name.length;\n  return((uchar *)plugin->name.str);\n}\n\n\nuchar *get_bookmark_hash_key(const uchar *buff, size_t *length,\n                             my_bool not_used __attribute__((unused)))\n{\n  struct st_bookmark *var= (st_bookmark *)buff;\n  *length= var->name_len + 1;\n  return (uchar*) var->key;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '-')\n      *p= '_';\n}\n\nstatic inline void convert_underscore_to_dash(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '_')\n      *p= '-';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\n\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_plugin_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_plugin_mutexes);\n  PSI_server->register_mutex(category, all_plugin_mutexes, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  The logic is that we first load and initialize all compiled in plugins.\n  From there we load up the dynamic types (assuming we have not been told to\n  skip this part).\n\n  Finally we initialize everything, aka the dynamic that have yet to initialize.\n*/\nint plugin_init(int *argc, char **argv, int flags)\n{\n  uint i;\n  struct st_maria_plugin **builtins;\n  struct st_maria_plugin *plugin;\n  struct st_plugin_int tmp, *plugin_ptr, **reap;\n  MEM_ROOT tmp_root;\n  bool reaped_mandatory_plugin= false;\n  bool mandatory= true;\n  LEX_STRING MyISAM= { C_STRING_WITH_LEN(\"MyISAM\") };\n  DBUG_ENTER(\"plugin_init\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  dlopen_count =0;\n\n  init_alloc_root(&plugin_mem_root, 4096, 4096, MYF(0));\n  init_alloc_root(&plugin_vars_mem_root, 4096, 4096, MYF(0));\n  init_alloc_root(&tmp_root, 4096, 4096, MYF(0));\n\n  if (my_hash_init(&bookmark_hash, &my_charset_bin, 32, 0, 0,\n                   get_bookmark_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n\n  /*\n    The 80 is from 2016-04-27 when we had 71 default plugins\n    Big enough to avoid many mallocs even in future\n  */\n  if (my_init_dynamic_array(&plugin_dl_array,\n                            sizeof(struct st_plugin_dl *), 16, 16, MYF(0)) ||\n      my_init_dynamic_array(&plugin_array,\n                            sizeof(struct st_plugin_int *), 80, 32, MYF(0)))\n    goto err;\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    if (my_hash_init(&plugin_hash[i], system_charset_info, 32, 0, 0,\n                     get_plugin_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n  }\n\n  /* prepare debug_sync service */\n  DBUG_ASSERT(strcmp(list_of_services[1].name, \"debug_sync_service\") == 0);\n  list_of_services[1].service= *(void**)&debug_sync_C_callback_ptr;\n\n  /* prepare encryption_keys service */\n  finalize_encryption_plugin(0);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  initialized= 1;\n\n  /*\n    First we register builtin plugins\n  */\n  if (global_system_variables.log_warnings >= 9)\n    sql_print_information(\"Initializing built-in plugins\");\n\n  for (builtins= mysql_mandatory_plugins; *builtins || mandatory; builtins++)\n  {\n    if (!*builtins)\n    {\n      builtins= mysql_optional_plugins;\n      mandatory= false;\n      if (!*builtins)\n        break;\n    }\n    for (plugin= *builtins; plugin->info; plugin++)\n    {\n      if (opt_ignore_builtin_innodb &&\n          !my_strnncoll(&my_charset_latin1, (const uchar*) plugin->name,\n                        6, (const uchar*) \"InnoDB\", 6))\n        continue;\n\n      bzero(&tmp, sizeof(tmp));\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= strlen(plugin->name);\n      tmp.state= 0;\n      tmp.load_option= mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      for (i=0; i < array_elements(override_plugin_load_policy); i++)\n      {\n        if (!my_strcasecmp(&my_charset_latin1, plugin->name,\n                           override_plugin_load_policy[i].plugin_name))\n        {\n          tmp.load_option= override_plugin_load_policy[i].override;\n          break;\n        }\n      }\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      tmp.state= PLUGIN_IS_UNINITIALIZED;\n      if (register_builtin(plugin, &tmp, &plugin_ptr))\n        goto err_unlock;\n    }\n  }\n\n  /*\n    First, we initialize only MyISAM - that should almost always succeed\n    (almost always, because plugins can be loaded outside of the server, too).\n  */\n  plugin_ptr= plugin_find_internal(&MyISAM, MYSQL_STORAGE_ENGINE_PLUGIN);\n  DBUG_ASSERT(plugin_ptr || !mysql_mandatory_plugins[0]);\n  if (plugin_ptr)\n  {\n    DBUG_ASSERT(plugin_ptr->load_option == PLUGIN_FORCE);\n\n    if (plugin_initialize(&tmp_root, plugin_ptr, argc, argv, false))\n      goto err_unlock;\n\n    /*\n      set the global default storage engine variable so that it will\n      not be null in any child thread.\n    */\n    global_system_variables.table_plugin =\n      intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n      DBUG_ASSERT(plugin_ptr->ref_count == 1);\n\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /* Register (not initialize!) all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING))\n  {\n    I_List_iterator<i_string> iter(opt_plugin_load_list);\n    i_string *item;\n    if (global_system_variables.log_warnings >= 9)\n      sql_print_information(\"Initializing plugins specified on the command line\");\n    while (NULL != (item= iter++))\n      plugin_load_list(&tmp_root, item->ptr);\n\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n    {\n      char path[FN_REFLEN + 1];\n      build_table_filename(path, sizeof(path) - 1, \"mysql\", \"plugin\", reg_ext, 0);\n      char engine_name_buf[NAME_CHAR_LEN + 1];\n      LEX_STRING maybe_myisam= { engine_name_buf, 0 };\n      frm_type_enum frm_type= dd_frm_type(NULL, path, &maybe_myisam);\n      /* if mysql.plugin table is MyISAM - load it right away */\n      if (frm_type == FRMTYPE_TABLE && !strcasecmp(maybe_myisam.str, \"MyISAM\"))\n      {\n        plugin_load(&tmp_root);\n        flags|= PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n      }\n    }\n  }\n\n  /*\n    Now we initialize all remaining plugins\n  */\n\n  mysql_mutex_lock(&LOCK_plugin);\n  reap= (st_plugin_int **) my_alloca((plugin_array.elements+1) * sizeof(void*));\n  *(reap++)= NULL;\n\n  for(;;)\n  {\n    for (i=0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      HASH *hash= plugin_hash + plugin_type_initialization_order[i];\n      for (uint idx= 0; idx < hash->records; idx++)\n      {\n        plugin_ptr= (struct st_plugin_int *) my_hash_element(hash, idx);\n        if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED)\n        {\n          if (plugin_initialize(&tmp_root, plugin_ptr, argc, argv,\n                                (flags & PLUGIN_INIT_SKIP_INITIALIZATION)))\n          {\n            plugin_ptr->state= PLUGIN_IS_DYING;\n            *(reap++)= plugin_ptr;\n          }\n        }\n      }\n    }\n\n    /* load and init plugins from the plugin table (unless done already) */\n    if (flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE)\n      break;\n\n    mysql_mutex_unlock(&LOCK_plugin);\n    plugin_load(&tmp_root);\n    flags|= PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n    mysql_mutex_lock(&LOCK_plugin);\n  }\n\n  /*\n    Check if any plugins have to be reaped\n  */\n  while ((plugin_ptr= *(--reap)))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_is_forced(plugin_ptr))\n      reaped_mandatory_plugin= TRUE;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  my_afree(reap);\n  if (reaped_mandatory_plugin)\n    goto err;\n\n  free_root(&tmp_root, MYF(0));\n\n  DBUG_RETURN(0);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\nerr:\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(1);\n}\n\n\nstatic bool register_builtin(struct st_maria_plugin *plugin,\n                             struct st_plugin_int *tmp,\n                             struct st_plugin_int **ptr)\n{\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count= 0;\n  tmp->plugin_dl= 0;\n\n  if (insert_dynamic(&plugin_array, (uchar*)&tmp))\n    DBUG_RETURN(1);\n\n  *ptr= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                         struct st_plugin_int **)=\n        (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)tmp,\n                                             sizeof(struct st_plugin_int));\n\n  if (my_hash_insert(&plugin_hash[plugin->type],(uchar*) *ptr))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  READ_RECORD read_record_info;\n  int error;\n  THD *new_thd= new THD(0);\n  bool result;\n  DBUG_ENTER(\"plugin_load\");\n\n  if (global_system_variables.log_warnings >= 9)\n    sql_print_information(\"Initializing installed plugins\");\n\n  new_thd->thread_stack= (char*) &tables;\n  new_thd->store_globals();\n  new_thd->db= my_strdup(\"mysql\", MYF(0));\n  new_thd->db_length= 5;\n  bzero((char*) &new_thd->net, sizeof(new_thd->net));\n  tables.init_one_table(STRING_WITH_LEN(\"mysql\"), STRING_WITH_LEN(\"plugin\"),\n                        \"plugin\", TL_READ);\n  tables.open_strategy= TABLE_LIST::OPEN_NORMAL;\n\n  result= open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  table= tables.table;\n  if (result)\n  {\n    DBUG_PRINT(\"error\",(\"Can't open plugin table\"));\n    if (!opt_help)\n      sql_print_error(\"Could not open mysql.plugin table. \"\n                      \"Some plugins may be not loaded\");\n    else\n      sql_print_warning(\"Could not open mysql.plugin table. \"\n                        \"Some options may be missing from the help text\");\n    goto end;\n  }\n\n  if (init_read_record(&read_record_info, new_thd, table, NULL, NULL, 1, 0,\n                       FALSE))\n  {\n    sql_print_error(\"Could not initialize init_read_record; Plugins not \"\n                    \"loaded\");\n    goto end;\n  }\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_STRING name= {(char *)str_name.ptr(), str_name.length()};\n    LEX_STRING dl= {(char *)str_dl.ptr(), str_dl.length()};\n\n    /*\n      there're no other threads running yet, so we don't need a mutex.\n      but plugin_add() before is designed to work in multi-threaded\n      environment, and it uses mysql_mutex_assert_owner(), so we lock\n      the mutex here to satisfy the assert\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_add(tmp_root, &name, &dl, REPORT_TO_LOG);\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  if (error > 0)\n    sql_print_error(ER_THD(new_thd, ER_GET_ERRNO), my_errno,\n                           table->file->table_type());\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n  close_mysql_tables(new_thd);\nend:\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, const char *list)\n{\n  char buffer[FN_REFLEN];\n  LEX_STRING name= {buffer, 0}, dl= {NULL, 0}, *str= &name;\n  char *p= buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list)\n  {\n    if (p == buffer + sizeof(buffer) - 1)\n    {\n      sql_print_error(\"plugin-load parameter too long\");\n      DBUG_RETURN(TRUE);\n    }\n\n    switch ((*(p++)= *(list++))) {\n    case '\\0':\n      list= NULL; /* terminate the loop */\n#ifndef __WIN__\n      /* fall through */\n    case ':':     /* can't use this as delimiter as it may be drive letter */\n#endif\n    case ';':\n      str->str[str->length]= '\\0';\n      if (str == &name)  // load all plugins in named module\n      {\n        if (!name.length)\n        {\n          p--;    /* reset pointer */\n          continue;\n        }\n\n        dl= name;\n        mysql_mutex_lock(&LOCK_plugin);\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        name.str= 0; // load everything\n        if (plugin_add(tmp_root, &name, &dl, REPORT_TO_LOG))\n          goto error;\n      }\n      else\n      {\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        mysql_mutex_lock(&LOCK_plugin);\n        if (plugin_add(tmp_root, &name, &dl, REPORT_TO_LOG))\n          goto error;\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n      name.length= dl.length= 0;\n      dl.str= NULL; name.str= p= buffer;\n      str= &name;\n      continue;\n    case '=':\n    case '#':\n      if (str == &name)\n      {\n        name.str[name.length]= '\\0';\n        str= &dl;\n        str->str= p;\n        continue;\n      }\n      /* fall through */\n    default:\n      str->length++;\n      continue;\n    }\n  }\n  DBUG_RETURN(FALSE);\nerror:\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (name.str)\n    sql_print_error(\"Couldn't load plugin '%s' from '%s'.\",\n                    name.str, dl.str);\n  else\n    sql_print_error(\"Couldn't load plugins from '%s'.\", dl.str);\n  DBUG_RETURN(TRUE);\n}\n\n\nvoid plugin_shutdown(void)\n{\n  uint i, count= plugin_array.elements;\n  struct st_plugin_int **plugins, *plugin;\n  struct st_plugin_dl **dl;\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed= true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count= plugin_array.elements))\n    {\n      reap_plugins();\n      for (i= 0; i < count; i++)\n      {\n        plugin= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n        if (plugin->state == PLUGIN_IS_READY)\n        {\n          plugin->state= PLUGIN_IS_DELETED;\n          reap_needed= true;\n        }\n      }\n      if (!reap_needed)\n      {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(NULL, &global_system_variables);\n        unlock_variables(NULL, &max_system_variables);\n      }\n    }\n\n    plugins= (struct st_plugin_int **) my_alloca(sizeof(void*) * (count+1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i= 0; i < count; i++)\n    {\n      plugins[i]= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state= PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i= 0; i < count; i++)\n      if (!(plugins[i]->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED |\n                                 PLUGIN_IS_DISABLED)))\n      {\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, as there're no\n      concurrent threads anymore. But some functions called from here\n      use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i= 0; i < count; i++)\n    {\n      if (plugins[i]->ref_count)\n        sql_print_error(\"Plugin '%s' has ref_count=%d after shutdown.\",\n                        plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED ||\n          plugins[i]->state & PLUGIN_IS_DISABLED)\n        plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(&global_system_variables);\n    cleanup_variables(&max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    initialized= 0;\n    mysql_mutex_destroy(&LOCK_plugin);\n\n    my_afree(plugins);\n  }\n\n  /* Dispose of the memory */\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    my_hash_free(&plugin_hash[i]);\n  delete_dynamic(&plugin_array);\n\n  count= plugin_dl_array.elements;\n  dl= (struct st_plugin_dl **)my_alloca(sizeof(void*) * count);\n  for (i= 0; i < count; i++)\n    dl[i]= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n  for (i= 0; i < plugin_dl_array.elements; i++)\n    free_plugin_mem(dl[i]);\n  my_afree(dl);\n  delete_dynamic(&plugin_dl_array);\n\n  my_hash_free(&bookmark_hash);\n  free_root(&plugin_mem_root, MYF(0));\n  free_root(&plugin_vars_mem_root, MYF(0));\n\n  global_variables_dynamic_size= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n/**\n  complete plugin installation (after plugin_add).\n\n  That is, initialize it, and update mysql.plugin table\n*/\nstatic bool finalize_install(THD *thd, TABLE *table, const LEX_STRING *name,\n                             int *argc, char **argv)\n{\n  struct st_plugin_int *tmp= plugin_find_internal(name, MYSQL_ANY_PLUGIN);\n  int error;\n  DBUG_ASSERT(tmp);\n  mysql_mutex_assert_owner(&LOCK_plugin); // because of tmp->state\n\n  if (tmp->state != PLUGIN_IS_UNINITIALIZED)\n  {\n    /* already installed */\n    return 0;\n  }\n  else\n  {\n    if (plugin_initialize(thd->mem_root, tmp, argc, argv, false))\n    {\n      report_error(REPORT_TO_USER, ER_CANT_INITIALIZE_UDF, name->str,\n                   \"Plugin initialization function failed.\");\n      tmp->state= PLUGIN_IS_DELETED;\n      return 1;\n    }\n  }\n  if (tmp->state == PLUGIN_IS_DISABLED)\n  {\n    if (global_system_variables.log_warnings)\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                          ER_CANT_INITIALIZE_UDF,\n                          ER_THD(thd, ER_CANT_INITIALIZE_UDF),\n                          name->str, \"Plugin is disabled\");\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  tmp_disable_binlog(thd);\n  table->use_all_columns();\n  restore_record(table, s->default_values);\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  table->field[1]->store(tmp->plugin_dl->dl.str, tmp->plugin_dl->dl.length,\n                         files_charset_info);\n  error= table->file->ha_write_row(table->record[0]);\n  reenable_binlog(thd);\n  if (error)\n  {\n    table->file->print_error(error, MYF(0));\n    tmp->state= PLUGIN_IS_DELETED;\n    return 1;\n  }\n  return 0;\n}\n\nbool mysql_install_plugin(THD *thd, const LEX_STRING *name,\n                          const LEX_STRING *dl_arg)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  LEX_STRING dl= *dl_arg;\n  bool error;\n  int argc=orig_argc;\n  char **argv=orig_argv;\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n  if (!opt_noacl && check_table_access(thd, INSERT_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table = open_ltable(thd, &tables, TL_WRITE,\n                             MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv, NULL))\n  {\n    report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n\n    See also mysql_uninstall_plugin() and initialize_audit_plugin()\n  */\n  unsigned long event_class_mask[MYSQL_AUDIT_CLASS_MASK_SIZE] =\n  { MYSQL_AUDIT_GENERAL_CLASSMASK };\n  if (mysql_audit_general_enabled())\n    mysql_audit_acquire_plugins(thd, event_class_mask);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  error= plugin_add(thd->mem_root, name, &dl, REPORT_TO_USER);\n  if (error)\n    goto err;\n\n  if (name->str)\n    error= finalize_install(thd, table, name, &argc, argv);\n  else\n  {\n    st_plugin_dl *plugin_dl= plugin_dl_find(&dl);\n    struct st_maria_plugin *plugin;\n    for (plugin= plugin_dl->plugins; plugin->info; plugin++)\n    {\n      LEX_STRING str= { const_cast<char*>(plugin->name), strlen(plugin->name) };\n      error|= finalize_install(thd, table, &str, &argc, argv);\n    }\n  }\n\n  if (error)\n  {\n    reap_needed= true;\n    reap_plugins();\n  }\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (argv)\n    free_defaults(argv);\n  DBUG_RETURN(error);\n}\n\n\nstatic bool do_uninstall(THD *thd, TABLE *table, const LEX_STRING *name)\n{\n  struct st_plugin_int *plugin;\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!(plugin= plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING))\n  {\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    return 1;\n  }\n  if (!plugin->plugin_dl)\n  {\n    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));\n    return 1;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    return 1;\n  }\n\n  plugin->state= PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_BUSY, ER_THD(thd, WARN_PLUGIN_BUSY));\n  else\n    reap_needed= true;\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n  if (! table->file->ha_index_read_idx_map(table->record[0], 0, user_key,\n                                           HA_WHOLE_KEY, HA_READ_KEY_EXACT))\n  {\n    int error;\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    tmp_disable_binlog(thd);\n    error= table->file->ha_delete_row(table->record[0]);\n    reenable_binlog(thd);\n    if (error)\n    {\n      table->file->print_error(error, MYF(0));\n      return 1;\n    }\n  }\n  return 0;\n}\n\n\nbool mysql_uninstall_plugin(THD *thd, const LEX_STRING *name,\n                            const LEX_STRING *dl_arg)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  LEX_STRING dl= *dl_arg;\n  bool error= false;\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl && check_table_access(thd, DELETE_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n\n    See also mysql_install_plugin() and initialize_audit_plugin()\n  */\n  unsigned long event_class_mask[MYSQL_AUDIT_CLASS_MASK_SIZE] =\n  { MYSQL_AUDIT_GENERAL_CLASSMASK };\n  if (mysql_audit_general_enabled())\n    mysql_audit_acquire_plugins(thd, event_class_mask);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  if (name->str)\n    error= do_uninstall(thd, table, name);\n  else\n  {\n    fix_dl_name(thd->mem_root, &dl);\n    st_plugin_dl *plugin_dl= plugin_dl_find(&dl);\n    if (plugin_dl)\n    {\n      for (struct st_maria_plugin *plugin= plugin_dl->plugins;\n           plugin->info; plugin++)\n      {\n        LEX_STRING str= { const_cast<char*>(plugin->name), strlen(plugin->name) };\n        error|= do_uninstall(thd, table, &str);\n      }\n    }\n    else\n    {\n      my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"SONAME\", dl.str);\n      error= true;\n    }\n  }\n  reap_plugins();\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(error);\n}\n\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                       int type, uint state_mask, void *arg)\n{\n  uint idx, total;\n  struct st_plugin_int *plugin, **plugins;\n  int version=plugin_array_version;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized)\n    DBUG_RETURN(FALSE);\n\n  state_mask= ~state_mask; // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total= type == MYSQL_ANY_PLUGIN ? plugin_array.elements\n                                  : plugin_hash[type].records;\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins=(struct st_plugin_int **)my_alloca(total*sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  else\n  {\n    HASH *hash= plugin_hash + type;\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, idx);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (idx= 0; idx < total; idx++)\n  {\n    if (unlikely(version != plugin_array_version))\n    {\n      mysql_mutex_lock(&LOCK_plugin);\n      for (uint i=idx; i < total; i++)\n        if (plugins[i] && plugins[i]->state & state_mask)\n          plugins[i]=0;\n      mysql_mutex_unlock(&LOCK_plugin);\n    }\n    plugin= plugins[idx];\n    /* It will stop iterating on first engine error when \"func\" returns TRUE */\n    if (plugin && func(thd, plugin_int_to_ref(plugin), arg))\n        goto err;\n  }\n\n  my_afree(plugins);\n  DBUG_RETURN(FALSE);\nerr:\n  my_afree(plugins);\n  DBUG_RETURN(TRUE);\n}\n\n\nstatic bool plugin_dl_foreach_internal(THD *thd, st_plugin_dl *plugin_dl,\n                                       st_maria_plugin *plug,\n                                       plugin_foreach_func *func, void *arg)\n{\n  for (; plug->name; plug++)\n  {\n    st_plugin_int tmp, *plugin;\n\n    tmp.name.str= const_cast<char*>(plug->name);\n    tmp.name.length= strlen(plug->name);\n    tmp.plugin= plug;\n    tmp.plugin_dl= plugin_dl;\n\n    mysql_mutex_lock(&LOCK_plugin);\n    if ((plugin= plugin_find_internal(&tmp.name, MYSQL_ANY_PLUGIN)) &&\n        plugin->plugin == plug)\n\n    {\n      tmp.state= plugin->state;\n      tmp.load_option= plugin->load_option;\n    }\n    else\n    {\n      tmp.state= PLUGIN_IS_FREED;\n      tmp.load_option= PLUGIN_OFF;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    plugin= &tmp;\n    if (func(thd, plugin_int_to_ref(plugin), arg))\n      return 1;\n  }\n  return 0;\n}\n\nbool plugin_dl_foreach(THD *thd, const LEX_STRING *dl,\n                       plugin_foreach_func *func, void *arg)\n{\n  bool err= 0;\n\n  if (dl)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n    st_plugin_dl *plugin_dl= plugin_dl_add(dl, REPORT_TO_USER);\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    if (!plugin_dl)\n      return 1;\n\n    err= plugin_dl_foreach_internal(thd, plugin_dl, plugin_dl->plugins,\n                                    func, arg);\n\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_dl_del(plugin_dl);\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  else\n  {\n    struct st_maria_plugin **builtins;\n    for (builtins= mysql_mandatory_plugins; !err && *builtins; builtins++)\n      err= plugin_dl_foreach_internal(thd, 0, *builtins, func, arg);\n    for (builtins= mysql_optional_plugins; !err && *builtins; builtins++)\n      err= plugin_dl_foreach_internal(thd, 0, *builtins, func, arg);\n  }\n  return err;\n}\n\n\n/****************************************************************************\n  Internal type declarations for variables support\n****************************************************************************/\n\n#undef MYSQL_SYSVAR_NAME\n#define MYSQL_SYSVAR_NAME(name) name\n#define PLUGIN_VAR_TYPEMASK 0x7f\n#define BOOKMARK_MEMALLOC   0x80\n\nstatic inline char plugin_var_bookmark_key(uint flags)\n{\n  return (flags & PLUGIN_VAR_TYPEMASK) |\n         (flags & PLUGIN_VAR_MEMALLOC ? BOOKMARK_MEMALLOC : 0);\n}\n\n#define EXTRA_OPTIONS 3 /* options for: 'foo', 'plugin-foo' and NULL */\n\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_str_t, char *);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_str_t, char *);\n\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_set_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_set_t, ulonglong);\n\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_int_t, int);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_long_t, long);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_uint_t, uint);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_double_t, double);\n\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_int_t, int);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_long_t, long);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_uint_t, uint);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_double_t, double);\n\n\n/****************************************************************************\n  default variable data check and update functions\n****************************************************************************/\n\nstatic int check_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int result, length;\n  long long tmp;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)) ||\n        (result= find_type(&bool_typelib, str, length, 1)-1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp) < 0)\n      goto err;\n    if (tmp != 0 && tmp != 1)\n      goto err;\n    result= (int) tmp;\n  }\n  *(my_bool *) save= result ? 1 : 0;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_int(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(uint *)save= (uint) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(int *)save= (int) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_long(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulong *)save= (ulong) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(long *)save= (long) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                               void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,\n                                               &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\nstatic int check_func_str(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int length;\n\n  length= sizeof(buff);\n  if ((str= value->val_str(value, buff, &length)))\n    str= thd->strmake(str, length);\n  *(const char**)save= str;\n  return 0;\n}\n\n\nstatic int check_func_enum(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  TYPELIB *typelib;\n  long long tmp;\n  long result;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_enum_t*) var)->typelib;\n  else\n    typelib= ((sysvar_enum_t*) var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    if ((result= (long)find_type(typelib, str, length, 0) - 1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp))\n      goto err;\n    if (tmp < 0 || tmp >= typelib->count)\n      goto err;\n    result= (long) tmp;\n  }\n  *(long*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_set(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE], *error= 0;\n  const char *str;\n  TYPELIB *typelib;\n  ulonglong result;\n  uint error_len= 0;                            // init as only set on error\n  bool not_used;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_set_t*) var)->typelib;\n  else\n    typelib= ((sysvar_set_t*)var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    result= find_set(typelib, str, length, NULL,\n                     &error, &error_len, &not_used);\n    if (error_len)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, (long long *)&result))\n      goto err;\n    if (unlikely((result >= (1ULL << typelib->count)) &&\n                 (typelib->count < sizeof(long)*8)))\n      goto err;\n  }\n  *(ulonglong*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\nstatic int check_func_double(THD *thd, struct st_mysql_sys_var *var,\n                             void *save, st_mysql_value *value)\n{\n  double v;\n  my_bool fixed;\n  struct my_option option;\n\n  value->val_real(value, &v);\n  plugin_opt_set_limits(&option, var);\n  *(double *) save= getopt_double_limit_value(v, &option, &fixed);\n\n  return throw_bounds_warning(thd, var->name, fixed, v);\n}\n\n\nstatic void update_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(my_bool *) tgt= *(my_bool *) save ? 1 : 0;\n}\n\n\nstatic void update_func_int(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(int *)tgt= *(int *) save;\n}\n\n\nstatic void update_func_long(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(long *)tgt= *(long *) save;\n}\n\n\nstatic void update_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(longlong *)tgt= *(ulonglong *) save;\n}\n\n\nstatic void update_func_str(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  char *value= *(char**) save;\n  if (var->flags & PLUGIN_VAR_MEMALLOC)\n  {\n    char *old= *(char**) tgt;\n    if (value)\n      *(char**) tgt= my_strdup(value, MYF(0));\n    else\n      *(char**) tgt= 0;\n    my_free(old);\n  }\n  else\n    *(char**) tgt= value;\n}\n\nstatic void update_func_double(THD *thd, struct st_mysql_sys_var *var,\n                               void *tgt, const void *save)\n{\n  *(double *) tgt= *(double *) save;\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length,\n                         bool throw_error, bool locked)\n{\n  sys_var *var;\n  sys_var_pluginvar *pi= NULL;\n  plugin_ref plugin;\n  DBUG_ENTER(\"find_sys_var_ex\");\n  DBUG_PRINT(\"enter\", (\"var '%.*s'\", (int)length, str));\n\n  if (!locked)\n    mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var= intern_find_sys_var(str, length)) &&\n      (pi= var->cast_pluginvar()))\n  {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex= thd ? thd->lex : 0;\n    if (!(plugin= intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var= NULL; /* failed to lock it, it must be uninstalling */\n    else\n    if (!(plugin_state(plugin) & PLUGIN_IS_READY))\n    {\n      /* initialization not completed */\n      var= NULL;\n      intern_plugin_unlock(lex, plugin);\n    }\n  }\n  else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!locked)\n    mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!throw_error && !var)\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), (int)length, (char*) str);\n  DBUG_RETURN(var);\n}\n\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length)\n{\n  return find_sys_var_ex(thd, str, length, false, false);\n}\n\n/*\n  called by register_var, construct_options and test_plugin_options.\n  Returns the 'bookmark' for the named variable.\n  LOCK_system_variables_hash should be at least read locked\n*/\nstatic st_bookmark *find_bookmark(const char *plugin, const char *name,\n                                  int flags)\n{\n  st_bookmark *result= NULL;\n  uint namelen, length, pluginlen= 0;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  namelen= strlen(name);\n  if (plugin)\n    pluginlen= strlen(plugin) + 1;\n  length= namelen + pluginlen + 2;\n  varname= (char*) my_alloca(length);\n\n  if (plugin)\n  {\n    strxmov(varname + 1, plugin, \"_\", name, NullS);\n    for (p= varname + 1; *p; p++)\n      if (*p == '-')\n        *p= '_';\n  }\n  else\n    memcpy(varname + 1, name, namelen + 1);\n\n  varname[0]= plugin_var_bookmark_key(flags);\n\n  result= (st_bookmark*) my_hash_search(&bookmark_hash,\n                                        (const uchar*) varname, length - 1);\n\n  my_afree(varname);\n  return result;\n}\n\n\nstatic size_t var_storage_size(int flags)\n{\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:         return sizeof(my_bool);\n  case PLUGIN_VAR_INT:          return sizeof(int);\n  case PLUGIN_VAR_LONG:         return sizeof(long);\n  case PLUGIN_VAR_ENUM:         return sizeof(long);\n  case PLUGIN_VAR_LONGLONG:     return sizeof(ulonglong);\n  case PLUGIN_VAR_SET:          return sizeof(ulonglong);\n  case PLUGIN_VAR_STR:          return sizeof(char*);\n  case PLUGIN_VAR_DOUBLE:       return sizeof(double);\n  default: DBUG_ASSERT(0);      return 0;\n  }\n}\n\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags)\n{\n  uint length= strlen(plugin) + strlen(name) + 3, size, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  DBUG_ASSERT(flags & PLUGIN_VAR_THDLOCAL);\n\n  size= var_storage_size(flags);\n  varname= ((char*) my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p= varname + 1; *p; p++)\n    if (*p == '-')\n      *p= '_';\n\n  if (!(result= find_bookmark(NULL, varname + 1, flags)))\n  {\n    result= (st_bookmark*) alloc_root(&plugin_vars_mem_root,\n                                      sizeof(struct st_bookmark) + length-1);\n    varname[0]= plugin_var_bookmark_key(flags);\n    memcpy(result->key, varname, length);\n    result->name_len= length - 2;\n    result->offset= -1;\n\n    DBUG_ASSERT(size && !(size & (size-1))); /* must be power of 2 */\n\n    offset= global_system_variables.dynamic_variables_size;\n    offset= (offset + size - 1) & ~(size - 1);\n    result->offset= (int) offset;\n\n    new_size= (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size)\n    {\n      global_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(global_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(max_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      bzero(global_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      bzero(max_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size= new_size;\n    }\n\n    global_system_variables.dynamic_variables_head= offset;\n    max_system_variables.dynamic_variables_head= offset;\n    global_system_variables.dynamic_variables_size= offset + size;\n    max_system_variables.dynamic_variables_size= offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version= global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    if (my_hash_insert(&bookmark_hash, (uchar*) result))\n    {\n      fprintf(stderr, \"failed to add placeholder to hash\");\n      DBUG_ASSERT(0);\n    }\n  }\n  my_afree(varname);\n  return result;\n}\n\n\nvoid sync_dynamic_session_variables(THD* thd, bool global_lock)\n{\n  uint idx;\n\n  thd->variables.dynamic_variables_ptr= (char*)\n    my_realloc(thd->variables.dynamic_variables_ptr,\n               global_variables_dynamic_size,\n               MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n  if (global_lock)\n    mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  memcpy(thd->variables.dynamic_variables_ptr +\n           thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_ptr +\n           thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_size -\n           thd->variables.dynamic_variables_size);\n\n  /*\n    now we need to iterate through any newly copied 'defaults'\n    and if it is a string type with MEMALLOC flag, we need to strdup\n  */\n  for (idx= 0; idx < bookmark_hash.records; idx++)\n  {\n    st_bookmark *v= (st_bookmark*) my_hash_element(&bookmark_hash,idx);\n\n    if (v->version <= thd->variables.dynamic_variables_version)\n      continue; /* already in thd->variables */\n\n    /* Here we do anything special that may be required of the data types */\n\n    if ((v->key[0] & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n         v->key[0] & BOOKMARK_MEMALLOC)\n    {\n      char **pp= (char**) (thd->variables.dynamic_variables_ptr + v->offset);\n      if (*pp)\n        *pp= my_strdup(*pp, MYF(MY_WME|MY_FAE));\n    }\n  }\n\n  if (global_lock)\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  thd->variables.dynamic_variables_version=\n         global_system_variables.dynamic_variables_version;\n  thd->variables.dynamic_variables_head=\n         global_system_variables.dynamic_variables_head;\n  thd->variables.dynamic_variables_size=\n         global_system_variables.dynamic_variables_size;\n}\n\n\n/*\n  returns a pointer to the memory which holds the thd-local variable or\n  a pointer to the global variable if thd==null.\n  If required, will sync with global variables if the requested variable\n  has not yet been allocated in the current thread.\n*/\nstatic uchar *intern_sys_var_ptr(THD* thd, int offset, bool global_lock)\n{\n  DBUG_ENTER(\"intern_sys_var_ptr\");\n  DBUG_ASSERT(offset >= 0);\n  DBUG_ASSERT((uint)offset <= global_system_variables.dynamic_variables_head);\n\n  if (!thd)\n    DBUG_RETURN((uchar*) global_system_variables.dynamic_variables_ptr + offset);\n\n  /*\n    dynamic_variables_head points to the largest valid offset\n  */\n  if (!thd->variables.dynamic_variables_ptr ||\n      (uint)offset > thd->variables.dynamic_variables_head)\n  {\n    mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n    sync_dynamic_session_variables(thd, global_lock);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  }\n  DBUG_RETURN((uchar*)thd->variables.dynamic_variables_ptr + offset);\n}\n\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic char *mysql_sys_var_char(THD* thd, int offset)\n{\n  return (char *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD* thd, int offset)\n{\n  return (int *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long *mysql_sys_var_long(THD* thd, int offset)\n{\n  return (long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD* thd, int offset)\n{\n  return (unsigned long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long long *mysql_sys_var_longlong(THD* thd, int offset)\n{\n  return (long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD* thd, int offset)\n{\n  return (unsigned long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD* thd, int offset)\n{\n  return (char **) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD* thd, int offset)\n{\n  return (double *) intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd)\n{\n  plugin_ref old_table_plugin= thd->variables.table_plugin;\n  plugin_ref old_tmp_table_plugin= thd->variables.tmp_table_plugin;\n  plugin_ref old_enforced_table_plugin= thd->variables.enforced_table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n\n  // This function may be called many times per THD (e.g. on COM_CHANGE_USER)\n  thd->variables.table_plugin= NULL;\n  thd->variables.tmp_table_plugin= NULL;\n  thd->variables.enforced_table_plugin= NULL;\n  cleanup_variables(&thd->variables);\n\n  thd->variables= global_system_variables;\n\n  /* we are going to allocate these lazily */\n  thd->variables.dynamic_variables_version= 0;\n  thd->variables.dynamic_variables_size= 0;\n  thd->variables.dynamic_variables_ptr= 0;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  thd->variables.table_plugin=\n      intern_plugin_lock(NULL, global_system_variables.table_plugin);\n  if (global_system_variables.tmp_table_plugin)\n    thd->variables.tmp_table_plugin=\n          intern_plugin_lock(NULL, global_system_variables.tmp_table_plugin);\n  if (global_system_variables.enforced_table_plugin)\n    thd->variables.enforced_table_plugin=\n          intern_plugin_lock(NULL, global_system_variables.enforced_table_plugin);\n  intern_plugin_unlock(NULL, old_table_plugin);\n  intern_plugin_unlock(NULL, old_tmp_table_plugin);\n  intern_plugin_unlock(NULL, old_enforced_table_plugin);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(THD *thd, struct system_variables *vars)\n{\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  intern_plugin_unlock(NULL, vars->tmp_table_plugin);\n  intern_plugin_unlock(NULL, vars->enforced_table_plugin);\n  vars->table_plugin= vars->tmp_table_plugin= vars->enforced_table_plugin= NULL;\n}\n\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(struct system_variables *vars)\n{\n  st_bookmark *v;\n  uint idx;\n\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  for (idx= 0; idx < bookmark_hash.records; idx++)\n  {\n    v= (st_bookmark*) my_hash_element(&bookmark_hash, idx);\n\n    if (v->version > vars->dynamic_variables_version)\n      continue; /* not in vars */\n\n    DBUG_ASSERT((uint)v->offset <= vars->dynamic_variables_head);\n\n    /* free allocated strings (PLUGIN_VAR_STR | PLUGIN_VAR_MEMALLOC) */\n    if ((v->key[0] & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n         v->key[0] & BOOKMARK_MEMALLOC)\n    {\n      char **ptr= (char**)(vars->dynamic_variables_ptr + v->offset);\n      my_free(*ptr);\n      *ptr= NULL;\n    }\n  }\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n\n  DBUG_ASSERT(vars->table_plugin == NULL);\n  DBUG_ASSERT(vars->tmp_table_plugin == NULL);\n  DBUG_ASSERT(vars->enforced_table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr= NULL;\n  vars->dynamic_variables_size= 0;\n  vars->dynamic_variables_version= 0;\n}\n\n\nvoid plugin_thdvar_cleanup(THD *thd)\n{\n  uint idx;\n  plugin_ref *list;\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  unlock_variables(thd, &thd->variables);\n  cleanup_variables(&thd->variables);\n\n  if ((idx= thd->lex->plugins.elements))\n  {\n    list= ((plugin_ref*) thd->lex->plugins.buffer) + idx - 1;\n    DBUG_PRINT(\"info\",(\"unlocking %d plugins\", idx));\n    while ((uchar*) list >= thd->lex->plugins.buffer)\n      intern_plugin_unlock(NULL, *list--);\n  }\n\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  reset_dynamic(&thd->lex->plugins);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars)\n{\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var= vars; var; var= var->next)\n  {\n    sys_var_pluginvar *piv= var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC))\n    {\n      /* Free the string from global_system_variables. */\n      char **valptr= (char**) piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\", (\"freeing value for: '%s'  addr: 0x%lx\",\n                            var->name.str, (long) valptr));\n      my_free(*valptr);\n      *valptr= NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic SHOW_TYPE pluginvar_show_type(const st_mysql_sys_var *plugin_var)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_UNSIGNED)) {\n  case PLUGIN_VAR_BOOL:\n    return SHOW_MY_BOOL;\n  case PLUGIN_VAR_INT:\n    return SHOW_SINT;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    return SHOW_UINT;\n  case PLUGIN_VAR_LONG:\n    return SHOW_SLONG;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    return SHOW_ULONG;\n  case PLUGIN_VAR_LONGLONG:\n    return SHOW_SLONGLONG;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    return SHOW_ULONGLONG;\n  case PLUGIN_VAR_STR:\n    return SHOW_CHAR_PTR;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_SET:\n    return SHOW_CHAR;\n  case PLUGIN_VAR_DOUBLE:\n    return SHOW_DOUBLE;\n  default:\n    DBUG_ASSERT(0);\n    return SHOW_UNDEF;\n  }\n}\n\n\nstatic int pluginvar_sysvar_flags(const st_mysql_sys_var *p)\n{\n  return (p->flags & PLUGIN_VAR_THDLOCAL ? sys_var::SESSION : sys_var::GLOBAL)\n       | (p->flags & PLUGIN_VAR_READONLY ? sys_var::READONLY : 0);\n}\n\nsys_var_pluginvar::sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n        st_plugin_int *p, st_mysql_sys_var *pv)\n    : sys_var(chain, name_arg, pv->comment, pluginvar_sysvar_flags(pv),\n              0, pv->flags & PLUGIN_VAR_NOCMDOPT ? -1 : 0, NO_ARG,\n              pluginvar_show_type(pv), 0,\n              NULL, VARIABLE_NOT_IN_BINLOG, NULL, NULL, NULL),\n    plugin(p), plugin_var(pv)\n{\n  plugin_var->name= name_arg;\n  plugin_opt_set_limits(&option, pv);\n}\n\nuchar* sys_var_pluginvar::real_value_ptr(THD *thd, enum_var_type type)\n{\n  if (type == OPT_DEFAULT)\n  {\n    switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      thd->sys_var_tmp.my_bool_value= option.def_value;\n      return (uchar*) &thd->sys_var_tmp.my_bool_value;\n    case PLUGIN_VAR_INT:\n      thd->sys_var_tmp.int_value= option.def_value;\n      return (uchar*) &thd->sys_var_tmp.int_value;\n    case PLUGIN_VAR_LONG:\n    case PLUGIN_VAR_ENUM:\n      thd->sys_var_tmp.long_value= option.def_value;\n      return (uchar*) &thd->sys_var_tmp.long_value;\n    case PLUGIN_VAR_LONGLONG:\n    case PLUGIN_VAR_SET:\n      return (uchar*) &option.def_value;\n    case PLUGIN_VAR_STR:\n      thd->sys_var_tmp.ptr_value= (void*) option.def_value;\n      return (uchar*) &thd->sys_var_tmp.ptr_value;\n    case PLUGIN_VAR_DOUBLE:\n      thd->sys_var_tmp.double_value= getopt_ulonglong2double(option.def_value);\n      return (uchar*) &thd->sys_var_tmp.double_value;\n    default:\n      DBUG_ASSERT(0);\n    }\n  }\n\n  DBUG_ASSERT(thd || (type == OPT_GLOBAL));\n  if (plugin_var->flags & PLUGIN_VAR_THDLOCAL)\n  {\n    if (type == OPT_GLOBAL)\n      thd= NULL;\n\n    return intern_sys_var_ptr(thd, *(int*) (plugin_var+1), false);\n  }\n  return *(uchar**) (plugin_var+1);\n}\n\n\nbool sys_var_pluginvar::session_is_default(THD *thd)\n{\n  uchar *value= plugin_var->flags & PLUGIN_VAR_THDLOCAL\n                ? intern_sys_var_ptr(thd, *(int*) (plugin_var+1), true)\n                : *(uchar**) (plugin_var+1);\n\n    real_value_ptr(thd, OPT_SESSION);\n\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    return option.def_value == *(my_bool*)value;\n  case PLUGIN_VAR_INT:\n    return option.def_value == *(int*)value;\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_ENUM:\n    return option.def_value == *(long*)value;\n  case PLUGIN_VAR_LONGLONG:\n  case PLUGIN_VAR_SET:\n    return option.def_value == *(longlong*)value;\n  case PLUGIN_VAR_STR:\n    {\n      const char *a=(char*)option.def_value;\n      const char *b=(char*)value;\n      return (!a && !b) || (a && b && strcmp(a,b));\n    }\n  case PLUGIN_VAR_DOUBLE:\n    return getopt_ulonglong2double(option.def_value) == *(double*)value;\n  }\n  DBUG_ASSERT(0);\n  return 0;\n}\n\n\nTYPELIB* sys_var_pluginvar::plugin_var_typelib(void)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n  case PLUGIN_VAR_ENUM:\n    return ((sysvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET:\n    return ((sysvar_set_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_set_t *)plugin_var)->typelib;\n  default:\n    return NULL;\n  }\n  return NULL;\t/* Keep compiler happy */\n}\n\n\nuchar* sys_var_pluginvar::do_value_ptr(THD *thd, enum_var_type type,\n                                       const LEX_STRING *base)\n{\n  uchar* result;\n\n  result= real_value_ptr(thd, type);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_ENUM)\n    result= (uchar*) get_type(plugin_var_typelib(), *(ulong*)result);\n  else if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_SET)\n    result= (uchar*) set_to_string(thd, 0, *(ulonglong*) result,\n                                   plugin_var_typelib()->type_names);\n  return result;\n}\n\nbool sys_var_pluginvar::do_check(THD *thd, set_var *var)\n{\n  st_item_value_holder value;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->check);\n\n  value.value_type= item_value_type;\n  value.val_str= item_val_str;\n  value.val_int= item_val_int;\n  value.val_real= item_val_real;\n  value.is_unsigned= item_is_unsigned;\n  value.item= var->value;\n\n  return plugin_var->check(thd, plugin_var, &var->save_result, &value);\n}\n\nbool sys_var_pluginvar::session_update(THD *thd, set_var *var)\n{\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->flags & PLUGIN_VAR_THDLOCAL);\n  DBUG_ASSERT(thd == current_thd);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  void *tgt= real_value_ptr(thd, OPT_SESSION);\n  const void *src= var->value ? (void*)&var->save_result\n                              : (void*)real_value_ptr(thd, OPT_GLOBAL);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  plugin_var->update(thd, plugin_var, tgt, src);\n\n  return false;\n}\n\nstatic const void *var_def_ptr(st_mysql_sys_var *pv)\n{\n    switch (pv->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n    case PLUGIN_VAR_INT:\n      return &((sysvar_uint_t*) pv)->def_val;\n    case PLUGIN_VAR_LONG:\n      return &((sysvar_ulong_t*) pv)->def_val;\n    case PLUGIN_VAR_LONGLONG:\n      return &((sysvar_ulonglong_t*) pv)->def_val;\n    case PLUGIN_VAR_ENUM:\n      return &((sysvar_enum_t*) pv)->def_val;\n    case PLUGIN_VAR_SET:\n      return &((sysvar_set_t*) pv)->def_val;\n    case PLUGIN_VAR_BOOL:\n      return &((sysvar_bool_t*) pv)->def_val;\n    case PLUGIN_VAR_STR:\n      return &((sysvar_str_t*) pv)->def_val;\n    case PLUGIN_VAR_DOUBLE:\n      return &((sysvar_double_t*) pv)->def_val;\n    case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_uint_t*) pv)->def_val;\n    case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_ulong_t*) pv)->def_val;\n    case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_ulonglong_t*) pv)->def_val;\n    case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_enum_t*) pv)->def_val;\n    case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_set_t*) pv)->def_val;\n    case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_bool_t*) pv)->def_val;\n    case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_str_t*) pv)->def_val;\n    case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_double_t*) pv)->def_val;\n    default:\n      DBUG_ASSERT(0);\n      return NULL;\n    }\n}\n\n\nbool sys_var_pluginvar::global_update(THD *thd, set_var *var)\n{\n  DBUG_ASSERT(!is_readonly());\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  void *tgt= real_value_ptr(thd, OPT_GLOBAL);\n  const void *src= &var->save_result;\n\n  if (!var->value)\n    src= var_def_ptr(plugin_var);\n\n  plugin_var->update(thd, plugin_var, tgt, src);\n  return false;\n}\n\n\n#define OPTION_SET_LIMITS(type, options, opt) \\\n  options->var_type= type; \\\n  options->def_value= (opt)->def_val; \\\n  options->min_value= (opt)->min_val; \\\n  options->max_value= (opt)->max_val; \\\n  options->block_size= (long) (opt)->blk_sz\n\n#define OPTION_SET_LIMITS_DOUBLE(options, opt) \\\n  options->var_type= GET_DOUBLE; \\\n  options->def_value= (longlong) getopt_double2ulonglong((opt)->def_val); \\\n  options->min_value= (longlong) getopt_double2ulonglong((opt)->min_val); \\\n  options->max_value= getopt_double2ulonglong((opt)->max_val); \\\n  options->block_size= (long) (opt)->blk_sz;\n\n\nvoid plugin_opt_set_limits(struct my_option *options,\n                           const struct st_mysql_sys_var *opt)\n{\n  options->sub_size= 0;\n\n  switch (opt->flags & (PLUGIN_VAR_TYPEMASK |\n                        PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL)) {\n  /* global system variables */\n  case PLUGIN_VAR_INT:\n    OPTION_SET_LIMITS(GET_INT, options, (sysvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_UINT, options, (sysvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG:\n    OPTION_SET_LIMITS(GET_LONG, options, (sysvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULONG, options, (sysvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n    OPTION_SET_LIMITS(GET_LL, options, (sysvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULL, options, (sysvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM:\n    options->var_type= GET_ENUM;\n    options->typelib= ((sysvar_enum_t*) opt)->typelib;\n    options->def_value= ((sysvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET:\n    options->var_type= GET_SET;\n    options->typelib= ((sysvar_set_t*) opt)->typelib;\n    options->def_value= ((sysvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((sysvar_bool_t*) opt)->def_val;\n    options->typelib= &bool_typelib;\n    break;\n  case PLUGIN_VAR_STR:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((sysvar_str_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    OPTION_SET_LIMITS_DOUBLE(options, (sysvar_double_t*) opt);\n    break;\n  /* threadlocal variables */\n  case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_INT, options, (thdvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_UINT, options, (thdvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LONG, options, (thdvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULONG, options, (thdvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LL, options, (thdvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULL, options, (thdvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS_DOUBLE(options, (thdvar_double_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_ENUM;\n    options->typelib= ((thdvar_enum_t*) opt)->typelib;\n    options->def_value= ((thdvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_SET;\n    options->typelib= ((thdvar_set_t*) opt)->typelib;\n    options->def_value= ((thdvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((thdvar_bool_t*) opt)->def_val;\n    options->typelib= &bool_typelib;\n    break;\n  case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((thdvar_str_t*) opt)->def_val;\n    break;\n  default:\n    DBUG_ASSERT(0);\n  }\n  options->arg_type= REQUIRED_ARG;\n  if (opt->flags & PLUGIN_VAR_NOCMDARG)\n    options->arg_type= NO_ARG;\n  if (opt->flags & PLUGIN_VAR_OPCMDARG)\n    options->arg_type= OPT_ARG;\n}\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, struct st_plugin_int *tmp,\n                             my_option *options)\n{\n  const char *plugin_name= tmp->plugin->name;\n  const LEX_STRING plugin_dash = { C_STRING_WITH_LEN(\"plugin-\") };\n  uint plugin_name_len= strlen(plugin_name);\n  uint optnamelen;\n  const int max_comment_len= 180;\n  char *comment= (char *) alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index= 0, UNINIT_VAR(offset);\n  st_mysql_sys_var *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr= (char*) alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr= (char*) alloc_root(mem_root,\n                                                  plugin_name_len +\n                                                  plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (!plugin_is_forced(tmp))\n  {\n    /* support --skip-plugin-foo syntax */\n    options[0].name= plugin_name_ptr;\n    options[1].name= plugin_name_with_prefix_ptr;\n    options[0].id= options[1].id= 0;\n    options[0].var_type= options[1].var_type= GET_ENUM;\n    options[0].arg_type= options[1].arg_type= OPT_ARG;\n    options[0].def_value= options[1].def_value= 1; /* ON */\n    options[0].typelib= options[1].typelib= &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n            \" plugin. One of: ON, OFF, FORCE (don't start \"\n            \"if the plugin fails to load).\", NullS);\n    options[0].comment= comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value= options[1].value=\n                      (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong*) options[0].value)= (ulong) options[0].def_value;\n\n    options+= 2;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    opt= *plugin_option;\n\n    if (!opt->name)\n    {\n      sql_print_error(\"Missing variable name in plugin '%s'.\",\n                      plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n      continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags)))\n      continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      ((thdvar_bool_t *) opt)->resolve= mysql_sys_var_char;\n      break;\n    case PLUGIN_VAR_INT:\n      ((thdvar_int_t *) opt)->resolve= mysql_sys_var_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      ((thdvar_long_t *) opt)->resolve= mysql_sys_var_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      ((thdvar_longlong_t *) opt)->resolve= mysql_sys_var_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      ((thdvar_str_t *) opt)->resolve= mysql_sys_var_str;\n      break;\n    case PLUGIN_VAR_ENUM:\n      ((thdvar_enum_t *) opt)->resolve= mysql_sys_var_ulong;\n      break;\n    case PLUGIN_VAR_SET:\n      ((thdvar_set_t *) opt)->resolve= mysql_sys_var_ulonglong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      ((thdvar_double_t *) opt)->resolve= mysql_sys_var_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    switch ((opt= *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      if (!opt->check)\n        opt->check= check_func_bool;\n      if (!opt->update)\n        opt->update= update_func_bool;\n      break;\n    case PLUGIN_VAR_INT:\n      if (!opt->check)\n        opt->check= check_func_int;\n      if (!opt->update)\n        opt->update= update_func_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      if (!opt->check)\n        opt->check= check_func_long;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      if (!opt->check)\n        opt->check= check_func_longlong;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      if (!opt->check)\n        opt->check= check_func_str;\n      if (!opt->update)\n      {\n        opt->update= update_func_str;\n        if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY)))\n        {\n          opt->flags|= PLUGIN_VAR_READONLY;\n          sql_print_warning(\"Server variable %s of plugin %s was forced \"\n                            \"to be read-only: string variable without \"\n                            \"update_func and PLUGIN_VAR_MEMALLOC flag\",\n                            opt->name, plugin_name);\n        }\n      }\n      break;\n    case PLUGIN_VAR_ENUM:\n      if (!opt->check)\n        opt->check= check_func_enum;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_SET:\n      if (!opt->check)\n        opt->check= check_func_set;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      if (!opt->check)\n        opt->check= check_func_double;\n      if (!opt->update)\n        opt->update= update_func_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL))\n                    == PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n    {\n      optnamelen= strlen(opt->name);\n      optname= (char*) alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen= plugin_name_len + optnamelen + 1;\n    }\n    else\n    {\n      /* this should not fail because register_var should create entry */\n      if (!(v= find_bookmark(plugin_name_ptr, opt->name, opt->flags)))\n      {\n        sql_print_error(\"Thread local variable '%s' not allocated \"\n                        \"in plugin '%s'.\", opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int*)(opt + 1)= offset= v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT)\n      {\n        char *val= global_system_variables.dynamic_variables_ptr + offset;\n        if (((opt->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n             (opt->flags & PLUGIN_VAR_MEMALLOC))\n        {\n          char *def_val= *(char**)var_def_ptr(opt);\n          *(char**)val= def_val ? my_strdup(def_val, MYF(0)) : NULL;\n        }\n        else\n          memcpy(val, var_def_ptr(opt), var_storage_size(opt->flags));\n        continue;\n      }\n\n      optname= (char*) memdup_root(mem_root, v->key + 1,\n                                   (optnamelen= v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name= optname;\n    options->comment= opt->comment;\n    options->app_type= (opt->flags & PLUGIN_VAR_NOSYSVAR) ? NULL : opt;\n    options->id= 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value= options->u_max_value= (uchar**)\n        (global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value= options->u_max_value= *(uchar***) (opt + 1);\n\n    char *option_name_ptr;\n    options[1]= options[0];\n    options[1].name= option_name_ptr= (char*) alloc_root(mem_root,\n                                                        plugin_dash.length +\n                                                        optnamelen + 1);\n    options[1].comment= 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options+= 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root,\n                                         struct st_plugin_int *p)\n{\n  st_mysql_sys_var **opt;\n  my_option *opts;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt= p->plugin->system_vars; opt && *opt; opt++, count+= 2)\n    ;\n\n  if (!(opts= (my_option*) alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  bzero(opts, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_NOSYSVAR flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_ptr_backup(p->nbackups, p->ptr_backup);\n\n  if (construct_options(mem_root, p, opts))\n    DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\nextern \"C\" my_bool mark_changed(int, const struct my_option *, char *);\nmy_bool mark_changed(int, const struct my_option *opt, char *)\n{\n  if (opt->app_type)\n  {\n    sys_var *var= (sys_var*) opt->app_type;\n    var->value_origin= sys_var::CONFIG;\n  }\n  return 0;\n}\n\n/**\n  It is always false to mark global plugin variable unloaded just to be\n  safe because we have no way now to know truth about them.\n\n  TODO: make correct mechanism for global plugin variables\n*/\nstatic bool static_unload= FALSE;\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] plugin Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, struct st_plugin_int *tmp,\n                               int *argc, char **argv)\n{\n  struct sys_var_chain chain= { NULL, NULL };\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option= tmp->load_option;\n\n  MEM_ROOT *mem_root= alloc_root_inited(&tmp->mem_root) ?\n                      &tmp->mem_root : &plugin_vars_mem_root;\n  st_mysql_sys_var **opt;\n  my_option *opts= NULL;\n  int error= 1;\n  struct st_bookmark *var;\n  uint len=0, count= EXTRA_OPTIONS;\n  st_ptr_backup *tmp_backup= 0;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  if (tmp->plugin->system_vars || (*argc > 1))\n  {\n    for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n    {\n      len++;\n      if (!((*opt)->flags & PLUGIN_VAR_NOCMDOPT))\n        count+= 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n    }\n\n    if (!(opts= (my_option*) alloc_root(tmp_root, sizeof(my_option) * count)))\n    {\n      sql_print_error(\"Out of memory for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    bzero(opts, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts))\n    {\n      sql_print_error(\"Bad options for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    if (tmp->plugin->system_vars)\n    {\n      tmp_backup= (st_ptr_backup *)my_alloca(len * sizeof(tmp_backup[0]));\n      DBUG_ASSERT(tmp->nbackups == 0);\n      DBUG_ASSERT(tmp->ptr_backup == 0);\n\n      for (opt= tmp->plugin->system_vars; *opt; opt++)\n      {\n        st_mysql_sys_var *o= *opt;\n        char *varname;\n        sys_var *v;\n\n        if (o->flags & PLUGIN_VAR_NOSYSVAR)\n          continue;\n\n        tmp_backup[tmp->nbackups++].save(&o->name);\n        if ((var= find_bookmark(tmp->name.str, o->name, o->flags)))\n        {\n          varname= var->key + 1;\n          var->loaded= TRUE;\n        }\n        else\n        {\n          var= NULL;\n          len= tmp->name.length + strlen(o->name) + 2;\n          varname= (char*) alloc_root(mem_root, len);\n          strxmov(varname, tmp->name.str, \"-\", o->name, NullS);\n          my_casedn_str(&my_charset_latin1, varname);\n          convert_dash_to_underscore(varname, len-1);\n        }\n        v= new (mem_root) sys_var_pluginvar(&chain, varname, tmp, o);\n        v->test_load= (var ? &var->loaded : &static_unload);\n        DBUG_ASSERT(static_unload == FALSE);\n\n        if (!(o->flags & PLUGIN_VAR_NOCMDOPT))\n        {\n          // update app_type, used for I_S.SYSTEM_VARIABLES\n          for (my_option *mo=opts; mo->name; mo++)\n            if (mo->app_type == o)\n              mo->app_type= v;\n        }\n      }\n\n      if (tmp->nbackups)\n      {\n        size_t bytes= tmp->nbackups * sizeof(tmp->ptr_backup[0]);\n        tmp->ptr_backup= (st_ptr_backup *)alloc_root(mem_root, bytes);\n        if (!tmp->ptr_backup)\n        {\n          restore_ptr_backup(tmp->nbackups, tmp_backup);\n          my_afree(tmp_backup);\n          goto err;\n        }\n        memcpy(tmp->ptr_backup, tmp_backup, bytes);\n      }\n      my_afree(tmp_backup);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (!plugin_is_forced(tmp))\n      opts[0].def_value= opts[1].def_value= plugin_load_option;\n\n    error= handle_options(argc, &argv, opts, mark_changed);\n    (*argc)++; /* add back one for the program name */\n\n    if (error)\n    {\n       sql_print_error(\"Parsing options for plugin '%s' failed.\",\n                       tmp->name.str);\n       goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (!plugin_is_forced(tmp))\n      plugin_load_option= (enum_plugin_load_option) *(ulong*) opts[0].value;\n  }\n\n  disable_plugin= (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option= plugin_load_option;\n\n  error= 1;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin)\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_information(\"Plugin '%s' is disabled.\",\n                            tmp->name.str);\n    goto err;\n  }\n\n  if (tmp->plugin->system_vars)\n  {\n    for (opt= tmp->plugin->system_vars; *opt; opt++)\n    {\n      /*\n        PLUGIN_VAR_STR command-line options without PLUGIN_VAR_MEMALLOC, point\n        directly to values in the argv[] array. For plugins started at the\n        server startup, argv[] array is allocated with load_defaults(), and\n        freed when the server is shut down.  But for plugins loaded with\n        INSTALL PLUGIN, the memory allocated with load_defaults() is freed with\n        free() at the end of mysql_install_plugin(). Which means we cannot\n        allow any pointers into that area.\n        Thus, for all plugins loaded after the server was started,\n        we copy string values to a plugin's memroot.\n      */\n      if (mysqld_server_started &&\n          (((*opt)->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_NOCMDOPT |\n                             PLUGIN_VAR_MEMALLOC)) == PLUGIN_VAR_STR))\n      {\n        sysvar_str_t* str= (sysvar_str_t *)*opt;\n        if (*str->value)\n          *str->value= strdup_root(mem_root, *str->value);\n      }\n    }\n\n    if (chain.first)\n    {\n      chain.last->next = NULL;\n      if (mysql_add_sys_var_chain(chain.first))\n      {\n        sql_print_error(\"Plugin '%s' has conflicting system variables\",\n                        tmp->name.str);\n        goto err;\n      }\n      tmp->system_vars= chain.first;\n    }\n  }\n\n  DBUG_RETURN(0);\n\nerr:\n  if (opts)\n    my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\n\nvoid add_plugin_options(DYNAMIC_ARRAY *options, MEM_ROOT *mem_root)\n{\n  struct st_plugin_int *p;\n  my_option *opt;\n\n  if (!initialized)\n    return;\n\n  for (uint idx= 0; idx < plugin_array.elements; idx++)\n  {\n    p= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n\n    if (!(opt= construct_help_options(mem_root, p)))\n      continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (;opt->name; opt++)\n      if (opt->comment)\n        insert_dynamic(options, (uchar*) opt);\n  }\n}\n\n\n/**\n  Returns a sys_var corresponding to a particular MYSQL_SYSVAR(...)\n*/\nsys_var *find_plugin_sysvar(st_plugin_int *plugin, st_mysql_sys_var *plugin_var)\n{\n  for (sys_var *var= plugin->system_vars; var; var= var->next)\n  {\n    sys_var_pluginvar *pvar=var->cast_pluginvar();\n    if (pvar->plugin_var == plugin_var)\n      return var;\n  }\n  return 0;\n}\n\n/*\n  On dlclose() we need to restore values of all symbols that we've modified in\n  the DSO. The reason is - the DSO might not actually be unloaded, so on the\n  next dlopen() these symbols will have old values, they won't be\n  reinitialized.\n\n  Perhaps, there can be many reason, why a DSO won't be unloaded. Strictly\n  speaking, it's implementation defined whether to unload an unused DSO or to\n  keep it in memory.\n\n  In particular, this happens for some plugins: In 2009 a new ELF stub was\n  introduced, see Ulrich Drepper's email \"Unique symbols for C++\"\n  http://www.redhat.com/archives/posix-c++-wg/2009-August/msg00002.html\n\n  DSO that has objects with this stub (STB_GNU_UNIQUE) cannot be unloaded\n  (this is mentioned in the email, see the url above).\n\n  These \"unique\" objects are, for example, static variables in templates,\n  in inline functions, in classes. So any DSO that uses them can\n  only be loaded once. And because Boost has them, any DSO that uses Boost\n  almost certainly cannot be unloaded.\n\n  To know whether a particular DSO has these objects, one can use\n\n    readelf -s /path/to/plugin.so|grep UNIQUE\n\n  There's nothing we can do about it, but to reset the DSO to its initial\n  state before dlclose().\n*/\nstatic void restore_ptr_backup(uint n, st_ptr_backup *backup)\n{\n  while (n--)\n    (backup++)->restore();\n}\n\n/****************************************************************************\n  thd specifics service, see include/mysql/service_thd_specifics.h\n****************************************************************************/\nstatic const int INVALID_THD_KEY= -1;\nstatic uint thd_key_no = 42;\n\nint thd_key_create(MYSQL_THD_KEY_T *key)\n{\n  int flags= PLUGIN_VAR_THDLOCAL | PLUGIN_VAR_STR |\n             PLUGIN_VAR_NOSYSVAR | PLUGIN_VAR_NOCMDOPT;\n  char namebuf[256];\n  snprintf(namebuf, sizeof(namebuf), \"%u\", thd_key_no++);\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  // non-letters in the name as an extra safety\n  st_bookmark *bookmark= register_var(\"\\a\\v\\a\\t\\a\\r\", namebuf, flags);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (bookmark)\n  {\n    *key= bookmark->offset;\n    return 0;\n  }\n  return ENOMEM;\n}\n\nvoid thd_key_delete(MYSQL_THD_KEY_T *key)\n{\n  *key= INVALID_THD_KEY;\n}\n\nvoid* thd_getspecific(MYSQL_THD thd, MYSQL_THD_KEY_T key)\n{\n  DBUG_ASSERT(key != INVALID_THD_KEY);\n  if (key == INVALID_THD_KEY || (!thd && !(thd= current_thd)))\n    return 0;\n\n  return *(void**)(intern_sys_var_ptr(thd, key, true));\n}\n\nint thd_setspecific(MYSQL_THD thd, MYSQL_THD_KEY_T key, void *value)\n{\n  DBUG_ASSERT(key != INVALID_THD_KEY);\n  if (key == INVALID_THD_KEY || (!thd && !(thd= current_thd)))\n    return EINVAL;\n  \n  memcpy(intern_sys_var_ptr(thd, key, true), &value, sizeof(void*));\n  return 0;\n}\n\nvoid plugin_mutex_init()\n{\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n}\n\n#ifdef WITH_WSREP\n\n/*\n  Placeholder for global_system_variables.table_plugin required during\n  initialization of startup wsrep threads.\n*/\nstatic st_plugin_int wsrep_dummy_plugin;\nstatic st_plugin_int *wsrep_dummy_plugin_ptr;\n\n/*\n  Initialize wsrep_dummy_plugin and assign it to\n  global_system_variables.table_plugin.\n*/\nvoid wsrep_plugins_pre_init()\n{\n  wsrep_dummy_plugin_ptr= &wsrep_dummy_plugin;\n  wsrep_dummy_plugin.state= PLUGIN_IS_DISABLED;\n  global_system_variables.table_plugin=\n    plugin_int_to_ref(wsrep_dummy_plugin_ptr);\n}\n\n/*\n  This function is intended to be called after the plugins and related\n  global system variables are initialized. It re-initializes some data\n  members of wsrep startup threads with correct values, as these value\n  were not available at the time these threads were created.\n*/\nvoid wsrep_plugins_post_init()\n{\n  THD *thd;\n  I_List_iterator<THD> it(threads);\n\n  while ((thd= it++))\n  {\n    if (IF_WSREP(thd->wsrep_applier,1))\n    {\n      // Save options_bits as it will get overwritten in plugin_thdvar_init()\n      ulonglong option_bits_saved= thd->variables.option_bits;\n\n      plugin_thdvar_init(thd);\n\n      // Restore option_bits\n      thd->variables.option_bits= option_bits_saved;\n    }\n  }\n\n  return;\n}\n#endif /* WITH_WSREP */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/WINDOWS_PORT.md",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/og_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-filelayout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-blockindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-readiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/Resize-of-20140327_200754-300x225.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-writeiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-fileindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-tieredstorage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/images/tree_example1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Black.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-BlackItalic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Light.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-BlackItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Light.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Black.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/alter_table_enable_keys_fulltext_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/function_snippet_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/function_snippet_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/fulltext_charset_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/alter_table_disable_keys_fulltext_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/fulltext_charset_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/alter_table_enable_keys_fulltext_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/alter_table_disable_keys_fulltext_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/fulltext_charset_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/function_snippet_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/function_snippet_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/fulltext_charset_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/fulltext_charset_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/fulltext_charset_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/fulltext_charset_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/fulltext_charset_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/benchmark/fixtures/geo-select/format_2010.html",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/benchmark/fixtures/geo-select/13_2010.CSV.xz",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_cd0a0a_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_2e83ff_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_55_fbf9ee_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_95_fef1ec_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_888888_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_highlight-soft_75_cccccc_1x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_75_dadada_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_flat_0_aaaaaa_40x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_flat_75_ffffff_40x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_222222_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_65_ffffff_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_454545_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_75_e6e6e6_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/xtradb/include/ut0mem.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/frmsg2.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/domdoc.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/JavaWrappers.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/frmsg1.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/frids.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/frcas.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/frmsg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/cp1251.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/biblio.json",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/Mongo3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/mdev9949.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/bib0.json",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/contacts.xls",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/JdbcMariaDB.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/test.sqlite3",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/Testbal.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/Mongo2.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/latin1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/std_data/nocs.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/r/xml_zip.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/r/json.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/connect/mysql-test/connect/r/xml2_zip.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/maria/ma_page.c",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-28-clean/log000000000000.tokulog28",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-25-dirty/log000000000000.tokulog25",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-24-clean/log000000000000.tokulog24",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-26-clean/log000000000000.tokulog26",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-28-dirty/log000000000000.tokulog28",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-25-clean/log000000000000.tokulog25",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-26-dirty/log000000000000.tokulog26",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-29-clean/log000000000000.tokulog29",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-27-dirty/log000000000000.tokulog27",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-27-clean/log000000000000.tokulog27",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-29-dirty/log000000000000.tokulog29",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-24-dirty/log000000000000.tokulog24",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb_bugs/std_data/leak172_t2.data",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/storage/tokudb/mysql-test/tokudb/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-bench/server-cfg.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-bench/crash-me.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-bench/limits/mysql-4.0.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-bench/limits/mysql-4.1.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql-bench/Comments/postgres.benchmark",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/strings/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/strings/ctype-latin1.c",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/strings/ctype-czech.c",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/tests/fork2_test.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/tests/function.tst",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/tests/function.res",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/plugin/handler_socket/regtest/test_01_lib/test04.expected",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/win/packaging/WixUIDialogBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/win/packaging/WixUIBannerBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/win/upgrade_wizard/res/upgrade.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/benchmark/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/benchmark/rsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/benchmark/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/taocrypt/certs/dsa512.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/certs/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/extra/yassl/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/debian/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/debian/po/da.po",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug49823.CSM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/host_old.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56datetime.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug49823.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56timestamp.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug11747416_32228_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev-4645-binlog_group_id_checksum.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/cluster_7022_table.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mariadb-5.5-binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/t917689.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev5029_1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/long_table_name.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/vcol_autoinc.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56timestamp.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56time.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/vcol_autoinc.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug48265.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug47142_master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56time.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev5029_2.MAI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug46565.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug48633.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bad_row_type.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug47012.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev-4645-binlog_checksum.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bad_row_type.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev-4645-binlog_group_id.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56time.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56datetime.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug19371.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev5029_2.MAD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev5029_2.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql57_virtual.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug48633.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev6020-mysql-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/long_table_name.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/host_old.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug47012.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/cluster_7022_table.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug48633.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/binlog-header.log",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mdev-4645-binlog_none.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug36055.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/trunc_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql57_virtual.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56timestamp.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug47012.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql56datetime.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug36055.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug19371.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/long_table_name.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug36055.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug19371.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/vchar.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_leap_second.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/user.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/servers.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition_type.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_leap_second.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/func.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/proc.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/proc.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/db.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/db.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/columns_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/event.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/servers.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/event.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/user.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/tables_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/plugin.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/tables_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/func.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_name.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/procs_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition_type.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/plugin.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_name.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/procs_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/user.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/db.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/time_zone.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql5613mysql/columns_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev9842.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev9823.utf8mb4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev9874.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev8711.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev9823.ujis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/loaddata/mdev-11079.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql_upgrade/event.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/mysql_upgrade/event.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/old_decimal/t1dec102.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/old_decimal/t1dec102.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/std_data/old_decimal/t1dec102.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/include/ctype_E05C.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/perfschema/r/misc.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/perfschema/r/statement_digest_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/perfschema/t/statement_digest_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/innodb_fts/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/innodb_fts/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/innodb_fts/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/galera/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_row_annotate_do.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_row_annotate_dont.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/r/rpl_parallel_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/rpl/t/rpl_parallel_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-telco.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_17.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/std_data/binlog_old_version_4_1.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/funcs_1/r/memory_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/funcs_1/r/innodb_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/funcs_1/r/myisam_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/maria/locking.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/maria/locking.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/encryption/t/filekeys-data.enc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/mariabackup/filekeys-data.enc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/iuds/r/strings_charsets_update_delete.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/json/r/json_no_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_big_tables_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_log_bin_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_quote_show_create_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_warnings_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/pseudo_slave_mode_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_buffer_result_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_big_selects_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_low_priority_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/innodb_table_locks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_notes_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/query_cache_wlock_invalidate_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/character_set_client_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/innodb_support_xa_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_safe_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/sql_log_off_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/r/foreign_key_checks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_log_bin_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_warnings_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_log_off_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_notes_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_buffer_result_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_safe_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_big_selects_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/foreign_key_checks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/sql_quote_show_create_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/innodb_table_locks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/pseudo_slave_mode_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/innodb_support_xa_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/query_cache_wlock_invalidate_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/suite/csv/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/extra/binlog_tests/binlog_mysqlbinlog-cp932.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/extra/rpl_tests/rpl_row_annotate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/alias.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/show_check.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/subselect2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/show_explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_gbk.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/warnings.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/rowid_order_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/func_in.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/func_test.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_cp932_binlog_stm.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/signal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/default.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/func_des_encrypt.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/func_gconcat.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/subselect2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/warnings.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/query_cache.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/bug13633383.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/func_gconcat.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/alias.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/func_test.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/func_in.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/mysqldump.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/show_check.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/default.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/show_explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/win/packaging/WixUIDialogBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmariadb/win/packaging/WixUIBannerBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/libmysqld.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/emb_samples.dfm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/images/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/images/mysql.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/images/db.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/images/net.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.2.8-7ea7s5pvixzrj7rq5wxq7elehprawpfe/spack-src/libmysqld/examples/builder-sample/images/find.ico"
    ],
    "total_files": 23488
}