{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/bin/fuzz.pl": "eval '(exit $?0)' && eval 'exec perl -S $0 ${1+\"$@\"}'\n    & eval 'exec perl -S $0 $argv:q'\n    if 0;\n\n#   Fuzz is a script whose purpose is to check through ACE/TAO/CIAO files for\n#   easy to spot (by a perl script, at least) problems.\n\nuse lib \"$ENV{ACE_ROOT}/bin\";\nif (defined $ENV{srcdir}) {\n  use lib \"$ENV{srcdir}/bin\";\n}\n\nuse Cwd;\nuse File::Find;\nuse File::Basename;\nuse Getopt::Std;\nuse PerlACE::Run_Test;\n\n###### TODO\n#\n# Add tests for these:\n#\n# - Guards in .h files\n# - no global functions\n# - other commit_check checks\n#\n# And others in ACE_Guidelines and Design Rules\n#\n# Also add a -g flag to ignore tao_idl generated files\n#\n###### END TODO\n\n# Lists of all the files\n@files_cdp = ();\n@files_cpp = ();\n@files_inl = ();\n@files_h = ();\n@files_html = ();\n@files_dsp = ();\n@files_dsw = ();\n@files_gnu = ();\n@files_idl = ();\n@files_pl = ();\n@files_py = ();\n@files_changelog = ();\n@files_makefile = ();\n@files_mpc = ();\n@files_bor = ();\n@files_noncvs = ();\n@files_sln = ();\n@files_vcproj = ();\n@files_run_pl = ();\n@files_generic = ();\n@files_doxygen = ();\n@files_conf = ();\n@files_rb = ();\n@files_features = ();\n\n# To keep track of errors and warnings\n$errors = 0;\n$warnings = 0;\n\n# to register suppressed tests\n%suppressed_tests = ();\n\n# to register excluded directories\n@excluded_dirs = ();\n\n##############################################################################\n\n# Use 'git status -s' to get a list of locally modified\n# files to look through\nsub find_mod_git_files ()\n{\n    unless (open (GIT, \"git status -s |\")) {\n        print STDERR \"Error: Could not run git\\n\";\n        return 0;\n    }\n\n    while (<GIT>) {\n        if (/^ [MA] +(.*)$/) {\n            store_file ($1);\n        }\n    }\n    close (GIT);\n    return 1;\n}\n\nsub find_mod_files ()\n{\n  if (!find_mod_git_files()) {\n    print \"Could use git to find modified files\\n\";\n    exit (1);\n  }\n}\n\n\nsub is_excluded ($)\n{\n  # exclude will contain the full file name\n  my $exclude = shift;\n  foreach (@excluded_dirs) {\n      if ($exclude =~ /$_/) {\n          return 1;\n      }\n  }\n  return 0;\n}\n\n# Find_Files will search for files with certain extensions in the\n# directory tree\nsub find_files ()\n{\n    # wanted is only used for the File::Find\n    sub wanted\n    {\n        store_file ($File::Find::name);\n    }\n\n    find (\\&wanted, '.');\n}\n\n#\nsub store_file ($)\n{\n    my $name = shift;\n\n    return if is_excluded ($name);\n\n    if ($name =~ /\\.(c|cc|cpp|cxx|tpp)$/i) {\n        push @files_cpp, ($name);\n    }\n    elsif ($name =~ /\\.(inl|i)$/i) {\n        push @files_inl, ($name);\n    }\n    elsif ($name =~ /\\.(h|hh|hpp|hxx)$/i) {\n        push @files_h, ($name);\n    }\n    elsif ($name =~ /\\.(htm|html)$/i) {\n        push @files_html, ($name);\n    }\n    elsif ($name =~ /\\.(bor)$/i) {\n        push @files_bor, ($name);\n    }\n    elsif ($name =~ /\\.(GNU)$/i) {\n        push @files_gnu, ($name);\n    }\n    elsif ($name =~ /\\.(dsp|vcp)$/i) {\n        push @files_dsp, ($name);\n    }\n    elsif ($name =~ /\\.(dsw|vcp)$/i) {\n        push @files_dsw, ($name);\n    }\n    elsif ($name =~ /\\.(pidl|idl|idl3|idl3p)$/i) {\n        push @files_idl, ($name);\n    }\n    elsif ($name =~ /\\.pl$/i) {\n        if ($name =~ /fuzz.pl/) {\n          return;\n        }\n        push @files_pl, ($name);\n        if ($name =~ /^run.*\\.pl$/i) {\n            push @files_run_pl, ($name);\n        }\n    }\n    elsif ($name =~ /\\.py$/i) {\n        push @files_py, ($name);\n    }\n    elsif ($name =~ /\\.(rb|erb)$/i) {\n        push @files_rb, ($name);\n    }\n    elsif ($name =~ /\\.features$/i) {\n        push @files_features, ($name);\n    }\n    elsif ($name =~ /\\.vcproj$/i) {\n        push @files_vcproj, ($name);\n    }\n    elsif ($name =~ /\\.sln$/i) {\n        push @files_sln, ($name);\n    }\n    elsif ($name =~ /ChangeLog/i && -f $name) {\n        push @files_changelog, ($name);\n    }\n    elsif ($name =~ /\\/GNUmakefile.*.[^~]$/) {\n        push @files_makefile, ($name);\n    }\n    elsif ($name =~ /\\.(mpc|mwc|mpb|mpt)$/i) {\n        push @files_mpc, ($name);\n    }\n    elsif ($name =~ /\\.(icc|ncb|zip)$/i) {\n        push @files_noncvs, ($name);\n    }\n    elsif ($name =~ /\\.(cdp)$/i) {\n        push @files_cdp, ($name);\n    }\n    elsif ($name =~ /\\.(doxygen)$/i) {\n        push @files_doxygen, ($name);\n    }\n    elsif ($name =~ /\\.(conf)$/i) {\n        if ($name =~ /\\.(WCHAR_T.conf|UTF-16.conf)$/i) {\n            return;\n        }\n        push @files_conf, ($name);\n    }\n    elsif ($name =~ /\\.(conf.xml)$/i) {\n        if ($name =~ /\\.(WCHAR_T.conf.xml|UTF-16.conf.xml)$/i) {\n            return;\n        }\n        push @files_conf, ($name);\n    }\n    elsif ($name =~ /\\.(pm|cmd|java|sh|txt|xml)$/i) {\n        push @files_generic, ($name);\n    }\n    elsif ($name =~ /README$/i) {\n        push @files_generic, ($name);\n    }\n}\n\n##############################################################################\n## Just messages\n\nsub print_error ($)\n{\n    my $msg = shift;\n    print \"Error: $msg\\n\";\n    ++$errors;\n}\n\n\nsub print_warning ($)\n{\n    my $msg = shift;\n    print \"Warning: $msg\\n\";\n    ++$warnings;\n}\n\n##############################################################################\n## Check if test is suppressed\n\nsub is_suppressed ()\n{\n  my $method = (split (/::/, (caller(1))[3]))[-1];\n  return (defined $suppressed_tests{$method} ? 1 : 0);\n}\n\n##############################################################################\n## Tests\n\n# The point of this test is to check for the existence of ACE_INLINE\n# or ASYS_INLINE in a .cpp file.  This is most commonly caused by\n# copy/pasted code from a .inl/.i file\nsub check_for_inline_in_cpp ()\n{\n    return if is_suppressed ();\n\n    print \"Running ACE_INLINE/ASYS_INLINE check\\n\";\n    foreach $file (@files_cpp) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/^ACE_INLINE/) {\n                    print_error (\"$file:$.: ACE_INLINE found\");\n                }\n                if (/^ASYS_INLINE/) {\n                    print_error (\"$file:$.: ASYS_INLINE found\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks to make sure we have no files with $Id string in them.\nsub check_for_id_string ()\n{\n    return if is_suppressed ();\n\n    print \"Running \\$Id\\$ string check\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h, @files_mpc, @files_bor,\n                   @files_gnu, @files_html, @files_idl, @files_pl,\n                   @files_cdp, @files_py, @files_conf, @files_generic, @files_features) {\n        my $found = 0;\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/\\$id\\$/) {\n                    print_error (\"$file:$.: Incorrect \\$id\\$ found (correct casing)\");\n                }\n                if (/\\$Id:\\$/) {\n                    print_error (\"$file:$.: Incorrect \\$Id:\\$ found (remove colon)\");\n                }\n                if (/\\$Id\\$/ || /\\$Id: /) {\n                    $found = 1;\n                }\n            }\n            close (FILE);\n            if ($found == 1) {\n                print_error (\"$file: \\$Id\\$ string found, not used anymore.\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# check for _MSC_VER\nsub check_for_msc_ver_string ()\n{\n    return if is_suppressed ();\n\n    print \"Running _MSC_VER check\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        my $found = 0;\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            my $mscline = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_msc_ver/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_msc_ver/) {\n                    $disable = 0;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\<= 1200/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\>= 1200/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\> 1200/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\< 1300/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\<= 1300/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\>= 1300/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\< 1310/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n                if ($disable == 0 and /\\_MSC_VER \\>= 1310/) {\n                    $found = 1;\n                    $mscline = $.;\n                }\n            }\n            close (FILE);\n            if ($found == 1) {\n               print_error (\"$file:$mscline: Incorrect _MSC_VER check found\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the newline at the end of a file\nsub check_for_newline ()\n{\n    return if is_suppressed ();\n\n    print \"Running newline check\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h,\n                   @files_html, @files_idl, @files_pl) {\n        if (open (FILE, $file)) {\n            my $line;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                $line = $_\n            }\n            close (FILE);\n            if ($line !~ /\\n$/) {\n                print_error (\"$file:$.: No ending newline found in $file\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n\n# This test checks for files that are not allowed to be in version control\nsub check_for_noncvs_files ()\n{\n    return if is_suppressed ();\n\n    print \"Running non versioned controlled files check\\n\";\n    foreach $file (@files_noncvs, @files_dsp, @files_dsw, @files_makefile, @files_bor) {\n        print_error (\"File $file should not be in version control!\");\n    }\n}\n\n# This test checks for the use of ACE_SYNCH_MUTEX in TAO/CIAO,\n# TAO_SYNCH_MUTEX should used instead.\n\nsub check_for_ACE_SYNCH_MUTEX ()\n{\n    return if is_suppressed ();\n\n    print \"Running ACE_SYNCH_MUTEX check\\n\";\n    ITERATION: foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_ACE_SYNCH_MUTEX/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_ACE_SYNCH_MUTEX/) {\n                    $disable = 0;\n                    next;\n                }\n                if ($disable == 0 and /ACE_SYNCH_MUTEX/) {\n                    # It is okay to use ACE_SYNCH_MUTEX in ACE\n                    # so don't check the ACE directory. The below\n                    # will check it for TAO and CIAO.\n                    if (($file !~ /.*TAO.*/)) {\n                      next ITERATION;\n                    }\n\n                    # Disable the check in the ESF directory for the\n                    # time being until we fix the issues there.\n                    if(($file =~ /.*TAO\\/orbsvcs\\/orbsvcs\\/ESF.*/)) {\n                      next ITERATION;\n                    }\n\n                    print_error (\"$file:$.: found ACE_SYNCH_MUTEX, use TAO_SYNCH_MUTEX instead\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for not having export files in CIAO, all have to be ---\n# generated using TAO_IDL. If you have a file that must be in the repository\n# remove the generated automatically by line\nsub check_for_export_file ()\n{\n    return if is_suppressed ();\n\n    print \"Running export file check\\n\";\n    ITERATION: foreach $file (@files_h) {\n        if (($file =~ /.*CIAO.*export.h/) || ($file =~ /.*DAnCE.*export.h/)) {\n          if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n              if (/generated automatically by/) {\n                print_error (\"$file:$.: file should be generated by TAO_IDL, check -Gxh** option\");\n              }\n            }\n            close (FILE);\n          }\n          else {\n            print STDERR \"Error: Could not open $file\\n\";\n          }\n        }\n    }\n}\n\n\n# This test checks for the use of ACE_Thread_Mutex in TAO/CIAO,\n# TAO_SYNCH_MUTEX should used instead to make the code build\n# in single-threaded builds.\nsub check_for_ACE_Thread_Mutex ()\n{\n    return if is_suppressed ();\n\n    print \"Running ACE_Thread_Mutex check\\n\";\n    ITERATION: foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_ACE_Thread_Mutex/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_ACE_Thread_Mutex/) {\n                    $disable = 0;\n                    next;\n                }\n                if ($disable == 0 and /ACE_Thread_Mutex/) {\n                    # It is okay to use ACE_Thread_Mutex in ACE\n                    # so don't check the ACE directory. The below\n                    # will check it for TAO and CIAO.\n                    if (($file !~ /.*TAO.*/)) {\n                      next ITERATION;\n                    }\n\n                    print_error (\"$file:$.: found ACE_Thread_Mutex, use TAO_SYNCH_MUTEX instead to allow the code to work in single-threaded builds\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the use of ACE_Guard\n# ACE_GUARD should used because it checks if we really got a lock\n# in single-threaded builds.\nsub check_for_ACE_Guard ()\n{\n    return if is_suppressed ();\n\n    print \"Running ACE_Guard check\\n\";\n    ITERATION: foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_ACE_Guard/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_ACE_Guard/) {\n                    $disable = 0;\n                    next;\n                }\n                if ($disable == 0 and /ACE_Guard/) {\n                    print_error (\"$file:$.: found ACE_Guard, use ACE_GUARD\");\n                }\n                if ($disable == 0 and /ACE_Read_Guard/) {\n                    print_error (\"$file:$.: found ACE_Read_Guard, use ACE_READ_GUARD\");\n                }\n                if ($disable == 0 and /ACE_Write_Guard/) {\n                    print_error (\"$file:$.: found ACE_Write_Guard, use ACE_WRITE_GUARD\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the use of tabs, spaces should be used instead of tabs\nsub check_for_tab ()\n{\n    return if is_suppressed ();\n\n    print \"Running tabs check\\n\";\n    ITERATION: foreach $file (@files_cpp, @files_inl, @files_h, @files_idl, @files_cdp, @files_doxygen, @files_changelog) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_tab/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_tab/) {\n                    $disable = 0;\n                }\n                if ($disable == 0 and /.*\\t.*/) {\n                    print_error (\"$file:$.: found tab\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_trailing_whitespace ()\n{\n    return if is_suppressed ();\n\n    print \"Running trailing_whitespaces check\\n\";\n    ITERATION: foreach $file (@files_cpp, @files_inl, @files_h, @files_idl,\n                              @files_cdp, @files_pl, @files_py, @files_generic) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_trailing_whitespace/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_trailing_whitespace/) {\n                    $disable = 0;\n                }\n                if ($disable == 0 and /\\s\\n$/) {\n                    print_error (\"$file:$.: found trailing whitespace\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the lack of ACE_OS\nsub check_for_lack_ACE_OS ()\n{\n    return if is_suppressed ();\n\n    $OS_NS_arpa_inet_symbols = \"inet_addr|inet_aton|inet_ntoa|inet_ntop|inet_pton\";\n\n    $OS_NS_ctype_symbols = \"isalnum|isalpha|iscntrl|isdigit|isgraph|islower|isprint|ispunct|isspace|isupper|isxdigit|tolower|toupper|isblank|isascii|isctype|iswctype\";\n\n    $OS_NS_dirent_symbols = \"closedir|opendir|readdir|readdir_r|rewinddir|scandir|alphasort|seekdir|telldir|opendir_emulation|scandir_emulation|closedir_emulation|readdir_emulation\";\n\n    $OS_NS_dlfcn_symbols = \"dlclose|dlerror|dlopen|dlsym\";\n\n    $OS_NS_errno_symbols = \"last_error|set_errno_to_last_error|set_errno_to_wsa_last_error\";\n\n    $OS_NS_fcntl_symbols = \"fcntl|open\";\n\n    $OS_NS_math_symbols = \"floor|ceil|log2\";\n\n    $OS_NS_netdb_symbols = \"gethostbyaddr|gethostbyaddr_r|gethostbyname|gethostbyname_r|getipnodebyaddr|getipnodebyname|getmacaddress|getprotobyname|getprotobyname_r|getprotobynumber|getprotobynumber_r|getservbyname|getservbyname_r|netdb_acquire|netdb_release\";\n\n    $OS_NS_poll_symbols = \"poll\";\n\n    $OS_NS_pwd_symbols = \"endpwent|getpwent|getpwnam|getpwnam_r|setpwent\";\n\n    $OS_NS_regex_symbols = \"compile|step\";\n\n    $OS_NS_signal_symbols = \"kill|pthread_sigmask|sigaction|sigaddset|sigdelset|sigemptyset|sigfillset|sigismember|signal|sigprocmask|sigsuspend|raise\";\n\n    $OS_NS_stdio_symbols = \"fileno|checkUnicodeFormat|clearerr|cuserid|fclose|fdopen|fflush|fgetc|getc|fgetpos|fgets|flock_adjust_params|flock_init|flock_destroy|flock_rdlock|flock_tryrdlock|flock_trywrlock|flock_unlock|flock_wrlock|fopen|default_win32_security_attributes|default_win32_security_attributes_r|get_win32_versioninfo|get_win32_resource_module|set_win32_resource_module|fprintf|ungetc|fputc|putc|fputs|fread|freopen|fseek|fsetpos|ftell|fwrite|perror|printf|puts|rename|rewind|snprintf|sprintf|tempnam|vsprintf|vsnprintf|asprintf|aswprintf|vasprintf|vaswprintf\";\n\n    $OS_NS_stdlib_symbols = \"_exit|abort|atexit|atof|atol|atoi|atop|bsearch|calloc|exit|free|getenv|getenvstrings|itoa|itoa_emulation|itow_emulation|malloc|mkstemp|mkstemp_emulation|mktemp|setenv|unsetenv|putenv|qsort|rand|rand_r|realloc|realpath|set_exit_hook|srand|strenvdup|strtod|strtol|strtol_emulation|strtoul|strtoul_emulation|strtoll|strtoll_emulation|strtoull|strtoull_emulation|system|getprogname|setprogname\";\n\n    $OS_NS_string_symbols = \"memchr|memchr_emulation|memcmp|memcpy|fast_memcpy|memmove|memset|strcat|strchr|strcmp|strcpy|strcspn|strdup|strdup_emulation|strecpy|strerror|strerror_emulation|strsignal|strlen|strncat|strnchr|strncmp|strncpy|strnlen|strnstr|strpbrk|strrchr|strrchr_emulation|strsncpy|strspn|strstr|strtok|strtok_r|strtok_r_emulation\";\n\n    $OS_NS_strings_symbols = \"strcasecmp|strncasecmp|strcasecmp_emulation\";\n\n    $OS_NS_stropts_symbols = \"getmsg|getpmsg|fattach|fdetach|ioctl|isastream|putmsg|putpmsg\";\n\n    $OS_NS_sys_mman_symbols = \"madvise|mmap|mprotect|msync|munmap|shm_open|shm_unlink\";\n\n    $OS_NS_sys_msg_symbols = \"msgctl|msgget|msgrcv|msgsnd\";\n\n    $OS_NS_sys_resource_symbols = \"getrlimit|getrusage|setrlimit\";\n\n    $OS_NS_sys_select_symbols = \"select\";\n\n    $OS_NS_sys_sendfile_symbols = \"sendfile|sendfile_emulation\";\n\n    $OS_NS_sys_shm_symbols = \"shmat|shmctl|shmdt|shmget\";\n\n    $OS_NS_sys_socket_symbols = \"accept|bind|closesocket|connect|enum_protocols|getpeername|getsockname|getsockopt|join_leaf|listen|recv|recvfrom|recvmsg|recvv|send|sendmsg|sendto|sendv|setsockopt|shutdown|if_nametoindex|if_indextoname|if_nameindex|socket_init|socket_fini|socket|socketpair\";\n\n    $OS_NS_sys_stat_symbols = \"creat|filesize|fstat|lstat|mkdir|mkfifo|stat|umask\";\n\n    $OS_NS_sys_time_symbols = \"gettimeofday\";\n\n    $OS_NS_sys_uio_symbols = \"readv|readv_emulation|writev|writev_emulation\";\n\n    $OS_NS_sys_utsname_symbols = \"uname\";\n\n    $OS_NS_sys_wait_symbols = \"wait|waitpid\";\n\n    $OS_NS_Thread_symbols = \"cleanup_tss|condattr_init|condattr_destroy|cond_broadcast|cond_destroy|cond_init|cond_signal|cond_timedwait|cond_wait|event_destroy|event_init|event_pulse|event_reset|event_signal|event_timedwait|event_wait|lwp_getparams|lwp_setparams|mutex_destroy|mutex_init|mutex_lock|mutex_lock_cleanup|mutex_trylock|mutex_unlock|priority_control|recursive_mutex_cond_unlock|recursive_mutex_cond_relock|recursive_mutex_destroy|recursive_mutex_init|recursive_mutex_lock|recursive_mutex_trylock|recursive_mutex_unlock|rw_rdlock|rw_tryrdlock|rw_trywrlock|rw_trywrlock_upgrade|rw_unlock|rw_wrlock|rwlock_destroy|rwlock_init|sched_params|scheduling_class|sema_destroy|sema_init|sema_post|sema_trywait|sema_wait|semctl|semget|semop|set_scheduling_params|sigtimedwait|sigwait|sigwaitinfo|thr_cancel|thr_cmp|thr_continue|thr_create|thr_equal|thr_exit|thr_getconcurrency|thr_getprio|thr_getspecific_native|thr_getspecific|thr_join|thr_get_affinity|thr_set_affinity|thr_key_detach|thr_key_used|thr_keycreate_native|thr_keycreate|thr_keyfree|thr_kill|thr_min_stack|thr_self|thr_setcancelstate|thr_setcanceltype|thr_setconcurrency|thr_setprio|thr_setspecific_native|thr_setspecific|thr_sigsetmask|thr_suspend|thr_testcancel|thr_yield|thread_mutex_destroy|thread_mutex_init|thread_mutex_lock|thread_mutex_trylock|thread_mutex_unlock|unique_name\";\n\n    $OS_NS_time_symbols = \"asctime|asctime_r|clock_gettime|clock_settime|ctime|ctime_r|difftime|gmtime|gmtime_r|localtime|localtime_r|mktime|nanosleep|readPPCTimeBase|strftime|strptime|strptime_emulation|strptime_getnum|time|timezone|tzset\";\n\n    $OS_NS_unistd_symbols = \"access|alarm|allocation_granularity|argv_to_string|chdir|rmdir|close|dup|dup2|execl|execle|execlp|execv|execve|execvp|fork|fork_exec|fsync|ftruncate|getcwd|getgid|getegid|getopt|getpagesize|getpgid|getpid|getppid|getuid|geteuid|hostname|isatty|lseek|llseek|num_processors|num_processors_online|pipe|pread|pwrite|read|read_n|readlink|sbrk|setgid|setegid|setpgid|setregid|setreuid|setsid|setuid|seteuid|sleep|string_to_argv|swab|sysconf|sysinfo|truncate|ualarm|unlink|write|write_n\";\n\n    $OS_NS_wchar_symbols = \"fgetwc|wcscat_emulation|wcschr_emulation|wcscmp_emulation|wcscpy_emulation|wcscspn_emulation|wcsicmp_emulation|wcslen_emulation|wcsncat_emulation|wcsncmp_emulation|wcsncpy_emulation|wcsnicmp_emulation|wcspbrk_emulation|wcsrchr_emulation|wcsrchr_emulation|wcsspn_emulation|wcsstr_emulation|wslen|wscpy|wscmp|wsncmp|ungetwc\";\n\n    print \"Running ACE_OS check\\n\";\n    foreach $file (@files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_lack_ACE_OS/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_lack_ACE_OS/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if($file !~ /.c$/ && $file !~ /S.cpp$/ && $file !~ /S.inl$/ && $file !~ /C.cpp$/ && $file !~ /C.inl$/) {\n                        if($file !~ /OS_NS_arpa_inet/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_arpa_inet_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_arpa_inet.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_ctype/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_ctype_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_ctype.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_dirent/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_dirent_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_dirent.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_dlfcn/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_dlfcn_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_dlfcn.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_errno/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_errno_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_errno.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_fcntl/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_fcntl_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_fcntl.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_math/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_math_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_math.\");\n                            }\n                        }\n                        if($file !~ /OS_NS_netdb/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_netdb_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_netdb.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_poll/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_netdb_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_poll.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_pwd/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_pwd_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_pwd.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_regex/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_regex_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_regex.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_signal/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_signal_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_signal.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_stdlib/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_stdlib_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_stdlib.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_stdio/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_stdio_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_stdio.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_string/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_string_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_string.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_strings/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_strings_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_strings.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_stropts/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_stropts_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_stropts.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_mman/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_mman_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_mman.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_msg/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_msg_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_msg.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_resource/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_resource_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_resource.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_select/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_select_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_select.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_sendfile/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_sendfile_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_sendfile.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_shm/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_shm_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_shm.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_socket/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_socket_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_socket.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_stat/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_stat_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_stat.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_time/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_time_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_time.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_uio/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_uio_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_uio.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_utsname/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_utsname_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_utsname.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_sys_wait/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_sys_wait_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_sys_wait.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_Thread/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_Thread_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_Thread.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_time/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_time_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_time.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_unistd/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_unistd_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_unistd.h\");\n                            }\n                        }\n                        if($file !~ /OS_NS_wchar/) {\n                            if(/(\\s+:{0,2}|\\(:{0,2}|\\s*!:{0,2}|^|\\):{0,2})($OS_NS_wchar_symbols)\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                                print_error (\"$file:$.: missing ACE_OS use ace/OS_NS_wchar.h\");\n                            }\n                        }\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the use of exception specification,\n# exception specification has fallen out of favor, and generally\n# should not be used.\nsub check_for_exception_spec ()\n{\n    return if is_suppressed ();\n\n    print \"Running exception specification check\\n\";\n\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_exception_sepc/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_exception_sepc/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if(/throw\\s*\\(\\s*\\)/) {\n                        #next;\n                    }\n                    elsif(/(^|\\s+)throw\\s*\\(/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                        print_error (\"$file:$.: exception specification found\");\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the use of NULL,\n# NULL shouldn't be used, use 0 instead\nsub check_for_NULL ()\n{\n    return if is_suppressed ();\n\n    print \"Running NULL usage check\\n\";\n\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_NULL/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_NULL/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if(/(\\(|\\)|\\s+|=)NULL(\\)|\\s+|\\;|\\,)/ and $` !~ /\\/\\// and $` !~ /\\/\\*/ and $` !~ /\\*\\*+/ and $` !~ /\\s+\\*+\\s+/) {\n                        print_error (\"$file:$.: NULL found\");\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for improper main declaration,\n# the proper form should look like:\n# int ACE_TMAIN (int argc, ACE_TCHAR *argv[])\nsub check_for_improper_main_declaration ()\n{\n    return if is_suppressed ();\n\n    print \"Running Improper main() declaration check\\n\";\n\n    foreach $file (@files_cpp) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            my $type_of_main;\n            my $multi_line;\n            my $not_found_end_line_count= 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (!defined $multi_line) {\n                    if (/FUZZ\\: disable check_for_improper_main_declaration/) {\n                        $disable = 1;\n                        next;\n                    }\n                    elsif (/FUZZ\\: enable check_for_improper_main_declaration/) {\n                        $disable = 0;\n                        next;\n                    }\n                    elsif ($disable == 0) {\n                        s/^\\s+//;           ## Remove leading space\n                        s/\\s*(\\/\\/.*)?$//;  ## Remove trailing space and line comments\n                        if (s/^(?:.*\\s)?(main|ACE_TMAIN)\\s*//) {\n                            $type_of_main = $1; ## main or ACE_TMAIN\n                            $multi_line   = $_; ## Rest of the line\n                        }\n                        else {\n                            next;\n                        }\n                    }\n                }\n                else {\n                    $_ =~ s/^\\s+//;           ## Remove leading space\n                    $_ =~ s/\\s*(\\/\\/.*)?$//;  ## Remove trailling space and line comments\n                    if ($multi_line eq \"\") {  ## Append this line to existing statement.\n                        $multi_line = $_;\n                    }\n                    else {\n                        $multi_line .= ' ' . $_;\n                    }\n                }\n                $multi_line =~ s!^(/+\\*.*?\\*/\\s*)*!!;  ## Remove leading /* ... */ comments\n                next if ($multi_line eq \"\");  ## Must have something after main\n                if ($multi_line !~ m/^\\(/) {\n                    ## Not a function opening bracket, we will ignore this one\n                    ## it is not a main function.\n                    undef $multi_line;\n                    $not_found_end_line_count = 0;\n                }\n                elsif ($multi_line =~ s/^\\(\\s*([^\\)]*?)\\s*\\)[^;\\{]*?\\{//) {\n                    $multi_line = $1;                             ## What was between the main's ( and )\n                    $multi_line =~ s/\\s{2,}/ /g;                  ## Compress white space\n                    my $was = $multi_line;\n                    $multi_line =~ s!([^/])\\*\\s([^/])!$1\\*$2!g;   ## Remove space after * (except around comment)\n                    $multi_line =~ s!([^/])\\s\\[!$1\\[!g;           ## Remove space before [ (except following comment)\n                    $multi_line =~ s!\\s?\\*/\\s?/\\*\\s?! !g;         ## Connect seporate adjacent /* ... */ comments\n                    if ($multi_line =~ s!^([^,]*?)\\s?,\\s?(/+\\*.*?\\*/\\s?)*!!) { # Fails if only 1 parameter (ignore this main)\n                        my $arg1 = $1;\n                        if ($multi_line =~ s/^(\\w[\\w\\d]*)\\s?//) { # Fails if no type for 2nd parameter (ignore this main)\n                            my $arg2_type = $1;\n                            $multi_line =~ s!^(?:/+\\*.*?\\*/\\s?)?(\\**)(\\w[\\w\\d]*|\\s?/\\*.*?\\*/\\s?)?!!;\n                            my $prefix = $1; ## should be * or **\n                            my $name   = $2; ## is now arg2's variable name\n                            $multi_line =~ s!\\s?\\*/\\s?/\\*\\s?! !g;  ## Connect seporate adjacent /* ... */ comments\n\n                            ## remove any comment after postfix\n                            if ($multi_line =~ s!\\s?(/+\\*.*?\\*/)$!! && $name eq '') {\n                                $name = \"$1 \";  ## Some name argv in comment after []\n                            }\n                            ## multi_line now postfix, should be []\n\n                            if ($type_of_main ne 'ACE_TMAIN'       ||\n                                $arg2_type ne 'ACE_TCHAR'          ||\n                                !(($prefix eq '*' && $multi_line eq '[]') ||\n                                  ($prefix eq '**' && $multi_line eq '' ))  ) {\n                                print_error (\"$file:$.:  $type_of_main ($was)  should be  ACE_TMAIN ($arg1, ACE_TCHAR \\*$name\\[])\");\n                           }\n                        }\n                    }\n\n                    undef $multi_line;\n                    $not_found_end_line_count = 0;\n                }\n                elsif ($not_found_end_line_count < 10) { # Limit the search for ( ... ) following main to ten lines\n                    ++$not_found_end_line_count;\n                }\n                else {\n                    undef $multi_line;\n                    $not_found_end_line_count = 0;\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the use of \"inline\" instead of ACE_INLINE\nsub check_for_inline ()\n{\n    return if is_suppressed ();\n\n    print \"Running inline check\\n\";\n    foreach $file (@files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_inline/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_inline/) {\n                    $disable = 0;\n                }\n                if ($disable == 0 and m/^\\s*inline/) {\n                    print_error (\"$file:$.: 'inline' keyword found\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n\n# This test checks for the inclusion of math.h.  math.h should be avoided\n# since on some platforms, \"exceptions\" is defined as a struct, which will\n# cause problems with exception handling\nsub check_for_math_include ()\n{\n    return if is_suppressed ();\n\n    print \"Running math.h test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_math_include/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_math_include/) {\n                    $disable = 0;\n                }\n                if ($disable == 0\n                    and /^\\s*#\\s*include\\s*(\\/\\*\\*\\/){0,1}\\s*\\<math\\.h\\>/) {\n                    print_error (\"$file:$.: <math.h> included\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the inclusion of streams.h.\n# // FUZZ: disable check_for_streams_include\nsub check_for_streams_include ()\n{\n    return if is_suppressed ();\n\n    print \"Running ace/streams.h test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_streams_include/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_streams_include/) {\n                    $disable = 0;\n                }\n                if ($disable == 0\n                    and /^\\s*#\\s*include\\s*\\\"ace\\/streams\\.h\\\"/) {\n                    print_error (\"$file:$.: expensive ace/streams.h included; consider ace/iosfwd.h\");\n                    print \" ace/streams.h is very expensive in both \";\n                    print \"compile-time and footprint. \\n\";\n                    print \" Please consider including ace/iosfwd.h instead.\\n\\n\";\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the inclusion of Synch*.h.\nsub check_for_synch_include ()\n{\n    return if is_suppressed ();\n\n    print \"Running ace/Synch*.h test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_synch_include/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_synch_include/) {\n                    $disable = 0;\n                }\n                if ($disable == 0\n                    and (/^\\s*#\\s*include\\s*\\\"(ace\\/Synch\\.h)\\\"/\n                         or /^\\s*#\\s*include\\s*\\\"(ace\\/Synch_T\\.h)\\\"/)) {\n                    my $synch = $1;\n                    print_error (\"$file:$.: expensive $synch included;  consider individual synch file\");\n                    print \" $synch is very expensive in both \";\n                    print \"compile-time and footprint. \\n\";\n                    print \" Please consider including one of the \";\n                    print \"individual synch files instead.\\n\\n\";\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# For general readability, lines should not contain more than 80 characters\nsub check_for_line_length ()\n{\n    return if is_suppressed ();\n\n    print \"Running line length test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n\n                # Make sure to ignore ACE_RCSID lines, since they\n                # are difficult to get under 80 chars.\n                if (/.{80,}/ and !/^ACE_RCSID/) {\n                    print_error (\"$file:$.: line longer than 80 chars\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n\n# For preprocessor directives, only the old C style comments (/* */)\n# should be used, not the newer // style.\nsub check_for_preprocessor_comments ()\n{\n    return if is_suppressed ();\n\n    print \"Running preprocessor comment test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/^\\#.*\\/\\//) {\n                    print_error (\"$file:$.: C++ comment in directive\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# We should not have empty files in the repo\nsub check_for_empty_files ()\n{\n    return if is_suppressed ();\n\n    print \"Running empty file test\\n\";\n    foreach $file (@files_inl, @files_cpp, @files_rb) {\n        my $found_non_empty_line = 0;\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n              next if /^[[:blank:]]*$/; # skip empty lines\n              next if /^[[:blank:]]*\\/\\//; # skip C++ comments\n              next if /^[[:blank:]]*\\/\\*/; # skip C++ comments\n              $found_non_empty_line = 1;\n              last;\n            }\n            close (FILE);\n            if ($found_non_empty_line == 0) {\n             print_error (\"$file:1: empty file should not be in the repository\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n\n# This test checks for the use of the Win32 Unicode string defines\n# or outdated ASYS_* macros\n# We should only be using the ACE_TCHAR, ACE_TEXT macros instead.\nsub check_for_tchar\n{\n    return if is_suppressed ();\n\n    print \"Running TCHAR test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_tchar/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_tchar/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if (/LPTSTR/) {\n                        print_error (\"$file:$.: LPTSTR found\");\n                    }\n\n                    if (/LPCTSTR/) {\n                        print_error (\"$file:$.: LPCTSTR found\");\n                    }\n\n                    if (/ASYS_TCHAR/) {\n                        print_error (\"$file:$.: ASYS_TCHAR found\");\n                    }\n                    elsif (/TCHAR/ and !/ACE_TCHAR/) {\n                        ### Do a double check, since some macros do have TCHAR\n                        ### (like DEFAULTCHARS)\n                        if (/^TCHAR[^\\w_]/ or /[^\\w_]TCHAR[^\\w_]/) {\n                            print_error (\"$file:$.: TCHAR found\");\n                        }\n                    }\n\n                    if (/ASYS_TEXT/) {\n                        print_error (\"$file:$.: ASYS_TEXT found\");\n                    }\n                    elsif (/TEXT/ and !/ACE_TEXT/) {\n                        ### Do a double check, since there are several macros\n                        ### that end with TEXT\n                        if (/^TEXT\\s*\\(/ or /[^\\w_]TEXT\\s*\\(/) {\n                            print_error (\"$file:$.: TEXT found\");\n                        }\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This checks to see if Makefiles define a DEPENDENCY_FILE, and if they do\n# whether or not it's in the cvs repo.\nsub check_for_dependency_file ()\n{\n    return if is_suppressed ();\n\n    print \"Running DEPENDENCY_FILE test\\n\";\n    foreach $file (@files_makefile) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/^DEPENDENCY_FILE\\s* =\\s*(.*)/) {\n                    my $depend = $1;\n                    my $path = $file;\n                    $path =~ s/\\/GNUmakefile.*/\\//;\n                    $depend = $path . $depend;\n                    unless (open (DFILE, $depend)) {\n                        print_error (\"DEPENDENCY_FILE \\\"$depend\\\" not found\");\n                        print \" Either add \\\"$depend\\\" to git \";\n                        print \"or remove DEPENDENCY_FILE variable\\n\";\n                        print \" from $file\\n\\n\";\n                    }\n                    close (DFILE);\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print_error (\"cannot open $file\");\n        }\n    }\n}\n\n# This checks to see if GNUmakefiles define a MAKEFILE, and if it matches the\n# name of the GNUmakefile\nsub check_for_makefile_variable ()\n{\n    return if is_suppressed ();\n\n    print \"Running MAKEFILE variable test\\n\";\n    foreach $file (@files_makefile) {\n        if (!(substr($file,-4) eq \".bor\")\n            and !(substr($file,-3) eq \".am\")\n            and !(substr($file,-4) eq \".vac\")\n            and !(substr($file,-4) eq \".alt\")) {\n            if (open (FILE, $file)) {\n                print \"Looking at file $file\\n\" if $opt_d;\n                my $makevarfound = 0;\n                my $filename = basename($file,\"\");\n                while (<FILE>) {\n                    if (/^MAKEFILE\\s*=\\s*(.*)/) {\n                        $makevarfound = 1;\n                        $makevar = $1;\n                        if (!($makevar eq $filename)) {\n                            print_error (\"$file:$.: MAKEFILE variable $makevar != $filename\");\n                            print \" Change MAKEFILE = $filename in $file.\\n\\n\";\n                        }\n                    }\n                }\n                if ($makevarfound == 0 and !($filename eq \"GNUmakefile\")) {\n                    print_error (\"$file:$.: MAKEFILE variable missing in $file\");\n                    print \" Add MAKEFILE = $filename to the top of $file.\\n\\n\";\n                }\n                close (FILE);\n            }\n            else {\n                print_error (\"cannot open $file\");\n            }\n        }\n    }\n}\n\n\n# This checks to make sure files include ace/post.h if ace/pre.h is included\n# and vice versa.\nsub check_for_pre_and_post ()\n{\n    return if is_suppressed ();\n\n    print \"Running pre.h/post.h test\\n\";\n    foreach $file (@files_h) {\n        my $pre = 0;\n        my $post = 0;\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_pre_and_post/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_pre_and_post/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if (/^\\s*#\\s*include\\s*\\\"ace\\/pre\\.h\\\"/) {\n                        print_error (\"$file:$.: pre.h  missing \\\"/**/\\\"\");\n                        ++$pre;\n                    }\n                    if (/^\\s*#\\s*include\\s*\\s*\\\"ace\\/post\\.h\\\"/) {\n                        print_error (\"$file:$.: post.h missing \\\"/**/\\\"\");\n                        ++$post;\n                    }\n                    if (/^\\s*#\\s*include\\s*\\/\\*\\*\\/\\s*\\\"ace\\/pre\\.h\\\"/) {\n                        ++$pre;\n                    }\n                    if (/^\\s*#\\s*include\\s*\\/\\*\\*\\/\\s*\\\"ace\\/post\\.h\\\"/) {\n                        ++$post;\n                    }\n                }\n            }\n            close (FILE);\n\n            if ($disable == 0 && $pre != $post) {\n                print_error (\"$file:1: pre.h/post.h mismatch\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test verifies that the same number of \"#pragma warning(push)\" and\n# \"#pragma warning(pop)\" pragmas are used in a given header.\nsub check_for_push_and_pop ()\n{\n    return if is_suppressed ();\n\n    print \"Running #pragma (push)/(pop) test\\n\";\n    foreach $file (@files_h) {\n        my $push_count = 0;\n        my $pop_count = 0;\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_push_and_pop/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_push_and_pop/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if (/^\\s*#\\s*pragma\\s*warning\\s*\\(\\s*push[,1-4]*\\s*\\)/) {\n                        ++$push_count;\n                    }\n                    if (/^\\s*#\\s*pragma\\s*warning\\s*\\(\\s*pop\\s*\\)/) {\n                        ++$pop_count;\n                    }\n                }\n            }\n            close (FILE);\n\n            if ($disable == 0 && $push_count != $pop_count) {\n                print_error (\"$file: #pragma warning(push)/(pop) mismatch\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test verifies that the same number of\n# \"ACE_VERSIONED_NAMESPACE_BEGIN_DECL\" and\n# \"ACE_END_VERSIONED_NAMESPACE_DECL\" macros are used in a given\n# source file.\nsub check_for_versioned_namespace_begin_end ()\n{\n  return if is_suppressed ();\n\n  print \"Running versioned namespace begin/end test\\n\";\n  foreach $file (@files_cpp, @files_inl, @files_h) {\n    my $begin_count = 0;\n    my $end_count = 0;\n    if (open (FILE, $file)) {\n      print \"Looking at file $file\\n\" if $opt_d;\n      while (<FILE>) {\n        if (/^\\s*\\w+_BEGIN_VERSIONED_NAMESPACE_DECL/) {\n          ++$begin_count;\n        }\n        if (/^\\s*\\w+_END_VERSIONED_NAMESPACE_DECL/) {\n          ++$end_count;\n        }\n        if ($begin_count > $end_count and\n            /^\\s*#\\s*include(\\s*\\/\\*\\*\\/)?\\s*\"/) {\n          print_error (\"$file:$.: #include directive within Versioned namespace block\");\n        }\n      }\n\n      close (FILE);\n\n      if ($begin_count != $end_count) {\n        print_error (\"$file: Versioned namespace begin($begin_count)/end($end_count) mismatch\");\n      }\n    }\n    else {\n      print STDERR \"Error: Could not open $file\\n\";\n    }\n  }\n}\n\n\n# Check doxygen @file comments\nsub check_for_mismatched_filename ()\n{\n    return if is_suppressed ();\n\n    print \"Running doxygen \\@file test\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl, @files_idl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (m/\\@file\\s*([^\\s]+)/){\n                    # $file includes complete path, $1 is the name after\n                    # @file. We must check whether the last part of $file\n                    # is equal to $1\n                    if ($file !~ /$1$/) {\n                        print_error (\"$file:$.: \\@file mismatch in $file, found $1\");\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# check for bad run_test\nsub check_for_bad_run_test ()\n{\n    return if is_suppressed ();\n\n    print \"Running run_test.pl test\\n\";\n    foreach $file (@files_run_pl) {\n        if (open (FILE, $file)) {\n            my $is_run_test = 0;\n            my $sub = 0;\n\n            if (($file =~ /.*TAO\\/examples\\/Advanced.*/)) {\n              next ITERATION;\n            }\n            if (($file =~ /.*TAO\\/orbsvcs\\/examples\\/Security\\/Send_File.*/)) {\n              next ITERATION;\n            }\n\n            print \"Looking at file $file\\n\" if $opt_d;\n\n            while (<FILE>) {\n                if (m/PerlACE/ || m/ACEutils/) {\n                    $is_run_test = 1;\n                }\n\n                if ($is_run_test == 1) {\n                    if (m/ACEutils/) {\n                        print_error (\"$file:$.: ACEutils.pm still in use\");\n                    }\n\n                    if (m/unshift \\@INC/) {\n                        print_error (\"$file:$.: unshifting \\@INC; use \\\"use lib\\\"\");\n                    }\n\n                    if (m/\\$EXEPREFIX/) {\n                        print_error (\"$file:$.: using \\$EXEPREFIX\");\n                    }\n\n                    if (m/\\$EXE_EXT/) {\n                        print_error (\"$file:$.: using \\$EXE_EXT\");\n                    }\n\n                    if (m/Sys::Hostname/) {\n                        print_error (\"$file:$.: using Sys::Hostname\");\n                    }\n\n                    if (m/PerlACE::wait_interval_for_process_creation/) {\n                        print_error (\"$file:$.: using PerlACE::wait_interval_for_process_creation\");\n                    }\n\n                    if (m/PerlACE::waitforfile_timed/) {\n                        print_error (\"$file:$.: using PerlACE::waitforfile_timed\");\n                    }\n\n                    if (m/PerlACE::is_vxworks_test/) {\n                        print_error (\"$file:$.: using PerlACE::is_vxworks_test\");\n                    }\n\n                    if (m/PerlACE::add_lib_path/) {\n                        print_error (\"$file:$.: using PerlACE::add_lib_path, use AddLibPath on the target\");\n                    }\n\n                    if (m/PerlACE::Run_Test/) {\n                        print_error (\"$file:$.: using PerlACE::Run_Test, use PerlACE::TestTarget\");\n                    }\n\n                    if (m/PerlACE::random_port/) {\n                        print_error (\"$file:$.: using PerlACE::random_port, use TestTarget::random_port\");\n                    }\n\n                    if (m/PerlACE::Process/) {\n                        print_error (\"$file:$.: using PerlACE::Process\");\n                    }\n\n                    if (m/PerlACE::TestConfig/) {\n                        print_error (\"$file:$.: using PerlACE::TestConfig\");\n                    }\n\n                    if (m/ACE_RUN_VX_TGTHOST/) {\n                        print_error (\"$file:$.: using ACE_RUN_VX_TGTHOST, use TestTarget::HostName\");\n                    }\n\n                    if (m/Spawn(Wait(Kill)?)?\\s*\\(.+\\->ProcessStop.*\\)/) {\n                        print_error (\"$file:$.: uses Stop together with Spawn\");\n                    }\n\n                    if (m/Spawn(Wait(Kill)?)?\\s*\\(\\d+\\)/) {\n                        print_error (\"$file:$.: uses hardcoded timeout for Spawn\");\n                    }\n\n                    if (m/Kill\\s*\\(\\d+\\)/) {\n                        print_error (\"$file:$.: uses hardcoded timeout for Kill\");\n                    }\n\n                    if (m/unlink/) {\n                        print_error (\"$file:$.: using unlink\");\n                    }\n\n                    if (m/PerlACE::LocalFile/) {\n                        print_error (\"$file:$.: using PerlACE::LocalFile\");\n                    }\n\n                    if (m/\\$DIR_SEPARATOR/) {\n                        print_error (\"$file:$.: using \\$DIR_SEPARATOR\");\n                    }\n                    if (m/ACE\\:\\:/ && !m/PerlACE\\:\\:/) {\n                        print_error (\"$file:$.: using ACE::*\");\n                    }\n\n                    if (m/Process\\:\\:/ && !m/PerlACE\\:\\:Process\\:\\:/) {\n                        print_error (\"$file:$.: using Process::*\");\n                    }\n\n                    if (m/Process\\:\\:Create/) {\n                        print_error (\"$file:$.: using Process::Create\");\n                    }\n\n                    if (m/^  [^ ]/) {\n                        print_warning (\"$file:$.: using two-space indentation\");\n                    }\n\n                    if (m/^\\s*\\t/) {\n                        print_error (\"$file:$.: Indenting using tabs\");\n                    }\n\n                    if (m/^\\s*\\{/ && $sub != 1) {\n                        print_warning (\"$file:$.: Using Curly Brace alone\");\n                    }\n\n                    if (m/timedout/i && !m/\\#/) {\n                        print_error (\"$file:$.: timedout message found\");\n                    }\n\n                    if (m/^\\s*sub/) {\n                        $sub = 1;\n                    }\n                    else {\n                        $sub = 0;\n                    }\n                }\n            }\n\n            close (FILE);\n\n            if ($is_run_test) {\n                my @output = `perl -wc $file 2>&1`;\n\n                foreach $output (@output) {\n                    chomp $output;\n                    if ($output =~ m/error/i) {\n                        print_error ($output);\n                    }\n                    elsif ($output !~ m/syntax OK/) {\n                        print_warning ($output);\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n# Check for links to ~schmidt/ACE_wrappers/, which should not be in the\n# documentation\nsub check_for_absolute_ace_wrappers()\n{\n    return if is_suppressed ();\n\n    print \"Running absolute ACE_wrappers test\\n\";\n    foreach $file (@files_html) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (m/\\~schmidt\\/ACE_wrappers\\//) {\n                    chomp;\n                    print_error (\"$file:$.: ~schmidt/ACE_wrappers found\");\n                    print_error ($_);\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# Check for generated headers in the code documentation\nsub check_for_generated_headers()\n{\n    return if is_suppressed ();\n\n    print \"Running generated headers test\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (m/Code generated by the The ACE ORB \\(TAO\\) IDL Compiler/) {\n                    chomp;\n                    print_error (\"$file:$.: header found\");\n                    print_error ($_);\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_numeric_log()\n{\n    return if is_suppressed ();\n\n    print \"Running check for numeric flags in DAnCE and DDS4CCM\\n\";\n\n    foreach $file (@files_inl, @files_cpp, @files_h) {\n        if (open (FILE, $file)) {\n            while (<FILE>) {\n                # look for debug statements\n                if (m/DANCE_DEBUG\\s*\\(\\s*\\d*\\s*,/) {\n                    print_warning (\"$file:$.: Found numeric log level in debug statement\");\n                }\n                if (m/DANCE_ERROR\\s*\\(\\s*\\d\\s*,/) {\n                    print_warning (\"$file:$.: Found numeric log level in error statement\");\n                }\n                if (m/DANCE_TRACE_LOG\\s*\\(\\s*\\d\\s*,/) {\n                    print_warning (\"$file:$.: Found numeric log level in trace log statement\");\n                }\n                if (m/DDS4CCM_DEBUG\\s*\\(\\s*\\d*\\s*,/) {\n                    print_warning (\"$file:$.: Found numeric log level in debug statement\");\n                }\n                if (m/DDS4CCM_ERROR\\s*\\(\\s*\\d\\s*,/) {\n                    print_warning (\"$file:$.: Found numeric log level in error statement\");\n                }\n            }\n\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# Make sure ACE_[OS_]TRACE matches the function/method\nsub check_for_bad_ace_trace()\n{\n    return if is_suppressed ();\n\n    print \"Running TRACE test\\n\";\n    foreach $file (@files_inl, @files_cpp) {\n        if (open (FILE, $file)) {\n            my $class;\n            my $function;\n\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n\n                # look for methods or functions\n                if (m/(^[^\\s][^\\(]*)\\:\\:([^\\:^\\(]*[^\\s^\\(])\\s*/) {\n                    $class = $1;\n                    $function = $2;\n                }\n                elsif (m/^([^\\s^\\(^\\#]*) \\(/i) {\n                    $class = \"\";\n                    $function = $1;\n                }\n                elsif (m/^(operator.*) \\(/i) {\n                    $class = \"\";\n                    $function = $1;\n                }\n                elsif (m/^class (.*)\\s*:/) {\n                    $class = $1;\n                    $function = \"\";\n                }\n                elsif (m/^class (.*)\\s*$/) {\n                    $class = $1;\n                    $function = \"\";\n                }\n\n                # print \"TRACE_CHECK. Class = $class\\n\";\n\n                # Look for TRACE statements\n                if (m/ACE_OS_TRACE\\s*\\(\\s*\\\"(.*)\\\"/\n                    || m/ACE_TRACE\\s*\\(\\s*\\\"(.*)\\\"/\n                    || m/CIAO_TRACE\\s*\\(\\s*\\\"(.*)\\\"/\n                    || m/DANCE_TRACE\\s*\\(\\s*\\\"(.*)\\\"/\n                    || m/DDS4CCM_TRACE\\s*\\(\\s*\\\"(.*)\\\"/) {\n                    my $trace = $1;\n\n                    # reduce the classname\n                    if ($class =~ m/([^\\s][^\\<^\\s]*)\\s*\\</) {\n                        $class = $1;\n                   }\n\n                    # print \"TRACE_CHECK. Found a trace. Class = $class\\n\";\n\n                    if ($class =~ m/([^\\s^\\&^\\*]*)\\s*$/) {\n                        $class = $1;\n                    }\n\n                    # print \"TRACE_CHECK. Augmenting class. Class = $class\\n\";\n\n                    if ($trace !~ m/\\Q$function\\E/\n                        || ($trace =~ m/\\:\\:/ && !($trace =~ m/\\Q$class\\E/ && $trace =~ m/\\Q$function\\E/))) {\n                        print_error (\"$file:$.: Mismatched TRACE\");\n                        print_error (\"$file:$.:   I see \\\"$trace\\\" but I think I'm in \\\"\"\n                                     . $class . \"::\" . $function . \"\\\"\");\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_deprecated_macros ()\n{\n    return if is_suppressed ();\n\n    ## Take the current working directory and remove everything up to\n    ## ACE_wrappers (or ACE for the peer-style checkout).  This will be\n    ## used to determine when the use of ACE_THROW_SPEC is an error.\n    my($cwd) = getcwd();\n    if ($cwd =~ s/.*(ACE_wrappers)/$1/) {\n    }\n    elsif ($cwd =~ s/.*(ACE)/$1/) {\n    }\n\n    print \"Running deprecated macros check\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n              if (/ACE_THROW_SPEC/) {\n                  ## Do not use ACE_THROW_SPEC in TAO or CIAO.\n                  if ($file =~ /TAO|CIAO/i || $cwd =~ /TAO|CIAO/i) {\n                      print_error (\"$file:$.: ACE_THROW_SPEC found.\");\n                  }\n              }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n# This test checks for ptr_arith_t usage in source code.  ptr_arith_t\n# is non-portable.  Use ptrdiff_t instead.\nsub check_for_ptr_arith_t ()\n{\n    return if is_suppressed ();\n\n    print \"Running ptr_arith_t check\\n\";\n    foreach $file (@files_cpp, @files_inl, @files_h) {\n        if (open (FILE, $file)) {\n\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n\n                next if m/^\\s*\\/\\//;  # Ignore C++ comments.\n                next if m/^\\s*$/;     # Skip lines only containing\n                                      # whitespace.\n\n                # Check for ptr_arith_t usage.  This test should\n                # ignore typedefs, and should only catch variable\n                # declarations and parameter types.\n                if (m/ptr_arith_t / || m/ptr_arith_t,/) {\n                    print_error (\"$file:$.: ptr_arith_t; use ptrdiff_t instead.\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the #include <ace/...>\n# This check is suggested by Don Hinton to force user to use\n# \" \" instead of <> to avoid confict with Doxygen.\nsub check_for_include ()\n{\n    return if is_suppressed ();\n\n    print \"Running the include check\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl, @files_idl) {\n        my $bad_occurance = 0;\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_include/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_include/) {\n                    $disable = 0;\n                }\n                if ($disable == 0) {\n                    if (/^\\s*#\\s*include\\s*<[(ace)|(TAO)|(CIAO)]\\/.*>/) {\n                        print_error (\"$file:$.: include <ace\\/..> used\");\n                        ++$bad_occurance;\n                    }\n                    if (/^\\s*#\\s*include\\s*<tao\\/.*>/) {\n                        print_error (\"$file:$.: include <tao\\/..> used\");\n                        ++$bad_occurance;\n                    }\n                    if (/^\\s*#\\s*include\\s*<ciao\\/.*>/) {\n                        print_error (\"$file:$.: include <ciao\\/..> used\");\n                        ++$bad_occurance;\n                    }\n                }\n            }\n            close (FILE);\n\n            if ($disable == 0 && $bad_occurance > 0 ) {\n                print_error (\"$file:1: found $bad_occurance usage(s) of #include <> of ace\\/tao\\/ciao.\");\n            }\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test verifies that all equality, relational and logical\n# operators return bool, as is the norm for modern C++.\n#\n# NOTE:  This test isn't fool proof yet.\nsub check_for_non_bool_operators ()\n{\n    return if is_suppressed ();\n\n    print \"Running non-bool equality, relational and logical operator check\\n\";\n    foreach $file (@files_h, @files_inl, @files_cpp) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            my $found_bool = 0;\n            my $found_return_type = 0;\n            while (<FILE>) {\n\n                if ($found_bool == 0\n                    && (/[^\\w]bool\\s*$/\n                        || /^bool\\s*$/\n                        || /\\sbool\\s+\\w/\n                        || /^bool\\s+\\w/\n                        || /[^\\w]return\\s*$/))\n                  {\n                    $found_bool = 1;\n                    $found_return_type = 0;\n                    next;\n                  }\n\n                if ($found_bool == 0 && $found_return_type == 0\n                    && /^(?:\\w+|\\s+\\w+)\\s*$/\n                    && !/[^\\w]return\\s*$/)\n                  {\n                    $found_return_type = 1;\n                    $found_bool = 0;\n                    next;\n                  }\n\n                if ($found_bool == 0\n                    && /(?<![^\\w]bool)(\\s+|\\w+::|>\\s*::)operator\\s*(?:!|<|<=|>|>=|==|!=|&&|\\|\\|)\\s*\\(/\n                    && !/\\(.*operator\\s*(?:!|<|<=|>|>=|==|!=|&&|\\|\\|)\\s*\\(/\n                    && !/^\\s*return\\s+/) {\n                    print_error (\"$file:$.: non-bool return type for operator\");\n                }\n\n                $found_return_type = 0;\n                $found_bool = 0;\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test verifies that all filenames are short enough\nsub check_for_long_file_names ()\n{\n    return if is_suppressed ();\n\n    my $max_filename = 50;\n    my $max_mpc_projectname = $max_filename - 12; ## GNUmakefile.[project_name]\n    print \"Running file names check\\n\";\n\n    foreach $file (@files_cpp, @files_inl, @files_h, @files_html,\n                   @files_dsp, @files_dsw, @files_gnu, @files_idl,\n                   @files_pl, @files_changelog, @files_makefile,\n                   @files_bor, @files_mpc, @files_generic) {\n        if ( length( basename($file) ) >= $max_filename )\n        {\n            print_error (\"File name $file meets or exceeds $max_filename chars.\");\n        }\n    }\n    foreach $file (grep(/\\.mpc$/, @files_mpc)) {\n      if (open(FH, $file)) {\n        my($blen) = length(basename($file)) - 4; ## .mpc\n        while(<FH>) {\n          if (/project\\s*(:.*)\\s*{/) {\n            if ($blen >= $max_mpc_projectname) {\n              print_warning (\"File name $file meets or exceeds $max_mpc_projectname chars.\");\n            }\n          }\n          elsif (/project\\s*\\(([^\\)]+)\\)/) {\n            my($name) = $1;\n            if ($name =~ /\\*/) {\n              my($length) = length($name) + (($name =~ tr/*//) * $blen);\n              if ($length >= $max_mpc_projectname) {\n                print_warning (\"Project name ($name) from $file will meet or exceed $max_mpc_projectname chars when expanded by MPC.\");\n              }\n            }\n            else {\n              if (length($name) >= $max_mpc_projectname) {\n                print_warning (\"Project name ($name) from $file meets or exceeds $max_mpc_projectname chars.\");\n              }\n            }\n          }\n        }\n        close(FH);\n      }\n    }\n}\n\nsub check_for_refcountservantbase ()\n{\n    return if is_suppressed ();\n\n    print \"Running PortableServer::RefCountServantBase derivation check\\n\";\n\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n\n                if (/PortableServer::RefCountServantBase/) {\n                  print_error (\"$file:$.: reference to deprecated PortableServer::RefCountServantBase\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_old_documentation_style ()\n{\n    return if is_suppressed ();\n\n    print \"Running documentation style check\\n\";\n\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n\n                if (/\\/\\/\\s*\\= TITLE/) {\n                  print_error (\"$file:$.: found old documentation style // = TITLE\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_TAO_Local_RefCounted_Object ()\n{\n    return if is_suppressed ();\n\n    print \"Running TAO_Local_RefCounted_Object check\\n\";\n\n    ITERATION: foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_TAO_Local_RefCounted_Object/) {\n                    $disable = 1;\n                }\n                if (/FUZZ\\: enable check_for_TAO_Local_RefCounted_Object/) {\n                    $disable = 0;\n                }\n\n                if ($disable == 0 and /TAO_Local_RefCounted_Object/) {\n                  print_error (\"$file:$.: TAO_Local_RefCounted_Object is deprecated, use CORBA::LocalObject instead\");\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the correct use of ORB_init() so as\n# to be compatible with wide character builds.\nsub check_for_ORB_init ()\n{\n    return if is_suppressed ();\n\n    print \"Running the ORB_init() wide character incompatibility check\\n\";\n    foreach $file (@files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            my $multi_line;\n            my $not_found_end_line_count= 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (!defined $multi_line) {\n                    if (/FUZZ\\: disable check_for_ORB_init/) {\n                        $disable = 1;\n                        next;\n                    }\n                    elsif (/FUZZ\\: enable check_for_ORB_init/) {\n                        $disable = 0;\n                        next;\n                    }\n                    elsif ($disable == 0) {\n                        s/^\\s+//;           ## Remove leading space\n                        s/\\s*(\\/\\/.*)?$//;  ## Remove trailling space and line comments\n                        if (s/^([^=]*=)?\\s*(CORBA\\s*::\\s*)?ORB_init\\s*//) {\n                            $multi_line = $_; ## Rest of the line\n                        }\n                        else {\n                            next;\n                        }\n                    }\n                }\n                else {\n                    $_ =~ s/^\\s+//;           ## Remove leading space\n                    $_ =~ s/\\s*(\\/\\/.*)?$//;  ## Remove trailling space and line comments\n                    if ($multi_line eq \"\") {  ## Append this line to existing statement.\n                        $multi_line = $_;\n                    }\n                    else {\n                        $multi_line .= ' ' . $_;\n                    }\n                }\n                my $testing = $multi_line;\n                if ($testing =~ s/^\\(([^\\\"\\/\\)]*(\\\"([^\\\"\\\\]*(\\\\.)*)\\\")?(\\/+\\*.*?\\*\\/\\s*)*)*\\)//) {\n                    # $testing has thrown away what we actually want, i.e.\n                    # we want to ignore what's left in $testing.\n\n                    $multi_line = substr ($multi_line, 0, -length ($testing));\n                    $multi_line =~ s!/\\*.*?\\*/! !g;  ## Remove any internal /* ... */ comments\n                    $multi_line =~ s!\\s{2,}! !g;     ## collapse multi spaces\n                    $multi_line =~ s/^\\(\\s*//;       ## Trim leading ( and space\n                    $multi_line =~ s/\\s*\\)$//;       ## Trim trailing space and )\n\n                    if ($multi_line =~ s/^[^,]*,\\s*//) { # If this fails there is only 1 parameter (which we will ignore)\n                        # 1st parameter has been removed by the above, split up remaining 2 & 3\n                        $multi_line =~ s/^([^,]*),?\\s*//;\n                        my $param2 = $1;\n                        $param2 =~ s/\\s+$//; # Trim trailing spaces\n\n                        print_error (\"$file:$.: ORB_init() 2nd parameter requires static_cast<ACE_TCHAR **>(0)\") if ($param2 eq '0');\n                        print_error (\"$file:$.: ORB_init() 3rd parameter is redundant (default orbID or give as string)\") if ($multi_line eq '0');\n                        print_error (\"$file:$.: ORB_init() 3rd parameter is redundant (default orbID already \\\"\\\")\") if ($multi_line eq '\"\"');\n                    }\n\n                    undef $multi_line;\n                    $not_found_end_line_count = 0;\n                }\n                elsif ($not_found_end_line_count < 10) { # Limit the search for ( ... ) following ORB_init to ten lines\n                    ++$not_found_end_line_count;\n                }\n                else {\n                    undef $multi_line;\n                    $not_found_end_line_count = 0;\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\n# This test checks for the presence of an include for ace/OS.h\n# which should never occur. Only user code is allowed to include OS.h.\nsub check_for_include_OS_h ()\n{\n    return if is_suppressed ();\n\n    print \"Running the OS.h inclusion check\\n\";\n    foreach $file (@files_h, @files_cpp, @files_inl) {\n        if (open (FILE, $file)) {\n            my $disable = 0;\n            print \"Looking at file $file\\n\" if $opt_d;\n            while (<FILE>) {\n                if (/FUZZ\\: disable check_for_include_OS_h/) {\n                    $disable = 1;\n                    next;\n                }\n                elsif (/FUZZ\\: enable check_for_include_OS_h/) {\n                    $disable = 0;\n                    next;\n                }\n                elsif ($disable == 0 and /^\\s*#\\s*include\\s*<[(ace)|(TAO)|(CIAO)]\\/.*>/) {\n                    print_error (\"$file:$.: include <ace\\/..> used\");\n                }\n                else {\n                    if ($disable == 0 and /^\\s*#\\s*include\\s*\"ace\\/OS.h\"/) {\n                        print_error (\"$file:$.: include ace/OS.h used\");\n                    }\n                }\n            }\n            close (FILE);\n        }\n        else {\n            print STDERR \"Error: Could not open $file\\n\";\n        }\n    }\n}\n\nsub check_for_ace_log_categories ()\n{\n    return if is_suppressed ();\n\n    print \"Running the ACE log categories check\\n\";\n\n    my @macros = qw/HEX_DUMP ERROR ERROR_RETURN ERROR_BREAK DEBUG/;\n    my $macros = join ('|', @macros);\n\n    for my $f (@files_h, @files_cpp, @files_inl) {\n        my $cat = 'ACE';\n        $f =~ s!\\\\!/!g;\n        if ($f =~ /\\bace\\/(\\w+)/) {\n            next if $1 eq 'Log_Msg' || $` =~ /\\/protocols\\/$/;\n            $cat = 'ACELIB';\n        }\n        elsif ($f =~ /tao\\// && $f !~ /interop-tests\\//) {\n            $cat = 'TAOLIB';\n        }\n        elsif ($f =~ /\\/orbsvcs\\// && $f !~ /tests|examples/i) {\n            $cat = 'ORBSVCS';\n        }\n        elsif ($f =~ /CIAO\\// || $f =~ /DAnCE\\//) {\n            next;\n        }\n        elsif ($f =~ /tests\\/Log_Msg_Test\\.cpp/) {\n            next;\n        }\n\n        if (open (IN, $f)) {\n            print \"Looking at file $f for category $cat\\n\" if $opt_d;\n            my $disable = 0;\n            while (<IN>) {\n                if (/FUZZ: disable check_for_ace_log_categories/) {\n                    $disable = 1;\n                    next;\n                }\n                elsif (/FUZZ: enable check_for_ace_log_categories/) {\n                    $disable = 0;\n                    next;\n                }\n                elsif ($disable == 0\n                       && /\\b(ACE|ACELIB|TAOLIB|ORBSVCS)_($macros)\\b/g\n                       && $1 ne $cat) {\n                    print_error (\"$f:$.: found log macro $1_$2, \"\n                                 . \"expecting ${cat}_$2\");\n                }\n            }\n            close IN;\n        }\n        else {\n            print STDERR \"Error: Could not open $f\\n\";\n        }\n    }\n}\n\n\n##############################################################################\n\nuse vars qw/$opt_c $opt_d $opt_x $opt_h $opt_l $opt_t $opt_s $opt_m/;\n\nif (!getopts ('cdx:hl:t:s:mv') || $opt_h) {\n    print \"fuzz.pl [-cdhm] [-l level] [-t test_names] [file1, file2, ...]\\n\";\n    print \"\\n\";\n    print \"    -c             only look at the files passed in\\n\";\n    print \"    -d             turn on debugging\\n\";\n    print \"    -x             specify comma-separated list of path masks\\n\";\n          \"                       (regex) to exclude\\n\";\n    print \"    -h             display this help\\n\";\n    print \"    -l level       set detection level (default = 5)\\n\";\n    print \"    -t test_names  specify comma-separated list of tests to run\\n\".\n          \"                       this will disable the run level setting\\n\";\n    print \"    -s test_names  specify comma-separated list of tests to suppress\\n\".\n          \"                       this will supplement the run level setting\\n\";\n    print \"    -m             only check locally modified files (uses git)\\n\";\n    print \"======================================================\\n\";\n    print \"list of the tests that could be run or suppressed:\\n\";\n    print <<EOT;\n           check_for_noncvs_files\n           check_for_generated_headers\n           check_for_synch_include\n           check_for_streams_include\n           check_for_dependency_file\n           check_for_makefile_variable\n           check_for_inline_in_cpp\n           check_for_id_string\n           check_for_newline\n           check_for_ACE_SYNCH_MUTEX\n           check_for_ACE_Thread_Mutex\n           check_for_tab\n           check_for_exception_spec\n           check_for_NULL\n           check_for_improper_main_declaration\n           check_for_lack_ACE_OS\n           check_for_inline\n           check_for_math_include\n           check_for_line_length\n           check_for_preprocessor_comments\n           check_for_tchar\n           check_for_pre_and_post\n           check_for_push_and_pop\n           check_for_versioned_namespace_begin_end\n           check_for_mismatched_filename\n           check_for_bad_run_test\n           check_for_absolute_ace_wrappers\n           check_for_bad_ace_trace\n           check_for_ptr_arith_t\n           check_for_include (disabled by default)\n           check_for_non_bool_operators\n           check_for_long_file_names\n           check_for_refcountservantbase\n           check_for_TAO_Local_RefCounted_Object\n           check_for_ORB_init\n           check_for_trailing_whitespace\n           check_for_include_OS_h\n           check_for_numeric_log\n           check_for_ORB_init\n           check_for_old_documentation_style\n           check_for_ace_log_categories\nEOT\n    exit (1);\n}\n\nif (!$opt_l) {\n    $opt_l = 5;\n}\n\n# Before opt_m is read!\nif ($opt_x) {\n    my @excludes = split '\\s*,\\s*', $opt_x;\n    for my $exclude (@excludes) {\n      push (@excluded_dirs, $exclude);\n    }\n}\n\nif ($opt_c) {\n    foreach $file (@ARGV) {\n        store_file ($file);\n    }\n}\nelsif ($opt_m) {\n    find_mod_files ();\n}\nelse {\n    find_files ();\n}\n\nif ($opt_t) {\n    my @tests = split '\\s*,\\s*', $opt_t;\n    for my $test (@tests) {\n      &$test();\n    }\n    print \"\\nfuzz.pl - $errors error(s), $warnings warning(s)\\n\";\n    exit ($errors > 0) ? 1 : 0;\n}\n\nif ($opt_s) {\n    my @tests = split '\\s*,\\s*', $opt_s;\n    for my $test (@tests) {\n      $suppressed_tests{$test} = 1;\n    }\n}\n\nprint \"--------------------Configuration: Fuzz - Level \",$opt_l,\n      \"--------------------\\n\";\n\ncheck_for_export_file () if ($opt_l >= 4);\ncheck_for_trailing_whitespace () if ($opt_l >= 4);\ncheck_for_lack_ACE_OS () if ($opt_l >= 6);\ncheck_for_ACE_Guard () if ($opt_l >= 1);\ncheck_for_generated_headers () if ($opt_l >= 6);\ncheck_for_bad_run_test () if ($opt_l >= 5);\ncheck_for_deprecated_macros () if ($opt_l >= 1);\ncheck_for_refcountservantbase () if ($opt_l >= 1);\ncheck_for_msc_ver_string () if ($opt_l >= 3);\ncheck_for_empty_files () if ($opt_l >= 1);\ncheck_for_noncvs_files () if ($opt_l >= 1);\ncheck_for_streams_include () if ($opt_l >= 6);\ncheck_for_dependency_file () if ($opt_l >= 1);\ncheck_for_makefile_variable () if ($opt_l >= 1);\ncheck_for_inline_in_cpp () if ($opt_l >= 2);\ncheck_for_id_string () if ($opt_l >= 1);\ncheck_for_newline () if ($opt_l >= 1);\ncheck_for_ACE_Thread_Mutex () if ($opt_l >= 1);\ncheck_for_ACE_SYNCH_MUTEX () if ($opt_l >= 1);\ncheck_for_tab () if ($opt_l >= 1);\ncheck_for_exception_spec () if ($opt_l >= 1);\ncheck_for_NULL () if ($opt_l >= 1);\ncheck_for_inline () if ($opt_l >= 2);\ncheck_for_math_include () if ($opt_l >= 3);\ncheck_for_synch_include () if ($opt_l >= 6);\ncheck_for_line_length () if ($opt_l >= 8);\ncheck_for_preprocessor_comments () if ($opt_l >= 7);\ncheck_for_tchar () if ($opt_l >= 4);\ncheck_for_pre_and_post () if ($opt_l >= 4);\ncheck_for_push_and_pop () if ($opt_l >= 4);\ncheck_for_versioned_namespace_begin_end () if ($opt_l >= 4);\ncheck_for_mismatched_filename () if ($opt_l >= 2);\ncheck_for_absolute_ace_wrappers () if ($opt_l >= 3);\ncheck_for_bad_ace_trace () if ($opt_l >= 4);\ncheck_for_ptr_arith_t () if ($opt_l >= 4);\ncheck_for_non_bool_operators () if ($opt_l > 2);\ncheck_for_long_file_names () if ($opt_l >= 1);\ncheck_for_improper_main_declaration () if ($opt_l >= 1);\ncheck_for_TAO_Local_RefCounted_Object () if ($opt_l >= 1);\ncheck_for_include_OS_h () if ($opt_l >= 1);\ncheck_for_numeric_log () if ($opt_l >= 3);\ncheck_for_ORB_init () if ($opt_l >= 1);\ncheck_for_old_documentation_style () if ($opt_l >= 6);\ncheck_for_ace_log_categories () if ($opt_l >= 5);\n\nprint \"\\nfuzz.pl - $errors error(s), $warnings warning(s)\\n\";\n\nexit (1) if $errors > 0;\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/Strategies_T.cpp": "#ifndef ACE_STRATEGIES_T_CPP\n#define ACE_STRATEGIES_T_CPP\n\n#include \"ace/Strategies_T.h\"\n\n#if !defined (ACE_LACKS_PRAGMA_ONCE)\n# pragma once\n#endif /* ACE_LACKS_PRAGMA_ONCE */\n\n#include \"ace/Service_Repository.h\"\n#include \"ace/Service_Types.h\"\n#include \"ace/Thread_Manager.h\"\n#include \"ace/WFMO_Reactor.h\"\n#include \"ace/ACE.h\"\n#include \"ace/OS_NS_dlfcn.h\"\n#include \"ace/OS_NS_string.h\"\n#include \"ace/OS_Errno.h\"\n#include \"ace/Svc_Handler.h\"\n#if defined (ACE_OPENVMS)\n# include \"ace/Lib_Find.h\"\n#endif\n\n#if !defined (__ACE_INLINE__)\n#include \"ace/Strategies_T.inl\"\n#endif /* __ACE_INLINE__ */\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\ntemplate<class SVC_HANDLER>\nACE_Recycling_Strategy<SVC_HANDLER>::~ACE_Recycling_Strategy (void)\n{\n}\n\ntemplate<class SVC_HANDLER> int\nACE_Recycling_Strategy<SVC_HANDLER>::assign_recycler (SVC_HANDLER *svc_handler,\n                                                      ACE_Connection_Recycling_Strategy *recycler,\n                                                      const void *recycling_act)\n{\n  svc_handler->recycler (recycler, recycling_act);\n  return 0;\n}\n\ntemplate<class SVC_HANDLER> int\nACE_Recycling_Strategy<SVC_HANDLER>::prepare_for_recycling (SVC_HANDLER *svc_handler)\n{\n  return svc_handler->recycle ();\n}\n\ntemplate <class SVC_HANDLER>\nACE_Singleton_Strategy<SVC_HANDLER>::~ACE_Singleton_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Singleton_Strategy<SVC_HANDLER>::~ACE_Singleton_Strategy\");\n  if (this->delete_svc_handler_)\n    delete this->svc_handler_;\n}\n\n// Create a Singleton SVC_HANDLER by always returning the same\n// SVC_HANDLER.\n\ntemplate <class SVC_HANDLER> int\nACE_Singleton_Strategy<SVC_HANDLER>::make_svc_handler (SVC_HANDLER *&sh)\n{\n  ACE_TRACE (\"ACE_Singleton_Strategy<SVC_HANDLER>::make_svc_handler\");\n  sh = this->svc_handler_;\n  return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Singleton_Strategy<SVC_HANDLER>::open (SVC_HANDLER *sh,\n                                           ACE_Thread_Manager *)\n{\n  ACE_TRACE (\"ACE_Singleton_Strategy<SVC_HANDLER>::open\");\n\n  if (this->delete_svc_handler_)\n    delete this->svc_handler_;\n\n  // If <sh> is NULL then create a new <SVC_HANDLER>.\n  if (sh == 0)\n    {\n      ACE_NEW_RETURN (this->svc_handler_,\n                      SVC_HANDLER,\n                      -1);\n      this->delete_svc_handler_ = true;\n    }\n  else\n    {\n      this->svc_handler_ = sh;\n      this->delete_svc_handler_ = false;\n    }\n\n  return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_DLL_Strategy<SVC_HANDLER>::open (const ACE_TCHAR dll_name[],\n                                     const ACE_TCHAR factory_function[],\n                                     const ACE_TCHAR svc_name[],\n                                     ACE_Service_Repository *svc_rep,\n                                     ACE_Thread_Manager *thr_mgr)\n{\n  ACE_TRACE (\"ACE_DLL_Strategy<SVC_HANDLER>::open\");\n  this->inherited::open (thr_mgr);\n  ACE_OS::strcpy (this->dll_name_, dll_name);\n  ACE_OS::strcpy (this->factory_function_, factory_function);\n  ACE_OS::strcpy (this->svc_name_, svc_name);\n  this->svc_rep_ = svc_rep;\n  return 0;\n}\n\n// Create a SVC_HANDLER by dynamically linking it from a DLL.\n\ntemplate <class SVC_HANDLER> int\nACE_DLL_Strategy<SVC_HANDLER>::make_svc_handler (SVC_HANDLER *&sh)\n{\n  ACE_TRACE (\"ACE_DLL_Strategy<SVC_HANDLER>::make_svc_handler\");\n\n  // Open the shared library.\n  ACE_SHLIB_HANDLE handle = ACE_OS::dlopen (this->dll_name_);\n\n  // Extract the factory function.\n#if defined (ACE_OPENVMS)\n  SVC_HANDLER *(*factory)(void) =\n    (SVC_HANDLER *(*)(void)) ACE::ldsymbol (handle,\n                                            this->factory_function_);\n#else\n  SVC_HANDLER *(*factory)(void) =\n    (SVC_HANDLER *(*)(void)) ACE_OS::dlsym (handle,\n                                            this->factory_function_);\n#endif\n\n  // Call the factory function to obtain the new SVC_Handler (should\n  // use RTTI here when it becomes available...)\n  SVC_HANDLER *svc_handler = 0;\n\n  ACE_ALLOCATOR_RETURN (svc_handler, (*factory)(), -1);\n\n  if (svc_handler != 0)\n    {\n      // Create an ACE_Service_Type containing the SVC_Handler and\n      // insert into this->svc_rep_;\n\n      ACE_Service_Type_Impl *stp = 0;\n      ACE_NEW_RETURN (stp,\n                      ACE_Service_Object_Type (svc_handler,\n                                               this->svc_name_),\n                      -1);\n\n      ACE_Service_Type *srp = 0;\n\n      ACE_NEW_RETURN (srp,\n                      ACE_Service_Type (this->svc_name_,\n                                        stp,\n                                        handle,\n                                        1),\n                      -1);\n      if (srp == 0)\n        {\n          delete stp;\n          errno = ENOMEM;\n          return -1;\n        }\n\n      if (this->svc_rep_->insert (srp) == -1)\n        return -1;\n      // @@ Somehow, we need to deal with this->thr_mgr_...\n    }\n\n  sh = svc_handler;\n  return 0;\n}\n\n// Default behavior is to activate the SVC_HANDLER by calling it's\n// open() method, which allows the SVC_HANDLER to determine its own\n// concurrency strategy.\n\ntemplate <class SVC_HANDLER> int\nACE_Concurrency_Strategy<SVC_HANDLER>::activate_svc_handler (SVC_HANDLER *svc_handler,\n                                                             void *arg)\n{\n  ACE_TRACE (\"ACE_Concurrency_Strategy<SVC_HANDLER>::activate_svc_handler\");\n\n  int result = 0;\n\n  // See if we should enable non-blocking I/O on the <svc_handler>'s\n  // peer.\n  if (ACE_BIT_ENABLED (this->flags_, ACE_NONBLOCK) != 0)\n    {\n      if (svc_handler->peer ().enable (ACE_NONBLOCK) == -1)\n        result = -1;\n    }\n  // Otherwise, make sure it's disabled by default.\n  else if (svc_handler->peer ().disable (ACE_NONBLOCK) == -1)\n    result = -1;\n\n  if (result == 0 && svc_handler->open (arg) == -1)\n    result = -1;\n\n  if (result == -1)\n    // The connection was already made; so this close is a \"normal\" close\n    // operation.\n    svc_handler->close (NORMAL_CLOSE_OPERATION);\n\n  return result;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Reactive_Strategy<SVC_HANDLER>::open (ACE_Reactor *reactor,\n                                          ACE_Reactor_Mask mask,\n                                          int flags)\n{\n  ACE_TRACE (\"ACE_Reactive_Strategy<SVC_HANDLER>::open\");\n  this->reactor_ = reactor;\n  this->mask_ = mask;\n  this->flags_ = flags;\n\n  // Must have a <Reactor>\n  if (this->reactor_ == 0)\n    return -1;\n  else\n    return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Reactive_Strategy<SVC_HANDLER>::activate_svc_handler (SVC_HANDLER *svc_handler,\n                                                          void *arg)\n{\n  ACE_TRACE (\"ACE_Reactive_Strategy<SVC_HANDLER>::activate_svc_handler\");\n\n  int result = 0;\n\n  if (this->reactor_ == 0)\n    result = -1;\n\n  // Register with the Reactor with the appropriate <mask>.\n  else if (this->reactor_->register_handler (svc_handler, this->mask_) == -1)\n    result = -1;\n\n  // If the implementation of the reactor uses event associations\n  else if (this->reactor_->uses_event_associations ())\n    {\n      // If we don't have non-block on, it won't work with\n      // WFMO_Reactor\n      // This maybe too harsh\n      // if (!ACE_BIT_ENABLED (this->flags_, ACE_NONBLOCK))\n      // goto failure;\n      if (svc_handler->open (arg) != -1)\n        return 0;\n      else\n        result = -1;\n    }\n  else\n    // Call up to our parent to do the SVC_HANDLER initialization.\n    return this->inherited::activate_svc_handler (svc_handler, arg);\n\n  if (result == -1)\n    // The connection was already made; so this close is a \"normal\" close\n    // operation.\n    svc_handler->close (NORMAL_CLOSE_OPERATION);\n\n  return result;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Thread_Strategy<SVC_HANDLER>::open (ACE_Thread_Manager *thr_mgr,\n                                        long thr_flags,\n                                        int n_threads,\n                                        int flags)\n{\n  ACE_TRACE (\"ACE_Thread_Strategy<SVC_HANDLER>::open\");\n  this->thr_mgr_ = thr_mgr;\n  this->n_threads_ = n_threads;\n  this->thr_flags_ = thr_flags;\n  this->flags_ = flags;\n\n  // Must have a thread manager!\n  if (this->thr_mgr_ == 0)\n    ACELIB_ERROR_RETURN ((LM_ERROR,\n                       ACE_TEXT (\"error: must have a non-NULL thread manager\\n\")),\n                      -1);\n  else\n    return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Thread_Strategy<SVC_HANDLER>::activate_svc_handler (SVC_HANDLER *svc_handler,\n                                                        void *arg)\n{\n  ACE_TRACE (\"ACE_Thread_Strategy<SVC_HANDLER>::activate_svc_handler\");\n  // Call up to our parent to do the SVC_HANDLER initialization.\n  if (this->inherited::activate_svc_handler (svc_handler,\n                                             arg) == -1)\n    return -1;\n  else\n    // Turn the <svc_handler> into an active object (if it isn't\n    // already one as a result of the first activation...)\n    return svc_handler->activate (this->thr_flags_,\n                                  this->n_threads_);\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1> int\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::open\n  (const ACE_PEER_ACCEPTOR_ADDR &local_addr, bool reuse_addr)\n{\n  this->reuse_addr_ = reuse_addr;\n  this->peer_acceptor_addr_ = local_addr;\n  if (this->peer_acceptor_.open (local_addr, reuse_addr) == -1)\n    return -1;\n\n  // Set the peer acceptor's handle into non-blocking mode.  This is a\n  // safe-guard against the race condition that can otherwise occur\n  // between the time when <select> indicates that a passive-mode\n  // socket handle is \"ready\" and when we call <accept>.  During this\n  // interval, the client can shutdown the connection, in which case,\n  // the <accept> call can hang!\n  if (this->peer_acceptor_.enable (ACE_NONBLOCK) == -1)\n    return -1;\n\n  return 0;\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1>\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::ACE_Accept_Strategy\n  (const ACE_PEER_ACCEPTOR_ADDR &local_addr,\n   bool reuse_addr,\n   ACE_Reactor *reactor)\n    : reactor_ (reactor)\n{\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::ACE_Accept_Strategy\");\n\n  if (this->open (local_addr, reuse_addr) == -1)\n    ACELIB_ERROR ((LM_ERROR,\n                ACE_TEXT (\"%p\\n\"),\n                ACE_TEXT (\"open\")));\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1> int\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::accept_svc_handler\n  (SVC_HANDLER *svc_handler)\n{\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::accept_svc_handler\");\n\n  // Try to find out if the implementation of the reactor that we are\n  // using requires us to reset the event association for the newly\n  // created handle. This is because the newly created handle will\n  // inherit the properties of the listen handle, including its event\n  // associations.\n  bool reset_new_handle = this->reactor_->uses_event_associations ();\n\n  if (this->peer_acceptor_.accept (svc_handler->peer (), // stream\n                                   0, // remote address\n                                   0, // timeout\n                                   1, // restart\n                                   reset_new_handle  // reset new handler\n                                   ) == -1)\n    {\n      // Ensure that errno is preserved in case the svc_handler\n      // close() method resets it\n      ACE_Errno_Guard error(errno);\n\n      // Close down handler to avoid memory leaks.\n      svc_handler->close (CLOSE_DURING_NEW_CONNECTION);\n\n      return -1;\n    }\n  else\n    return 0;\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_CONNECTOR_1> int\nACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connect_svc_handler\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms)\n{\n  ACE_TRACE (\"ACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connect_svc_handler\");\n\n  return this->connector_.connect (sh->peer (),\n                                   remote_addr,\n                                   timeout,\n                                   local_addr,\n                                   reuse_addr,\n                                   flags,\n                                   perms);\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_CONNECTOR_1> int\nACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connect_svc_handler\n(SVC_HANDLER *&sh,\n SVC_HANDLER *&sh_copy,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms)\n{\n  ACE_TRACE (\"ACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connect_svc_handler\");\n\n  int const result =\n    this->connector_.connect (sh->peer (),\n                              remote_addr,\n                              timeout,\n                              local_addr,\n                              reuse_addr,\n                              flags,\n                              perms);\n  sh_copy = sh;\n  return result;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Process_Strategy<SVC_HANDLER>::open (size_t n_processes,\n                                         ACE_Event_Handler *acceptor,\n                                         ACE_Reactor *reactor,\n                                         int avoid_zombies)\n{\n  ACE_TRACE (\"ACE_Process_Strategy<SVC_HANDLER>::open\");\n  this->n_processes_ = n_processes;\n  this->acceptor_ = acceptor;\n  this->reactor_ = reactor;\n  this->flags_ = avoid_zombies;\n\n  return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Process_Strategy<SVC_HANDLER>::activate_svc_handler (SVC_HANDLER *svc_handler,\n                                                         void *arg)\n{\n  ACE_TRACE (\"ACE_Process_Strategy<SVC_HANDLER>::activate_svc_handler\");\n\n  // If <flags_> is non-0 then we won't create zombies.\n  switch (ACE::fork (ACE_TEXT (\"child\"), this->flags_))\n    {\n    case static_cast<pid_t>(-1):\n      {\n        ACE_Errno_Guard error (errno);\n        svc_handler->close ();\n      }\n      ACELIB_ERROR_RETURN ((LM_ERROR,\n                         ACE_TEXT (\"%p\\n\"),\n                         ACE_TEXT (\"fork\")),\n                        -1);\n      /* NOTREACHED */\n    case 0: // In child process.\n\n      // Close down the SOCK_Acceptor's handle since we don't need to\n      // keep it open.\n      if (this->acceptor_ != 0)\n        // Ignore the return value here...\n        (void) this->reactor_->remove_handler (this->acceptor_,\n                                               ACE_Event_Handler::ACCEPT_MASK);\n\n      // Call up to our ancestor in the inheritance to do the\n      // SVC_HANDLER initialization.\n      return this->inherited::activate_svc_handler (svc_handler, arg);\n      /* NOTREACHED */\n    default: // In parent process.\n      // We need to close down the <SVC_HANDLER> here because it's\n      // running in the child.\n      svc_handler->close ();\n      return 0;\n    }\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX>\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::ACE_Cached_Connect_Strategy\n(creation_strategy_type *cre_s,\n ACE_Concurrency_Strategy<SVC_HANDLER> *con_s,\n ACE_Recycling_Strategy<SVC_HANDLER> *rec_s,\n MUTEX *lock,\n bool delete_lock)\n  : lock_ (lock),\n    delete_lock_ (delete_lock),\n    reverse_lock_ (0),\n    creation_strategy_ (0),\n    delete_creation_strategy_ (false),\n    concurrency_strategy_ (0),\n    delete_concurrency_strategy_ (false),\n    recycling_strategy_ (0),\n    delete_recycling_strategy_ (false)\n{\n  // Create a new lock if necessary.\n  if (this->lock_ == 0)\n    {\n      ACE_NEW (this->lock_,\n               MUTEX);\n\n      this->delete_lock_ = true;\n    }\n\n  ACE_NEW (this->reverse_lock_,\n           REVERSE_MUTEX (*this->lock_));\n\n  if (this->open (cre_s,\n                  con_s,\n                  rec_s) == -1)\n    ACELIB_ERROR ((LM_ERROR,\n                ACE_TEXT (\"%p\\n\"),\n                ACE_TEXT (\"ACE_Cached_Connect_Strategy::ACE_Cached_Connect_Strategy\")));\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX>\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::~ACE_Cached_Connect_Strategy (void)\n{\n  if (this->delete_lock_)\n    delete this->lock_;\n\n  delete this->reverse_lock_;\n\n  if (this->delete_creation_strategy_)\n    delete this->creation_strategy_;\n  this->delete_creation_strategy_ = false;\n  this->creation_strategy_ = 0;\n\n  if (this->delete_concurrency_strategy_)\n    delete this->concurrency_strategy_;\n  this->delete_concurrency_strategy_ = false;\n  this->concurrency_strategy_ = 0;\n\n  if (this->delete_recycling_strategy_)\n    delete this->recycling_strategy_;\n  this->delete_recycling_strategy_ = false;\n  this->recycling_strategy_ = 0;\n\n  // Close down all cached service handlers.\n  CONNECTION_MAP_ENTRY *entry = 0;\n  for (CONNECTION_MAP_ITERATOR iterator (connection_map_);\n       iterator.next (entry);\n       iterator.advance ())\n    {\n      entry->int_id_->recycler (0, 0);\n      entry->int_id_->close ();\n    }\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::open\n(creation_strategy_type *cre_s,\n ACE_Concurrency_Strategy<SVC_HANDLER> *con_s,\n ACE_Recycling_Strategy<SVC_HANDLER> *rec_s)\n{\n  // Initialize the creation strategy.\n\n  // First we decide if we need to clean up.\n  if (this->creation_strategy_ != 0 &&\n      this->delete_creation_strategy_ &&\n      cre_s != 0)\n    {\n      delete this->creation_strategy_;\n      this->creation_strategy_ = 0;\n      this->delete_creation_strategy_ = false;\n    }\n\n  if (cre_s != 0)\n    this->creation_strategy_ = cre_s;\n  else if (this->creation_strategy_ == 0)\n    {\n      ACE_NEW_RETURN (this->creation_strategy_,\n                      CREATION_STRATEGY, -1);\n      this->delete_creation_strategy_ = true;\n    }\n\n  // Initialize the concurrency strategy.\n\n  if (this->concurrency_strategy_ != 0 &&\n      this->delete_concurrency_strategy_ &&\n      con_s != 0)\n    {\n      delete this->concurrency_strategy_;\n      this->concurrency_strategy_ = 0;\n      this->delete_concurrency_strategy_ = false;\n    }\n\n  if (con_s != 0)\n    this->concurrency_strategy_ = con_s;\n  else if (this->concurrency_strategy_ == 0)\n    {\n      ACE_NEW_RETURN (this->concurrency_strategy_,\n                      CONCURRENCY_STRATEGY, -1);\n      this->delete_concurrency_strategy_ = true;\n    }\n\n  // Initialize the recycling strategy.\n\n  if (this->recycling_strategy_ != 0 &&\n      this->delete_recycling_strategy_ &&\n      rec_s != 0)\n    {\n      delete this->recycling_strategy_;\n      this->recycling_strategy_ = 0;\n      this->delete_recycling_strategy_ = false;\n    }\n\n  if (rec_s != 0)\n    this->recycling_strategy_ = rec_s;\n  else if (this->recycling_strategy_ == 0)\n    {\n      ACE_NEW_RETURN (this->recycling_strategy_,\n                      RECYCLING_STRATEGY, -1);\n      this->delete_recycling_strategy_ = true;\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::make_svc_handler\n  (SVC_HANDLER *&sh)\n{\n  return this->creation_strategy_->make_svc_handler (sh);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::activate_svc_handler\n  (SVC_HANDLER *svc_handler)\n{\n  return this->concurrency_strategy_->activate_svc_handler (svc_handler);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::assign_recycler\n  (SVC_HANDLER *svc_handler,\n   ACE_Connection_Recycling_Strategy *recycler,\n   const void *recycling_act)\n{\n  return this->recycling_strategy_->assign_recycler (svc_handler,\n                                                     recycler,\n                                                     recycling_act);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::prepare_for_recycling\n  (SVC_HANDLER *svc_handler)\n{\n  return this->recycling_strategy_->prepare_for_recycling (svc_handler);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::check_hint_i\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms,\n CONNECTION_MAP_ENTRY *&entry,\n int &found)\n{\n  ACE_UNUSED_ARG (remote_addr);\n  ACE_UNUSED_ARG (timeout);\n  ACE_UNUSED_ARG (local_addr);\n  ACE_UNUSED_ARG (reuse_addr);\n  ACE_UNUSED_ARG (flags);\n  ACE_UNUSED_ARG (perms);\n\n  found = 0;\n\n  // Get the recycling act for the svc_handler\n  CONNECTION_MAP_ENTRY *possible_entry = (CONNECTION_MAP_ENTRY *) sh->recycling_act ();\n\n  // Check to see if the hint svc_handler has been closed down\n  if (possible_entry->ext_id_.recycle_state () == ACE_RECYCLABLE_CLOSED)\n    {\n      // If close, decrement refcount\n      if (possible_entry->ext_id_.decrement () == 0)\n        {\n          // If refcount goes to zero, close down the svc_handler\n          possible_entry->int_id_->recycler (0, 0);\n          possible_entry->int_id_->close ();\n          this->purge_i (possible_entry);\n        }\n\n      // Hint not successful\n      found = 0;\n\n      // Reset hint\n      sh = 0;\n    }\n\n  // If hint is not closed, see if it is connected to the correct\n  // address and is recyclable\n  else if ((possible_entry->ext_id_.recycle_state () == ACE_RECYCLABLE_IDLE_AND_PURGABLE ||\n            possible_entry->ext_id_.recycle_state () == ACE_RECYCLABLE_IDLE_BUT_NOT_PURGABLE) &&\n           possible_entry->ext_id_.subject () == remote_addr)\n    {\n      // Hint successful\n      found = 1;\n\n      // Tell the <svc_handler> that it should prepare itself for\n      // being recycled.\n      this->prepare_for_recycling (sh);\n    }\n  else\n    {\n      // This hint will not be used.\n      possible_entry->ext_id_.decrement ();\n\n      // Hint not successful\n      found = 0;\n\n      // If <sh> is not connected to the correct address or is busy,\n      // we will not use it.\n      sh = 0;\n    }\n\n  if (found)\n    entry = possible_entry;\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::find_or_create_svc_handler_i\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms,\n CONNECTION_MAP_ENTRY *&entry,\n int &found)\n{\n  // Explicit type conversion\n  REFCOUNTED_HASH_RECYCLABLE_ADDRESS search_addr (remote_addr);\n\n  // Try to find the address in the cache.  Only if we don't find it\n  // do we create a new <SVC_HANDLER> and connect it with the server.\n  if (this->find (search_addr, entry) == -1)\n    {\n      // Set the flag\n      found = 0;\n\n      // We need to use a temporary variable here since we are not\n      // allowed to change <sh> because other threads may use this\n      // when we let go of the lock during the OS level connect.\n      //\n      // Note that making a new svc_handler, connecting remotely,\n      // binding to the map, and assigning of the hint and recycler\n      // should be atomic to the outside world.\n      SVC_HANDLER *potential_handler = 0;\n\n      // Create a new svc_handler\n      if (this->make_svc_handler (potential_handler) == -1)\n        return -1;\n\n      // Actively establish the connection.  This is a timed blocking\n      // connect.\n      if (this->new_connection (potential_handler,\n                                remote_addr,\n                                timeout,\n                                local_addr,\n                                reuse_addr,\n                                flags,\n                                perms) == -1)\n        {\n          // If connect() failed because of timeouts, we have to\n          // reject the connection entirely. This is necessary since\n          // currently there is no way for the non-blocking connects\n          // to complete and for the <Connector> to notify the cache\n          // of the completion of connect().\n          if (errno == EWOULDBLOCK)\n            errno = ENOTSUP;\n\n          // Close the svc handler.\n          potential_handler->close (0);\n\n          return -1;\n        }\n      else\n        {\n          // Insert the new SVC_HANDLER instance into the cache.\n          if (this->connection_map_.bind (search_addr,\n                                          potential_handler,\n                                          entry) == -1)\n            {\n              // Close the svc handler.\n              potential_handler->close (CLOSE_DURING_NEW_CONNECTION);\n\n              return -1;\n            }\n\n          // Everything succeeded as planned. Assign <sh> to <potential_handler>.\n          sh = potential_handler;\n\n          // Set the recycler and the recycling act\n          this->assign_recycler (sh, this, entry);\n        }\n    }\n  else\n    // We found a cached svc_handler.\n    {\n      // Set the flag\n      found = 1;\n\n      // Get the cached <svc_handler>\n      sh = entry->int_id_;\n\n      // Tell the <svc_handler> that it should prepare itself for\n      // being recycled.\n      this->prepare_for_recycling (sh);\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::new_connection\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms)\n{\n  // Yow, Reverse Guard!  Let go of the lock for the duration of the\n  // actual connect.  This will allow other threads to hack on the\n  // connection cache while this thread creates the new connection.\n  ACE_GUARD_RETURN (REVERSE_MUTEX, ace_mon, *this->reverse_lock_, -1);\n\n  return this->CONNECT_STRATEGY::connect_svc_handler (sh,\n                                                      remote_addr,\n                                                      timeout,\n                                                      local_addr,\n                                                      reuse_addr,\n                                                      flags,\n                                                      perms);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::connect_svc_handler\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms)\n{\n  int found = 0;\n\n  // This artificial scope is required since we need to let go of the\n  // lock *before* registering the newly created handler with the\n  // Reactor.\n  {\n    // Synchronization is required here as the setting of the\n    // recyclable state must be done atomically with the finding and\n    // binding of the service handler in the cache.\n    ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n    int result = this->connect_svc_handler_i (sh,\n                                              remote_addr,\n                                              timeout,\n                                              local_addr,\n                                              reuse_addr,\n                                              flags,\n                                              perms,\n                                              found);\n    if (result != 0)\n      return result;\n\n  }\n\n  // If it is a new connection, activate it.\n  //\n  // Note: This activation is outside the scope of the lock of the\n  // cached connector.  This is necessary to avoid subtle deadlock\n  // conditions with this lock and the Reactor lock.\n\n  if (!found)\n    {\n      if (this->activate_svc_handler (sh) == -1)\n        {\n          // If an error occurs while activating the handler, the\n          // <activate_svc_handler> method will close the handler.\n          // This in turn will remove this entry from the internal\n          // table.\n\n          // Synchronization is required here as the setting of the\n          // handler to zero must be done atomically with the users of\n          // the cache.\n          ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n          // Reset handler.\n          sh = 0;\n\n          return -1;\n        }\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::connect_svc_handler\n(SVC_HANDLER *&sh,\n SVC_HANDLER *&sh_copy,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms)\n{\n  int found = 0;\n\n  // This artificial scope is required since we need to let go of the\n  // lock *before* registering the newly created handler with the\n  // Reactor.\n  {\n    // Synchronization is required here as the setting of the\n    // recyclable state must be done atomically with the finding and\n    // binding of the service handler in the cache.\n    ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n    int result = this->connect_svc_handler_i (sh,\n                                              remote_addr,\n                                              timeout,\n                                              local_addr,\n                                              reuse_addr,\n                                              flags,\n                                              perms,\n                                              found);\n    sh_copy = sh;\n\n    if (result != 0)\n      return result;\n\n  }\n\n  // If it is a new connection, activate it.\n  //\n  // Note: This activation is outside the scope of the lock of the\n  // cached connector.  This is necessary to avoid subtle deadlock\n  // conditions with this lock and the Reactor lock.\n\n  if (!found)\n    {\n      if (this->activate_svc_handler (sh_copy) == -1)\n        {\n          // If an error occurs while activating the handler, the\n          // <activate_svc_handler> method will close the handler.\n          // This in turn will remove this entry from the internal\n          // table.\n\n          // Synchronization is required here as the setting of the\n          // handler to zero must be done atomically with the users of\n          // the cache.\n          ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n          // Reset handler.\n          sh = 0;\n          sh_copy = 0;\n\n          return -1;\n        }\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::connect_svc_handler_i\n(SVC_HANDLER *&sh,\n const ACE_PEER_CONNECTOR_ADDR &remote_addr,\n ACE_Time_Value *timeout,\n const ACE_PEER_CONNECTOR_ADDR &local_addr,\n bool reuse_addr,\n int flags,\n int perms,\n int& found)\n{\n  CONNECTION_MAP_ENTRY *entry = 0;\n\n  // Check if the user passed a hint svc_handler\n  if (sh != 0)\n    {\n      int result = this->check_hint_i (sh,\n                                       remote_addr,\n                                       timeout,\n                                       local_addr,\n                                       reuse_addr,\n                                       flags,\n                                       perms,\n                                       entry,\n                                       found);\n      if (result != 0)\n        return result;\n    }\n\n  // If not found\n  if (!found)\n    {\n      int result = this->find_or_create_svc_handler_i (sh,\n                                                       remote_addr,\n                                                       timeout,\n                                                       local_addr,\n                                                       reuse_addr,\n                                                       flags,\n                                                       perms,\n                                                       entry,\n                                                       found);\n      if (result != 0)\n        return result;\n    }\n\n  if (entry)\n    {\n      // For all successful cases: mark the <svc_handler> in the cache\n      // as being <in_use>.  Therefore recyclable is BUSY.\n      entry->ext_id_.recycle_state (ACE_RECYCLABLE_BUSY);\n\n      // And increment the refcount\n      entry->ext_id_.increment ();\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::cache (const void *recycling_act)\n{\n  // Synchronization is required here as the setting of the recyclable\n  // state must be done atomically with respect to other threads that\n  // are querying the cache.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n  return this->cache_i (recycling_act);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::cache_i (const void *recycling_act)\n{\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  // Mark the <svc_handler> in the cache as not being <in_use>.\n  // Therefore recyclable is IDLE.\n  entry->ext_id_.recycle_state (ACE_RECYCLABLE_IDLE_AND_PURGABLE);\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::recycle_state (const void *recycling_act,\n                                                                                      ACE_Recyclable_State new_state)\n{\n  // Synchronization is required here as the setting of the recyclable\n  // state must be done atomically with respect to other threads that\n  // are querying the cache.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n  return this->recycle_state_i (recycling_act,\n                                new_state);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::recycle_state_i (const void *recycling_act,\n                                                                                        ACE_Recyclable_State new_state)\n{\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  // Mark the <svc_handler> in the cache as not being <in_use>.\n  // Therefore recyclable is IDLE.\n  entry->ext_id_.recycle_state (new_state);\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> ACE_Recyclable_State\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::recycle_state (const void *recycling_act) const\n{\n  // Const cast.\n  SELF *fake_this = const_cast<SELF *> (this);\n\n  // Synchronization is required here.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *fake_this->lock_, ACE_RECYCLABLE_UNKNOWN);\n\n  return this->recycle_state_i (recycling_act);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> ACE_Recyclable_State\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::recycle_state_i (const void *recycling_act) const\n{\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  // Mark the <svc_handler> in the cache as not being <in_use>.\n  // Therefore recyclable is IDLE.\n  return entry->ext_id_.recycle_state ();\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::purge (const void *recycling_act)\n{\n  // Excluded other threads from changing cache while we take this\n  // entry out.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n  return this->purge_i (recycling_act);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::purge_i (const void *recycling_act)\n{\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  return this->connection_map_.unbind (entry);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::mark_as_closed (const void *recycling_act)\n{\n  // Excluded other threads from changing cache while we take this\n  // entry out.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n  return this->mark_as_closed_i (recycling_act);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::mark_as_closed_i (const void *recycling_act)\n{\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  // Mark the <svc_handler> in the cache as CLOSED.\n  entry->ext_id_.recycle_state (ACE_RECYCLABLE_CLOSED);\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::cleanup_hint (const void *recycling_act,\n                                                                                     void **act_holder)\n{\n  // Excluded other threads from changing cache while we take this\n  // entry out.\n  ACE_GUARD_RETURN (MUTEX, ace_mon, *this->lock_, -1);\n\n  return this->cleanup_hint_i (recycling_act,\n                               act_holder);\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::cleanup_hint_i (const void *recycling_act,\n                                                                                       void **act_holder)\n{\n  // Reset the <*act_holder> in the confines and protection of the\n  // lock.\n  if (act_holder)\n    *act_holder = 0;\n\n  // The wonders and perils of ACT\n  CONNECTION_MAP_ENTRY *entry = (CONNECTION_MAP_ENTRY *) recycling_act;\n\n  // Decrement the refcount on the <svc_handler>.\n  int refcount = entry->ext_id_.decrement ();\n\n  // If the svc_handler state is closed and the refcount == 0, call\n  // close() on svc_handler.\n  if (entry->ext_id_.recycle_state () == ACE_RECYCLABLE_CLOSED &&\n      refcount == 0)\n    {\n      entry->int_id_->recycler (0, 0);\n      entry->int_id_->close ();\n      this->purge_i (entry);\n    }\n\n  return 0;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> ACE_Creation_Strategy<SVC_HANDLER> *\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::creation_strategy (void) const\n{\n  return this->creation_strategy_;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> ACE_Recycling_Strategy<SVC_HANDLER> *\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::recycling_strategy (void) const\n{\n  return this->recycling_strategy_;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> ACE_Concurrency_Strategy<SVC_HANDLER> *\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::concurrency_strategy (void) const\n{\n  return this->concurrency_strategy_;\n}\n\ntemplate<class SVC_HANDLER, ACE_PEER_CONNECTOR_1, class MUTEX> int\nACE_Cached_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2, MUTEX>::find (\n  REFCOUNTED_HASH_RECYCLABLE_ADDRESS &search_addr,\n  CONNECTION_MAP_ENTRY *&entry)\n{\n  typedef ACE_Hash_Map_Bucket_Iterator<REFCOUNTED_HASH_RECYCLABLE_ADDRESS,\n                                       SVC_HANDLER *,\n                                       ACE_Hash<REFCOUNTED_HASH_RECYCLABLE_ADDRESS>,\n                                       ACE_Equal_To<REFCOUNTED_HASH_RECYCLABLE_ADDRESS>,\n                                       ACE_Null_Mutex>\n    CONNECTION_MAP_BUCKET_ITERATOR;\n\n  CONNECTION_MAP_BUCKET_ITERATOR iterator (this->connection_map_,\n                                           search_addr);\n\n  CONNECTION_MAP_BUCKET_ITERATOR end (this->connection_map_,\n                                      search_addr,\n                                      1);\n\n  for (;\n       iterator != end;\n       ++iterator)\n    {\n      REFCOUNTED_HASH_RECYCLABLE_ADDRESS &addr = (*iterator).ext_id_;\n\n      if (addr.recycle_state () != ACE_RECYCLABLE_IDLE_AND_PURGABLE &&\n          addr.recycle_state () != ACE_RECYCLABLE_IDLE_BUT_NOT_PURGABLE)\n        continue;\n\n      if (addr.subject () != search_addr.subject ())\n        continue;\n\n      entry = &(*iterator);\n      return 0;\n    }\n\n  return -1;\n}\n\ntemplate <class SVC_HANDLER> void\nACE_DLL_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_DLL_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Concurrency_Strategy<SVC_HANDLER>::~ACE_Concurrency_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Concurrency_Strategy<SVC_HANDLER>::~ACE_Concurrency_Strategy\");\n}\n\n\ntemplate <class SVC_HANDLER> void\nACE_Concurrency_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Concurrency_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Reactive_Strategy<SVC_HANDLER>::~ACE_Reactive_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Reactive_Strategy<SVC_HANDLER>::~ACE_Reactive_Strategy\");\n}\n\n\ntemplate <class SVC_HANDLER> void\nACE_Reactive_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Reactive_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Thread_Strategy<SVC_HANDLER>::~ACE_Thread_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Thread_Strategy<SVC_HANDLER>::~ACE_Thread_Strategy\");\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Thread_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Thread_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1>\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::~ACE_Accept_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::~ACE_Accept_Strategy\");\n\n  // Close the underlying acceptor.\n  this->peer_acceptor_.close ();\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_HANDLE\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::get_handle (void) const\n{\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::get_handle\");\n  return this->peer_acceptor_.get_handle ();\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_PEER_ACCEPTOR &\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::acceptor (void) const\n{\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::acceptor\");\n  return (ACE_PEER_ACCEPTOR &) this->peer_acceptor_;\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_ACCEPTOR_1> void\nACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Accept_Strategy<SVC_HANDLER, ACE_PEER_ACCEPTOR_2>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_CONNECTOR_1>\nACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::~ACE_Connect_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::~ACE_Connect_Strategy\");\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_CONNECTOR_1> ACE_PEER_CONNECTOR &\nACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connector (void) const\n{\n  ACE_TRACE (\"ACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::connector\");\n  return (ACE_PEER_CONNECTOR &) this->connector_;\n}\n\ntemplate <class SVC_HANDLER, ACE_PEER_CONNECTOR_1> void\nACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Connect_Strategy<SVC_HANDLER, ACE_PEER_CONNECTOR_2>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Process_Strategy<SVC_HANDLER>::~ACE_Process_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Process_Strategy<SVC_HANDLER>::~ACE_Process_Strategy\");\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Process_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Process_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Scheduling_Strategy<SVC_HANDLER>::~ACE_Scheduling_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Scheduling_Strategy<SVC_HANDLER>::~ACE_Scheduling_Strategy\");\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Scheduling_Strategy<SVC_HANDLER>::suspend (void)\n{\n  ACE_TRACE (\"ACE_Scheduling_Strategy<SVC_HANDLER>::suspend\");\n  return -1;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Scheduling_Strategy<SVC_HANDLER>::resume (void)\n{\n  ACE_TRACE (\"ACE_Scheduling_Strategy<SVC_HANDLER>::resume\");\n  return -1;\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Scheduling_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Scheduling_Strategy<SVC_HANDLER>::dump\");\n\n  ACELIB_DEBUG ((LM_DEBUG, ACE_BEGIN_DUMP, this));\n  ACELIB_DEBUG ((LM_DEBUG, ACE_END_DUMP));\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::suspend (void)\n{\n  ACE_TRACE (\"ACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::suspend\");\n  return this->reactor_->suspend_handlers ();\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::resume (void)\n{\n  ACE_TRACE (\"ACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::resume\");\n  return this->reactor_->resume_handlers ();\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Schedule_All_Reactive_Strategy<SVC_HANDLER>::dump\");\n\n  ACE_Scheduling_Strategy<SVC_HANDLER>::dump ();\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::suspend (void)\n{\n  ACE_TRACE (\"ACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::suspend\");\n  return this->thr_mgr_->suspend_all ();\n}\n\ntemplate <class SVC_HANDLER> int\nACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::resume (void)\n{\n  ACE_TRACE (\"ACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::resume\");\n  return this->thr_mgr_->resume_all ();\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Schedule_All_Threaded_Strategy<SVC_HANDLER>::dump\");\n\n  ACE_Scheduling_Strategy<SVC_HANDLER>::dump ();\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class T>\nACE_Refcounted_Hash_Recyclable<T>::~ACE_Refcounted_Hash_Recyclable (void)\n{\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Singleton_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Singleton_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER>\nACE_Creation_Strategy<SVC_HANDLER>::~ACE_Creation_Strategy (void)\n{\n  ACE_TRACE (\"ACE_Creation_Strategy<SVC_HANDLER>::~ACE_Creation_Strategy\");\n}\n\n// Default behavior is to make a new SVC_HANDLER, passing in the\n// Thread_Manager (if any).\n\ntemplate <class SVC_HANDLER> int\nACE_Creation_Strategy<SVC_HANDLER>::make_svc_handler (SVC_HANDLER *&sh)\n{\n  ACE_TRACE (\"ACE_Creation_Strategy<SVC_HANDLER>::make_svc_handler\");\n\n  if (sh == 0)\n    ACE_NEW_RETURN (sh, SVC_HANDLER (this->thr_mgr_), -1);\n  sh->reactor (this->reactor_);\n  return 0;\n}\n\ntemplate <class SVC_HANDLER> void\nACE_Creation_Strategy<SVC_HANDLER>::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Creation_Strategy<SVC_HANDLER>::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\ntemplate <class SVC_HANDLER> int\nACE_NOOP_Creation_Strategy<SVC_HANDLER>::make_svc_handler (SVC_HANDLER *&)\n{\n  ACE_TRACE (\"ACE_NOOP_Creation_Strategy<SVC_HANDLER>::make_svc_handler\");\n  return 0;\n}\n\ntemplate <class SVC_HANDLER> int\nACE_NOOP_Concurrency_Strategy<SVC_HANDLER>::activate_svc_handler (SVC_HANDLER *,\n                                                                  void *)\n{\n  ACE_TRACE (\"ACE_NOOP_Concurrency_Strategy<SVC_HANDLER>::activate_svc_handler\");\n  return 0;\n}\n\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Creation_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Singleton_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_DLL_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Concurrency_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Reactive_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Thread_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tc(ACE_Process_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tca(ACE_Accept_Strategy)\nACE_ALLOC_HOOK_DEFINE_Tco(ACE_Connect_Strategy)\n\nACE_END_VERSIONED_NAMESPACE_DECL\n\n#endif /* ACE_STRATEGIES_T_CPP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/Lib_Find.cpp": "#include \"ace/Lib_Find.h\"\n#include \"ace/Log_Category.h\"\n#include \"ace/OS_NS_string.h\"\n#include \"ace/OS_NS_errno.h\"\n#include \"ace/OS_NS_stdio.h\"\n#include \"ace/OS_NS_unistd.h\"\n#include \"ace/OS_NS_stdlib.h\"\n#include \"ace/OS_Memory.h\"\n#include \"ace/OS_NS_fcntl.h\"\n\n#if defined (ACE_HAS_ALLOC_HOOKS)\n# include \"ace/Malloc_Base.h\"\n#endif /* ACE_HAS_ALLOC_HOOKS */\n\n#if defined (ACE_WIN32)\n#  include \"ace/OS_NS_strings.h\"\n#endif /* ACE_WIN32 */\n\n#if defined (ACE_OPENVMS)\n#include \"ace/RB_Tree.h\"\n#include \"ace/Thread_Mutex.h\"\n#include \"ace/Singleton.h\"\n\n#include /**/ \"descrip.h\"\n#include /**/ \"chfdef.h\"\n#include /**/ \"stsdef.h\"\n#include /**/ \"libdef.h\"\n\nextern \"C\" int LIB$FIND_IMAGE_SYMBOL(...);\n\n/**\n * @internal\n *\n * Implements a class to register symbols and addresses for use with DLL\n * symbol retrieval.\n *\n * OpenVMS restricts symbol length to 31 characters encoding any symbols\n * longer than that. In these cases dlsym() only works with the encoded\n * names.\n * This creates serious problems for the service configurator framework\n * where the factory method names often exceed 31 chars and where loading\n * is based on retrieval of method pointers using the *full* name.\n * For OpenVMS we therefor added this singleton class and the\n * ACE_Dynamic_Svc_Registrar class which registers full names and function\n * pointers with this singleton at the time the static ACE_Dynamic_Svc_Registrar\n * object is created in a (service) DLL.\n * By forcing the DLL to load using a common symbol (\"NULL\") we trigger static\n * object creation *before* the full names are referenced.\n * Symbol references will be resolved as follows on OpenVMS:\n * - first try directly from DLL using the RTL dlsym() function and if that fails;\n * - try to find symbol in singleton registry.\n */\nclass ACE_LD_Symbol_Registry\n{\npublic:\n\n  typedef ACE_RB_Tree<const ACE_TCHAR*,\n                      void*,\n                      ACE_Less_Than<const ACE_TCHAR*>,\n                      ACE_Thread_Mutex>\n          TREE;\n\n  void register_symbol (const ACE_TCHAR* symname, void* symaddr);\n\n  void* find_symbol (const ACE_TCHAR* symname);\n\n  ACE_LD_Symbol_Registry () {}\nprivate:\n\n  TREE symbol_registry_;\n};\n\nvoid\nACE_LD_Symbol_Registry::register_symbol (const ACE_TCHAR* symname,\n                                         void* symaddr)\n{\n  int const result = symbol_registry_.bind (symname, symaddr);\n  if (result == 1)\n    {\n      ACELIB_DEBUG((LM_INFO, ACE_TEXT (\"ACE_LD_Symbol_Registry:\")\n                          ACE_TEXT (\" duplicate symbol %s registered\\n\"),\n                          ACE_TEXT_ALWAYS_CHAR (symname)));\n    }\n  else if (result == -1)\n    {\n      ACELIB_ERROR((LM_ERROR, ACE_TEXT (\"ACE_LD_Symbol_Registry:\")\n                           ACE_TEXT (\" failed to register symbol %s\\n\"),\n                           ACE_TEXT_ALWAYS_CHAR (symname)));\n    }\n}\n\nvoid*\nACE_LD_Symbol_Registry::find_symbol (const ACE_TCHAR* symname)\n{\n  void* symaddr = 0;\n  int const result = symbol_registry_.find (symname, symaddr);\n\n  return (result == 0 ? symaddr : 0);\n}\n\n/// Declare a process wide singleton\nACE_SINGLETON_DECLARE (ACE_Singleton,\n                       ACE_LD_Symbol_Registry,\n                       ACE_Thread_Mutex)\n\ntypedef ACE_Singleton<ACE_LD_Symbol_Registry, ACE_Thread_Mutex>\n        ACE_LD_SYMBOL_REGISTRY;\n\nACE_SINGLETON_TEMPLATE_INSTANTIATE(ACE_Singleton, ACE_LD_Symbol_Registry, ACE_SYNCH_MUTEX);\n\n\n#endif\n\n\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nint\nACE::ldfind (const ACE_TCHAR* filename,\n             ACE_TCHAR pathname[],\n             size_t maxpathnamelen)\n{\n  ACE_TRACE (\"ACE::ldfind\");\n#if defined (ACE_OPENVMS)\n  if (ACE_OS::strlen (filename) >= maxpathnamelen)\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n\n  dsc$descriptor nameDsc;\n  nameDsc.dsc$b_class = DSC$K_CLASS_S;\n  nameDsc.dsc$b_dtype = DSC$K_DTYPE_T;\n  nameDsc.dsc$w_length = ACE_OS::strlen (filename);\n  nameDsc.dsc$a_pointer = (char*)filename;\n\n  char symbol[] = \"NULL\";\n  dsc$descriptor symbolDsc;\n  symbolDsc.dsc$b_class = DSC$K_CLASS_S;\n  symbolDsc.dsc$b_dtype = DSC$K_DTYPE_T;\n  symbolDsc.dsc$w_length = ACE_OS::strlen (symbol);\n  symbolDsc.dsc$a_pointer = symbol;\n\n  int symbolValue;\n  int result;\n  try\n    {\n      result = LIB$FIND_IMAGE_SYMBOL (&nameDsc, &symbolDsc, &symbolValue, 0, 0);\n    }\n  catch (chf$signal_array &sig)\n    {\n      result = sig.chf$l_sig_name;\n    }\n\n  int severity = result & STS$M_SEVERITY;\n  int conditionId = result & STS$M_COND_ID;\n  if (severity == STS$K_SUCCESS || severity == STS$K_WARNING || severity == STS$K_INFO ||\n      (severity == STS$K_ERROR && conditionId == (LIB$_KEYNOTFOU & STS$M_COND_ID)))\n    {\n      ACE_OS::strcpy (pathname, filename);\n      return 0;\n    }\n\n  if (ACE_OS::strlen (filename) + ACE_OS::strlen (ACE_DLL_PREFIX) >= maxpathnamelen)\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n\n\n  ACE_OS::strcpy (pathname, ACE_DLL_PREFIX);\n  ACE_OS::strcat (pathname, filename);\n  nameDsc.dsc$w_length = ACE_OS::strlen (pathname);\n  nameDsc.dsc$a_pointer = pathname;\n  try\n    {\n      result = LIB$FIND_IMAGE_SYMBOL (&nameDsc, &symbolDsc, &symbolValue, 0, 0);\n    }\n  catch (chf$signal_array &sig)\n    {\n      result = sig.chf$l_sig_name;\n    }\n\n  severity = result & STS$M_SEVERITY;\n  conditionId = result & STS$M_COND_ID;\n  if (severity == STS$K_SUCCESS || severity == STS$K_WARNING || severity == STS$K_INFO ||\n      (severity == STS$K_ERROR && conditionId == (LIB$_KEYNOTFOU & STS$M_COND_ID)))\n    {\n      return 0;\n    }\n  errno = ENOENT;\n  return -1;\n#endif /* ACE_OPENVMS */\n\n#if defined (ACE_WIN32) && !defined (ACE_HAS_WINCE) && \\\n    !defined (ACE_HAS_PHARLAP)\n  ACE_TCHAR expanded_filename[MAXPATHLEN];\n  if (ACE_TEXT_ExpandEnvironmentStrings (filename,\n                                         expanded_filename,\n                                         sizeof expanded_filename\n                                         / sizeof (ACE_TCHAR)))\n    filename = expanded_filename;\n#endif /* ACE_WIN32 && !ACE_HAS_WINCE && !ACE_HAS_PHARLAP */\n\n  ACE_TCHAR tempcopy[MAXPATHLEN + 1];\n  ACE_TCHAR searchpathname[MAXPATHLEN + 1];\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n  ACE_TCHAR decorator[] = ACE_LD_DECORATOR_STR;\n  ACE_TCHAR searchfilename[MAXPATHLEN + sizeof(decorator) / sizeof (ACE_TCHAR)];\n#else\n  ACE_TCHAR searchfilename[MAXPATHLEN + 1];\n#endif /* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */\n\n  // Create a copy of filename to work with.\n  if (ACE_OS::strlen (filename) + 1\n      > (sizeof tempcopy / sizeof (ACE_TCHAR)))\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n  else\n    ACE_OS::strcpy (tempcopy, filename);\n\n  // Insert canonical directory separators.\n  ACE_TCHAR *separator_ptr;\n\n#if (ACE_DIRECTORY_SEPARATOR_CHAR != '/')\n  // Make all the directory separators \"canonical\" to simplify\n  // subsequent code.\n  ACE::strrepl (tempcopy, ACE_DIRECTORY_SEPARATOR_CHAR, '/');\n#endif /* ACE_DIRECTORY_SEPARATOR_CHAR */\n\n  // Separate filename from pathname.\n  separator_ptr = ACE_OS::strrchr (tempcopy, '/');\n\n  // This is a relative path.\n  if (separator_ptr == 0)\n    {\n      searchpathname[0] = '\\0';\n      ACE_OS::strcpy (searchfilename, tempcopy);\n    }\n  else // This is an absolute path.\n    {\n      ACE_OS::strcpy (searchfilename, separator_ptr + 1);\n      separator_ptr[1] = '\\0';\n      ACE_OS::strcpy (searchpathname, tempcopy);\n    }\n\n  bool has_suffix = false;\n\n  // Check to see if this has an appropriate DLL suffix for the OS\n  // platform.\n  ACE_TCHAR *s = ACE_OS::strrchr (searchfilename, '.');\n\n  const ACE_TCHAR *dll_suffix = ACE_DLL_SUFFIX;\n\n  if (s != 0)\n    {\n      // If we have a dot, we have a suffix\n      has_suffix = true;\n\n      // Check whether this matches the appropriate platform-specific\n      // suffix.\n#if defined (ACE_WIN32)\n      // Use <ACE_OS::strcasecmp> on any platform with\n      // case-insensitive filenames.\n      if (ACE_OS::strcasecmp (s, dll_suffix) != 0)\n#else\n      if (ACE_OS::strcmp (s, dll_suffix) != 0)\n#endif /* ACE_WIN32 */\n        {\n          ACELIB_ERROR ((LM_WARNING,\n                      ACE_TEXT (\"Warning: improper suffix for a \")\n                      ACE_TEXT (\"shared library on this platform: %s\\n\"),\n                      s));\n        }\n    }\n\n  // Make sure we've got enough space in searchfilename.\n  if (ACE_OS::strlen (searchfilename)\n      + ACE_OS::strlen (ACE_DLL_PREFIX)\n      + (has_suffix ? 0 : ACE_OS::strlen (dll_suffix))\n      >= (sizeof searchfilename / sizeof (ACE_TCHAR)))\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n  size_t const len_searchfilename = ACE_OS::strlen (searchfilename);\n  if (!has_suffix)\n    ACE_OS::strcpy (searchfilename + len_searchfilename, decorator);\n\n  for (int tag = 1; tag >= 0; tag --)\n    {\n      if (tag == 0)\n        searchfilename [len_searchfilename] = 0;\n\n#endif /* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */\n      // Use absolute pathname if there is one.\n      if (ACE_OS::strlen (searchpathname) > 0)\n        {\n          if (ACE_OS::strlen (searchfilename)\n              + ACE_OS::strlen (searchpathname) >= maxpathnamelen)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n          else\n            {\n#if (ACE_DIRECTORY_SEPARATOR_CHAR != '/')\n              // Revert to native path name separators.\n              ACE::strrepl (searchpathname,\n                            '/',\n                            ACE_DIRECTORY_SEPARATOR_CHAR);\n#endif /* ACE_DIRECTORY_SEPARATOR_CHAR */\n              // First, try matching the filename *without* adding a\n              // prefix.\n              ACE_OS::snprintf (pathname, maxpathnamelen,\n                                ACE_TEXT (\"%s%s%s\"),\n                                searchpathname,\n                                searchfilename,\n                                has_suffix ? ACE_TEXT (\"\") : dll_suffix);\n              if (ACE_OS::access (pathname, F_OK) == 0)\n                return 0;\n\n              // Second, try matching the filename *with* adding a prefix.\n              ACE_OS::snprintf (pathname, maxpathnamelen,\n                                ACE_TEXT (\"%s%s%s%s\"),\n                                searchpathname,\n                                ACE_DLL_PREFIX,\n                                searchfilename,\n                                has_suffix ? ACE_TEXT (\"\") : dll_suffix);\n              if (ACE_OS::access (pathname, F_OK) == 0)\n                return 0;\n            }\n        }\n\n      // Use relative filenames via LD_LIBRARY_PATH or PATH (depending on\n      // OS platform).\n      else\n        {\n#if defined (ACE_WIN32) && !defined (ACE_HAS_WINCE)\n          ACE_TCHAR *file_component = 0;\n          DWORD pathlen =\n            ACE_TEXT_SearchPath (0,\n                                 searchfilename,\n                                 dll_suffix,\n                                 static_cast<DWORD> (maxpathnamelen),\n                                 pathname,\n                                 &file_component);\n          if (pathlen >= maxpathnamelen)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n          else if (pathlen > 0)\n            return 0;\n\n          // In case not found we should try again with the ACE_DLL_PREFIX\n          // prefixed\n          ACE_OS::strcpy (searchfilename, ACE_DLL_PREFIX);\n          ACE_OS::strcat (searchfilename, tempcopy);\n          pathlen =\n            ACE_TEXT_SearchPath (0,\n                                 searchfilename,\n                                 dll_suffix,\n                                 static_cast<DWORD> (maxpathnamelen),\n                                 pathname,\n                                 &file_component);\n          if (pathlen >= maxpathnamelen)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n          else if (pathlen > 0)\n            return 0;\n#else\n          ACE_TCHAR *ld_path = 0;\n#  if defined ACE_DEFAULT_LD_SEARCH_PATH\n          ld_path = const_cast<ACE_TCHAR*> (ACE_DEFAULT_LD_SEARCH_PATH);\n#  else\n#    if defined (ACE_WIN32) || !defined (ACE_USES_WCHAR)\n          ld_path = ACE_OS::getenv (ACE_LD_SEARCH_PATH);\n#    else\n          // Wide-char, non-Windows only offers char * getenv. So capture\n          // it, translate to wide-char, and continue.\n          ACE_Ascii_To_Wide wide_ldpath\n            (ACE_OS::getenv (ACE_TEXT_ALWAYS_CHAR (ACE_LD_SEARCH_PATH)));\n          ld_path = wide_ldpath.wchar_rep ();\n#    endif /* ACE_WIN32 || !ACE_USES_WCHAR */\n#  endif /* ACE_DEFAULT_LD_SEARCH_PATH */\n\n#if defined (ACE_HAS_WINCE)\n            ACE_TCHAR *ld_path_temp = 0;\n            if (ld_path != 0)\n              {\n                ld_path_temp = (ACE_TCHAR *)\n                  ACE_OS::malloc ((ACE_OS::strlen (ld_path) + 2)\n                                  * sizeof (ACE_TCHAR));\n                if (ld_path_temp != 0)\n                  {\n                    ACE_OS::strcpy (ld_path_temp,\n                                    ACE_LD_SEARCH_PATH_SEPARATOR_STR);\n\n                    ACE_OS::strcat (ld_path_temp, ld_path);\n                    ld_path = ld_path_temp;\n                  }\n                else\n                  {\n                    ACE_OS::free ((void *) ld_path_temp);\n                    ld_path = ld_path_temp = 0;\n                  }\n              }\n#endif /* ACE_HAS_WINCE */\n\n          if (ld_path != 0\n              && (ld_path = ACE_OS::strdup (ld_path)) != 0)\n            {\n              // strtok has the strange behavior of not separating the\n              // string \":/foo:/bar\" into THREE tokens.  One would expect\n              // that the first iteration the token would be an empty\n              // string, the second iteration would be \"/foo\", and the\n              // third iteration would be \"/bar\".  However, this is not\n              // the case; one only gets two iterations: \"/foo\" followed\n              // by \"/bar\".\n\n              // This is especially a problem in parsing Unix paths\n              // because it is permissible to specify 'the current\n              // directory' as an empty entry.  So, we introduce the\n              // following special code to cope with this:\n\n              // Look at each dynamic lib directory in the search path.\n\n              ACE_TCHAR *nextholder = 0;\n              const ACE_TCHAR *path_entry =\n                ACE::strsplit_r (ld_path,\n                                 ACE_LD_SEARCH_PATH_SEPARATOR_STR,\n                                 nextholder);\n              int result = 0;\n\n              for (;;)\n                {\n                  // Check if at end of search path.\n                  if (path_entry == 0)\n                    {\n                      errno = ENOENT;\n                      result = -1;\n                      break;\n                    }\n                  else if (ACE_OS::strlen (path_entry)\n                           + 1\n                           + ACE_OS::strlen (searchfilename)\n                           >= maxpathnamelen)\n                    {\n                      errno = ENOMEM;\n                      result = -1;\n                      break;\n                    }\n                  // This works around the issue where a path might have\n                  // an empty component indicating 'current directory'.\n                  // We need to do it here rather than anywhere else so\n                  // that the loop condition will still work.\n                  else if (path_entry[0] == '\\0')\n                    path_entry = ACE_TEXT (\".\");\n\n                  // First, try matching the filename *without* adding a\n                  // prefix.\n                  ACE_OS::snprintf (pathname, maxpathnamelen,\n                                    ACE_TEXT (\"%s%c%s%s\"),\n                                    path_entry,\n                                    ACE_DIRECTORY_SEPARATOR_CHAR,\n                                    searchfilename,\n                                    has_suffix ? ACE_TEXT (\"\") : dll_suffix);\n                  if (ACE_OS::access (pathname, F_OK) == 0)\n                    break;\n\n                  // Second, try matching the filename *with* adding a\n                  // prefix.\n                  ACE_OS::snprintf (pathname, maxpathnamelen,\n                                    ACE_TEXT (\"%s%c%s%s%s\"),\n                                    path_entry,\n                                    ACE_DIRECTORY_SEPARATOR_CHAR,\n                                    ACE_DLL_PREFIX,\n                                    searchfilename,\n                                    has_suffix ? ACE_TEXT (\"\") : dll_suffix);\n                  if (ACE_OS::access (pathname, F_OK) == 0)\n                    break;\n\n                  // Fetch the next item in the path\n                  path_entry =\n                    ACE::strsplit_r (0,\n                                     ACE_LD_SEARCH_PATH_SEPARATOR_STR,\n                                     nextholder);\n                }\n\n#if defined (ACE_HAS_WINCE)\n              if (ld_path_temp != 0)\n                ACE_OS::free (ld_path_temp);\n#endif /* ACE_HAS_WINCE */\n#if defined (ACE_HAS_ALLOC_HOOKS)\n              ACE_Allocator::instance()->free ((void *) ld_path);\n#else\n              ACE_OS::free ((void *) ld_path);\n#endif /* ACE_HAS_ALLOC_HOOKS */\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n              if (result == 0 || tag == 0)\n#endif /* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */\n                return result;\n            }\n#endif /* ACE_WIN32 && !ACE_HAS_WINCE */\n        }\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n    }\n#endif /* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */\n\n  errno = ENOENT;\n  return -1;\n}\n\nFILE *\nACE::ldopen (const ACE_TCHAR *filename,\n             const ACE_TCHAR *type)\n{\n  ACE_TRACE (\"ACE::ldopen\");\n\n  ACE_TCHAR buf[MAXPATHLEN + 1];\n  if (ACE::ldfind (filename,\n                   buf,\n                   sizeof (buf) /sizeof (ACE_TCHAR)) == -1)\n    return 0;\n  else\n    return ACE_OS::fopen (buf, type);\n}\n\nACE_TCHAR *\nACE::ldname (const ACE_TCHAR *entry_point)\n{\n  ACE_TRACE (\"ACE::ldname\");\n\n#if defined(ACE_NEEDS_DL_UNDERSCORE)\n  size_t size =\n    1 // leading '_'\n    + ACE_OS::strlen (entry_point)\n    + 1;\n\n  ACE_TCHAR *new_name;\n  ACE_NEW_RETURN (new_name,\n                  ACE_TCHAR[size],\n                  0);\n\n  ACE_OS::strcpy (new_name, ACE_TEXT (\"_\"));\n  ACE_OS::strcat (new_name, entry_point);\n\n  return new_name;\n#else /* ACE_NEEDS_DL_UNDERSCORE */\n  size_t size =\n    ACE_OS::strlen (entry_point)\n    + 1;\n\n  ACE_TCHAR *new_name;\n#if defined (ACE_HAS_ALLOC_HOOKS)\n  ACE_ALLOCATOR_RETURN (new_name,\n                        static_cast<ACE_TCHAR *>(ACE_Allocator::instance()->malloc(sizeof(ACE_TCHAR) * size)),\n                        0);\n#else\n  ACE_NEW_RETURN (new_name,\n                  ACE_TCHAR[size],\n                  0);\n#endif /* ACE_HAS_ALLOC_HOOKS */\n\n  ACE_OS::strcpy (new_name, entry_point);\n  return new_name;\n#endif /* ACE_NEEDS_DL_UNDERSCORE */\n}\n\n#if defined (ACE_OPENVMS)\nvoid\nACE::ldregister (const ACE_TCHAR *entry_point,\n                 void* entry_addr)\n{\n  ACE_LD_SYMBOL_REGISTRY::instance ()->register_symbol (entry_point,\n                                                        entry_addr);\n}\n\nvoid *\nACE::ldsymbol (ACE_SHLIB_HANDLE sh, const ACE_TCHAR *entry_point)\n{\n  void* symaddr = ACE_OS::dlsym (sh, entry_point);\n  // if not found through dlsym() try registry\n  if (symaddr == 0)\n    symaddr = ACE_LD_SYMBOL_REGISTRY::instance ()->find_symbol (entry_point);\n\n  return symaddr;\n}\n#endif\n\nint\nACE::get_temp_dir (ACE_TCHAR *buffer, size_t buffer_len)\n{\n  int result;\n#if defined (ACE_WIN32)\n  result = ACE_TEXT_GetTempPath (static_cast<DWORD> (buffer_len),\n                                 buffer);\n\n  // Make sure to return -1 if there is an error\n  if ((result == 0 && ::GetLastError () != ERROR_SUCCESS)\n      || (result > static_cast<int> (buffer_len)))\n    result = -1;\n\n#else /* ACE_WIN32 */\n\n  // NOTE! Non-Windows platforms don't deal with wide chars for env.\n  // variables, so do this narrow-char and convert to wide for the\n  // caller if necessary.\n\n  // On non-win32 platforms, check to see what the TMPDIR environment\n  // variable is defined to be.  If it doesn't exist, just use /tmp\n  const char *tmpdir = ACE_OS::getenv (\"TMPDIR\");\n\n  if (tmpdir == 0)\n    {\n#if defined (ACE_DEFAULT_TEMP_DIR)\n      tmpdir = ACE_DEFAULT_TEMP_DIR;\n#else\n      tmpdir = \"/tmp\";\n#endif\n    }\n\n  size_t len = ACE_OS::strlen (tmpdir);\n\n  // Check to see if the buffer is large enough for the string,\n  // another /, and its null character (hence the + 2)\n  if ((len + 2) > buffer_len)\n    {\n      result = -1;\n    }\n  else\n    {\n      ACE_OS::strcpy (buffer, ACE_TEXT_CHAR_TO_TCHAR (tmpdir));\n\n      // Add a trailing slash because we cannot assume there is already one\n      // at the end.  And having an extra one should not cause problems.\n      buffer[len] = ACE_TEXT ('/');\n      buffer[len + 1] = 0;\n      result = 0;\n    }\n#endif /* ACE_WIN32 */\n  return result;\n}\n\nACE_HANDLE\nACE::open_temp_file (const ACE_TCHAR *name, int mode, int perm)\n{\n#if defined (ACE_WIN32)\n  ACE_UNUSED_ARG (perm);\n  ACE_HANDLE handle = ACE_OS::open (name,\n                                    mode,\n                                    FILE_SHARE_READ\n                                    | FILE_SHARE_WRITE\n                                    | FILE_SHARE_DELETE);\n#else\n  // Open it.\n  ACE_HANDLE handle = ACE_OS::open (name, mode, perm);\n#endif /* ACE_WIN32 */\n\n  if (handle == ACE_INVALID_HANDLE)\n    return ACE_INVALID_HANDLE;\n\n  // Unlink it so that the file will be removed automatically when the\n  // process goes away.\n  if (ACE_OS::unlink (name) == -1)\n    {\n      ACE_OS::close (handle);\n      return ACE_INVALID_HANDLE;\n    }\n  else\n    // Return the handle.\n    return handle;\n}\n\nsize_t\nACE::strrepl (char *s, char search, char replace)\n{\n  ACE_TRACE (\"ACE::strrepl\");\n\n  size_t replaced = 0;\n\n  for (size_t i = 0; s[i] != '\\0'; i++)\n    if (s[i] == search)\n      {\n        s[i] = replace;\n        ++replaced;\n      }\n\n  return replaced;\n}\n\n\n// Split a string up into 'token'-delimited pieces, ala Perl's\n// \"split\".\n\nchar *\nACE::strsplit_r (char *str,\n                 const char *token,\n                 char *&next_start)\n{\n  char *result = 0;\n\n  if (str != 0)\n    next_start = str;\n\n  if (next_start != 0)\n    {\n      char *tok_loc = ACE_OS::strstr (next_start, token);\n\n      if (tok_loc != 0)\n        {\n          // Return the beginning of the string.\n          result = next_start;\n\n          // Insure it's terminated.\n          *tok_loc = '\\0';\n          next_start = tok_loc + ACE_OS::strlen (token);\n        }\n      else\n        {\n          result = next_start;\n          next_start = (char *) 0;\n        }\n    }\n\n  return result;\n}\n\n#if defined (ACE_HAS_WCHAR)\nwchar_t *\nACE::strsplit_r (wchar_t *str,\n                 const wchar_t *token,\n                 wchar_t *&next_start)\n{\n  wchar_t *result = 0;\n\n  if (str != 0)\n    next_start = str;\n\n  if (next_start != 0)\n    {\n      wchar_t *tok_loc = ACE_OS::strstr (next_start, token);\n\n      if (tok_loc != 0)\n        {\n          // Return the beginning of the string.\n          result = next_start;\n\n          // Insure it's terminated.\n          *tok_loc = '\\0';\n          next_start = tok_loc + ACE_OS::strlen (token);\n        }\n      else\n        {\n          result = next_start;\n          next_start = (wchar_t *) 0;\n        }\n    }\n\n  return result;\n}\n\nsize_t\nACE::strrepl (wchar_t *s, wchar_t search, wchar_t replace)\n{\n  ACE_TRACE (\"ACE::strrepl\");\n\n  size_t replaced = 0;\n\n  for (size_t i = 0; s[i] != '\\0'; i++)\n    if (s[i] == search)\n      {\n        s[i] = replace;\n        ++replaced;\n      }\n\n  return replaced;\n}\n#endif /* ACE_HAS_WCHAR */\n\nACE_END_VERSIONED_NAMESPACE_DECL\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/config-openbsd.h": "/* -*- C++ -*- */\n// The following configuration file is designed to work for OpenBSD\n\n#ifndef ACE_CONFIG_H\n#define ACE_CONFIG_H\n#include /**/ \"ace/pre.h\"\n\n#if !defined (ACE_MT_SAFE)\n#  define ACE_MT_SAFE 1\n#endif\n\n// Platform specific directives\n#include <sys/param.h>\n\n#include \"ace/config-posix.h\"\n\n#include \"ace/config-g++-common.h\"\n\n#define ACE_HAS_2_PARAM_ASCTIME_R_AND_CTIME_R\n#define ACE_HAS_3_PARAM_READDIR_R\n#define ACE_HAS_3_PARAM_WCSTOK\n#define ACE_HAS_4_4BSD_SENDMSG_RECVMSG\n#define ACE_HAS_ALLOCA\n#define ACE_HAS_ALT_CUSERID\n#define ACE_HAS_AUTOMATIC_INIT_FINI\n#define ACE_HAS_CHARPTR_DL\n#define ACE_HAS_CLOCK_GETTIME\n#define ACE_HAS_CLOCK_SETTIME\n#define ACE_HAS_CONSISTENT_SIGNAL_PROTOTYPES\n#define ACE_HAS_DIRENT\n#define ACE_HAS_GETIFADDRS\n#define ACE_HAS_GETPAGESIZE\n#define ACE_HAS_GETRUSAGE\n#define ACE_HAS_GPERF\n#define ACE_HAS_HANDLE_SET_OPTIMIZED_FOR_SELECT\n#define ACE_HAS_ICMP_SUPPORT 1\n#define ACE_HAS_IPV6\n#define ACE_HAS_IP_MULTICAST\n#define ACE_HAS_MEMCHR\n#define ACE_HAS_MKDIR\n#define ACE_HAS_MSG\n#define ACE_HAS_NANOSLEEP\n#define ACE_HAS_NEW_NO_H\n#define ACE_HAS_NONCONST_SELECT_TIMEVAL\n#define ACE_HAS_POLL\n#define ACE_HAS_POSIX_NONBLOCK\n#define ACE_HAS_POSIX_TIME\n#define ACE_HAS_PTHREADS_UNIX98_EXT\n#define ACE_HAS_PTHREAD_GETCONCURRENCY\n#define ACE_HAS_PTHREAD_MUTEXATTR_SETKIND_NP\n#define ACE_HAS_PTHREAD_NP_H\n#define ACE_HAS_PTHREAD_SETCONCURRENCY\n#define ACE_HAS_PTHREAD_SIGMASK_PROTOTYPE\n#define ACE_HAS_P_READ_WRITE\n#define ACE_HAS_RECURSIVE_THR_EXIT_SEMANTICS\n#define ACE_HAS_REENTRANT_FUNCTIONS\n#define ACE_HAS_RTLD_LAZY_V\n#define ACE_HAS_SCANDIR\n#define ACE_HAS_SEMUN\n#define ACE_HAS_SIGACTION_CONSTP2\n#define ACE_HAS_SIGINFO_T\n#define ACE_HAS_SIGSUSPEND\n#define ACE_HAS_SIGWAIT\n#define ACE_HAS_SIG_ATOMIC_T\n#define ACE_HAS_SIG_C_FUNC\n#define ACE_HAS_SOCKADDR_IN6_SIN6_LEN\n#define ACE_HAS_SOCKADDR_IN_SIN_LEN\n#define ACE_HAS_SOCKADDR_MSG_NAME\n#define ACE_HAS_SOCKLEN_T\n#define ACE_HAS_SSIZE_T\n#define ACE_HAS_STRINGS\n#define ACE_HAS_STRING_CLASS\n#define ACE_HAS_SVR4_DYNAMIC_LINKING\n#define ACE_HAS_SVR4_SIGNAL_T\n#define ACE_HAS_SYSCTL\n#define ACE_HAS_SYSV_IPC\n#define ACE_HAS_SYS_FILIO_H\n#define ACE_HAS_STRSIGNAL\n#define ACE_HAS_SYS_SOCKIO_H\n#define ACE_HAS_SYS_SYSCALL_H\n#define ACE_HAS_TERMIOS\n#define ACE_HAS_THREAD_SPECIFIC_STORAGE\n#define ACE_HAS_TIMEZONE_GETTIMEOFDAY\n#define ACE_HAS_UALARM\n#define ACE_HAS_VASPRINTF\n#define ACE_HAS_VOIDPTR_MMAP\n#define ACE_HAS_VOIDPTR_SOCKOPT\n#define ACE_HAS_VOID_UNSETENV\n#define ACE_HAS_WCHAR\n#define ACE_HAS_XPG4_MULTIBYTE_CHAR\n#define ACE_HAS_SYS_SIGINFO_H\n\n#define ACE_LACKS_CONDATTR_PSHARED\n#define ACE_LACKS_GETIPNODEBYADDR\n#define ACE_LACKS_GETIPNODEBYNAME\n#define ACE_LACKS_ISCTYPE\n#define ACE_LACKS_MUTEXATTR_PSHARED\n#define ACE_LACKS_NETDB_REENTRANT_FUNCTIONS\n#define ACE_LACKS_SETSCHED\n#define ACE_LACKS_STROPTS_H\n#define ACE_LACKS_STRRECVFD\n#define ACE_LACKS_TIMESPEC_T\n#define ACE_LACKS_UCONTEXT_H\n\n#define ACE_PAGE_SIZE 4096\n\n// OpenBSD 3.6\n#if (OpenBSD < 200411)\n#  define ACE_USES_ASM_SYMBOL_IN_DLSYM\n#endif\n\n// ucontext_t is in OpenBSD 3.5 and later.\n#if (OpenBSD >= 200405)\n#  define ACE_HAS_UCONTEXT_T\n#endif /* OpenBSD >= 200405 */\n\n// Lacks perfect filtering, must bind group address.\n#if !defined ACE_LACKS_PERFECT_MULTICAST_FILTERING\n#  define ACE_LACKS_PERFECT_MULTICAST_FILTERING 1\n#endif /* ACE_LACKS_PERFECT_MULTICAST_FILTERING */\n\n// OpenBSD's dlsym call segfaults when passed an invalid handle.\n// It seems as if most other OSs detect this and just report an error.\n#define ACE_HAS_DLSYM_SEGFAULT_ON_INVALID_HANDLE\n\n#define ACE_SSIZE_T_FORMAT_SPECIFIER_ASCII \"%ld\"\n#define ACE_SIZE_T_FORMAT_SPECIFIER_ASCII \"%lu\"\n\n#include /**/ \"ace/post.h\"\n\n#endif /* ACE_CONFIG_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/OS_NS_dlfcn.h": "// -*- C++ -*-\n\n//=============================================================================\n/**\n *  @file   OS_NS_dlfcn.h\n *\n *  @author Douglas C. Schmidt <d.schmidt@vanderbilt.edu>\n *  @author Jesper S. M|ller<stophph@diku.dk>\n *  @author and a cast of thousands...\n *\n *  Originally in OS.h.\n */\n//=============================================================================\n\n#ifndef ACE_OS_NS_DLFCN_H\n# define ACE_OS_NS_DLFCN_H\n\n# include /**/ \"ace/pre.h\"\n\n# include \"ace/config-all.h\"\n\n# if !defined (ACE_LACKS_PRAGMA_ONCE)\n#  pragma once\n# endif /* ACE_LACKS_PRAGMA_ONCE */\n\n#include \"ace/os_include/os_dlfcn.h\"\n#include /**/ \"ace/ACE_export.h\"\n\n#if defined (ACE_EXPORT_MACRO)\n#  undef ACE_EXPORT_MACRO\n#endif\n#define ACE_EXPORT_MACRO ACE_Export\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nnamespace ACE_OS {\n\n  //@{ @name A set of wrappers for explicit dynamic linking.\n  ACE_NAMESPACE_INLINE_FUNCTION\n  int dlclose (ACE_SHLIB_HANDLE handle);\n\n  ACE_NAMESPACE_INLINE_FUNCTION\n  ACE_TCHAR *dlerror (void);\n\n  ACE_NAMESPACE_INLINE_FUNCTION\n  ACE_SHLIB_HANDLE dlopen (const ACE_TCHAR *filename,\n                           int mode = ACE_DEFAULT_SHLIB_MODE);\n\n  ACE_NAMESPACE_INLINE_FUNCTION\n  void *dlsym (ACE_SHLIB_HANDLE handle,\n               const ACE_TCHAR *symbol);\n  //@}\n\n} /* namespace ACE_OS */\n\nACE_END_VERSIONED_NAMESPACE_DECL\n\n# if defined (ACE_HAS_INLINED_OSCALLS)\n#   if defined (ACE_INLINE)\n#     undef ACE_INLINE\n#   endif /* ACE_INLINE */\n#   define ACE_INLINE inline\n#   include \"ace/OS_NS_dlfcn.inl\"\n# endif /* ACE_HAS_INLINED_OSCALLS */\n\n# include /**/ \"ace/post.h\"\n#endif /* ACE_OS_NS_DLFCN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/Lib_Find.h": "// -*- C++ -*-\n\n//=============================================================================\n/**\n *  @file   Lib_Find.h\n *\n *  All the static function calls needed to search and open shared\n *  libraries.\n */\n//=============================================================================\n\n#ifndef ACE_LIB_FIND_H\n#define ACE_LIB_FIND_H\n#include /**/ \"ace/pre.h\"\n\n#include /**/ \"ace/config-all.h\"\n#include /**/ \"ace/ACE_export.h\"\n#include \"ace/os_include/os_stdio.h\"\n#if defined (ACE_OPENVMS)\n# include \"ace/OS_NS_dlfcn.h\"\n#endif\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nnamespace ACE\n{\n  // = Methods for searching and opening shared libraries.\n\n  /**\n   * Finds the file @a filename either using an absolute path or using\n   * a relative path in conjunction with ACE_LD_SEARCH_PATH (e.g.,\n   * $LD_LIBRARY_PATH on UNIX or the directories scanned by Win32 API\n   * SearchPath on Win32).  This function will add appropriate suffix\n   * (e.g., .dll on Win32 or .so on UNIX) according to the OS\n   * platform.  In addition, this function will apply the appropriate\n   * prefix (e.g., \"lib\" on UNIX and \"\" on Win32) if the @a filename\n   * doesn't match directly.\n   */\n  extern ACE_Export int ldfind (const ACE_TCHAR* filename,\n                                ACE_TCHAR pathname[],\n                                size_t maxpathnamelen);\n\n  /**\n   * Uses @c ldfind to locate and open the appropriate @a filename and\n   * returns a pointer to the file, else it returns a NULL\n   * pointer. @a type specifies how the file should be open.\n   */\n  extern ACE_Export FILE *ldopen (const ACE_TCHAR *filename,\n                                  const ACE_TCHAR *type);\n\n  /**\n   * Transforms @a entry_point into a form that can be located in a\n   * dynamic library using <dlsym>. For example, with Win32/Borland\n   * extern \"C\" functions which use the default calling convention\n   * have a '_' prepended. Always returns a buffer that has been\n   * dynamically allocated using <operator new>.\n   */\n  extern ACE_Export ACE_TCHAR *ldname (const ACE_TCHAR *entry_point);\n\n\n#if defined (ACE_OPENVMS)\n  /**\n   * Registers an @a entry_point and its address for later retrieval\n   * through the ACE::ldsymbol () method.\n   * For use in cases where the OS compiler encodes long symbolnames.\n   */\n  extern ACE_Export void ldregister (const ACE_TCHAR *entry_point,\n                                     void* entry_addr);\n\n  /**\n   * Looks up an @a entry_point address either from previously registered\n   * symbols or through ACE_OS::dlsym ().\n   * Returns 0 in case the entry_point is not found, otherwise nonzero.\n   * For use in cases where the OS compiler encodes long symbolnames.\n   */\n  extern ACE_Export void *ldsymbol (ACE_SHLIB_HANDLE sh,\n                                    const ACE_TCHAR *entry_point);\n#endif\n\n  /**\n   * Returns the temporary directory including the trailing slash in\n   * @a buffer.  Returns -1 for an error or if the buffer_len is not\n   * long enough.\n   */\n  extern ACE_Export int get_temp_dir (ACE_TCHAR *buffer, size_t buffer_len);\n\n  /// Opening the temp file.  File is automagically unlinked when it is\n  /// closed.  This is useful for have temp files.\n  extern ACE_Export ACE_HANDLE open_temp_file (const ACE_TCHAR *name,\n                                               int mode,\n                                               int perm = 0);\n\n  // @@ Though the following functions don't come under the same category as\n  // above, these are used only in the functions in this class. So it makes\n  // more sense to move these functions too to this class.\n  //\n  /// Replace all instances of @a search in @a s with @a replace.  Returns\n  /// the number of replacements made.\n  extern ACE_Export size_t strrepl (char *s, char search, char replace);\n\n  /**\n   * Splits string @a s into pieces separated by the string @a token.\n   * @a next_start is an opaque cookie handed back by the call to store\n   * its state for the next invocation, thus making it re-entrant.\n   * This operates very similar to Perl's @c split function except that\n   * it returns pieces one at a time instead of into an array.\n   */\n  extern ACE_Export char *strsplit_r (char *s,\n                                      const char *token,\n                                      char *&next_start);\n\n#if defined (ACE_HAS_WCHAR)\n  /// As strrepl, but for wide characters.\n  extern ACE_Export size_t strrepl (wchar_t *s,\n                                    wchar_t search,\n                                    wchar_t replace);\n\n  /// As strsplit_r, but for wide characters.\n  extern ACE_Export wchar_t *strsplit_r (wchar_t *s,\n                                         const wchar_t *token,\n                                         wchar_t *&next_start);\n#endif /* ACE_HAS_WCHAR */\n}\n\nACE_END_VERSIONED_NAMESPACE_DECL\n\n#include /**/ \"ace/post.h\"\n#endif  /* ACE_LIB_FIND_H */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/OS_NS_dlfcn.inl": "// -*- C++ -*-\n#include \"ace/OS_NS_macros.h\"\n#include \"ace/OS_NS_errno.h\"\n#include \"ace/OS_NS_fcntl.h\"\n#include \"ace/OS_NS_string.h\"\n#include \"ace/OS_NS_unistd.h\"\n#include \"ace/Default_Constants.h\"\n#include \"ace/os_include/os_fcntl.h\"\n#include \"ace/os_include/os_string.h\"\n\n#if defined (ACE_WIN32) && defined (ACE_HAS_PHARLAP)\n# include \"ace/OS_NS_stdio.h\"\n#endif\n\n#if defined (ACE_USES_ASM_SYMBOL_IN_DLSYM)\n#  include \"ace/OS_Memory.h\"\n#  include \"ace/OS_NS_string.h\"\n#endif /* ACE_USES_ASM_SYMBOL_IN_DLSYM */\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nACE_INLINE int\nACE_OS::dlclose (ACE_SHLIB_HANDLE handle)\n{\n  ACE_OS_TRACE (\"ACE_OS::dlclose\");\n#if defined (ACE_LACKS_DLCLOSE)\n  ACE_UNUSED_ARG (handle);\n  return 0;\n#elif defined (ACE_HAS_SVR4_DYNAMIC_LINKING)\n\n# if !defined (ACE_HAS_AUTOMATIC_INIT_FINI)\n  // SunOS4 does not automatically call _fini()!\n  void *ptr;\n\n  ACE_OSCALL (::dlsym (handle, ACE_TEXT (\"_fini\")), void *, 0, ptr);\n\n  if (ptr != 0)\n    (*((int (*)(void)) ptr)) (); // Call _fini hook explicitly.\n# endif /* ACE_HAS_AUTOMATIC_INIT_FINI */\n  ACE_OSCALL_RETURN (::dlclose (handle), int, -1);\n#elif defined (ACE_WIN32)\n  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::FreeLibrary (handle), ace_result_), int, -1);\n#elif defined (__hpux)\n  // HP-UX 10.x and 32-bit 11.00 do not pay attention to the ref count\n  // when unloading a dynamic lib.  So, if the ref count is more than\n  // 1, do not unload the lib.  This will cause a library loaded more\n  // than once to not be unloaded until the process runs down, but\n  // that's life.  It's better than unloading a library that's in use.\n  // So far as I know, there's no way to decrement the refcnt that the\n  // kernel is looking at - the shl_descriptor is a copy of what the\n  // kernel has, not the actual struct.  On 64-bit HP-UX using dlopen,\n  // this problem has been fixed.\n  struct shl_descriptor  desc;\n  if (shl_gethandle_r (handle, &desc) == -1)\n    return -1;\n  if (desc.ref_count > 1)\n    return 0;\n# if defined(__GNUC__) || __cplusplus >= 199707L\n  ACE_OSCALL_RETURN (::shl_unload (handle), int, -1);\n# else\n  ACE_OSCALL_RETURN (::cxxshl_unload (handle), int, -1);\n# endif  /* aC++ vs. Hp C++ */\n#else\n  ACE_UNUSED_ARG (handle);\n  ACE_NOTSUP_RETURN (-1);\n#endif /* ACE_HAS_SVR4_DYNAMIC_LINKING */\n}\n\nACE_INLINE ACE_TCHAR *\nACE_OS::dlerror (void)\n{\n  ACE_OS_TRACE (\"ACE_OS::dlerror\");\n# if defined (ACE_HAS_SVR4_DYNAMIC_LINKING)\n  const char *err = 0;\n  ACE_OSCALL (::dlerror (), const char *, 0, err);\n  if (err == 0)\n    return 0;\n#   if defined (ACE_USES_WCHAR)\n  const size_t BufLen = 256;\n  static wchar_t buf[BufLen];\n  ACE_OS::strncpy (buf, ACE_TEXT_CHAR_TO_TCHAR (err), BufLen);\n  return buf;\n#   else\n  return const_cast <char *> (err);\n#   endif /* ACE_USES_WCHAR */\n# elif defined (__hpux) || defined (ACE_VXWORKS)\n  //FUZZ: disable check_for_lack_ACE_OS\n  ACE_OSCALL_RETURN (::strerror(errno), char *, 0);\n  //FUZZ: enable check_for_lack_ACE_OS\n# elif defined (ACE_WIN32)\n  static ACE_TCHAR buf[128];\n#   if defined (ACE_HAS_PHARLAP)\n  ACE_OS::sprintf (buf, \"error code %d\", GetLastError());\n#   else\n  ACE_TEXT_FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,\n                          0,\n                          ::GetLastError (),\n                          0,\n                          buf,\n                          sizeof buf / sizeof buf[0],\n                          0);\n#   endif /* ACE_HAS_PHARLAP */\n  return buf;\n# else\n  ACE_NOTSUP_RETURN (0);\n# endif /* ACE_HAS_SVR4_DYNAMIC_LINKING */\n}\n\nACE_INLINE ACE_SHLIB_HANDLE\nACE_OS::dlopen (const ACE_TCHAR *fname,\n                int mode)\n{\n  ACE_OS_TRACE (\"ACE_OS::dlopen\");\n\n# if defined (ACE_HAS_SVR4_DYNAMIC_LINKING)\n  void *handle;\n  ACE_OSCALL (::dlopen (ACE_TEXT_ALWAYS_CHAR (fname), mode), void *, 0, handle);\n#   if !defined (ACE_HAS_AUTOMATIC_INIT_FINI)\n  if (handle != 0)\n    {\n      void *ptr;\n      // Some systems (e.g., SunOS4) do not automatically call _init(), so\n      // we'll have to call it manually.\n\n      ACE_OSCALL (::dlsym (handle, ACE_TEXT (\"_init\")), void *, 0, ptr);\n\n      if (ptr != 0 && (*((int (*)(void)) ptr)) () == -1) // Call _init hook explicitly.\n        {\n          // Close down the handle to prevent leaks.\n          ::dlclose (handle);\n          return 0;\n        }\n    }\n#   endif /* ACE_HAS_AUTOMATIC_INIT_FINI */\n  return handle;\n# elif defined (ACE_WIN32)\n  ACE_UNUSED_ARG (mode);\n\n  ACE_WIN32CALL_RETURN (ACE_TEXT_LoadLibrary (fname), ACE_SHLIB_HANDLE, 0);\n# elif defined (__hpux)\n\n#   if defined(__GNUC__) || __cplusplus >= 199707L\n  ACE_OSCALL_RETURN (::shl_load(fname, mode, 0L), ACE_SHLIB_HANDLE, 0);\n#   else\n  ACE_OSCALL_RETURN (::cxxshl_load(fname, mode, 0L), ACE_SHLIB_HANDLE, 0);\n#   endif  /* aC++ vs. Hp C++ */\n# elif defined (ACE_VXWORKS) && !defined (__RTP__)\n  ACE_UNUSED_ARG (mode);\n  MODULE* handle = 0;\n  // Open readonly\n  ACE_HANDLE filehandle = ACE_OS::open (fname,\n                                        O_RDONLY,\n                                        ACE_DEFAULT_FILE_PERMS);\n\n  if (filehandle != ACE_INVALID_HANDLE)\n    {\n      ACE_OS::last_error(0);\n      ACE_OSCALL ( ::loadModule (filehandle, LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL ), MODULE *, 0, handle);\n      int loaderror = ACE_OS::last_error();\n      ACE_OS::close (filehandle);\n\n      if ( (loaderror != 0) && (handle != 0) )\n        {\n          // ouch something went wrong most likely unresolved externals\n          if (handle)\n            ::unldByModuleId ( handle, 0 );\n          handle = 0;\n        }\n    }\n  else\n    {\n      // couldn't open file\n      handle = 0;\n    }\n  return handle;\n# else\n  ACE_UNUSED_ARG (fname);\n  ACE_UNUSED_ARG (mode);\n  ACE_NOTSUP_RETURN (0);\n# endif /* ACE_HAS_SVR4_DYNAMIC_LINKING */\n}\n\nACE_INLINE void *\nACE_OS::dlsym (ACE_SHLIB_HANDLE handle,\n               const ACE_TCHAR *sname)\n{\n  ACE_OS_TRACE (\"ACE_OS::dlsym\");\n\n#if defined (ACE_HAS_DLSYM_SEGFAULT_ON_INVALID_HANDLE)\n  // Check if the handle is valid before making any calls using it.\n  if (handle == ACE_SHLIB_INVALID_HANDLE)\n    return 0;\n#endif /* ACE_HAS_DLSYM_SEGFAULT_ON_INVALID_HANDLE */\n\n  // Get the correct OS type.\n#if defined (ACE_HAS_WINCE)\n  // CE (at least thru Pocket PC 2003) offers GetProcAddressW, not ...A, so\n  // we always need a wide-char string.\n  const wchar_t *symbolname = 0;\n#  if defined (ACE_USES_WCHAR)\n  symbolname = sname;\n#  else\n  ACE_Ascii_To_Wide sname_xlate (sname);\n  symbolname = sname_xlate.wchar_rep ();\n#  endif /* ACE_USES_WCHAR */\n#elif defined (ACE_USES_WCHAR)\n  // WinCE is WCHAR always; other platforms need a char * symbol name\n  ACE_Wide_To_Ascii w_sname (sname);\n  char *symbolname = w_sname.char_rep ();\n#elif defined (ACE_VXWORKS)\n  char *symbolname = const_cast<char *> (sname);\n#else\n  const char *symbolname = sname;\n#endif /* ACE_HAS_WINCE */\n\n# if defined (ACE_HAS_SVR4_DYNAMIC_LINKING)\n\n#   if defined (ACE_USES_ASM_SYMBOL_IN_DLSYM)\n  int l = ACE_OS::strlen (symbolname) + 2;\n  char *asm_symbolname = 0;\n  ACE_NEW_RETURN (asm_symbolname, char[l], 0);\n  ACE_OS::strcpy (asm_symbolname, \"_\") ;\n  ACE_OS::strcpy (asm_symbolname + 1, symbolname) ;\n  void *ace_result;\n  ACE_OSCALL (::dlsym (handle, asm_symbolname), void *, 0, ace_result);\n  delete [] asm_symbolname;\n  return ace_result;\n#   else\n  ACE_OSCALL_RETURN (::dlsym (handle, symbolname), void *, 0);\n#   endif /* ACE_USES_ASM_SYMBOL_IN_DLSYM */\n\n# elif defined (ACE_WIN32)\n\n  ACE_WIN32CALL_RETURN (::GetProcAddress (handle, symbolname), void *, 0);\n\n# elif defined (__hpux)\n\n  void *value = 0;\n  int status;\n  shl_t _handle = handle;\n  ACE_OSCALL (::shl_findsym(&_handle, symbolname, TYPE_UNDEFINED, &value), int, -1, status);\n  return status == 0 ? value : 0;\n\n# elif defined (ACE_VXWORKS) && !defined (__RTP__)\n\n  // For now we use the VxWorks global symbol table\n  // which resolves the most recently loaded symbols, which resolve\n  // mostly what we want..\n  ACE_UNUSED_ARG (handle);\n#if (ACE_VXWORKS < 0x690)\n  SYM_TYPE symtype;\n  char *value = 0;\n  STATUS status;\n  ACE_OSCALL (::symFindByName(sysSymTbl, symbolname, &value, &symtype), int, -1, status);\n\n  return status == OK ? reinterpret_cast <void*>(value) : 0;\n#else\n  STATUS status;\n\n  SYMBOL_DESC symbolDesc;     /* symFind() descriptor */\n  ACE_OS::memset (&symbolDesc, 0, sizeof (SYMBOL_DESC));\n  symbolDesc.mask = SYM_FIND_BY_NAME;\n  symbolDesc.name = symbolname;\n\n  ACE_OSCALL (::symFind(sysSymTbl, &symbolDesc), int, -1, status);\n\n  return status == OK ? reinterpret_cast <void*>(symbolDesc.value) : 0;\n#endif /* (ACE_VXWORKS < 0x690) */\n\n# else\n\n  ACE_UNUSED_ARG (handle);\n  ACE_UNUSED_ARG (symbolname);\n  ACE_NOTSUP_RETURN (0);\n\n# endif /* ACE_HAS_SVR4_DYNAMIC_LINKING */\n}\n\nACE_END_VERSIONED_NAMESPACE_DECL\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/DLL_Manager.cpp": "#include \"ace/DLL_Manager.h\"\n\n#include \"ace/Auto_Ptr.h\"\n#include \"ace/Log_Category.h\"\n#include \"ace/ACE.h\"\n#include \"ace/Framework_Component.h\"\n\n#include \"ace/Lib_Find.h\"\n#include \"ace/Object_Manager.h\"\n#include \"ace/SString.h\"\n#include \"ace/Recursive_Thread_Mutex.h\"\n#include \"ace/Guard_T.h\"\n#include \"ace/OS_NS_dlfcn.h\"\n#include \"ace/OS_NS_string.h\"\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nsig_atomic_t ACE_DLL_Handle::open_called_ = 0;\n\nACE_DLL_Handle::ACE_DLL_Handle (void)\n  : refcount_ (0),\n    dll_name_ (0),\n    handle_ (ACE_SHLIB_INVALID_HANDLE)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::ACE_DLL_Handle\");\n}\n\nACE_DLL_Handle::~ACE_DLL_Handle (void)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::~ACE_DLL_Handle\");\n  this->close (1);\n#if defined (ACE_HAS_ALLOC_HOOKS)\n  ACE_Allocator::instance()->free(this->dll_name_);\n#else\n  delete[] this->dll_name_;\n#endif /* ACE_HAS_ALLOC_HOOKS */\n}\n\nACE_ALLOC_HOOK_DEFINE(ACE_DLL_Handle)\n\nconst ACE_TCHAR  *\nACE_DLL_Handle::dll_name (void) const\n{\n  ACE_TRACE (\"ACE_DLL_Handle::dll_name\");\n  return this->dll_name_;\n}\n\nint\nACE_DLL_Handle::open (const ACE_TCHAR *dll_name,\n                      int open_mode,\n                      ACE_SHLIB_HANDLE handle,\n                      ERROR_STACK *errors)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::open\");\n  ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n\n  if (this->dll_name_)\n    {\n      // Once dll_name_ has been set, it can't be changed..\n      if (ACE_OS::strcmp (this->dll_name_, dll_name) != 0)\n        {\n          if (ACE::debug ())\n            ACELIB_ERROR ((LM_ERROR,\n                        ACE_TEXT (\"ACE (%P|%t) DLL_Handle::open: error, \")\n                        ACE_TEXT (\"tried to reopen <%s> with name <%s>\\n\"),\n                        this->dll_name_,\n                        dll_name));\n\n          return -1;\n        }\n    }\n  else\n    this->dll_name_ = ACE::strnew (dll_name);\n\n  if (!this->open_called_)\n    this->open_called_ = 1;\n\n  // If it hasn't been loaded yet, go ahead and do that now.\n  if (this->handle_ == ACE_SHLIB_INVALID_HANDLE)\n    {\n      if (handle)\n        this->handle_ = handle;\n      else\n        {\n          /*\n          ** Get the set of names to try loading. We need to do this to\n          ** properly support the ability for a user to specify a simple,\n          ** unadorned name (for example, \"ACE\") that will work across\n          ** platforms. We apply platform specifics to get a name that will\n          ** work (e.g. libACE, ACEd.dll, ACE.dll, etc.) We rely on the\n          ** underlying dlopen() implementation to \"Do The Right Thing\" in\n          ** terms of using relative paths, LD_LIBRARY_PATH, system security\n          ** rules, etc. except when ACE_MUST_HELP_DLOPEN_SEARCH_PATH is set.\n          ** If it is set, then ACE::ldfind() scans the configured path\n          ** looking for a match on the name and prefix/suffix applications.\n          ** NOTE: having ACE scan for a file and then pass a fully-qualified\n          ** pathname to dlopen() is a potential security hole; therefore,\n          ** do not use ACE_MUST_HELP_DLOPEN_SEARCH_PATH unless necessary\n          ** and only after considering the risks.\n          */\n          ACE_Array<ACE_TString> dll_names;\n          dll_names.max_size (10);    // Decent guess to avoid realloc later\n\n#if defined (ACE_MUST_HELP_DLOPEN_SEARCH_PATH)\n          // Find out where the library is\n          ACE_TCHAR dll_pathname[MAXPATHLEN + 1];\n\n          // Transform the pathname into the appropriate dynamic link library\n          // by searching the ACE_LD_SEARCH_PATH.\n          ACE::ldfind (dll_name,\n                       dll_pathname,\n                       (sizeof dll_pathname / sizeof (ACE_TCHAR)));\n          ACE_TString dll_str (dll_pathname);\n          dll_names.size (1);\n          dll_names.set (dll_str, 0);\n#else\n          this->get_dll_names (dll_name, dll_names);\n#endif\n\n          ACE_TString *name = 0;\n          for (ACE_Array_Iterator<ACE_TString> name_iter (dll_names);\n               name_iter.next (name); name_iter.advance ())\n            {\n              if (this->open_i (name->c_str (), open_mode, errors))\n                break;\n\n#if defined (AIX)\n# define SHR_O ACE_TEXT(\"(shr.o)\")\n# define SHR_O_LEN (sizeof (SHR_O) / sizeof(ACE_TCHAR) - 1)\n              // AIX often puts the shared library file (most often named\n              // shr.o) inside an archive library. If this is an archive\n              // library name, then try appending [shr.o] and retry.\n              if (ACE_TString::npos != name->strstr (ACE_TEXT (\".a\")))\n                {\n                  ACE_TCHAR aix_pathname[MAXPATHLEN + 1];\n                  if (name->length () + SHR_O_LEN <= MAXPATHLEN)\n                    {\n                      ACE_OS::strcpy (aix_pathname, name->c_str());\n                      ACE_OS::strcat (aix_pathname, SHR_O);\n                    }\n                  else\n                    {\n                      if (errors)\n                        {\n                          errors->push (\"path is too long\");\n                        }\n\n                      if (ACE::debug ())\n                        {\n                          ACELIB_ERROR ((LM_ERROR,\n                                ACE_TEXT (\"ACE (%P|%t) DLL_Handle::open: \")\n                                ACE_TEXT (\"('%s(shr.o)') is too long\\n\"),\n                                name->c_str()));\n                        }\n\n                      return -1;\n                    }\n                  open_mode |= RTLD_MEMBER;\n\n                  if (this->open_i (aix_pathname, open_mode, errors))\n                    break;\n                }\n#endif /* AIX */\n            }\n\n          if (this->handle_ == ACE_SHLIB_INVALID_HANDLE)\n            {\n              if (ACE::debug ())\n                {\n                  ACE_TString errtmp;\n                  this->error (errtmp);\n                  ACELIB_ERROR ((LM_ERROR,\n                                ACE_TEXT (\"ACE (%P|%t) DLL_Handle::open (\\\"%s\\\"): \")\n                                ACE_TEXT (\"Invalid handle error: %s\\n\"),\n                                this->dll_name_,\n                                errtmp.c_str ()));\n                }\n              return -1;\n            }\n        }\n    }\n\n  ++this->refcount_;\n\n  if (ACE::debug ())\n    ACELIB_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) DLL_Handle::open - <%s> (%d), refcount=%d\\n\"),\n                this->dll_name_,\n                this->handle_,\n                this->refcount_));\n  return 0;\n}\n\n\nint\nACE_DLL_Handle::close (int unload)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::close\");\n\n  int retval = 0;\n  ACE_SHLIB_HANDLE h = ACE_SHLIB_INVALID_HANDLE;\n\n  // Only hold the lock until it comes time to dlclose() the DLL. Closing\n  // the DLL can cause further shutdowns as DLLs and their dependents are\n  // unloaded.\n  {\n    ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n\n    // Since we don't actually unload the dll as soon as the refcount\n    // reaches zero, we need to make sure we don't decrement it below\n    // zero.\n    if (this->refcount_ > 0)\n      --this->refcount_;\n    else\n      this->refcount_ = 0;\n\n    if (ACE::debug ())\n      ACELIB_DEBUG ((LM_DEBUG,\n                  ACE_TEXT (\"ACE (%P|%t) DLL_Handle::close - \")\n                  ACE_TEXT (\"<%s> (handle=%d, refcount=%d)\\n\"),\n                  this->dll_name_,\n                  this->handle_,\n                  this->refcount_));\n\n    if (this->refcount_ == 0 &&\n        this->handle_ != ACE_SHLIB_INVALID_HANDLE &&\n        unload == 1)\n      {\n        if (ACE::debug ())\n          ACELIB_DEBUG ((LM_DEBUG,\n                      ACE_TEXT (\"ACE (%P|%t) DLL_Handle::close: \")\n                      ACE_TEXT (\"Unloading <%s> (handle=%d)\\n\"),\n                      this->dll_name_,\n                      this->handle_));\n\n        // First remove any associated Framework Components.\n        ACE_Framework_Repository *frPtr= ACE_Framework_Repository::instance ();\n        if (frPtr)\n          {\n            frPtr->remove_dll_components (this->dll_name_);\n          }\n\n        h = this->handle_;\n        this->handle_ = ACE_SHLIB_INVALID_HANDLE;\n      }\n  } // Release lock_ here\n\n  if (h != ACE_SHLIB_INVALID_HANDLE)\n    {\n      retval = ACE_OS::dlclose (h);\n\n      if (retval != 0 && ACE::debug ())\n        {\n          ACE_TString err;\n          ACELIB_ERROR ((LM_ERROR,\n                      ACE_TEXT (\"ACE (%P|%t) DLL_Handle::close - \")\n                      ACE_TEXT (\"Failed with: <%s>\\n\"),\n                      this->error (err).c_str ()));\n        }\n    }\n\n  return retval;\n}\n\nsig_atomic_t\nACE_DLL_Handle::refcount (void) const\n{\n  return this->refcount_;\n}\n\nvoid *\nACE_DLL_Handle::symbol (const ACE_TCHAR *sym_name, bool ignore_errors)\n{\n  ACE_TString error;\n  return this->symbol (sym_name, ignore_errors, error);\n}\n\nvoid *\nACE_DLL_Handle::symbol (const ACE_TCHAR *sym_name, bool ignore_errors, ACE_TString &error)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::symbol\");\n  ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n\n  ACE_Auto_Array_Ptr <ACE_TCHAR> auto_name (ACE::ldname (sym_name));\n  // handle_ can be invalid especially when ACE_DLL_Handle resigned ownership\n  // BTW. Handle lifecycle management is a little crazy in ACE\n  if (this->handle_ != ACE_SHLIB_INVALID_HANDLE)\n    {\n#if defined (ACE_OPENVMS)\n      void *sym =  ACE::ldsymbol (this->handle_, auto_name.get ());\n#else\n      void *sym =  ACE_OS::dlsym (this->handle_, auto_name.get ());\n#endif\n\n      // Linux says that the symbol could be null and that it isn't an\n      // error.  So you should check the error message also, but since\n      // null symbols won't do us much good anyway, let's still report\n      // an error.\n      if (!sym && !ignore_errors)\n        {\n          this->error (error);\n\n          if (ACE::debug ())\n            ACELIB_ERROR ((LM_ERROR,\n                        ACE_TEXT (\"ACE (%P|%t) DLL_Handle::symbol <%s>\")\n                        ACE_TEXT (\" failed with <%s>\\n\"),\n                        auto_name.get (),\n                        error.c_str ()));\n\n          return 0;\n        }\n      return sym;\n    }\n  return 0;\n}\n\nACE_SHLIB_HANDLE\nACE_DLL_Handle::get_handle (bool become_owner)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::get_handle\");\n  ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n\n  if (this->refcount_ == 0 && become_owner)\n    {\n      if (ACE::debug ())\n        ACELIB_ERROR ((LM_ERROR,\n                    ACE_TEXT (\"ACE (%P|%t) DLL_Handle::get_handle: \")\n                    ACE_TEXT (\"cannot become owner, refcount == 0.\\n\")));\n\n      return ACE_SHLIB_INVALID_HANDLE;\n    }\n\n  ACE_SHLIB_HANDLE handle = this->handle_;\n\n  if (become_owner)\n    {\n      if (--this->refcount_ == 0)\n        this->handle_ = ACE_SHLIB_INVALID_HANDLE;\n    }\n\n  if (ACE::debug ())\n    ACELIB_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) DLL_Handle::get_handle: \")\n                ACE_TEXT (\"post call: handle %s, refcount %d\\n\"),\n                this->handle_ == ACE_SHLIB_INVALID_HANDLE ?\n                ACE_TEXT (\"invalid\") : ACE_TEXT (\"valid\"),\n                this->refcount_));\n\n  return handle;\n}\n\n// This method is used return the last error of a library operation.\nACE_TString &\nACE_DLL_Handle::error (ACE_TString &err)\n{\n  ACE_TRACE (\"ACE_DLL_Handle::error\");\n  const ACE_TCHAR *error = ACE_OS::dlerror ();\n  if (error)\n    {\n      err = error;\n    }\n  return err;\n}\n\nvoid\nACE_DLL_Handle::get_dll_names (const ACE_TCHAR *dll_name,\n                               ACE_Array<ACE_TString> &try_names)\n{\n  // Build the array of DLL names to try on this platform by applying the\n  // proper prefixes and/or suffixes to the specified dll_name.\n  ACE_TString base (dll_name);\n  ACE_TString base_dir, base_file, base_suffix;\n\n  // 1. Separate the dll_name into the dir part and the file part. We\n  // only decorate the file part to determine the names to try loading.\n  ACE_TString::size_type pos = base.rfind (ACE_DIRECTORY_SEPARATOR_CHAR);\n  if (pos != ACE_TString::npos)\n    {\n      base_dir = base.substr (0, pos + 1);\n      base_file = base.substr (pos + 1);\n    }\n  else\n    base_file = base;\n\n  // 2. Locate the file suffix, if there is one. Move the '.' and the\n  // suffix to base_suffix.\n  if ((pos = base_file.rfind (ACE_TEXT ('.'))) != ACE_TString::npos)\n    {\n      base_suffix = base_file.substr (pos);\n      base_file = base_file.substr (0, pos);\n    }\n\n  // 3. Build the combinations to try for this platform.\n  // Try these combinations:\n  //   - name with platform's dll prefix (if it has one) and suffix\n  //   - name with platform's dll prefix, decorator, and suffix.\n  //   - name with decorator and platform's suffix appended (if not supplied)\n  //   - name with platform's suffix appended (if not supplied)\n  //   - name as originally given\n  // We first try to find the file using the decorator so that when a\n  // filename with and without decorator is used, we get the file with\n  // the same decorator as the ACE dll has and then as last resort\n  // the one without. For example with msvc, the debug build has a \"d\"\n  // decorator, but the release build has none and we really want to get\n  // the debug version of the library in a debug application instead\n  // of the release one.\n  // So we need room for 5 entries in try_names.\n  try_names.size (0);\n  if ((try_names.max_size () - try_names.size ()) < 5)\n    try_names.max_size (try_names.max_size () + 5);\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n  ACE_TString decorator (ACE_LD_DECORATOR_STR);\n#endif\n  ACE_TString suffix (ACE_DLL_SUFFIX);\n  ACE_TString prefix (ACE_DLL_PREFIX);\n\n  for (size_t i = 0; i < 5 && try_names.size () < try_names.max_size (); ++i)\n    {\n      ACE_TString try_this;\n      size_t const j = try_names.size ();\n      switch (i)\n        {\n        case 0:        // Prefix + name + decorator + suffix\n        case 1:        // Prefix + name + suffix\n        case 2:        // Name + decorator + suffix\n        case 3:        // Name + suffix\n          if (\n              base_suffix.length () > 0\n#if !(defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK))\n              || (i == 1 || i == 3)    // No decorator desired; skip\n#endif\n              )\n            break;\n          try_this = base_dir;\n          if (i < 2)\n            try_this += prefix;\n          try_this += base_file;\n          if (base_suffix.length () > 0)\n            try_this += base_suffix;\n          else\n            {\n#if defined (ACE_LD_DECORATOR_STR) && !defined (ACE_DISABLE_DEBUG_DLL_CHECK)\n              try_this += decorator;\n#endif\n              try_this += suffix;\n            }\n          break;\n        case 4:\n          try_this = dll_name;\n          break;\n        }\n\n      if (try_this.length ())\n        {\n          try_names.size (j + 1);\n          try_names.set (try_this, j);\n        }\n    }\n  return;\n}\n\nbool\nACE_DLL_Handle::open_i (const ACE_TCHAR *dll_name, int open_mode, ERROR_STACK* errors)\n{\n  // The ACE_SHLIB_HANDLE object is obtained.\n  this->handle_ = ACE_OS::dlopen (dll_name, open_mode);\n\n  if (errors || ACE::debug ())\n    {\n      ACE_TString err;\n      this->error (err);\n      if (errors && err.length () > 0)\n        {\n          errors->push (err);\n        }\n      if (ACE::debug ())\n        {\n          ACELIB_DEBUG ((LM_DEBUG,\n                      ACE_TEXT (\"ACE (%P|%t) DLL_Handle::open_i \")\n                      ACE_TEXT (\"<%s>, 0x%x) -> <%s>: <%s>\\n\"),\n                      dll_name,\n                      open_mode,\n                      ((this->handle_ != ACE_SHLIB_INVALID_HANDLE)\n                      ? ACE_TEXT (\"succeeded\")\n                      : ACE_TEXT (\"failed\")),\n                      err.c_str ()));\n        }\n    }\n\n  return this->handle_ != ACE_SHLIB_INVALID_HANDLE;\n}\n\n/******************************************************************/\n\n// Pointer to the Singleton instance.\nACE_DLL_Manager *ACE_DLL_Manager::instance_ = 0;\n\n\nACE_DLL_Manager *\nACE_DLL_Manager::instance (int size)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::instance\");\n\n  if (ACE_DLL_Manager::instance_ == 0)\n    {\n      // Perform Double-Checked Locking Optimization.\n      ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,\n                                *ACE_Static_Object_Lock::instance (), 0));\n      if (ACE_DLL_Manager::instance_ == 0)\n        {\n          ACE_NEW_RETURN (ACE_DLL_Manager::instance_,\n                          ACE_DLL_Manager (size),\n                          0);\n        }\n    }\n\n  return ACE_DLL_Manager::instance_;\n}\n\nvoid\nACE_DLL_Manager::close_singleton (void)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::close_singleton\");\n\n  ACE_MT (ACE_GUARD (ACE_Recursive_Thread_Mutex, ace_mon,\n                     *ACE_Static_Object_Lock::instance ()));\n\n  delete ACE_DLL_Manager::instance_;\n  ACE_DLL_Manager::instance_ = 0;\n}\n\nACE_DLL_Manager::ACE_DLL_Manager (int size)\n  : handle_vector_ (0),\n    current_size_ (0),\n    total_size_ (0),\n    unload_policy_ (ACE_DLL_UNLOAD_POLICY_PER_DLL)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::ACE_DLL_Manager\");\n\n  if (this->open (size) != 0 && ACE::debug ())\n    ACELIB_ERROR ((LM_ERROR,\n                ACE_TEXT (\"ACE (%P|%t) DLL_Manager ctor failed to allocate \")\n                ACE_TEXT (\"handle_vector_.\\n\")));\n}\n\nACE_DLL_Manager::~ACE_DLL_Manager (void)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::~ACE_DLL_Manager\");\n\n  if (this->close () != 0 && ACE::debug ())\n    ACELIB_ERROR ((LM_ERROR,\n                ACE_TEXT (\"ACE (%P|%t) DLL_Manager dtor failed to close \")\n                ACE_TEXT (\"properly.\\n\")));\n}\n\nACE_ALLOC_HOOK_DEFINE(ACE_DLL_Manager)\n\nACE_DLL_Handle *\nACE_DLL_Manager::open_dll (const ACE_TCHAR *dll_name,\n                           int open_mode,\n                           ACE_SHLIB_HANDLE handle,\n                           ACE_DLL_Handle::ERROR_STACK *errors)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::open_dll\");\n\n  ACE_DLL_Handle *temp_handle = 0;\n  ACE_DLL_Handle *dll_handle = 0;\n  {\n    ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n    dll_handle = this->find_dll (dll_name);\n    if (!dll_handle)\n      {\n        if (this->current_size_ < this->total_size_)\n          {\n            ACE_NEW_RETURN (temp_handle,\n                            ACE_DLL_Handle,\n                            0);\n\n            dll_handle = temp_handle;\n          }\n      }\n  }\n\n  if (dll_handle)\n    {\n      if (dll_handle->open (dll_name, open_mode, handle, errors) != 0)\n        {\n          // Error while opening dll. Free temp handle\n          if (ACE::debug ())\n            ACELIB_ERROR ((LM_ERROR,\n                        ACE_TEXT (\"ACE (%P|%t) DLL_Manager::open_dll: Could not \")\n                        ACE_TEXT (\"open dll <%s>\\n\"),\n                        dll_name));\n\n          delete temp_handle;\n          return 0;\n        }\n\n      // Add the handle to the vector only if the dll is successfully\n      // opened.\n      if (temp_handle != 0)\n        {\n          ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n          this->handle_vector_[this->current_size_] = dll_handle;\n          ++this->current_size_;\n        }\n    }\n\n  return dll_handle;\n}\n\nint\nACE_DLL_Manager::close_dll (const ACE_TCHAR *dll_name)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::close_dll\");\n  ACE_DLL_Handle *handle = 0;\n\n  {\n    ACE_MT (ACE_GUARD_RETURN (ACE_Thread_Mutex, ace_mon, this->lock_, 0));\n    handle = this->find_dll (dll_name);\n  }\n\n  if (handle)\n    {\n      return this->unload_dll (handle, 0);\n    }\n\n  return -1;\n}\n\nu_long\nACE_DLL_Manager::unload_policy (void) const\n{\n  ACE_TRACE (\"ACE_DLL_Manager::unload_policy\");\n  return this->unload_policy_;\n}\n\nvoid\nACE_DLL_Manager::unload_policy (u_long unload_policy)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::unload_policy\");\n  ACE_MT (ACE_GUARD (ACE_Thread_Mutex, ace_mon, this->lock_));\n\n  u_long old_policy = this->unload_policy_;\n  this->unload_policy_ = unload_policy;\n\n  // If going from LAZY to EAGER or from PER_DLL to PER_PROCESS|EAGER,\n  // call close(1) on all the ACE_DLL_Handle objects with refcount == 0\n  // which will force those that are still loaded to be unloaded.\n  if (this->handle_vector_)\n    if (( ACE_BIT_ENABLED (old_policy, ACE_DLL_UNLOAD_POLICY_LAZY) &&\n          ACE_BIT_DISABLED (this->unload_policy_, ACE_DLL_UNLOAD_POLICY_LAZY) ) ||\n        ( ACE_BIT_DISABLED (this->unload_policy_, ACE_DLL_UNLOAD_POLICY_LAZY) &&\n          ACE_BIT_ENABLED (old_policy, ACE_DLL_UNLOAD_POLICY_PER_DLL) &&\n          ACE_BIT_DISABLED (this->unload_policy_, ACE_DLL_UNLOAD_POLICY_PER_DLL) ))\n      {\n        for (int i = this->current_size_ - 1; i >= 0; i--)\n          {\n            if (this->handle_vector_[i] &&\n                this->handle_vector_[i]->refcount () == 0)\n              this->handle_vector_[i]->close (1);\n          }\n      }\n}\n\nint\nACE_DLL_Manager::open (int size)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::open\");\n\n  ACE_DLL_Handle **temp = 0;\n\n#if defined (ACE_HAS_ALLOC_HOOKS)\n  ACE_ALLOCATOR_RETURN (temp,\n                        static_cast<ACE_DLL_Handle**> (ACE_Allocator::instance()->malloc(sizeof (ACE_DLL_Handle*) * size)),\n                        -1);\n#else\n  ACE_NEW_RETURN (temp,\n                  ACE_DLL_Handle *[size],\n                  -1);\n#endif /* ACE_HAS_ALLOC_HOOKS */\n\n  this->handle_vector_ = temp;\n  this->total_size_ = size;\n  return 0;\n}\n\nint\nACE_DLL_Manager::close (void)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::close\");\n\n  int force_close = 1;\n\n  if (this->handle_vector_ != 0)\n    {\n      // Delete components in reverse order.\n      for (int i = this->current_size_ - 1; i >= 0; i--)\n        {\n          if (this->handle_vector_[i])\n            {\n              ACE_DLL_Handle *s =\n                const_cast<ACE_DLL_Handle *> (this->handle_vector_[i]);\n              this->handle_vector_[i] = 0;\n              this->unload_dll (s, force_close);\n              delete s;\n            }\n        }\n\n#if defined (ACE_HAS_ALLOC_HOOKS)\n      ACE_Allocator::instance()->free(this->handle_vector_);\n#else\n      delete [] this->handle_vector_;\n#endif /* ACE_HAS_ALLOC_HOOKS */\n\n      this->handle_vector_ = 0;\n      this->current_size_ = 0;\n    }\n  return 0;\n}\n\nACE_DLL_Handle *\nACE_DLL_Manager::find_dll (const ACE_TCHAR *dll_name) const\n{\n  ACE_TRACE (\"ACE_DLL_Manager::find_dll\");\n\n  for (int i = 0; i < this->current_size_; i++)\n    if (this->handle_vector_[i] &&\n        ACE_OS::strcmp (this->handle_vector_[i]->dll_name (), dll_name) == 0)\n      {\n        return this->handle_vector_[i];\n      }\n\n  return 0;\n}\n\nint\nACE_DLL_Manager::unload_dll (ACE_DLL_Handle *dll_handle, int force_unload)\n{\n  ACE_TRACE (\"ACE_DLL_Manager::unload_dll\");\n\n  if (dll_handle)\n    {\n      int unload = force_unload;\n      if (unload == 0)\n        {\n          // apply strategy\n          if (ACE_BIT_DISABLED (this->unload_policy_,\n                                ACE_DLL_UNLOAD_POLICY_PER_DLL))\n            {\n              unload = ACE_BIT_DISABLED (this->unload_policy_,\n                                         ACE_DLL_UNLOAD_POLICY_LAZY);\n            }\n          else\n            {\n              // Declare the type of the symbol:\n              typedef int (*dll_unload_policy)(void);\n\n              void * const unload_policy_ptr =\n                dll_handle->symbol (ACE_TEXT (\"_get_dll_unload_policy\"), 1);\n#if defined (ACE_OPENVMS) && (!defined (__INITIAL_POINTER_SIZE) || (__INITIAL_POINTER_SIZE < 64))\n              int const temp_p =\n                reinterpret_cast<int> (unload_policy_ptr);\n#else\n              intptr_t const temp_p =\n                reinterpret_cast<intptr_t> (unload_policy_ptr);\n#endif\n\n              dll_unload_policy const the_policy =\n                reinterpret_cast<dll_unload_policy> (temp_p);\n\n              if (the_policy != 0)\n                unload = ACE_BIT_DISABLED (the_policy (),\n                                           ACE_DLL_UNLOAD_POLICY_LAZY);\n              else\n                unload = ACE_BIT_DISABLED (this->unload_policy_,\n                                           ACE_DLL_UNLOAD_POLICY_LAZY);\n            }\n        }\n\n      if (dll_handle->close (unload) != 0)\n        {\n          if (ACE::debug ())\n            ACELIB_ERROR ((LM_ERROR,\n                        ACE_TEXT (\"ACE (%P|%t) DLL_Manager::unload error.\\n\")));\n\n          return -1;\n        }\n    }\n  else\n    {\n      if (ACE::debug ())\n        ACELIB_ERROR ((LM_ERROR,\n                    ACE_TEXT (\"ACE (%P|%t) DLL_Manager::unload_dll called with \")\n                    ACE_TEXT (\"null pointer.\\n\")));\n\n      return -1;\n    }\n\n  return 0;\n}\n\nACE_END_VERSIONED_NAMESPACE_DECL\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Based_Pointer_Test.cpp": "\n//=============================================================================\n/**\n *  @file    Based_Pointer_Test.cpp\n *\n *  This test check the Based_Pointer and Based_Pointer_repository classes.\n *\n *  @author Steve Williams  <steve@telxio>\n */\n//=============================================================================\n\n\n#include \"test_config.h\"\n#include \"ace/DLL.h\"\n#include \"ace/ACE.h\"\n#ifdef ACE_HAS_POSITION_INDEPENDENT_POINTERS\n#include \"ace/Based_Pointer_Repository.h\"\n#endif /* ACE_HAS_POSITION_INDEPENDENT_POINTERS */\n#include \"ace/Malloc_T.h\"\n#include \"ace/MMAP_Memory_Pool.h\"\n#include \"ace/PI_Malloc.h\"\n#include \"ace/Null_Mutex.h\"\n#include \"ace/Based_Pointer_T.h\"\n#include \"ace/SString.h\"\n#include \"ace/OS_NS_unistd.h\"\n\nclass Foo\n{\nprivate:\n  Foo(const Foo &)\n  {\n  }\npublic:\n  friend class ace_dewarn_gplusplus;\n  ~Foo ()\n  {\n  }\n};\n\nclass Void_Pointer : public ACE_Based_Pointer<void>\n{\n};\n\n#ifdef ACE_HAS_POSITION_INDEPENDENT_POINTERS\n\n#if defined (ACE_LD_DECORATOR_STR)\n# define OBJ_SUFFIX ACE_LD_DECORATOR_STR ACE_DLL_SUFFIX\n#else\n# define OBJ_SUFFIX ACE_DLL_SUFFIX\n#endif /* ACE_LD_DECORATOR_STR */\n\n#if defined (ACE_WIN32) || defined (ACE_OPENVMS)\n#  define OBJ_PREFIX ACE_DLL_PREFIX\n#else\n#  define OBJ_PREFIX ACE_TEXT(\"./\") ACE_DLL_PREFIX\n#endif /* ACE_WIN32 */\n\n// Declare the type of the DLL symbol:\ntypedef void *(*Get_Bp_Repository_Inst)(void);\n\n// Declare an allocator based MMAP_Memory_Pool\ntypedef ACE_Malloc_T< ACE_MMAP_MEMORY_POOL, ACE_Null_Mutex, ACE_PI_Control_Block\n                   > MMAP_Allocator;\n\n\n// Check that the ACE_Based_Pointer_Repository can be accessed\n// from a Windows DLL\n// (see http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=1991)\nint singleton_test (void)\n{\n    void* baddr1 = ACE_BASED_POINTER_REPOSITORY::instance();\n    void* baddr2 = ACE_BASED_POINTER_REPOSITORY::instance();\n\n    if (baddr1 != baddr2)\n    {\n      ACE_ERROR_RETURN ((LM_ERROR,\n                         ACE_TEXT (\"ACE_Based_Pointer_Repository is not a singleton\\n\")),\n                        -1);\n    }\n\n// Protection against this test being run on platforms not supporting Dlls.\n#if defined(ACE_HAS_DYNAMIC_LINKING)\n\n    ACE_TString dll_file;\n    const char *subdir_env = ACE_OS::getenv (\"ACE_EXE_SUB_DIR\");\n    if (subdir_env)\n      {\n        dll_file = ACE_TEXT_CHAR_TO_TCHAR (subdir_env);\n        dll_file += ACE_DIRECTORY_SEPARATOR_STR;\n      }\n\n    dll_file += OBJ_PREFIX ACE_TEXT (\"Based_Pointer_Test_Lib\") OBJ_SUFFIX;\n\n    // If DLL causes multiple instances of singleton\n    // then the ACE_Cleanup object registered\n    // with the ACE_Object_manager will no longer be valid,\n    // at exit time if the library is unloaded. Override\n    // the default close on destruct.\n    ACE_DLL dll;\n    int retval = dll.open (dll_file.c_str (),\n                           ACE_DEFAULT_SHLIB_MODE,\n                           0);\n\n    if (retval != 0)\n       {\n       ACE_TCHAR *dll_error = dll.error ();\n       ACE_ERROR_RETURN ((LM_ERROR,\n                           ACE_TEXT (\"Error in DLL Open: %s\\n\"),\n                           dll_error ? dll_error : ACE_TEXT (\"unknown error\")),\n                           -1);\n       }\n\n#if defined (ACE_OPENVMS)\n    // with OPENVMS symbol names > 31 cause us trouble with dlsym()\n    void* foo = dll.symbol (ACE_TEXT (\"get_based_pointer_repo_inst\"));\n#else\n    void* foo = dll.symbol (ACE_TEXT (\"get_based_pointer_repository_instance\"));\n#endif\n\n    // Cast the void* to function* with a long as intermediate.\n    ptrdiff_t tmp = reinterpret_cast<ptrdiff_t> (foo);\n    Get_Bp_Repository_Inst get_bp_repository_inst =\n       reinterpret_cast<Get_Bp_Repository_Inst> (tmp);\n    if (get_bp_repository_inst == 0)\n       ACE_ERROR_RETURN ((LM_ERROR,\n                          ACE_TEXT (\"%p\\n\"),\n                          dll.error ()),\n                         -1);\n\n    void* baddr_dll = get_bp_repository_inst ();\n\n    dll.close ();\n\n    if (baddr_dll != baddr1)\n      {\n        ACE_ERROR_RETURN ((LM_ERROR,\n                           ACE_TEXT (\"ACE_Based_Pointer_Repository is not a \")\n                           ACE_TEXT (\"singleton in DLL <%@> <%@>\\n\"),\n                           baddr_dll,\n                           baddr1),\n                          -1);\n      }\n#endif /* ACE_HAS_DYNAMIC_LINKING */\n\n    return 0;\n}\n\n// Check that MMAP memory blocks are correctly mapped\n// into the Based_Pointer_Repository\nint\nmmap_map_test(void)\n{\n    MMAP_Allocator* alloc = 0;\n\n    ACE_OS::unlink(\"foo\");\n      {\n        // The 'options' are only here to quiet MSVC 6. It can be removed\n        // when MSVC 6 support is removed.\n        MMAP_Allocator::MEMORY_POOL_OPTIONS *options = 0;\n        ACE_NEW_RETURN\n          (alloc,\n           MMAP_Allocator (ACE_TEXT (\"foo\"), ACE_TEXT (\"foo\"), options),\n           -1);\n\n        void* addr = alloc->base_addr();\n        if(addr == 0)\n         {\n           ACE_ERROR((LM_ERROR,\n               ACE_TEXT (\"Unable to get base to MMAP Memory Pool\\n\")));\n           alloc->remove();\n           delete alloc;\n            return -1;\n         }\n\n       // Check a base address mapping was added to the Repository\n       // when the pool was created\n       void* ba = 0;\n       if(ACE_BASED_POINTER_REPOSITORY::instance()->find(addr, ba) == -1)\n        {\n           ACE_ERROR((LM_ERROR, ACE_TEXT (\"Unable to access repository\\n\")));\n           alloc->remove();\n           delete alloc;\n           return -1;\n         }\n\n       alloc->remove();\n       delete alloc;\n\n       if(ba != addr)\n         {\n           ACE_ERROR_RETURN ((LM_ERROR,\n                              ACE_TEXT (\"MMAP pool mapping not present\\n\")),\n                             -1);\n         }\n\n       // Check Mapping is removed when object is deleted\n       if (ACE_BASED_POINTER_REPOSITORY::instance()->find(addr, ba) == -1)\n         {\n           ACE_ERROR_RETURN ((LM_ERROR,\n                              ACE_TEXT (\"Unable to access repository\\n\")),\n                             -1);\n         }\n       if(ba != 0)\n         {\n           ACE_ERROR_RETURN ((LM_ERROR,\n                              ACE_TEXT (\"MMAP pool mapping not removed\\n\")),\n                             -1);\n         }\n    }\n    return 0;\n}\n\n// Check that persistent MMAP memory blocks are correctly remapped\n// into the Based_Pointer_Repository\n// (i.e. maps based on backing stores that are already\n//  present in the filesystem)\n// (see http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=2216)\nint\nmmap_persistent_map_test(void)\n{\n    MMAP_Allocator* alloc = 0;\n\n    // The 'options' are only here to quiet MSVC 6. It can be removed\n    // when MSVC 6 support is removed.\n    MMAP_Allocator::MEMORY_POOL_OPTIONS *options = 0;\n    ACE_OS::unlink(\"foo\");\n      {\n        ACE_NEW_RETURN\n          (alloc,\n           MMAP_Allocator (ACE_TEXT (\"foo\"), ACE_TEXT (\"foo\"), options),\n           -1);\n        alloc->sync();\n\n        // Delete Malloc and the memory pool, but do not remove\n        // the backing store\n        alloc->memory_pool().release(0);\n        delete alloc;\n      }\n    //\n    // Recreate segment with existing backing store\n    //\n    ACE_NEW_RETURN\n      (alloc,\n       MMAP_Allocator (ACE_TEXT (\"foo\"), ACE_TEXT(\"foo\"), options),\n       -1);\n\n    void* addr = alloc->base_addr();\n    if(addr == 0)\n      {\n        ACE_ERROR ((LM_ERROR,\n           ACE_TEXT (\"Unable to get base to persistent MMAP Memory Pool\\n\")));\n        alloc->remove();\n        delete alloc;\n        return -1;\n      }\n    void* ba = 0;\n    if(ACE_BASED_POINTER_REPOSITORY::instance()->find(addr, ba) == -1)\n      {\n        ACE_ERROR ((LM_ERROR,\n                    ACE_TEXT (\"Unable to find base address after map of persistent segment\\n\")));\n        alloc->remove();\n        delete alloc;\n        return -1;\n      }\n    if(ba == 0)\n      {\n        ACE_ERROR ((LM_ERROR,\n           ACE_TEXT (\"Persistent MMAP Memory Pool not mapped\\n\")));\n        alloc->remove();\n        delete alloc;\n        return -1;\n      }\n\n    alloc->remove();\n    delete alloc;\n    return 0;\n}\n\n// Check that MMAP memory blocks are correctly remapped\n// into the Based_Pointer_Repository\n// (i.e. when a segment is resized it may move its base address\n// because the OS cannot fit the new segment size at the same\n// base address, in this case the Repository must be updated)\n// (see http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=2218)\nint\nmmap_remap_test(void)\n{\n    // Use a Position Independent memory segment\n    // because this one is going to move\n\n    MMAP_Allocator *alloc[ 3 ]= {0, 0, 0};\n    void *pool_base[ 3 ]= {0, 0, 0};\n\n    // Make sure the Pool options are set to allow\n    // the segment to move\n    ACE_MMAP_Memory_Pool_Options data_opts(\n               0,\n               ACE_MMAP_Memory_Pool_Options::NEVER_FIXED );\n    int i;\n\n    for (i= 0; i<3; ++i)\n      {\n        ACE_TCHAR store[ MAXPATHLEN + 1 ];\n        ACE_OS::snprintf( store, MAXPATHLEN + 1, ACE_TEXT(\"foo%d\"), i );\n        ACE_OS::unlink( store );\n\n        ACE_NEW_RETURN (alloc[ i ],\n                        MMAP_Allocator (store, store, &data_opts),\n                        -1);\n        pool_base[ i ]= alloc[ i ]->base_addr();\n      }\n\n    // sort pools into base address order\n    for (i= 0; i<2; ++i)\n      {\n        if (pool_base[ i ] < pool_base[ i+1 ])\n          {\n            void *tmp1= pool_base[ i ];\n            MMAP_Allocator *tmp2= alloc[ i ];\n            pool_base[ i ]= pool_base[ i+1 ];\n            alloc[ i ]= alloc[ i+1 ];\n            pool_base[ i+1 ]= tmp1;\n            alloc[ i+1 ]= tmp2;\n            i= -1;\n          }\n      }\n\n    // alloc[1] is now bounded, whether memory grows up or\n    // down, it will hit either alloc[0] or alloc[2] and have\n    // to be remapped.\n    //\n    // Calculate maximum space between base addresses\n\n    size_t size= (char *) pool_base[ 0 ] - (char *) pool_base[ 1 ];\n    size_t tmpsize= (char *) pool_base[ 1 ] - (char *) pool_base[ 2 ];\n    size= (size < tmpsize) ? tmpsize : size;\n\n    // force pool to move\n    ++size;\n\n    (void)alloc[ 1 ]->malloc(size);\n    void *nba= alloc[ 1 ]->base_addr();\n\n    if (pool_base[ 1 ] == nba)\n      {\n        ACE_ERROR ((LM_ERROR,\n                   ACE_TEXT (\"MMAP Pool did not move base address as expected\\n\")));\n        for (i= 0; i<3; ++i)\n          {\n            alloc[ i ]->remove();\n            delete alloc[ i ];\n          }\n        return -1;\n      }\n\n    void *ba= 0;\n    if (ACE_BASED_POINTER_REPOSITORY::instance()->find(nba, ba) == -1)\n      {\n        ACE_ERROR ((LM_ERROR,\n            ACE_TEXT (\"Unable to find base address after remap of segment\\n\")));\n        for (i= 0; i<3; ++i)\n          {\n            alloc[ i ]->remove();\n            delete alloc[ i ];\n          }\n        return -1;\n      }\n\n    if (ba != nba)\n      {\n        ACE_ERROR ((LM_ERROR,\n              ACE_TEXT (\"New base address not mapped after MMAP remap\\n\")));\n        for (i= 0; i<3; ++i)\n          {\n            alloc[ i ]->remove();\n            delete alloc[ i ];\n          }\n        return -1;\n      }\n\n    // Check old base address has been removed\n    // from the repository\n    if (ACE_BASED_POINTER_REPOSITORY::instance()->find( pool_base[ 1 ], ba ) == -1)\n      {\n         ACE_ERROR ((LM_ERROR,\n            ACE_TEXT (\"Unable to find base address after remap of segment\\n\")));\n         for (i= 0; i<3; ++i)\n           {\n             alloc[ i ]->remove();\n             delete alloc[ i ];\n           }\n         return -1;\n      }\n\n    if (ba == pool_base[ 1 ])\n      {\n        ACE_ERROR ((LM_ERROR,\n            ACE_TEXT (\"Old base address not removed after MMAP remap\\n\")));\n        for (i= 0; i<3; ++i)\n          {\n            alloc[ i ]->remove();\n            delete alloc[ i ];\n          }\n        return -1;\n      }\n\n    for (i= 0; i<3; ++i)\n      {\n        alloc[ i ]->remove();\n        delete alloc[ i ];\n      }\n    return 0;\n}\n\n\nint\nrun_main (int, ACE_TCHAR *[])\n{\n    ACE_START_TEST (ACE_TEXT (\"Based_Pointer_Test\"));\n\n    int retval = 0;\n\n    retval += singleton_test ();\n    retval += mmap_map_test();\n    retval += mmap_persistent_map_test();\n    retval += mmap_remap_test();\n\n    ACE_Based_Pointer_Basic<Foo> Foo_Ptr;\n    ACE_UNUSED_ARG (Foo_Ptr);\n\n    ACE_END_TEST;\n    return retval == 0 ? 0 : 1;\n}\n\n#else /* ! ACE_HAS_POSITION_INDEPENDENT_POINTERS */\n// Nothing to test !\nint\nrun_main (int, ACE_TCHAR *[])\n{\n    ACE_START_TEST (ACE_TEXT (\"Based_Pointer_Test\"));\n    ACE_Based_Pointer_Basic<Foo> Foo_Ptr;\n    ACE_UNUSED_ARG (Foo_Ptr);\n    ACE_END_TEST;\n    return 0;\n}\n#endif /* ACE_HAS_POSITION_INDEPENDENT_POINTERS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/DLL_Test.cpp": "\n//=============================================================================\n/**\n *  @file    DLL_Test.cpp\n *\n *  This test illustrates the use of <ACE_DLL> wrapper class.\n *\n *  @author Kirthika Parameswaran  <kirthika@cs.wustl.edu>\n */\n//=============================================================================\n\n#include \"test_config.h\"\n#include \"ace/DLL.h\"\n#include \"ace/Auto_Ptr.h\"\n#include \"ace/ACE.h\"\n#include \"ace/DLL_Manager.h\"\n#include \"ace/SString.h\"\n#include \"ace/OS_NS_dlfcn.h\"\n#include \"DLL_Test.h\"\n\n#if defined (ACE_LD_DECORATOR_STR)\n# define OBJ_SUFFIX ACE_LD_DECORATOR_STR ACE_DLL_SUFFIX\n#else\n# define OBJ_SUFFIX ACE_DLL_SUFFIX\n#endif /* ACE_LD_DECORATOR_STR */\n\n#if defined (ACE_WIN32) || defined (ACE_OPENVMS)\n#  define OBJ_PREFIX ACE_DLL_PREFIX\n#else\n#  define OBJ_PREFIX ACE_TEXT(\"./\") ACE_DLL_PREFIX\n#endif /* ACE_WIN32 */\n\n// Declare the type of the symbol:\ntypedef Hello *(*Hello_Factory)(void);\n\ntypedef int ( *PFN )( Parent* );\n\nint handle_test (ACE_DLL &dll)\n{\n  // Test the get/set_handle methods.\n  ACE_DLL local_dll;\n\n  ACE_SHLIB_HANDLE handle = dll.get_handle (1);\n  if (handle != ACE_SHLIB_INVALID_HANDLE)\n    {\n      if (local_dll.set_handle (handle) != 0)\n        ACE_ERROR_RETURN ((LM_ERROR,\n                           ACE_TEXT (\"Error setting handle.\\n\")),\n                          -1);\n      return 0;\n    }\n  ACE_ERROR_RETURN ((LM_ERROR,\n                     ACE_TEXT (\"Error getting handle.\\n\")),\n                    -1);\n}\n\nint basic_test (ACE_DLL &dll)\n{\n\n  ACE_TString dll_file;\n  const char *subdir_env = ACE_OS::getenv (\"ACE_EXE_SUB_DIR\");\n  if (subdir_env)\n    {\n      dll_file = ACE_TEXT_CHAR_TO_TCHAR (subdir_env);\n      dll_file += ACE_DIRECTORY_SEPARATOR_STR;\n    }\n\n  dll_file += OBJ_PREFIX ACE_TEXT (\"DLL_Test_Lib\") OBJ_SUFFIX;\n\n  int retval = dll.open (dll_file.c_str());\n\n  if (retval != 0)\n    {\n      ACE_TCHAR *dll_error = dll.error ();\n      ACE_ERROR_RETURN ((LM_ERROR,\n                         ACE_TEXT (\"Error in DLL Open of <%s>: %s\\n\"),\n                         OBJ_PREFIX ACE_TEXT (\"DLL_Test_Lib\") OBJ_SUFFIX,\n                         dll_error ? dll_error : ACE_TEXT (\"unknown error\")),\n                        -1);\n    }\n\n  // Just because the ANSI C++ spec says you can no longer cast a\n  // void* to a function pointer. Doesn't allow:\n  // TC f = (Hello_Factory) dll.symbol (\"get_hello\");\n  void *foo = dll.symbol (ACE_TEXT (\"get_hello\"));\n\n  // Cast the void* to long first.\n  ptrdiff_t tmp = reinterpret_cast<ptrdiff_t> (foo);\n  Hello_Factory factory = reinterpret_cast<Hello_Factory> (tmp);\n  if (factory == 0)\n    ACE_ERROR_RETURN ((LM_ERROR,\n                       ACE_TEXT (\"%p\\n\"),\n                       dll.error ()),\n                      -1);\n\n#if defined ACE_HAS_CPP11\n  std::unique_ptr<Hello> my_hello (factory ());\n#else\n  auto_ptr<Hello> my_hello (factory ());\n#endif\n\n  // Make the method calls, as the object pointer is available.\n  my_hello->say_hello ();\n  my_hello->say_next ();\n\n  // Allocate and delete a string allocated via new in a different dll.\n  ACE_TCHAR *new_str = my_hello->new_info ();\n  ACE_DEBUG ((LM_DEBUG, ACE_TEXT (\"Result for new_info(): %s\\n\"), new_str));\n  ACE::strdelete (new_str);\n\n  // Allocate and free a string allocated via malloc in a different dll.\n  ACE_TCHAR *malloc_str = my_hello->malloc_info ();\n  ACE_DEBUG ((LM_DEBUG, ACE_TEXT (\"Result for malloc_info(): %s\\n\"), malloc_str));\n  ACE_OS::free (malloc_str);\n\n  return 0;\n}\n\nint dynamic_cast_test (ACE_DLL &dll)\n{\n  Child child;\n  child.test();\n\n  Parent *parent = &child;\n\n  void * foo = dll.symbol (ACE_TEXT (\"dynamic_cast_test\"));\n\n  // Cast the void* to long first.\n  ptrdiff_t tmp = reinterpret_cast<ptrdiff_t> (foo);\n  PFN pfnAcquire = reinterpret_cast<PFN> (tmp);\n  if (pfnAcquire == 0)\n    ACE_ERROR_RETURN ((LM_ERROR,\n                       ACE_TEXT (\"%p\\n\"),\n                       dll.error ()),\n                      -1);\n\n  ACE_DEBUG ((LM_DEBUG, ACE_TEXT (\"before %@ %@\\n\"),\n              &child,  dynamic_cast<Child*> (parent)));\n\n  if (pfnAcquire (&child) == -1)\n    ACE_ERROR_RETURN ((LM_ERROR, ACE_TEXT (\"dynamic_cast failed.\\n\")), -1);\n\n  return 0;\n}\n\n\nint\nrun_main (int, ACE_TCHAR *[])\n{\n  ACE_START_TEST (ACE_TEXT (\"DLL_Test\"));\n\n  int retval = 0;\n\n// Protection against this test being run on platforms not supporting Dlls.\n#if defined(ACE_HAS_DYNAMIC_LINKING)\n\n  ACE_DLL dll;\n\n  retval += basic_test (dll);\n\n  retval += dynamic_cast_test (dll);\n\n  retval += handle_test (dll);\n\n  // Call close here so that any errors make it into the log.\n  dll.close ();\n\n#else\n  ACE_ERROR ((LM_INFO,\n              ACE_TEXT (\"Dynamically Linkable Libraries not supported on this platform\\n\")));\n#endif /* ACE_HAS_DYNAMIC_LINKING */\n\n  ACE_TEST_ASSERT (ACE_OS::dlsym (ACE_SHLIB_INVALID_HANDLE, ACE_TEXT (\"open\")));\n\n  ACE_END_TEST;\n  return retval == 0 ? 0 : 1;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Based_Pointer_Test_Lib.cpp": "\n//=============================================================================\n/**\n *  @file    Based_Pointer_Test_Lib.cpp\n *\n *  This test confirms the function of the Based_Pointer_Repository\n *\n *  @author Steve Williams  <steve@telxio>\n */\n//=============================================================================\n\n\n#include \"ace/ACE.h\"\n#include \"ace/svc_export.h\"\n#include \"ace/Based_Pointer_Repository.h\"\n\n#if defined (ACE_OPENVMS)\n// with OPENVMS symbol names > 31 cause us trouble with dlsym()\nextern \"C\" ACE_Svc_Export void *\nget_based_pointer_repo_inst (void)\n#else\nextern \"C\" ACE_Svc_Export void *\nget_based_pointer_repository_instance (void)\n#endif\n{\n    void* baddr = ACE_BASED_POINTER_REPOSITORY::instance();\n    return baddr;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Bug_2980_Regression_Test.cpp": "//FUZZ: disable check_for_lack_ACE_OS\n\n#include \"ace/config-lite.h\"\n\n#include <iostream>\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <string.h>\n\n// This is a non-ACE driver program which loads an ACE-based DLL.  The\n// usual ACE-related defines will not apply and we must use\n// platform-specific ones.\n//\n// This test has not been made to work on Windows and vxWorks, yet ...\n\n#if defined (ACE_HAS_THREADS)\n#  define CAN_USE_THREADS\n#else\n#  undef CAN_USE_THREADS\n#endif\n\n#if !(defined (WIN32) || defined (ACE_VXWORKS) || defined (ACE_HAS_LYNXOS_178))\\\n    && !defined ACE_FACE_SAFETY_EXTENDED\n#  define CAN_RUN_TEST\n\n#  include <dlfcn.h>\n\nnamespace {\n#  if defined (ACE_DLL_SUFFIX)\n  const char *DllTestName = \"./libBug_2980_Regression\" ACE_DLL_SUFFIX;\n#else\n  const char *DllTestName = \"./libBug_2980_Regression.so\";\n#endif /* ACE_DLL_SUFFIX */\n}\n\n#  if defined CAN_USE_THREADS\n#    include <pthread.h>\n#  endif\n\n#else\n#  undef CAN_RUN_TEST\n#endif\n\n#if defined (__BORLANDC__)\n#  define PRINTF std::printf\n#else\n#  define PRINTF printf\n#endif\n\n\ntypedef int (* voidfunction)(void);\n\n\n#if defined (CAN_RUN_TEST)\nstatic void * dllHandle;\nstatic voidfunction   capi_init = 0;\nstatic voidfunction   capi_fini = 0;\nstatic voidfunction   capi_dosomething = 0;\n#endif /* defined (CAN_RUN_TEST) */\n\n\nextern \"C\"\nvoid* loadDll(void*)\n{\n#if defined (CAN_RUN_TEST)\n\n  PRINTF (\"loadDll - entered\\n\");\n  const char *subdir_env = getenv (\"ACE_EXE_SUB_DIR\");\n  if (subdir_env)\n    {\n      char *dllFile =\n        (char *) malloc (2 + strlen (subdir_env) + strlen (DllTestName));\n      strcpy (dllFile, subdir_env);\n      strcat (dllFile, \"/\");\n      strcat (dllFile, DllTestName);\n      dllHandle = dlopen (dllFile, RTLD_NOW);\n      free (dllFile);\n    }\n  else\n    {\n      dllHandle = dlopen (DllTestName, RTLD_NOW);\n    }\n\n  if (dllHandle == 0)\n  {\n    PRINTF (\"unable to load library: %s\\n\", dlerror());\n    assert(dllHandle != 0);\n  }\n\n  void* temp = dlsym (dllHandle, \"capi_init\");\n  memcpy (&capi_init, &temp, sizeof (temp));\n  if (capi_init == 0)\n  {\n    PRINTF (\"unable to resolve symbol capi_init: %s\\n\", dlerror());\n    assert(capi_init != 0);\n  }\n\n  temp = dlsym (dllHandle, \"capi_fini\");\n  memcpy (&capi_fini, &temp, sizeof (temp));\n  if (capi_fini == 0)\n  {\n    PRINTF (\"unable to resolve symbol capi_fini: %s\\n\", dlerror());\n    assert(capi_fini != 0);\n  }\n\n  temp = dlsym (dllHandle, \"capi_dosomething\");\n  memcpy (&capi_dosomething, &temp, sizeof (temp));\n  if (capi_dosomething == 0)\n  {\n    PRINTF (\"unable to resolve symbol capi_dosomething: %s\\n\", dlerror());\n    assert(capi_dosomething != 0);\n  }\n  capi_init();\n  PRINTF (\"loadDll - leaving\\n\");\n#endif /* defined (CAN_RUN_TEST) */\n  return 0;\n}\n\nextern \"C\"\nvoid* unloadDll(void*)\n{\n#if defined (CAN_RUN_TEST)\n  PRINTF (\"unloadDll - entered\\n\");\n  capi_fini();\n  dlclose(dllHandle);\n  PRINTF (\"unloadDll - leaving\\n\");\n#endif /* defined (CAN_RUN_TEST) */\n  return 0;\n}\n\nvoid * loadunloadDll(void *pp)\n{\n  loadDll(pp);\n\n#if defined (CAN_RUN_TEST)\n  assert(capi_dosomething != 0);\n  capi_dosomething();\n#endif /* defined (CAN_RUN_TEST) */\n\n  unloadDll(pp);\n\n  return 0;\n}\n// FUZZ: disable check_for_improper_main_declaration\nint main (int, char *[])\n{\n#if !defined (CAN_RUN_TEST)\n# ifndef ACE_FACE_SAFETY_EXTENDED\n  PRINTF (\"Terminating because this test has not been designed \"\n          \"to run on WIN32 or VXWORKS.\\n\");\n# endif\n#else\n  PRINTF (\"main called\\n\");\n  PRINTF (\"main - calling loadDll\\n\");\n\n#  if defined (CAN_USE_THREADS)\n  int result = 0;\n  pthread_t tid1;\n  result = pthread_create(&tid1, 0, &loadDll, 0);\n  if (result != 0)\n  {\n    PRINTF (\"pthread_create() failed: %d\\n\", result);\n    return result;\n  }\n\n  pthread_join(tid1, 0);\n  PRINTF (\"loadDll thread finished and re-joined\\n\");\n\n#  else\n\n  loadDll(0);\n  PRINTF (\"loadDll finished\\n\");\n\n#  endif /* defined (CAN_USE_THREADS) */\n\n  PRINTF (\"main - calling unloadDll\\n\");\n\n#  if defined (CAN_USE_THREADS)\n  pthread_t tid2;\n  result = pthread_create(&tid2, 0, &unloadDll, 0);\n  if (result != 0)\n  {\n    PRINTF (\"pthread_create() failed: %d\\n\", result);\n    return 1;\n  }\n  pthread_join(tid2, 0);\n  PRINTF (\"unloadDll thread finished and re-joined\\n\");\n\n#  else\n\n  unloadDll(0);\n  PRINTF (\"unloadDll finished\\n\");\n\n#  endif /* defined (CAN_USE_THREADS) */\n\n  PRINTF (\"main finished\\n\");\n#endif /* defined (CAN_RUN_TEST) */\n\n  return 0;\n\n}\n  //FUZZ: enable check_for_lack_ACE_OS\n",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/apps/JAWS/clients/WebSTONE/src/nsapi-includes/base/dll.h": "/*\n * Copyright (c) 1994, 1995.  Netscape Communications Corporation.  All\n * rights reserved.\n *\n * Use of this software is governed by the terms of the license agreement for\n * the Netscape Communications or Netscape Comemrce Server between the\n * parties.\n */\n\n\n/* ------------------------------------------------------------------------ */\n\n\n/*\n * dll.h: Handle dynamically linked libraries\n *\n * Rob McCool\n */\n\n#ifndef _DLL_H\n#define _DLL_H\n\n#include \"systems.h\"\n\n#if defined(DLL_CAPABLE)\n\n/* --------------------------- Data structures ---------------------------- */\n\n\n#if defined(USE_NSPR)\n#include <nspr/prlink.h>\ntypedef int DLHANDLE;\n\n#elif defined(DLL_DLOPEN)\n#include <dlfcn.h>\ntypedef void *DLHANDLE;  /* DLOPEN */\n\n#elif defined(DLL_HPSHL)\n#include <dl.h>\ntypedef shl_t DLHANDLE;  /* HP_SHL */\n\n#elif defined(DLL_WIN32)\ntypedef HINSTANCE DLHANDLE; /* WIN32 */\n#endif\n\n\n/* ------------------------------ Prototypes ------------------------------ */\n\n\n/*\n * dll_open loads the library at the given path into memory, and returns\n * a handle to be used in later calls to dll_findsym and dll_close.\n */\n#if defined(USE_NSPR)\n#define dll_open(libfn) PR_LoadLibrary(libfn)\n\n#elif defined(DLL_DLOPEN)\n#define dll_open(libfn) dlopen(libfn, DLL_DLOPEN_FLAGS)\n\n#elif defined(DLL_HPSHL)\n#define dll_open(libfn) shl_load((libfn), BIND_IMMEDIATE, 0)\n\n#elif defined(DLL_WIN32)\nDLHANDLE dll_open(char *libfn);\n#endif\n\n\n/*\n * dll_findsym looks for a symbol with the given name in the library\n * pointed to by the given handle. Returns a pointer to the named function.\n */\n\n#if defined(USE_NSPR)\n#define dll_findsym(dlp, name) PR_FindSymbol(name)\n\n#elif defined(DLL_DLOPEN)\n#define dll_findsym(dlp, name) dlsym(dlp, name)\n\n#elif defined(DLL_HPSHL)\nvoid *dll_findsym(DLHANDLE dlp, char *name);\n\n#elif defined(DLL_WIN32)\n#define dll_findsym(dlp, name) GetProcAddress(dlp, name)\n#endif\n\n\n/*\n * dll_error returns a string describing the last error on the given handle\n */\n#if defined(USE_NSPR)\n#define dll_error(dlp) system_errmsg(0)\n\n#elif defined(DLL_DLOPEN)\n#define dll_error(dlp) dlerror()\n\n#elif defined(DLL_HPSHL)\n#define dll_error(dlp) system_errmsg(0)\n\n#elif defined(DLL_WIN32)\n#define dll_error(dlp) system_errmsg(0)\n#endif\n\n\n/*\n * dll_close closes the previously opened library given by handle\n */\n#if defined(USE_NSPR)\nint dll_close(void *arg);\n\n#elif defined(DLL_DLOPEN)\n#define dll_close dlclose\n\n#elif defined (DLL_HPSHL)\n#define dll_close shl_unload\n\n#elif defined(DLL_WIN32)\n#define dll_close FreeLibrary\n#endif\n\n\n#endif /* DLL_CAPABLE */\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/bin/LabVIEW_RT/PXI_Reset.exe",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/bin/LabVIEW_RT/Reboot_Target.exe",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/Kokyu/docs/kokyu2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/Kokyu/docs/KokyuEC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/Kokyu/docs/kokyu1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/performance-tests/SCTP/SOCK_SEQPACK_wrapper_facade.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/performance-tests/SCTP/README.SCTP_in_ACE",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/performance-tests/SCTP/sample-spectrum.png",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/ace/Monitor_Control/Monitor_Control.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Service_Config_Test.UTF-16.conf.xml",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/ACE_Init_Test.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Service_Config_Test.WCHAR_T.conf",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/tests/Service_Config_Test.UTF-16.conf",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/MPC.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/rpmworkflow.png",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/images/mpc_mtiff.eps",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/images/mpc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/images/mwc_mtiff.eps",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/images/mwc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/MPC/docs/html/images/OCILOGO_bw_book.eps",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/apps/JAWS3/docs/web/images/jaws3_components.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/apps/JAWS3/docs/web/images/jaws3_banner.png",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/apps/JAWS3/docs/web/images/jaws3_banner.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/apps/JAWS/clients/WebSTONE/doc/webstone.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/examples/Log_Msg/Log_Msg_MFC/res/Log_Msg_MFC.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/examples/ConfigViewer/mondrian.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/contrib/FaCE/ACE_Racer.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/contrib/FaCE/ACE.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/contrib/FaCE/FACE.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/contrib/FaCE/TAO.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-ace-6.5.12-uzhtxrvng3hy2vmwmu4p5hy3abfyilyh/spack-src/docs/ace_guidelines.vsmacros"
    ],
    "total_files": 8830
}