{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/client/src/unifyfs-internal.h": "/*\n * Copyright (c) 2020, Lawrence Livermore National Security, LLC.\n * Produced at the Lawrence Livermore National Laboratory.\n *\n * Copyright 2020, UT-Battelle, LLC.\n *\n * LLNL-CODE-741539\n * All rights reserved.\n *\n * This is the license for UnifyFS.\n * For details, see https://github.com/LLNL/UnifyFS.\n * Please read https://github.com/LLNL/UnifyFS/LICENSE for full license text.\n */\n\n/*\n * Copyright (c) 2017, Lawrence Livermore National Security, LLC.\n * Produced at the Lawrence Livermore National Laboratory.\n * Copyright (c) 2017, Florida State University. Contributions from\n * the Computer Architecture and Systems Research Laboratory (CASTL)\n * at the Department of Computer Science.\n *\n * Written by: Teng Wang, Adam Moody, Weikuan Yu, Kento Sato, Kathryn Mohror\n * LLNL-CODE-728877. All rights reserved.\n *\n * This file is part of burstfs.\n * For details, see https://github.com/llnl/burstfs\n * Please read https://github.com/llnl/burstfs/LICENSE for full license text.\n */\n\n/*\n * Copyright (c) 2013, Lawrence Livermore National Security, LLC.\n * Produced at the Lawrence Livermore National Laboratory.\n * code Written by\n *   Raghunath Rajachandrasekar <rajachan@cse.ohio-state.edu>\n *   Kathryn Mohror <kathryn@llnl.gov>\n *   Adam Moody <moody20@llnl.gov>\n * All rights reserved.\n * This file is part of CRUISE.\n * For details, see https://github.com/hpc/cruise\n * Please also read this file LICENSE.CRUISE\n */\n\n#ifndef UNIFYFS_INTERNAL_H\n#define UNIFYFS_INTERNAL_H\n\n#include \"config.h\"\n\n#ifdef HAVE_OFF64_T\n#define _FILE_OFFSET_BITS 64\n#define _LARGEFILE64_SOURCE\n#else\n#define off64_t int64_t\n#endif\n\n/* -------------------------------\n * Common includes\n * -------------------------------\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n// system headers\n#include <aio.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <poll.h>\n#include <pthread.h>\n#include <sched.h>\n#include <search.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ipc.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/shm.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <time.h>\n#include <unistd.h>\n#include <wchar.h>\n#include <dirent.h>\n\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n\n// common headers\n#include \"arraylist.h\"\n#include \"unifyfs_configurator.h\"\n#include \"unifyfs_const.h\"\n#include \"unifyfs_keyval.h\"\n#include \"unifyfs_log.h\"\n#include \"unifyfs_logio.h\"\n#include \"unifyfs_meta.h\"\n#include \"unifyfs_shm.h\"\n#include \"seg_tree.h\"\n\n// client headers\n#include \"unifyfs-stack.h\"\n#include \"utlist.h\"\n#include \"uthash.h\"\n\n/* -------------------------------\n * Defines and types\n * -------------------------------\n */\n\n/* define a macro to capture function name, file name, and line number\n * along with user-defined string */\n#define UNIFYFS_UNSUPPORTED(fmt, args...) \\\n      unifyfs_unsupported(__func__, __FILE__, __LINE__, fmt, ##args)\n\n#ifdef UNIFYFS_GOTCHA\n#include <gotcha/gotcha.h>\n\n/* the name of our wrapper - we use __wrap_<iofunc> instead of <iofunc> */\n#define UNIFYFS_WRAP(name) __wrap_ ## name\n\n/* the name of the real function pointer */\n#define UNIFYFS_REAL(name) __real_ ## name\n\n/* declare anything that will be used externally */\n#define UNIFYFS_DECL(name, ret, args)  \\\n    extern gotcha_wrappee_handle_t wrappee_handle_ ## name; \\\n    extern ret (*__real_ ## name) args; \\\n    ret __wrap_ ## name args\n\n/* ask gotcha for the address of the real function */\n#define MAP_OR_FAIL(name) \\\ndo { \\\n    if (NULL == __real_ ## name) { \\\n        __real_ ## name = gotcha_get_wrappee(wrappee_handle_ ## name); \\\n        if (NULL == __real_ ## name) { \\\n            assert(!\"missing Gotcha wrappee for \" #name); \\\n        } \\\n    } \\\n} while (0)\n\nint setup_gotcha_wrappers(void);\n\n#elif UNIFYFS_PRELOAD\n\n/* ===================================================================\n * Using LD_PRELOAD to intercept\n * ===================================================================\n * we need to use the same function names the application is calling,\n * and we then invoke the real library function after looking it up with\n * dlsym */\n\n/* we need the dlsym function */\n#include <dlfcn.h>\n\n/* define a static variable called __real_open to record address of\n * real open call and initialize it to NULL */\n#define UNIFYFS_DECL(name,ret,args) \\\n      static ret (*__real_ ## name)args = NULL;\n\n/* our open wrapper assumes the name of open() */\n#define UNIFYFS_WRAP(name) name\n\n/* the address of the real open call is stored in __real_open variable */\n#define UNIFYFS_REAL(name) __real_ ## name\n\n/* if __real_open is still NULL, call dlsym to lookup address of real\n * function and record it */\n#define MAP_OR_FAIL(func) \\\n        if (!(__real_ ## func)) \\\n        { \\\n            __real_ ## func = dlsym(RTLD_NEXT, #func); \\\n            if (!(__real_ ## func)) { \\\n               fprintf(stderr, \"UNIFYFS failed to map symbol: %s\\n\", #func); \\\n               exit(1); \\\n           } \\\n        }\n#else\n\n/* ===================================================================\n * Using ld -wrap option to intercept\n * ===================================================================\n * the linker will convert application calls from open --> __wrap_open,\n * so we define all of our functions as the __wrap variant and then\n * to call the real library, we call __real_open */\n\n/* we don't need a variable to record the address of the real function,\n * just declare the existence of __real_open so the compiler knows the\n * prototype of this function (linker will provide it), also need to\n * declare prototype for __wrap_open */\n#define UNIFYFS_DECL(name,ret,args) \\\n      extern ret __real_ ## name args;  \\\n      ret __wrap_ ## name args;\n\n/* we define our wrapper function as __wrap_open instead of open */\n#define UNIFYFS_WRAP(name) __wrap_ ## name\n\n/* the linker maps the open call to __real_open() */\n#define UNIFYFS_REAL(name) __real_ ## name\n\n/* no need to look up the address of the real function */\n#define MAP_OR_FAIL(func)\n\n#endif\n\n/* ----------------------------------------\n * Structure and enumeration declarations\n * ---------------------------------------- */\n\n/* structure to represent file descriptors */\ntypedef struct {\n    int   fid;   /* local file id associated with fd */\n    off_t pos;   /* current file pointer */\n    int   read;  /* whether file is opened for read */\n    int   write; /* whether file is opened for write */\n    int   append; /* whether file is opened for append */\n} unifyfs_fd_t;\n\nenum unifyfs_stream_orientation {\n    UNIFYFS_STREAM_ORIENTATION_NULL = 0,\n    UNIFYFS_STREAM_ORIENTATION_BYTE,\n    UNIFYFS_STREAM_ORIENTATION_WIDE,\n};\n\n/* structure to represent FILE* streams */\ntypedef struct {\n    int    sid;      /* index within unifyfs_streams */\n    int    err;      /* stream error indicator flag */\n    int    eof;      /* stream end-of-file indicator flag */\n    int    fd;       /* file descriptor associated with stream */\n    int    append;   /* whether file is opened in append mode */\n    int    orient;   /* stream orientation, UNIFYFS_STREAM_ORIENTATION_{NULL,BYTE,WIDE} */\n\n    void*  buf;      /* pointer to buffer */\n    int    buffree;  /* whether we need to free buffer */\n    int    buftype;  /* _IOFBF fully buffered, _IOLBF line buffered, _IONBF unbuffered */\n    size_t bufsize;  /* size of buffer in bytes */\n    off_t  bufpos;   /* byte offset in file corresponding to start of buffer */\n    size_t buflen;   /* number of bytes active in buffer */\n    size_t bufdirty; /* whether data in buffer needs to be flushed */\n\n    unsigned char* ubuf; /* ungetc buffer (we store bytes from end) */\n    size_t ubufsize;     /* size of ungetc buffer in bytes */\n    size_t ubuflen;      /* number of active bytes in buffer */\n\n    unsigned char* _p; /* pointer to character in buffer */\n    size_t         _r; /* number of bytes left at pointer */\n} unifyfs_stream_t;\n\n/* structure to represent DIR* streams */\ntypedef struct {\n    int dirid; /* index within unifyfs_dirstreams */\n    int fid;   /* local file id of directory for this stream */\n    int fd;    /* file descriptor associated with stream */\n    off_t pos; /* position within directory stream */\n} unifyfs_dirstream_t;\n\nenum flock_enum {\n    UNLOCKED,\n    EX_LOCKED,\n    SH_LOCKED\n};\n\nenum unifyfs_file_storage {\n    FILE_STORAGE_NULL = 0,\n    FILE_STORAGE_LOGIO\n};\n\ntypedef struct {\n    off_t global_size;            /* Global size of the file */\n    pthread_spinlock_t fspinlock; /* file lock variable */\n    enum flock_enum flock_status; /* file lock status */\n\n    int storage;                  /* FILE_STORAGE type */\n\n    int fid;                      /* local file index in filemetas array */\n    int gfid;                     /* global file id for this file */\n    int needs_sync;               /* have unsynced writes */\n\n    int is_laminated;             /* Is this file laminated */\n    uint32_t mode;                /* st_mode bits.  This has file\n                                   * permission info and will tell you if this\n                                   * is a regular file or directory. */\n    struct seg_tree extents_sync; /* Segment tree containing our coalesced\n                                   * writes between sync operations */\n    struct seg_tree extents;      /* Segment tree of all local data extents */\n} unifyfs_filemeta_t;\n\n/* struct used to map a full path to its local file id,\n * an array of these is kept and a simple linear search\n * is used to find a match */\ntypedef struct {\n    /* flag incidating whether slot is in use */\n    int in_use;\n\n    /* full path and name of file */\n    const char filename[UNIFYFS_MAX_FILENAME];\n} unifyfs_filename_t;\n\n/* This structure defines a client read request for one file corresponding to\n * the global file id (gfid). It describes a contiguous read extent starting\n * at offset with given length. */\ntypedef struct {\n    /* The read request parameters */\n    int gfid;             /* global id of file to be read */\n    size_t offset;        /* logical file offset */\n    size_t length;        /* requested number of bytes */\n    char* buf;            /* user buffer to place data */\n    struct aiocb* aiocbp; /* user aiocb* from aio or listio */\n\n    /* These two variables define the byte offset range of the extent for\n     * which we filled valid data.\n     * If cover_begin_offset != 0, there is a gap at the beginning\n     * of the read extent that should be zero-filled.\n     * If cover_end_offset != (length - 1), it was a short read. */\n    size_t cover_begin_offset;\n    size_t cover_end_offset;\n\n    /* nread is the user-visible number of bytes read. Since this includes\n     * any gaps, nread should be set to (cover_end_offset + 1) when the\n     * read request has been fully serviced. */\n    size_t nread;\n\n    /* errcode holds any error code encountered during the read.\n     * The error may be an internal error value (unifyfs_rc_e) or a\n     * normal POSIX error code. It will be converted to a valid errno value\n     * for use in returning from the syscall. */\n    int errcode;\n} read_req_t;\n\ntypedef struct {\n    size_t* ptr_num_entries;\n    unifyfs_index_t* index_entry;\n} unifyfs_index_buf_t;\n\n\n/* -------------------------------\n * Global variable declarations\n * ------------------------------- */\n\nextern unifyfs_index_buf_t unifyfs_indices;\nextern unsigned long unifyfs_max_index_entries;\n\n/* log-based I/O context */\nextern logio_context* logio_ctx;\n\nextern int unifyfs_app_id;\nextern int unifyfs_client_id;\n\n/* keep track of what we've initialized */\nextern int unifyfs_initialized;\n\n/* list of file name structures of fixed length,\n * used to map a full path to its local file id,\n * an array of these is kept and a simple linear search\n * is used to find a match */\nextern unifyfs_filename_t* unifyfs_filelist;\n\n/* mount directory */\nextern char*  unifyfs_mount_prefix;\nextern size_t unifyfs_mount_prefixlen;\n\n/* tracks current working directory within unifyfs directory namespace */\nextern char* unifyfs_cwd;\n\n/* array of file descriptors */\nextern unifyfs_fd_t unifyfs_fds[UNIFYFS_CLIENT_MAX_FILEDESCS];\nextern rlim_t unifyfs_fd_limit;\n\n/* array of file streams */\nextern unifyfs_stream_t unifyfs_streams[UNIFYFS_CLIENT_MAX_FILEDESCS];\n\n/* array of directory streams */\nextern unifyfs_dirstream_t unifyfs_dirstreams[UNIFYFS_CLIENT_MAX_FILEDESCS];\n\n/* stack of free file descriptor values,\n * each is an index into unifyfs_fds array */\nextern void* unifyfs_fd_stack;\n\n/* stack of free streams,\n * each is an index into unifyfs_streams array */\nextern void* unifyfs_stream_stack;\n\n/* stack of directory streams,\n * each is an index into unifyfs_dirstreams array */\nextern void* unifyfs_dirstream_stack;\n\n/* mutex to lock stack operations */\nextern pthread_mutex_t unifyfs_stack_mutex;\n\nextern int    unifyfs_max_files;  /* maximum number of files to store */\nextern bool   unifyfs_local_extents;  /* enable tracking of local extents */\n\n/* -------------------------------\n * Common functions\n * ------------------------------- */\n\n/* single function to route all unsupported wrapper calls through */\nint unifyfs_unsupported(const char* fn_name, const char* file, int line,\n                        const char* fmt, ...);\n\n/* returns 1 if two input parameters will overflow their type when\n * added together */\nint unifyfs_would_overflow_offt(off_t a, off_t b);\n\n/* returns 1 if two input parameters will overflow their type when\n * added together */\nint unifyfs_would_overflow_long(long a, long b);\n\nint unifyfs_stack_lock(void);\n\nint unifyfs_stack_unlock(void);\n\n/* sets flag if the path should be intercept as a unifyfs path,\n * and if so, writes normalized path in upath, which should\n * be a buffer of size UNIFYFS_MAX_FILENAME */\nint unifyfs_intercept_path(const char* path, char* upath);\n\n/* given an fd, return 1 if we should intercept this file, 0 otherwise,\n * convert fd to new fd value if needed */\nint unifyfs_intercept_fd(int* fd);\n\n/* given a FILE*, returns 1 if we should intercept this file,\n * 0 otherwise */\nint unifyfs_intercept_stream(FILE* stream);\n\n/* given a DIR*, returns 1 if we should intercept this directory,\n * 0 otherwise */\nint unifyfs_intercept_dirstream(DIR* dirp);\n\n/* given a path, return the file id */\nint unifyfs_get_fid_from_path(const char* path);\n\n/* given a file descriptor, return the file id */\nint unifyfs_get_fid_from_fd(int fd);\n\n/* initialze file descriptor structure corresponding to fd value */\nint unifyfs_fd_init(int fd);\n\n/* initialze file stream structure corresponding to id value */\nint unifyfs_stream_init(int sid);\n\n/* initialze directory stream descriptor structure\n * corresponding to id value */\nint unifyfs_dirstream_init(int dirid);\n\n/* return address of file descriptor structure or NULL if fd is out\n * of range */\nunifyfs_fd_t* unifyfs_get_filedesc_from_fd(int fd);\n\n/* given a file id, return a pointer to the meta data,\n * otherwise return NULL */\nunifyfs_filemeta_t* unifyfs_get_meta_from_fid(int fid);\n\n/* Return 1 if fid is laminated, 0 if not */\nint unifyfs_fid_is_laminated(int fid);\n\n/* Return 1 if fd is laminated, 0 if not */\nint unifyfs_fd_is_laminated(int fd);\n\n/* Given a fid, return the path.  */\nconst char* unifyfs_path_from_fid(int fid);\n\n/* Given a fid, return a gfid */\nint unifyfs_gfid_from_fid(const int fid);\n\n/* returns fid for corresponding gfid, if one is active,\n * returns -1 otherwise */\nint unifyfs_fid_from_gfid(const int gfid);\n\n/* checks to see if fid is a directory\n * returns 1 for yes\n * returns 0 for no */\nint unifyfs_fid_is_dir(int fid);\n\n/* checks to see if a directory is empty\n * assumes that check for is_dir has already been made\n * only checks for full path matches, does not check relative paths,\n * e.g. ../dirname will not work\n * returns 1 for yes it is empty\n * returns 0 for no */\nint unifyfs_fid_is_dir_empty(const char* path);\n\n/* Return current global size of given file id */\noff_t unifyfs_fid_global_size(int fid);\n\n/* if we have a local fid structure corresponding to the gfid\n * in question, we attempt the file lookup with the fid method\n * otherwise call back to the rpc */\noff_t unifyfs_gfid_filesize(int gfid);\n\n/*\n * Return current size of given file id.  If the file is laminated, return the\n * global size.  Otherwise, return the local size.\n */\noff_t unifyfs_fid_logical_size(int fid);\n\n/* Update local metadata for file from global metadata */\nint unifyfs_fid_update_file_meta(int fid, unifyfs_file_attr_t* gfattr);\n\n/* allocate a file id slot for a new file\n * return the fid or -1 on error */\nint unifyfs_fid_alloc(void);\n\n/* return the file id back to the free pool */\nint unifyfs_fid_free(int fid);\n\n/* add a new file and initialize metadata\n * returns the new fid, or negative value on error */\nint unifyfs_fid_create_file(const char* path);\n\n/* add a new directory and initialize metadata\n * returns the new fid, or a negative value on error */\nint unifyfs_fid_create_directory(const char* path);\n\n/* write count bytes from buf into file starting at offset pos */\nint unifyfs_fid_write(\n    int fid,         /* local file id to write to */\n    off_t pos,       /* starting offset within file */\n    const void* buf, /* buffer of data to be written */\n    size_t count,    /* number of bytes to write */\n    size_t* nwritten /* returns number of bytes written */\n);\n\n/* truncate file id to given length, frees resources if length is\n * less than size and allocates and zero-fills new bytes if length\n * is more than size */\nint unifyfs_fid_truncate(int fid, off_t length);\n\n/* sync data for file id to server if needed */\nint unifyfs_fid_sync(int fid);\n\n/* opens a new file id with specified path, access flags, and permissions,\n * fills outfid with file id and outpos with position for current file pointer,\n * returns UNIFYFS error code */\nint unifyfs_fid_open(const char* path, int flags, mode_t mode, int* outfid,\n                     off_t* outpos);\n\nint unifyfs_fid_close(int fid);\n\n/* delete a file id and return file its resources to free pools */\nint unifyfs_fid_unlink(int fid);\n\n\n/* global metadata functions */\n\nint unifyfs_set_global_file_meta_from_fid(int fid,\n                                          unifyfs_file_attr_op_e op);\n\nint unifyfs_set_global_file_meta(int gfid,\n                                 unifyfs_file_attr_op_e op,\n                                 unifyfs_file_attr_t* gfattr);\n\nint unifyfs_get_global_file_meta(int gfid,\n                                 unifyfs_file_attr_t* gfattr);\n\n// These require types/structures defined above\n#include \"unifyfs-fixed.h\"\n#include \"unifyfs-stdio.h\"\n#include \"unifyfs-sysio.h\"\n#include \"unifyfs-dirops.h\"\n\n#endif /* UNIFYFS_INTERNAL_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/.git/objects/pack/pack-3c0aaa6122cbbe1448b45e6dbffa3036ec505999.pack",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/.git/objects/pack/pack-3c0aaa6122cbbe1448b45e6dbffa3036ec505999.idx",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/images/tap-output.png",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/images/UnifyFS-developers-documentation.png",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/images/UnifyFS-logo_sml.png",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/images/UnifyFS-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/images/design-high-lvl.png",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/__init__.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/Inconsolata-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/_themes/sphinx_rtd_theme2/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-unifyfs-develop-wtpcsfvx2ch7ktyrv6r6nfdpvqyyqhue/spack-src/docs/slides/UnifyFS-developers-documentation.pdf"
    ],
    "total_files": 390
}