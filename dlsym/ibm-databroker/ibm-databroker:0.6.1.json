{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.6.1-xe2olxgz2d2r24bpzvvookg5bfypvtt2/spack-src/src/util/dbrUtils.c": "/*\n * Copyright \u00a9 2018, 2019 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n#include \"logutil.h\"\n#include \"libdatabroker.h\"\n#include \"libdatabroker_int.h\"\n#include \"libdbrAPI.h\"\n\n#include \"lib/sge.h\"\n#include \"lib/backend.h\"\n\n#ifdef __APPLE__\n#include <stdlib.h>\n#else\n#include <stdlib.h>\n#include <malloc.h>\n#endif\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <dlfcn.h>\n\nstatic dbrMain_context_t *gMain_context = NULL;\nstatic pthread_mutex_t gMain_creation_lock = PTHREAD_MUTEX_INITIALIZER;\n\ndbrMain_context_t* dbrCheckCreateMainCTX(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    gMain_context = (dbrMain_context_t*)malloc( sizeof( dbrMain_context_t ) );\n    if( gMain_context == NULL )\n    {\n      errno = ENOMEM;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n    memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n\n    char *to_str = getenv(DBR_TIMEOUT_ENV);\n    if( to_str == NULL )\n      gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    else\n    {\n      gMain_context->_config._timeout_sec = strtol( to_str, NULL, 10 );\n      if(( gMain_context->_config._timeout_sec == LONG_MIN ) || ( gMain_context->_config._timeout_sec == LONG_MAX ))\n        gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    }\n    if( gMain_context->_config._timeout_sec == 0 )\n      gMain_context->_config._timeout_sec = INT_MAX;\n\n    gMain_context->_tmp_testkey_buf = malloc( DBR_TMP_BUFFER_LEN );\n    if( gMain_context->_tmp_testkey_buf == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to allocate tmp key buffer.\\n\" );\n      free( gMain_context );\n      gMain_context = NULL;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n\n    gMain_context->_be_ctx = dbrlib_backend_get_handle();\n    if( gMain_context->_be_ctx == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to create/connect backend.\\n\" );\n      free( gMain_context );\n      gMain_context = NULL;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n\n#ifdef DBR_DATA_ADAPTERS\n    // get plugin location from env variable\n    to_str = getenv(DBR_PLUGIN_ENV);\n    if( to_str == NULL )\n      gMain_context->_data_adapter = NULL;\n    else\n    {\n      // dlopen and load adapter symbol\n      if( (gMain_context->_da_library = dlopen( to_str, RTLD_LAZY )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: failed to load Data Adapter library %s. Looked for in %s\\n\", to_str, getenv(\"LD_LIBRARY_PATH\") );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n      dlerror();\n      if( (gMain_context->_data_adapter = dlsym( gMain_context->_da_library, \"dbrDA\" )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: symbol 'dbrDA' not defined in %s\\n\", to_str );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n    }\n#endif\n    pthread_mutex_init( &gMain_context->_biglock, NULL );\n  }\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return gMain_context;\n}\n\nint dbrMain_exit(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    pthread_mutex_unlock( &gMain_creation_lock );\n    return 0;\n  }\n\n  int rc = dbrlib_backend_delete( gMain_context->_be_ctx );\n\n  if( gMain_context->_tmp_testkey_buf != NULL )\n  {\n    LOG( DBG_VERBOSE, stdout, \"Cleaning up temporary buffer\\n\");\n    memset( gMain_context->_tmp_testkey_buf, 0, DBR_TMP_BUFFER_LEN );\n    free( gMain_context->_tmp_testkey_buf );\n    gMain_context->_tmp_testkey_buf = NULL;\n  }\n\n#ifdef DBR_DATA_ADAPTERS\n  if( gMain_context->_da_library != NULL )\n  {\n    dlclose( gMain_context->_da_library );\n    gMain_context->_data_adapter = NULL;\n  }\n#endif\n\n  pthread_mutex_destroy( &gMain_context->_biglock );\n  memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n  free( gMain_context );\n  gMain_context = NULL;\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return rc;\n}\n\n\nDBR_Tag_t dbrTag_get( dbrMain_context_t *ctx )\n{\n  if( ctx == NULL )\n    return DB_TAG_ERROR;\n\n  typeof(ctx->_tag_head) t = ctx->_tag_head;\n\n  // hop through the work entries to check for available tags\n  while( ctx->_cs_wq[ t ] != NULL )\n  {\n    // while we're at it: clean up any closed request entries\n    // !! make sure the whole chain is in closed state !!\n\n    dbrRequestContext_t *rctx = ctx->_cs_wq[ t ];\n    dbrRequest_status_t st = rctx->_status;\n    while(( st == dbrSTATUS_CLOSED ) && ( rctx->_next != NULL ))\n    {\n      rctx = rctx->_next;\n      st = rctx->_status;\n    }\n\n    if( st == dbrSTATUS_CLOSED )\n    {\n      dbrRequestContext_t *r = ctx->_cs_wq[ t ];\n      memset( r, 0, sizeof( dbrRequestContext_t ) + r->_req._sge_count * sizeof(dbBE_sge_t) );\n      free( r );\n      ctx->_cs_wq[ t ] = NULL;\n      break;\n    }\n\n    t = ( t + 1 ) % dbrMAX_TAGS;\n    if( t == ctx->_tag_head )\n    {\n      LOG( DBG_ERR, stderr, \"No more tags available for async op\\n\" );\n      return DB_TAG_ERROR;\n    }\n  }\n\n  ctx->_tag_head = ( t + 1 ) % dbrMAX_TAGS;\n\n#ifdef DBR_INTTAG\n//  LOG( DBG_INFO, stdout, \"Returning Tag: %d\\n\", t );\n  return (DBR_Tag_t)t;\n#else\n  // needs to point into the array!\n  // -> otherwise there is no index calculation afterwards\n  return (DBR_Tag_t)&ctx->_cs_wq[ t ];\n#endif\n}\n\nDBR_Errorcode_t dbrValidateTag( dbrRequestContext_t *rctx, DBR_Tag_t req_tag )\n{\n#ifdef DBR_INTTAG\n  if(( req_tag >= 0 ) && ( req_tag < dbrMAX_TAGS ))\n#else\n  if(( req_tag != NULL ) && ( req_tag != DB_TAG_ERROR ))\n#endif\n    return DBR_SUCCESS;\n  else\n    return DBR_ERR_TAGERROR;\n}\n\n\nvoid __attribute__ ((destructor)) unload( void )\n{\n  LOG( DBG_VERBOSE, stdout, \"Unloading library\\n\");\n  dbrMain_exit();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.6.1-xe2olxgz2d2r24bpzvvookg5bfypvtt2/spack-src/doc/fig/architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.6.1-xe2olxgz2d2r24bpzvvookg5bfypvtt2/spack-src/doc/fig/dbrworkflow.png"
    ],
    "total_files": 170
}