{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-yvml6sehzsmgqhvoqrwy5v2kdxd5unkm/spack-src/src/lib/backend.c": "/*\n * Copyright \u00a9 2018-2020 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"logutil.h\"\n#include \"backend.h\"\n#include \"common/utility.h\"\n\n#include <stddef.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#ifndef DEFAULT_BE\n#define DEFAULT_BE_LIB \"libdbbe_redis.so\"\n#endif\n\n\nstatic dbrBackend_t *gBE = NULL;\n\ndbrBackend_t* dbrlib_backend_get_handle(void)\n{\n  // check backend context and initialize\n  dbrBackend_t *be = NULL;\n  if( gBE == NULL )\n  {\n    char *to_str = dbBE_Extract_env( DBR_BACKEND_ENV, DEFAULT_BE_LIB );\n    if( to_str == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to get backend environment variable.\\n\" );\n      goto error;\n    }\n\n    be = (dbrBackend_t*)calloc( 1, sizeof( dbrBackend_t ));\n    if( be == NULL )\n      return NULL;\n\n    if( (be->_library = dlopen( to_str, RTLD_LAZY )) == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to load Backend Library %s. Looked for in %s\\n\", to_str, getenv(\"LD_LIBRARY_PATH\") );\n      goto error;\n    }\n    dlerror();\n    if( (be->_api = dlsym( be->_library, \"dbBE\" )) == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: symbol 'dbBE' not defined in %s\\n\", to_str );\n      goto error;\n    }\n\n    be->_context = be->_api->initialize( );\n    gBE = be;\n  }\n  return gBE;\n\nerror:\n  if( be != NULL )\n  {\n    if( be->_api != NULL ) be->_api = NULL;\n    if( be->_library != NULL )\n    {\n      dlclose( be->_library );\n      be->_library = NULL;\n    }\n    free( be );\n    be = NULL;\n    gBE = NULL;\n  }\n  return (dbBE_Handle_t)be;\n}\n\nint dbrlib_backend_delete( dbrBackend_t *be )\n{\n  if( be == NULL )\n    return -EINVAL;\n\n  int rc = 0;\n  if( be->_api != NULL )\n    rc = be->_api->exit( be->_context );\n\n  if( be->_library != NULL )\n    rc = dlclose( be->_library );\n\n  free( be );\n  gBE = NULL;\n  return rc;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-yvml6sehzsmgqhvoqrwy5v2kdxd5unkm/spack-src/src/util/dbrUtils.c": "/*\n * Copyright \u00a9 2018-2020 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n#include \"logutil.h\"\n#include \"libdatabroker.h\"\n#include \"libdatabroker_int.h\"\n#include \"libdbrAPI.h\"\n\n#include \"lib/sge.h\"\n#include \"lib/backend.h\"\n\n#ifdef __APPLE__\n#include <stdlib.h>\n#else\n#include <stdlib.h>\n#include <malloc.h>\n#endif\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <dlfcn.h>\n\nstatic dbrMain_context_t *gMain_context = NULL;\nstatic pthread_mutex_t gMain_creation_lock = PTHREAD_MUTEX_INITIALIZER;\n\ndbrMain_context_t* dbrCheckCreateMainCTX(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    gMain_context = (dbrMain_context_t*)malloc( sizeof( dbrMain_context_t ) );\n    if( gMain_context == NULL )\n    {\n      errno = ENOMEM;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n    memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n\n    char *to_str = getenv(DBR_TIMEOUT_ENV);\n    if( to_str == NULL )\n      gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    else\n    {\n      gMain_context->_config._timeout_sec = strtol( to_str, NULL, 10 );\n      if(( gMain_context->_config._timeout_sec == LONG_MIN ) || ( gMain_context->_config._timeout_sec == LONG_MAX ))\n        gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    }\n    if( gMain_context->_config._timeout_sec == 0 )\n      gMain_context->_config._timeout_sec = INT_MAX;\n\n    gMain_context->_tmp_testkey_buf = malloc( DBR_TMP_BUFFER_LEN );\n    if( gMain_context->_tmp_testkey_buf == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to allocate tmp key buffer.\\n\" );\n      free( gMain_context );\n      gMain_context = NULL;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n\n    gMain_context->_be_ctx = dbrlib_backend_get_handle();\n    if( gMain_context->_be_ctx == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to create/connect backend.\\n\" );\n      pthread_mutex_unlock( &gMain_creation_lock );\n      dbrMain_exit();\n      return NULL;\n    }\n\n#ifdef DBR_DATA_ADAPTERS\n    // get plugin location from env variable\n    to_str = getenv(DBR_PLUGIN_ENV);\n    if( to_str == NULL )\n      gMain_context->_data_adapter = NULL;\n    else\n    {\n      // dlopen and load adapter symbol\n      if( (gMain_context->_da_library = dlopen( to_str, RTLD_LAZY )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: failed to load Data Adapter library %s. Looked for in %s\\n\", to_str, getenv(\"LD_LIBRARY_PATH\") );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n      dlerror();\n      if( (gMain_context->_data_adapter = dlsym( gMain_context->_da_library, \"dbrDA\" )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: symbol 'dbrDA' not defined in %s\\n\", to_str );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n    }\n#endif\n    pthread_mutex_init( &gMain_context->_biglock, NULL );\n  }\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return gMain_context;\n}\n\nint dbrMain_exit(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    pthread_mutex_unlock( &gMain_creation_lock );\n    return 0;\n  }\n\n  int rc = dbrlib_backend_delete( gMain_context->_be_ctx );\n\n  if( gMain_context->_tmp_testkey_buf != NULL )\n  {\n    LOG( DBG_VERBOSE, stdout, \"Cleaning up temporary buffer\\n\");\n    memset( gMain_context->_tmp_testkey_buf, 0, DBR_TMP_BUFFER_LEN );\n    free( gMain_context->_tmp_testkey_buf );\n    gMain_context->_tmp_testkey_buf = NULL;\n  }\n\n#ifdef DBR_DATA_ADAPTERS\n  if( gMain_context->_da_library != NULL )\n  {\n    dlclose( gMain_context->_da_library );\n    gMain_context->_data_adapter = NULL;\n  }\n#endif\n\n  pthread_mutex_destroy( &gMain_context->_biglock );\n  memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n  free( gMain_context );\n  gMain_context = NULL;\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return rc;\n}\n\n\nDBR_Tag_t dbrTag_get( dbrMain_context_t *ctx )\n{\n  if( ctx == NULL )\n    return DB_TAG_ERROR;\n\n  typeof(ctx->_tag_head) t = ctx->_tag_head;\n\n  // hop through the work entries to check for available tags\n  while( ctx->_cs_wq[ t ] != NULL )\n  {\n    // while we're at it: clean up any closed request entries\n    // !! make sure the whole chain is in closed state !!\n\n    dbrRequestContext_t *rctx = ctx->_cs_wq[ t ];\n    dbrRequest_status_t st = rctx->_status;\n    while(( st == dbrSTATUS_CLOSED ) && ( rctx->_next != NULL ))\n    {\n      rctx = rctx->_next;\n      st = rctx->_status;\n    }\n\n    if( st == dbrSTATUS_CLOSED )\n    {\n      dbrRequestContext_t *r = ctx->_cs_wq[ t ];\n      memset( r, 0, sizeof( dbrRequestContext_t ) + r->_req._sge_count * sizeof(dbBE_sge_t) );\n      free( r );\n      ctx->_cs_wq[ t ] = NULL;\n      break;\n    }\n\n    t = ( t + 1 ) % dbrMAX_TAGS;\n    if( t == ctx->_tag_head )\n    {\n      LOG( DBG_ERR, stderr, \"No more tags available for async op\\n\" );\n      return DB_TAG_ERROR;\n    }\n  }\n\n  ctx->_tag_head = ( t + 1 ) % dbrMAX_TAGS;\n\n#ifdef DBR_INTTAG\n//  LOG( DBG_INFO, stdout, \"Returning Tag: %d\\n\", t );\n  return (DBR_Tag_t)t;\n#else\n  // needs to point into the array!\n  // -> otherwise there is no index calculation afterwards\n  return (DBR_Tag_t)&ctx->_cs_wq[ t ];\n#endif\n}\n\nDBR_Errorcode_t dbrValidateTag( dbrRequestContext_t *rctx, DBR_Tag_t req_tag )\n{\n#ifdef DBR_INTTAG\n  if(( req_tag >= 0 ) && ( req_tag < dbrMAX_TAGS ))\n#else\n  if(( req_tag != NULL ) && ( req_tag != DB_TAG_ERROR ))\n#endif\n    return DBR_SUCCESS;\n  else\n    return DBR_ERR_TAGERROR;\n}\n\n\nvoid __attribute__ ((destructor)) unload( void )\n{\n  LOG( DBG_VERBOSE, stdout, \"Unloading library\\n\");\n  dbrMain_exit();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-yvml6sehzsmgqhvoqrwy5v2kdxd5unkm/spack-src/doc/fig/architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-yvml6sehzsmgqhvoqrwy5v2kdxd5unkm/spack-src/doc/fig/dbrworkflow.png"
    ],
    "total_files": 230
}