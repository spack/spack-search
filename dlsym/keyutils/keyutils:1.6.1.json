{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-keyutils-1.6.1-gmoxsg2w64bit4tx77ck7rnbzpeb5x3f/spack-src/keyutils.c": "/* keyutils.c: key utility library\n *\n * Copyright (C) 2005,2011 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <sys/uio.h>\n#include <errno.h>\n#include <asm/unistd.h>\n#include \"keyutils.h\"\n\nconst char keyutils_version_string[] = PKGVERSION;\nconst char keyutils_build_string[] = PKGBUILD;\n\n#ifdef NO_GLIBC_KEYERR\nstatic int error_inited;\nstatic void (*libc_perror)(const char *msg);\nstatic char *(*libc_strerror_r)(int errnum, char *buf, size_t n);\n//static int (*libc_xpg_strerror_r)(int errnum, char *buf, size_t n);\n#define RTLD_NEXT      ((void *) -1L)\n#endif\n\n#define __weak __attribute__((weak))\n\nkey_serial_t __weak add_key(const char *type,\n\t\t\t    const char *description,\n\t\t\t    const void *payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\treturn syscall(__NR_add_key,\n\t\t       type, description, payload, plen, ringid);\n}\n\nkey_serial_t __weak request_key(const char *type,\n\t\t\t\tconst char *description,\n\t\t\t\tconst char * callout_info,\n\t\t\t\tkey_serial_t destringid)\n{\n\treturn syscall(__NR_request_key,\n\t\t       type, description, callout_info, destringid);\n}\n\nstatic inline long __keyctl(int cmd,\n\t\t\t    unsigned long arg2,\n\t\t\t    unsigned long arg3,\n\t\t\t    unsigned long arg4,\n\t\t\t    unsigned long arg5)\n{\n\treturn syscall(__NR_keyctl,\n\t\t       cmd, arg2, arg3, arg4, arg5);\n}\n\nlong __weak keyctl(int cmd, ...)\n{\n\tva_list va;\n\tunsigned long arg2, arg3, arg4, arg5;\n\n\tva_start(va, cmd);\n\targ2 = va_arg(va, unsigned long);\n\targ3 = va_arg(va, unsigned long);\n\targ4 = va_arg(va, unsigned long);\n\targ5 = va_arg(va, unsigned long);\n\tva_end(va);\n\n\treturn __keyctl(cmd, arg2, arg3, arg4, arg5);\n}\n\nkey_serial_t keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\treturn keyctl(KEYCTL_GET_KEYRING_ID, id, create);\n}\n\nkey_serial_t keyctl_join_session_keyring(const char *name)\n{\n\treturn keyctl(KEYCTL_JOIN_SESSION_KEYRING, name);\n}\n\nlong keyctl_update(key_serial_t id, const void *payload, size_t plen)\n{\n\treturn keyctl(KEYCTL_UPDATE, id, payload, plen);\n}\n\nlong keyctl_revoke(key_serial_t id)\n{\n\treturn keyctl(KEYCTL_REVOKE, id);\n}\n\nlong keyctl_chown(key_serial_t id, uid_t uid, gid_t gid)\n{\n\treturn keyctl(KEYCTL_CHOWN, id, uid, gid);\n}\n\nlong keyctl_setperm(key_serial_t id, key_perm_t perm)\n{\n\treturn keyctl(KEYCTL_SETPERM, id, perm);\n}\n\nlong keyctl_describe(key_serial_t id, char *buffer, size_t buflen)\n{\n\treturn keyctl(KEYCTL_DESCRIBE, id, buffer, buflen);\n}\n\nlong keyctl_clear(key_serial_t ringid)\n{\n\treturn keyctl(KEYCTL_CLEAR, ringid);\n}\n\nlong keyctl_link(key_serial_t id, key_serial_t ringid)\n{\n\treturn keyctl(KEYCTL_LINK, id, ringid);\n}\n\nlong keyctl_unlink(key_serial_t id, key_serial_t ringid)\n{\n\treturn keyctl(KEYCTL_UNLINK, id, ringid);\n}\n\nlong keyctl_search(key_serial_t ringid,\n\t\t   const char *type,\n\t\t   const char *description,\n\t\t   key_serial_t destringid)\n{\n\treturn keyctl(KEYCTL_SEARCH, ringid, type, description, destringid);\n}\n\nlong keyctl_read(key_serial_t id, char *buffer, size_t buflen)\n{\n\treturn keyctl(KEYCTL_READ, id, buffer, buflen);\n}\n\nlong keyctl_instantiate(key_serial_t id,\n\t\t\tconst void *payload,\n\t\t\tsize_t plen,\n\t\t\tkey_serial_t ringid)\n{\n\treturn keyctl(KEYCTL_INSTANTIATE, id, payload, plen, ringid);\n}\n\nlong keyctl_negate(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl(KEYCTL_NEGATE, id, timeout, ringid);\n}\n\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\treturn keyctl(KEYCTL_SET_REQKEY_KEYRING, reqkey_defl);\n}\n\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\treturn keyctl(KEYCTL_SET_TIMEOUT, id, timeout);\n}\n\nlong keyctl_assume_authority(key_serial_t id)\n{\n\treturn keyctl(KEYCTL_ASSUME_AUTHORITY, id);\n}\n\nlong keyctl_get_security(key_serial_t id, char *buffer, size_t buflen)\n{\n\treturn keyctl(KEYCTL_GET_SECURITY, id, buffer, buflen);\n}\n\nlong keyctl_session_to_parent(void)\n{\n\treturn keyctl(KEYCTL_SESSION_TO_PARENT);\n}\n\nlong keyctl_reject(key_serial_t id, unsigned timeout, unsigned error,\n\t\t   key_serial_t ringid)\n{\n\tlong ret = keyctl(KEYCTL_REJECT, id, timeout, error, ringid);\n\n\t/* fall back to keyctl_negate() if this op is not supported by this\n\t * kernel version */\n\tif (ret == -1 && errno == EOPNOTSUPP)\n\t\treturn keyctl_negate(id, timeout, ringid);\n\treturn ret;\n}\n\nlong keyctl_instantiate_iov(key_serial_t id,\n\t\t\t    const struct iovec *payload_iov,\n\t\t\t    unsigned ioc,\n\t\t\t    key_serial_t ringid)\n{\n\tlong ret = keyctl(KEYCTL_INSTANTIATE_IOV, id, payload_iov, ioc, ringid);\n\n\t/* fall back to keyctl_instantiate() if this op is not supported by\n\t * this kernel version */\n\tif (ret == -1 && errno == EOPNOTSUPP) {\n\t\tunsigned loop;\n\t\tsize_t bsize = 0, seg;\n\t\tvoid *buf, *p;\n\n\t\tif (!payload_iov || !ioc)\n\t\t\treturn keyctl_instantiate(id, NULL, 0, ringid);\n\t\tfor (loop = 0; loop < ioc; loop++)\n\t\t\tbsize += payload_iov[loop].iov_len;\n\t\tif (bsize == 0)\n\t\t\treturn keyctl_instantiate(id, NULL, 0, ringid);\n\t\tp = buf = malloc(bsize);\n\t\tif (!buf)\n\t\t\treturn -1;\n\t\tfor (loop = 0; loop < ioc; loop++) {\n\t\t\tseg = payload_iov[loop].iov_len;\n\t\t\tp = memcpy(p, payload_iov[loop].iov_base, seg) + seg;\n\t\t}\n\t\tret = keyctl_instantiate(id, buf, bsize, ringid);\n\t\tfree(buf);\n\t}\n\treturn ret;\n}\n\nlong keyctl_invalidate(key_serial_t id)\n{\n\treturn keyctl(KEYCTL_INVALIDATE, id);\n}\n\nlong keyctl_get_persistent(uid_t uid, key_serial_t id)\n{\n\treturn keyctl(KEYCTL_GET_PERSISTENT, uid, id);\n}\n\nlong keyctl_dh_compute(key_serial_t priv, key_serial_t prime,\n\t\t       key_serial_t base, char *buffer, size_t buflen)\n{\n\tstruct keyctl_dh_params params = { .priv = priv,\n\t\t\t\t\t   .prime = prime,\n\t\t\t\t\t   .base = base };\n\n\treturn keyctl(KEYCTL_DH_COMPUTE, &params, buffer, buflen, 0);\n}\n\nlong keyctl_dh_compute_kdf(key_serial_t private, key_serial_t prime,\n\t\t\t   key_serial_t base, char *hashname, char *otherinfo,\n\t\t\t   size_t otherinfolen, char *buffer, size_t buflen)\n{\n\tstruct keyctl_dh_params params = { .priv = private,\n\t\t\t\t\t   .prime = prime,\n\t\t\t\t\t   .base = base };\n\tstruct keyctl_kdf_params kdfparams = { .hashname = hashname,\n\t\t\t\t\t       .otherinfo = otherinfo,\n\t\t\t\t\t       .otherinfolen = otherinfolen };\n\n\treturn keyctl(KEYCTL_DH_COMPUTE, &params, buffer, buflen, &kdfparams);\n}\n\nlong keyctl_restrict_keyring(key_serial_t keyring, const char *type,\n\t\t\t     const char *restriction)\n{\n\treturn keyctl(KEYCTL_RESTRICT_KEYRING, keyring, type, restriction);\n}\n\nlong keyctl_pkey_query(key_serial_t key_id,\n\t\t       const char *info,\n\t\t       struct keyctl_pkey_query *result)\n{\n\treturn keyctl(KEYCTL_PKEY_QUERY, key_id, NULL, info, result);\n}\n\nlong keyctl_pkey_encrypt(key_serial_t key_id,\n\t\t\t const char *info,\n\t\t\t const void *data, size_t data_len,\n\t\t\t void *enc, size_t enc_len)\n{\n\tstruct keyctl_pkey_params params = {\n\t\t.key_id\t\t= key_id,\n\t\t.in_len\t\t= data_len,\n\t\t.out_len\t= enc_len,\n\t};\n\n\treturn keyctl(KEYCTL_PKEY_ENCRYPT, &params, info, data, enc);\n}\n\nlong keyctl_pkey_decrypt(key_serial_t key_id,\n\t\t\t const char *info,\n\t\t\t const void *enc, size_t enc_len,\n\t\t\t void *data, size_t data_len)\n{\n\tstruct keyctl_pkey_params params = {\n\t\t.key_id\t\t= key_id,\n\t\t.in_len\t\t= enc_len,\n\t\t.out_len\t= data_len,\n\t};\n\n\treturn keyctl(KEYCTL_PKEY_DECRYPT, &params, info, enc, data);\n}\n\nlong keyctl_pkey_sign(key_serial_t key_id,\n\t\t      const char *info,\n\t\t      const void *data, size_t data_len,\n\t\t      void *sig, size_t sig_len)\n{\n\tstruct keyctl_pkey_params params = {\n\t\t.key_id\t\t= key_id,\n\t\t.in_len\t\t= data_len,\n\t\t.out_len\t= sig_len,\n\t};\n\n\treturn keyctl(KEYCTL_PKEY_SIGN, &params, info, data, sig);\n}\n\nlong keyctl_pkey_verify(key_serial_t key_id,\n\t\t\tconst char *info,\n\t\t\tconst void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tstruct keyctl_pkey_params params = {\n\t\t.key_id\t\t= key_id,\n\t\t.in_len\t\t= data_len,\n\t\t.in2_len\t= sig_len,\n\t};\n\n\treturn keyctl(KEYCTL_PKEY_VERIFY, &params, info, data, sig);\n}\n\nlong keyctl_move(key_serial_t id,\n\t\t key_serial_t from_ringid,\n\t\t key_serial_t to_ringid,\n\t\t unsigned int flags)\n{\n\treturn keyctl(KEYCTL_MOVE, id, from_ringid, to_ringid, flags);\n}\n\nlong keyctl_capabilities(unsigned char *buffer, size_t buflen)\n{\n\tlong n;\n\n\tn = keyctl(KEYCTL_CAPABILITIES, buffer, buflen);\n\tif (n != -1 || errno != EOPNOTSUPP)\n\t\treturn n;\n\n\t/* Emulate the operation */\n\tif (buflen > 0) {\n\t\tmemset(buffer, 0, buflen);\n\n\t\terrno = 0;\n\t\tkeyctl_get_persistent(-1, 0);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_PERSISTENT_KEYRINGS;\n\n\t\terrno = 0;\n\t\tkeyctl_dh_compute(0, 0, 0, NULL, 0);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_DIFFIE_HELLMAN;\n\n\t\terrno = 0;\n\t\tkeyctl_pkey_query(0, NULL, NULL);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_PUBLIC_KEY;\n\n\t\t/* Can't emulate KEYCTL_CAPS0_BIG_KEY without a valid\n\t\t * destination keyring.\n\t\t */\n\n\t\terrno = 0;\n\t\tkeyctl_invalidate(0);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_INVALIDATE;\n\n\t\terrno = 0;\n\t\tkeyctl_restrict_keyring(0, NULL, NULL);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_RESTRICT_KEYRING;\n\n\t\terrno = 0;\n\t\tkeyctl_move(0, 0, 0, 0);\n\t\tif (errno != EOPNOTSUPP)\n\t\t\tbuffer[0] |= KEYCTL_CAPS0_MOVE;\n\t}\n\n\treturn sizeof(unsigned char);\n}\n\n/*****************************************************************************/\n/*\n * fetch key description into an allocated buffer\n * - resulting string is NUL terminated\n * - returns count not including NUL\n */\nint keyctl_describe_alloc(key_serial_t id, char **_buffer)\n{\n\tchar *buf;\n\tlong buflen, ret;\n\n\tret = keyctl_describe(id, NULL, 0);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tbuflen = ret;\n\t\tbuf = malloc(buflen);\n\t\tif (!buf)\n\t\t\treturn -1;\n\n\t\tret = keyctl_describe(id, buf, buflen);\n\t\tif (ret < 0) {\n\t\t\tfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (buflen >= ret)\n\t\t\tbreak;\n\t\tfree(buf);\n\t}\n\n\t*_buffer = buf;\n\treturn ret - 1;\n}\n\n/*****************************************************************************/\n/*\n * fetch key contents into an allocated buffer\n * - resulting buffer has an extra NUL added to the end\n * - returns count (not including extraneous NUL)\n */\nint keyctl_read_alloc(key_serial_t id, void **_buffer)\n{\n\tchar *buf;\n\tlong buflen, ret;\n\n\tret = keyctl_read(id, NULL, 0);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tbuflen = ret;\n\t\tbuf = malloc(buflen + 1);\n\t\tif (!buf)\n\t\t\treturn -1;\n\n\t\tret = keyctl_read(id, buf, buflen);\n\t\tif (ret < 0) {\n\t\t\tfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (buflen >= ret)\n\t\t\tbreak;\n\t\tfree(buf);\n\t}\n\n\tbuf[ret] = 0;\n\t*_buffer = buf;\n\treturn ret;\n}\n\n/*****************************************************************************/\n/*\n * fetch key security label into an allocated buffer\n * - resulting string is NUL terminated\n * - returns count not including NUL\n */\nint keyctl_get_security_alloc(key_serial_t id, char **_buffer)\n{\n\tchar *buf;\n\tlong buflen, ret;\n\n\tret = keyctl_get_security(id, NULL, 0);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tbuflen = ret;\n\t\tbuf = malloc(buflen);\n\t\tif (!buf)\n\t\t\treturn -1;\n\n\t\tret = keyctl_get_security(id, buf, buflen);\n\t\tif (ret < 0) {\n\t\t\tfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (buflen >= ret)\n\t\t\tbreak;\n\t\tfree(buf);\n\t}\n\n\t*_buffer = buf;\n\treturn ret - 1;\n}\n\n/*****************************************************************************/\n/*\n * fetch DH computation results into an allocated buffer\n * - resulting buffer has an extra NUL added to the end\n * - returns count (not including extraneous NUL)\n */\nint keyctl_dh_compute_alloc(key_serial_t priv, key_serial_t prime,\n\t\t\t    key_serial_t base, void **_buffer)\n{\n\tchar *buf;\n\tlong buflen, ret;\n\n\tret = keyctl_dh_compute(priv, prime, base, NULL, 0);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tbuflen = ret;\n\tbuf = malloc(buflen + 1);\n\tif (!buf)\n\t\treturn -1;\n\n\tret = keyctl_dh_compute(priv, prime, base, buf, buflen);\n\tif (ret < 0) {\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\n\tbuf[ret] = 0;\n\t*_buffer = buf;\n\treturn ret;\n}\n\n/*\n * Depth-first recursively apply a function over a keyring tree\n */\nstatic int recursive_key_scan_aux(key_serial_t parent, key_serial_t key,\n\t\t\t\t  int depth, recursive_key_scanner_t func,\n\t\t\t\t  void *data)\n{\n\tkey_serial_t *pk;\n\tkey_perm_t perm;\n\tsize_t ringlen;\n\tvoid *ring;\n\tchar *desc, type[255];\n\tint desc_len, uid, gid, ret, n, kcount = 0;\n\n\tif (depth > 800)\n\t\treturn 0;\n\n\t/* read the key description */\n\tdesc = NULL;\n\tdesc_len = keyctl_describe_alloc(key, &desc);\n\tif (desc_len < 0)\n\t\tgoto do_this_key;\n\n\t/* parse */\n\ttype[0] = 0;\n\n\tn = sscanf(desc, \"%[^;];%d;%d;%x;\", type, &uid, &gid, &perm);\n\tif (n != 4) {\n\t\tfree(desc);\n\t\tdesc = NULL;\n\t\terrno = -EINVAL;\n\t\tdesc_len = -1;\n\t\tgoto do_this_key;\n\t}\n\n\t/* if it's a keyring then we're going to want to recursively search it\n\t * if we can */\n\tif (strcmp(type, \"keyring\") == 0) {\n\t\t/* read the keyring's contents */\n\t\tret = keyctl_read_alloc(key, &ring);\n\t\tif (ret < 0)\n\t\t\tgoto do_this_key;\n\n\t\tringlen = ret;\n\n\t\t/* walk the keyring */\n\t\tpk = ring;\n\t\tfor (ringlen = ret;\n\t\t     ringlen >= sizeof(key_serial_t);\n\t\t     ringlen -= sizeof(key_serial_t)\n\t\t     )\n\t\t\tkcount += recursive_key_scan_aux(key, *pk++, depth + 1,\n\t\t\t\t\t\t\t func, data);\n\n\t\tfree(ring);\n\t}\n\ndo_this_key:\n\tkcount += func(parent, key, desc, desc_len, data);\n\tfree(desc);\n\treturn kcount;\n}\n\n/*\n * Depth-first apply a function over a keyring tree\n */\nint recursive_key_scan(key_serial_t key, recursive_key_scanner_t func, void *data)\n{\n\treturn recursive_key_scan_aux(0, key, 0, func, data);\n}\n\n/*\n * Depth-first apply a function over session keyring tree\n */\nint recursive_session_key_scan(recursive_key_scanner_t func, void *data)\n{\n\tkey_serial_t session =\n\t\tkeyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 0);\n\tif (session > 0)\n\t\treturn recursive_key_scan(session, func, data);\n\treturn 0;\n}\n\n/*\n * Find a key by type and description\n */\nkey_serial_t find_key_by_type_and_desc(const char *type, const char *desc,\n\t\t\t\t       key_serial_t destringid)\n{\n\tkey_serial_t id, error;\n\tFILE *f;\n\tchar buf[1024], typebuf[40], rdesc[1024], *kdesc, *cp;\n\tint n, ndesc, dlen;\n\n\terror = ENOKEY;\n\n\tid = request_key(type, desc, NULL, destringid);\n\tif (id >= 0 || errno == ENOMEM)\n\t\treturn id;\n\tif (errno != ENOKEY)\n\t\terror = errno;\n\n\tdlen = strlen(desc);\n\n\tf = fopen(\"/proc/keys\", \"r\");\n\tif (!f) {\n\t\tfprintf(stderr, \"libkeyutils: Can't open /proc/keys: %m\\n\");\n\t\treturn -1;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tcp = strchr(buf, '\\n');\n\t\tif (*cp)\n\t\t\t*cp = '\\0';\n\n\t\tndesc = 0;\n\t\tn = sscanf(buf, \"%x %*s %*u %*s %*x %*d %*d %s %n\",\n\t\t\t   &id, typebuf, &ndesc);\n\t\tif (n == 2 && ndesc > 0 && ndesc <= cp - buf) {\n\t\t\tif (strcmp(typebuf, type) != 0)\n\t\t\t\tcontinue;\n\t\t\tkdesc = buf + ndesc;\n\t\t\tif (memcmp(kdesc, desc, dlen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (kdesc[dlen] != ':' &&\n\t\t\t    kdesc[dlen] != '\\0' &&\n\t\t\t    kdesc[dlen] != ' ')\n\t\t\t\tcontinue;\n\t\t\tkdesc[dlen] = '\\0';\n\n\t\t\t/* The key type appends extra stuff to the end of the\n\t\t\t * description after a colon in /proc/keys.  Colons,\n\t\t\t * however, are allowed in descriptions, so we need to\n\t\t\t * make a further check. */\n\t\t\tn = keyctl_describe(id, rdesc, sizeof(rdesc) - 1);\n\t\t\tif (n == -1) {\n\t\t\t\tif (errno != ENOKEY)\n\t\t\t\t\terror = errno;\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= sizeof(rdesc) - 1)\n\t\t\t\tcontinue;\n\t\t\trdesc[n] = '\\0';\n\n\t\t\tcp = strrchr(rdesc, ';');\n\t\t\tif (!cp)\n\t\t\t\tcontinue;\n\t\t\tcp++;\n\t\t\tif (strcmp(cp, desc) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tfclose(f);\n\n\t\t\tif (destringid &&\n\t\t\t    keyctl_link(id, destringid) == -1)\n\t\t\t\treturn -1;\n\n\t\t\treturn id;\n\t\t}\n\t}\n\n\tfclose(f);\n\terrno = error;\n\treturn -1;\n}\n\n#ifdef NO_GLIBC_KEYERR\n/*****************************************************************************/\n/*\n * initialise error handling\n */\nstatic void error_init(void)\n{\n\tchar *err;\n\n\terror_inited = 1;\n\n\tdlerror();\n\n\tlibc_perror = dlsym(RTLD_NEXT,\"perror\");\n\tif (!libc_perror) {\n\t\tfprintf(stderr, \"Failed to look up next perror\\n\");\n\t\terr = dlerror();\n\t\tif (err)\n\t\t\tfprintf(stderr, \"%s\\n\", err);\n\t\tabort();\n\t}\n\n\t//fprintf(stderr, \"next perror at %p\\n\", libc_perror);\n\n\tlibc_strerror_r = dlsym(RTLD_NEXT,\"strerror_r\");\n\tif (!libc_strerror_r) {\n\t\tfprintf(stderr, \"Failed to look up next strerror_r\\n\");\n\t\terr = dlerror();\n\t\tif (err)\n\t\t\tfprintf(stderr, \"%s\\n\", err);\n\t\tabort();\n\t}\n\n\t//fprintf(stderr, \"next strerror_r at %p\\n\", libc_strerror_r);\n\n#if 0\n\tlibc_xpg_strerror_r = dlsym(RTLD_NEXT,\"xpg_strerror_r\");\n\tif (!libc_xpg_strerror_r) {\n\t\tfprintf(stderr, \"Failed to look up next xpg_strerror_r\\n\");\n\t\terr = dlerror();\n\t\tif (err)\n\t\t\tfprintf(stderr, \"%s\\n\", err);\n\t\tabort();\n\t}\n\n\t//fprintf(stderr, \"next xpg_strerror_r at %p\\n\", libc_xpg_strerror_r);\n#endif\n\n} /* end error_init() */\n\n/*****************************************************************************/\n/*\n * overload glibc's strerror_r() with a version that knows about key errors\n */\nchar *strerror_r(int errnum, char *buf, size_t n)\n{\n\tconst char *errstr;\n\tint len;\n\n\tprintf(\"hello\\n\");\n\n\tif (!error_inited)\n\t\terror_init();\n\n\tswitch (errnum) {\n\tcase ENOKEY:\n\t\terrstr = \"Requested key not available\";\n\t\tbreak;\n\n\tcase EKEYEXPIRED:\n\t\terrstr = \"Key has expired\";\n\t\tbreak;\n\n\tcase EKEYREVOKED:\n\t\terrstr = \"Key has been revoked\";\n\t\tbreak;\n\n\tcase EKEYREJECTED:\n\t\terrstr = \"Key was rejected by service\";\n\t\tbreak;\n\n\tdefault:\n\t\treturn libc_strerror_r(errnum, buf, n);\n\t}\n\n\tlen = strlen(errstr) + 1;\n\tif (n > len) {\n\t\terrno = ERANGE;\n\t\tif (n > 0) {\n\t\t\tmemcpy(buf, errstr, n - 1);\n\t\t\tbuf[n - 1] = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n\telse {\n\t\tmemcpy(buf, errstr, len);\n\t\treturn buf;\n\t}\n\n} /* end strerror_r() */\n\n#if 0\n/*****************************************************************************/\n/*\n * overload glibc's strerror_r() with a version that knows about key errors\n */\nint xpg_strerror_r(int errnum, char *buf, size_t n)\n{\n\tconst char *errstr;\n\tint len;\n\n\tif (!error_inited)\n\t\terror_init();\n\n\tswitch (errnum) {\n\tcase ENOKEY:\n\t\terrstr = \"Requested key not available\";\n\t\tbreak;\n\n\tcase EKEYEXPIRED:\n\t\terrstr = \"Key has expired\";\n\t\tbreak;\n\n\tcase EKEYREVOKED:\n\t\terrstr = \"Key has been revoked\";\n\t\tbreak;\n\n\tcase EKEYREJECTED:\n\t\terrstr = \"Key was rejected by service\";\n\t\tbreak;\n\n\tdefault:\n\t\treturn libc_xpg_strerror_r(errnum, buf, n);\n\t}\n\n\tlen = strlen(errstr) + 1;\n\tif (n > len) {\n\t\terrno = ERANGE;\n\t\tif (n > 0) {\n\t\t\tmemcpy(buf, errstr, n - 1);\n\t\t\tbuf[n - 1] = 0;\n\t\t}\n\t\treturn -1;\n\t}\n\telse {\n\t\tmemcpy(buf, errstr, len);\n\t\treturn 0;\n\t}\n\n} /* end xpg_strerror_r() */\n#endif\n\n/*****************************************************************************/\n/*\n *\n */\nvoid perror(const char *msg)\n{\n\tif (!error_inited)\n\t\terror_init();\n\n\tswitch (errno) {\n\tcase ENOKEY:\n\t\tfprintf(stderr, \"%s: Requested key not available\\n\", msg);\n\t\treturn;\n\n\tcase EKEYEXPIRED:\n\t\tfprintf(stderr, \"%s: Key has expired\\n\", msg);\n\t\treturn;\n\n\tcase EKEYREVOKED:\n\t\tfprintf(stderr, \"%s: Key has been revoked\\n\", msg);\n\t\treturn;\n\n\tcase EKEYREJECTED:\n\t\tfprintf(stderr, \"%s: Key was rejected by service\\n\", msg);\n\t\treturn;\n\n\tdefault:\n\t\tlibc_perror(msg);\n\t\treturn;\n\t}\n\n} /* end perror() */\n#endif\n"
    },
    "skipped": [],
    "total_files": 131
}