{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/src/ocl.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the OpenCV Foundation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <iostream> // std::cerr\n\n#define CV_OPENCL_ALWAYS_SHOW_BUILD_LOG 0\n#define CV_OPENCL_SHOW_RUN_ERRORS       0\n#define CV_OPENCL_SHOW_SVM_ERROR_LOG    1\n#define CV_OPENCL_SHOW_SVM_LOG          0\n\n#include \"opencv2/core/bufferpool.hpp\"\n#ifndef LOG_BUFFER_POOL\n# if 0\n#   define LOG_BUFFER_POOL printf\n# else\n#   define LOG_BUFFER_POOL(...)\n# endif\n#endif\n\n\n// TODO Move to some common place\nstatic bool getBoolParameter(const char* name, bool defaultValue)\n{\n/*\n * If your system doesn't support getenv(), define NO_GETENV to disable\n * this feature.\n */\n#ifdef NO_GETENV\n    const char* envValue = NULL;\n#else\n    const char* envValue = getenv(name);\n#endif\n    if (envValue == NULL)\n    {\n        return defaultValue;\n    }\n    cv::String value = envValue;\n    if (value == \"1\" || value == \"True\" || value == \"true\" || value == \"TRUE\")\n    {\n        return true;\n    }\n    if (value == \"0\" || value == \"False\" || value == \"false\" || value == \"FALSE\")\n    {\n        return false;\n    }\n    CV_ErrorNoReturn(cv::Error::StsBadArg, cv::format(\"Invalid value for %s parameter: %s\", name, value.c_str()));\n}\n\n\n// TODO Move to some common place\nstatic size_t getConfigurationParameterForSize(const char* name, size_t defaultValue)\n{\n#ifdef NO_GETENV\n    const char* envValue = NULL;\n#else\n    const char* envValue = getenv(name);\n#endif\n    if (envValue == NULL)\n    {\n        return defaultValue;\n    }\n    cv::String value = envValue;\n    size_t pos = 0;\n    for (; pos < value.size(); pos++)\n    {\n        if (!isdigit(value[pos]))\n            break;\n    }\n    cv::String valueStr = value.substr(0, pos);\n    cv::String suffixStr = value.substr(pos, value.length() - pos);\n    int v = atoi(valueStr.c_str());\n    if (suffixStr.length() == 0)\n        return v;\n    else if (suffixStr == \"MB\" || suffixStr == \"Mb\" || suffixStr == \"mb\")\n        return v * 1024 * 1024;\n    else if (suffixStr == \"KB\" || suffixStr == \"Kb\" || suffixStr == \"kb\")\n        return v * 1024;\n    CV_ErrorNoReturn(cv::Error::StsBadArg, cv::format(\"Invalid value for %s parameter: %s\", name, value.c_str()));\n}\n\n#if CV_OPENCL_SHOW_SVM_LOG\n// TODO add timestamp logging\n#define CV_OPENCL_SVM_TRACE_P printf(\"line %d (ocl.cpp): \", __LINE__); printf\n#else\n#define CV_OPENCL_SVM_TRACE_P(...)\n#endif\n\n#if CV_OPENCL_SHOW_SVM_ERROR_LOG\n// TODO add timestamp logging\n#define CV_OPENCL_SVM_TRACE_ERROR_P printf(\"Error on line %d (ocl.cpp): \", __LINE__); printf\n#else\n#define CV_OPENCL_SVM_TRACE_ERROR_P(...)\n#endif\n\n#include \"opencv2/core/opencl/runtime/opencl_clamdblas.hpp\"\n#include \"opencv2/core/opencl/runtime/opencl_clamdfft.hpp\"\n\n#ifdef HAVE_OPENCL\n#include \"opencv2/core/opencl/runtime/opencl_core.hpp\"\n#else\n// TODO FIXIT: This file can't be build without OPENCL\n\n/*\n  Part of the file is an extract from the standard OpenCL headers from Khronos site.\n  Below is the original copyright.\n*/\n\n/*******************************************************************************\n * Copyright (c) 2008 - 2012 The Khronos Group Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and/or associated documentation files (the\n * \"Materials\"), to deal in the Materials without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Materials, and to\n * permit persons to whom the Materials are furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Materials.\n *\n * THE MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n ******************************************************************************/\n\n#if 0 //defined __APPLE__\n#define HAVE_OPENCL 1\n#else\n#undef HAVE_OPENCL\n#endif\n\n#define OPENCV_CL_NOT_IMPLEMENTED -1000\n\n#ifdef HAVE_OPENCL\n\n#if defined __APPLE__\n#include <OpenCL/opencl.h>\n#else\n#include <CL/opencl.h>\n#endif\n\nstatic const bool g_haveOpenCL = true;\n\n#else\n\nextern \"C\" {\n\nstruct _cl_platform_id { int dummy; };\nstruct _cl_device_id { int dummy; };\nstruct _cl_context { int dummy; };\nstruct _cl_command_queue { int dummy; };\nstruct _cl_mem { int dummy; };\nstruct _cl_program { int dummy; };\nstruct _cl_kernel { int dummy; };\nstruct _cl_event { int dummy; };\nstruct _cl_sampler { int dummy; };\n\ntypedef struct _cl_platform_id *    cl_platform_id;\ntypedef struct _cl_device_id *      cl_device_id;\ntypedef struct _cl_context *        cl_context;\ntypedef struct _cl_command_queue *  cl_command_queue;\ntypedef struct _cl_mem *            cl_mem;\ntypedef struct _cl_program *        cl_program;\ntypedef struct _cl_kernel *         cl_kernel;\ntypedef struct _cl_event *          cl_event;\ntypedef struct _cl_sampler *        cl_sampler;\n\ntypedef int cl_int;\ntypedef unsigned cl_uint;\n#if defined (_WIN32) && defined(_MSC_VER)\n    typedef __int64 cl_long;\n    typedef unsigned __int64 cl_ulong;\n#else\n    typedef long cl_long;\n    typedef unsigned long cl_ulong;\n#endif\n\ntypedef cl_uint             cl_bool; /* WARNING!  Unlike cl_ types in cl_platform.h, cl_bool is not guaranteed to be the same size as the bool in kernels. */\ntypedef cl_ulong            cl_bitfield;\ntypedef cl_bitfield         cl_device_type;\ntypedef cl_uint             cl_platform_info;\ntypedef cl_uint             cl_device_info;\ntypedef cl_bitfield         cl_device_fp_config;\ntypedef cl_uint             cl_device_mem_cache_type;\ntypedef cl_uint             cl_device_local_mem_type;\ntypedef cl_bitfield         cl_device_exec_capabilities;\ntypedef cl_bitfield         cl_command_queue_properties;\ntypedef intptr_t            cl_device_partition_property;\ntypedef cl_bitfield         cl_device_affinity_domain;\n\ntypedef intptr_t            cl_context_properties;\ntypedef cl_uint             cl_context_info;\ntypedef cl_uint             cl_command_queue_info;\ntypedef cl_uint             cl_channel_order;\ntypedef cl_uint             cl_channel_type;\ntypedef cl_bitfield         cl_mem_flags;\ntypedef cl_uint             cl_mem_object_type;\ntypedef cl_uint             cl_mem_info;\ntypedef cl_bitfield         cl_mem_migration_flags;\ntypedef cl_uint             cl_image_info;\ntypedef cl_uint             cl_buffer_create_type;\ntypedef cl_uint             cl_addressing_mode;\ntypedef cl_uint             cl_filter_mode;\ntypedef cl_uint             cl_sampler_info;\ntypedef cl_bitfield         cl_map_flags;\ntypedef cl_uint             cl_program_info;\ntypedef cl_uint             cl_program_build_info;\ntypedef cl_uint             cl_program_binary_type;\ntypedef cl_int              cl_build_status;\ntypedef cl_uint             cl_kernel_info;\ntypedef cl_uint             cl_kernel_arg_info;\ntypedef cl_uint             cl_kernel_arg_address_qualifier;\ntypedef cl_uint             cl_kernel_arg_access_qualifier;\ntypedef cl_bitfield         cl_kernel_arg_type_qualifier;\ntypedef cl_uint             cl_kernel_work_group_info;\ntypedef cl_uint             cl_event_info;\ntypedef cl_uint             cl_command_type;\ntypedef cl_uint             cl_profiling_info;\n\n\ntypedef struct _cl_image_format {\n    cl_channel_order        image_channel_order;\n    cl_channel_type         image_channel_data_type;\n} cl_image_format;\n\ntypedef struct _cl_image_desc {\n    cl_mem_object_type      image_type;\n    size_t                  image_width;\n    size_t                  image_height;\n    size_t                  image_depth;\n    size_t                  image_array_size;\n    size_t                  image_row_pitch;\n    size_t                  image_slice_pitch;\n    cl_uint                 num_mip_levels;\n    cl_uint                 num_samples;\n    cl_mem                  buffer;\n} cl_image_desc;\n\ntypedef struct _cl_buffer_region {\n    size_t                  origin;\n    size_t                  size;\n} cl_buffer_region;\n\n\n//////////////////////////////////////////////////////////\n\n#define CL_SUCCESS                                  0\n#define CL_DEVICE_NOT_FOUND                         -1\n#define CL_DEVICE_NOT_AVAILABLE                     -2\n#define CL_COMPILER_NOT_AVAILABLE                   -3\n#define CL_MEM_OBJECT_ALLOCATION_FAILURE            -4\n#define CL_OUT_OF_RESOURCES                         -5\n#define CL_OUT_OF_HOST_MEMORY                       -6\n#define CL_PROFILING_INFO_NOT_AVAILABLE             -7\n#define CL_MEM_COPY_OVERLAP                         -8\n#define CL_IMAGE_FORMAT_MISMATCH                    -9\n#define CL_IMAGE_FORMAT_NOT_SUPPORTED               -10\n#define CL_BUILD_PROGRAM_FAILURE                    -11\n#define CL_MAP_FAILURE                              -12\n#define CL_MISALIGNED_SUB_BUFFER_OFFSET             -13\n#define CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST -14\n#define CL_COMPILE_PROGRAM_FAILURE                  -15\n#define CL_LINKER_NOT_AVAILABLE                     -16\n#define CL_LINK_PROGRAM_FAILURE                     -17\n#define CL_DEVICE_PARTITION_FAILED                  -18\n#define CL_KERNEL_ARG_INFO_NOT_AVAILABLE            -19\n\n#define CL_INVALID_VALUE                            -30\n#define CL_INVALID_DEVICE_TYPE                      -31\n#define CL_INVALID_PLATFORM                         -32\n#define CL_INVALID_DEVICE                           -33\n#define CL_INVALID_CONTEXT                          -34\n#define CL_INVALID_QUEUE_PROPERTIES                 -35\n#define CL_INVALID_COMMAND_QUEUE                    -36\n#define CL_INVALID_HOST_PTR                         -37\n#define CL_INVALID_MEM_OBJECT                       -38\n#define CL_INVALID_IMAGE_FORMAT_DESCRIPTOR          -39\n#define CL_INVALID_IMAGE_SIZE                       -40\n#define CL_INVALID_SAMPLER                          -41\n#define CL_INVALID_BINARY                           -42\n#define CL_INVALID_BUILD_OPTIONS                    -43\n#define CL_INVALID_PROGRAM                          -44\n#define CL_INVALID_PROGRAM_EXECUTABLE               -45\n#define CL_INVALID_KERNEL_NAME                      -46\n#define CL_INVALID_KERNEL_DEFINITION                -47\n#define CL_INVALID_KERNEL                           -48\n#define CL_INVALID_ARG_INDEX                        -49\n#define CL_INVALID_ARG_VALUE                        -50\n#define CL_INVALID_ARG_SIZE                         -51\n#define CL_INVALID_KERNEL_ARGS                      -52\n#define CL_INVALID_WORK_DIMENSION                   -53\n#define CL_INVALID_WORK_GROUP_SIZE                  -54\n#define CL_INVALID_WORK_ITEM_SIZE                   -55\n#define CL_INVALID_GLOBAL_OFFSET                    -56\n#define CL_INVALID_EVENT_WAIT_LIST                  -57\n#define CL_INVALID_EVENT                            -58\n#define CL_INVALID_OPERATION                        -59\n#define CL_INVALID_GL_OBJECT                        -60\n#define CL_INVALID_BUFFER_SIZE                      -61\n#define CL_INVALID_MIP_LEVEL                        -62\n#define CL_INVALID_GLOBAL_WORK_SIZE                 -63\n#define CL_INVALID_PROPERTY                         -64\n#define CL_INVALID_IMAGE_DESCRIPTOR                 -65\n#define CL_INVALID_COMPILER_OPTIONS                 -66\n#define CL_INVALID_LINKER_OPTIONS                   -67\n#define CL_INVALID_DEVICE_PARTITION_COUNT           -68\n\n/*#define CL_VERSION_1_0                              1\n#define CL_VERSION_1_1                              1\n#define CL_VERSION_1_2                              1*/\n\n#define CL_FALSE                                    0\n#define CL_TRUE                                     1\n#define CL_BLOCKING                                 CL_TRUE\n#define CL_NON_BLOCKING                             CL_FALSE\n\n#define CL_PLATFORM_PROFILE                         0x0900\n#define CL_PLATFORM_VERSION                         0x0901\n#define CL_PLATFORM_NAME                            0x0902\n#define CL_PLATFORM_VENDOR                          0x0903\n#define CL_PLATFORM_EXTENSIONS                      0x0904\n\n#define CL_DEVICE_TYPE_DEFAULT                      (1 << 0)\n#define CL_DEVICE_TYPE_CPU                          (1 << 1)\n#define CL_DEVICE_TYPE_GPU                          (1 << 2)\n#define CL_DEVICE_TYPE_ACCELERATOR                  (1 << 3)\n#define CL_DEVICE_TYPE_CUSTOM                       (1 << 4)\n#define CL_DEVICE_TYPE_ALL                          0xFFFFFFFF\n#define CL_DEVICE_TYPE                              0x1000\n#define CL_DEVICE_VENDOR_ID                         0x1001\n#define CL_DEVICE_MAX_COMPUTE_UNITS                 0x1002\n#define CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS          0x1003\n#define CL_DEVICE_MAX_WORK_GROUP_SIZE               0x1004\n#define CL_DEVICE_MAX_WORK_ITEM_SIZES               0x1005\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR       0x1006\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT      0x1007\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT        0x1008\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG       0x1009\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT      0x100A\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE     0x100B\n#define CL_DEVICE_MAX_CLOCK_FREQUENCY               0x100C\n#define CL_DEVICE_ADDRESS_BITS                      0x100D\n#define CL_DEVICE_MAX_READ_IMAGE_ARGS               0x100E\n#define CL_DEVICE_MAX_WRITE_IMAGE_ARGS              0x100F\n#define CL_DEVICE_MAX_MEM_ALLOC_SIZE                0x1010\n#define CL_DEVICE_IMAGE2D_MAX_WIDTH                 0x1011\n#define CL_DEVICE_IMAGE2D_MAX_HEIGHT                0x1012\n#define CL_DEVICE_IMAGE3D_MAX_WIDTH                 0x1013\n#define CL_DEVICE_IMAGE3D_MAX_HEIGHT                0x1014\n#define CL_DEVICE_IMAGE3D_MAX_DEPTH                 0x1015\n#define CL_DEVICE_IMAGE_SUPPORT                     0x1016\n#define CL_DEVICE_MAX_PARAMETER_SIZE                0x1017\n#define CL_DEVICE_MAX_SAMPLERS                      0x1018\n#define CL_DEVICE_MEM_BASE_ADDR_ALIGN               0x1019\n#define CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE          0x101A\n#define CL_DEVICE_SINGLE_FP_CONFIG                  0x101B\n#define CL_DEVICE_GLOBAL_MEM_CACHE_TYPE             0x101C\n#define CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE         0x101D\n#define CL_DEVICE_GLOBAL_MEM_CACHE_SIZE             0x101E\n#define CL_DEVICE_GLOBAL_MEM_SIZE                   0x101F\n#define CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE          0x1020\n#define CL_DEVICE_MAX_CONSTANT_ARGS                 0x1021\n#define CL_DEVICE_LOCAL_MEM_TYPE                    0x1022\n#define CL_DEVICE_LOCAL_MEM_SIZE                    0x1023\n#define CL_DEVICE_ERROR_CORRECTION_SUPPORT          0x1024\n#define CL_DEVICE_PROFILING_TIMER_RESOLUTION        0x1025\n#define CL_DEVICE_ENDIAN_LITTLE                     0x1026\n#define CL_DEVICE_AVAILABLE                         0x1027\n#define CL_DEVICE_COMPILER_AVAILABLE                0x1028\n#define CL_DEVICE_EXECUTION_CAPABILITIES            0x1029\n#define CL_DEVICE_QUEUE_PROPERTIES                  0x102A\n#define CL_DEVICE_NAME                              0x102B\n#define CL_DEVICE_VENDOR                            0x102C\n#define CL_DRIVER_VERSION                           0x102D\n#define CL_DEVICE_PROFILE                           0x102E\n#define CL_DEVICE_VERSION                           0x102F\n#define CL_DEVICE_EXTENSIONS                        0x1030\n#define CL_DEVICE_PLATFORM                          0x1031\n#define CL_DEVICE_DOUBLE_FP_CONFIG                  0x1032\n#define CL_DEVICE_HALF_FP_CONFIG                    0x1033\n#define CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF       0x1034\n#define CL_DEVICE_HOST_UNIFIED_MEMORY               0x1035\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR          0x1036\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT         0x1037\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_INT           0x1038\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG          0x1039\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT         0x103A\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE        0x103B\n#define CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF          0x103C\n#define CL_DEVICE_OPENCL_C_VERSION                  0x103D\n#define CL_DEVICE_LINKER_AVAILABLE                  0x103E\n#define CL_DEVICE_BUILT_IN_KERNELS                  0x103F\n#define CL_DEVICE_IMAGE_MAX_BUFFER_SIZE             0x1040\n#define CL_DEVICE_IMAGE_MAX_ARRAY_SIZE              0x1041\n#define CL_DEVICE_PARENT_DEVICE                     0x1042\n#define CL_DEVICE_PARTITION_MAX_SUB_DEVICES         0x1043\n#define CL_DEVICE_PARTITION_PROPERTIES              0x1044\n#define CL_DEVICE_PARTITION_AFFINITY_DOMAIN         0x1045\n#define CL_DEVICE_PARTITION_TYPE                    0x1046\n#define CL_DEVICE_REFERENCE_COUNT                   0x1047\n#define CL_DEVICE_PREFERRED_INTEROP_USER_SYNC       0x1048\n#define CL_DEVICE_PRINTF_BUFFER_SIZE                0x1049\n#define CL_DEVICE_IMAGE_PITCH_ALIGNMENT             0x104A\n#define CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT      0x104B\n\n#define CL_FP_DENORM                                (1 << 0)\n#define CL_FP_INF_NAN                               (1 << 1)\n#define CL_FP_ROUND_TO_NEAREST                      (1 << 2)\n#define CL_FP_ROUND_TO_ZERO                         (1 << 3)\n#define CL_FP_ROUND_TO_INF                          (1 << 4)\n#define CL_FP_FMA                                   (1 << 5)\n#define CL_FP_SOFT_FLOAT                            (1 << 6)\n#define CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT         (1 << 7)\n\n#define CL_NONE                                     0x0\n#define CL_READ_ONLY_CACHE                          0x1\n#define CL_READ_WRITE_CACHE                         0x2\n#define CL_LOCAL                                    0x1\n#define CL_GLOBAL                                   0x2\n#define CL_EXEC_KERNEL                              (1 << 0)\n#define CL_EXEC_NATIVE_KERNEL                       (1 << 1)\n#define CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE      (1 << 0)\n#define CL_QUEUE_PROFILING_ENABLE                   (1 << 1)\n\n#define CL_CONTEXT_REFERENCE_COUNT                  0x1080\n#define CL_CONTEXT_DEVICES                          0x1081\n#define CL_CONTEXT_PROPERTIES                       0x1082\n#define CL_CONTEXT_NUM_DEVICES                      0x1083\n#define CL_CONTEXT_PLATFORM                         0x1084\n#define CL_CONTEXT_INTEROP_USER_SYNC                0x1085\n\n#define CL_DEVICE_PARTITION_EQUALLY                 0x1086\n#define CL_DEVICE_PARTITION_BY_COUNTS               0x1087\n#define CL_DEVICE_PARTITION_BY_COUNTS_LIST_END      0x0\n#define CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN      0x1088\n#define CL_DEVICE_AFFINITY_DOMAIN_NUMA                     (1 << 0)\n#define CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE                 (1 << 1)\n#define CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE                 (1 << 2)\n#define CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE                 (1 << 3)\n#define CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE                 (1 << 4)\n#define CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE       (1 << 5)\n#define CL_QUEUE_CONTEXT                            0x1090\n#define CL_QUEUE_DEVICE                             0x1091\n#define CL_QUEUE_REFERENCE_COUNT                    0x1092\n#define CL_QUEUE_PROPERTIES                         0x1093\n#define CL_MEM_READ_WRITE                           (1 << 0)\n#define CL_MEM_WRITE_ONLY                           (1 << 1)\n#define CL_MEM_READ_ONLY                            (1 << 2)\n#define CL_MEM_USE_HOST_PTR                         (1 << 3)\n#define CL_MEM_ALLOC_HOST_PTR                       (1 << 4)\n#define CL_MEM_COPY_HOST_PTR                        (1 << 5)\n// reserved                                         (1 << 6)\n#define CL_MEM_HOST_WRITE_ONLY                      (1 << 7)\n#define CL_MEM_HOST_READ_ONLY                       (1 << 8)\n#define CL_MEM_HOST_NO_ACCESS                       (1 << 9)\n#define CL_MIGRATE_MEM_OBJECT_HOST                  (1 << 0)\n#define CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED     (1 << 1)\n\n#define CL_R                                        0x10B0\n#define CL_A                                        0x10B1\n#define CL_RG                                       0x10B2\n#define CL_RA                                       0x10B3\n#define CL_RGB                                      0x10B4\n#define CL_RGBA                                     0x10B5\n#define CL_BGRA                                     0x10B6\n#define CL_ARGB                                     0x10B7\n#define CL_INTENSITY                                0x10B8\n#define CL_LUMINANCE                                0x10B9\n#define CL_Rx                                       0x10BA\n#define CL_RGx                                      0x10BB\n#define CL_RGBx                                     0x10BC\n#define CL_DEPTH                                    0x10BD\n#define CL_DEPTH_STENCIL                            0x10BE\n\n#define CL_SNORM_INT8                               0x10D0\n#define CL_SNORM_INT16                              0x10D1\n#define CL_UNORM_INT8                               0x10D2\n#define CL_UNORM_INT16                              0x10D3\n#define CL_UNORM_SHORT_565                          0x10D4\n#define CL_UNORM_SHORT_555                          0x10D5\n#define CL_UNORM_INT_101010                         0x10D6\n#define CL_SIGNED_INT8                              0x10D7\n#define CL_SIGNED_INT16                             0x10D8\n#define CL_SIGNED_INT32                             0x10D9\n#define CL_UNSIGNED_INT8                            0x10DA\n#define CL_UNSIGNED_INT16                           0x10DB\n#define CL_UNSIGNED_INT32                           0x10DC\n#define CL_HALF_FLOAT                               0x10DD\n#define CL_FLOAT                                    0x10DE\n#define CL_UNORM_INT24                              0x10DF\n\n#define CL_MEM_OBJECT_BUFFER                        0x10F0\n#define CL_MEM_OBJECT_IMAGE2D                       0x10F1\n#define CL_MEM_OBJECT_IMAGE3D                       0x10F2\n#define CL_MEM_OBJECT_IMAGE2D_ARRAY                 0x10F3\n#define CL_MEM_OBJECT_IMAGE1D                       0x10F4\n#define CL_MEM_OBJECT_IMAGE1D_ARRAY                 0x10F5\n#define CL_MEM_OBJECT_IMAGE1D_BUFFER                0x10F6\n\n#define CL_MEM_TYPE                                 0x1100\n#define CL_MEM_FLAGS                                0x1101\n#define CL_MEM_SIZE                                 0x1102\n#define CL_MEM_HOST_PTR                             0x1103\n#define CL_MEM_MAP_COUNT                            0x1104\n#define CL_MEM_REFERENCE_COUNT                      0x1105\n#define CL_MEM_CONTEXT                              0x1106\n#define CL_MEM_ASSOCIATED_MEMOBJECT                 0x1107\n#define CL_MEM_OFFSET                               0x1108\n\n#define CL_IMAGE_FORMAT                             0x1110\n#define CL_IMAGE_ELEMENT_SIZE                       0x1111\n#define CL_IMAGE_ROW_PITCH                          0x1112\n#define CL_IMAGE_SLICE_PITCH                        0x1113\n#define CL_IMAGE_WIDTH                              0x1114\n#define CL_IMAGE_HEIGHT                             0x1115\n#define CL_IMAGE_DEPTH                              0x1116\n#define CL_IMAGE_ARRAY_SIZE                         0x1117\n#define CL_IMAGE_BUFFER                             0x1118\n#define CL_IMAGE_NUM_MIP_LEVELS                     0x1119\n#define CL_IMAGE_NUM_SAMPLES                        0x111A\n\n#define CL_ADDRESS_NONE                             0x1130\n#define CL_ADDRESS_CLAMP_TO_EDGE                    0x1131\n#define CL_ADDRESS_CLAMP                            0x1132\n#define CL_ADDRESS_REPEAT                           0x1133\n#define CL_ADDRESS_MIRRORED_REPEAT                  0x1134\n\n#define CL_FILTER_NEAREST                           0x1140\n#define CL_FILTER_LINEAR                            0x1141\n\n#define CL_SAMPLER_REFERENCE_COUNT                  0x1150\n#define CL_SAMPLER_CONTEXT                          0x1151\n#define CL_SAMPLER_NORMALIZED_COORDS                0x1152\n#define CL_SAMPLER_ADDRESSING_MODE                  0x1153\n#define CL_SAMPLER_FILTER_MODE                      0x1154\n\n#define CL_MAP_READ                                 (1 << 0)\n#define CL_MAP_WRITE                                (1 << 1)\n#define CL_MAP_WRITE_INVALIDATE_REGION              (1 << 2)\n\n#define CL_PROGRAM_REFERENCE_COUNT                  0x1160\n#define CL_PROGRAM_CONTEXT                          0x1161\n#define CL_PROGRAM_NUM_DEVICES                      0x1162\n#define CL_PROGRAM_DEVICES                          0x1163\n#define CL_PROGRAM_SOURCE                           0x1164\n#define CL_PROGRAM_BINARY_SIZES                     0x1165\n#define CL_PROGRAM_BINARIES                         0x1166\n#define CL_PROGRAM_NUM_KERNELS                      0x1167\n#define CL_PROGRAM_KERNEL_NAMES                     0x1168\n#define CL_PROGRAM_BUILD_STATUS                     0x1181\n#define CL_PROGRAM_BUILD_OPTIONS                    0x1182\n#define CL_PROGRAM_BUILD_LOG                        0x1183\n#define CL_PROGRAM_BINARY_TYPE                      0x1184\n#define CL_PROGRAM_BINARY_TYPE_NONE                 0x0\n#define CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT      0x1\n#define CL_PROGRAM_BINARY_TYPE_LIBRARY              0x2\n#define CL_PROGRAM_BINARY_TYPE_EXECUTABLE           0x4\n\n#define CL_BUILD_SUCCESS                            0\n#define CL_BUILD_NONE                               -1\n#define CL_BUILD_ERROR                              -2\n#define CL_BUILD_IN_PROGRESS                        -3\n\n#define CL_KERNEL_FUNCTION_NAME                     0x1190\n#define CL_KERNEL_NUM_ARGS                          0x1191\n#define CL_KERNEL_REFERENCE_COUNT                   0x1192\n#define CL_KERNEL_CONTEXT                           0x1193\n#define CL_KERNEL_PROGRAM                           0x1194\n#define CL_KERNEL_ATTRIBUTES                        0x1195\n#define CL_KERNEL_ARG_ADDRESS_QUALIFIER             0x1196\n#define CL_KERNEL_ARG_ACCESS_QUALIFIER              0x1197\n#define CL_KERNEL_ARG_TYPE_NAME                     0x1198\n#define CL_KERNEL_ARG_TYPE_QUALIFIER                0x1199\n#define CL_KERNEL_ARG_NAME                          0x119A\n#define CL_KERNEL_ARG_ADDRESS_GLOBAL                0x119B\n#define CL_KERNEL_ARG_ADDRESS_LOCAL                 0x119C\n#define CL_KERNEL_ARG_ADDRESS_CONSTANT              0x119D\n#define CL_KERNEL_ARG_ADDRESS_PRIVATE               0x119E\n#define CL_KERNEL_ARG_ACCESS_READ_ONLY              0x11A0\n#define CL_KERNEL_ARG_ACCESS_WRITE_ONLY             0x11A1\n#define CL_KERNEL_ARG_ACCESS_READ_WRITE             0x11A2\n#define CL_KERNEL_ARG_ACCESS_NONE                   0x11A3\n#define CL_KERNEL_ARG_TYPE_NONE                     0\n#define CL_KERNEL_ARG_TYPE_CONST                    (1 << 0)\n#define CL_KERNEL_ARG_TYPE_RESTRICT                 (1 << 1)\n#define CL_KERNEL_ARG_TYPE_VOLATILE                 (1 << 2)\n#define CL_KERNEL_WORK_GROUP_SIZE                   0x11B0\n#define CL_KERNEL_COMPILE_WORK_GROUP_SIZE           0x11B1\n#define CL_KERNEL_LOCAL_MEM_SIZE                    0x11B2\n#define CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE 0x11B3\n#define CL_KERNEL_PRIVATE_MEM_SIZE                  0x11B4\n#define CL_KERNEL_GLOBAL_WORK_SIZE                  0x11B5\n\n#define CL_EVENT_COMMAND_QUEUE                      0x11D0\n#define CL_EVENT_COMMAND_TYPE                       0x11D1\n#define CL_EVENT_REFERENCE_COUNT                    0x11D2\n#define CL_EVENT_COMMAND_EXECUTION_STATUS           0x11D3\n#define CL_EVENT_CONTEXT                            0x11D4\n\n#define CL_COMMAND_NDRANGE_KERNEL                   0x11F0\n#define CL_COMMAND_TASK                             0x11F1\n#define CL_COMMAND_NATIVE_KERNEL                    0x11F2\n#define CL_COMMAND_READ_BUFFER                      0x11F3\n#define CL_COMMAND_WRITE_BUFFER                     0x11F4\n#define CL_COMMAND_COPY_BUFFER                      0x11F5\n#define CL_COMMAND_READ_IMAGE                       0x11F6\n#define CL_COMMAND_WRITE_IMAGE                      0x11F7\n#define CL_COMMAND_COPY_IMAGE                       0x11F8\n#define CL_COMMAND_COPY_IMAGE_TO_BUFFER             0x11F9\n#define CL_COMMAND_COPY_BUFFER_TO_IMAGE             0x11FA\n#define CL_COMMAND_MAP_BUFFER                       0x11FB\n#define CL_COMMAND_MAP_IMAGE                        0x11FC\n#define CL_COMMAND_UNMAP_MEM_OBJECT                 0x11FD\n#define CL_COMMAND_MARKER                           0x11FE\n#define CL_COMMAND_ACQUIRE_GL_OBJECTS               0x11FF\n#define CL_COMMAND_RELEASE_GL_OBJECTS               0x1200\n#define CL_COMMAND_READ_BUFFER_RECT                 0x1201\n#define CL_COMMAND_WRITE_BUFFER_RECT                0x1202\n#define CL_COMMAND_COPY_BUFFER_RECT                 0x1203\n#define CL_COMMAND_USER                             0x1204\n#define CL_COMMAND_BARRIER                          0x1205\n#define CL_COMMAND_MIGRATE_MEM_OBJECTS              0x1206\n#define CL_COMMAND_FILL_BUFFER                      0x1207\n#define CL_COMMAND_FILL_IMAGE                       0x1208\n\n#define CL_COMPLETE                                 0x0\n#define CL_RUNNING                                  0x1\n#define CL_SUBMITTED                                0x2\n#define CL_QUEUED                                   0x3\n#define CL_BUFFER_CREATE_TYPE_REGION                0x1220\n\n#define CL_PROFILING_COMMAND_QUEUED                 0x1280\n#define CL_PROFILING_COMMAND_SUBMIT                 0x1281\n#define CL_PROFILING_COMMAND_START                  0x1282\n#define CL_PROFILING_COMMAND_END                    0x1283\n\n#define CL_CALLBACK CV_STDCALL\n\nstatic volatile bool g_haveOpenCL = false;\nstatic const char* oclFuncToCheck = \"clEnqueueReadBufferRect\";\n\n#if defined(__APPLE__)\n#include <dlfcn.h>\n\nstatic void* initOpenCLAndLoad(const char* funcname)\n{\n    static bool initialized = false;\n    static void* handle = 0;\n    if (!handle)\n    {\n        if(!initialized)\n        {\n            const char* oclpath = getenv(\"OPENCV_OPENCL_RUNTIME\");\n            oclpath = oclpath && strlen(oclpath) > 0 ? oclpath :\n                \"/System/Library/Frameworks/OpenCL.framework/Versions/Current/OpenCL\";\n            handle = dlopen(oclpath, RTLD_LAZY);\n            initialized = true;\n            g_haveOpenCL = handle != 0 && dlsym(handle, oclFuncToCheck) != 0;\n            if( g_haveOpenCL )\n                fprintf(stderr, \"Successfully loaded OpenCL v1.1+ runtime from %s\\n\", oclpath);\n            else\n                fprintf(stderr, \"Failed to load OpenCL runtime\\n\");\n        }\n        if(!handle)\n            return 0;\n    }\n\n    return funcname && handle ? dlsym(handle, funcname) : 0;\n}\n\n#elif defined WIN32 || defined _WIN32\n\n#ifndef _WIN32_WINNT           // This is needed for the declaration of TryEnterCriticalSection in winbase.h with Visual Studio 2005 (and older?)\n  #define _WIN32_WINNT 0x0400  // http://msdn.microsoft.com/en-us/library/ms686857(VS.85).aspx\n#endif\n#include <windows.h>\n#if (_WIN32_WINNT >= 0x0602)\n  #include <synchapi.h>\n#endif\n#undef small\n#undef min\n#undef max\n#undef abs\n\nstatic void* initOpenCLAndLoad(const char* funcname)\n{\n    static bool initialized = false;\n    static HMODULE handle = 0;\n    if (!handle)\n    {\n#ifndef WINRT\n        if(!initialized)\n        {\n            handle = LoadLibraryA(\"OpenCL.dll\");\n            initialized = true;\n            g_haveOpenCL = handle != 0 && GetProcAddress(handle, oclFuncToCheck) != 0;\n        }\n#endif\n        if(!handle)\n            return 0;\n    }\n\n    return funcname ? (void*)GetProcAddress(handle, funcname) : 0;\n}\n\n#elif defined(__linux)\n\n#include <dlfcn.h>\n#include <stdio.h>\n\nstatic void* initOpenCLAndLoad(const char* funcname)\n{\n    static bool initialized = false;\n    static void* handle = 0;\n    if (!handle)\n    {\n        if(!initialized)\n        {\n            handle = dlopen(\"libOpenCL.so\", RTLD_LAZY);\n            if(!handle)\n                handle = dlopen(\"libCL.so\", RTLD_LAZY);\n            initialized = true;\n            g_haveOpenCL = handle != 0 && dlsym(handle, oclFuncToCheck) != 0;\n        }\n        if(!handle)\n            return 0;\n    }\n\n    return funcname ? (void*)dlsym(handle, funcname) : 0;\n}\n\n#else\n\nstatic void* initOpenCLAndLoad(const char*)\n{\n    return 0;\n}\n\n#endif\n\n\n#define OCL_FUNC(rettype, funcname, argsdecl, args) \\\n    typedef rettype (CV_STDCALL * funcname##_t) argsdecl; \\\n    static rettype funcname argsdecl \\\n    { \\\n        static funcname##_t funcname##_p = 0; \\\n        if( !funcname##_p ) \\\n        { \\\n            funcname##_p = (funcname##_t)initOpenCLAndLoad(#funcname); \\\n            if( !funcname##_p ) \\\n                return OPENCV_CL_NOT_IMPLEMENTED; \\\n        } \\\n        return funcname##_p args; \\\n    }\n\n\n#define OCL_FUNC_P(rettype, funcname, argsdecl, args) \\\n    typedef rettype (CV_STDCALL * funcname##_t) argsdecl; \\\n    static rettype funcname argsdecl \\\n    { \\\n        static funcname##_t funcname##_p = 0; \\\n        if( !funcname##_p ) \\\n        { \\\n            funcname##_p = (funcname##_t)initOpenCLAndLoad(#funcname); \\\n            if( !funcname##_p ) \\\n            { \\\n                if( errcode_ret ) \\\n                    *errcode_ret = OPENCV_CL_NOT_IMPLEMENTED; \\\n                return 0; \\\n            } \\\n        } \\\n        return funcname##_p args; \\\n    }\n\nOCL_FUNC(cl_int, clGetPlatformIDs,\n    (cl_uint num_entries, cl_platform_id* platforms, cl_uint* num_platforms),\n    (num_entries, platforms, num_platforms))\n\nOCL_FUNC(cl_int, clGetPlatformInfo,\n    (cl_platform_id platform, cl_platform_info param_name,\n    size_t param_value_size, void * param_value,\n    size_t * param_value_size_ret),\n    (platform, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC(cl_int, clGetDeviceInfo,\n         (cl_device_id device,\n          cl_device_info param_name,\n          size_t param_value_size,\n          void * param_value,\n          size_t * param_value_size_ret),\n         (device, param_name, param_value_size, param_value, param_value_size_ret))\n\n\nOCL_FUNC(cl_int, clGetDeviceIDs,\n    (cl_platform_id platform,\n    cl_device_type device_type,\n    cl_uint num_entries,\n    cl_device_id * devices,\n    cl_uint * num_devices),\n    (platform, device_type, num_entries, devices, num_devices))\n\nOCL_FUNC_P(cl_context, clCreateContext,\n    (const cl_context_properties * properties,\n    cl_uint num_devices,\n    const cl_device_id * devices,\n    void (CL_CALLBACK * pfn_notify)(const char *, const void *, size_t, void *),\n    void * user_data,\n    cl_int * errcode_ret),\n    (properties, num_devices, devices, pfn_notify, user_data, errcode_ret))\n\nOCL_FUNC(cl_int, clReleaseContext, (cl_context context), (context))\n\n\nOCL_FUNC(cl_int, clRetainContext, (cl_context context), (context))\n/*\nOCL_FUNC_P(cl_context, clCreateContextFromType,\n    (const cl_context_properties * properties,\n    cl_device_type device_type,\n    void (CL_CALLBACK * pfn_notify)(const char *, const void *, size_t, void *),\n    void * user_data,\n    cl_int * errcode_ret),\n    (properties, device_type, pfn_notify, user_data, errcode_ret))\n\nOCL_FUNC(cl_int, clGetContextInfo,\n    (cl_context context,\n    cl_context_info param_name,\n    size_t param_value_size,\n    void * param_value,\n    size_t * param_value_size_ret),\n    (context, param_name, param_value_size,\n    param_value, param_value_size_ret))\n*/\nOCL_FUNC_P(cl_command_queue, clCreateCommandQueue,\n    (cl_context context,\n    cl_device_id device,\n    cl_command_queue_properties properties,\n    cl_int * errcode_ret),\n    (context, device, properties, errcode_ret))\n\nOCL_FUNC(cl_int, clReleaseCommandQueue, (cl_command_queue command_queue), (command_queue))\n\nOCL_FUNC_P(cl_mem, clCreateBuffer,\n    (cl_context context,\n    cl_mem_flags flags,\n    size_t size,\n    void * host_ptr,\n    cl_int * errcode_ret),\n    (context, flags, size, host_ptr, errcode_ret))\n\n/*\nOCL_FUNC(cl_int, clRetainCommandQueue, (cl_command_queue command_queue), (command_queue))\n\nOCL_FUNC(cl_int, clGetCommandQueueInfo,\n (cl_command_queue command_queue,\n cl_command_queue_info param_name,\n size_t param_value_size,\n void * param_value,\n size_t * param_value_size_ret),\n (command_queue, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC_P(cl_mem, clCreateSubBuffer,\n    (cl_mem buffer,\n    cl_mem_flags flags,\n    cl_buffer_create_type buffer_create_type,\n    const void * buffer_create_info,\n    cl_int * errcode_ret),\n    (buffer, flags, buffer_create_type, buffer_create_info, errcode_ret))\n*/\n\nOCL_FUNC_P(cl_mem, clCreateImage,\n    (cl_context context,\n    cl_mem_flags flags,\n    const cl_image_format * image_format,\n    const cl_image_desc * image_desc,\n    void * host_ptr,\n    cl_int * errcode_ret),\n    (context, flags, image_format, image_desc, host_ptr, errcode_ret))\n\nOCL_FUNC_P(cl_mem, clCreateImage2D,\n    (cl_context context,\n    cl_mem_flags flags,\n    const cl_image_format * image_format,\n    size_t image_width,\n    size_t image_height,\n    size_t image_row_pitch,\n    void * host_ptr,\n    cl_int *errcode_ret),\n    (context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret))\n\nOCL_FUNC(cl_int, clGetSupportedImageFormats,\n (cl_context context,\n cl_mem_flags flags,\n cl_mem_object_type image_type,\n cl_uint num_entries,\n cl_image_format * image_formats,\n cl_uint * num_image_formats),\n (context, flags, image_type, num_entries, image_formats, num_image_formats))\n\n\nOCL_FUNC(cl_int, clGetMemObjectInfo,\n (cl_mem memobj,\n cl_mem_info param_name,\n size_t param_value_size,\n void * param_value,\n size_t * param_value_size_ret),\n (memobj, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC(cl_int, clGetImageInfo,\n (cl_mem image,\n cl_image_info param_name,\n size_t param_value_size,\n void * param_value,\n size_t * param_value_size_ret),\n (image, param_name, param_value_size, param_value, param_value_size_ret))\n\n/*\nOCL_FUNC(cl_int, clCreateKernelsInProgram,\n (cl_program program,\n cl_uint num_kernels,\n cl_kernel * kernels,\n cl_uint * num_kernels_ret),\n (program, num_kernels, kernels, num_kernels_ret))\n\nOCL_FUNC(cl_int, clRetainKernel, (cl_kernel kernel), (kernel))\n\nOCL_FUNC(cl_int, clGetKernelArgInfo,\n (cl_kernel kernel,\n cl_uint arg_indx,\n cl_kernel_arg_info param_name,\n size_t param_value_size,\n void * param_value,\n size_t * param_value_size_ret),\n (kernel, arg_indx, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC(cl_int, clEnqueueReadImage,\n (cl_command_queue command_queue,\n cl_mem image,\n cl_bool blocking_read,\n const size_t * origin[3],\n const size_t * region[3],\n size_t row_pitch,\n size_t slice_pitch,\n void * ptr,\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, image, blocking_read, origin, region,\n row_pitch, slice_pitch,\n ptr,\n num_events_in_wait_list,\n event_wait_list,\n event))\n\nOCL_FUNC(cl_int, clEnqueueWriteImage,\n (cl_command_queue command_queue,\n cl_mem image,\n cl_bool blocking_write,\n const size_t * origin[3],\n const size_t * region[3],\n size_t input_row_pitch,\n size_t input_slice_pitch,\n const void * ptr,\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, image, blocking_write, origin, region, input_row_pitch,\n input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueFillImage,\n (cl_command_queue command_queue,\n cl_mem image,\n const void * fill_color,\n const size_t * origin[3],\n const size_t * region[3],\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, image, fill_color, origin, region,\n num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueCopyImage,\n (cl_command_queue command_queue,\n cl_mem src_image,\n cl_mem dst_image,\n const size_t * src_origin[3],\n const size_t * dst_origin[3],\n const size_t * region[3],\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, src_image, dst_image, src_origin, dst_origin,\n region, num_events_in_wait_list, event_wait_list, event))\n*/\n\nOCL_FUNC(cl_int, clEnqueueCopyImageToBuffer,\n (cl_command_queue command_queue,\n cl_mem src_image,\n cl_mem dst_buffer,\n const size_t * src_origin,\n const size_t * region,\n size_t dst_offset,\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, src_image, dst_buffer, src_origin, region, dst_offset,\n num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueCopyBufferToImage,\n (cl_command_queue command_queue,\n cl_mem src_buffer,\n cl_mem dst_image,\n size_t src_offset,\n const size_t dst_origin[3],\n const size_t region[3],\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event),\n (command_queue, src_buffer, dst_image, src_offset, dst_origin,\n region, num_events_in_wait_list, event_wait_list, event))\n\n OCL_FUNC(cl_int, clFlush,\n (cl_command_queue command_queue),\n (command_queue))\n\n/*\nOCL_FUNC_P(void*, clEnqueueMapImage,\n (cl_command_queue command_queue,\n cl_mem image,\n cl_bool blocking_map,\n cl_map_flags map_flags,\n const size_t * origin[3],\n const size_t * region[3],\n size_t * image_row_pitch,\n size_t * image_slice_pitch,\n cl_uint num_events_in_wait_list,\n const cl_event * event_wait_list,\n cl_event * event,\n cl_int * errcode_ret),\n (command_queue, image, blocking_map, map_flags, origin, region,\n image_row_pitch, image_slice_pitch, num_events_in_wait_list,\n event_wait_list, event, errcode_ret))\n*/\n\n/*\nOCL_FUNC(cl_int, clRetainProgram, (cl_program program), (program))\n\nOCL_FUNC(cl_int, clGetKernelInfo,\n (cl_kernel kernel,\n cl_kernel_info param_name,\n size_t param_value_size,\n void * param_value,\n size_t * param_value_size_ret),\n (kernel, param_name, param_value_size, param_value, param_value_size_ret))\n\n*/\n\nOCL_FUNC(cl_int, clRetainMemObject, (cl_mem memobj), (memobj))\n\nOCL_FUNC(cl_int, clReleaseMemObject, (cl_mem memobj), (memobj))\n\n\nOCL_FUNC_P(cl_program, clCreateProgramWithSource,\n    (cl_context context,\n    cl_uint count,\n    const char ** strings,\n    const size_t * lengths,\n    cl_int * errcode_ret),\n    (context, count, strings, lengths, errcode_ret))\n\nOCL_FUNC_P(cl_program, clCreateProgramWithBinary,\n    (cl_context context,\n    cl_uint num_devices,\n    const cl_device_id * device_list,\n    const size_t * lengths,\n    const unsigned char ** binaries,\n    cl_int * binary_status,\n    cl_int * errcode_ret),\n    (context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret))\n\nOCL_FUNC(cl_int, clReleaseProgram, (cl_program program), (program))\n\nOCL_FUNC(cl_int, clBuildProgram,\n    (cl_program program,\n    cl_uint num_devices,\n    const cl_device_id * device_list,\n    const char * options,\n    void (CL_CALLBACK * pfn_notify)(cl_program, void *),\n    void * user_data),\n    (program, num_devices, device_list, options, pfn_notify, user_data))\n\nOCL_FUNC(cl_int, clGetProgramInfo,\n    (cl_program program,\n    cl_program_info param_name,\n    size_t param_value_size,\n    void * param_value,\n    size_t * param_value_size_ret),\n    (program, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC(cl_int, clGetProgramBuildInfo,\n    (cl_program program,\n    cl_device_id device,\n    cl_program_build_info param_name,\n    size_t param_value_size,\n    void * param_value,\n    size_t * param_value_size_ret),\n    (program, device, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC_P(cl_kernel, clCreateKernel,\n    (cl_program program,\n    const char * kernel_name,\n    cl_int * errcode_ret),\n    (program, kernel_name, errcode_ret))\n\nOCL_FUNC(cl_int, clReleaseKernel, (cl_kernel kernel), (kernel))\n\nOCL_FUNC(cl_int, clSetKernelArg,\n    (cl_kernel kernel,\n    cl_uint arg_index,\n    size_t arg_size,\n    const void * arg_value),\n    (kernel, arg_index, arg_size, arg_value))\n\nOCL_FUNC(cl_int, clGetKernelWorkGroupInfo,\n    (cl_kernel kernel,\n    cl_device_id device,\n    cl_kernel_work_group_info param_name,\n    size_t param_value_size,\n    void * param_value,\n    size_t * param_value_size_ret),\n    (kernel, device, param_name, param_value_size, param_value, param_value_size_ret))\n\nOCL_FUNC(cl_int, clFinish, (cl_command_queue command_queue), (command_queue))\n\nOCL_FUNC(cl_int, clEnqueueReadBuffer,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    cl_bool blocking_read,\n    size_t offset,\n    size_t size,\n    void * ptr,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, buffer, blocking_read, offset, size, ptr,\n    num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueReadBufferRect,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    cl_bool blocking_read,\n    const size_t * buffer_offset,\n    const size_t * host_offset,\n    const size_t * region,\n    size_t buffer_row_pitch,\n    size_t buffer_slice_pitch,\n    size_t host_row_pitch,\n    size_t host_slice_pitch,\n    void * ptr,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, buffer, blocking_read, buffer_offset, host_offset, region, buffer_row_pitch,\n    buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list,\n    event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueWriteBuffer,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    cl_bool blocking_write,\n    size_t offset,\n    size_t size,\n    const void * ptr,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, buffer, blocking_write, offset, size, ptr,\n    num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueWriteBufferRect,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    cl_bool blocking_write,\n    const size_t * buffer_offset,\n    const size_t * host_offset,\n    const size_t * region,\n    size_t buffer_row_pitch,\n    size_t buffer_slice_pitch,\n    size_t host_row_pitch,\n    size_t host_slice_pitch,\n    const void * ptr,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, buffer, blocking_write, buffer_offset, host_offset,\n    region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch,\n    host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event))\n\n/*OCL_FUNC(cl_int, clEnqueueFillBuffer,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    const void * pattern,\n    size_t pattern_size,\n    size_t offset,\n    size_t size,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, buffer, pattern, pattern_size, offset, size,\n    num_events_in_wait_list, event_wait_list, event))*/\n\nOCL_FUNC(cl_int, clEnqueueCopyBuffer,\n    (cl_command_queue command_queue,\n    cl_mem src_buffer,\n    cl_mem dst_buffer,\n    size_t src_offset,\n    size_t dst_offset,\n    size_t size,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, src_buffer, dst_buffer, src_offset, dst_offset,\n    size, num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueCopyBufferRect,\n    (cl_command_queue command_queue,\n    cl_mem src_buffer,\n    cl_mem dst_buffer,\n    const size_t * src_origin,\n    const size_t * dst_origin,\n    const size_t * region,\n    size_t src_row_pitch,\n    size_t src_slice_pitch,\n    size_t dst_row_pitch,\n    size_t dst_slice_pitch,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, src_buffer, dst_buffer, src_origin, dst_origin,\n    region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch,\n    num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC_P(void*, clEnqueueMapBuffer,\n    (cl_command_queue command_queue,\n    cl_mem buffer,\n    cl_bool blocking_map,\n    cl_map_flags map_flags,\n    size_t offset,\n    size_t size,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event,\n    cl_int * errcode_ret),\n    (command_queue, buffer, blocking_map, map_flags, offset, size,\n    num_events_in_wait_list, event_wait_list, event, errcode_ret))\n\nOCL_FUNC(cl_int, clEnqueueUnmapMemObject,\n    (cl_command_queue command_queue,\n    cl_mem memobj,\n    void * mapped_ptr,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueNDRangeKernel,\n    (cl_command_queue command_queue,\n    cl_kernel kernel,\n    cl_uint work_dim,\n    const size_t * global_work_offset,\n    const size_t * global_work_size,\n    const size_t * local_work_size,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, kernel, work_dim, global_work_offset, global_work_size,\n    local_work_size, num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clEnqueueTask,\n    (cl_command_queue command_queue,\n    cl_kernel kernel,\n    cl_uint num_events_in_wait_list,\n    const cl_event * event_wait_list,\n    cl_event * event),\n    (command_queue, kernel, num_events_in_wait_list, event_wait_list, event))\n\nOCL_FUNC(cl_int, clSetEventCallback,\n    (cl_event event,\n    cl_int command_exec_callback_type ,\n    void (CL_CALLBACK  *pfn_event_notify) (cl_event event, cl_int event_command_exec_status, void *user_data),\n    void *user_data),\n    (event, command_exec_callback_type, pfn_event_notify, user_data))\n\nOCL_FUNC(cl_int, clReleaseEvent, (cl_event event), (event))\n\n}\n\n#endif\n\n#ifndef CL_VERSION_1_2\n#define CL_VERSION_1_2\n#endif\n\n#endif // HAVE_OPENCL\n\n#ifdef _DEBUG\n#define CV_OclDbgAssert CV_DbgAssert\n#else\nstatic bool isRaiseError()\n{\n    static bool initialized = false;\n    static bool value = false;\n    if (!initialized)\n    {\n        value = getBoolParameter(\"OPENCV_OPENCL_RAISE_ERROR\", false);\n        initialized = true;\n    }\n    return value;\n}\n#define CV_OclDbgAssert(expr) do { if (isRaiseError()) { CV_Assert(expr); } else { (void)(expr); } } while ((void)0, 0)\n#endif\n\n#ifdef HAVE_OPENCL_SVM\n#include \"opencv2/core/opencl/runtime/opencl_svm_20.hpp\"\n#include \"opencv2/core/opencl/runtime/opencl_svm_hsa_extension.hpp\"\n#include \"opencv2/core/opencl/opencl_svm.hpp\"\n#endif\n\nnamespace cv { namespace ocl {\n\nstruct UMat2D\n{\n    UMat2D(const UMat& m)\n    {\n        offset = (int)m.offset;\n        step = (int)m.step;\n        rows = m.rows;\n        cols = m.cols;\n    }\n    int offset;\n    int step;\n    int rows;\n    int cols;\n};\n\nstruct UMat3D\n{\n    UMat3D(const UMat& m)\n    {\n        offset = (int)m.offset;\n        step = (int)m.step.p[1];\n        slicestep = (int)m.step.p[0];\n        slices = (int)m.size.p[0];\n        rows = m.size.p[1];\n        cols = m.size.p[2];\n    }\n    int offset;\n    int slicestep;\n    int step;\n    int slices;\n    int rows;\n    int cols;\n};\n\n// Computes 64-bit \"cyclic redundancy check\" sum, as specified in ECMA-182\nstatic uint64 crc64( const uchar* data, size_t size, uint64 crc0=0 )\n{\n    static uint64 table[256];\n    static bool initialized = false;\n\n    if( !initialized )\n    {\n        for( int i = 0; i < 256; i++ )\n        {\n            uint64 c = i;\n            for( int j = 0; j < 8; j++ )\n                c = ((c & 1) ? CV_BIG_UINT(0xc96c5795d7870f42) : 0) ^ (c >> 1);\n            table[i] = c;\n        }\n        initialized = true;\n    }\n\n    uint64 crc = ~crc0;\n    for( size_t idx = 0; idx < size; idx++ )\n        crc = table[(uchar)crc ^ data[idx]] ^ (crc >> 8);\n\n    return ~crc;\n}\n\nstruct HashKey\n{\n    typedef uint64 part;\n    HashKey(part _a, part _b) : a(_a), b(_b) {}\n    part a, b;\n};\n\ninline bool operator == (const HashKey& h1, const HashKey& h2)\n{\n    return h1.a == h2.a && h1.b == h2.b;\n}\n\ninline bool operator < (const HashKey& h1, const HashKey& h2)\n{\n    return h1.a < h2.a || (h1.a == h2.a && h1.b < h2.b);\n}\n\n\nbool haveOpenCL()\n{\n#ifdef HAVE_OPENCL\n    static bool g_isOpenCLInitialized = false;\n    static bool g_isOpenCLAvailable = false;\n\n    if (!g_isOpenCLInitialized)\n    {\n        try\n        {\n            cl_uint n = 0;\n            g_isOpenCLAvailable = ::clGetPlatformIDs(0, NULL, &n) == CL_SUCCESS;\n        }\n        catch (...)\n        {\n            g_isOpenCLAvailable = false;\n        }\n        g_isOpenCLInitialized = true;\n    }\n    return g_isOpenCLAvailable;\n#else\n    return false;\n#endif\n}\n\nbool useOpenCL()\n{\n    CoreTLSData* data = getCoreTlsData().get();\n    if( data->useOpenCL < 0 )\n    {\n        try\n        {\n            data->useOpenCL = (int)haveOpenCL() && Device::getDefault().ptr() && Device::getDefault().available();\n        }\n        catch (...)\n        {\n            data->useOpenCL = 0;\n        }\n    }\n    return data->useOpenCL > 0;\n}\n\nvoid setUseOpenCL(bool flag)\n{\n    if( haveOpenCL() )\n    {\n        CoreTLSData* data = getCoreTlsData().get();\n        data->useOpenCL = (flag && Device::getDefault().ptr() != NULL) ? 1 : 0;\n    }\n}\n\n#ifdef HAVE_CLAMDBLAS\n\nclass AmdBlasHelper\n{\npublic:\n    static AmdBlasHelper & getInstance()\n    {\n        CV_SINGLETON_LAZY_INIT_REF(AmdBlasHelper, new AmdBlasHelper())\n    }\n\n    bool isAvailable() const\n    {\n        return g_isAmdBlasAvailable;\n    }\n\n    ~AmdBlasHelper()\n    {\n        try\n        {\n            clAmdBlasTeardown();\n        }\n        catch (...) { }\n    }\n\nprotected:\n    AmdBlasHelper()\n    {\n        if (!g_isAmdBlasInitialized)\n        {\n            AutoLock lock(getInitializationMutex());\n\n            if (!g_isAmdBlasInitialized)\n            {\n                if (haveOpenCL())\n                {\n                    try\n                    {\n                        g_isAmdBlasAvailable = clAmdBlasSetup() == clAmdBlasSuccess;\n                    }\n                    catch (...)\n                    {\n                        g_isAmdBlasAvailable = false;\n                    }\n                }\n                else\n                    g_isAmdBlasAvailable = false;\n\n                g_isAmdBlasInitialized = true;\n            }\n        }\n    }\n\nprivate:\n    static bool g_isAmdBlasInitialized;\n    static bool g_isAmdBlasAvailable;\n};\n\nbool AmdBlasHelper::g_isAmdBlasAvailable = false;\nbool AmdBlasHelper::g_isAmdBlasInitialized = false;\n\nbool haveAmdBlas()\n{\n    return AmdBlasHelper::getInstance().isAvailable();\n}\n\n#else\n\nbool haveAmdBlas()\n{\n    return false;\n}\n\n#endif\n\n#ifdef HAVE_CLAMDFFT\n\nclass AmdFftHelper\n{\npublic:\n    static AmdFftHelper & getInstance()\n    {\n        CV_SINGLETON_LAZY_INIT_REF(AmdFftHelper, new AmdFftHelper())\n    }\n\n    bool isAvailable() const\n    {\n        return g_isAmdFftAvailable;\n    }\n\n    ~AmdFftHelper()\n    {\n        try\n        {\n//            clAmdFftTeardown();\n        }\n        catch (...) { }\n    }\n\nprotected:\n    AmdFftHelper()\n    {\n        if (!g_isAmdFftInitialized)\n        {\n            AutoLock lock(getInitializationMutex());\n\n            if (!g_isAmdFftInitialized)\n            {\n                if (haveOpenCL())\n                {\n                    try\n                    {\n                        cl_uint major, minor, patch;\n                        CV_Assert(clAmdFftInitSetupData(&setupData) == CLFFT_SUCCESS);\n\n                        // it throws exception in case AmdFft binaries are not found\n                        CV_Assert(clAmdFftGetVersion(&major, &minor, &patch) == CLFFT_SUCCESS);\n                        g_isAmdFftAvailable = true;\n                    }\n                    catch (const Exception &)\n                    {\n                        g_isAmdFftAvailable = false;\n                    }\n                }\n                else\n                    g_isAmdFftAvailable = false;\n\n                g_isAmdFftInitialized = true;\n            }\n        }\n    }\n\nprivate:\n    static clAmdFftSetupData setupData;\n    static bool g_isAmdFftInitialized;\n    static bool g_isAmdFftAvailable;\n};\n\nclAmdFftSetupData AmdFftHelper::setupData;\nbool AmdFftHelper::g_isAmdFftAvailable = false;\nbool AmdFftHelper::g_isAmdFftInitialized = false;\n\nbool haveAmdFft()\n{\n    return AmdFftHelper::getInstance().isAvailable();\n}\n\n#else\n\nbool haveAmdFft()\n{\n    return false;\n}\n\n#endif\n\nbool haveSVM()\n{\n#ifdef HAVE_OPENCL_SVM\n    return true;\n#else\n    return false;\n#endif\n}\n\nvoid finish()\n{\n    Queue::getDefault().finish();\n}\n\n#define IMPLEMENT_REFCOUNTABLE() \\\n    void addref() { CV_XADD(&refcount, 1); } \\\n    void release() { if( CV_XADD(&refcount, -1) == 1 && !cv::__termination) delete this; } \\\n    int refcount\n\n/////////////////////////////////////////// Platform /////////////////////////////////////////////\n\nstruct Platform::Impl\n{\n    Impl()\n    {\n        refcount = 1;\n        handle = 0;\n        initialized = false;\n    }\n\n    ~Impl() {}\n\n    void init()\n    {\n        if( !initialized )\n        {\n            //cl_uint num_entries\n            cl_uint n = 0;\n            if( clGetPlatformIDs(1, &handle, &n) != CL_SUCCESS || n == 0 )\n                handle = 0;\n            if( handle != 0 )\n            {\n                char buf[1000];\n                size_t len = 0;\n                CV_OclDbgAssert(clGetPlatformInfo(handle, CL_PLATFORM_VENDOR, sizeof(buf), buf, &len) == CL_SUCCESS);\n                buf[len] = '\\0';\n                vendor = String(buf);\n            }\n\n            initialized = true;\n        }\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    cl_platform_id handle;\n    String vendor;\n    bool initialized;\n};\n\nPlatform::Platform()\n{\n    p = 0;\n}\n\nPlatform::~Platform()\n{\n    if(p)\n        p->release();\n}\n\nPlatform::Platform(const Platform& pl)\n{\n    p = (Impl*)pl.p;\n    if(p)\n        p->addref();\n}\n\nPlatform& Platform::operator = (const Platform& pl)\n{\n    Impl* newp = (Impl*)pl.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nvoid* Platform::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nPlatform& Platform::getDefault()\n{\n    static Platform p;\n    if( !p.p )\n    {\n        p.p = new Impl;\n        p.p->init();\n    }\n    return p;\n}\n\n/////////////////////////////////////// Device ////////////////////////////////////////////\n\n// deviceVersion has format\n//   OpenCL<space><major_version.minor_version><space><vendor-specific information>\n// by specification\n//   http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceInfo.html\n//   http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html\nstatic void parseDeviceVersion(const String &deviceVersion, int &major, int &minor)\n{\n    major = minor = 0;\n    if (10 >= deviceVersion.length())\n        return;\n    const char *pstr = deviceVersion.c_str();\n    if (0 != strncmp(pstr, \"OpenCL \", 7))\n        return;\n    size_t ppos = deviceVersion.find('.', 7);\n    if (String::npos == ppos)\n        return;\n    String temp = deviceVersion.substr(7, ppos - 7);\n    major = atoi(temp.c_str());\n    temp = deviceVersion.substr(ppos + 1);\n    minor = atoi(temp.c_str());\n}\n\nstruct Device::Impl\n{\n    Impl(void* d)\n    {\n        handle = (cl_device_id)d;\n        refcount = 1;\n\n        name_ = getStrProp(CL_DEVICE_NAME);\n        version_ = getStrProp(CL_DEVICE_VERSION);\n        doubleFPConfig_ = getProp<cl_device_fp_config, int>(CL_DEVICE_DOUBLE_FP_CONFIG);\n        hostUnifiedMemory_ = getBoolProp(CL_DEVICE_HOST_UNIFIED_MEMORY);\n        maxComputeUnits_ = getProp<cl_uint, int>(CL_DEVICE_MAX_COMPUTE_UNITS);\n        maxWorkGroupSize_ = getProp<size_t, size_t>(CL_DEVICE_MAX_WORK_GROUP_SIZE);\n        type_ = getProp<cl_device_type, int>(CL_DEVICE_TYPE);\n        driverVersion_ = getStrProp(CL_DRIVER_VERSION);\n\n        String deviceVersion_ = getStrProp(CL_DEVICE_VERSION);\n        parseDeviceVersion(deviceVersion_, deviceVersionMajor_, deviceVersionMinor_);\n\n        vendorName_ = getStrProp(CL_DEVICE_VENDOR);\n        if (vendorName_ == \"Advanced Micro Devices, Inc.\" ||\n            vendorName_ == \"AMD\")\n            vendorID_ = VENDOR_AMD;\n        else if (vendorName_ == \"Intel(R) Corporation\" || vendorName_ == \"Intel\" || strstr(name_.c_str(), \"Iris\") != 0)\n            vendorID_ = VENDOR_INTEL;\n        else if (vendorName_ == \"NVIDIA Corporation\")\n            vendorID_ = VENDOR_NVIDIA;\n        else\n            vendorID_ = UNKNOWN_VENDOR;\n    }\n\n    template<typename _TpCL, typename _TpOut>\n    _TpOut getProp(cl_device_info prop) const\n    {\n        _TpCL temp=_TpCL();\n        size_t sz = 0;\n\n        return clGetDeviceInfo(handle, prop, sizeof(temp), &temp, &sz) == CL_SUCCESS &&\n            sz == sizeof(temp) ? _TpOut(temp) : _TpOut();\n    }\n\n    bool getBoolProp(cl_device_info prop) const\n    {\n        cl_bool temp = CL_FALSE;\n        size_t sz = 0;\n\n        return clGetDeviceInfo(handle, prop, sizeof(temp), &temp, &sz) == CL_SUCCESS &&\n            sz == sizeof(temp) ? temp != 0 : false;\n    }\n\n    String getStrProp(cl_device_info prop) const\n    {\n        char buf[1024];\n        size_t sz=0;\n        return clGetDeviceInfo(handle, prop, sizeof(buf)-16, buf, &sz) == CL_SUCCESS &&\n            sz < sizeof(buf) ? String(buf) : String();\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n    cl_device_id handle;\n\n    String name_;\n    String version_;\n    int doubleFPConfig_;\n    bool hostUnifiedMemory_;\n    int maxComputeUnits_;\n    size_t maxWorkGroupSize_;\n    int type_;\n    int deviceVersionMajor_;\n    int deviceVersionMinor_;\n    String driverVersion_;\n    String vendorName_;\n    int vendorID_;\n};\n\n\nDevice::Device()\n{\n    p = 0;\n}\n\nDevice::Device(void* d)\n{\n    p = 0;\n    set(d);\n}\n\nDevice::Device(const Device& d)\n{\n    p = d.p;\n    if(p)\n        p->addref();\n}\n\nDevice& Device::operator = (const Device& d)\n{\n    Impl* newp = (Impl*)d.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nDevice::~Device()\n{\n    if(p)\n        p->release();\n}\n\nvoid Device::set(void* d)\n{\n    if(p)\n        p->release();\n    p = new Impl(d);\n}\n\nvoid* Device::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nString Device::name() const\n{ return p ? p->name_ : String(); }\n\nString Device::extensions() const\n{ return p ? p->getStrProp(CL_DEVICE_EXTENSIONS) : String(); }\n\nString Device::version() const\n{ return p ? p->version_ : String(); }\n\nString Device::vendorName() const\n{ return p ? p->vendorName_ : String(); }\n\nint Device::vendorID() const\n{ return p ? p->vendorID_ : 0; }\n\nString Device::OpenCL_C_Version() const\n{ return p ? p->getStrProp(CL_DEVICE_OPENCL_C_VERSION) : String(); }\n\nString Device::OpenCLVersion() const\n{ return p ? p->getStrProp(CL_DEVICE_EXTENSIONS) : String(); }\n\nint Device::deviceVersionMajor() const\n{ return p ? p->deviceVersionMajor_ : 0; }\n\nint Device::deviceVersionMinor() const\n{ return p ? p->deviceVersionMinor_ : 0; }\n\nString Device::driverVersion() const\n{ return p ? p->driverVersion_ : String(); }\n\nint Device::type() const\n{ return p ? p->type_ : 0; }\n\nint Device::addressBits() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_ADDRESS_BITS) : 0; }\n\nbool Device::available() const\n{ return p ? p->getBoolProp(CL_DEVICE_AVAILABLE) : false; }\n\nbool Device::compilerAvailable() const\n{ return p ? p->getBoolProp(CL_DEVICE_COMPILER_AVAILABLE) : false; }\n\nbool Device::linkerAvailable() const\n#ifdef CL_VERSION_1_2\n{ return p ? p->getBoolProp(CL_DEVICE_LINKER_AVAILABLE) : false; }\n#else\n{ CV_REQUIRE_OPENCL_1_2_ERROR; }\n#endif\n\nint Device::doubleFPConfig() const\n{ return p ? p->doubleFPConfig_ : 0; }\n\nint Device::singleFPConfig() const\n{ return p ? p->getProp<cl_device_fp_config, int>(CL_DEVICE_SINGLE_FP_CONFIG) : 0; }\n\nint Device::halfFPConfig() const\n#ifdef CL_VERSION_1_2\n{ return p ? p->getProp<cl_device_fp_config, int>(CL_DEVICE_HALF_FP_CONFIG) : 0; }\n#else\n{ CV_REQUIRE_OPENCL_1_2_ERROR; }\n#endif\n\nbool Device::endianLittle() const\n{ return p ? p->getBoolProp(CL_DEVICE_ENDIAN_LITTLE) : false; }\n\nbool Device::errorCorrectionSupport() const\n{ return p ? p->getBoolProp(CL_DEVICE_ERROR_CORRECTION_SUPPORT) : false; }\n\nint Device::executionCapabilities() const\n{ return p ? p->getProp<cl_device_exec_capabilities, int>(CL_DEVICE_EXECUTION_CAPABILITIES) : 0; }\n\nsize_t Device::globalMemCacheSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_GLOBAL_MEM_CACHE_SIZE) : 0; }\n\nint Device::globalMemCacheType() const\n{ return p ? p->getProp<cl_device_mem_cache_type, int>(CL_DEVICE_GLOBAL_MEM_CACHE_TYPE) : 0; }\n\nint Device::globalMemCacheLineSize() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE) : 0; }\n\nsize_t Device::globalMemSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_GLOBAL_MEM_SIZE) : 0; }\n\nsize_t Device::localMemSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_LOCAL_MEM_SIZE) : 0; }\n\nint Device::localMemType() const\n{ return p ? p->getProp<cl_device_local_mem_type, int>(CL_DEVICE_LOCAL_MEM_TYPE) : 0; }\n\nbool Device::hostUnifiedMemory() const\n{ return p ? p->hostUnifiedMemory_ : false; }\n\nbool Device::imageSupport() const\n{ return p ? p->getBoolProp(CL_DEVICE_IMAGE_SUPPORT) : false; }\n\nbool Device::imageFromBufferSupport() const\n{\n    bool ret = false;\n    if (p)\n    {\n        size_t pos = p->getStrProp(CL_DEVICE_EXTENSIONS).find(\"cl_khr_image2d_from_buffer\");\n        if (pos != String::npos)\n        {\n            ret = true;\n        }\n    }\n    return ret;\n}\n\nuint Device::imagePitchAlignment() const\n{\n#ifdef CL_DEVICE_IMAGE_PITCH_ALIGNMENT\n    return p ? p->getProp<cl_uint, uint>(CL_DEVICE_IMAGE_PITCH_ALIGNMENT) : 0;\n#else\n    return 0;\n#endif\n}\n\nuint Device::imageBaseAddressAlignment() const\n{\n#ifdef CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT\n    return p ? p->getProp<cl_uint, uint>(CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT) : 0;\n#else\n    return 0;\n#endif\n}\n\nsize_t Device::image2DMaxWidth() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE2D_MAX_WIDTH) : 0; }\n\nsize_t Device::image2DMaxHeight() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE2D_MAX_HEIGHT) : 0; }\n\nsize_t Device::image3DMaxWidth() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE3D_MAX_WIDTH) : 0; }\n\nsize_t Device::image3DMaxHeight() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE3D_MAX_HEIGHT) : 0; }\n\nsize_t Device::image3DMaxDepth() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE3D_MAX_DEPTH) : 0; }\n\nsize_t Device::imageMaxBufferSize() const\n#ifdef CL_VERSION_1_2\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE_MAX_BUFFER_SIZE) : 0; }\n#else\n{ CV_REQUIRE_OPENCL_1_2_ERROR; }\n#endif\n\nsize_t Device::imageMaxArraySize() const\n#ifdef CL_VERSION_1_2\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_IMAGE_MAX_ARRAY_SIZE) : 0; }\n#else\n{ CV_REQUIRE_OPENCL_1_2_ERROR; }\n#endif\n\nint Device::maxClockFrequency() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_CLOCK_FREQUENCY) : 0; }\n\nint Device::maxComputeUnits() const\n{ return p ? p->maxComputeUnits_ : 0; }\n\nint Device::maxConstantArgs() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_CONSTANT_ARGS) : 0; }\n\nsize_t Device::maxConstantBufferSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE) : 0; }\n\nsize_t Device::maxMemAllocSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_MAX_MEM_ALLOC_SIZE) : 0; }\n\nsize_t Device::maxParameterSize() const\n{ return p ? p->getProp<cl_ulong, size_t>(CL_DEVICE_MAX_PARAMETER_SIZE) : 0; }\n\nint Device::maxReadImageArgs() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_READ_IMAGE_ARGS) : 0; }\n\nint Device::maxWriteImageArgs() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_WRITE_IMAGE_ARGS) : 0; }\n\nint Device::maxSamplers() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_SAMPLERS) : 0; }\n\nsize_t Device::maxWorkGroupSize() const\n{ return p ? p->maxWorkGroupSize_ : 0; }\n\nint Device::maxWorkItemDims() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS) : 0; }\n\nvoid Device::maxWorkItemSizes(size_t* sizes) const\n{\n    if(p)\n    {\n        const int MAX_DIMS = 32;\n        size_t retsz = 0;\n        CV_OclDbgAssert(clGetDeviceInfo(p->handle, CL_DEVICE_MAX_WORK_ITEM_SIZES,\n                MAX_DIMS*sizeof(sizes[0]), &sizes[0], &retsz) == CL_SUCCESS);\n    }\n}\n\nint Device::memBaseAddrAlign() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_MEM_BASE_ADDR_ALIGN) : 0; }\n\nint Device::nativeVectorWidthChar() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR) : 0; }\n\nint Device::nativeVectorWidthShort() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT) : 0; }\n\nint Device::nativeVectorWidthInt() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_INT) : 0; }\n\nint Device::nativeVectorWidthLong() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG) : 0; }\n\nint Device::nativeVectorWidthFloat() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT) : 0; }\n\nint Device::nativeVectorWidthDouble() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE) : 0; }\n\nint Device::nativeVectorWidthHalf() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF) : 0; }\n\nint Device::preferredVectorWidthChar() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR) : 0; }\n\nint Device::preferredVectorWidthShort() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT) : 0; }\n\nint Device::preferredVectorWidthInt() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT) : 0; }\n\nint Device::preferredVectorWidthLong() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG) : 0; }\n\nint Device::preferredVectorWidthFloat() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT) : 0; }\n\nint Device::preferredVectorWidthDouble() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE) : 0; }\n\nint Device::preferredVectorWidthHalf() const\n{ return p ? p->getProp<cl_uint, int>(CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF) : 0; }\n\nsize_t Device::printfBufferSize() const\n#ifdef CL_VERSION_1_2\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_PRINTF_BUFFER_SIZE) : 0; }\n#else\n{ CV_REQUIRE_OPENCL_1_2_ERROR; }\n#endif\n\n\nsize_t Device::profilingTimerResolution() const\n{ return p ? p->getProp<size_t, size_t>(CL_DEVICE_PROFILING_TIMER_RESOLUTION) : 0; }\n\nconst Device& Device::getDefault()\n{\n    const Context& ctx = Context::getDefault();\n    int idx = getCoreTlsData().get()->device;\n    const Device& device = ctx.device(idx);\n    return device;\n}\n\n////////////////////////////////////// Context ///////////////////////////////////////////////////\n\ntemplate <typename Functor, typename ObjectType>\ninline cl_int getStringInfo(Functor f, ObjectType obj, cl_uint name, std::string& param)\n{\n    ::size_t required;\n    cl_int err = f(obj, name, 0, NULL, &required);\n    if (err != CL_SUCCESS)\n        return err;\n\n    param.clear();\n    if (required > 0)\n    {\n        AutoBuffer<char> buf(required + 1);\n        char* ptr = (char*)buf; // cleanup is not needed\n        err = f(obj, name, required, ptr, NULL);\n        if (err != CL_SUCCESS)\n            return err;\n        param = ptr;\n    }\n\n    return CL_SUCCESS;\n}\n\nstatic void split(const std::string &s, char delim, std::vector<std::string> &elems)\n{\n    elems.clear();\n    if (s.size() == 0)\n        return;\n    std::istringstream ss(s);\n    std::string item;\n    while (!ss.eof())\n    {\n        std::getline(ss, item, delim);\n        elems.push_back(item);\n    }\n}\n\n// Layout: <Platform>:<CPU|GPU|ACCELERATOR|nothing=GPU/CPU>:<deviceName>\n// Sample: AMD:GPU:\n// Sample: AMD:GPU:Tahiti\n// Sample: :GPU|CPU: = '' = ':' = '::'\nstatic bool parseOpenCLDeviceConfiguration(const std::string& configurationStr,\n        std::string& platform, std::vector<std::string>& deviceTypes, std::string& deviceNameOrID)\n{\n    std::vector<std::string> parts;\n    split(configurationStr, ':', parts);\n    if (parts.size() > 3)\n    {\n        std::cerr << \"ERROR: Invalid configuration string for OpenCL device\" << std::endl;\n        return false;\n    }\n    if (parts.size() > 2)\n        deviceNameOrID = parts[2];\n    if (parts.size() > 1)\n    {\n        split(parts[1], '|', deviceTypes);\n    }\n    if (parts.size() > 0)\n    {\n        platform = parts[0];\n    }\n    return true;\n}\n\n#ifdef WINRT\nstatic cl_device_id selectOpenCLDevice()\n{\n    return NULL;\n}\n#else\nstatic cl_device_id selectOpenCLDevice()\n{\n    std::string platform, deviceName;\n    std::vector<std::string> deviceTypes;\n\n    const char* configuration = getenv(\"OPENCV_OPENCL_DEVICE\");\n    if (configuration &&\n            (strcmp(configuration, \"disabled\") == 0 ||\n             !parseOpenCLDeviceConfiguration(std::string(configuration), platform, deviceTypes, deviceName)\n            ))\n        return NULL;\n\n    bool isID = false;\n    int deviceID = -1;\n    if (deviceName.length() == 1)\n    // We limit ID range to 0..9, because we want to write:\n    // - '2500' to mean i5-2500\n    // - '8350' to mean AMD FX-8350\n    // - '650' to mean GeForce 650\n    // To extend ID range change condition to '> 0'\n    {\n        isID = true;\n        for (size_t i = 0; i < deviceName.length(); i++)\n        {\n            if (!isdigit(deviceName[i]))\n            {\n                isID = false;\n                break;\n            }\n        }\n        if (isID)\n        {\n            deviceID = atoi(deviceName.c_str());\n            if (deviceID < 0)\n                return NULL;\n        }\n    }\n\n    std::vector<cl_platform_id> platforms;\n    {\n        cl_uint numPlatforms = 0;\n        CV_OclDbgAssert(clGetPlatformIDs(0, NULL, &numPlatforms) == CL_SUCCESS);\n\n        if (numPlatforms == 0)\n            return NULL;\n        platforms.resize((size_t)numPlatforms);\n        CV_OclDbgAssert(clGetPlatformIDs(numPlatforms, &platforms[0], &numPlatforms) == CL_SUCCESS);\n        platforms.resize(numPlatforms);\n    }\n\n    int selectedPlatform = -1;\n    if (platform.length() > 0)\n    {\n        for (size_t i = 0; i < platforms.size(); i++)\n        {\n            std::string name;\n            CV_OclDbgAssert(getStringInfo(clGetPlatformInfo, platforms[i], CL_PLATFORM_NAME, name) == CL_SUCCESS);\n            if (name.find(platform) != std::string::npos)\n            {\n                selectedPlatform = (int)i;\n                break;\n            }\n        }\n        if (selectedPlatform == -1)\n        {\n            std::cerr << \"ERROR: Can't find OpenCL platform by name: \" << platform << std::endl;\n            goto not_found;\n        }\n    }\n    if (deviceTypes.size() == 0)\n    {\n        if (!isID)\n        {\n            deviceTypes.push_back(\"GPU\");\n            if (configuration)\n                deviceTypes.push_back(\"CPU\");\n        }\n        else\n            deviceTypes.push_back(\"ALL\");\n    }\n    for (size_t t = 0; t < deviceTypes.size(); t++)\n    {\n        int deviceType = 0;\n        std::string tempStrDeviceType = deviceTypes[t];\n        std::transform( tempStrDeviceType.begin(), tempStrDeviceType.end(), tempStrDeviceType.begin(), tolower );\n\n        if (tempStrDeviceType == \"gpu\" || tempStrDeviceType == \"dgpu\" || tempStrDeviceType == \"igpu\")\n            deviceType = Device::TYPE_GPU;\n        else if (tempStrDeviceType == \"cpu\")\n            deviceType = Device::TYPE_CPU;\n        else if (tempStrDeviceType == \"accelerator\")\n            deviceType = Device::TYPE_ACCELERATOR;\n        else if (tempStrDeviceType == \"all\")\n            deviceType = Device::TYPE_ALL;\n        else\n        {\n            std::cerr << \"ERROR: Unsupported device type for OpenCL device (GPU, CPU, ACCELERATOR): \" << deviceTypes[t] << std::endl;\n            goto not_found;\n        }\n\n        std::vector<cl_device_id> devices; // TODO Use clReleaseDevice to cleanup\n        for (int i = selectedPlatform >= 0 ? selectedPlatform : 0;\n                (selectedPlatform >= 0 ? i == selectedPlatform : true) && (i < (int)platforms.size());\n                i++)\n        {\n            cl_uint count = 0;\n            cl_int status = clGetDeviceIDs(platforms[i], deviceType, 0, NULL, &count);\n            CV_OclDbgAssert(status == CL_SUCCESS || status == CL_DEVICE_NOT_FOUND);\n            if (count == 0)\n                continue;\n            size_t base = devices.size();\n            devices.resize(base + count);\n            status = clGetDeviceIDs(platforms[i], deviceType, count, &devices[base], &count);\n            CV_OclDbgAssert(status == CL_SUCCESS || status == CL_DEVICE_NOT_FOUND);\n        }\n\n        for (size_t i = (isID ? deviceID : 0);\n             (isID ? (i == (size_t)deviceID) : true) && (i < devices.size());\n             i++)\n        {\n            std::string name;\n            CV_OclDbgAssert(getStringInfo(clGetDeviceInfo, devices[i], CL_DEVICE_NAME, name) == CL_SUCCESS);\n            cl_bool useGPU = true;\n            if(tempStrDeviceType == \"dgpu\" || tempStrDeviceType == \"igpu\")\n            {\n                cl_bool isIGPU = CL_FALSE;\n                clGetDeviceInfo(devices[i], CL_DEVICE_HOST_UNIFIED_MEMORY, sizeof(isIGPU), &isIGPU, NULL);\n                useGPU = tempStrDeviceType == \"dgpu\" ? !isIGPU : isIGPU;\n            }\n            if ( (isID || name.find(deviceName) != std::string::npos) && useGPU)\n            {\n                // TODO check for OpenCL 1.1\n                return devices[i];\n            }\n        }\n    }\n\nnot_found:\n    if (!configuration)\n        return NULL; // suppress messages on stderr\n\n    std::cerr << \"ERROR: Requested OpenCL device not found, check configuration: \" << (configuration == NULL ? \"\" : configuration) << std::endl\n            << \"    Platform: \" << (platform.length() == 0 ? \"any\" : platform) << std::endl\n            << \"    Device types: \";\n    for (size_t t = 0; t < deviceTypes.size(); t++)\n        std::cerr << deviceTypes[t] << \" \";\n\n    std::cerr << std::endl << \"    Device name: \" << (deviceName.length() == 0 ? \"any\" : deviceName) << std::endl;\n    return NULL;\n}\n#endif\n\n#ifdef HAVE_OPENCL_SVM\nnamespace svm {\n\nenum AllocatorFlags { // don't use first 16 bits\n        OPENCL_SVM_COARSE_GRAIN_BUFFER = 1 << 16, // clSVMAlloc + SVM map/unmap\n        OPENCL_SVM_FINE_GRAIN_BUFFER = 2 << 16, // clSVMAlloc\n        OPENCL_SVM_FINE_GRAIN_SYSTEM = 3 << 16, // direct access\n        OPENCL_SVM_BUFFER_MASK = 3 << 16,\n        OPENCL_SVM_BUFFER_MAP = 4 << 16\n};\n\nstatic bool checkForceSVMUmatUsage()\n{\n    static bool initialized = false;\n    static bool force = false;\n    if (!initialized)\n    {\n        force = getBoolParameter(\"OPENCV_OPENCL_SVM_FORCE_UMAT_USAGE\", false);\n        initialized = true;\n    }\n    return force;\n}\nstatic bool checkDisableSVMUMatUsage()\n{\n    static bool initialized = false;\n    static bool force = false;\n    if (!initialized)\n    {\n        force = getBoolParameter(\"OPENCV_OPENCL_SVM_DISABLE_UMAT_USAGE\", false);\n        initialized = true;\n    }\n    return force;\n}\nstatic bool checkDisableSVM()\n{\n    static bool initialized = false;\n    static bool force = false;\n    if (!initialized)\n    {\n        force = getBoolParameter(\"OPENCV_OPENCL_SVM_DISABLE\", false);\n        initialized = true;\n    }\n    return force;\n}\n// see SVMCapabilities\nstatic unsigned int getSVMCapabilitiesMask()\n{\n    static bool initialized = false;\n    static unsigned int mask = 0;\n    if (!initialized)\n    {\n        const char* envValue = getenv(\"OPENCV_OPENCL_SVM_CAPABILITIES_MASK\");\n        if (envValue == NULL)\n        {\n            return ~0U; // all bits 1\n        }\n        mask = atoi(envValue);\n        initialized = true;\n    }\n    return mask;\n}\n} // namespace\n#endif\n\nstruct Context::Impl\n{\n    static Context::Impl* get(Context& context) { return context.p; }\n\n    void __init()\n    {\n        refcount = 1;\n        handle = 0;\n#ifdef HAVE_OPENCL_SVM\n        svmInitialized = false;\n#endif\n    }\n\n    Impl()\n    {\n        __init();\n    }\n\n    void setDefault()\n    {\n        CV_Assert(handle == NULL);\n\n        cl_device_id d = selectOpenCLDevice();\n\n        if (d == NULL)\n            return;\n\n        cl_platform_id pl = NULL;\n        CV_OclDbgAssert(clGetDeviceInfo(d, CL_DEVICE_PLATFORM, sizeof(cl_platform_id), &pl, NULL) == CL_SUCCESS);\n\n        cl_context_properties prop[] =\n        {\n            CL_CONTEXT_PLATFORM, (cl_context_properties)pl,\n            0\n        };\n\n        // !!! in the current implementation force the number of devices to 1 !!!\n        cl_uint nd = 1;\n        cl_int status;\n\n        handle = clCreateContext(prop, nd, &d, 0, 0, &status);\n\n        bool ok = handle != 0 && status == CL_SUCCESS;\n        if( ok )\n        {\n            devices.resize(nd);\n            devices[0].set(d);\n        }\n        else\n            handle = NULL;\n    }\n\n    Impl(int dtype0)\n    {\n        __init();\n\n        cl_int retval = 0;\n        cl_platform_id pl = (cl_platform_id)Platform::getDefault().ptr();\n        cl_context_properties prop[] =\n        {\n            CL_CONTEXT_PLATFORM, (cl_context_properties)pl,\n            0\n        };\n\n        cl_uint i, nd0 = 0, nd = 0;\n        int dtype = dtype0 & 15;\n        CV_OclDbgAssert(clGetDeviceIDs( pl, dtype, 0, 0, &nd0 ) == CL_SUCCESS);\n\n        AutoBuffer<void*> dlistbuf(nd0*2+1);\n        cl_device_id* dlist = (cl_device_id*)(void**)dlistbuf;\n        cl_device_id* dlist_new = dlist + nd0;\n        CV_OclDbgAssert(clGetDeviceIDs( pl, dtype, nd0, dlist, &nd0 ) == CL_SUCCESS);\n        String name0;\n\n        for(i = 0; i < nd0; i++)\n        {\n            Device d(dlist[i]);\n            if( !d.available() || !d.compilerAvailable() )\n                continue;\n            if( dtype0 == Device::TYPE_DGPU && d.hostUnifiedMemory() )\n                continue;\n            if( dtype0 == Device::TYPE_IGPU && !d.hostUnifiedMemory() )\n                continue;\n            String name = d.name();\n            if( nd != 0 && name != name0 )\n                continue;\n            name0 = name;\n            dlist_new[nd++] = dlist[i];\n        }\n\n        if(nd == 0)\n            return;\n\n        // !!! in the current implementation force the number of devices to 1 !!!\n        nd = 1;\n\n        handle = clCreateContext(prop, nd, dlist_new, 0, 0, &retval);\n        bool ok = handle != 0 && retval == CL_SUCCESS;\n        if( ok )\n        {\n            devices.resize(nd);\n            for( i = 0; i < nd; i++ )\n                devices[i].set(dlist_new[i]);\n        }\n    }\n\n    ~Impl()\n    {\n        if(handle)\n        {\n            clReleaseContext(handle);\n            handle = NULL;\n        }\n        devices.clear();\n    }\n\n    Program getProg(const ProgramSource& src,\n                    const String& buildflags, String& errmsg)\n    {\n        String prefix = Program::getPrefix(buildflags);\n        HashKey k(src.hash(), crc64((const uchar*)prefix.c_str(), prefix.size()));\n        phash_t::iterator it = phash.find(k);\n        if( it != phash.end() )\n            return it->second;\n        //String filename = format(\"%08x%08x_%08x%08x.clb2\",\n        Program prog(src, buildflags, errmsg);\n        if(prog.ptr())\n            phash.insert(std::pair<HashKey,Program>(k, prog));\n        return prog;\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    cl_context handle;\n    std::vector<Device> devices;\n\n    typedef ProgramSource::hash_t hash_t;\n\n    struct HashKey\n    {\n        HashKey(hash_t _a, hash_t _b) : a(_a), b(_b) {}\n        bool operator < (const HashKey& k) const { return a < k.a || (a == k.a && b < k.b); }\n        bool operator == (const HashKey& k) const { return a == k.a && b == k.b; }\n        bool operator != (const HashKey& k) const { return a != k.a || b != k.b; }\n        hash_t a, b;\n    };\n    typedef std::map<HashKey, Program> phash_t;\n    phash_t phash;\n\n#ifdef HAVE_OPENCL_SVM\n    bool svmInitialized;\n    bool svmAvailable;\n    bool svmEnabled;\n    svm::SVMCapabilities svmCapabilities;\n    svm::SVMFunctions svmFunctions;\n\n    void svmInit()\n    {\n        CV_Assert(handle != NULL);\n        const Device& device = devices[0];\n        cl_device_svm_capabilities deviceCaps = 0;\n        CV_Assert(((void)0, CL_DEVICE_SVM_CAPABILITIES == CL_DEVICE_SVM_CAPABILITIES_AMD)); // Check assumption\n        cl_int status = clGetDeviceInfo((cl_device_id)device.ptr(), CL_DEVICE_SVM_CAPABILITIES, sizeof(deviceCaps), &deviceCaps, NULL);\n        if (status != CL_SUCCESS)\n        {\n            CV_OPENCL_SVM_TRACE_ERROR_P(\"CL_DEVICE_SVM_CAPABILITIES via clGetDeviceInfo failed: %d\\n\", status);\n            goto noSVM;\n        }\n        CV_OPENCL_SVM_TRACE_P(\"CL_DEVICE_SVM_CAPABILITIES returned: 0x%x\\n\", (int)deviceCaps);\n        CV_Assert(((void)0, CL_DEVICE_SVM_COARSE_GRAIN_BUFFER == CL_DEVICE_SVM_COARSE_GRAIN_BUFFER_AMD)); // Check assumption\n        svmCapabilities.value_ =\n                ((deviceCaps & CL_DEVICE_SVM_COARSE_GRAIN_BUFFER) ? svm::SVMCapabilities::SVM_COARSE_GRAIN_BUFFER : 0) |\n                ((deviceCaps & CL_DEVICE_SVM_FINE_GRAIN_BUFFER) ? svm::SVMCapabilities::SVM_FINE_GRAIN_BUFFER : 0) |\n                ((deviceCaps & CL_DEVICE_SVM_FINE_GRAIN_SYSTEM) ? svm::SVMCapabilities::SVM_FINE_GRAIN_SYSTEM : 0) |\n                ((deviceCaps & CL_DEVICE_SVM_ATOMICS) ? svm::SVMCapabilities::SVM_ATOMICS : 0);\n        svmCapabilities.value_ &= svm::getSVMCapabilitiesMask();\n        if (svmCapabilities.value_ == 0)\n        {\n            CV_OPENCL_SVM_TRACE_ERROR_P(\"svmCapabilities is empty\\n\");\n            goto noSVM;\n        }\n        try\n        {\n            // Try OpenCL 2.0\n            CV_OPENCL_SVM_TRACE_P(\"Try SVM from OpenCL 2.0 ...\\n\");\n            void* ptr = clSVMAlloc(handle, CL_MEM_READ_WRITE, 100, 0);\n            if (!ptr)\n            {\n                CV_OPENCL_SVM_TRACE_ERROR_P(\"clSVMAlloc returned NULL...\\n\");\n                CV_ErrorNoReturn(Error::StsBadArg, \"clSVMAlloc returned NULL\");\n            }\n            try\n            {\n                bool error = false;\n                cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n                if (CL_SUCCESS != clEnqueueSVMMap(q, CL_TRUE, CL_MAP_WRITE, ptr, 100, 0, NULL, NULL))\n                {\n                    CV_OPENCL_SVM_TRACE_ERROR_P(\"clEnqueueSVMMap failed...\\n\");\n                    CV_ErrorNoReturn(Error::StsBadArg, \"clEnqueueSVMMap FAILED\");\n                }\n                clFinish(q);\n                try\n                {\n                    ((int*)ptr)[0] = 100;\n                }\n                catch (...)\n                {\n                    CV_OPENCL_SVM_TRACE_ERROR_P(\"SVM buffer access test FAILED\\n\");\n                    error = true;\n                }\n                if (CL_SUCCESS != clEnqueueSVMUnmap(q, ptr, 0, NULL, NULL))\n                {\n                    CV_OPENCL_SVM_TRACE_ERROR_P(\"clEnqueueSVMUnmap failed...\\n\");\n                    CV_ErrorNoReturn(Error::StsBadArg, \"clEnqueueSVMUnmap FAILED\");\n                }\n                clFinish(q);\n                if (error)\n                {\n                    CV_ErrorNoReturn(Error::StsBadArg, \"OpenCL SVM buffer access test was FAILED\");\n                }\n            }\n            catch (...)\n            {\n                CV_OPENCL_SVM_TRACE_ERROR_P(\"OpenCL SVM buffer access test was FAILED\\n\");\n                clSVMFree(handle, ptr);\n                throw;\n            }\n            clSVMFree(handle, ptr);\n            svmFunctions.fn_clSVMAlloc = clSVMAlloc;\n            svmFunctions.fn_clSVMFree = clSVMFree;\n            svmFunctions.fn_clSetKernelArgSVMPointer = clSetKernelArgSVMPointer;\n            //svmFunctions.fn_clSetKernelExecInfo = clSetKernelExecInfo;\n            //svmFunctions.fn_clEnqueueSVMFree = clEnqueueSVMFree;\n            svmFunctions.fn_clEnqueueSVMMemcpy = clEnqueueSVMMemcpy;\n            svmFunctions.fn_clEnqueueSVMMemFill = clEnqueueSVMMemFill;\n            svmFunctions.fn_clEnqueueSVMMap = clEnqueueSVMMap;\n            svmFunctions.fn_clEnqueueSVMUnmap = clEnqueueSVMUnmap;\n        }\n        catch (...)\n        {\n            CV_OPENCL_SVM_TRACE_P(\"clSVMAlloc failed, trying HSA extension...\\n\");\n            try\n            {\n                // Try HSA extension\n                String extensions = device.extensions();\n                if (extensions.find(\"cl_amd_svm\") == String::npos)\n                {\n                    CV_OPENCL_SVM_TRACE_P(\"Device extension doesn't have cl_amd_svm: %s\\n\", extensions.c_str());\n                    goto noSVM;\n                }\n                cl_platform_id p = NULL;\n                status = clGetDeviceInfo((cl_device_id)device.ptr(), CL_DEVICE_PLATFORM, sizeof(cl_platform_id), &p, NULL);\n                CV_Assert(status == CL_SUCCESS);\n                svmFunctions.fn_clSVMAlloc = (clSVMAllocAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clSVMAllocAMD\");\n                svmFunctions.fn_clSVMFree = (clSVMFreeAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clSVMFreeAMD\");\n                svmFunctions.fn_clSetKernelArgSVMPointer = (clSetKernelArgSVMPointerAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clSetKernelArgSVMPointerAMD\");\n                //svmFunctions.fn_clSetKernelExecInfo = (clSetKernelExecInfoAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clSetKernelExecInfoAMD\");\n                //svmFunctions.fn_clEnqueueSVMFree = (clEnqueueSVMFreeAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clEnqueueSVMFreeAMD\");\n                svmFunctions.fn_clEnqueueSVMMemcpy = (clEnqueueSVMMemcpyAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clEnqueueSVMMemcpyAMD\");\n                svmFunctions.fn_clEnqueueSVMMemFill = (clEnqueueSVMMemFillAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clEnqueueSVMMemFillAMD\");\n                svmFunctions.fn_clEnqueueSVMMap = (clEnqueueSVMMapAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clEnqueueSVMMapAMD\");\n                svmFunctions.fn_clEnqueueSVMUnmap = (clEnqueueSVMUnmapAMD_fn)clGetExtensionFunctionAddressForPlatform(p, \"clEnqueueSVMUnmapAMD\");\n                CV_Assert(svmFunctions.isValid());\n            }\n            catch (...)\n            {\n                CV_OPENCL_SVM_TRACE_P(\"Something is totally wrong\\n\");\n                goto noSVM;\n            }\n        }\n\n        svmAvailable = true;\n        svmEnabled = !svm::checkDisableSVM();\n        svmInitialized = true;\n        CV_OPENCL_SVM_TRACE_P(\"OpenCV OpenCL SVM support initialized\\n\");\n        return;\n    noSVM:\n        CV_OPENCL_SVM_TRACE_P(\"OpenCL SVM is not detected\\n\");\n        svmAvailable = false;\n        svmEnabled = false;\n        svmCapabilities.value_ = 0;\n        svmInitialized = true;\n        svmFunctions.fn_clSVMAlloc = NULL;\n        return;\n    }\n#endif\n};\n\n\nContext::Context()\n{\n    p = 0;\n}\n\nContext::Context(int dtype)\n{\n    p = 0;\n    create(dtype);\n}\n\nbool Context::create()\n{\n    if( !haveOpenCL() )\n        return false;\n    if(p)\n        p->release();\n    p = new Impl();\n    if(!p->handle)\n    {\n        delete p;\n        p = 0;\n    }\n    return p != 0;\n}\n\nbool Context::create(int dtype0)\n{\n    if( !haveOpenCL() )\n        return false;\n    if(p)\n        p->release();\n    p = new Impl(dtype0);\n    if(!p->handle)\n    {\n        delete p;\n        p = 0;\n    }\n    return p != 0;\n}\n\nContext::~Context()\n{\n    if (p)\n    {\n        p->release();\n        p = NULL;\n    }\n}\n\nContext::Context(const Context& c)\n{\n    p = (Impl*)c.p;\n    if(p)\n        p->addref();\n}\n\nContext& Context::operator = (const Context& c)\n{\n    Impl* newp = (Impl*)c.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nvoid* Context::ptr() const\n{\n    return p == NULL ? NULL : p->handle;\n}\n\nsize_t Context::ndevices() const\n{\n    return p ? p->devices.size() : 0;\n}\n\nconst Device& Context::device(size_t idx) const\n{\n    static Device dummy;\n    return !p || idx >= p->devices.size() ? dummy : p->devices[idx];\n}\n\nContext& Context::getDefault(bool initialize)\n{\n    static Context* ctx = new Context();\n    if(!ctx->p && haveOpenCL())\n    {\n        if (!ctx->p)\n            ctx->p = new Impl();\n        if (initialize)\n        {\n            // do not create new Context right away.\n            // First, try to retrieve existing context of the same type.\n            // In its turn, Platform::getContext() may call Context::create()\n            // if there is no such context.\n            if (ctx->p->handle == NULL)\n                ctx->p->setDefault();\n        }\n    }\n\n    return *ctx;\n}\n\nProgram Context::getProg(const ProgramSource& prog,\n                         const String& buildopts, String& errmsg)\n{\n    return p ? p->getProg(prog, buildopts, errmsg) : Program();\n}\n\n\n\n#ifdef HAVE_OPENCL_SVM\nbool Context::useSVM() const\n{\n    Context::Impl* i = p;\n    CV_Assert(i);\n    if (!i->svmInitialized)\n        i->svmInit();\n    return i->svmEnabled;\n}\nvoid Context::setUseSVM(bool enabled)\n{\n    Context::Impl* i = p;\n    CV_Assert(i);\n    if (!i->svmInitialized)\n        i->svmInit();\n    if (enabled && !i->svmAvailable)\n    {\n        CV_ErrorNoReturn(Error::StsError, \"OpenCL Shared Virtual Memory (SVM) is not supported by OpenCL device\");\n    }\n    i->svmEnabled = enabled;\n}\n#else\nbool Context::useSVM() const { return false; }\nvoid Context::setUseSVM(bool enabled) { CV_Assert(!enabled); }\n#endif\n\n#ifdef HAVE_OPENCL_SVM\nnamespace svm {\n\nconst SVMCapabilities getSVMCapabilitites(const ocl::Context& context)\n{\n    Context::Impl* i = context.p;\n    CV_Assert(i);\n    if (!i->svmInitialized)\n        i->svmInit();\n    return i->svmCapabilities;\n}\n\nCV_EXPORTS const SVMFunctions* getSVMFunctions(const ocl::Context& context)\n{\n    Context::Impl* i = context.p;\n    CV_Assert(i);\n    CV_Assert(i->svmInitialized); // getSVMCapabilitites() must be called first\n    CV_Assert(i->svmFunctions.fn_clSVMAlloc != NULL);\n    return &i->svmFunctions;\n}\n\nCV_EXPORTS bool useSVM(UMatUsageFlags usageFlags)\n{\n    if (checkForceSVMUmatUsage())\n        return true;\n    if (checkDisableSVMUMatUsage())\n        return false;\n    if ((usageFlags & USAGE_ALLOCATE_SHARED_MEMORY) != 0)\n        return true;\n    return false; // don't use SVM by default\n}\n\n} // namespace cv::ocl::svm\n#endif // HAVE_OPENCL_SVM\n\n\nstatic void get_platform_name(cl_platform_id id, String& name)\n{\n    // get platform name string length\n    size_t sz = 0;\n    if (CL_SUCCESS != clGetPlatformInfo(id, CL_PLATFORM_NAME, 0, 0, &sz))\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"clGetPlatformInfo failed!\");\n\n    // get platform name string\n    AutoBuffer<char> buf(sz + 1);\n    if (CL_SUCCESS != clGetPlatformInfo(id, CL_PLATFORM_NAME, sz, buf, 0))\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"clGetPlatformInfo failed!\");\n\n    // just in case, ensure trailing zero for ASCIIZ string\n    buf[sz] = 0;\n\n    name = (const char*)buf;\n}\n\n/*\n// Attaches OpenCL context to OpenCV\n*/\nvoid attachContext(const String& platformName, void* platformID, void* context, void* deviceID)\n{\n    cl_uint cnt = 0;\n\n    if(CL_SUCCESS != clGetPlatformIDs(0, 0, &cnt))\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"clGetPlatformIDs failed!\");\n\n    if (cnt == 0)\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"no OpenCL platform available!\");\n\n    std::vector<cl_platform_id> platforms(cnt);\n\n    if(CL_SUCCESS != clGetPlatformIDs(cnt, &platforms[0], 0))\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"clGetPlatformIDs failed!\");\n\n    bool platformAvailable = false;\n\n    // check if external platformName contained in list of available platforms in OpenCV\n    for (unsigned int i = 0; i < cnt; i++)\n    {\n        String availablePlatformName;\n        get_platform_name(platforms[i], availablePlatformName);\n        // external platform is found in the list of available platforms\n        if (platformName == availablePlatformName)\n        {\n            platformAvailable = true;\n            break;\n        }\n    }\n\n    if (!platformAvailable)\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"No matched platforms available!\");\n\n    // check if platformID corresponds to platformName\n    String actualPlatformName;\n    get_platform_name((cl_platform_id)platformID, actualPlatformName);\n    if (platformName != actualPlatformName)\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"No matched platforms available!\");\n\n    // do not initialize OpenCL context\n    Context ctx = Context::getDefault(false);\n\n    // attach supplied context to OpenCV\n    initializeContextFromHandle(ctx, platformID, context, deviceID);\n\n    if(CL_SUCCESS != clRetainContext((cl_context)context))\n        CV_ErrorNoReturn(cv::Error::OpenCLApiCallError, \"clRetainContext failed!\");\n\n    // clear command queue, if any\n    getCoreTlsData().get()->oclQueue.finish();\n    Queue q;\n    getCoreTlsData().get()->oclQueue = q;\n\n    return;\n} // attachContext()\n\n\nvoid initializeContextFromHandle(Context& ctx, void* platform, void* _context, void* _device)\n{\n    cl_context context = (cl_context)_context;\n    cl_device_id device = (cl_device_id)_device;\n\n    // cleanup old context\n    Context::Impl * impl = ctx.p;\n    if (impl->handle)\n    {\n        CV_OclDbgAssert(clReleaseContext(impl->handle) == CL_SUCCESS);\n    }\n    impl->devices.clear();\n\n    impl->handle = context;\n    impl->devices.resize(1);\n    impl->devices[0].set(device);\n\n    Platform& p = Platform::getDefault();\n    Platform::Impl* pImpl = p.p;\n    pImpl->handle = (cl_platform_id)platform;\n}\n\n/////////////////////////////////////////// Queue /////////////////////////////////////////////\n\nstruct Queue::Impl\n{\n    Impl(const Context& c, const Device& d)\n    {\n        refcount = 1;\n        const Context* pc = &c;\n        cl_context ch = (cl_context)pc->ptr();\n        if( !ch )\n        {\n            pc = &Context::getDefault();\n            ch = (cl_context)pc->ptr();\n        }\n        cl_device_id dh = (cl_device_id)d.ptr();\n        if( !dh )\n            dh = (cl_device_id)pc->device(0).ptr();\n        cl_int retval = 0;\n        handle = clCreateCommandQueue(ch, dh, 0, &retval);\n        CV_OclDbgAssert(retval == CL_SUCCESS);\n    }\n\n    ~Impl()\n    {\n#ifdef _WIN32\n        if (!cv::__termination)\n#endif\n        {\n            if(handle)\n            {\n                clFinish(handle);\n                clReleaseCommandQueue(handle);\n                handle = NULL;\n            }\n        }\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    cl_command_queue handle;\n};\n\nQueue::Queue()\n{\n    p = 0;\n}\n\nQueue::Queue(const Context& c, const Device& d)\n{\n    p = 0;\n    create(c, d);\n}\n\nQueue::Queue(const Queue& q)\n{\n    p = q.p;\n    if(p)\n        p->addref();\n}\n\nQueue& Queue::operator = (const Queue& q)\n{\n    Impl* newp = (Impl*)q.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nQueue::~Queue()\n{\n    if(p)\n        p->release();\n}\n\nbool Queue::create(const Context& c, const Device& d)\n{\n    if(p)\n        p->release();\n    p = new Impl(c, d);\n    return p->handle != 0;\n}\n\nvoid Queue::finish()\n{\n    if(p && p->handle)\n    {\n        CV_OclDbgAssert(clFinish(p->handle) == CL_SUCCESS);\n    }\n}\n\nvoid* Queue::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nQueue& Queue::getDefault()\n{\n    Queue& q = getCoreTlsData().get()->oclQueue;\n    if( !q.p && haveOpenCL() )\n        q.create(Context::getDefault());\n    return q;\n}\n\nstatic cl_command_queue getQueue(const Queue& q)\n{\n    cl_command_queue qq = (cl_command_queue)q.ptr();\n    if(!qq)\n        qq = (cl_command_queue)Queue::getDefault().ptr();\n    return qq;\n}\n\n/////////////////////////////////////////// KernelArg /////////////////////////////////////////////\n\nKernelArg::KernelArg()\n    : flags(0), m(0), obj(0), sz(0), wscale(1), iwscale(1)\n{\n}\n\nKernelArg::KernelArg(int _flags, UMat* _m, int _wscale, int _iwscale, const void* _obj, size_t _sz)\n    : flags(_flags), m(_m), obj(_obj), sz(_sz), wscale(_wscale), iwscale(_iwscale)\n{\n}\n\nKernelArg KernelArg::Constant(const Mat& m)\n{\n    CV_Assert(m.isContinuous());\n    return KernelArg(CONSTANT, 0, 0, 0, m.ptr(), m.total()*m.elemSize());\n}\n\n/////////////////////////////////////////// Kernel /////////////////////////////////////////////\n\nstruct Kernel::Impl\n{\n    Impl(const char* kname, const Program& prog) :\n        refcount(1), e(0), nu(0)\n    {\n        cl_program ph = (cl_program)prog.ptr();\n        cl_int retval = 0;\n        handle = ph != 0 ?\n            clCreateKernel(ph, kname, &retval) : 0;\n        CV_OclDbgAssert(retval == CL_SUCCESS);\n        for( int i = 0; i < MAX_ARRS; i++ )\n            u[i] = 0;\n        haveTempDstUMats = false;\n    }\n\n    void cleanupUMats()\n    {\n        for( int i = 0; i < MAX_ARRS; i++ )\n            if( u[i] )\n            {\n                if( CV_XADD(&u[i]->urefcount, -1) == 1 )\n                    u[i]->currAllocator->deallocate(u[i]);\n                u[i] = 0;\n            }\n        nu = 0;\n        haveTempDstUMats = false;\n    }\n\n    void addUMat(const UMat& m, bool dst)\n    {\n        CV_Assert(nu < MAX_ARRS && m.u && m.u->urefcount > 0);\n        u[nu] = m.u;\n        CV_XADD(&m.u->urefcount, 1);\n        nu++;\n        if(dst && m.u->tempUMat())\n            haveTempDstUMats = true;\n    }\n\n    void addImage(const Image2D& image)\n    {\n        images.push_back(image);\n    }\n\n    void finit()\n    {\n        cleanupUMats();\n        images.clear();\n        if(e) { clReleaseEvent(e); e = 0; }\n        release();\n    }\n\n    ~Impl()\n    {\n        if(handle)\n            clReleaseKernel(handle);\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    cl_kernel handle;\n    cl_event e;\n    enum { MAX_ARRS = 16 };\n    UMatData* u[MAX_ARRS];\n    int nu;\n    std::list<Image2D> images;\n    bool haveTempDstUMats;\n};\n\n}} // namespace cv::ocl\n\nextern \"C\" {\n\nstatic void CL_CALLBACK oclCleanupCallback(cl_event, cl_int, void *p)\n{\n    ((cv::ocl::Kernel::Impl*)p)->finit();\n}\n\n}\n\nnamespace cv { namespace ocl {\n\nKernel::Kernel()\n{\n    p = 0;\n}\n\nKernel::Kernel(const char* kname, const Program& prog)\n{\n    p = 0;\n    create(kname, prog);\n}\n\nKernel::Kernel(const char* kname, const ProgramSource& src,\n               const String& buildopts, String* errmsg)\n{\n    p = 0;\n    create(kname, src, buildopts, errmsg);\n}\n\nKernel::Kernel(const Kernel& k)\n{\n    p = k.p;\n    if(p)\n        p->addref();\n}\n\nKernel& Kernel::operator = (const Kernel& k)\n{\n    Impl* newp = (Impl*)k.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nKernel::~Kernel()\n{\n    if(p)\n        p->release();\n}\n\nbool Kernel::create(const char* kname, const Program& prog)\n{\n    if(p)\n        p->release();\n    p = new Impl(kname, prog);\n    if(p->handle == 0)\n    {\n        p->release();\n        p = 0;\n    }\n#ifdef CV_OPENCL_RUN_ASSERT // check kernel compilation fails\n    CV_Assert(p);\n#endif\n    return p != 0;\n}\n\nbool Kernel::create(const char* kname, const ProgramSource& src,\n                    const String& buildopts, String* errmsg)\n{\n    if(p)\n    {\n        p->release();\n        p = 0;\n    }\n    String tempmsg;\n    if( !errmsg ) errmsg = &tempmsg;\n    const Program& prog = Context::getDefault().getProg(src, buildopts, *errmsg);\n    return create(kname, prog);\n}\n\nvoid* Kernel::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nbool Kernel::empty() const\n{\n    return ptr() == 0;\n}\n\nint Kernel::set(int i, const void* value, size_t sz)\n{\n    if (!p || !p->handle)\n        return -1;\n    if (i < 0)\n        return i;\n    if( i == 0 )\n        p->cleanupUMats();\n\n    cl_int retval = clSetKernelArg(p->handle, (cl_uint)i, sz, value);\n    CV_OclDbgAssert(retval == CL_SUCCESS);\n    if (retval != CL_SUCCESS)\n        return -1;\n    return i+1;\n}\n\nint Kernel::set(int i, const Image2D& image2D)\n{\n    p->addImage(image2D);\n    cl_mem h = (cl_mem)image2D.ptr();\n    return set(i, &h, sizeof(h));\n}\n\nint Kernel::set(int i, const UMat& m)\n{\n    return set(i, KernelArg(KernelArg::READ_WRITE, (UMat*)&m, 0, 0));\n}\n\nint Kernel::set(int i, const KernelArg& arg)\n{\n    if( !p || !p->handle )\n        return -1;\n    if (i < 0)\n        return i;\n    if( i == 0 )\n        p->cleanupUMats();\n    if( arg.m )\n    {\n        int accessFlags = ((arg.flags & KernelArg::READ_ONLY) ? ACCESS_READ : 0) +\n                          ((arg.flags & KernelArg::WRITE_ONLY) ? ACCESS_WRITE : 0);\n        bool ptronly = (arg.flags & KernelArg::PTR_ONLY) != 0;\n        cl_mem h = (cl_mem)arg.m->handle(accessFlags);\n\n        if (!h)\n        {\n            p->release();\n            p = 0;\n            return -1;\n        }\n\n#ifdef HAVE_OPENCL_SVM\n        if ((arg.m->u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n        {\n            const Context& ctx = Context::getDefault();\n            const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n            uchar*& svmDataPtr = (uchar*&)arg.m->u->handle;\n            CV_OPENCL_SVM_TRACE_P(\"clSetKernelArgSVMPointer: %p\\n\", svmDataPtr);\n#if 1 // TODO\n            cl_int status = svmFns->fn_clSetKernelArgSVMPointer(p->handle, (cl_uint)i, svmDataPtr);\n#else\n            cl_int status = svmFns->fn_clSetKernelArgSVMPointer(p->handle, (cl_uint)i, &svmDataPtr);\n#endif\n            CV_Assert(status == CL_SUCCESS);\n        }\n        else\n#endif\n        {\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)i, sizeof(h), &h) == CL_SUCCESS);\n        }\n\n        if (ptronly)\n        {\n            i++;\n        }\n        else if( arg.m->dims <= 2 )\n        {\n            UMat2D u2d(*arg.m);\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+1), sizeof(u2d.step), &u2d.step) == CL_SUCCESS);\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+2), sizeof(u2d.offset), &u2d.offset) == CL_SUCCESS);\n            i += 3;\n\n            if( !(arg.flags & KernelArg::NO_SIZE) )\n            {\n                int cols = u2d.cols*arg.wscale/arg.iwscale;\n                CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)i, sizeof(u2d.rows), &u2d.rows) == CL_SUCCESS);\n                CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+1), sizeof(cols), &cols) == CL_SUCCESS);\n                i += 2;\n            }\n        }\n        else\n        {\n            UMat3D u3d(*arg.m);\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+1), sizeof(u3d.slicestep), &u3d.slicestep) == CL_SUCCESS);\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+2), sizeof(u3d.step), &u3d.step) == CL_SUCCESS);\n            CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+3), sizeof(u3d.offset), &u3d.offset) == CL_SUCCESS);\n            i += 4;\n            if( !(arg.flags & KernelArg::NO_SIZE) )\n            {\n                int cols = u3d.cols*arg.wscale/arg.iwscale;\n                CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)i, sizeof(u3d.slices), &u3d.rows) == CL_SUCCESS);\n                CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+1), sizeof(u3d.rows), &u3d.rows) == CL_SUCCESS);\n                CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)(i+2), sizeof(u3d.cols), &cols) == CL_SUCCESS);\n                i += 3;\n            }\n        }\n        p->addUMat(*arg.m, (accessFlags & ACCESS_WRITE) != 0);\n        return i;\n    }\n    CV_OclDbgAssert(clSetKernelArg(p->handle, (cl_uint)i, arg.sz, arg.obj) == CL_SUCCESS);\n    return i+1;\n}\n\n\nbool Kernel::run(int dims, size_t _globalsize[], size_t _localsize[],\n                 bool sync, const Queue& q)\n{\n    if(!p || !p->handle || p->e != 0)\n        return false;\n\n    cl_command_queue qq = getQueue(q);\n    size_t offset[CV_MAX_DIM] = {0}, globalsize[CV_MAX_DIM] = {1,1,1};\n    size_t total = 1;\n    CV_Assert(_globalsize != 0);\n    for (int i = 0; i < dims; i++)\n    {\n        size_t val = _localsize ? _localsize[i] :\n            dims == 1 ? 64 : dims == 2 ? (i == 0 ? 256 : 8) : dims == 3 ? (8>>(int)(i>0)) : 1;\n        CV_Assert( val > 0 );\n        total *= _globalsize[i];\n        globalsize[i] = ((_globalsize[i] + val - 1)/val)*val;\n    }\n    if( total == 0 )\n        return true;\n    if( p->haveTempDstUMats )\n        sync = true;\n    cl_int retval = clEnqueueNDRangeKernel(qq, p->handle, (cl_uint)dims,\n                                           offset, globalsize, _localsize, 0, 0,\n                                           sync ? 0 : &p->e);\n#if CV_OPENCL_SHOW_RUN_ERRORS\n    if (retval != CL_SUCCESS)\n    {\n        printf(\"OpenCL program returns error: %d\\n\", retval);\n        fflush(stdout);\n    }\n#endif\n    if( sync || retval != CL_SUCCESS )\n    {\n        CV_OclDbgAssert(clFinish(qq) == CL_SUCCESS);\n        p->cleanupUMats();\n    }\n    else\n    {\n        p->addref();\n        CV_OclDbgAssert(clSetEventCallback(p->e, CL_COMPLETE, oclCleanupCallback, p) == CL_SUCCESS);\n    }\n    return retval == CL_SUCCESS;\n}\n\nbool Kernel::runTask(bool sync, const Queue& q)\n{\n    if(!p || !p->handle || p->e != 0)\n        return false;\n\n    cl_command_queue qq = getQueue(q);\n    cl_int retval = clEnqueueTask(qq, p->handle, 0, 0, sync ? 0 : &p->e);\n    if( sync || retval != CL_SUCCESS )\n    {\n        CV_OclDbgAssert(clFinish(qq) == CL_SUCCESS);\n        p->cleanupUMats();\n    }\n    else\n    {\n        p->addref();\n        CV_OclDbgAssert(clSetEventCallback(p->e, CL_COMPLETE, oclCleanupCallback, p) == CL_SUCCESS);\n    }\n    return retval == CL_SUCCESS;\n}\n\n\nsize_t Kernel::workGroupSize() const\n{\n    if(!p || !p->handle)\n        return 0;\n    size_t val = 0, retsz = 0;\n    cl_device_id dev = (cl_device_id)Device::getDefault().ptr();\n    return clGetKernelWorkGroupInfo(p->handle, dev, CL_KERNEL_WORK_GROUP_SIZE,\n                                    sizeof(val), &val, &retsz) == CL_SUCCESS ? val : 0;\n}\n\nsize_t Kernel::preferedWorkGroupSizeMultiple() const\n{\n    if(!p || !p->handle)\n        return 0;\n    size_t val = 0, retsz = 0;\n    cl_device_id dev = (cl_device_id)Device::getDefault().ptr();\n    return clGetKernelWorkGroupInfo(p->handle, dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE,\n                                    sizeof(val), &val, &retsz) == CL_SUCCESS ? val : 0;\n}\n\nbool Kernel::compileWorkGroupSize(size_t wsz[]) const\n{\n    if(!p || !p->handle || !wsz)\n        return 0;\n    size_t retsz = 0;\n    cl_device_id dev = (cl_device_id)Device::getDefault().ptr();\n    return clGetKernelWorkGroupInfo(p->handle, dev, CL_KERNEL_COMPILE_WORK_GROUP_SIZE,\n                                    sizeof(wsz[0])*3, wsz, &retsz) == CL_SUCCESS;\n}\n\nsize_t Kernel::localMemSize() const\n{\n    if(!p || !p->handle)\n        return 0;\n    size_t retsz = 0;\n    cl_ulong val = 0;\n    cl_device_id dev = (cl_device_id)Device::getDefault().ptr();\n    return clGetKernelWorkGroupInfo(p->handle, dev, CL_KERNEL_LOCAL_MEM_SIZE,\n                                    sizeof(val), &val, &retsz) == CL_SUCCESS ? (size_t)val : 0;\n}\n\n/////////////////////////////////////////// Program /////////////////////////////////////////////\n\nstruct Program::Impl\n{\n    Impl(const ProgramSource& _src,\n         const String& _buildflags, String& errmsg)\n    {\n        refcount = 1;\n        const Context& ctx = Context::getDefault();\n        src = _src;\n        buildflags = _buildflags;\n        const String& srcstr = src.source();\n        const char* srcptr = srcstr.c_str();\n        size_t srclen = srcstr.size();\n        cl_int retval = 0;\n\n        handle = clCreateProgramWithSource((cl_context)ctx.ptr(), 1, &srcptr, &srclen, &retval);\n        if( handle && retval == CL_SUCCESS )\n        {\n            int i, n = (int)ctx.ndevices();\n            AutoBuffer<void*> deviceListBuf(n+1);\n            void** deviceList = deviceListBuf;\n            for( i = 0; i < n; i++ )\n                deviceList[i] = ctx.device(i).ptr();\n\n            Device device = Device::getDefault();\n            if (device.isAMD())\n                buildflags += \" -D AMD_DEVICE\";\n            else if (device.isIntel())\n                buildflags += \" -D INTEL_DEVICE\";\n\n            retval = clBuildProgram(handle, n,\n                                    (const cl_device_id*)deviceList,\n                                    buildflags.c_str(), 0, 0);\n#if !CV_OPENCL_ALWAYS_SHOW_BUILD_LOG\n            if( retval != CL_SUCCESS )\n#endif\n            {\n                size_t retsz = 0;\n                cl_int buildInfo_retval = clGetProgramBuildInfo(handle, (cl_device_id)deviceList[0],\n                                               CL_PROGRAM_BUILD_LOG, 0, 0, &retsz);\n                if (buildInfo_retval == CL_SUCCESS && retsz > 1)\n                {\n                    AutoBuffer<char> bufbuf(retsz + 16);\n                    char* buf = bufbuf;\n                    buildInfo_retval = clGetProgramBuildInfo(handle, (cl_device_id)deviceList[0],\n                                                   CL_PROGRAM_BUILD_LOG, retsz+1, buf, &retsz);\n                    if (buildInfo_retval == CL_SUCCESS)\n                    {\n                        // TODO It is useful to see kernel name & program file name also\n                        errmsg = String(buf);\n                        printf(\"OpenCL program build log: %s\\n%s\\n\", buildflags.c_str(), errmsg.c_str());\n                        fflush(stdout);\n                    }\n                }\n                if (retval != CL_SUCCESS && handle)\n                {\n                    clReleaseProgram(handle);\n                    handle = NULL;\n                }\n            }\n        }\n    }\n\n    Impl(const String& _buf, const String& _buildflags)\n    {\n        refcount = 1;\n        handle = 0;\n        buildflags = _buildflags;\n        if(_buf.empty())\n            return;\n        String prefix0 = Program::getPrefix(buildflags);\n        const Context& ctx = Context::getDefault();\n        const Device& dev = Device::getDefault();\n        const char* pos0 = _buf.c_str();\n        const char* pos1 = strchr(pos0, '\\n');\n        if(!pos1)\n            return;\n        const char* pos2 = strchr(pos1+1, '\\n');\n        if(!pos2)\n            return;\n        const char* pos3 = strchr(pos2+1, '\\n');\n        if(!pos3)\n            return;\n        size_t prefixlen = (pos3 - pos0)+1;\n        String prefix(pos0, prefixlen);\n        if( prefix != prefix0 )\n            return;\n        const uchar* bin = (uchar*)(pos3+1);\n        void* devid = dev.ptr();\n        size_t codelen = _buf.length() - prefixlen;\n        cl_int binstatus = 0, retval = 0;\n        handle = clCreateProgramWithBinary((cl_context)ctx.ptr(), 1, (cl_device_id*)&devid,\n                                           &codelen, &bin, &binstatus, &retval);\n        CV_OclDbgAssert(retval == CL_SUCCESS);\n    }\n\n    String store()\n    {\n        if(!handle)\n            return String();\n        size_t progsz = 0, retsz = 0;\n        String prefix = Program::getPrefix(buildflags);\n        size_t prefixlen = prefix.length();\n        if(clGetProgramInfo(handle, CL_PROGRAM_BINARY_SIZES, sizeof(progsz), &progsz, &retsz) != CL_SUCCESS)\n            return String();\n        AutoBuffer<uchar> bufbuf(prefixlen + progsz + 16);\n        uchar* buf = bufbuf;\n        memcpy(buf, prefix.c_str(), prefixlen);\n        buf += prefixlen;\n        if(clGetProgramInfo(handle, CL_PROGRAM_BINARIES, sizeof(buf), &buf, &retsz) != CL_SUCCESS)\n            return String();\n        buf[progsz] = (uchar)'\\0';\n        return String((const char*)(uchar*)bufbuf, prefixlen + progsz);\n    }\n\n    ~Impl()\n    {\n        if( handle )\n        {\n#ifdef _WIN32\n            if (!cv::__termination)\n#endif\n            {\n                clReleaseProgram(handle);\n            }\n            handle = NULL;\n        }\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    ProgramSource src;\n    String buildflags;\n    cl_program handle;\n};\n\n\nProgram::Program() { p = 0; }\n\nProgram::Program(const ProgramSource& src,\n        const String& buildflags, String& errmsg)\n{\n    p = 0;\n    create(src, buildflags, errmsg);\n}\n\nProgram::Program(const Program& prog)\n{\n    p = prog.p;\n    if(p)\n        p->addref();\n}\n\nProgram& Program::operator = (const Program& prog)\n{\n    Impl* newp = (Impl*)prog.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nProgram::~Program()\n{\n    if(p)\n        p->release();\n}\n\nbool Program::create(const ProgramSource& src,\n            const String& buildflags, String& errmsg)\n{\n    if(p)\n        p->release();\n    p = new Impl(src, buildflags, errmsg);\n    if(!p->handle)\n    {\n        p->release();\n        p = 0;\n    }\n    return p != 0;\n}\n\nconst ProgramSource& Program::source() const\n{\n    static ProgramSource dummy;\n    return p ? p->src : dummy;\n}\n\nvoid* Program::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nbool Program::read(const String& bin, const String& buildflags)\n{\n    if(p)\n        p->release();\n    p = new Impl(bin, buildflags);\n    return p->handle != 0;\n}\n\nbool Program::write(String& bin) const\n{\n    if(!p)\n        return false;\n    bin = p->store();\n    return !bin.empty();\n}\n\nString Program::getPrefix() const\n{\n    if(!p)\n        return String();\n    return getPrefix(p->buildflags);\n}\n\nString Program::getPrefix(const String& buildflags)\n{\n    const Context& ctx = Context::getDefault();\n    const Device& dev = ctx.device(0);\n    return format(\"name=%s\\ndriver=%s\\nbuildflags=%s\\n\",\n                  dev.name().c_str(), dev.driverVersion().c_str(), buildflags.c_str());\n}\n\n///////////////////////////////////////// ProgramSource ///////////////////////////////////////////////\n\nstruct ProgramSource::Impl\n{\n    Impl(const char* _src)\n    {\n        init(String(_src));\n    }\n    Impl(const String& _src)\n    {\n        init(_src);\n    }\n    void init(const String& _src)\n    {\n        refcount = 1;\n        src = _src;\n        h = crc64((uchar*)src.c_str(), src.size());\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n    String src;\n    ProgramSource::hash_t h;\n};\n\n\nProgramSource::ProgramSource()\n{\n    p = 0;\n}\n\nProgramSource::ProgramSource(const char* prog)\n{\n    p = new Impl(prog);\n}\n\nProgramSource::ProgramSource(const String& prog)\n{\n    p = new Impl(prog);\n}\n\nProgramSource::~ProgramSource()\n{\n    if(p)\n        p->release();\n}\n\nProgramSource::ProgramSource(const ProgramSource& prog)\n{\n    p = prog.p;\n    if(p)\n        p->addref();\n}\n\nProgramSource& ProgramSource::operator = (const ProgramSource& prog)\n{\n    Impl* newp = (Impl*)prog.p;\n    if(newp)\n        newp->addref();\n    if(p)\n        p->release();\n    p = newp;\n    return *this;\n}\n\nconst String& ProgramSource::source() const\n{\n    static String dummy;\n    return p ? p->src : dummy;\n}\n\nProgramSource::hash_t ProgramSource::hash() const\n{\n    return p ? p->h : 0;\n}\n\n//////////////////////////////////////////// OpenCLAllocator //////////////////////////////////////////////////\n\ntemplate<typename T>\nclass OpenCLBufferPool\n{\nprotected:\n    ~OpenCLBufferPool() { }\npublic:\n    virtual T allocate(size_t size) = 0;\n    virtual void release(T buffer) = 0;\n};\n\ntemplate <typename Derived, typename BufferEntry, typename T>\nclass OpenCLBufferPoolBaseImpl : public BufferPoolController, public OpenCLBufferPool<T>\n{\nprivate:\n    inline Derived& derived() { return *static_cast<Derived*>(this); }\nprotected:\n    Mutex mutex_;\n\n    size_t currentReservedSize;\n    size_t maxReservedSize;\n\n    std::list<BufferEntry> allocatedEntries_; // Allocated and used entries\n    std::list<BufferEntry> reservedEntries_; // LRU order. Allocated, but not used entries\n\n    // synchronized\n    bool _findAndRemoveEntryFromAllocatedList(CV_OUT BufferEntry& entry, T buffer)\n    {\n        typename std::list<BufferEntry>::iterator i = allocatedEntries_.begin();\n        for (; i != allocatedEntries_.end(); ++i)\n        {\n            BufferEntry& e = *i;\n            if (e.clBuffer_ == buffer)\n            {\n                entry = e;\n                allocatedEntries_.erase(i);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // synchronized\n    bool _findAndRemoveEntryFromReservedList(CV_OUT BufferEntry& entry, const size_t size)\n    {\n        if (reservedEntries_.empty())\n            return false;\n        typename std::list<BufferEntry>::iterator i = reservedEntries_.begin();\n        typename std::list<BufferEntry>::iterator result_pos = reservedEntries_.end();\n        BufferEntry result;\n        size_t minDiff = (size_t)(-1);\n        for (; i != reservedEntries_.end(); ++i)\n        {\n            BufferEntry& e = *i;\n            if (e.capacity_ >= size)\n            {\n                size_t diff = e.capacity_ - size;\n                if (diff < std::max((size_t)4096, size / 8) && (result_pos == reservedEntries_.end() || diff < minDiff))\n                {\n                    minDiff = diff;\n                    result_pos = i;\n                    result = e;\n                    if (diff == 0)\n                        break;\n                }\n            }\n        }\n        if (result_pos != reservedEntries_.end())\n        {\n            //CV_DbgAssert(result == *result_pos);\n            reservedEntries_.erase(result_pos);\n            entry = result;\n            currentReservedSize -= entry.capacity_;\n            allocatedEntries_.push_back(entry);\n            return true;\n        }\n        return false;\n    }\n\n    // synchronized\n    void _checkSizeOfReservedEntries()\n    {\n        while (currentReservedSize > maxReservedSize)\n        {\n            CV_DbgAssert(!reservedEntries_.empty());\n            const BufferEntry& entry = reservedEntries_.back();\n            CV_DbgAssert(currentReservedSize >= entry.capacity_);\n            currentReservedSize -= entry.capacity_;\n            derived()._releaseBufferEntry(entry);\n            reservedEntries_.pop_back();\n        }\n    }\n\n    inline size_t _allocationGranularity(size_t size)\n    {\n        // heuristic values\n        if (size < 1024*1024)\n            return 4096;  // don't work with buffers smaller than 4Kb (hidden allocation overhead issue)\n        else if (size < 16*1024*1024)\n            return 64*1024;\n        else\n            return 1024*1024;\n    }\n\npublic:\n    OpenCLBufferPoolBaseImpl()\n        : currentReservedSize(0),\n          maxReservedSize(0)\n    {\n        // nothing\n    }\n    virtual ~OpenCLBufferPoolBaseImpl()\n    {\n        freeAllReservedBuffers();\n        CV_Assert(reservedEntries_.empty());\n    }\npublic:\n    virtual T allocate(size_t size)\n    {\n        AutoLock locker(mutex_);\n        BufferEntry entry;\n        if (maxReservedSize > 0 && _findAndRemoveEntryFromReservedList(entry, size))\n        {\n            CV_DbgAssert(size <= entry.capacity_);\n            LOG_BUFFER_POOL(\"Reuse reserved buffer: %p\\n\", entry.clBuffer_);\n        }\n        else\n        {\n            derived()._allocateBufferEntry(entry, size);\n        }\n        return entry.clBuffer_;\n    }\n    virtual void release(T buffer)\n    {\n        AutoLock locker(mutex_);\n        BufferEntry entry;\n        CV_Assert(_findAndRemoveEntryFromAllocatedList(entry, buffer));\n        if (maxReservedSize == 0 || entry.capacity_ > maxReservedSize / 8)\n        {\n            derived()._releaseBufferEntry(entry);\n        }\n        else\n        {\n            reservedEntries_.push_front(entry);\n            currentReservedSize += entry.capacity_;\n            _checkSizeOfReservedEntries();\n        }\n    }\n\n    virtual size_t getReservedSize() const { return currentReservedSize; }\n    virtual size_t getMaxReservedSize() const { return maxReservedSize; }\n    virtual void setMaxReservedSize(size_t size)\n    {\n        AutoLock locker(mutex_);\n        size_t oldMaxReservedSize = maxReservedSize;\n        maxReservedSize = size;\n        if (maxReservedSize < oldMaxReservedSize)\n        {\n            typename std::list<BufferEntry>::iterator i = reservedEntries_.begin();\n            for (; i != reservedEntries_.end();)\n            {\n                const BufferEntry& entry = *i;\n                if (entry.capacity_ > maxReservedSize / 8)\n                {\n                    CV_DbgAssert(currentReservedSize >= entry.capacity_);\n                    currentReservedSize -= entry.capacity_;\n                    derived()._releaseBufferEntry(entry);\n                    i = reservedEntries_.erase(i);\n                    continue;\n                }\n                ++i;\n            }\n            _checkSizeOfReservedEntries();\n        }\n    }\n    virtual void freeAllReservedBuffers()\n    {\n        AutoLock locker(mutex_);\n        typename std::list<BufferEntry>::const_iterator i = reservedEntries_.begin();\n        for (; i != reservedEntries_.end(); ++i)\n        {\n            const BufferEntry& entry = *i;\n            derived()._releaseBufferEntry(entry);\n        }\n        reservedEntries_.clear();\n        currentReservedSize = 0;\n    }\n};\n\nstruct CLBufferEntry\n{\n    cl_mem clBuffer_;\n    size_t capacity_;\n    CLBufferEntry() : clBuffer_((cl_mem)NULL), capacity_(0) { }\n};\n\nclass OpenCLBufferPoolImpl : public OpenCLBufferPoolBaseImpl<OpenCLBufferPoolImpl, CLBufferEntry, cl_mem>\n{\npublic:\n    typedef struct CLBufferEntry BufferEntry;\nprotected:\n    int createFlags_;\npublic:\n    OpenCLBufferPoolImpl(int createFlags = 0)\n        : createFlags_(createFlags)\n    {\n    }\n\n    void _allocateBufferEntry(BufferEntry& entry, size_t size)\n    {\n        CV_DbgAssert(entry.clBuffer_ == NULL);\n        entry.capacity_ = alignSize(size, (int)_allocationGranularity(size));\n        Context& ctx = Context::getDefault();\n        cl_int retval = CL_SUCCESS;\n        entry.clBuffer_ = clCreateBuffer((cl_context)ctx.ptr(), CL_MEM_READ_WRITE|createFlags_, entry.capacity_, 0, &retval);\n        CV_Assert(retval == CL_SUCCESS);\n        CV_Assert(entry.clBuffer_ != NULL);\n        if(retval == CL_SUCCESS)\n        {\n            CV_IMPL_ADD(CV_IMPL_OCL);\n        }\n        LOG_BUFFER_POOL(\"OpenCL allocate %lld (0x%llx) bytes: %p\\n\",\n                (long long)entry.capacity_, (long long)entry.capacity_, entry.clBuffer_);\n        allocatedEntries_.push_back(entry);\n    }\n\n    void _releaseBufferEntry(const BufferEntry& entry)\n    {\n        CV_Assert(entry.capacity_ != 0);\n        CV_Assert(entry.clBuffer_ != NULL);\n        LOG_BUFFER_POOL(\"OpenCL release buffer: %p, %lld (0x%llx) bytes\\n\",\n                entry.clBuffer_, (long long)entry.capacity_, (long long)entry.capacity_);\n        clReleaseMemObject(entry.clBuffer_);\n    }\n};\n\n#ifdef HAVE_OPENCL_SVM\nstruct CLSVMBufferEntry\n{\n    void* clBuffer_;\n    size_t capacity_;\n    CLSVMBufferEntry() : clBuffer_(NULL), capacity_(0) { }\n};\nclass OpenCLSVMBufferPoolImpl : public OpenCLBufferPoolBaseImpl<OpenCLSVMBufferPoolImpl, CLSVMBufferEntry, void*>\n{\npublic:\n    typedef struct CLSVMBufferEntry BufferEntry;\npublic:\n    OpenCLSVMBufferPoolImpl()\n    {\n    }\n\n    void _allocateBufferEntry(BufferEntry& entry, size_t size)\n    {\n        CV_DbgAssert(entry.clBuffer_ == NULL);\n        entry.capacity_ = alignSize(size, (int)_allocationGranularity(size));\n\n        Context& ctx = Context::getDefault();\n        const svm::SVMCapabilities svmCaps = svm::getSVMCapabilitites(ctx);\n        bool isFineGrainBuffer = svmCaps.isSupportFineGrainBuffer();\n        cl_svm_mem_flags memFlags = CL_MEM_READ_WRITE |\n                (isFineGrainBuffer ? CL_MEM_SVM_FINE_GRAIN_BUFFER : 0);\n\n        const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n        CV_DbgAssert(svmFns->isValid());\n\n        CV_OPENCL_SVM_TRACE_P(\"clSVMAlloc: %d\\n\", (int)entry.capacity_);\n        void *buf = svmFns->fn_clSVMAlloc((cl_context)ctx.ptr(), memFlags, entry.capacity_, 0);\n        CV_Assert(buf);\n\n        entry.clBuffer_ = buf;\n        {\n            CV_IMPL_ADD(CV_IMPL_OCL);\n        }\n        LOG_BUFFER_POOL(\"OpenCL SVM allocate %lld (0x%llx) bytes: %p\\n\",\n                (long long)entry.capacity_, (long long)entry.capacity_, entry.clBuffer_);\n        allocatedEntries_.push_back(entry);\n    }\n\n    void _releaseBufferEntry(const BufferEntry& entry)\n    {\n        CV_Assert(entry.capacity_ != 0);\n        CV_Assert(entry.clBuffer_ != NULL);\n        LOG_BUFFER_POOL(\"OpenCL release SVM buffer: %p, %lld (0x%llx) bytes\\n\",\n                entry.clBuffer_, (long long)entry.capacity_, (long long)entry.capacity_);\n        Context& ctx = Context::getDefault();\n        const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n        CV_DbgAssert(svmFns->isValid());\n        CV_OPENCL_SVM_TRACE_P(\"clSVMFree: %p\\n\",  entry.clBuffer_);\n        svmFns->fn_clSVMFree((cl_context)ctx.ptr(), entry.clBuffer_);\n    }\n};\n#endif\n\n\n\n#if defined _MSC_VER\n#pragma warning(disable:4127) // conditional expression is constant\n#endif\ntemplate <bool readAccess, bool writeAccess>\nclass AlignedDataPtr\n{\nprotected:\n    const size_t size_;\n    uchar* const originPtr_;\n    const size_t alignment_;\n    uchar* ptr_;\n    uchar* allocatedPtr_;\n\npublic:\n    AlignedDataPtr(uchar* ptr, size_t size, size_t alignment)\n        : size_(size), originPtr_(ptr), alignment_(alignment), ptr_(ptr), allocatedPtr_(NULL)\n    {\n        CV_DbgAssert((alignment & (alignment - 1)) == 0); // check for 2^n\n        if (((size_t)ptr_ & (alignment - 1)) != 0)\n        {\n            allocatedPtr_ = new uchar[size_ + alignment - 1];\n            ptr_ = (uchar*)(((uintptr_t)allocatedPtr_ + (alignment - 1)) & ~(alignment - 1));\n            if (readAccess)\n            {\n                memcpy(ptr_, originPtr_, size_);\n            }\n        }\n    }\n\n    uchar* getAlignedPtr() const\n    {\n        CV_DbgAssert(((size_t)ptr_ & (alignment_ - 1)) == 0);\n        return ptr_;\n    }\n\n    ~AlignedDataPtr()\n    {\n        if (allocatedPtr_)\n        {\n            if (writeAccess)\n            {\n                memcpy(originPtr_, ptr_, size_);\n            }\n            delete[] allocatedPtr_;\n            allocatedPtr_ = NULL;\n        }\n        ptr_ = NULL;\n    }\nprivate:\n    AlignedDataPtr(const AlignedDataPtr&); // disabled\n    AlignedDataPtr& operator=(const AlignedDataPtr&); // disabled\n};\n\ntemplate <bool readAccess, bool writeAccess>\nclass AlignedDataPtr2D\n{\nprotected:\n    const size_t size_;\n    uchar* const originPtr_;\n    const size_t alignment_;\n    uchar* ptr_;\n    uchar* allocatedPtr_;\n    size_t rows_;\n    size_t cols_;\n    size_t step_;\n\npublic:\n    AlignedDataPtr2D(uchar* ptr, size_t rows, size_t cols, size_t step, size_t alignment)\n        : size_(rows*step), originPtr_(ptr), alignment_(alignment), ptr_(ptr), allocatedPtr_(NULL), rows_(rows), cols_(cols), step_(step)\n    {\n        CV_DbgAssert((alignment & (alignment - 1)) == 0); // check for 2^n\n        if (((size_t)ptr_ & (alignment - 1)) != 0)\n        {\n            allocatedPtr_ = new uchar[size_ + alignment - 1];\n            ptr_ = (uchar*)(((uintptr_t)allocatedPtr_ + (alignment - 1)) & ~(alignment - 1));\n            if (readAccess)\n            {\n                for (size_t i = 0; i < rows_; i++)\n                    memcpy(ptr_ + i*step_, originPtr_ + i*step_, cols_);\n            }\n        }\n    }\n\n    uchar* getAlignedPtr() const\n    {\n        CV_DbgAssert(((size_t)ptr_ & (alignment_ - 1)) == 0);\n        return ptr_;\n    }\n\n    ~AlignedDataPtr2D()\n    {\n        if (allocatedPtr_)\n        {\n            if (writeAccess)\n            {\n                for (size_t i = 0; i < rows_; i++)\n                    memcpy(originPtr_ + i*step_, ptr_ + i*step_, cols_);\n            }\n            delete[] allocatedPtr_;\n            allocatedPtr_ = NULL;\n        }\n        ptr_ = NULL;\n    }\nprivate:\n    AlignedDataPtr2D(const AlignedDataPtr2D&); // disabled\n    AlignedDataPtr2D& operator=(const AlignedDataPtr2D&); // disabled\n};\n#if defined _MSC_VER\n#pragma warning(default:4127) // conditional expression is constant\n#endif\n\n#ifndef CV_OPENCL_DATA_PTR_ALIGNMENT\n#define CV_OPENCL_DATA_PTR_ALIGNMENT 16\n#endif\n\nclass OpenCLAllocator : public MatAllocator\n{\n    mutable OpenCLBufferPoolImpl bufferPool;\n    mutable OpenCLBufferPoolImpl bufferPoolHostPtr;\n#ifdef  HAVE_OPENCL_SVM\n    mutable OpenCLSVMBufferPoolImpl bufferPoolSVM;\n#endif\n\n    enum AllocatorFlags\n    {\n        ALLOCATOR_FLAGS_BUFFER_POOL_USED = 1 << 0,\n        ALLOCATOR_FLAGS_BUFFER_POOL_HOST_PTR_USED = 1 << 1\n#ifdef HAVE_OPENCL_SVM\n        ,ALLOCATOR_FLAGS_BUFFER_POOL_SVM_USED = 1 << 2\n#endif\n    };\npublic:\n    OpenCLAllocator()\n        : bufferPool(0),\n          bufferPoolHostPtr(CL_MEM_ALLOC_HOST_PTR)\n    {\n        size_t defaultPoolSize, poolSize;\n        defaultPoolSize = ocl::Device::getDefault().isIntel() ? 1 << 27 : 0;\n        poolSize = getConfigurationParameterForSize(\"OPENCV_OPENCL_BUFFERPOOL_LIMIT\", defaultPoolSize);\n        bufferPool.setMaxReservedSize(poolSize);\n        poolSize = getConfigurationParameterForSize(\"OPENCV_OPENCL_HOST_PTR_BUFFERPOOL_LIMIT\", defaultPoolSize);\n        bufferPoolHostPtr.setMaxReservedSize(poolSize);\n#ifdef HAVE_OPENCL_SVM\n        poolSize = getConfigurationParameterForSize(\"OPENCV_OPENCL_SVM_BUFFERPOOL_LIMIT\", defaultPoolSize);\n        bufferPoolSVM.setMaxReservedSize(poolSize);\n#endif\n\n        matStdAllocator = Mat::getDefaultAllocator();\n    }\n\n    UMatData* defaultAllocate(int dims, const int* sizes, int type, void* data, size_t* step,\n            int flags, UMatUsageFlags usageFlags) const\n    {\n        UMatData* u = matStdAllocator->allocate(dims, sizes, type, data, step, flags, usageFlags);\n        return u;\n    }\n\n    void getBestFlags(const Context& ctx, int /*flags*/, UMatUsageFlags usageFlags, int& createFlags, int& flags0) const\n    {\n        const Device& dev = ctx.device(0);\n        createFlags = 0;\n        if ((usageFlags & USAGE_ALLOCATE_HOST_MEMORY) != 0)\n            createFlags |= CL_MEM_ALLOC_HOST_PTR;\n\n        if( dev.hostUnifiedMemory() )\n            flags0 = 0;\n        else\n            flags0 = UMatData::COPY_ON_MAP;\n    }\n\n    UMatData* allocate(int dims, const int* sizes, int type,\n                       void* data, size_t* step, int flags, UMatUsageFlags usageFlags) const\n    {\n        if(!useOpenCL())\n            return defaultAllocate(dims, sizes, type, data, step, flags, usageFlags);\n        CV_Assert(data == 0);\n        size_t total = CV_ELEM_SIZE(type);\n        for( int i = dims-1; i >= 0; i-- )\n        {\n            if( step )\n                step[i] = total;\n            total *= sizes[i];\n        }\n\n        Context& ctx = Context::getDefault();\n\n        int createFlags = 0, flags0 = 0;\n        getBestFlags(ctx, flags, usageFlags, createFlags, flags0);\n\n        void* handle = NULL;\n        int allocatorFlags = 0;\n\n#ifdef HAVE_OPENCL_SVM\n        const svm::SVMCapabilities svmCaps = svm::getSVMCapabilitites(ctx);\n        if (ctx.useSVM() && svm::useSVM(usageFlags) && !svmCaps.isNoSVMSupport())\n        {\n            allocatorFlags = ALLOCATOR_FLAGS_BUFFER_POOL_SVM_USED;\n            handle = bufferPoolSVM.allocate(total);\n\n            // this property is constant, so single buffer pool can be used here\n            bool isFineGrainBuffer = svmCaps.isSupportFineGrainBuffer();\n            allocatorFlags |= isFineGrainBuffer ? svm::OPENCL_SVM_FINE_GRAIN_BUFFER : svm::OPENCL_SVM_COARSE_GRAIN_BUFFER;\n        }\n        else\n#endif\n        if (createFlags == 0)\n        {\n            allocatorFlags = ALLOCATOR_FLAGS_BUFFER_POOL_USED;\n            handle = bufferPool.allocate(total);\n        }\n        else if (createFlags == CL_MEM_ALLOC_HOST_PTR)\n        {\n            allocatorFlags = ALLOCATOR_FLAGS_BUFFER_POOL_HOST_PTR_USED;\n            handle = bufferPoolHostPtr.allocate(total);\n        }\n        else\n        {\n            CV_Assert(handle != NULL); // Unsupported, throw\n        }\n\n        if (!handle)\n            return defaultAllocate(dims, sizes, type, data, step, flags, usageFlags);\n\n        UMatData* u = new UMatData(this);\n        u->data = 0;\n        u->size = total;\n        u->handle = handle;\n        u->flags = flags0;\n        u->allocatorFlags_ = allocatorFlags;\n        CV_DbgAssert(!u->tempUMat()); // for bufferPool.release() consistency in deallocate()\n        u->markHostCopyObsolete(true);\n        return u;\n    }\n\n    bool allocate(UMatData* u, int accessFlags, UMatUsageFlags usageFlags) const\n    {\n        if(!u)\n            return false;\n\n        UMatDataAutoLock lock(u);\n\n        if(u->handle == 0)\n        {\n            CV_Assert(u->origdata != 0);\n            Context& ctx = Context::getDefault();\n            int createFlags = 0, flags0 = 0;\n            getBestFlags(ctx, accessFlags, usageFlags, createFlags, flags0);\n\n            cl_context ctx_handle = (cl_context)ctx.ptr();\n            int allocatorFlags = 0;\n            int tempUMatFlags = 0;\n            void* handle = NULL;\n            cl_int retval = CL_SUCCESS;\n\n#ifdef HAVE_OPENCL_SVM\n            svm::SVMCapabilities svmCaps = svm::getSVMCapabilitites(ctx);\n            bool useSVM = ctx.useSVM() && svm::useSVM(usageFlags);\n            if (useSVM && svmCaps.isSupportFineGrainSystem())\n            {\n                allocatorFlags = svm::OPENCL_SVM_FINE_GRAIN_SYSTEM;\n                tempUMatFlags = UMatData::TEMP_UMAT;\n                handle = u->origdata;\n                CV_OPENCL_SVM_TRACE_P(\"Use fine grain system: %d (%p)\\n\", (int)u->size, handle);\n            }\n            else if (useSVM && (svmCaps.isSupportFineGrainBuffer() || svmCaps.isSupportCoarseGrainBuffer()))\n            {\n                if (!(accessFlags & ACCESS_FAST)) // memcpy used\n                {\n                    bool isFineGrainBuffer = svmCaps.isSupportFineGrainBuffer();\n\n                    cl_svm_mem_flags memFlags = createFlags |\n                            (isFineGrainBuffer ? CL_MEM_SVM_FINE_GRAIN_BUFFER : 0);\n\n                    const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                    CV_DbgAssert(svmFns->isValid());\n\n                    CV_OPENCL_SVM_TRACE_P(\"clSVMAlloc + copy: %d\\n\", (int)u->size);\n                    handle = svmFns->fn_clSVMAlloc((cl_context)ctx.ptr(), memFlags, u->size, 0);\n                    CV_Assert(handle);\n\n                    cl_command_queue q = NULL;\n                    if (!isFineGrainBuffer)\n                    {\n                        q = (cl_command_queue)Queue::getDefault().ptr();\n                        CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMap: %p (%d)\\n\", handle, (int)u->size);\n                        cl_int status = svmFns->fn_clEnqueueSVMMap(q, CL_TRUE, CL_MAP_WRITE,\n                                handle, u->size,\n                                0, NULL, NULL);\n                        CV_Assert(status == CL_SUCCESS);\n\n                    }\n                    memcpy(handle, u->origdata, u->size);\n                    if (!isFineGrainBuffer)\n                    {\n                        CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", handle);\n                        cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, handle, 0, NULL, NULL);\n                        CV_Assert(status == CL_SUCCESS);\n                    }\n\n                    tempUMatFlags = UMatData::TEMP_UMAT | UMatData::TEMP_COPIED_UMAT;\n                    allocatorFlags |= isFineGrainBuffer ? svm::OPENCL_SVM_FINE_GRAIN_BUFFER\n                                                : svm::OPENCL_SVM_COARSE_GRAIN_BUFFER;\n                }\n            }\n            else\n#endif\n            {\n                tempUMatFlags = UMatData::TEMP_UMAT;\n                if (u->origdata == cv::alignPtr(u->origdata, 4)) // There are OpenCL runtime issues for less aligned data\n                {\n                    handle = clCreateBuffer(ctx_handle, CL_MEM_USE_HOST_PTR|createFlags,\n                                            u->size, u->origdata, &retval);\n                }\n                if((!handle || retval < 0) && !(accessFlags & ACCESS_FAST))\n                {\n                    handle = clCreateBuffer(ctx_handle, CL_MEM_COPY_HOST_PTR|CL_MEM_READ_WRITE|createFlags,\n                                               u->size, u->origdata, &retval);\n                    tempUMatFlags |= UMatData::TEMP_COPIED_UMAT;\n                }\n            }\n            if(!handle || retval != CL_SUCCESS)\n                return false;\n            u->handle = handle;\n            u->prevAllocator = u->currAllocator;\n            u->currAllocator = this;\n            u->flags |= tempUMatFlags;\n            u->allocatorFlags_ = allocatorFlags;\n        }\n        if(accessFlags & ACCESS_WRITE)\n            u->markHostCopyObsolete(true);\n        return true;\n    }\n\n    /*void sync(UMatData* u) const\n    {\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n        UMatDataAutoLock lock(u);\n\n        if( u->hostCopyObsolete() && u->handle && u->refcount > 0 && u->origdata)\n        {\n            if( u->tempCopiedUMat() )\n            {\n                clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,\n                                    u->size, u->origdata, 0, 0, 0);\n            }\n            else\n            {\n                cl_int retval = 0;\n                void* data = clEnqueueMapBuffer(q, (cl_mem)u->handle, CL_TRUE,\n                                                (CL_MAP_READ | CL_MAP_WRITE),\n                                                0, u->size, 0, 0, 0, &retval);\n                clEnqueueUnmapMemObject(q, (cl_mem)u->handle, data, 0, 0, 0);\n                clFinish(q);\n            }\n            u->markHostCopyObsolete(false);\n        }\n        else if( u->copyOnMap() && u->deviceCopyObsolete() && u->data )\n        {\n            clEnqueueWriteBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,\n                                 u->size, u->data, 0, 0, 0);\n        }\n    }*/\n\n    void deallocate(UMatData* u) const\n    {\n        if(!u)\n            return;\n\n        CV_Assert(u->urefcount == 0);\n        CV_Assert(u->refcount == 0 && \"UMat deallocation error: some derived Mat is still alive\");\n\n        CV_Assert(u->handle != 0);\n        CV_Assert(u->mapcount == 0);\n        if(u->tempUMat())\n        {\n            CV_Assert(u->origdata);\n//            UMatDataAutoLock lock(u);\n\n            if (u->hostCopyObsolete())\n            {\n#ifdef HAVE_OPENCL_SVM\n                if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n                {\n                    Context& ctx = Context::getDefault();\n                    const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                    CV_DbgAssert(svmFns->isValid());\n\n                    if( u->tempCopiedUMat() )\n                    {\n                        CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER ||\n                                (u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER);\n                        bool isFineGrainBuffer = (u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER;\n                        cl_command_queue q = NULL;\n                        if (!isFineGrainBuffer)\n                        {\n                            CV_DbgAssert(((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) == 0));\n                            q = (cl_command_queue)Queue::getDefault().ptr();\n                            CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMap: %p (%d)\\n\", u->handle, (int)u->size);\n                            cl_int status = svmFns->fn_clEnqueueSVMMap(q, CL_FALSE, CL_MAP_READ,\n                                    u->handle, u->size,\n                                    0, NULL, NULL);\n                            CV_Assert(status == CL_SUCCESS);\n                        }\n                        clFinish(q);\n                        memcpy(u->origdata, u->handle, u->size);\n                        if (!isFineGrainBuffer)\n                        {\n                            CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", u->handle);\n                            cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, u->handle, 0, NULL, NULL);\n                            CV_Assert(status == CL_SUCCESS);\n                        }\n                    }\n                    else\n                    {\n                        CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_SYSTEM);\n                        // nothing\n                    }\n                }\n                else\n#endif\n                {\n                    cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n                    if( u->tempCopiedUMat() )\n                    {\n                        AlignedDataPtr<false, true> alignedPtr(u->origdata, u->size, CV_OPENCL_DATA_PTR_ALIGNMENT);\n                        CV_OclDbgAssert(clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,\n                                            u->size, alignedPtr.getAlignedPtr(), 0, 0, 0) == CL_SUCCESS);\n                    }\n                    else\n                    {\n                        cl_int retval = 0;\n                        if (u->tempUMat())\n                        {\n                            CV_Assert(u->mapcount == 0);\n                            void* data = clEnqueueMapBuffer(q, (cl_mem)u->handle, CL_TRUE,\n                                (CL_MAP_READ | CL_MAP_WRITE),\n                                0, u->size, 0, 0, 0, &retval);\n                            CV_Assert(u->origdata == data);\n                            CV_OclDbgAssert(retval == CL_SUCCESS);\n                            if (u->originalUMatData)\n                            {\n                                CV_Assert(u->originalUMatData->data == data);\n                            }\n                            CV_OclDbgAssert(clEnqueueUnmapMemObject(q, (cl_mem)u->handle, data, 0, 0, 0) == CL_SUCCESS);\n                            CV_OclDbgAssert(clFinish(q) == CL_SUCCESS);\n                        }\n                    }\n                }\n                u->markHostCopyObsolete(false);\n            }\n            else\n            {\n                // nothing\n            }\n#ifdef HAVE_OPENCL_SVM\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n            {\n                if( u->tempCopiedUMat() )\n                {\n                    Context& ctx = Context::getDefault();\n                    const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                    CV_DbgAssert(svmFns->isValid());\n\n                    CV_OPENCL_SVM_TRACE_P(\"clSVMFree: %p\\n\", u->handle);\n                    svmFns->fn_clSVMFree((cl_context)ctx.ptr(), u->handle);\n                }\n            }\n            else\n#endif\n            {\n                clReleaseMemObject((cl_mem)u->handle);\n            }\n            u->handle = 0;\n            u->markDeviceCopyObsolete(true);\n            u->currAllocator = u->prevAllocator;\n            u->prevAllocator = NULL;\n            if(u->data && u->copyOnMap() && u->data != u->origdata)\n                fastFree(u->data);\n            u->data = u->origdata;\n            u->currAllocator->deallocate(u);\n            u = NULL;\n        }\n        else\n        {\n            CV_Assert(u->origdata == NULL);\n            if(u->data && u->copyOnMap() && u->data != u->origdata)\n            {\n                fastFree(u->data);\n                u->data = 0;\n                u->markHostCopyObsolete(true);\n            }\n            if (u->allocatorFlags_ & ALLOCATOR_FLAGS_BUFFER_POOL_USED)\n            {\n                bufferPool.release((cl_mem)u->handle);\n            }\n            else if (u->allocatorFlags_ & ALLOCATOR_FLAGS_BUFFER_POOL_HOST_PTR_USED)\n            {\n                bufferPoolHostPtr.release((cl_mem)u->handle);\n            }\n#ifdef HAVE_OPENCL_SVM\n            else if (u->allocatorFlags_ & ALLOCATOR_FLAGS_BUFFER_POOL_SVM_USED)\n            {\n                if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_SYSTEM)\n                {\n                    //nothing\n                }\n                else if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER ||\n                        (u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n                {\n                    Context& ctx = Context::getDefault();\n                    const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                    CV_DbgAssert(svmFns->isValid());\n                    cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n                    if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) != 0)\n                    {\n                        CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", u->handle);\n                        cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, u->handle, 0, NULL, NULL);\n                        CV_Assert(status == CL_SUCCESS);\n                    }\n                }\n                bufferPoolSVM.release((void*)u->handle);\n            }\n#endif\n            else\n            {\n                clReleaseMemObject((cl_mem)u->handle);\n            }\n            u->handle = 0;\n            u->markDeviceCopyObsolete(true);\n            delete u;\n            u = NULL;\n        }\n        CV_Assert(u == NULL);\n    }\n\n    // synchronized call (external UMatDataAutoLock, see UMat::getMat)\n    void map(UMatData* u, int accessFlags) const\n    {\n        CV_Assert(u && u->handle);\n\n        if(accessFlags & ACCESS_WRITE)\n            u->markDeviceCopyObsolete(true);\n\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n        {\n            if( !u->copyOnMap() )\n            {\n                // TODO\n                // because there can be other map requests for the same UMat with different access flags,\n                // we use the universal (read-write) access mode.\n#ifdef HAVE_OPENCL_SVM\n                if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n                {\n                    if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n                    {\n                        Context& ctx = Context::getDefault();\n                        const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                        CV_DbgAssert(svmFns->isValid());\n\n                        if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) == 0)\n                        {\n                            CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMap: %p (%d)\\n\", u->handle, (int)u->size);\n                            cl_int status = svmFns->fn_clEnqueueSVMMap(q, CL_FALSE, CL_MAP_READ | CL_MAP_WRITE,\n                                    u->handle, u->size,\n                                    0, NULL, NULL);\n                            CV_Assert(status == CL_SUCCESS);\n                            u->allocatorFlags_ |= svm::OPENCL_SVM_BUFFER_MAP;\n                        }\n                    }\n                    clFinish(q);\n                    u->data = (uchar*)u->handle;\n                    u->markHostCopyObsolete(false);\n                    u->markDeviceMemMapped(true);\n                    return;\n                }\n#endif\n\n                cl_int retval = CL_SUCCESS;\n                if (!u->deviceMemMapped())\n                {\n                    CV_Assert(u->refcount == 1);\n                    CV_Assert(u->mapcount++ == 0);\n                    u->data = (uchar*)clEnqueueMapBuffer(q, (cl_mem)u->handle, CL_TRUE,\n                                                         (CL_MAP_READ | CL_MAP_WRITE),\n                                                         0, u->size, 0, 0, 0, &retval);\n                }\n                if (u->data && retval == CL_SUCCESS)\n                {\n                    u->markHostCopyObsolete(false);\n                    u->markDeviceMemMapped(true);\n                    return;\n                }\n\n                // TODO Is it really a good idea and was it tested well?\n                // if map failed, switch to copy-on-map mode for the particular buffer\n                u->flags |= UMatData::COPY_ON_MAP;\n            }\n\n            if(!u->data)\n            {\n                u->data = (uchar*)fastMalloc(u->size);\n                u->markHostCopyObsolete(true);\n            }\n        }\n\n        if( (accessFlags & ACCESS_READ) != 0 && u->hostCopyObsolete() )\n        {\n            AlignedDataPtr<false, true> alignedPtr(u->data, u->size, CV_OPENCL_DATA_PTR_ALIGNMENT);\n#ifdef HAVE_OPENCL_SVM\n            CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == 0);\n#endif\n            CV_Assert( clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,\n                                           u->size, alignedPtr.getAlignedPtr(), 0, 0, 0) == CL_SUCCESS );\n            u->markHostCopyObsolete(false);\n        }\n    }\n\n    void unmap(UMatData* u) const\n    {\n        if(!u)\n            return;\n\n\n        CV_Assert(u->handle != 0);\n\n        UMatDataAutoLock autolock(u);\n\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n        cl_int retval = 0;\n        if( !u->copyOnMap() && u->deviceMemMapped() )\n        {\n            CV_Assert(u->data != NULL);\n#ifdef HAVE_OPENCL_SVM\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n            {\n                if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n                {\n                    Context& ctx = Context::getDefault();\n                    const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                    CV_DbgAssert(svmFns->isValid());\n\n                    CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) != 0);\n                    {\n                        CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", u->handle);\n                        cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, u->handle,\n                                0, NULL, NULL);\n                        CV_Assert(status == CL_SUCCESS);\n                        clFinish(q);\n                        u->allocatorFlags_ &= ~svm::OPENCL_SVM_BUFFER_MAP;\n                    }\n                }\n                if (u->refcount == 0)\n                    u->data = 0;\n                u->markDeviceCopyObsolete(false);\n                u->markHostCopyObsolete(true);\n                return;\n            }\n#endif\n            if (u->refcount == 0)\n            {\n                CV_Assert(u->mapcount-- == 1);\n                CV_Assert((retval = clEnqueueUnmapMemObject(q,\n                          (cl_mem)u->handle, u->data, 0, 0, 0)) == CL_SUCCESS);\n                if (Device::getDefault().isAMD())\n                {\n                    // required for multithreaded applications (see stitching test)\n                    CV_OclDbgAssert(clFinish(q) == CL_SUCCESS);\n                }\n                u->markDeviceMemMapped(false);\n                u->data = 0;\n                u->markDeviceCopyObsolete(false);\n                u->markHostCopyObsolete(true);\n            }\n        }\n        else if( u->copyOnMap() && u->deviceCopyObsolete() )\n        {\n            AlignedDataPtr<true, false> alignedPtr(u->data, u->size, CV_OPENCL_DATA_PTR_ALIGNMENT);\n#ifdef HAVE_OPENCL_SVM\n            CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == 0);\n#endif\n            CV_Assert( (retval = clEnqueueWriteBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,\n                                u->size, alignedPtr.getAlignedPtr(), 0, 0, 0)) == CL_SUCCESS );\n            u->markDeviceCopyObsolete(false);\n            u->markHostCopyObsolete(true);\n        }\n    }\n\n    bool checkContinuous(int dims, const size_t sz[],\n                         const size_t srcofs[], const size_t srcstep[],\n                         const size_t dstofs[], const size_t dststep[],\n                         size_t& total, size_t new_sz[],\n                         size_t& srcrawofs, size_t new_srcofs[], size_t new_srcstep[],\n                         size_t& dstrawofs, size_t new_dstofs[], size_t new_dststep[]) const\n    {\n        bool iscontinuous = true;\n        srcrawofs = srcofs ? srcofs[dims-1] : 0;\n        dstrawofs = dstofs ? dstofs[dims-1] : 0;\n        total = sz[dims-1];\n        for( int i = dims-2; i >= 0; i-- )\n        {\n            if( i >= 0 && (total != srcstep[i] || total != dststep[i]) )\n                iscontinuous = false;\n            total *= sz[i];\n            if( srcofs )\n                srcrawofs += srcofs[i]*srcstep[i];\n            if( dstofs )\n                dstrawofs += dstofs[i]*dststep[i];\n        }\n\n        if( !iscontinuous )\n        {\n            // OpenCL uses {x, y, z} order while OpenCV uses {z, y, x} order.\n            if( dims == 2 )\n            {\n                new_sz[0] = sz[1]; new_sz[1] = sz[0]; new_sz[2] = 1;\n                // we assume that new_... arrays are initialized by caller\n                // with 0's, so there is no else branch\n                if( srcofs )\n                {\n                    new_srcofs[0] = srcofs[1];\n                    new_srcofs[1] = srcofs[0];\n                    new_srcofs[2] = 0;\n                }\n\n                if( dstofs )\n                {\n                    new_dstofs[0] = dstofs[1];\n                    new_dstofs[1] = dstofs[0];\n                    new_dstofs[2] = 0;\n                }\n\n                new_srcstep[0] = srcstep[0]; new_srcstep[1] = 0;\n                new_dststep[0] = dststep[0]; new_dststep[1] = 0;\n            }\n            else\n            {\n                // we could check for dims == 3 here,\n                // but from user perspective this one is more informative\n                CV_Assert(dims <= 3);\n                new_sz[0] = sz[2]; new_sz[1] = sz[1]; new_sz[2] = sz[0];\n                if( srcofs )\n                {\n                    new_srcofs[0] = srcofs[2];\n                    new_srcofs[1] = srcofs[1];\n                    new_srcofs[2] = srcofs[0];\n                }\n\n                if( dstofs )\n                {\n                    new_dstofs[0] = dstofs[2];\n                    new_dstofs[1] = dstofs[1];\n                    new_dstofs[2] = dstofs[0];\n                }\n\n                new_srcstep[0] = srcstep[1]; new_srcstep[1] = srcstep[0];\n                new_dststep[0] = dststep[1]; new_dststep[1] = dststep[0];\n            }\n        }\n        return iscontinuous;\n    }\n\n    void download(UMatData* u, void* dstptr, int dims, const size_t sz[],\n                  const size_t srcofs[], const size_t srcstep[],\n                  const size_t dststep[]) const\n    {\n        if(!u)\n            return;\n        UMatDataAutoLock autolock(u);\n\n        if( u->data && !u->hostCopyObsolete() )\n        {\n            Mat::getDefaultAllocator()->download(u, dstptr, dims, sz, srcofs, srcstep, dststep);\n            return;\n        }\n        CV_Assert( u->handle != 0 );\n\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n        size_t total = 0, new_sz[] = {0, 0, 0};\n        size_t srcrawofs = 0, new_srcofs[] = {0, 0, 0}, new_srcstep[] = {0, 0, 0};\n        size_t dstrawofs = 0, new_dstofs[] = {0, 0, 0}, new_dststep[] = {0, 0, 0};\n\n        bool iscontinuous = checkContinuous(dims, sz, srcofs, srcstep, 0, dststep,\n                                            total, new_sz,\n                                            srcrawofs, new_srcofs, new_srcstep,\n                                            dstrawofs, new_dstofs, new_dststep);\n\n#ifdef HAVE_OPENCL_SVM\n        if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n        {\n            CV_DbgAssert(u->data == NULL || u->data == u->handle);\n            Context& ctx = Context::getDefault();\n            const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n            CV_DbgAssert(svmFns->isValid());\n\n            CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) == 0);\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n            {\n                CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMap: %p (%d)\\n\", u->handle, (int)u->size);\n                cl_int status = svmFns->fn_clEnqueueSVMMap(q, CL_FALSE, CL_MAP_READ,\n                        u->handle, u->size,\n                        0, NULL, NULL);\n                CV_Assert(status == CL_SUCCESS);\n            }\n            clFinish(q);\n            if( iscontinuous )\n            {\n                memcpy(dstptr, (uchar*)u->handle + srcrawofs, total);\n            }\n            else\n            {\n                // This code is from MatAllocator::download()\n                int isz[CV_MAX_DIM];\n                uchar* srcptr = (uchar*)u->handle;\n                for( int i = 0; i < dims; i++ )\n                {\n                    CV_Assert( sz[i] <= (size_t)INT_MAX );\n                    if( sz[i] == 0 )\n                    return;\n                    if( srcofs )\n                    srcptr += srcofs[i]*(i <= dims-2 ? srcstep[i] : 1);\n                    isz[i] = (int)sz[i];\n                }\n\n                Mat src(dims, isz, CV_8U, srcptr, srcstep);\n                Mat dst(dims, isz, CV_8U, dstptr, dststep);\n\n                const Mat* arrays[] = { &src, &dst };\n                uchar* ptrs[2];\n                NAryMatIterator it(arrays, ptrs, 2);\n                size_t j, planesz = it.size;\n\n                for( j = 0; j < it.nplanes; j++, ++it )\n                    memcpy(ptrs[1], ptrs[0], planesz);\n            }\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n            {\n                CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", u->handle);\n                cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, u->handle,\n                        0, NULL, NULL);\n                CV_Assert(status == CL_SUCCESS);\n                clFinish(q);\n            }\n        }\n        else\n#endif\n        {\n            if( iscontinuous )\n            {\n                AlignedDataPtr<false, true> alignedPtr((uchar*)dstptr, total, CV_OPENCL_DATA_PTR_ALIGNMENT);\n                CV_Assert(clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE,\n                    srcrawofs, total, alignedPtr.getAlignedPtr(), 0, 0, 0) >= 0 );\n            }\n            else\n            {\n                AlignedDataPtr2D<false, true> alignedPtr((uchar*)dstptr, new_sz[1], new_sz[0], new_dststep[0], CV_OPENCL_DATA_PTR_ALIGNMENT);\n                uchar* ptr = alignedPtr.getAlignedPtr();\n\n                CV_Assert( clEnqueueReadBufferRect(q, (cl_mem)u->handle, CL_TRUE,\n                    new_srcofs, new_dstofs, new_sz,\n                    new_srcstep[0], 0,\n                    new_dststep[0], 0,\n                    ptr, 0, 0, 0) >= 0 );\n            }\n        }\n    }\n\n    void upload(UMatData* u, const void* srcptr, int dims, const size_t sz[],\n                const size_t dstofs[], const size_t dststep[],\n                const size_t srcstep[]) const\n    {\n        if(!u)\n            return;\n\n        // there should be no user-visible CPU copies of the UMat which we are going to copy to\n        CV_Assert(u->refcount == 0 || u->tempUMat());\n\n        size_t total = 0, new_sz[] = {0, 0, 0};\n        size_t srcrawofs = 0, new_srcofs[] = {0, 0, 0}, new_srcstep[] = {0, 0, 0};\n        size_t dstrawofs = 0, new_dstofs[] = {0, 0, 0}, new_dststep[] = {0, 0, 0};\n\n        bool iscontinuous = checkContinuous(dims, sz, 0, srcstep, dstofs, dststep,\n                                            total, new_sz,\n                                            srcrawofs, new_srcofs, new_srcstep,\n                                            dstrawofs, new_dstofs, new_dststep);\n\n        UMatDataAutoLock autolock(u);\n\n        // if there is cached CPU copy of the GPU matrix,\n        // we could use it as a destination.\n        // we can do it in 2 cases:\n        //    1. we overwrite the whole content\n        //    2. we overwrite part of the matrix, but the GPU copy is out-of-date\n        if( u->data && (u->hostCopyObsolete() < u->deviceCopyObsolete() || total == u->size))\n        {\n            Mat::getDefaultAllocator()->upload(u, srcptr, dims, sz, dstofs, dststep, srcstep);\n            u->markHostCopyObsolete(false);\n            u->markDeviceCopyObsolete(true);\n            return;\n        }\n\n        CV_Assert( u->handle != 0 );\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n#ifdef HAVE_OPENCL_SVM\n        if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n        {\n            CV_DbgAssert(u->data == NULL || u->data == u->handle);\n            Context& ctx = Context::getDefault();\n            const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n            CV_DbgAssert(svmFns->isValid());\n\n            CV_DbgAssert((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MAP) == 0);\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n            {\n                CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMap: %p (%d)\\n\", u->handle, (int)u->size);\n                cl_int status = svmFns->fn_clEnqueueSVMMap(q, CL_FALSE, CL_MAP_WRITE,\n                        u->handle, u->size,\n                        0, NULL, NULL);\n                CV_Assert(status == CL_SUCCESS);\n            }\n            clFinish(q);\n            if( iscontinuous )\n            {\n                memcpy((uchar*)u->handle + dstrawofs, srcptr, total);\n            }\n            else\n            {\n                // This code is from MatAllocator::upload()\n                int isz[CV_MAX_DIM];\n                uchar* dstptr = (uchar*)u->handle;\n                for( int i = 0; i < dims; i++ )\n                {\n                    CV_Assert( sz[i] <= (size_t)INT_MAX );\n                    if( sz[i] == 0 )\n                    return;\n                    if( dstofs )\n                    dstptr += dstofs[i]*(i <= dims-2 ? dststep[i] : 1);\n                    isz[i] = (int)sz[i];\n                }\n\n                Mat src(dims, isz, CV_8U, (void*)srcptr, srcstep);\n                Mat dst(dims, isz, CV_8U, dstptr, dststep);\n\n                const Mat* arrays[] = { &src, &dst };\n                uchar* ptrs[2];\n                NAryMatIterator it(arrays, ptrs, 2);\n                size_t j, planesz = it.size;\n\n                for( j = 0; j < it.nplanes; j++, ++it )\n                    memcpy(ptrs[1], ptrs[0], planesz);\n            }\n            if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_COARSE_GRAIN_BUFFER)\n            {\n                CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMUnmap: %p\\n\", u->handle);\n                cl_int status = svmFns->fn_clEnqueueSVMUnmap(q, u->handle,\n                        0, NULL, NULL);\n                CV_Assert(status == CL_SUCCESS);\n                clFinish(q);\n            }\n        }\n        else\n#endif\n        {\n            if( iscontinuous )\n            {\n                AlignedDataPtr<true, false> alignedPtr((uchar*)srcptr, total, CV_OPENCL_DATA_PTR_ALIGNMENT);\n                CV_Assert(clEnqueueWriteBuffer(q, (cl_mem)u->handle, CL_TRUE,\n                    dstrawofs, total, alignedPtr.getAlignedPtr(), 0, 0, 0) >= 0);\n            }\n            else\n            {\n                AlignedDataPtr2D<true, false> alignedPtr((uchar*)srcptr, new_sz[1], new_sz[0], new_srcstep[0], CV_OPENCL_DATA_PTR_ALIGNMENT);\n                uchar* ptr = alignedPtr.getAlignedPtr();\n\n                CV_Assert(clEnqueueWriteBufferRect(q, (cl_mem)u->handle, CL_TRUE,\n                    new_dstofs, new_srcofs, new_sz,\n                    new_dststep[0], 0,\n                    new_srcstep[0], 0,\n                    ptr, 0, 0, 0) >= 0 );\n            }\n        }\n        u->markHostCopyObsolete(true);\n#ifdef HAVE_OPENCL_SVM\n        if ((u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER ||\n                (u->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_SYSTEM)\n        {\n            // nothing\n        }\n        else\n#endif\n        {\n            u->markHostCopyObsolete(true);\n        }\n        u->markDeviceCopyObsolete(false);\n    }\n\n    void copy(UMatData* src, UMatData* dst, int dims, const size_t sz[],\n              const size_t srcofs[], const size_t srcstep[],\n              const size_t dstofs[], const size_t dststep[], bool _sync) const\n    {\n        if(!src || !dst)\n            return;\n\n        size_t total = 0, new_sz[] = {0, 0, 0};\n        size_t srcrawofs = 0, new_srcofs[] = {0, 0, 0}, new_srcstep[] = {0, 0, 0};\n        size_t dstrawofs = 0, new_dstofs[] = {0, 0, 0}, new_dststep[] = {0, 0, 0};\n\n        bool iscontinuous = checkContinuous(dims, sz, srcofs, srcstep, dstofs, dststep,\n                                            total, new_sz,\n                                            srcrawofs, new_srcofs, new_srcstep,\n                                            dstrawofs, new_dstofs, new_dststep);\n\n        UMatDataAutoLock src_autolock(src);\n        UMatDataAutoLock dst_autolock(dst);\n\n        if( !src->handle || (src->data && src->hostCopyObsolete() < src->deviceCopyObsolete()) )\n        {\n            upload(dst, src->data + srcrawofs, dims, sz, dstofs, dststep, srcstep);\n            return;\n        }\n        if( !dst->handle || (dst->data && dst->hostCopyObsolete() < dst->deviceCopyObsolete()) )\n        {\n            download(src, dst->data + dstrawofs, dims, sz, srcofs, srcstep, dststep);\n            dst->markHostCopyObsolete(false);\n#ifdef HAVE_OPENCL_SVM\n            if ((dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER ||\n                    (dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_SYSTEM)\n            {\n                // nothing\n            }\n            else\n#endif\n            {\n                dst->markDeviceCopyObsolete(true);\n            }\n            return;\n        }\n\n        // there should be no user-visible CPU copies of the UMat which we are going to copy to\n        CV_Assert(dst->refcount == 0);\n        cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n        cl_int retval = CL_SUCCESS;\n#ifdef HAVE_OPENCL_SVM\n        if ((src->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0 ||\n                (dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n        {\n            if ((src->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0 &&\n                            (dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n            {\n                Context& ctx = Context::getDefault();\n                const svm::SVMFunctions* svmFns = svm::getSVMFunctions(ctx);\n                CV_DbgAssert(svmFns->isValid());\n\n                if( iscontinuous )\n                {\n                    CV_OPENCL_SVM_TRACE_P(\"clEnqueueSVMMemcpy: %p <-- %p (%d)\\n\",\n                            (uchar*)dst->handle + dstrawofs, (uchar*)src->handle + srcrawofs, (int)total);\n                    cl_int status = svmFns->fn_clEnqueueSVMMemcpy(q, CL_TRUE,\n                            (uchar*)dst->handle + dstrawofs, (uchar*)src->handle + srcrawofs,\n                            total, 0, NULL, NULL);\n                    CV_Assert(status == CL_SUCCESS);\n                }\n                else\n                {\n                    clFinish(q);\n                    // This code is from MatAllocator::download()/upload()\n                    int isz[CV_MAX_DIM];\n                    uchar* srcptr = (uchar*)src->handle;\n                    for( int i = 0; i < dims; i++ )\n                    {\n                        CV_Assert( sz[i] <= (size_t)INT_MAX );\n                        if( sz[i] == 0 )\n                        return;\n                        if( srcofs )\n                        srcptr += srcofs[i]*(i <= dims-2 ? srcstep[i] : 1);\n                        isz[i] = (int)sz[i];\n                    }\n                    Mat m_src(dims, isz, CV_8U, srcptr, srcstep);\n\n                    uchar* dstptr = (uchar*)dst->handle;\n                    for( int i = 0; i < dims; i++ )\n                    {\n                        if( dstofs )\n                        dstptr += dstofs[i]*(i <= dims-2 ? dststep[i] : 1);\n                    }\n                    Mat m_dst(dims, isz, CV_8U, dstptr, dststep);\n\n                    const Mat* arrays[] = { &m_src, &m_dst };\n                    uchar* ptrs[2];\n                    NAryMatIterator it(arrays, ptrs, 2);\n                    size_t j, planesz = it.size;\n\n                    for( j = 0; j < it.nplanes; j++, ++it )\n                        memcpy(ptrs[1], ptrs[0], planesz);\n                }\n            }\n            else\n            {\n                if ((src->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) != 0)\n                {\n                    map(src, ACCESS_READ);\n                    upload(dst, src->data + srcrawofs, dims, sz, dstofs, dststep, srcstep);\n                    unmap(src);\n                }\n                else\n                {\n                    map(dst, ACCESS_WRITE);\n                    download(src, dst->data + dstrawofs, dims, sz, srcofs, srcstep, dststep);\n                    unmap(dst);\n                }\n            }\n        }\n        else\n#endif\n        {\n            if( iscontinuous )\n            {\n                CV_Assert( (retval = clEnqueueCopyBuffer(q, (cl_mem)src->handle, (cl_mem)dst->handle,\n                                               srcrawofs, dstrawofs, total, 0, 0, 0)) == CL_SUCCESS );\n            }\n            else\n            {\n                CV_Assert( (retval = clEnqueueCopyBufferRect(q, (cl_mem)src->handle, (cl_mem)dst->handle,\n                                                   new_srcofs, new_dstofs, new_sz,\n                                                   new_srcstep[0], 0,\n                                                   new_dststep[0], 0,\n                                                   0, 0, 0)) == CL_SUCCESS );\n            }\n        }\n        if (retval == CL_SUCCESS)\n        {\n            CV_IMPL_ADD(CV_IMPL_OCL)\n        }\n\n#ifdef HAVE_OPENCL_SVM\n        if ((dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_BUFFER ||\n            (dst->allocatorFlags_ & svm::OPENCL_SVM_BUFFER_MASK) == svm::OPENCL_SVM_FINE_GRAIN_SYSTEM)\n        {\n            // nothing\n        }\n        else\n#endif\n        {\n            dst->markHostCopyObsolete(true);\n        }\n        dst->markDeviceCopyObsolete(false);\n\n        if( _sync )\n        {\n            CV_OclDbgAssert(clFinish(q) == CL_SUCCESS);\n        }\n    }\n\n    BufferPoolController* getBufferPoolController(const char* id) const {\n#ifdef HAVE_OPENCL_SVM\n        if ((svm::checkForceSVMUmatUsage() && (id == NULL || strcmp(id, \"OCL\") == 0)) || (id != NULL && strcmp(id, \"SVM\") == 0))\n        {\n            return &bufferPoolSVM;\n        }\n#endif\n        if (id != NULL && strcmp(id, \"HOST_ALLOC\") == 0)\n        {\n            return &bufferPoolHostPtr;\n        }\n        if (id != NULL && strcmp(id, \"OCL\") != 0)\n        {\n            CV_ErrorNoReturn(cv::Error::StsBadArg, \"getBufferPoolController(): unknown BufferPool ID\\n\");\n        }\n        return &bufferPool;\n    }\n\n    MatAllocator* matStdAllocator;\n};\n\nMatAllocator* getOpenCLAllocator()\n{\n    CV_SINGLETON_LAZY_INIT(MatAllocator, new OpenCLAllocator())\n}\n\n}} // namespace cv::ocl\n\n\nnamespace cv {\n\n// three funcs below are implemented in umatrix.cpp\nvoid setSize( UMat& m, int _dims, const int* _sz, const size_t* _steps,\n              bool autoSteps = false );\n\nvoid updateContinuityFlag(UMat& m);\nvoid finalizeHdr(UMat& m);\n\n} // namespace cv\n\n\nnamespace cv { namespace ocl {\n\n/*\n// Convert OpenCL buffer memory to UMat\n*/\nvoid convertFromBuffer(void* cl_mem_buffer, size_t step, int rows, int cols, int type, UMat& dst)\n{\n    int d = 2;\n    int sizes[] = { rows, cols };\n\n    CV_Assert(0 <= d && d <= CV_MAX_DIM);\n\n    dst.release();\n\n    dst.flags      = (type & Mat::TYPE_MASK) | Mat::MAGIC_VAL;\n    dst.usageFlags = USAGE_DEFAULT;\n\n    setSize(dst, d, sizes, 0, true);\n    dst.offset = 0;\n\n    cl_mem             memobj = (cl_mem)cl_mem_buffer;\n    cl_mem_object_type mem_type = 0;\n\n    CV_Assert(clGetMemObjectInfo(memobj, CL_MEM_TYPE, sizeof(cl_mem_object_type), &mem_type, 0) == CL_SUCCESS);\n\n    CV_Assert(CL_MEM_OBJECT_BUFFER == mem_type);\n\n    size_t total = 0;\n    CV_Assert(clGetMemObjectInfo(memobj, CL_MEM_SIZE, sizeof(size_t), &total, 0) == CL_SUCCESS);\n\n    CV_Assert(clRetainMemObject(memobj) == CL_SUCCESS);\n\n    CV_Assert((int)step >= cols * CV_ELEM_SIZE(type));\n    CV_Assert(total >= rows * step);\n\n    // attach clBuffer to UMatData\n    dst.u = new UMatData(getOpenCLAllocator());\n    dst.u->data            = 0;\n    dst.u->allocatorFlags_ = 0; // not allocated from any OpenCV buffer pool\n    dst.u->flags           = 0;\n    dst.u->handle          = cl_mem_buffer;\n    dst.u->origdata        = 0;\n    dst.u->prevAllocator   = 0;\n    dst.u->size            = total;\n\n    finalizeHdr(dst);\n    dst.addref();\n\n    return;\n} // convertFromBuffer()\n\n\n/*\n// Convert OpenCL image2d_t memory to UMat\n*/\nvoid convertFromImage(void* cl_mem_image, UMat& dst)\n{\n    cl_mem             clImage = (cl_mem)cl_mem_image;\n    cl_mem_object_type mem_type = 0;\n\n    CV_Assert(clGetMemObjectInfo(clImage, CL_MEM_TYPE, sizeof(cl_mem_object_type), &mem_type, 0) == CL_SUCCESS);\n\n    CV_Assert(CL_MEM_OBJECT_IMAGE2D == mem_type);\n\n    cl_image_format fmt = { 0, 0 };\n    CV_Assert(clGetImageInfo(clImage, CL_IMAGE_FORMAT, sizeof(cl_image_format), &fmt, 0) == CL_SUCCESS);\n\n    int depth = CV_8U;\n    switch (fmt.image_channel_data_type)\n    {\n    case CL_UNORM_INT8:\n    case CL_UNSIGNED_INT8:\n        depth = CV_8U;\n        break;\n\n    case CL_SNORM_INT8:\n    case CL_SIGNED_INT8:\n        depth = CV_8S;\n        break;\n\n    case CL_UNORM_INT16:\n    case CL_UNSIGNED_INT16:\n        depth = CV_16U;\n        break;\n\n    case CL_SNORM_INT16:\n    case CL_SIGNED_INT16:\n        depth = CV_16S;\n        break;\n\n    case CL_SIGNED_INT32:\n        depth = CV_32S;\n        break;\n\n    case CL_FLOAT:\n        depth = CV_32F;\n        break;\n\n    default:\n        CV_Error(cv::Error::OpenCLApiCallError, \"Not supported image_channel_data_type\");\n    }\n\n    int type = CV_8UC1;\n    switch (fmt.image_channel_order)\n    {\n    case CL_R:\n        type = CV_MAKE_TYPE(depth, 1);\n        break;\n\n    case CL_RGBA:\n    case CL_BGRA:\n    case CL_ARGB:\n         type = CV_MAKE_TYPE(depth, 4);\n        break;\n\n    default:\n        CV_Error(cv::Error::OpenCLApiCallError, \"Not supported image_channel_order\");\n        break;\n    }\n\n    size_t step = 0;\n    CV_Assert(clGetImageInfo(clImage, CL_IMAGE_ROW_PITCH, sizeof(size_t), &step, 0) == CL_SUCCESS);\n\n    size_t w = 0;\n    CV_Assert(clGetImageInfo(clImage, CL_IMAGE_WIDTH, sizeof(size_t), &w, 0) == CL_SUCCESS);\n\n    size_t h = 0;\n    CV_Assert(clGetImageInfo(clImage, CL_IMAGE_HEIGHT, sizeof(size_t), &h, 0) == CL_SUCCESS);\n\n    dst.create((int)h, (int)w, type);\n\n    cl_mem clBuffer = (cl_mem)dst.handle(ACCESS_READ);\n\n    cl_command_queue q = (cl_command_queue)Queue::getDefault().ptr();\n\n    size_t offset = 0;\n    size_t src_origin[3] = { 0, 0, 0 };\n    size_t region[3] = { w, h, 1 };\n    CV_Assert(clEnqueueCopyImageToBuffer(q, clImage, clBuffer, src_origin, region, offset, 0, NULL, NULL) == CL_SUCCESS);\n\n    CV_Assert(clFinish(q) == CL_SUCCESS);\n\n    return;\n} // convertFromImage()\n\n\n///////////////////////////////////////////// Utility functions /////////////////////////////////////////////////\n\nstatic void getDevices(std::vector<cl_device_id>& devices, cl_platform_id platform)\n{\n    cl_uint numDevices = 0;\n    CV_OclDbgAssert(clGetDeviceIDs(platform, (cl_device_type)Device::TYPE_ALL,\n                                0, NULL, &numDevices) == CL_SUCCESS);\n\n    if (numDevices == 0)\n    {\n        devices.clear();\n        return;\n    }\n\n    devices.resize((size_t)numDevices);\n    CV_OclDbgAssert(clGetDeviceIDs(platform, (cl_device_type)Device::TYPE_ALL,\n                                numDevices, &devices[0], &numDevices) == CL_SUCCESS);\n}\n\nstruct PlatformInfo::Impl\n{\n    Impl(void* id)\n    {\n        refcount = 1;\n        handle = *(cl_platform_id*)id;\n        getDevices(devices, handle);\n    }\n\n    String getStrProp(cl_device_info prop) const\n    {\n        char buf[1024];\n        size_t sz=0;\n        return clGetPlatformInfo(handle, prop, sizeof(buf)-16, buf, &sz) == CL_SUCCESS &&\n            sz < sizeof(buf) ? String(buf) : String();\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n    std::vector<cl_device_id> devices;\n    cl_platform_id handle;\n};\n\nPlatformInfo::PlatformInfo()\n{\n    p = 0;\n}\n\nPlatformInfo::PlatformInfo(void* platform_id)\n{\n    p = new Impl(platform_id);\n}\n\nPlatformInfo::~PlatformInfo()\n{\n    if(p)\n        p->release();\n}\n\nPlatformInfo::PlatformInfo(const PlatformInfo& i)\n{\n    if (i.p)\n        i.p->addref();\n    p = i.p;\n}\n\nPlatformInfo& PlatformInfo::operator =(const PlatformInfo& i)\n{\n    if (i.p != p)\n    {\n        if (i.p)\n            i.p->addref();\n        if (p)\n            p->release();\n        p = i.p;\n    }\n    return *this;\n}\n\nint PlatformInfo::deviceNumber() const\n{\n    return p ? (int)p->devices.size() : 0;\n}\n\nvoid PlatformInfo::getDevice(Device& device, int d) const\n{\n    CV_Assert(p && d < (int)p->devices.size() );\n    if(p)\n        device.set(p->devices[d]);\n}\n\nString PlatformInfo::name() const\n{\n    return p ? p->getStrProp(CL_PLATFORM_NAME) : String();\n}\n\nString PlatformInfo::vendor() const\n{\n    return p ? p->getStrProp(CL_PLATFORM_VENDOR) : String();\n}\n\nString PlatformInfo::version() const\n{\n    return p ? p->getStrProp(CL_PLATFORM_VERSION) : String();\n}\n\nstatic void getPlatforms(std::vector<cl_platform_id>& platforms)\n{\n    cl_uint numPlatforms = 0;\n    CV_OclDbgAssert(clGetPlatformIDs(0, NULL, &numPlatforms) == CL_SUCCESS);\n\n    if (numPlatforms == 0)\n    {\n        platforms.clear();\n        return;\n    }\n\n    platforms.resize((size_t)numPlatforms);\n    CV_OclDbgAssert(clGetPlatformIDs(numPlatforms, &platforms[0], &numPlatforms) == CL_SUCCESS);\n}\n\nvoid getPlatfomsInfo(std::vector<PlatformInfo>& platformsInfo)\n{\n    std::vector<cl_platform_id> platforms;\n    getPlatforms(platforms);\n\n    for (size_t i = 0; i < platforms.size(); i++)\n        platformsInfo.push_back( PlatformInfo((void*)&platforms[i]) );\n}\n\nconst char* typeToStr(int type)\n{\n    static const char* tab[]=\n    {\n        \"uchar\", \"uchar2\", \"uchar3\", \"uchar4\", 0, 0, 0, \"uchar8\", 0, 0, 0, 0, 0, 0, 0, \"uchar16\",\n        \"char\", \"char2\", \"char3\", \"char4\", 0, 0, 0, \"char8\", 0, 0, 0, 0, 0, 0, 0, \"char16\",\n        \"ushort\", \"ushort2\", \"ushort3\", \"ushort4\",0, 0, 0, \"ushort8\", 0, 0, 0, 0, 0, 0, 0, \"ushort16\",\n        \"short\", \"short2\", \"short3\", \"short4\", 0, 0, 0, \"short8\", 0, 0, 0, 0, 0, 0, 0, \"short16\",\n        \"int\", \"int2\", \"int3\", \"int4\", 0, 0, 0, \"int8\", 0, 0, 0, 0, 0, 0, 0, \"int16\",\n        \"float\", \"float2\", \"float3\", \"float4\", 0, 0, 0, \"float8\", 0, 0, 0, 0, 0, 0, 0, \"float16\",\n        \"double\", \"double2\", \"double3\", \"double4\", 0, 0, 0, \"double8\", 0, 0, 0, 0, 0, 0, 0, \"double16\",\n        \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\"\n    };\n    int cn = CV_MAT_CN(type), depth = CV_MAT_DEPTH(type);\n    return cn > 16 ? \"?\" : tab[depth*16 + cn-1];\n}\n\nconst char* memopTypeToStr(int type)\n{\n    static const char* tab[] =\n    {\n        \"uchar\", \"uchar2\", \"uchar3\", \"uchar4\", 0, 0, 0, \"uchar8\", 0, 0, 0, 0, 0, 0, 0, \"uchar16\",\n        \"char\", \"char2\", \"char3\", \"char4\", 0, 0, 0, \"char8\", 0, 0, 0, 0, 0, 0, 0, \"char16\",\n        \"ushort\", \"ushort2\", \"ushort3\", \"ushort4\",0, 0, 0, \"ushort8\", 0, 0, 0, 0, 0, 0, 0, \"ushort16\",\n        \"short\", \"short2\", \"short3\", \"short4\", 0, 0, 0, \"short8\", 0, 0, 0, 0, 0, 0, 0, \"short16\",\n        \"int\", \"int2\", \"int3\", \"int4\", 0, 0, 0, \"int8\", 0, 0, 0, 0, 0, 0, 0, \"int16\",\n        \"int\", \"int2\", \"int3\", \"int4\", 0, 0, 0, \"int8\", 0, 0, 0, 0, 0, 0, 0, \"int16\",\n        \"ulong\", \"ulong2\", \"ulong3\", \"ulong4\", 0, 0, 0, \"ulong8\", 0, 0, 0, 0, 0, 0, 0, \"ulong16\",\n        \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\"\n    };\n    int cn = CV_MAT_CN(type), depth = CV_MAT_DEPTH(type);\n    return cn > 16 ? \"?\" : tab[depth*16 + cn-1];\n}\n\nconst char* vecopTypeToStr(int type)\n{\n    static const char* tab[] =\n    {\n        \"uchar\", \"short\", \"uchar3\", \"int\", 0, 0, 0, \"int2\", 0, 0, 0, 0, 0, 0, 0, \"int4\",\n        \"char\", \"short\", \"char3\", \"int\", 0, 0, 0, \"int2\", 0, 0, 0, 0, 0, 0, 0, \"int4\",\n        \"ushort\", \"int\", \"ushort3\", \"int2\",0, 0, 0, \"int4\", 0, 0, 0, 0, 0, 0, 0, \"int8\",\n        \"short\", \"int\", \"short3\", \"int2\", 0, 0, 0, \"int4\", 0, 0, 0, 0, 0, 0, 0, \"int8\",\n        \"int\", \"int2\", \"int3\", \"int4\", 0, 0, 0, \"int8\", 0, 0, 0, 0, 0, 0, 0, \"int16\",\n        \"int\", \"int2\", \"int3\", \"int4\", 0, 0, 0, \"int8\", 0, 0, 0, 0, 0, 0, 0, \"int16\",\n        \"ulong\", \"ulong2\", \"ulong3\", \"ulong4\", 0, 0, 0, \"ulong8\", 0, 0, 0, 0, 0, 0, 0, \"ulong16\",\n        \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\"\n    };\n    int cn = CV_MAT_CN(type), depth = CV_MAT_DEPTH(type);\n    return cn > 16 ? \"?\" : tab[depth*16 + cn-1];\n}\n\nconst char* convertTypeStr(int sdepth, int ddepth, int cn, char* buf)\n{\n    if( sdepth == ddepth )\n        return \"noconvert\";\n    const char *typestr = typeToStr(CV_MAKETYPE(ddepth, cn));\n    if( ddepth >= CV_32F ||\n        (ddepth == CV_32S && sdepth < CV_32S) ||\n        (ddepth == CV_16S && sdepth <= CV_8S) ||\n        (ddepth == CV_16U && sdepth == CV_8U))\n    {\n        sprintf(buf, \"convert_%s\", typestr);\n    }\n    else if( sdepth >= CV_32F )\n        sprintf(buf, \"convert_%s%s_rte\", typestr, (ddepth < CV_32S ? \"_sat\" : \"\"));\n    else\n        sprintf(buf, \"convert_%s_sat\", typestr);\n\n    return buf;\n}\n\ntemplate <typename T>\nstatic std::string kerToStr(const Mat & k)\n{\n    int width = k.cols - 1, depth = k.depth();\n    const T * const data = k.ptr<T>();\n\n    std::ostringstream stream;\n    stream.precision(10);\n\n    if (depth <= CV_8S)\n    {\n        for (int i = 0; i < width; ++i)\n            stream << \"DIG(\" << (int)data[i] << \")\";\n        stream << \"DIG(\" << (int)data[width] << \")\";\n    }\n    else if (depth == CV_32F)\n    {\n        stream.setf(std::ios_base::showpoint);\n        for (int i = 0; i < width; ++i)\n            stream << \"DIG(\" << data[i] << \"f)\";\n        stream << \"DIG(\" << data[width] << \"f)\";\n    }\n    else\n    {\n        for (int i = 0; i < width; ++i)\n            stream << \"DIG(\" << data[i] << \")\";\n        stream << \"DIG(\" << data[width] << \")\";\n    }\n\n    return stream.str();\n}\n\nString kernelToStr(InputArray _kernel, int ddepth, const char * name)\n{\n    Mat kernel = _kernel.getMat().reshape(1, 1);\n\n    int depth = kernel.depth();\n    if (ddepth < 0)\n        ddepth = depth;\n\n    if (ddepth != depth)\n        kernel.convertTo(kernel, ddepth);\n\n    typedef std::string (* func_t)(const Mat &);\n    static const func_t funcs[] = { kerToStr<uchar>, kerToStr<char>, kerToStr<ushort>, kerToStr<short>,\n                                    kerToStr<int>, kerToStr<float>, kerToStr<double>, 0 };\n    const func_t func = funcs[ddepth];\n    CV_Assert(func != 0);\n\n    return cv::format(\" -D %s=%s\", name ? name : \"COEFF\", func(kernel).c_str());\n}\n\n#define PROCESS_SRC(src) \\\n    do \\\n    { \\\n        if (!src.empty()) \\\n        { \\\n            CV_Assert(src.isMat() || src.isUMat()); \\\n            Size csize = src.size(); \\\n            int ctype = src.type(), ccn = CV_MAT_CN(ctype), cdepth = CV_MAT_DEPTH(ctype), \\\n                ckercn = vectorWidths[cdepth], cwidth = ccn * csize.width; \\\n            if (cwidth < ckercn || ckercn <= 0) \\\n                return 1; \\\n            cols.push_back(cwidth); \\\n            if (strat == OCL_VECTOR_OWN && ctype != ref_type) \\\n                return 1; \\\n            offsets.push_back(src.offset()); \\\n            steps.push_back(src.step()); \\\n            dividers.push_back(ckercn * CV_ELEM_SIZE1(ctype)); \\\n            kercns.push_back(ckercn); \\\n        } \\\n    } \\\n    while ((void)0, 0)\n\nint predictOptimalVectorWidth(InputArray src1, InputArray src2, InputArray src3,\n                              InputArray src4, InputArray src5, InputArray src6,\n                              InputArray src7, InputArray src8, InputArray src9,\n                              OclVectorStrategy strat)\n{\n    const ocl::Device & d = ocl::Device::getDefault();\n\n    int vectorWidths[] = { d.preferredVectorWidthChar(), d.preferredVectorWidthChar(),\n        d.preferredVectorWidthShort(), d.preferredVectorWidthShort(),\n        d.preferredVectorWidthInt(), d.preferredVectorWidthFloat(),\n        d.preferredVectorWidthDouble(), -1 };\n\n    // if the device says don't use vectors\n    if (vectorWidths[0] == 1)\n    {\n        // it's heuristic\n        vectorWidths[CV_8U] = vectorWidths[CV_8S] = 4;\n        vectorWidths[CV_16U] = vectorWidths[CV_16S] = 2;\n        vectorWidths[CV_32S] = vectorWidths[CV_32F] = vectorWidths[CV_64F] = 1;\n    }\n\n    return checkOptimalVectorWidth(vectorWidths, src1, src2, src3, src4, src5, src6, src7, src8, src9, strat);\n}\n\nint checkOptimalVectorWidth(const int *vectorWidths,\n                            InputArray src1, InputArray src2, InputArray src3,\n                            InputArray src4, InputArray src5, InputArray src6,\n                            InputArray src7, InputArray src8, InputArray src9,\n                            OclVectorStrategy strat)\n{\n    CV_Assert(vectorWidths);\n\n    int ref_type = src1.type();\n\n    std::vector<size_t> offsets, steps, cols;\n    std::vector<int> dividers, kercns;\n    PROCESS_SRC(src1);\n    PROCESS_SRC(src2);\n    PROCESS_SRC(src3);\n    PROCESS_SRC(src4);\n    PROCESS_SRC(src5);\n    PROCESS_SRC(src6);\n    PROCESS_SRC(src7);\n    PROCESS_SRC(src8);\n    PROCESS_SRC(src9);\n\n    size_t size = offsets.size();\n\n    for (size_t i = 0; i < size; ++i)\n        while (offsets[i] % dividers[i] != 0 || steps[i] % dividers[i] != 0 || cols[i] % kercns[i] != 0)\n            dividers[i] >>= 1, kercns[i] >>= 1;\n\n    // default strategy\n    int kercn = *std::min_element(kercns.begin(), kercns.end());\n\n    return kercn;\n}\n\nint predictOptimalVectorWidthMax(InputArray src1, InputArray src2, InputArray src3,\n                                 InputArray src4, InputArray src5, InputArray src6,\n                                 InputArray src7, InputArray src8, InputArray src9)\n{\n    return predictOptimalVectorWidth(src1, src2, src3, src4, src5, src6, src7, src8, src9, OCL_VECTOR_MAX);\n}\n\n#undef PROCESS_SRC\n\n\n// TODO Make this as a method of OpenCL \"BuildOptions\" class\nvoid buildOptionsAddMatrixDescription(String& buildOptions, const String& name, InputArray _m)\n{\n    if (!buildOptions.empty())\n        buildOptions += \" \";\n    int type = _m.type(), depth = CV_MAT_DEPTH(type);\n    buildOptions += format(\n            \"-D %s_T=%s -D %s_T1=%s -D %s_CN=%d -D %s_TSIZE=%d -D %s_T1SIZE=%d -D %s_DEPTH=%d\",\n            name.c_str(), ocl::typeToStr(type),\n            name.c_str(), ocl::typeToStr(CV_MAKE_TYPE(depth, 1)),\n            name.c_str(), (int)CV_MAT_CN(type),\n            name.c_str(), (int)CV_ELEM_SIZE(type),\n            name.c_str(), (int)CV_ELEM_SIZE1(type),\n            name.c_str(), (int)depth\n            );\n}\n\n\nstruct Image2D::Impl\n{\n    Impl(const UMat &src, bool norm, bool alias)\n    {\n        handle = 0;\n        refcount = 1;\n        init(src, norm, alias);\n    }\n\n    ~Impl()\n    {\n        if (handle)\n            clReleaseMemObject(handle);\n    }\n\n    static cl_image_format getImageFormat(int depth, int cn, bool norm)\n    {\n        cl_image_format format;\n        static const int channelTypes[] = { CL_UNSIGNED_INT8, CL_SIGNED_INT8, CL_UNSIGNED_INT16,\n                                       CL_SIGNED_INT16, CL_SIGNED_INT32, CL_FLOAT, -1, -1 };\n        static const int channelTypesNorm[] = { CL_UNORM_INT8, CL_SNORM_INT8, CL_UNORM_INT16,\n                                                CL_SNORM_INT16, -1, -1, -1, -1 };\n        static const int channelOrders[] = { -1, CL_R, CL_RG, -1, CL_RGBA };\n\n        int channelType = norm ? channelTypesNorm[depth] : channelTypes[depth];\n        int channelOrder = channelOrders[cn];\n        format.image_channel_data_type = (cl_channel_type)channelType;\n        format.image_channel_order = (cl_channel_order)channelOrder;\n        return format;\n    }\n\n    static bool isFormatSupported(cl_image_format format)\n    {\n        if (!haveOpenCL())\n            CV_Error(Error::OpenCLApiCallError, \"OpenCL runtime not found!\");\n\n        cl_context context = (cl_context)Context::getDefault().ptr();\n        // Figure out how many formats are supported by this context.\n        cl_uint numFormats = 0;\n        cl_int err = clGetSupportedImageFormats(context, CL_MEM_READ_WRITE,\n                                                CL_MEM_OBJECT_IMAGE2D, numFormats,\n                                                NULL, &numFormats);\n        AutoBuffer<cl_image_format> formats(numFormats);\n        err = clGetSupportedImageFormats(context, CL_MEM_READ_WRITE,\n                                         CL_MEM_OBJECT_IMAGE2D, numFormats,\n                                         formats, NULL);\n        CV_OclDbgAssert(err == CL_SUCCESS);\n        for (cl_uint i = 0; i < numFormats; ++i)\n        {\n            if (!memcmp(&formats[i], &format, sizeof(format)))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void init(const UMat &src, bool norm, bool alias)\n    {\n        if (!haveOpenCL())\n            CV_Error(Error::OpenCLApiCallError, \"OpenCL runtime not found!\");\n\n        CV_Assert(!src.empty());\n        CV_Assert(ocl::Device::getDefault().imageSupport());\n\n        int err, depth = src.depth(), cn = src.channels();\n        CV_Assert(cn <= 4);\n        cl_image_format format = getImageFormat(depth, cn, norm);\n\n        if (!isFormatSupported(format))\n            CV_Error(Error::OpenCLApiCallError, \"Image format is not supported\");\n\n        if (alias && !src.handle(ACCESS_RW))\n            CV_Error(Error::OpenCLApiCallError, \"Incorrect UMat, handle is null\");\n\n        cl_context context = (cl_context)Context::getDefault().ptr();\n        cl_command_queue queue = (cl_command_queue)Queue::getDefault().ptr();\n\n#ifdef CL_VERSION_1_2\n        // this enables backwards portability to\n        // run on OpenCL 1.1 platform if library binaries are compiled with OpenCL 1.2 support\n        const Device & d = ocl::Device::getDefault();\n        int minor = d.deviceVersionMinor(), major = d.deviceVersionMajor();\n        CV_Assert(!alias || canCreateAlias(src));\n        if (1 < major || (1 == major && 2 <= minor))\n        {\n            cl_image_desc desc;\n            desc.image_type       = CL_MEM_OBJECT_IMAGE2D;\n            desc.image_width      = src.cols;\n            desc.image_height     = src.rows;\n            desc.image_depth      = 0;\n            desc.image_array_size = 1;\n            desc.image_row_pitch  = alias ? src.step[0] : 0;\n            desc.image_slice_pitch = 0;\n            desc.buffer           = alias ? (cl_mem)src.handle(ACCESS_RW) : 0;\n            desc.num_mip_levels   = 0;\n            desc.num_samples      = 0;\n            handle = clCreateImage(context, CL_MEM_READ_WRITE, &format, &desc, NULL, &err);\n        }\n        else\n#endif\n        {\n            CV_SUPPRESS_DEPRECATED_START\n            CV_Assert(!alias);  // This is an OpenCL 1.2 extension\n            handle = clCreateImage2D(context, CL_MEM_READ_WRITE, &format, src.cols, src.rows, 0, NULL, &err);\n            CV_SUPPRESS_DEPRECATED_END\n        }\n        CV_OclDbgAssert(err == CL_SUCCESS);\n\n        size_t origin[] = { 0, 0, 0 };\n        size_t region[] = { static_cast<size_t>(src.cols), static_cast<size_t>(src.rows), 1 };\n\n        cl_mem devData;\n        if (!alias && !src.isContinuous())\n        {\n            devData = clCreateBuffer(context, CL_MEM_READ_ONLY, src.cols * src.rows * src.elemSize(), NULL, &err);\n            CV_OclDbgAssert(err == CL_SUCCESS);\n\n            const size_t roi[3] = {static_cast<size_t>(src.cols) * src.elemSize(), static_cast<size_t>(src.rows), 1};\n            CV_Assert(clEnqueueCopyBufferRect(queue, (cl_mem)src.handle(ACCESS_READ), devData, origin, origin,\n                roi, src.step, 0, src.cols * src.elemSize(), 0, 0, NULL, NULL) == CL_SUCCESS);\n            CV_OclDbgAssert(clFlush(queue) == CL_SUCCESS);\n        }\n        else\n        {\n            devData = (cl_mem)src.handle(ACCESS_READ);\n        }\n        CV_Assert(devData != NULL);\n\n        if (!alias)\n        {\n            CV_OclDbgAssert(clEnqueueCopyBufferToImage(queue, devData, handle, 0, origin, region, 0, NULL, 0) == CL_SUCCESS);\n            if (!src.isContinuous())\n            {\n                CV_OclDbgAssert(clFlush(queue) == CL_SUCCESS);\n                CV_OclDbgAssert(clReleaseMemObject(devData) == CL_SUCCESS);\n            }\n        }\n    }\n\n    IMPLEMENT_REFCOUNTABLE();\n\n    cl_mem handle;\n};\n\nImage2D::Image2D()\n{\n    p = NULL;\n}\n\nImage2D::Image2D(const UMat &src, bool norm, bool alias)\n{\n    p = new Impl(src, norm, alias);\n}\n\nbool Image2D::canCreateAlias(const UMat &m)\n{\n    bool ret = false;\n    const Device & d = ocl::Device::getDefault();\n    if (d.imageFromBufferSupport() && !m.empty())\n    {\n        // This is the required pitch alignment in pixels\n        uint pitchAlign = d.imagePitchAlignment();\n        if (pitchAlign && !(m.step % (pitchAlign * m.elemSize())))\n        {\n            // We don't currently handle the case where the buffer was created\n            // with CL_MEM_USE_HOST_PTR\n            if (!m.u->tempUMat())\n            {\n                ret = true;\n            }\n        }\n    }\n    return ret;\n}\n\nbool Image2D::isFormatSupported(int depth, int cn, bool norm)\n{\n    cl_image_format format = Impl::getImageFormat(depth, cn, norm);\n\n    return Impl::isFormatSupported(format);\n}\n\nImage2D::Image2D(const Image2D & i)\n{\n    p = i.p;\n    if (p)\n        p->addref();\n}\n\nImage2D & Image2D::operator = (const Image2D & i)\n{\n    if (i.p != p)\n    {\n        if (i.p)\n            i.p->addref();\n        if (p)\n            p->release();\n        p = i.p;\n    }\n    return *this;\n}\n\nImage2D::~Image2D()\n{\n    if (p)\n        p->release();\n}\n\nvoid* Image2D::ptr() const\n{\n    return p ? p->handle : 0;\n}\n\nbool internal::isPerformanceCheckBypassed()\n{\n    static bool initialized = false;\n    static bool value = false;\n    if (!initialized)\n    {\n        value = getBoolParameter(\"OPENCV_OPENCL_PERF_CHECK_BYPASS\", false);\n        initialized = true;\n    }\n    return value;\n}\n\nbool internal::isCLBuffer(UMat& u)\n{\n    void* h = u.handle(ACCESS_RW);\n    if (!h)\n        return true;\n    CV_DbgAssert(u.u->currAllocator == getOpenCLAllocator());\n#if 1\n    if ((u.u->allocatorFlags_ & 0xffff0000) != 0) // OpenCL SVM flags are stored here\n        return false;\n#else\n    cl_mem_object_type type = 0;\n    cl_int ret = clGetMemObjectInfo((cl_mem)h, CL_MEM_TYPE, sizeof(type), &type, NULL);\n    if (ret != CL_SUCCESS || type != CL_MEM_OBJECT_BUFFER)\n        return false;\n#endif\n    return true;\n}\n\n}}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/src/gl_core_3_1.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n#include \"gl_core_3_1.hpp\"\n\n#ifdef HAVE_OPENGL\n\n    #ifdef __APPLE__\n        #include <dlfcn.h>\n\n        static void* AppleGLGetProcAddress (const char* name)\n        {\n            static bool initialized = false;\n            static void * handle = NULL;\n            if (!handle)\n            {\n                if (!initialized)\n                {\n                    initialized = true;\n                    const char * const path = \"/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL\";\n\n                    handle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n                }\n                if (!handle)\n                    return NULL;\n            }\n            return dlsym(handle, name);\n        }\n    #endif // __APPLE__\n\n    #if defined(__sgi) || defined (__sun)\n        #include <dlfcn.h>\n        #include <stdio.h>\n\n        static void* SunGetProcAddress (const char* name)\n        {\n            typedef void* (func_t*)(const GLubyte*);\n\n            static void* h = 0;\n            static func_t gpa = 0;\n\n            if (!h)\n            {\n                h = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL);\n                if (!h)\n                    return 0;\n                gpa = (func_t) dlsym(h, \"glXGetProcAddress\");\n            }\n\n            return gpa ? gpa((const GLubyte*) name) : dlsym(h, name);\n        }\n    #endif // __sgi || __sun\n\n    #if defined(_WIN32)\n        #ifdef _MSC_VER\n            #pragma warning(disable: 4055)\n            #pragma warning(disable: 4054)\n        #endif\n\n        static int TestPointer(const PROC pTest)\n        {\n            if(!pTest)\n                return 0;\n\n            ptrdiff_t iTest = (ptrdiff_t) pTest;\n\n            if (iTest == 1 || iTest == 2 || iTest == 3 || iTest == -1)\n                return 0;\n\n            return 1;\n        }\n\n        static PROC WinGetProcAddress(const char* name)\n        {\n            PROC pFunc = wglGetProcAddress((LPCSTR) name);\n            if (TestPointer(pFunc))\n                return pFunc;\n\n            HMODULE glMod = GetModuleHandleA(\"OpenGL32.dll\");\n            return (PROC) GetProcAddress(glMod, (LPCSTR) name);\n        }\n    #endif // _WIN32\n\n    #if defined(_WIN32)\n        #define CV_GL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n    #elif defined(__APPLE__)\n        #define CV_GL_GET_PROC_ADDRESS(name) AppleGLGetProcAddress(name)\n    #elif defined(__sgi) || defined(__sun)\n        #define CV_GL_GET_PROC_ADDRESS(name) SunGetProcAddress(name)\n    #else // GLX\n        #include <GL/glx.h>\n\n        #define CV_GL_GET_PROC_ADDRESS(name) glXGetProcAddressARB((const GLubyte*) name)\n    #endif\n\n    static void* IntGetProcAddress(const char* name)\n    {\n        void* func =  (void*) CV_GL_GET_PROC_ADDRESS(name);\n        if (!func)\n        {\n            CV_Error(cv::Error::OpenGlApiCallError, cv::format(\"Can't load OpenGL extension [%s]\", name) );\n        }\n        return func;\n    }\n#else\n    static void* IntGetProcAddress(const char*)\n    {\n        CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n        return 0;\n    }\n#endif\n\nnamespace gl\n{\n    //////////////////////////////////////////////\n    // Function pointer types\n\n    // Extension: 1.1\n    typedef void (CODEGEN_FUNCPTR *PFNCULLFACEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFRONTFACEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNHINTPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLINEWIDTHPROC)(GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTSIZEPROC)(GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOLYGONMODEPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSCISSORPROC)(GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERFPROC)(GLenum , GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERFVPROC)(GLenum , GLenum , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIPROC)(GLenum , GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIVPROC)(GLenum , GLenum , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLint , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXIMAGE2DPROC)(GLenum , GLint , GLint , GLsizei , GLsizei , GLint , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARPROC)(GLbitfield );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARCOLORPROC)(GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARSTENCILPROC)(GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARDEPTHPROC)(GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILMASKPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORMASKPROC)(GLboolean , GLboolean , GLboolean , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHMASKPROC)(GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFINISHPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNFLUSHPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDFUNCPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLOGICOPPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILFUNCPROC)(GLenum , GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILOPPROC)(GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHFUNCPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNPIXELSTOREFPROC)(GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPIXELSTOREIPROC)(GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNREADBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNREADPIXELSPROC)(GLint , GLint , GLsizei , GLsizei , GLenum , GLenum , GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBOOLEANVPROC)(GLenum , GLboolean *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETDOUBLEVPROC)(GLenum , GLdouble *);\n    typedef GLenum (CODEGEN_FUNCPTR *PFNGETERRORPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNGETFLOATVPROC)(GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETINTEGERVPROC)(GLenum , GLint *);\n    typedef const GLubyte * (CODEGEN_FUNCPTR *PFNGETSTRINGPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXIMAGEPROC)(GLenum , GLint , GLenum , GLenum , GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERFVPROC)(GLenum , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXLEVELPARAMETERFVPROC)(GLenum , GLint , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXLEVELPARAMETERIVPROC)(GLenum , GLint , GLenum , GLint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISENABLEDPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHRANGEPROC)(GLdouble , GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNVIEWPORTPROC)(GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWARRAYSPROC)(GLenum , GLint , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWELEMENTSPROC)(GLenum , GLsizei , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPOINTERVPROC)(GLenum , GLvoid* *);\n    typedef void (CODEGEN_FUNCPTR *PFNPOLYGONOFFSETPROC)(GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXIMAGE1DPROC)(GLenum , GLint , GLenum , GLint , GLint , GLsizei , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXIMAGE2DPROC)(GLenum , GLint , GLenum , GLint , GLint , GLsizei , GLsizei , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLsizei , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDTEXTUREPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETETEXTURESPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENTEXTURESPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISTEXTUREPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNINDEXUBPROC)(GLubyte );\n    typedef void (CODEGEN_FUNCPTR *PFNINDEXUBVPROC)(const GLubyte *);\n\n    // Extension: 1.2\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDCOLORPROC)(GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDEQUATIONPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWRANGEELEMENTSPROC)(GLenum , GLuint , GLuint , GLsizei , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei , GLsizei , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLint , GLint , GLsizei , GLsizei );\n\n    // Extension: 1.3\n    typedef void (CODEGEN_FUNCPTR *PFNACTIVETEXTUREPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSAMPLECOVERAGEPROC)(GLfloat , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE3DPROC)(GLenum , GLint , GLenum , GLsizei , GLsizei , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE2DPROC)(GLenum , GLint , GLenum , GLsizei , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE1DPROC)(GLenum , GLint , GLenum , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei , GLsizei , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLsizei , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETCOMPRESSEDTEXIMAGEPROC)(GLenum , GLint , GLvoid *);\n\n    // Extension: 1.4\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDFUNCSEPARATEPROC)(GLenum , GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNMULTIDRAWARRAYSPROC)(GLenum , const GLint *, const GLsizei *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNMULTIDRAWELEMENTSPROC)(GLenum , const GLsizei *, GLenum , const GLvoid* const *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERFPROC)(GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERFVPROC)(GLenum , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERIPROC)(GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERIVPROC)(GLenum , const GLint *);\n\n    // Extension: 1.5\n    typedef void (CODEGEN_FUNCPTR *PFNGENQUERIESPROC)(GLsizei , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEQUERIESPROC)(GLsizei , const GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISQUERYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINQUERYPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNENDQUERYPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYOBJECTIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYOBJECTUIVPROC)(GLuint , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENBUFFERSPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBUFFERDATAPROC)(GLenum , GLsizeiptr , const GLvoid *, GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBUFFERSUBDATAPROC)(GLenum , GLintptr , GLsizeiptr , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERSUBDATAPROC)(GLenum , GLintptr , GLsizeiptr , GLvoid *);\n    typedef GLvoid* (CODEGEN_FUNCPTR *PFNMAPBUFFERPROC)(GLenum , GLenum );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNUNMAPBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERPOINTERVPROC)(GLenum , GLenum , GLvoid* *);\n\n    // Extension: 2.0\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDEQUATIONSEPARATEPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWBUFFERSPROC)(GLsizei , const GLenum *);\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILOPSEPARATEPROC)(GLenum , GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILFUNCSEPARATEPROC)(GLenum , GLenum , GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILMASKSEPARATEPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNATTACHSHADERPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDATTRIBLOCATIONPROC)(GLuint , GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPILESHADERPROC)(GLuint );\n    typedef GLuint (CODEGEN_FUNCPTR *PFNCREATEPROGRAMPROC)();\n    typedef GLuint (CODEGEN_FUNCPTR *PFNCREATESHADERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETESHADERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDETACHSHADERPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEVERTEXATTRIBARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEVERTEXATTRIBARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEATTRIBPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLint *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLint *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETATTACHEDSHADERSPROC)(GLuint , GLsizei , GLsizei *, GLuint *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETATTRIBLOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPROGRAMIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPROGRAMINFOLOGPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERINFOLOGPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERSOURCEPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETUNIFORMLOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMFVPROC)(GLuint , GLint , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMIVPROC)(GLuint , GLint , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBDVPROC)(GLuint , GLenum , GLdouble *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBFVPROC)(GLuint , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBPOINTERVPROC)(GLuint , GLenum , GLvoid* *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISPROGRAMPROC)(GLuint );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISSHADERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNLINKPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSHADERSOURCEPROC)(GLuint , GLsizei , const GLchar* const *, const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUSEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1FPROC)(GLint , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2FPROC)(GLint , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3FPROC)(GLint , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4FPROC)(GLint , GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1IPROC)(GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2IPROC)(GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3IPROC)(GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4IPROC)(GLint , GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNVALIDATEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBPOINTERPROC)(GLuint , GLint , GLenum , GLboolean , GLsizei , const GLvoid *);\n\n    // Extension: 2.1\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2X3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3X2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2X4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4X2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3X4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4X3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n\n    // Extension: ARB_vertex_array_object\n    typedef void (CODEGEN_FUNCPTR *PFNBINDVERTEXARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEVERTEXARRAYSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENVERTEXARRAYSPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISVERTEXARRAYPROC)(GLuint );\n\n    // Extension: ARB_map_buffer_range\n    typedef GLvoid* (CODEGEN_FUNCPTR *PFNMAPBUFFERRANGEPROC)(GLenum , GLintptr , GLsizeiptr , GLbitfield );\n    typedef void (CODEGEN_FUNCPTR *PFNFLUSHMAPPEDBUFFERRANGEPROC)(GLenum , GLintptr , GLsizeiptr );\n\n    // Extension: ARB_framebuffer_object\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISRENDERBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDRENDERBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETERENDERBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENRENDERBUFFERSPROC)(GLsizei , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNRENDERBUFFERSTORAGEPROC)(GLenum , GLenum , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNGETRENDERBUFFERPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISFRAMEBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDFRAMEBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEFRAMEBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENFRAMEBUFFERSPROC)(GLsizei , GLuint *);\n    typedef GLenum (CODEGEN_FUNCPTR *PFNCHECKFRAMEBUFFERSTATUSPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE1DPROC)(GLenum , GLenum , GLenum , GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE2DPROC)(GLenum , GLenum , GLenum , GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE3DPROC)(GLenum , GLenum , GLenum , GLuint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERRENDERBUFFERPROC)(GLenum , GLenum , GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum , GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENERATEMIPMAPPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBLITFRAMEBUFFERPROC)(GLint , GLint , GLint , GLint , GLint , GLint , GLint , GLint , GLbitfield , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum , GLsizei , GLenum , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURELAYERPROC)(GLenum , GLenum , GLuint , GLint , GLint );\n\n    // Extension: 3.0\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORMASKIPROC)(GLuint , GLboolean , GLboolean , GLboolean , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNGETBOOLEANI_VPROC)(GLenum , GLuint , GLboolean *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETINTEGERI_VPROC)(GLenum , GLuint , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEIPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEIPROC)(GLenum , GLuint );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISENABLEDIPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINTRANSFORMFEEDBACKPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENDTRANSFORMFEEDBACKPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERRANGEPROC)(GLenum , GLuint , GLuint , GLintptr , GLsizeiptr );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERBASEPROC)(GLenum , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNTRANSFORMFEEDBACKVARYINGSPROC)(GLuint , GLsizei , const GLchar* const *, GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLsizei *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLAMPCOLORPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINCONDITIONALRENDERPROC)(GLuint , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENDCONDITIONALRENDERPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBIPOINTERPROC)(GLuint , GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIUIVPROC)(GLuint , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1IPROC)(GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2IPROC)(GLuint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3IPROC)(GLuint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4IPROC)(GLuint , GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1UIPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2UIPROC)(GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3UIPROC)(GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UIPROC)(GLuint , GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4BVPROC)(GLuint , const GLbyte *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4SVPROC)(GLuint , const GLshort *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UBVPROC)(GLuint , const GLubyte *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4USVPROC)(GLuint , const GLushort *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMUIVPROC)(GLuint , GLint , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDFRAGDATALOCATIONPROC)(GLuint , GLuint , const GLchar *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETFRAGDATALOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1UIPROC)(GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2UIPROC)(GLint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3UIPROC)(GLint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4UIPROC)(GLint , GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIIVPROC)(GLenum , GLenum , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIUIVPROC)(GLenum , GLenum , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIUIVPROC)(GLenum , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERIVPROC)(GLenum , GLint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERUIVPROC)(GLenum , GLint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERFVPROC)(GLenum , GLint , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERFIPROC)(GLenum , GLint , GLfloat , GLint );\n    typedef const GLubyte * (CODEGEN_FUNCPTR *PFNGETSTRINGIPROC)(GLenum , GLuint );\n\n    // Extension: ARB_uniform_buffer_object\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMINDICESPROC)(GLuint , GLsizei , const GLchar* const *, GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMSIVPROC)(GLuint , GLsizei , const GLuint *, GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMNAMEPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef GLuint (CODEGEN_FUNCPTR *PFNGETUNIFORMBLOCKINDEXPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMBLOCKIVPROC)(GLuint , GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMBLOCKBINDINGPROC)(GLuint , GLuint , GLuint );\n\n    // Extension: ARB_copy_buffer\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYBUFFERSUBDATAPROC)(GLenum , GLenum , GLintptr , GLintptr , GLsizeiptr );\n\n    // Extension: 3.1\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWARRAYSINSTANCEDPROC)(GLenum , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWELEMENTSINSTANCEDPROC)(GLenum , GLsizei , GLenum , const GLvoid *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXBUFFERPROC)(GLenum , GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNPRIMITIVERESTARTINDEXPROC)(GLuint );\n\n    // Legacy\n    typedef void (CODEGEN_FUNCPTR *PFNENABLECLIENTSTATEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLECLIENTSTATEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNNORMALPOINTERPROC)(GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXCOORDPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXENVIPROC)(GLenum , GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNMATRIXMODEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLOADIDENTITYPROC)(void);\n    typedef void (CODEGEN_FUNCPTR *PFNORTHOPROC)(GLdouble , GLdouble , GLdouble , GLdouble , GLdouble , GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNCOLOR3DPROC)(GLdouble , GLdouble , GLdouble );\n\n    //////////////////////////////////////////////\n    // Function pointers\n\n    // Extension: 1.1\n    PFNCULLFACEPROC CullFace;\n    PFNFRONTFACEPROC FrontFace;\n    PFNHINTPROC Hint;\n    PFNLINEWIDTHPROC LineWidth;\n    PFNPOINTSIZEPROC PointSize;\n    PFNPOLYGONMODEPROC PolygonMode;\n    PFNSCISSORPROC Scissor;\n    PFNTEXPARAMETERFPROC TexParameterf;\n    PFNTEXPARAMETERFVPROC TexParameterfv;\n    PFNTEXPARAMETERIPROC TexParameteri;\n    PFNTEXPARAMETERIVPROC TexParameteriv;\n    PFNTEXIMAGE1DPROC TexImage1D;\n    PFNTEXIMAGE2DPROC TexImage2D;\n    PFNDRAWBUFFERPROC DrawBuffer;\n    PFNCLEARPROC Clear;\n    PFNCLEARCOLORPROC ClearColor;\n    PFNCLEARSTENCILPROC ClearStencil;\n    PFNCLEARDEPTHPROC ClearDepth;\n    PFNSTENCILMASKPROC StencilMask;\n    PFNCOLORMASKPROC ColorMask;\n    PFNDEPTHMASKPROC DepthMask;\n    PFNDISABLEPROC Disable;\n    PFNENABLEPROC Enable;\n    PFNFINISHPROC Finish;\n    PFNFLUSHPROC Flush;\n    PFNBLENDFUNCPROC BlendFunc;\n    PFNLOGICOPPROC LogicOp;\n    PFNSTENCILFUNCPROC StencilFunc;\n    PFNSTENCILOPPROC StencilOp;\n    PFNDEPTHFUNCPROC DepthFunc;\n    PFNPIXELSTOREFPROC PixelStoref;\n    PFNPIXELSTOREIPROC PixelStorei;\n    PFNREADBUFFERPROC ReadBuffer;\n    PFNREADPIXELSPROC ReadPixels;\n    PFNGETBOOLEANVPROC GetBooleanv;\n    PFNGETDOUBLEVPROC GetDoublev;\n    PFNGETERRORPROC GetError;\n    PFNGETFLOATVPROC GetFloatv;\n    PFNGETINTEGERVPROC GetIntegerv;\n    PFNGETSTRINGPROC GetString;\n    PFNGETTEXIMAGEPROC GetTexImage;\n    PFNGETTEXPARAMETERFVPROC GetTexParameterfv;\n    PFNGETTEXPARAMETERIVPROC GetTexParameteriv;\n    PFNGETTEXLEVELPARAMETERFVPROC GetTexLevelParameterfv;\n    PFNGETTEXLEVELPARAMETERIVPROC GetTexLevelParameteriv;\n    PFNISENABLEDPROC IsEnabled;\n    PFNDEPTHRANGEPROC DepthRange;\n    PFNVIEWPORTPROC Viewport;\n    PFNDRAWARRAYSPROC DrawArrays;\n    PFNDRAWELEMENTSPROC DrawElements;\n    PFNGETPOINTERVPROC GetPointerv;\n    PFNPOLYGONOFFSETPROC PolygonOffset;\n    PFNCOPYTEXIMAGE1DPROC CopyTexImage1D;\n    PFNCOPYTEXIMAGE2DPROC CopyTexImage2D;\n    PFNCOPYTEXSUBIMAGE1DPROC CopyTexSubImage1D;\n    PFNCOPYTEXSUBIMAGE2DPROC CopyTexSubImage2D;\n    PFNTEXSUBIMAGE1DPROC TexSubImage1D;\n    PFNTEXSUBIMAGE2DPROC TexSubImage2D;\n    PFNBINDTEXTUREPROC BindTexture;\n    PFNDELETETEXTURESPROC DeleteTextures;\n    PFNGENTEXTURESPROC GenTextures;\n    PFNISTEXTUREPROC IsTexture;\n    PFNINDEXUBPROC Indexub;\n    PFNINDEXUBVPROC Indexubv;\n\n    // Extension: 1.2\n    PFNBLENDCOLORPROC BlendColor;\n    PFNBLENDEQUATIONPROC BlendEquation;\n    PFNDRAWRANGEELEMENTSPROC DrawRangeElements;\n    PFNTEXSUBIMAGE3DPROC TexSubImage3D;\n    PFNCOPYTEXSUBIMAGE3DPROC CopyTexSubImage3D;\n\n    // Extension: 1.3\n    PFNACTIVETEXTUREPROC ActiveTexture;\n    PFNSAMPLECOVERAGEPROC SampleCoverage;\n    PFNCOMPRESSEDTEXIMAGE3DPROC CompressedTexImage3D;\n    PFNCOMPRESSEDTEXIMAGE2DPROC CompressedTexImage2D;\n    PFNCOMPRESSEDTEXIMAGE1DPROC CompressedTexImage1D;\n    PFNCOMPRESSEDTEXSUBIMAGE3DPROC CompressedTexSubImage3D;\n    PFNCOMPRESSEDTEXSUBIMAGE2DPROC CompressedTexSubImage2D;\n    PFNCOMPRESSEDTEXSUBIMAGE1DPROC CompressedTexSubImage1D;\n    PFNGETCOMPRESSEDTEXIMAGEPROC GetCompressedTexImage;\n\n    // Extension: 1.4\n    PFNBLENDFUNCSEPARATEPROC BlendFuncSeparate;\n    PFNMULTIDRAWARRAYSPROC MultiDrawArrays;\n    PFNMULTIDRAWELEMENTSPROC MultiDrawElements;\n    PFNPOINTPARAMETERFPROC PointParameterf;\n    PFNPOINTPARAMETERFVPROC PointParameterfv;\n    PFNPOINTPARAMETERIPROC PointParameteri;\n    PFNPOINTPARAMETERIVPROC PointParameteriv;\n\n    // Extension: 1.5\n    PFNGENQUERIESPROC GenQueries;\n    PFNDELETEQUERIESPROC DeleteQueries;\n    PFNISQUERYPROC IsQuery;\n    PFNBEGINQUERYPROC BeginQuery;\n    PFNENDQUERYPROC EndQuery;\n    PFNGETQUERYIVPROC GetQueryiv;\n    PFNGETQUERYOBJECTIVPROC GetQueryObjectiv;\n    PFNGETQUERYOBJECTUIVPROC GetQueryObjectuiv;\n    PFNBINDBUFFERPROC BindBuffer;\n    PFNDELETEBUFFERSPROC DeleteBuffers;\n    PFNGENBUFFERSPROC GenBuffers;\n    PFNISBUFFERPROC IsBuffer;\n    PFNBUFFERDATAPROC BufferData;\n    PFNBUFFERSUBDATAPROC BufferSubData;\n    PFNGETBUFFERSUBDATAPROC GetBufferSubData;\n    PFNMAPBUFFERPROC MapBuffer;\n    PFNUNMAPBUFFERPROC UnmapBuffer;\n    PFNGETBUFFERPARAMETERIVPROC GetBufferParameteriv;\n    PFNGETBUFFERPOINTERVPROC GetBufferPointerv;\n\n    // Extension: 2.0\n    PFNBLENDEQUATIONSEPARATEPROC BlendEquationSeparate;\n    PFNDRAWBUFFERSPROC DrawBuffers;\n    PFNSTENCILOPSEPARATEPROC StencilOpSeparate;\n    PFNSTENCILFUNCSEPARATEPROC StencilFuncSeparate;\n    PFNSTENCILMASKSEPARATEPROC StencilMaskSeparate;\n    PFNATTACHSHADERPROC AttachShader;\n    PFNBINDATTRIBLOCATIONPROC BindAttribLocation;\n    PFNCOMPILESHADERPROC CompileShader;\n    PFNCREATEPROGRAMPROC CreateProgram;\n    PFNCREATESHADERPROC CreateShader;\n    PFNDELETEPROGRAMPROC DeleteProgram;\n    PFNDELETESHADERPROC DeleteShader;\n    PFNDETACHSHADERPROC DetachShader;\n    PFNDISABLEVERTEXATTRIBARRAYPROC DisableVertexAttribArray;\n    PFNENABLEVERTEXATTRIBARRAYPROC EnableVertexAttribArray;\n    PFNGETACTIVEATTRIBPROC GetActiveAttrib;\n    PFNGETACTIVEUNIFORMPROC GetActiveUniform;\n    PFNGETATTACHEDSHADERSPROC GetAttachedShaders;\n    PFNGETATTRIBLOCATIONPROC GetAttribLocation;\n    PFNGETPROGRAMIVPROC GetProgramiv;\n    PFNGETPROGRAMINFOLOGPROC GetProgramInfoLog;\n    PFNGETSHADERIVPROC GetShaderiv;\n    PFNGETSHADERINFOLOGPROC GetShaderInfoLog;\n    PFNGETSHADERSOURCEPROC GetShaderSource;\n    PFNGETUNIFORMLOCATIONPROC GetUniformLocation;\n    PFNGETUNIFORMFVPROC GetUniformfv;\n    PFNGETUNIFORMIVPROC GetUniformiv;\n    PFNGETVERTEXATTRIBDVPROC GetVertexAttribdv;\n    PFNGETVERTEXATTRIBFVPROC GetVertexAttribfv;\n    PFNGETVERTEXATTRIBIVPROC GetVertexAttribiv;\n    PFNGETVERTEXATTRIBPOINTERVPROC GetVertexAttribPointerv;\n    PFNISPROGRAMPROC IsProgram;\n    PFNISSHADERPROC IsShader;\n    PFNLINKPROGRAMPROC LinkProgram;\n    PFNSHADERSOURCEPROC ShaderSource;\n    PFNUSEPROGRAMPROC UseProgram;\n    PFNUNIFORM1FPROC Uniform1f;\n    PFNUNIFORM2FPROC Uniform2f;\n    PFNUNIFORM3FPROC Uniform3f;\n    PFNUNIFORM4FPROC Uniform4f;\n    PFNUNIFORM1IPROC Uniform1i;\n    PFNUNIFORM2IPROC Uniform2i;\n    PFNUNIFORM3IPROC Uniform3i;\n    PFNUNIFORM4IPROC Uniform4i;\n    PFNUNIFORM1FVPROC Uniform1fv;\n    PFNUNIFORM2FVPROC Uniform2fv;\n    PFNUNIFORM3FVPROC Uniform3fv;\n    PFNUNIFORM4FVPROC Uniform4fv;\n    PFNUNIFORM1IVPROC Uniform1iv;\n    PFNUNIFORM2IVPROC Uniform2iv;\n    PFNUNIFORM3IVPROC Uniform3iv;\n    PFNUNIFORM4IVPROC Uniform4iv;\n    PFNUNIFORMMATRIX2FVPROC UniformMatrix2fv;\n    PFNUNIFORMMATRIX3FVPROC UniformMatrix3fv;\n    PFNUNIFORMMATRIX4FVPROC UniformMatrix4fv;\n    PFNVALIDATEPROGRAMPROC ValidateProgram;\n    PFNVERTEXATTRIBPOINTERPROC VertexAttribPointer;\n\n    // Extension: 2.1\n    PFNUNIFORMMATRIX2X3FVPROC UniformMatrix2x3fv;\n    PFNUNIFORMMATRIX3X2FVPROC UniformMatrix3x2fv;\n    PFNUNIFORMMATRIX2X4FVPROC UniformMatrix2x4fv;\n    PFNUNIFORMMATRIX4X2FVPROC UniformMatrix4x2fv;\n    PFNUNIFORMMATRIX3X4FVPROC UniformMatrix3x4fv;\n    PFNUNIFORMMATRIX4X3FVPROC UniformMatrix4x3fv;\n\n    // Extension: ARB_vertex_array_object\n    PFNBINDVERTEXARRAYPROC BindVertexArray;\n    PFNDELETEVERTEXARRAYSPROC DeleteVertexArrays;\n    PFNGENVERTEXARRAYSPROC GenVertexArrays;\n    PFNISVERTEXARRAYPROC IsVertexArray;\n\n    // Extension: ARB_map_buffer_range\n    PFNMAPBUFFERRANGEPROC MapBufferRange;\n    PFNFLUSHMAPPEDBUFFERRANGEPROC FlushMappedBufferRange;\n\n    // Extension: ARB_framebuffer_object\n    PFNISRENDERBUFFERPROC IsRenderbuffer;\n    PFNBINDRENDERBUFFERPROC BindRenderbuffer;\n    PFNDELETERENDERBUFFERSPROC DeleteRenderbuffers;\n    PFNGENRENDERBUFFERSPROC GenRenderbuffers;\n    PFNRENDERBUFFERSTORAGEPROC RenderbufferStorage;\n    PFNGETRENDERBUFFERPARAMETERIVPROC GetRenderbufferParameteriv;\n    PFNISFRAMEBUFFERPROC IsFramebuffer;\n    PFNBINDFRAMEBUFFERPROC BindFramebuffer;\n    PFNDELETEFRAMEBUFFERSPROC DeleteFramebuffers;\n    PFNGENFRAMEBUFFERSPROC GenFramebuffers;\n    PFNCHECKFRAMEBUFFERSTATUSPROC CheckFramebufferStatus;\n    PFNFRAMEBUFFERTEXTURE1DPROC FramebufferTexture1D;\n    PFNFRAMEBUFFERTEXTURE2DPROC FramebufferTexture2D;\n    PFNFRAMEBUFFERTEXTURE3DPROC FramebufferTexture3D;\n    PFNFRAMEBUFFERRENDERBUFFERPROC FramebufferRenderbuffer;\n    PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC GetFramebufferAttachmentParameteriv;\n    PFNGENERATEMIPMAPPROC GenerateMipmap;\n    PFNBLITFRAMEBUFFERPROC BlitFramebuffer;\n    PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC RenderbufferStorageMultisample;\n    PFNFRAMEBUFFERTEXTURELAYERPROC FramebufferTextureLayer;\n\n    // Extension: 3.0\n    PFNCOLORMASKIPROC ColorMaski;\n    PFNGETBOOLEANI_VPROC GetBooleani_v;\n    PFNGETINTEGERI_VPROC GetIntegeri_v;\n    PFNENABLEIPROC Enablei;\n    PFNDISABLEIPROC Disablei;\n    PFNISENABLEDIPROC IsEnabledi;\n    PFNBEGINTRANSFORMFEEDBACKPROC BeginTransformFeedback;\n    PFNENDTRANSFORMFEEDBACKPROC EndTransformFeedback;\n    PFNBINDBUFFERRANGEPROC BindBufferRange;\n    PFNBINDBUFFERBASEPROC BindBufferBase;\n    PFNTRANSFORMFEEDBACKVARYINGSPROC TransformFeedbackVaryings;\n    PFNGETTRANSFORMFEEDBACKVARYINGPROC GetTransformFeedbackVarying;\n    PFNCLAMPCOLORPROC ClampColor;\n    PFNBEGINCONDITIONALRENDERPROC BeginConditionalRender;\n    PFNENDCONDITIONALRENDERPROC EndConditionalRender;\n    PFNVERTEXATTRIBIPOINTERPROC VertexAttribIPointer;\n    PFNGETVERTEXATTRIBIIVPROC GetVertexAttribIiv;\n    PFNGETVERTEXATTRIBIUIVPROC GetVertexAttribIuiv;\n    PFNVERTEXATTRIBI1IPROC VertexAttribI1i;\n    PFNVERTEXATTRIBI2IPROC VertexAttribI2i;\n    PFNVERTEXATTRIBI3IPROC VertexAttribI3i;\n    PFNVERTEXATTRIBI4IPROC VertexAttribI4i;\n    PFNVERTEXATTRIBI1UIPROC VertexAttribI1ui;\n    PFNVERTEXATTRIBI2UIPROC VertexAttribI2ui;\n    PFNVERTEXATTRIBI3UIPROC VertexAttribI3ui;\n    PFNVERTEXATTRIBI4UIPROC VertexAttribI4ui;\n    PFNVERTEXATTRIBI1IVPROC VertexAttribI1iv;\n    PFNVERTEXATTRIBI2IVPROC VertexAttribI2iv;\n    PFNVERTEXATTRIBI3IVPROC VertexAttribI3iv;\n    PFNVERTEXATTRIBI4IVPROC VertexAttribI4iv;\n    PFNVERTEXATTRIBI1UIVPROC VertexAttribI1uiv;\n    PFNVERTEXATTRIBI2UIVPROC VertexAttribI2uiv;\n    PFNVERTEXATTRIBI3UIVPROC VertexAttribI3uiv;\n    PFNVERTEXATTRIBI4UIVPROC VertexAttribI4uiv;\n    PFNVERTEXATTRIBI4BVPROC VertexAttribI4bv;\n    PFNVERTEXATTRIBI4SVPROC VertexAttribI4sv;\n    PFNVERTEXATTRIBI4UBVPROC VertexAttribI4ubv;\n    PFNVERTEXATTRIBI4USVPROC VertexAttribI4usv;\n    PFNGETUNIFORMUIVPROC GetUniformuiv;\n    PFNBINDFRAGDATALOCATIONPROC BindFragDataLocation;\n    PFNGETFRAGDATALOCATIONPROC GetFragDataLocation;\n    PFNUNIFORM1UIPROC Uniform1ui;\n    PFNUNIFORM2UIPROC Uniform2ui;\n    PFNUNIFORM3UIPROC Uniform3ui;\n    PFNUNIFORM4UIPROC Uniform4ui;\n    PFNUNIFORM1UIVPROC Uniform1uiv;\n    PFNUNIFORM2UIVPROC Uniform2uiv;\n    PFNUNIFORM3UIVPROC Uniform3uiv;\n    PFNUNIFORM4UIVPROC Uniform4uiv;\n    PFNTEXPARAMETERIIVPROC TexParameterIiv;\n    PFNTEXPARAMETERIUIVPROC TexParameterIuiv;\n    PFNGETTEXPARAMETERIIVPROC GetTexParameterIiv;\n    PFNGETTEXPARAMETERIUIVPROC GetTexParameterIuiv;\n    PFNCLEARBUFFERIVPROC ClearBufferiv;\n    PFNCLEARBUFFERUIVPROC ClearBufferuiv;\n    PFNCLEARBUFFERFVPROC ClearBufferfv;\n    PFNCLEARBUFFERFIPROC ClearBufferfi;\n    PFNGETSTRINGIPROC GetStringi;\n\n    // Extension: ARB_uniform_buffer_object\n    PFNGETUNIFORMINDICESPROC GetUniformIndices;\n    PFNGETACTIVEUNIFORMSIVPROC GetActiveUniformsiv;\n    PFNGETACTIVEUNIFORMNAMEPROC GetActiveUniformName;\n    PFNGETUNIFORMBLOCKINDEXPROC GetUniformBlockIndex;\n    PFNGETACTIVEUNIFORMBLOCKIVPROC GetActiveUniformBlockiv;\n    PFNGETACTIVEUNIFORMBLOCKNAMEPROC GetActiveUniformBlockName;\n    PFNUNIFORMBLOCKBINDINGPROC UniformBlockBinding;\n\n    // Extension: ARB_copy_buffer\n    PFNCOPYBUFFERSUBDATAPROC CopyBufferSubData;\n\n    // Extension: 3.1\n    PFNDRAWARRAYSINSTANCEDPROC DrawArraysInstanced;\n    PFNDRAWELEMENTSINSTANCEDPROC DrawElementsInstanced;\n    PFNTEXBUFFERPROC TexBuffer;\n    PFNPRIMITIVERESTARTINDEXPROC PrimitiveRestartIndex;\n\n    // Legacy\n    PFNENABLECLIENTSTATEPROC EnableClientState;\n    PFNDISABLECLIENTSTATEPROC DisableClientState;\n    PFNVERTEXPOINTERPROC VertexPointer;\n    PFNNORMALPOINTERPROC NormalPointer;\n    PFNCOLORPOINTERPROC ColorPointer;\n    PFNTEXCOORDPOINTERPROC TexCoordPointer;\n\n    PFNTEXENVIPROC TexEnvi;\n\n    PFNMATRIXMODEPROC MatrixMode;\n    PFNLOADIDENTITYPROC LoadIdentity;\n    PFNORTHOPROC Ortho;\n\n    PFNCOLOR3DPROC Color3d;\n\n    //////////////////////////////////////////////\n    // Switch functions\n\n    // Extension: 1.1\n\n    static void CODEGEN_FUNCPTR Switch_CullFace(GLenum mode)\n    {\n        CullFace = (PFNCULLFACEPROC)IntGetProcAddress(\"glCullFace\");\n        CullFace(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FrontFace(GLenum mode)\n    {\n        FrontFace = (PFNFRONTFACEPROC)IntGetProcAddress(\"glFrontFace\");\n        FrontFace(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Hint(GLenum target, GLenum mode)\n    {\n        Hint = (PFNHINTPROC)IntGetProcAddress(\"glHint\");\n        Hint(target, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LineWidth(GLfloat width)\n    {\n        LineWidth = (PFNLINEWIDTHPROC)IntGetProcAddress(\"glLineWidth\");\n        LineWidth(width);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointSize(GLfloat size)\n    {\n        PointSize = (PFNPOINTSIZEPROC)IntGetProcAddress(\"glPointSize\");\n        PointSize(size);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PolygonMode(GLenum face, GLenum mode)\n    {\n        PolygonMode = (PFNPOLYGONMODEPROC)IntGetProcAddress(\"glPolygonMode\");\n        PolygonMode(face, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Scissor(GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        Scissor = (PFNSCISSORPROC)IntGetProcAddress(\"glScissor\");\n        Scissor(x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterf(GLenum target, GLenum pname, GLfloat param)\n    {\n        TexParameterf = (PFNTEXPARAMETERFPROC)IntGetProcAddress(\"glTexParameterf\");\n        TexParameterf(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)\n    {\n        TexParameterfv = (PFNTEXPARAMETERFVPROC)IntGetProcAddress(\"glTexParameterfv\");\n        TexParameterfv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameteri(GLenum target, GLenum pname, GLint param)\n    {\n        TexParameteri = (PFNTEXPARAMETERIPROC)IntGetProcAddress(\"glTexParameteri\");\n        TexParameteri(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameteriv(GLenum target, GLenum pname, const GLint *params)\n    {\n        TexParameteriv = (PFNTEXPARAMETERIVPROC)IntGetProcAddress(\"glTexParameteriv\");\n        TexParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexImage1D = (PFNTEXIMAGE1DPROC)IntGetProcAddress(\"glTexImage1D\");\n        TexImage1D(target, level, internalformat, width, border, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexImage2D = (PFNTEXIMAGE2DPROC)IntGetProcAddress(\"glTexImage2D\");\n        TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawBuffer(GLenum mode)\n    {\n        DrawBuffer = (PFNDRAWBUFFERPROC)IntGetProcAddress(\"glDrawBuffer\");\n        DrawBuffer(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Clear(GLbitfield mask)\n    {\n        Clear = (PFNCLEARPROC)IntGetProcAddress(\"glClear\");\n        Clear(mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)\n    {\n        ClearColor = (PFNCLEARCOLORPROC)IntGetProcAddress(\"glClearColor\");\n        ClearColor(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearStencil(GLint s)\n    {\n        ClearStencil = (PFNCLEARSTENCILPROC)IntGetProcAddress(\"glClearStencil\");\n        ClearStencil(s);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearDepth(GLdouble depth)\n    {\n        ClearDepth = (PFNCLEARDEPTHPROC)IntGetProcAddress(\"glClearDepth\");\n        ClearDepth(depth);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilMask(GLuint mask)\n    {\n        StencilMask = (PFNSTENCILMASKPROC)IntGetProcAddress(\"glStencilMask\");\n        StencilMask(mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)\n    {\n        ColorMask = (PFNCOLORMASKPROC)IntGetProcAddress(\"glColorMask\");\n        ColorMask(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthMask(GLboolean flag)\n    {\n        DepthMask = (PFNDEPTHMASKPROC)IntGetProcAddress(\"glDepthMask\");\n        DepthMask(flag);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Disable(GLenum cap)\n    {\n        Disable = (PFNDISABLEPROC)IntGetProcAddress(\"glDisable\");\n        Disable(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Enable(GLenum cap)\n    {\n        Enable = (PFNENABLEPROC)IntGetProcAddress(\"glEnable\");\n        Enable(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Finish()\n    {\n        Finish = (PFNFINISHPROC)IntGetProcAddress(\"glFinish\");\n        Finish();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Flush()\n    {\n        Flush = (PFNFLUSHPROC)IntGetProcAddress(\"glFlush\");\n        Flush();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlendFunc(GLenum sfactor, GLenum dfactor)\n    {\n        BlendFunc = (PFNBLENDFUNCPROC)IntGetProcAddress(\"glBlendFunc\");\n        BlendFunc(sfactor, dfactor);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LogicOp(GLenum opcode)\n    {\n        LogicOp = (PFNLOGICOPPROC)IntGetProcAddress(\"glLogicOp\");\n        LogicOp(opcode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilFunc(GLenum func, GLint ref, GLuint mask)\n    {\n        StencilFunc = (PFNSTENCILFUNCPROC)IntGetProcAddress(\"glStencilFunc\");\n        StencilFunc(func, ref, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilOp(GLenum fail, GLenum zfail, GLenum zpass)\n    {\n        StencilOp = (PFNSTENCILOPPROC)IntGetProcAddress(\"glStencilOp\");\n        StencilOp(fail, zfail, zpass);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthFunc(GLenum func)\n    {\n        DepthFunc = (PFNDEPTHFUNCPROC)IntGetProcAddress(\"glDepthFunc\");\n        DepthFunc(func);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PixelStoref(GLenum pname, GLfloat param)\n    {\n        PixelStoref = (PFNPIXELSTOREFPROC)IntGetProcAddress(\"glPixelStoref\");\n        PixelStoref(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PixelStorei(GLenum pname, GLint param)\n    {\n        PixelStorei = (PFNPIXELSTOREIPROC)IntGetProcAddress(\"glPixelStorei\");\n        PixelStorei(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ReadBuffer(GLenum mode)\n    {\n        ReadBuffer = (PFNREADBUFFERPROC)IntGetProcAddress(\"glReadBuffer\");\n        ReadBuffer(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)\n    {\n        ReadPixels = (PFNREADPIXELSPROC)IntGetProcAddress(\"glReadPixels\");\n        ReadPixels(x, y, width, height, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBooleanv(GLenum pname, GLboolean *params)\n    {\n        GetBooleanv = (PFNGETBOOLEANVPROC)IntGetProcAddress(\"glGetBooleanv\");\n        GetBooleanv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetDoublev(GLenum pname, GLdouble *params)\n    {\n        GetDoublev = (PFNGETDOUBLEVPROC)IntGetProcAddress(\"glGetDoublev\");\n        GetDoublev(pname, params);\n    }\n\n    static GLenum CODEGEN_FUNCPTR Switch_GetError()\n    {\n        GetError = (PFNGETERRORPROC)IntGetProcAddress(\"glGetError\");\n        return GetError();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetFloatv(GLenum pname, GLfloat *params)\n    {\n        GetFloatv = (PFNGETFLOATVPROC)IntGetProcAddress(\"glGetFloatv\");\n        GetFloatv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetIntegerv(GLenum pname, GLint *params)\n    {\n        GetIntegerv = (PFNGETINTEGERVPROC)IntGetProcAddress(\"glGetIntegerv\");\n        GetIntegerv(pname, params);\n    }\n\n    static const GLubyte * CODEGEN_FUNCPTR Switch_GetString(GLenum name)\n    {\n        GetString = (PFNGETSTRINGPROC)IntGetProcAddress(\"glGetString\");\n        return GetString(name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)\n    {\n        GetTexImage = (PFNGETTEXIMAGEPROC)IntGetProcAddress(\"glGetTexImage\");\n        GetTexImage(target, level, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)\n    {\n        GetTexParameterfv = (PFNGETTEXPARAMETERFVPROC)IntGetProcAddress(\"glGetTexParameterfv\");\n        GetTexParameterfv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetTexParameteriv = (PFNGETTEXPARAMETERIVPROC)IntGetProcAddress(\"glGetTexParameteriv\");\n        GetTexParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)\n    {\n        GetTexLevelParameterfv = (PFNGETTEXLEVELPARAMETERFVPROC)IntGetProcAddress(\"glGetTexLevelParameterfv\");\n        GetTexLevelParameterfv(target, level, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)\n    {\n        GetTexLevelParameteriv = (PFNGETTEXLEVELPARAMETERIVPROC)IntGetProcAddress(\"glGetTexLevelParameteriv\");\n        GetTexLevelParameteriv(target, level, pname, params);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsEnabled(GLenum cap)\n    {\n        IsEnabled = (PFNISENABLEDPROC)IntGetProcAddress(\"glIsEnabled\");\n        return IsEnabled(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthRange(GLdouble ren_near, GLdouble ren_far)\n    {\n        DepthRange = (PFNDEPTHRANGEPROC)IntGetProcAddress(\"glDepthRange\");\n        DepthRange(ren_near, ren_far);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Viewport(GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        Viewport = (PFNVIEWPORTPROC)IntGetProcAddress(\"glViewport\");\n        Viewport(x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawArrays(GLenum mode, GLint first, GLsizei count)\n    {\n        DrawArrays = (PFNDRAWARRAYSPROC)IntGetProcAddress(\"glDrawArrays\");\n        DrawArrays(mode, first, count);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)\n    {\n        DrawElements = (PFNDRAWELEMENTSPROC)IntGetProcAddress(\"glDrawElements\");\n        DrawElements(mode, count, type, indices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetPointerv(GLenum pname, GLvoid* *params)\n    {\n        GetPointerv = (PFNGETPOINTERVPROC)IntGetProcAddress(\"glGetPointerv\");\n        GetPointerv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PolygonOffset(GLfloat factor, GLfloat units)\n    {\n        PolygonOffset = (PFNPOLYGONOFFSETPROC)IntGetProcAddress(\"glPolygonOffset\");\n        PolygonOffset(factor, units);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)\n    {\n        CopyTexImage1D = (PFNCOPYTEXIMAGE1DPROC)IntGetProcAddress(\"glCopyTexImage1D\");\n        CopyTexImage1D(target, level, internalformat, x, y, width, border);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)\n    {\n        CopyTexImage2D = (PFNCOPYTEXIMAGE2DPROC)IntGetProcAddress(\"glCopyTexImage2D\");\n        CopyTexImage2D(target, level, internalformat, x, y, width, height, border);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)\n    {\n        CopyTexSubImage1D = (PFNCOPYTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glCopyTexSubImage1D\");\n        CopyTexSubImage1D(target, level, xoffset, x, y, width);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        CopyTexSubImage2D = (PFNCOPYTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glCopyTexSubImage2D\");\n        CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage1D = (PFNTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glTexSubImage1D\");\n        TexSubImage1D(target, level, xoffset, width, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage2D = (PFNTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glTexSubImage2D\");\n        TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindTexture(GLenum target, GLuint texture)\n    {\n        BindTexture = (PFNBINDTEXTUREPROC)IntGetProcAddress(\"glBindTexture\");\n        BindTexture(target, texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteTextures(GLsizei n, const GLuint *textures)\n    {\n        DeleteTextures = (PFNDELETETEXTURESPROC)IntGetProcAddress(\"glDeleteTextures\");\n        DeleteTextures(n, textures);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenTextures(GLsizei n, GLuint *textures)\n    {\n        GenTextures = (PFNGENTEXTURESPROC)IntGetProcAddress(\"glGenTextures\");\n        GenTextures(n, textures);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsTexture(GLuint texture)\n    {\n        IsTexture = (PFNISTEXTUREPROC)IntGetProcAddress(\"glIsTexture\");\n        return IsTexture(texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Indexub(GLubyte c)\n    {\n        Indexub = (PFNINDEXUBPROC)IntGetProcAddress(\"glIndexub\");\n        Indexub(c);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Indexubv(const GLubyte *c)\n    {\n        Indexubv = (PFNINDEXUBVPROC)IntGetProcAddress(\"glIndexubv\");\n        Indexubv(c);\n    }\n\n    // Extension: 1.2\n\n    static void CODEGEN_FUNCPTR Switch_BlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)\n    {\n        BlendColor = (PFNBLENDCOLORPROC)IntGetProcAddress(\"glBlendColor\");\n        BlendColor(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlendEquation(GLenum mode)\n    {\n        BlendEquation = (PFNBLENDEQUATIONPROC)IntGetProcAddress(\"glBlendEquation\");\n        BlendEquation(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)\n    {\n        DrawRangeElements = (PFNDRAWRANGEELEMENTSPROC)IntGetProcAddress(\"glDrawRangeElements\");\n        DrawRangeElements(mode, start, end, count, type, indices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage3D = (PFNTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glTexSubImage3D\");\n        TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        CopyTexSubImage3D = (PFNCOPYTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glCopyTexSubImage3D\");\n        CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);\n    }\n\n    // Extension: 1.3\n\n    static void CODEGEN_FUNCPTR Switch_ActiveTexture(GLenum texture)\n    {\n        ActiveTexture = (PFNACTIVETEXTUREPROC)IntGetProcAddress(\"glActiveTexture\");\n        ActiveTexture(texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_SampleCoverage(GLfloat value, GLboolean invert)\n    {\n        SampleCoverage = (PFNSAMPLECOVERAGEPROC)IntGetProcAddress(\"glSampleCoverage\");\n        SampleCoverage(value, invert);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage3D = (PFNCOMPRESSEDTEXIMAGE3DPROC)IntGetProcAddress(\"glCompressedTexImage3D\");\n        CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage2D = (PFNCOMPRESSEDTEXIMAGE2DPROC)IntGetProcAddress(\"glCompressedTexImage2D\");\n        CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage1D = (PFNCOMPRESSEDTEXIMAGE1DPROC)IntGetProcAddress(\"glCompressedTexImage1D\");\n        CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage3D = (PFNCOMPRESSEDTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glCompressedTexSubImage3D\");\n        CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage2D = (PFNCOMPRESSEDTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glCompressedTexSubImage2D\");\n        CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage1D = (PFNCOMPRESSEDTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glCompressedTexSubImage1D\");\n        CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetCompressedTexImage(GLenum target, GLint level, GLvoid *img)\n    {\n        GetCompressedTexImage = (PFNGETCOMPRESSEDTEXIMAGEPROC)IntGetProcAddress(\"glGetCompressedTexImage\");\n        GetCompressedTexImage(target, level, img);\n    }\n\n    // Extension: 1.4\n\n    static void CODEGEN_FUNCPTR Switch_BlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)\n    {\n        BlendFuncSeparate = (PFNBLENDFUNCSEPARATEPROC)IntGetProcAddress(\"glBlendFuncSeparate\");\n        BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount)\n    {\n        MultiDrawArrays = (PFNMULTIDRAWARRAYSPROC)IntGetProcAddress(\"glMultiDrawArrays\");\n        MultiDrawArrays(mode, first, count, drawcount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount)\n    {\n        MultiDrawElements = (PFNMULTIDRAWELEMENTSPROC)IntGetProcAddress(\"glMultiDrawElements\");\n        MultiDrawElements(mode, count, type, indices, drawcount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameterf(GLenum pname, GLfloat param)\n    {\n        PointParameterf = (PFNPOINTPARAMETERFPROC)IntGetProcAddress(\"glPointParameterf\");\n        PointParameterf(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameterfv(GLenum pname, const GLfloat *params)\n    {\n        PointParameterfv = (PFNPOINTPARAMETERFVPROC)IntGetProcAddress(\"glPointParameterfv\");\n        PointParameterfv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameteri(GLenum pname, GLint param)\n    {\n        PointParameteri = (PFNPOINTPARAMETERIPROC)IntGetProcAddress(\"glPointParameteri\");\n        PointParameteri(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameteriv(GLenum pname, const GLint *params)\n    {\n        PointParameteriv = (PFNPOINTPARAMETERIVPROC)IntGetProcAddress(\"glPointParameteriv\");\n        PointParameteriv(pname, params);\n    }\n\n    // Extension: 1.5\n\n    static void CODEGEN_FUNCPTR Switch_GenQueries(GLsizei n, GLuint *ids)\n    {\n        GenQueries = (PFNGENQUERIESPROC)IntGetProcAddress(\"glGenQueries\");\n        GenQueries(n, ids);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteQueries(GLsizei n, const GLuint *ids)\n    {\n        DeleteQueries = (PFNDELETEQUERIESPROC)IntGetProcAddress(\"glDeleteQueries\");\n        DeleteQueries(n, ids);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsQuery(GLuint id)\n    {\n        IsQuery = (PFNISQUERYPROC)IntGetProcAddress(\"glIsQuery\");\n        return IsQuery(id);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginQuery(GLenum target, GLuint id)\n    {\n        BeginQuery = (PFNBEGINQUERYPROC)IntGetProcAddress(\"glBeginQuery\");\n        BeginQuery(target, id);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndQuery(GLenum target)\n    {\n        EndQuery = (PFNENDQUERYPROC)IntGetProcAddress(\"glEndQuery\");\n        EndQuery(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryiv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetQueryiv = (PFNGETQUERYIVPROC)IntGetProcAddress(\"glGetQueryiv\");\n        GetQueryiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryObjectiv(GLuint id, GLenum pname, GLint *params)\n    {\n        GetQueryObjectiv = (PFNGETQUERYOBJECTIVPROC)IntGetProcAddress(\"glGetQueryObjectiv\");\n        GetQueryObjectiv(id, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)\n    {\n        GetQueryObjectuiv = (PFNGETQUERYOBJECTUIVPROC)IntGetProcAddress(\"glGetQueryObjectuiv\");\n        GetQueryObjectuiv(id, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBuffer(GLenum target, GLuint buffer)\n    {\n        BindBuffer = (PFNBINDBUFFERPROC)IntGetProcAddress(\"glBindBuffer\");\n        BindBuffer(target, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteBuffers(GLsizei n, const GLuint *buffers)\n    {\n        DeleteBuffers = (PFNDELETEBUFFERSPROC)IntGetProcAddress(\"glDeleteBuffers\");\n        DeleteBuffers(n, buffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenBuffers(GLsizei n, GLuint *buffers)\n    {\n        GenBuffers = (PFNGENBUFFERSPROC)IntGetProcAddress(\"glGenBuffers\");\n        GenBuffers(n, buffers);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsBuffer(GLuint buffer)\n    {\n        IsBuffer = (PFNISBUFFERPROC)IntGetProcAddress(\"glIsBuffer\");\n        return IsBuffer(buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)\n    {\n        BufferData = (PFNBUFFERDATAPROC)IntGetProcAddress(\"glBufferData\");\n        BufferData(target, size, data, usage);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)\n    {\n        BufferSubData = (PFNBUFFERSUBDATAPROC)IntGetProcAddress(\"glBufferSubData\");\n        BufferSubData(target, offset, size, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)\n    {\n        GetBufferSubData = (PFNGETBUFFERSUBDATAPROC)IntGetProcAddress(\"glGetBufferSubData\");\n        GetBufferSubData(target, offset, size, data);\n    }\n\n    static GLvoid* CODEGEN_FUNCPTR Switch_MapBuffer(GLenum target, GLenum access)\n    {\n        MapBuffer = (PFNMAPBUFFERPROC)IntGetProcAddress(\"glMapBuffer\");\n        return MapBuffer(target, access);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_UnmapBuffer(GLenum target)\n    {\n        UnmapBuffer = (PFNUNMAPBUFFERPROC)IntGetProcAddress(\"glUnmapBuffer\");\n        return UnmapBuffer(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetBufferParameteriv = (PFNGETBUFFERPARAMETERIVPROC)IntGetProcAddress(\"glGetBufferParameteriv\");\n        GetBufferParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferPointerv(GLenum target, GLenum pname, GLvoid* *params)\n    {\n        GetBufferPointerv = (PFNGETBUFFERPOINTERVPROC)IntGetProcAddress(\"glGetBufferPointerv\");\n        GetBufferPointerv(target, pname, params);\n    }\n\n    // Extension: 2.0\n\n    static void CODEGEN_FUNCPTR Switch_BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)\n    {\n        BlendEquationSeparate = (PFNBLENDEQUATIONSEPARATEPROC)IntGetProcAddress(\"glBlendEquationSeparate\");\n        BlendEquationSeparate(modeRGB, modeAlpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawBuffers(GLsizei n, const GLenum *bufs)\n    {\n        DrawBuffers = (PFNDRAWBUFFERSPROC)IntGetProcAddress(\"glDrawBuffers\");\n        DrawBuffers(n, bufs);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)\n    {\n        StencilOpSeparate = (PFNSTENCILOPSEPARATEPROC)IntGetProcAddress(\"glStencilOpSeparate\");\n        StencilOpSeparate(face, sfail, dpfail, dppass);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)\n    {\n        StencilFuncSeparate = (PFNSTENCILFUNCSEPARATEPROC)IntGetProcAddress(\"glStencilFuncSeparate\");\n        StencilFuncSeparate(face, func, ref, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilMaskSeparate(GLenum face, GLuint mask)\n    {\n        StencilMaskSeparate = (PFNSTENCILMASKSEPARATEPROC)IntGetProcAddress(\"glStencilMaskSeparate\");\n        StencilMaskSeparate(face, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_AttachShader(GLuint program, GLuint shader)\n    {\n        AttachShader = (PFNATTACHSHADERPROC)IntGetProcAddress(\"glAttachShader\");\n        AttachShader(program, shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindAttribLocation(GLuint program, GLuint index, const GLchar *name)\n    {\n        BindAttribLocation = (PFNBINDATTRIBLOCATIONPROC)IntGetProcAddress(\"glBindAttribLocation\");\n        BindAttribLocation(program, index, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompileShader(GLuint shader)\n    {\n        CompileShader = (PFNCOMPILESHADERPROC)IntGetProcAddress(\"glCompileShader\");\n        CompileShader(shader);\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_CreateProgram()\n    {\n        CreateProgram = (PFNCREATEPROGRAMPROC)IntGetProcAddress(\"glCreateProgram\");\n        return CreateProgram();\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_CreateShader(GLenum type)\n    {\n        CreateShader = (PFNCREATESHADERPROC)IntGetProcAddress(\"glCreateShader\");\n        return CreateShader(type);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteProgram(GLuint program)\n    {\n        DeleteProgram = (PFNDELETEPROGRAMPROC)IntGetProcAddress(\"glDeleteProgram\");\n        DeleteProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteShader(GLuint shader)\n    {\n        DeleteShader = (PFNDELETESHADERPROC)IntGetProcAddress(\"glDeleteShader\");\n        DeleteShader(shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DetachShader(GLuint program, GLuint shader)\n    {\n        DetachShader = (PFNDETACHSHADERPROC)IntGetProcAddress(\"glDetachShader\");\n        DetachShader(program, shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DisableVertexAttribArray(GLuint index)\n    {\n        DisableVertexAttribArray = (PFNDISABLEVERTEXATTRIBARRAYPROC)IntGetProcAddress(\"glDisableVertexAttribArray\");\n        DisableVertexAttribArray(index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EnableVertexAttribArray(GLuint index)\n    {\n        EnableVertexAttribArray = (PFNENABLEVERTEXATTRIBARRAYPROC)IntGetProcAddress(\"glEnableVertexAttribArray\");\n        EnableVertexAttribArray(index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)\n    {\n        GetActiveAttrib = (PFNGETACTIVEATTRIBPROC)IntGetProcAddress(\"glGetActiveAttrib\");\n        GetActiveAttrib(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)\n    {\n        GetActiveUniform = (PFNGETACTIVEUNIFORMPROC)IntGetProcAddress(\"glGetActiveUniform\");\n        GetActiveUniform(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj)\n    {\n        GetAttachedShaders = (PFNGETATTACHEDSHADERSPROC)IntGetProcAddress(\"glGetAttachedShaders\");\n        GetAttachedShaders(program, maxCount, count, obj);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetAttribLocation(GLuint program, const GLchar *name)\n    {\n        GetAttribLocation = (PFNGETATTRIBLOCATIONPROC)IntGetProcAddress(\"glGetAttribLocation\");\n        return GetAttribLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetProgramiv(GLuint program, GLenum pname, GLint *params)\n    {\n        GetProgramiv = (PFNGETPROGRAMIVPROC)IntGetProcAddress(\"glGetProgramiv\");\n        GetProgramiv(program, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)\n    {\n        GetProgramInfoLog = (PFNGETPROGRAMINFOLOGPROC)IntGetProcAddress(\"glGetProgramInfoLog\");\n        GetProgramInfoLog(program, bufSize, length, infoLog);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderiv(GLuint shader, GLenum pname, GLint *params)\n    {\n        GetShaderiv = (PFNGETSHADERIVPROC)IntGetProcAddress(\"glGetShaderiv\");\n        GetShaderiv(shader, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)\n    {\n        GetShaderInfoLog = (PFNGETSHADERINFOLOGPROC)IntGetProcAddress(\"glGetShaderInfoLog\");\n        GetShaderInfoLog(shader, bufSize, length, infoLog);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)\n    {\n        GetShaderSource = (PFNGETSHADERSOURCEPROC)IntGetProcAddress(\"glGetShaderSource\");\n        GetShaderSource(shader, bufSize, length, source);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetUniformLocation(GLuint program, const GLchar *name)\n    {\n        GetUniformLocation = (PFNGETUNIFORMLOCATIONPROC)IntGetProcAddress(\"glGetUniformLocation\");\n        return GetUniformLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformfv(GLuint program, GLint location, GLfloat *params)\n    {\n        GetUniformfv = (PFNGETUNIFORMFVPROC)IntGetProcAddress(\"glGetUniformfv\");\n        GetUniformfv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformiv(GLuint program, GLint location, GLint *params)\n    {\n        GetUniformiv = (PFNGETUNIFORMIVPROC)IntGetProcAddress(\"glGetUniformiv\");\n        GetUniformiv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)\n    {\n        GetVertexAttribdv = (PFNGETVERTEXATTRIBDVPROC)IntGetProcAddress(\"glGetVertexAttribdv\");\n        GetVertexAttribdv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)\n    {\n        GetVertexAttribfv = (PFNGETVERTEXATTRIBFVPROC)IntGetProcAddress(\"glGetVertexAttribfv\");\n        GetVertexAttribfv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)\n    {\n        GetVertexAttribiv = (PFNGETVERTEXATTRIBIVPROC)IntGetProcAddress(\"glGetVertexAttribiv\");\n        GetVertexAttribiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid* *pointer)\n    {\n        GetVertexAttribPointerv = (PFNGETVERTEXATTRIBPOINTERVPROC)IntGetProcAddress(\"glGetVertexAttribPointerv\");\n        GetVertexAttribPointerv(index, pname, pointer);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsProgram(GLuint program)\n    {\n        IsProgram = (PFNISPROGRAMPROC)IntGetProcAddress(\"glIsProgram\");\n        return IsProgram(program);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsShader(GLuint shader)\n    {\n        IsShader = (PFNISSHADERPROC)IntGetProcAddress(\"glIsShader\");\n        return IsShader(shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LinkProgram(GLuint program)\n    {\n        LinkProgram = (PFNLINKPROGRAMPROC)IntGetProcAddress(\"glLinkProgram\");\n        LinkProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ShaderSource(GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length)\n    {\n        ShaderSource = (PFNSHADERSOURCEPROC)IntGetProcAddress(\"glShaderSource\");\n        ShaderSource(shader, count, string, length);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UseProgram(GLuint program)\n    {\n        UseProgram = (PFNUSEPROGRAMPROC)IntGetProcAddress(\"glUseProgram\");\n        UseProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1f(GLint location, GLfloat v0)\n    {\n        Uniform1f = (PFNUNIFORM1FPROC)IntGetProcAddress(\"glUniform1f\");\n        Uniform1f(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2f(GLint location, GLfloat v0, GLfloat v1)\n    {\n        Uniform2f = (PFNUNIFORM2FPROC)IntGetProcAddress(\"glUniform2f\");\n        Uniform2f(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)\n    {\n        Uniform3f = (PFNUNIFORM3FPROC)IntGetProcAddress(\"glUniform3f\");\n        Uniform3f(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)\n    {\n        Uniform4f = (PFNUNIFORM4FPROC)IntGetProcAddress(\"glUniform4f\");\n        Uniform4f(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1i(GLint location, GLint v0)\n    {\n        Uniform1i = (PFNUNIFORM1IPROC)IntGetProcAddress(\"glUniform1i\");\n        Uniform1i(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2i(GLint location, GLint v0, GLint v1)\n    {\n        Uniform2i = (PFNUNIFORM2IPROC)IntGetProcAddress(\"glUniform2i\");\n        Uniform2i(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)\n    {\n        Uniform3i = (PFNUNIFORM3IPROC)IntGetProcAddress(\"glUniform3i\");\n        Uniform3i(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)\n    {\n        Uniform4i = (PFNUNIFORM4IPROC)IntGetProcAddress(\"glUniform4i\");\n        Uniform4i(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform1fv = (PFNUNIFORM1FVPROC)IntGetProcAddress(\"glUniform1fv\");\n        Uniform1fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform2fv = (PFNUNIFORM2FVPROC)IntGetProcAddress(\"glUniform2fv\");\n        Uniform2fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform3fv = (PFNUNIFORM3FVPROC)IntGetProcAddress(\"glUniform3fv\");\n        Uniform3fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform4fv = (PFNUNIFORM4FVPROC)IntGetProcAddress(\"glUniform4fv\");\n        Uniform4fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform1iv = (PFNUNIFORM1IVPROC)IntGetProcAddress(\"glUniform1iv\");\n        Uniform1iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform2iv = (PFNUNIFORM2IVPROC)IntGetProcAddress(\"glUniform2iv\");\n        Uniform2iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform3iv = (PFNUNIFORM3IVPROC)IntGetProcAddress(\"glUniform3iv\");\n        Uniform3iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform4iv = (PFNUNIFORM4IVPROC)IntGetProcAddress(\"glUniform4iv\");\n        Uniform4iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2fv = (PFNUNIFORMMATRIX2FVPROC)IntGetProcAddress(\"glUniformMatrix2fv\");\n        UniformMatrix2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3fv = (PFNUNIFORMMATRIX3FVPROC)IntGetProcAddress(\"glUniformMatrix3fv\");\n        UniformMatrix3fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4fv = (PFNUNIFORMMATRIX4FVPROC)IntGetProcAddress(\"glUniformMatrix4fv\");\n        UniformMatrix4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ValidateProgram(GLuint program)\n    {\n        ValidateProgram = (PFNVALIDATEPROGRAMPROC)IntGetProcAddress(\"glValidateProgram\");\n        ValidateProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)\n    {\n        VertexAttribPointer = (PFNVERTEXATTRIBPOINTERPROC)IntGetProcAddress(\"glVertexAttribPointer\");\n        VertexAttribPointer(index, size, type, normalized, stride, pointer);\n    }\n\n    // Extension: 2.1\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2x3fv = (PFNUNIFORMMATRIX2X3FVPROC)IntGetProcAddress(\"glUniformMatrix2x3fv\");\n        UniformMatrix2x3fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3x2fv = (PFNUNIFORMMATRIX3X2FVPROC)IntGetProcAddress(\"glUniformMatrix3x2fv\");\n        UniformMatrix3x2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2x4fv = (PFNUNIFORMMATRIX2X4FVPROC)IntGetProcAddress(\"glUniformMatrix2x4fv\");\n        UniformMatrix2x4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4x2fv = (PFNUNIFORMMATRIX4X2FVPROC)IntGetProcAddress(\"glUniformMatrix4x2fv\");\n        UniformMatrix4x2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3x4fv = (PFNUNIFORMMATRIX3X4FVPROC)IntGetProcAddress(\"glUniformMatrix3x4fv\");\n        UniformMatrix3x4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4x3fv = (PFNUNIFORMMATRIX4X3FVPROC)IntGetProcAddress(\"glUniformMatrix4x3fv\");\n        UniformMatrix4x3fv(location, count, transpose, value);\n    }\n\n    // Extension: ARB_vertex_array_object\n\n    static void CODEGEN_FUNCPTR Switch_BindVertexArray(GLuint ren_array)\n    {\n        BindVertexArray = (PFNBINDVERTEXARRAYPROC)IntGetProcAddress(\"glBindVertexArray\");\n        BindVertexArray(ren_array);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteVertexArrays(GLsizei n, const GLuint *arrays)\n    {\n        DeleteVertexArrays = (PFNDELETEVERTEXARRAYSPROC)IntGetProcAddress(\"glDeleteVertexArrays\");\n        DeleteVertexArrays(n, arrays);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenVertexArrays(GLsizei n, GLuint *arrays)\n    {\n        GenVertexArrays = (PFNGENVERTEXARRAYSPROC)IntGetProcAddress(\"glGenVertexArrays\");\n        GenVertexArrays(n, arrays);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsVertexArray(GLuint ren_array)\n    {\n        IsVertexArray = (PFNISVERTEXARRAYPROC)IntGetProcAddress(\"glIsVertexArray\");\n        return IsVertexArray(ren_array);\n    }\n\n    // Extension: ARB_map_buffer_range\n\n    static GLvoid* CODEGEN_FUNCPTR Switch_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)\n    {\n        MapBufferRange = (PFNMAPBUFFERRANGEPROC)IntGetProcAddress(\"glMapBufferRange\");\n        return MapBufferRange(target, offset, length, access);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)\n    {\n        FlushMappedBufferRange = (PFNFLUSHMAPPEDBUFFERRANGEPROC)IntGetProcAddress(\"glFlushMappedBufferRange\");\n        FlushMappedBufferRange(target, offset, length);\n    }\n\n    // Extension: ARB_framebuffer_object\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsRenderbuffer(GLuint renderbuffer)\n    {\n        IsRenderbuffer = (PFNISRENDERBUFFERPROC)IntGetProcAddress(\"glIsRenderbuffer\");\n        return IsRenderbuffer(renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindRenderbuffer(GLenum target, GLuint renderbuffer)\n    {\n        BindRenderbuffer = (PFNBINDRENDERBUFFERPROC)IntGetProcAddress(\"glBindRenderbuffer\");\n        BindRenderbuffer(target, renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)\n    {\n        DeleteRenderbuffers = (PFNDELETERENDERBUFFERSPROC)IntGetProcAddress(\"glDeleteRenderbuffers\");\n        DeleteRenderbuffers(n, renderbuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenRenderbuffers(GLsizei n, GLuint *renderbuffers)\n    {\n        GenRenderbuffers = (PFNGENRENDERBUFFERSPROC)IntGetProcAddress(\"glGenRenderbuffers\");\n        GenRenderbuffers(n, renderbuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)\n    {\n        RenderbufferStorage = (PFNRENDERBUFFERSTORAGEPROC)IntGetProcAddress(\"glRenderbufferStorage\");\n        RenderbufferStorage(target, internalformat, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetRenderbufferParameteriv = (PFNGETRENDERBUFFERPARAMETERIVPROC)IntGetProcAddress(\"glGetRenderbufferParameteriv\");\n        GetRenderbufferParameteriv(target, pname, params);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsFramebuffer(GLuint framebuffer)\n    {\n        IsFramebuffer = (PFNISFRAMEBUFFERPROC)IntGetProcAddress(\"glIsFramebuffer\");\n        return IsFramebuffer(framebuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindFramebuffer(GLenum target, GLuint framebuffer)\n    {\n        BindFramebuffer = (PFNBINDFRAMEBUFFERPROC)IntGetProcAddress(\"glBindFramebuffer\");\n        BindFramebuffer(target, framebuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)\n    {\n        DeleteFramebuffers = (PFNDELETEFRAMEBUFFERSPROC)IntGetProcAddress(\"glDeleteFramebuffers\");\n        DeleteFramebuffers(n, framebuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenFramebuffers(GLsizei n, GLuint *framebuffers)\n    {\n        GenFramebuffers = (PFNGENFRAMEBUFFERSPROC)IntGetProcAddress(\"glGenFramebuffers\");\n        GenFramebuffers(n, framebuffers);\n    }\n\n    static GLenum CODEGEN_FUNCPTR Switch_CheckFramebufferStatus(GLenum target)\n    {\n        CheckFramebufferStatus = (PFNCHECKFRAMEBUFFERSTATUSPROC)IntGetProcAddress(\"glCheckFramebufferStatus\");\n        return CheckFramebufferStatus(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)\n    {\n        FramebufferTexture1D = (PFNFRAMEBUFFERTEXTURE1DPROC)IntGetProcAddress(\"glFramebufferTexture1D\");\n        FramebufferTexture1D(target, attachment, textarget, texture, level);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)\n    {\n        FramebufferTexture2D = (PFNFRAMEBUFFERTEXTURE2DPROC)IntGetProcAddress(\"glFramebufferTexture2D\");\n        FramebufferTexture2D(target, attachment, textarget, texture, level);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)\n    {\n        FramebufferTexture3D = (PFNFRAMEBUFFERTEXTURE3DPROC)IntGetProcAddress(\"glFramebufferTexture3D\");\n        FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)\n    {\n        FramebufferRenderbuffer = (PFNFRAMEBUFFERRENDERBUFFERPROC)IntGetProcAddress(\"glFramebufferRenderbuffer\");\n        FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)\n    {\n        GetFramebufferAttachmentParameteriv = (PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)IntGetProcAddress(\"glGetFramebufferAttachmentParameteriv\");\n        GetFramebufferAttachmentParameteriv(target, attachment, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenerateMipmap(GLenum target)\n    {\n        GenerateMipmap = (PFNGENERATEMIPMAPPROC)IntGetProcAddress(\"glGenerateMipmap\");\n        GenerateMipmap(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)\n    {\n        BlitFramebuffer = (PFNBLITFRAMEBUFFERPROC)IntGetProcAddress(\"glBlitFramebuffer\");\n        BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)\n    {\n        RenderbufferStorageMultisample = (PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC)IntGetProcAddress(\"glRenderbufferStorageMultisample\");\n        RenderbufferStorageMultisample(target, samples, internalformat, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)\n    {\n        FramebufferTextureLayer = (PFNFRAMEBUFFERTEXTURELAYERPROC)IntGetProcAddress(\"glFramebufferTextureLayer\");\n        FramebufferTextureLayer(target, attachment, texture, level, layer);\n    }\n\n    // Extension: 3.0\n\n    static void CODEGEN_FUNCPTR Switch_ColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)\n    {\n        ColorMaski = (PFNCOLORMASKIPROC)IntGetProcAddress(\"glColorMaski\");\n        ColorMaski(index, r, g, b, a);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBooleani_v(GLenum target, GLuint index, GLboolean *data)\n    {\n        GetBooleani_v = (PFNGETBOOLEANI_VPROC)IntGetProcAddress(\"glGetBooleani_v\");\n        GetBooleani_v(target, index, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetIntegeri_v(GLenum target, GLuint index, GLint *data)\n    {\n        GetIntegeri_v = (PFNGETINTEGERI_VPROC)IntGetProcAddress(\"glGetIntegeri_v\");\n        GetIntegeri_v(target, index, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Enablei(GLenum target, GLuint index)\n    {\n        Enablei = (PFNENABLEIPROC)IntGetProcAddress(\"glEnablei\");\n        Enablei(target, index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Disablei(GLenum target, GLuint index)\n    {\n        Disablei = (PFNDISABLEIPROC)IntGetProcAddress(\"glDisablei\");\n        Disablei(target, index);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsEnabledi(GLenum target, GLuint index)\n    {\n        IsEnabledi = (PFNISENABLEDIPROC)IntGetProcAddress(\"glIsEnabledi\");\n        return IsEnabledi(target, index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginTransformFeedback(GLenum primitiveMode)\n    {\n        BeginTransformFeedback = (PFNBEGINTRANSFORMFEEDBACKPROC)IntGetProcAddress(\"glBeginTransformFeedback\");\n        BeginTransformFeedback(primitiveMode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndTransformFeedback()\n    {\n        EndTransformFeedback = (PFNENDTRANSFORMFEEDBACKPROC)IntGetProcAddress(\"glEndTransformFeedback\");\n        EndTransformFeedback();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)\n    {\n        BindBufferRange = (PFNBINDBUFFERRANGEPROC)IntGetProcAddress(\"glBindBufferRange\");\n        BindBufferRange(target, index, buffer, offset, size);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBufferBase(GLenum target, GLuint index, GLuint buffer)\n    {\n        BindBufferBase = (PFNBINDBUFFERBASEPROC)IntGetProcAddress(\"glBindBufferBase\");\n        BindBufferBase(target, index, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode)\n    {\n        TransformFeedbackVaryings = (PFNTRANSFORMFEEDBACKVARYINGSPROC)IntGetProcAddress(\"glTransformFeedbackVaryings\");\n        TransformFeedbackVaryings(program, count, varyings, bufferMode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)\n    {\n        GetTransformFeedbackVarying = (PFNGETTRANSFORMFEEDBACKVARYINGPROC)IntGetProcAddress(\"glGetTransformFeedbackVarying\");\n        GetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClampColor(GLenum target, GLenum clamp)\n    {\n        ClampColor = (PFNCLAMPCOLORPROC)IntGetProcAddress(\"glClampColor\");\n        ClampColor(target, clamp);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginConditionalRender(GLuint id, GLenum mode)\n    {\n        BeginConditionalRender = (PFNBEGINCONDITIONALRENDERPROC)IntGetProcAddress(\"glBeginConditionalRender\");\n        BeginConditionalRender(id, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndConditionalRender()\n    {\n        EndConditionalRender = (PFNENDCONDITIONALRENDERPROC)IntGetProcAddress(\"glEndConditionalRender\");\n        EndConditionalRender();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)\n    {\n        VertexAttribIPointer = (PFNVERTEXATTRIBIPOINTERPROC)IntGetProcAddress(\"glVertexAttribIPointer\");\n        VertexAttribIPointer(index, size, type, stride, pointer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)\n    {\n        GetVertexAttribIiv = (PFNGETVERTEXATTRIBIIVPROC)IntGetProcAddress(\"glGetVertexAttribIiv\");\n        GetVertexAttribIiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)\n    {\n        GetVertexAttribIuiv = (PFNGETVERTEXATTRIBIUIVPROC)IntGetProcAddress(\"glGetVertexAttribIuiv\");\n        GetVertexAttribIuiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1i(GLuint index, GLint x)\n    {\n        VertexAttribI1i = (PFNVERTEXATTRIBI1IPROC)IntGetProcAddress(\"glVertexAttribI1i\");\n        VertexAttribI1i(index, x);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2i(GLuint index, GLint x, GLint y)\n    {\n        VertexAttribI2i = (PFNVERTEXATTRIBI2IPROC)IntGetProcAddress(\"glVertexAttribI2i\");\n        VertexAttribI2i(index, x, y);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)\n    {\n        VertexAttribI3i = (PFNVERTEXATTRIBI3IPROC)IntGetProcAddress(\"glVertexAttribI3i\");\n        VertexAttribI3i(index, x, y, z);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)\n    {\n        VertexAttribI4i = (PFNVERTEXATTRIBI4IPROC)IntGetProcAddress(\"glVertexAttribI4i\");\n        VertexAttribI4i(index, x, y, z, w);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1ui(GLuint index, GLuint x)\n    {\n        VertexAttribI1ui = (PFNVERTEXATTRIBI1UIPROC)IntGetProcAddress(\"glVertexAttribI1ui\");\n        VertexAttribI1ui(index, x);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2ui(GLuint index, GLuint x, GLuint y)\n    {\n        VertexAttribI2ui = (PFNVERTEXATTRIBI2UIPROC)IntGetProcAddress(\"glVertexAttribI2ui\");\n        VertexAttribI2ui(index, x, y);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)\n    {\n        VertexAttribI3ui = (PFNVERTEXATTRIBI3UIPROC)IntGetProcAddress(\"glVertexAttribI3ui\");\n        VertexAttribI3ui(index, x, y, z);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)\n    {\n        VertexAttribI4ui = (PFNVERTEXATTRIBI4UIPROC)IntGetProcAddress(\"glVertexAttribI4ui\");\n        VertexAttribI4ui(index, x, y, z, w);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI1iv = (PFNVERTEXATTRIBI1IVPROC)IntGetProcAddress(\"glVertexAttribI1iv\");\n        VertexAttribI1iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI2iv = (PFNVERTEXATTRIBI2IVPROC)IntGetProcAddress(\"glVertexAttribI2iv\");\n        VertexAttribI2iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI3iv = (PFNVERTEXATTRIBI3IVPROC)IntGetProcAddress(\"glVertexAttribI3iv\");\n        VertexAttribI3iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI4iv = (PFNVERTEXATTRIBI4IVPROC)IntGetProcAddress(\"glVertexAttribI4iv\");\n        VertexAttribI4iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI1uiv = (PFNVERTEXATTRIBI1UIVPROC)IntGetProcAddress(\"glVertexAttribI1uiv\");\n        VertexAttribI1uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI2uiv = (PFNVERTEXATTRIBI2UIVPROC)IntGetProcAddress(\"glVertexAttribI2uiv\");\n        VertexAttribI2uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI3uiv = (PFNVERTEXATTRIBI3UIVPROC)IntGetProcAddress(\"glVertexAttribI3uiv\");\n        VertexAttribI3uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI4uiv = (PFNVERTEXATTRIBI4UIVPROC)IntGetProcAddress(\"glVertexAttribI4uiv\");\n        VertexAttribI4uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4bv(GLuint index, const GLbyte *v)\n    {\n        VertexAttribI4bv = (PFNVERTEXATTRIBI4BVPROC)IntGetProcAddress(\"glVertexAttribI4bv\");\n        VertexAttribI4bv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4sv(GLuint index, const GLshort *v)\n    {\n        VertexAttribI4sv = (PFNVERTEXATTRIBI4SVPROC)IntGetProcAddress(\"glVertexAttribI4sv\");\n        VertexAttribI4sv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4ubv(GLuint index, const GLubyte *v)\n    {\n        VertexAttribI4ubv = (PFNVERTEXATTRIBI4UBVPROC)IntGetProcAddress(\"glVertexAttribI4ubv\");\n        VertexAttribI4ubv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4usv(GLuint index, const GLushort *v)\n    {\n        VertexAttribI4usv = (PFNVERTEXATTRIBI4USVPROC)IntGetProcAddress(\"glVertexAttribI4usv\");\n        VertexAttribI4usv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformuiv(GLuint program, GLint location, GLuint *params)\n    {\n        GetUniformuiv = (PFNGETUNIFORMUIVPROC)IntGetProcAddress(\"glGetUniformuiv\");\n        GetUniformuiv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindFragDataLocation(GLuint program, GLuint color, const GLchar *name)\n    {\n        BindFragDataLocation = (PFNBINDFRAGDATALOCATIONPROC)IntGetProcAddress(\"glBindFragDataLocation\");\n        BindFragDataLocation(program, color, name);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetFragDataLocation(GLuint program, const GLchar *name)\n    {\n        GetFragDataLocation = (PFNGETFRAGDATALOCATIONPROC)IntGetProcAddress(\"glGetFragDataLocation\");\n        return GetFragDataLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1ui(GLint location, GLuint v0)\n    {\n        Uniform1ui = (PFNUNIFORM1UIPROC)IntGetProcAddress(\"glUniform1ui\");\n        Uniform1ui(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2ui(GLint location, GLuint v0, GLuint v1)\n    {\n        Uniform2ui = (PFNUNIFORM2UIPROC)IntGetProcAddress(\"glUniform2ui\");\n        Uniform2ui(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)\n    {\n        Uniform3ui = (PFNUNIFORM3UIPROC)IntGetProcAddress(\"glUniform3ui\");\n        Uniform3ui(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)\n    {\n        Uniform4ui = (PFNUNIFORM4UIPROC)IntGetProcAddress(\"glUniform4ui\");\n        Uniform4ui(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform1uiv = (PFNUNIFORM1UIVPROC)IntGetProcAddress(\"glUniform1uiv\");\n        Uniform1uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform2uiv = (PFNUNIFORM2UIVPROC)IntGetProcAddress(\"glUniform2uiv\");\n        Uniform2uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform3uiv = (PFNUNIFORM3UIVPROC)IntGetProcAddress(\"glUniform3uiv\");\n        Uniform3uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform4uiv = (PFNUNIFORM4UIVPROC)IntGetProcAddress(\"glUniform4uiv\");\n        Uniform4uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)\n    {\n        TexParameterIiv = (PFNTEXPARAMETERIIVPROC)IntGetProcAddress(\"glTexParameterIiv\");\n        TexParameterIiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)\n    {\n        TexParameterIuiv = (PFNTEXPARAMETERIUIVPROC)IntGetProcAddress(\"glTexParameterIuiv\");\n        TexParameterIuiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetTexParameterIiv = (PFNGETTEXPARAMETERIIVPROC)IntGetProcAddress(\"glGetTexParameterIiv\");\n        GetTexParameterIiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)\n    {\n        GetTexParameterIuiv = (PFNGETTEXPARAMETERIUIVPROC)IntGetProcAddress(\"glGetTexParameterIuiv\");\n        GetTexParameterIuiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)\n    {\n        ClearBufferiv = (PFNCLEARBUFFERIVPROC)IntGetProcAddress(\"glClearBufferiv\");\n        ClearBufferiv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)\n    {\n        ClearBufferuiv = (PFNCLEARBUFFERUIVPROC)IntGetProcAddress(\"glClearBufferuiv\");\n        ClearBufferuiv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)\n    {\n        ClearBufferfv = (PFNCLEARBUFFERFVPROC)IntGetProcAddress(\"glClearBufferfv\");\n        ClearBufferfv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)\n    {\n        ClearBufferfi = (PFNCLEARBUFFERFIPROC)IntGetProcAddress(\"glClearBufferfi\");\n        ClearBufferfi(buffer, drawbuffer, depth, stencil);\n    }\n\n    static const GLubyte * CODEGEN_FUNCPTR Switch_GetStringi(GLenum name, GLuint index)\n    {\n        GetStringi = (PFNGETSTRINGIPROC)IntGetProcAddress(\"glGetStringi\");\n        return GetStringi(name, index);\n    }\n\n    // Extension: ARB_uniform_buffer_object\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices)\n    {\n        GetUniformIndices = (PFNGETUNIFORMINDICESPROC)IntGetProcAddress(\"glGetUniformIndices\");\n        GetUniformIndices(program, uniformCount, uniformNames, uniformIndices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)\n    {\n        GetActiveUniformsiv = (PFNGETACTIVEUNIFORMSIVPROC)IntGetProcAddress(\"glGetActiveUniformsiv\");\n        GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)\n    {\n        GetActiveUniformName = (PFNGETACTIVEUNIFORMNAMEPROC)IntGetProcAddress(\"glGetActiveUniformName\");\n        GetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_GetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)\n    {\n        GetUniformBlockIndex = (PFNGETUNIFORMBLOCKINDEXPROC)IntGetProcAddress(\"glGetUniformBlockIndex\");\n        return GetUniformBlockIndex(program, uniformBlockName);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)\n    {\n        GetActiveUniformBlockiv = (PFNGETACTIVEUNIFORMBLOCKIVPROC)IntGetProcAddress(\"glGetActiveUniformBlockiv\");\n        GetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)\n    {\n        GetActiveUniformBlockName = (PFNGETACTIVEUNIFORMBLOCKNAMEPROC)IntGetProcAddress(\"glGetActiveUniformBlockName\");\n        GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)\n    {\n        UniformBlockBinding = (PFNUNIFORMBLOCKBINDINGPROC)IntGetProcAddress(\"glUniformBlockBinding\");\n        UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);\n    }\n\n    // Extension: ARB_copy_buffer\n\n    static void CODEGEN_FUNCPTR Switch_CopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)\n    {\n        CopyBufferSubData = (PFNCOPYBUFFERSUBDATAPROC)IntGetProcAddress(\"glCopyBufferSubData\");\n        CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);\n    }\n\n    // Extension: 3.1\n\n    static void CODEGEN_FUNCPTR Switch_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)\n    {\n        DrawArraysInstanced = (PFNDRAWARRAYSINSTANCEDPROC)IntGetProcAddress(\"glDrawArraysInstanced\");\n        DrawArraysInstanced(mode, first, count, instancecount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount)\n    {\n        DrawElementsInstanced = (PFNDRAWELEMENTSINSTANCEDPROC)IntGetProcAddress(\"glDrawElementsInstanced\");\n        DrawElementsInstanced(mode, count, type, indices, instancecount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexBuffer(GLenum target, GLenum internalformat, GLuint buffer)\n    {\n        TexBuffer = (PFNTEXBUFFERPROC)IntGetProcAddress(\"glTexBuffer\");\n        TexBuffer(target, internalformat, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PrimitiveRestartIndex(GLuint index)\n    {\n        PrimitiveRestartIndex = (PFNPRIMITIVERESTARTINDEXPROC)IntGetProcAddress(\"glPrimitiveRestartIndex\");\n        PrimitiveRestartIndex(index);\n    }\n\n    // Legacy\n\n    static void CODEGEN_FUNCPTR Switch_EnableClientState(GLenum cap)\n    {\n        EnableClientState = (PFNENABLECLIENTSTATEPROC)IntGetProcAddress(\"glEnableClientState\");\n        EnableClientState(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DisableClientState(GLenum cap)\n    {\n        DisableClientState = (PFNDISABLECLIENTSTATEPROC)IntGetProcAddress(\"glDisableClientState\");\n        DisableClientState(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        VertexPointer = (PFNVERTEXPOINTERPROC)IntGetProcAddress(\"glVertexPointer\");\n        VertexPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        NormalPointer = (PFNNORMALPOINTERPROC)IntGetProcAddress(\"glNormalPointer\");\n        NormalPointer(type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        ColorPointer = (PFNCOLORPOINTERPROC)IntGetProcAddress(\"glColorPointer\");\n        ColorPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        TexCoordPointer = (PFNTEXCOORDPOINTERPROC)IntGetProcAddress(\"glTexCoordPointer\");\n        TexCoordPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexEnvi(GLenum target, GLenum pname, GLint param)\n    {\n        TexEnvi = (PFNTEXENVIPROC)IntGetProcAddress(\"glTexEnvi\");\n        TexEnvi(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MatrixMode(GLenum mode)\n    {\n        MatrixMode = (PFNMATRIXMODEPROC)IntGetProcAddress(\"glMatrixMode\");\n        MatrixMode(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LoadIdentity(void)\n    {\n        LoadIdentity = (PFNLOADIDENTITYPROC)IntGetProcAddress(\"glLoadIdentity\");\n        LoadIdentity();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Ortho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)\n    {\n        Ortho = (PFNORTHOPROC)IntGetProcAddress(\"glOrtho\");\n        Ortho(left, right, bottom, top, near_val, far_val);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Color3d(GLdouble red, GLdouble green, GLdouble blue)\n    {\n        Color3d = (PFNCOLOR3DPROC)IntGetProcAddress(\"glColor3d\");\n        Color3d(red, green, blue);\n    }\n\n    struct InitializeVariables\n    {\n        InitializeVariables()\n        {\n            // Extension: 1.1\n            CullFace = Switch_CullFace;\n            FrontFace = Switch_FrontFace;\n            Hint = Switch_Hint;\n            LineWidth = Switch_LineWidth;\n            PointSize = Switch_PointSize;\n            PolygonMode = Switch_PolygonMode;\n            Scissor = Switch_Scissor;\n            TexParameterf = Switch_TexParameterf;\n            TexParameterfv = Switch_TexParameterfv;\n            TexParameteri = Switch_TexParameteri;\n            TexParameteriv = Switch_TexParameteriv;\n            TexImage1D = Switch_TexImage1D;\n            TexImage2D = Switch_TexImage2D;\n            DrawBuffer = Switch_DrawBuffer;\n            Clear = Switch_Clear;\n            ClearColor = Switch_ClearColor;\n            ClearStencil = Switch_ClearStencil;\n            ClearDepth = Switch_ClearDepth;\n            StencilMask = Switch_StencilMask;\n            ColorMask = Switch_ColorMask;\n            DepthMask = Switch_DepthMask;\n            Disable = Switch_Disable;\n            Enable = Switch_Enable;\n            Finish = Switch_Finish;\n            Flush = Switch_Flush;\n            BlendFunc = Switch_BlendFunc;\n            LogicOp = Switch_LogicOp;\n            StencilFunc = Switch_StencilFunc;\n            StencilOp = Switch_StencilOp;\n            DepthFunc = Switch_DepthFunc;\n            PixelStoref = Switch_PixelStoref;\n            PixelStorei = Switch_PixelStorei;\n            ReadBuffer = Switch_ReadBuffer;\n            ReadPixels = Switch_ReadPixels;\n            GetBooleanv = Switch_GetBooleanv;\n            GetDoublev = Switch_GetDoublev;\n            GetError = Switch_GetError;\n            GetFloatv = Switch_GetFloatv;\n            GetIntegerv = Switch_GetIntegerv;\n            GetString = Switch_GetString;\n            GetTexImage = Switch_GetTexImage;\n            GetTexParameterfv = Switch_GetTexParameterfv;\n            GetTexParameteriv = Switch_GetTexParameteriv;\n            GetTexLevelParameterfv = Switch_GetTexLevelParameterfv;\n            GetTexLevelParameteriv = Switch_GetTexLevelParameteriv;\n            IsEnabled = Switch_IsEnabled;\n            DepthRange = Switch_DepthRange;\n            Viewport = Switch_Viewport;\n            DrawArrays = Switch_DrawArrays;\n            DrawElements = Switch_DrawElements;\n            GetPointerv = Switch_GetPointerv;\n            PolygonOffset = Switch_PolygonOffset;\n            CopyTexImage1D = Switch_CopyTexImage1D;\n            CopyTexImage2D = Switch_CopyTexImage2D;\n            CopyTexSubImage1D = Switch_CopyTexSubImage1D;\n            CopyTexSubImage2D = Switch_CopyTexSubImage2D;\n            TexSubImage1D = Switch_TexSubImage1D;\n            TexSubImage2D = Switch_TexSubImage2D;\n            BindTexture = Switch_BindTexture;\n            DeleteTextures = Switch_DeleteTextures;\n            GenTextures = Switch_GenTextures;\n            IsTexture = Switch_IsTexture;\n            Indexub = Switch_Indexub;\n            Indexubv = Switch_Indexubv;\n\n            // Extension: 1.2\n            BlendColor = Switch_BlendColor;\n            BlendEquation = Switch_BlendEquation;\n            DrawRangeElements = Switch_DrawRangeElements;\n            TexSubImage3D = Switch_TexSubImage3D;\n            CopyTexSubImage3D = Switch_CopyTexSubImage3D;\n\n            // Extension: 1.3\n            ActiveTexture = Switch_ActiveTexture;\n            SampleCoverage = Switch_SampleCoverage;\n            CompressedTexImage3D = Switch_CompressedTexImage3D;\n            CompressedTexImage2D = Switch_CompressedTexImage2D;\n            CompressedTexImage1D = Switch_CompressedTexImage1D;\n            CompressedTexSubImage3D = Switch_CompressedTexSubImage3D;\n            CompressedTexSubImage2D = Switch_CompressedTexSubImage2D;\n            CompressedTexSubImage1D = Switch_CompressedTexSubImage1D;\n            GetCompressedTexImage = Switch_GetCompressedTexImage;\n\n            // Extension: 1.4\n            BlendFuncSeparate = Switch_BlendFuncSeparate;\n            MultiDrawArrays = Switch_MultiDrawArrays;\n            MultiDrawElements = Switch_MultiDrawElements;\n            PointParameterf = Switch_PointParameterf;\n            PointParameterfv = Switch_PointParameterfv;\n            PointParameteri = Switch_PointParameteri;\n            PointParameteriv = Switch_PointParameteriv;\n\n            // Extension: 1.5\n            GenQueries = Switch_GenQueries;\n            DeleteQueries = Switch_DeleteQueries;\n            IsQuery = Switch_IsQuery;\n            BeginQuery = Switch_BeginQuery;\n            EndQuery = Switch_EndQuery;\n            GetQueryiv = Switch_GetQueryiv;\n            GetQueryObjectiv = Switch_GetQueryObjectiv;\n            GetQueryObjectuiv = Switch_GetQueryObjectuiv;\n            BindBuffer = Switch_BindBuffer;\n            DeleteBuffers = Switch_DeleteBuffers;\n            GenBuffers = Switch_GenBuffers;\n            IsBuffer = Switch_IsBuffer;\n            BufferData = Switch_BufferData;\n            BufferSubData = Switch_BufferSubData;\n            GetBufferSubData = Switch_GetBufferSubData;\n            MapBuffer = Switch_MapBuffer;\n            UnmapBuffer = Switch_UnmapBuffer;\n            GetBufferParameteriv = Switch_GetBufferParameteriv;\n            GetBufferPointerv = Switch_GetBufferPointerv;\n\n            // Extension: 2.0\n            BlendEquationSeparate = Switch_BlendEquationSeparate;\n            DrawBuffers = Switch_DrawBuffers;\n            StencilOpSeparate = Switch_StencilOpSeparate;\n            StencilFuncSeparate = Switch_StencilFuncSeparate;\n            StencilMaskSeparate = Switch_StencilMaskSeparate;\n            AttachShader = Switch_AttachShader;\n            BindAttribLocation = Switch_BindAttribLocation;\n            CompileShader = Switch_CompileShader;\n            CreateProgram = Switch_CreateProgram;\n            CreateShader = Switch_CreateShader;\n            DeleteProgram = Switch_DeleteProgram;\n            DeleteShader = Switch_DeleteShader;\n            DetachShader = Switch_DetachShader;\n            DisableVertexAttribArray = Switch_DisableVertexAttribArray;\n            EnableVertexAttribArray = Switch_EnableVertexAttribArray;\n            GetActiveAttrib = Switch_GetActiveAttrib;\n            GetActiveUniform = Switch_GetActiveUniform;\n            GetAttachedShaders = Switch_GetAttachedShaders;\n            GetAttribLocation = Switch_GetAttribLocation;\n            GetProgramiv = Switch_GetProgramiv;\n            GetProgramInfoLog = Switch_GetProgramInfoLog;\n            GetShaderiv = Switch_GetShaderiv;\n            GetShaderInfoLog = Switch_GetShaderInfoLog;\n            GetShaderSource = Switch_GetShaderSource;\n            GetUniformLocation = Switch_GetUniformLocation;\n            GetUniformfv = Switch_GetUniformfv;\n            GetUniformiv = Switch_GetUniformiv;\n            GetVertexAttribdv = Switch_GetVertexAttribdv;\n            GetVertexAttribfv = Switch_GetVertexAttribfv;\n            GetVertexAttribiv = Switch_GetVertexAttribiv;\n            GetVertexAttribPointerv = Switch_GetVertexAttribPointerv;\n            IsProgram = Switch_IsProgram;\n            IsShader = Switch_IsShader;\n            LinkProgram = Switch_LinkProgram;\n            ShaderSource = Switch_ShaderSource;\n            UseProgram = Switch_UseProgram;\n            Uniform1f = Switch_Uniform1f;\n            Uniform2f = Switch_Uniform2f;\n            Uniform3f = Switch_Uniform3f;\n            Uniform4f = Switch_Uniform4f;\n            Uniform1i = Switch_Uniform1i;\n            Uniform2i = Switch_Uniform2i;\n            Uniform3i = Switch_Uniform3i;\n            Uniform4i = Switch_Uniform4i;\n            Uniform1fv = Switch_Uniform1fv;\n            Uniform2fv = Switch_Uniform2fv;\n            Uniform3fv = Switch_Uniform3fv;\n            Uniform4fv = Switch_Uniform4fv;\n            Uniform1iv = Switch_Uniform1iv;\n            Uniform2iv = Switch_Uniform2iv;\n            Uniform3iv = Switch_Uniform3iv;\n            Uniform4iv = Switch_Uniform4iv;\n            UniformMatrix2fv = Switch_UniformMatrix2fv;\n            UniformMatrix3fv = Switch_UniformMatrix3fv;\n            UniformMatrix4fv = Switch_UniformMatrix4fv;\n            ValidateProgram = Switch_ValidateProgram;\n            VertexAttribPointer = Switch_VertexAttribPointer;\n\n            // Extension: 2.1\n            UniformMatrix2x3fv = Switch_UniformMatrix2x3fv;\n            UniformMatrix3x2fv = Switch_UniformMatrix3x2fv;\n            UniformMatrix2x4fv = Switch_UniformMatrix2x4fv;\n            UniformMatrix4x2fv = Switch_UniformMatrix4x2fv;\n            UniformMatrix3x4fv = Switch_UniformMatrix3x4fv;\n            UniformMatrix4x3fv = Switch_UniformMatrix4x3fv;\n\n            // Extension: ARB_vertex_array_object\n            BindVertexArray = Switch_BindVertexArray;\n            DeleteVertexArrays = Switch_DeleteVertexArrays;\n            GenVertexArrays = Switch_GenVertexArrays;\n            IsVertexArray = Switch_IsVertexArray;\n\n            // Extension: ARB_map_buffer_range\n            MapBufferRange = Switch_MapBufferRange;\n            FlushMappedBufferRange = Switch_FlushMappedBufferRange;\n\n            // Extension: ARB_framebuffer_object\n            IsRenderbuffer = Switch_IsRenderbuffer;\n            BindRenderbuffer = Switch_BindRenderbuffer;\n            DeleteRenderbuffers = Switch_DeleteRenderbuffers;\n            GenRenderbuffers = Switch_GenRenderbuffers;\n            RenderbufferStorage = Switch_RenderbufferStorage;\n            GetRenderbufferParameteriv = Switch_GetRenderbufferParameteriv;\n            IsFramebuffer = Switch_IsFramebuffer;\n            BindFramebuffer = Switch_BindFramebuffer;\n            DeleteFramebuffers = Switch_DeleteFramebuffers;\n            GenFramebuffers = Switch_GenFramebuffers;\n            CheckFramebufferStatus = Switch_CheckFramebufferStatus;\n            FramebufferTexture1D = Switch_FramebufferTexture1D;\n            FramebufferTexture2D = Switch_FramebufferTexture2D;\n            FramebufferTexture3D = Switch_FramebufferTexture3D;\n            FramebufferRenderbuffer = Switch_FramebufferRenderbuffer;\n            GetFramebufferAttachmentParameteriv = Switch_GetFramebufferAttachmentParameteriv;\n            GenerateMipmap = Switch_GenerateMipmap;\n            BlitFramebuffer = Switch_BlitFramebuffer;\n            RenderbufferStorageMultisample = Switch_RenderbufferStorageMultisample;\n            FramebufferTextureLayer = Switch_FramebufferTextureLayer;\n\n            // Extension: 3.0\n            ColorMaski = Switch_ColorMaski;\n            GetBooleani_v = Switch_GetBooleani_v;\n            GetIntegeri_v = Switch_GetIntegeri_v;\n            Enablei = Switch_Enablei;\n            Disablei = Switch_Disablei;\n            IsEnabledi = Switch_IsEnabledi;\n            BeginTransformFeedback = Switch_BeginTransformFeedback;\n            EndTransformFeedback = Switch_EndTransformFeedback;\n            BindBufferRange = Switch_BindBufferRange;\n            BindBufferBase = Switch_BindBufferBase;\n            TransformFeedbackVaryings = Switch_TransformFeedbackVaryings;\n            GetTransformFeedbackVarying = Switch_GetTransformFeedbackVarying;\n            ClampColor = Switch_ClampColor;\n            BeginConditionalRender = Switch_BeginConditionalRender;\n            EndConditionalRender = Switch_EndConditionalRender;\n            VertexAttribIPointer = Switch_VertexAttribIPointer;\n            GetVertexAttribIiv = Switch_GetVertexAttribIiv;\n            GetVertexAttribIuiv = Switch_GetVertexAttribIuiv;\n            VertexAttribI1i = Switch_VertexAttribI1i;\n            VertexAttribI2i = Switch_VertexAttribI2i;\n            VertexAttribI3i = Switch_VertexAttribI3i;\n            VertexAttribI4i = Switch_VertexAttribI4i;\n            VertexAttribI1ui = Switch_VertexAttribI1ui;\n            VertexAttribI2ui = Switch_VertexAttribI2ui;\n            VertexAttribI3ui = Switch_VertexAttribI3ui;\n            VertexAttribI4ui = Switch_VertexAttribI4ui;\n            VertexAttribI1iv = Switch_VertexAttribI1iv;\n            VertexAttribI2iv = Switch_VertexAttribI2iv;\n            VertexAttribI3iv = Switch_VertexAttribI3iv;\n            VertexAttribI4iv = Switch_VertexAttribI4iv;\n            VertexAttribI1uiv = Switch_VertexAttribI1uiv;\n            VertexAttribI2uiv = Switch_VertexAttribI2uiv;\n            VertexAttribI3uiv = Switch_VertexAttribI3uiv;\n            VertexAttribI4uiv = Switch_VertexAttribI4uiv;\n            VertexAttribI4bv = Switch_VertexAttribI4bv;\n            VertexAttribI4sv = Switch_VertexAttribI4sv;\n            VertexAttribI4ubv = Switch_VertexAttribI4ubv;\n            VertexAttribI4usv = Switch_VertexAttribI4usv;\n            GetUniformuiv = Switch_GetUniformuiv;\n            BindFragDataLocation = Switch_BindFragDataLocation;\n            GetFragDataLocation = Switch_GetFragDataLocation;\n            Uniform1ui = Switch_Uniform1ui;\n            Uniform2ui = Switch_Uniform2ui;\n            Uniform3ui = Switch_Uniform3ui;\n            Uniform4ui = Switch_Uniform4ui;\n            Uniform1uiv = Switch_Uniform1uiv;\n            Uniform2uiv = Switch_Uniform2uiv;\n            Uniform3uiv = Switch_Uniform3uiv;\n            Uniform4uiv = Switch_Uniform4uiv;\n            TexParameterIiv = Switch_TexParameterIiv;\n            TexParameterIuiv = Switch_TexParameterIuiv;\n            GetTexParameterIiv = Switch_GetTexParameterIiv;\n            GetTexParameterIuiv = Switch_GetTexParameterIuiv;\n            ClearBufferiv = Switch_ClearBufferiv;\n            ClearBufferuiv = Switch_ClearBufferuiv;\n            ClearBufferfv = Switch_ClearBufferfv;\n            ClearBufferfi = Switch_ClearBufferfi;\n            GetStringi = Switch_GetStringi;\n\n            // Extension: ARB_uniform_buffer_object\n            GetUniformIndices = Switch_GetUniformIndices;\n            GetActiveUniformsiv = Switch_GetActiveUniformsiv;\n            GetActiveUniformName = Switch_GetActiveUniformName;\n            GetUniformBlockIndex = Switch_GetUniformBlockIndex;\n            GetActiveUniformBlockiv = Switch_GetActiveUniformBlockiv;\n            GetActiveUniformBlockName = Switch_GetActiveUniformBlockName;\n            UniformBlockBinding = Switch_UniformBlockBinding;\n\n            // Extension: ARB_copy_buffer\n            CopyBufferSubData = Switch_CopyBufferSubData;\n\n            // Extension: 3.1\n            DrawArraysInstanced = Switch_DrawArraysInstanced;\n            DrawElementsInstanced = Switch_DrawElementsInstanced;\n            TexBuffer = Switch_TexBuffer;\n            PrimitiveRestartIndex = Switch_PrimitiveRestartIndex;\n\n            // Legacy\n            EnableClientState = Switch_EnableClientState;\n            DisableClientState = Switch_DisableClientState;\n            VertexPointer = Switch_VertexPointer;\n            NormalPointer = Switch_NormalPointer;\n            ColorPointer = Switch_ColorPointer;\n            TexCoordPointer = Switch_TexCoordPointer;\n            TexEnvi = Switch_TexEnvi;\n            MatrixMode = Switch_MatrixMode;\n            LoadIdentity = Switch_LoadIdentity;\n            Ortho = Switch_Ortho;\n            Color3d = Switch_Color3d;\n        }\n    };\n\n    InitializeVariables g_initVariables;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/src/opencl/runtime/opencl_core.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2010-2013, Advanced Micro Devices, Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the OpenCV Foundation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"../../precomp.hpp\"\n\n#if defined(HAVE_OPENCL) && !defined(HAVE_OPENCL_STATIC)\n\n#include \"opencv2/core.hpp\" // CV_Error\n\n#include \"opencv2/core/opencl/runtime/opencl_core.hpp\"\n\n#define OPENCL_FUNC_TO_CHECK_1_1 \"clEnqueueReadBufferRect\"\n#define ERROR_MSG_CANT_LOAD \"Failed to load OpenCL runtime\\n\"\n#define ERROR_MSG_INVALID_VERSION \"Failed to load OpenCL runtime (expected version 1.1+)\\n\"\n\n#if defined(__APPLE__)\n#include <dlfcn.h>\n\nstatic void* AppleCLGetProcAddress(const char* name)\n{\n    static bool initialized = false;\n    static void* handle = NULL;\n    if (!handle)\n    {\n        if(!initialized)\n        {\n            initialized = true;\n            const char* path = \"/System/Library/Frameworks/OpenCL.framework/Versions/Current/OpenCL\";\n            const char* envPath = getenv(\"OPENCV_OPENCL_RUNTIME\");\n            if (envPath)\n                path = envPath;\n            handle = dlopen(oclpath, RTLD_LAZY | RTLD_GLOBAL);\n            if (handle == NULL)\n            {\n                if (envPath)\n                    fprintf(stderr, ERROR_MSG_CANT_LOAD);\n            }\n            else if (dlsym(handle, OPENCL_FUNC_TO_CHECK_1_1) == NULL)\n            {\n                fprintf(stderr, ERROR_MSG_INVALID_VERSION);\n                handle = NULL;\n            }\n        }\n        if (!handle)\n            return NULL;\n    }\n    return dlsym(handle, name);\n}\n#define CV_CL_GET_PROC_ADDRESS(name) AppleCLGetProcAddress(name)\n#endif // __APPLE__\n\n#if defined(_WIN32)\n#include <windows.h>\n\nstatic void* WinGetProcAddress(const char* name)\n{\n    static bool initialized = false;\n    static HMODULE handle = NULL;\n    if (!handle)\n    {\n        if(!initialized)\n        {\n            initialized = true;\n            handle = GetModuleHandleA(\"OpenCL.dll\");\n            if (!handle)\n            {\n                const char* path = \"OpenCL.dll\";\n                const char* envPath = getenv(\"OPENCV_OPENCL_RUNTIME\");\n                if (envPath)\n                    path = envPath;\n                handle = LoadLibraryA(path);\n                if (!handle)\n                {\n                    if (envPath)\n                        fprintf(stderr, ERROR_MSG_CANT_LOAD);\n                }\n                else if (GetProcAddress(handle, OPENCL_FUNC_TO_CHECK_1_1) == NULL)\n                {\n                    fprintf(stderr, ERROR_MSG_INVALID_VERSION);\n                    handle = NULL;\n                }\n            }\n        }\n        if (!handle)\n            return NULL;\n    }\n    return (void*)GetProcAddress(handle, name);\n}\n#define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n#include <dlfcn.h>\n#include <stdio.h>\n\nstatic void* GetProcAddress(const char* name)\n{\n    static bool initialized = false;\n    static void* handle = NULL;\n    if (!handle)\n    {\n        if(!initialized)\n        {\n            initialized = true;\n            const char* path = \"libOpenCL.so\";\n            const char* envPath = getenv(\"OPENCV_OPENCL_RUNTIME\");\n            if (envPath)\n                path = envPath;\n            handle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n            if (handle == NULL)\n            {\n                if (envPath)\n                    fprintf(stderr, ERROR_MSG_CANT_LOAD);\n            }\n            else if (dlsym(handle, OPENCL_FUNC_TO_CHECK_1_1) == NULL)\n            {\n                fprintf(stderr, ERROR_MSG_INVALID_VERSION);\n                handle = NULL;\n            }\n        }\n        if (!handle)\n            return NULL;\n    }\n    return dlsym(handle, name);\n}\n#define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#ifdef __GNUC__\n#warning(\"OPENCV: OpenCL dynamic library loader: check configuration\")\n#else\n#pragma message(\"WARNING: OPENCV: OpenCL dynamic library loader: check configuration\")\n#endif\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\nstatic void* opencl_check_fn(int ID);\n\n#include \"runtime_common.hpp\"\n\n#include \"autogenerated/opencl_core_impl.hpp\"\n\n//\n// BEGIN OF CUSTOM FUNCTIONS\n//\n\n#define CUSTOM_FUNCTION_ID 1000\n\n#ifdef HAVE_OPENCL_SVM\n#include \"opencv2/core/opencl/runtime/opencl_svm_20.hpp\"\n#define SVM_FUNCTION_ID_START CUSTOM_FUNCTION_ID\n#define SVM_FUNCTION_ID_END CUSTOM_FUNCTION_ID + 100\n\nenum OPENCL_FN_SVM_ID\n{\n    OPENCL_FN_clSVMAlloc = SVM_FUNCTION_ID_START,\n    OPENCL_FN_clSVMFree,\n    OPENCL_FN_clSetKernelArgSVMPointer,\n    OPENCL_FN_clSetKernelExecInfo,\n    OPENCL_FN_clEnqueueSVMFree,\n    OPENCL_FN_clEnqueueSVMMemcpy,\n    OPENCL_FN_clEnqueueSVMMemFill,\n    OPENCL_FN_clEnqueueSVMMap,\n    OPENCL_FN_clEnqueueSVMUnmap,\n};\n\nvoid* (CL_API_CALL *clSVMAlloc)(cl_context context, cl_svm_mem_flags flags, size_t size, unsigned int alignment) =\n        opencl_fn4<OPENCL_FN_clSVMAlloc, void*, cl_context, cl_svm_mem_flags, size_t, unsigned int>::switch_fn;\nstatic const struct DynamicFnEntry _clSVMAlloc_definition = { \"clSVMAlloc\", (void**)&clSVMAlloc};\nvoid (CL_API_CALL *clSVMFree)(cl_context context, void* svm_pointer) =\n        opencl_fn2<OPENCL_FN_clSVMFree, void, cl_context, void*>::switch_fn;\nstatic const struct DynamicFnEntry _clSVMFree_definition = { \"clSVMFree\", (void**)&clSVMFree};\ncl_int (CL_API_CALL *clSetKernelArgSVMPointer)(cl_kernel kernel, cl_uint arg_index, const void* arg_value) =\n        opencl_fn3<OPENCL_FN_clSetKernelArgSVMPointer, cl_int, cl_kernel, cl_uint, const void*>::switch_fn;\nstatic const struct DynamicFnEntry _clSetKernelArgSVMPointer_definition = { \"clSetKernelArgSVMPointer\", (void**)&clSetKernelArgSVMPointer};\n//void* (CL_API_CALL *clSetKernelExecInfo)(cl_kernel kernel, cl_kernel_exec_info param_name, size_t param_value_size, const void* param_value) =\n//        opencl_fn4<OPENCL_FN_clSetKernelExecInfo, void*, cl_kernel, cl_kernel_exec_info, size_t, const void*>::switch_fn;\n//static const struct DynamicFnEntry _clSetKernelExecInfo_definition = { \"clSetKernelExecInfo\", (void**)&clSetKernelExecInfo};\n//cl_int (CL_API_CALL *clEnqueueSVMFree)(...) =\n//        opencl_fn8<OPENCL_FN_clEnqueueSVMFree, cl_int, ...>::switch_fn;\n//static const struct DynamicFnEntry _clEnqueueSVMFree_definition = { \"clEnqueueSVMFree\", (void**)&clEnqueueSVMFree};\ncl_int (CL_API_CALL *clEnqueueSVMMemcpy)(cl_command_queue command_queue, cl_bool blocking_copy, void* dst_ptr, const void* src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event* event_wait_list, cl_event* event) =\n        opencl_fn8<OPENCL_FN_clEnqueueSVMMemcpy, cl_int, cl_command_queue, cl_bool, void*, const void*, size_t, cl_uint, const cl_event*, cl_event*>::switch_fn;\nstatic const struct DynamicFnEntry _clEnqueueSVMMemcpy_definition = { \"clEnqueueSVMMemcpy\", (void**)&clEnqueueSVMMemcpy};\ncl_int (CL_API_CALL *clEnqueueSVMMemFill)(cl_command_queue command_queue, void* svm_ptr, const void* pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event* event_wait_list, cl_event* event) =\n        opencl_fn8<OPENCL_FN_clEnqueueSVMMemFill, cl_int, cl_command_queue, void*, const void*, size_t, size_t, cl_uint, const cl_event*, cl_event*>::switch_fn;\nstatic const struct DynamicFnEntry _clEnqueueSVMMemFill_definition = { \"clEnqueueSVMMemFill\", (void**)&clEnqueueSVMMemFill};\ncl_int (CL_API_CALL *clEnqueueSVMMap)(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags map_flags, void* svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event* event_wait_list, cl_event* event) =\n        opencl_fn8<OPENCL_FN_clEnqueueSVMMap, cl_int, cl_command_queue, cl_bool, cl_map_flags, void*, size_t, cl_uint, const cl_event*, cl_event*>::switch_fn;\nstatic const struct DynamicFnEntry _clEnqueueSVMMap_definition = { \"clEnqueueSVMMap\", (void**)&clEnqueueSVMMap};\ncl_int (CL_API_CALL *clEnqueueSVMUnmap)(cl_command_queue command_queue, void* svm_ptr, cl_uint num_events_in_wait_list, const cl_event* event_wait_list, cl_event* event) =\n        opencl_fn5<OPENCL_FN_clEnqueueSVMUnmap, cl_int, cl_command_queue, void*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nstatic const struct DynamicFnEntry _clEnqueueSVMUnmap_definition = { \"clEnqueueSVMUnmap\", (void**)&clEnqueueSVMUnmap};\n\nstatic const struct DynamicFnEntry* opencl_svm_fn_list[] = {\n    &_clSVMAlloc_definition,\n    &_clSVMFree_definition,\n    &_clSetKernelArgSVMPointer_definition,\n    NULL/*&_clSetKernelExecInfo_definition*/,\n    NULL/*&_clEnqueueSVMFree_definition*/,\n    &_clEnqueueSVMMemcpy_definition,\n    &_clEnqueueSVMMemFill_definition,\n    &_clEnqueueSVMMap_definition,\n    &_clEnqueueSVMUnmap_definition,\n};\n#endif // HAVE_OPENCL_SVM\n\n//\n// END OF CUSTOM FUNCTIONS HERE\n//\n\nstatic void* opencl_check_fn(int ID)\n{\n    const struct DynamicFnEntry* e = NULL;\n    if (ID < CUSTOM_FUNCTION_ID)\n    {\n        assert(ID >= 0 && ID < (int)(sizeof(opencl_fn_list)/sizeof(opencl_fn_list[0])));\n        e = opencl_fn_list[ID];\n    }\n#ifdef HAVE_OPENCL_SVM\n    else if (ID >= SVM_FUNCTION_ID_START && ID < SVM_FUNCTION_ID_END)\n    {\n        ID = ID - SVM_FUNCTION_ID_START;\n        assert(ID >= 0 && ID < (int)(sizeof(opencl_svm_fn_list)/sizeof(opencl_svm_fn_list[0])));\n        e = opencl_svm_fn_list[ID];\n    }\n#endif\n    else\n    {\n        CV_ErrorNoReturn(cv::Error::StsBadArg, \"Invalid function ID\");\n    }\n    void* func = CV_CL_GET_PROC_ADDRESS(e->fnName);\n    if (!func)\n    {\n        throw cv::Exception(cv::Error::OpenCLApiCallError,\n                cv::format(\"OpenCL function is not available: [%s]\", e->fnName),\n                CV_Func, __FILE__, __LINE__);\n    }\n    *(e->ppFn) = func;\n    return func;\n}\n\n#ifdef HAVE_OPENGL\n\n#include \"opencv2/core/opencl/runtime/opencl_gl.hpp\"\n\nstatic void* opencl_gl_check_fn(int ID);\n\n#include \"autogenerated/opencl_gl_impl.hpp\"\n\nstatic void* opencl_gl_check_fn(int ID)\n{\n    const struct DynamicFnEntry* e = NULL;\n    assert(ID >= 0 && ID < (int)(sizeof(opencl_gl_fn_list)/sizeof(opencl_gl_fn_list[0])));\n    e = opencl_gl_fn_list[ID];\n    void* func = CV_CL_GET_PROC_ADDRESS(e->fnName);\n    if (!func)\n    {\n        throw cv::Exception(cv::Error::OpenCLApiCallError,\n                cv::format(\"OpenCL function is not available: [%s]\", e->fnName),\n                CV_Func, __FILE__, __LINE__);\n    }\n    *(e->ppFn) = func;\n    return func;\n}\n\n#endif // HAVE_OPENGL\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/src/opencl/runtime/opencl_clamdblas.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2010-2013, Advanced Micro Devices, Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the OpenCV Foundation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"../../precomp.hpp\"\n\n#ifdef HAVE_CLAMDBLAS\n\n#include \"opencv2/core/opencl/runtime/opencl_core.hpp\"\n#include \"opencv2/core/opencl/runtime/opencl_clamdblas.hpp\"\n\n#if defined(_WIN32)\n#include <windows.h>\n\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdBlas.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdBlas.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdBlas.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#ifdef __GNUC__\n#warning(\"OPENCV: OpenCL BLAS dynamic library loader: check configuration\")\n#else\n#pragma message(\"WARNING: OPENCV: OpenCL BLAS dynamic library loader: check configuration\")\n#endif\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\nstatic void* openclamdblas_check_fn(int ID);\n\n#include \"runtime_common.hpp\"\n\n//\n// BEGIN OF CUSTOM FUNCTIONS\n//\n\n#define CUSTOM_FUNCTION_ID 1000\n\n//\n// END OF CUSTOM FUNCTIONS HERE\n//\n\n#include \"autogenerated/opencl_clamdblas_impl.hpp\"\n\nstatic void* openclamdblas_check_fn(int ID)\n{\n    assert(ID >= 0 && ID < (int)(sizeof(openclamdblas_fn)/sizeof(openclamdblas_fn[0])));\n    const struct DynamicFnEntry* e = openclamdblas_fn[ID];\n    void* func = CV_CL_GET_PROC_ADDRESS(e->fnName);\n    if (!func)\n    {\n        throw cv::Exception(cv::Error::OpenCLApiCallError,\n                cv::format(\"OpenCL AMD BLAS function is not available: [%s]\", e->fnName),\n                CV_Func, __FILE__, __LINE__);\n    }\n    *(e->ppFn) = func;\n    return func;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/src/opencl/runtime/opencl_clamdfft.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2010-2013, Advanced Micro Devices, Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the OpenCV Foundation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"../../precomp.hpp\"\n\n#ifdef HAVE_CLAMDFFT\n\n#include \"opencv2/core/opencl/runtime/opencl_core.hpp\"\n#include \"opencv2/core/opencl/runtime/opencl_clamdfft.hpp\"\n\n#if defined(_WIN32)\n#include <windows.h>\n\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdFft.Runtime.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdFft.Runtime.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdFft.Runtime.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#ifdef __GNUC__\n#warning(\"OPENCV: OpenCL FFT dynamic library loader: check configuration\")\n#else\n#pragma message(\"WARNING: OPENCV: OpenCL FFT dynamic library loader: check configuration\")\n#endif\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\nstatic void* openclamdfft_check_fn(int ID);\n\n#include \"runtime_common.hpp\"\n\n//\n// BEGIN OF CUSTOM FUNCTIONS\n//\n\n#define CUSTOM_FUNCTION_ID 1000\n\n//\n// END OF CUSTOM FUNCTIONS HERE\n//\n\n#include \"autogenerated/opencl_clamdfft_impl.hpp\"\n\nstatic void* openclamdfft_check_fn(int ID)\n{\n    assert(ID >= 0 && ID < (int)(sizeof(openclamdfft_fn)/sizeof(openclamdfft_fn[0])));\n    const struct DynamicFnEntry* e = openclamdfft_fn[ID];\n    void* func = CV_CL_GET_PROC_ADDRESS(e->fnName);\n    if (!func)\n    {\n        throw cv::Exception(cv::Error::OpenCLApiCallError,\n                cv::format(\"OpenCL AMD FFT function is not available: [%s]\", e->fnName),\n                CV_Func, __FILE__, __LINE__);\n    }\n    *(e->ppFn) = func;\n    return func;\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/data/vec_files/trainingfaces_24-24.vec",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/platforms/android/service/engine/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/3rdparty/openexr/IlmImf/ImfPizCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/3rdparty/openexr/IlmImf/ImfZipCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/3rdparty/openexr/IlmImf/ImfRleCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/3rdparty/openexr/Half/half.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/FaceDetection_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/group2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/group3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/FaceDetection/FaceDetection/Assets/group1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/MediaCapture_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/splash-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/windows-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/windows-sdk.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/opencv-logo-150.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/ImageManipulations/assets/opencv-logo-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/MediaCaptureJavaScript_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/splash-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/windows-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/smalllogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/storeLogo-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/squareTile-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/tile-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/storelogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/splashscreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/microsoft-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/JavaScript/images/smallTile-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/OcvImageProcessing_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/Lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/tutorial-3-cameracontrol/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/color-blob-detection/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/face-detection/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/camera-calibration/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/tutorial-4-opencl/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/15-puzzle/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/tutorial-1-camerapreview/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/tutorial-2-mixedprocessing/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/android/image-manipulations/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/SplashScreenImage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/AlignmentGrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/AlignmentGrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OpenCVXaml/OpenCVXaml/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/SplashScreenImage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/AlignmentGrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/tmpl.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/chessboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right02.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right12.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/baboon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/tree.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/detect_blob.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/HappyFish.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left12.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right09.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/box.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left09.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/rubberwhale2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/box_in_scene.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/WindowsLogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/messi5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right07.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left13.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left01.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right06.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/chicky_512.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/768x576.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/notes.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right08.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left03.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/imageTextR.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/lena_tmpl.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/LinuxLogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/templ.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left02.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left06.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right13.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/butterfly.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/aloeR.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/basketball1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right04.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/lena.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right03.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left14.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/aloeGT.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left07.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right11.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left04.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/mask.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/imageTextN.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right05.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left11.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/opencv-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/board.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/starry_night.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/cards.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/aero1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/building.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left05.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/aloeL.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/graf1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/digits.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/left08.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/text_defocus.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/graf3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/home.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/stuff.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/licenseplate_motion.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/blox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right14.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/fruits.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pic3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/right01.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/rubberwhale1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/text_motion.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/basketball2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/aero3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/pca_test1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/data/shape_sample/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/video_capture_xaml.WindowsPhone_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/Logo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/SmallLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/SplashScreen.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/WideLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/Square71x71Logo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/Assets/StoreLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/video_capture_xaml.Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/Logo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/SmallLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/SplashScreen.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/WideLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/Square71x71Logo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/winrt_universal/PhoneTutorial/Assets/StoreLogo.scale-240.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/Data/box.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/Data/resized_IMG_3875.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/cpp/tutorial_code/HighGUI/video-input-psnr-ssim/video/Megamind.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/cpp/tutorial_code/HighGUI/video-input-psnr-ssim/video/Megamind_bugy.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/java/clojure/simple-sample/resources/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/java/sbt/src/main/resources/img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/java/sbt/src/main/resources/AverageMaleFace.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/java/sbt/src/main/resources/img2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/samples/java/sbt/sbt/sbt-launch.jar",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/pattern.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/bodybg.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/acircles_pattern.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv-logo2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/opencv.ico",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/photoicon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/MachineLearnings.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/imgproc.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/videoicon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/featureicon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/obj_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/core.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/intro.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/gui.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/images/calib3d_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/images/video_display.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/images/mouse_drawing.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/images/trackbar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/images/image_display.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/images/drawing.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/py_trackbar/images/trackbar_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/py_drawing_functions/images/drawing_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/py_image_display/images/opencv_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_gui/py_image_display/images/matplotlib_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/images/opticalflow.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/images/lucas.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/images/camshift.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/images/background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_bg_subtraction/images/resmog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_bg_subtraction/images/resmog2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_bg_subtraction/images/resframe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_bg_subtraction/images/resgmg.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_lucas_kanade/images/opticalflow_lk.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_lucas_kanade/images/optical_flow_basic1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_lucas_kanade/images/opticalfb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_meanshift/images/meanshift_basics.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_meanshift/images/meanshift_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_meanshift/images/camshift_face.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_meanshift/images/meanshift_face.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_video/py_meanshift/images/camshift_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_bindings/images/nlm_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture80.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/py_setup_in_windows/images/Capture5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/images/windows_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/images/opencv_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_setup/images/fedora_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_feature_homography/images/homography_findobj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/fast_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/features_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/brief.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/surf_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/orb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/shi_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/harris_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/matching.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/homography_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/images/sift_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_sift_intro/images/sift_scale_invariant.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_sift_intro/images/sift_dog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_sift_intro/images/sift_keypoints.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_sift_intro/images/sift_local_extrema.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_fast/images/fast_kp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_fast/images/fast_eqns.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_fast/images/fast_speedtest.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_surf_intro/images/surf_orientation.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_surf_intro/images/surf_kp2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_surf_intro/images/surf_kp1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_surf_intro/images/surf_matching.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_surf_intro/images/surf_boxfilter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_features_harris/images/subpixel3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_features_harris/images/harris_region.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_features_harris/images/harris_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_matcher/images/matcher_result1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_matcher/images/matcher_result2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_matcher/images/matcher_flann.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_shi_tomasi/images/shitomasi_space.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_shi_tomasi/images/shitomasi_block1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_features_meaning/images/feature_simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_features_meaning/images/feature_building.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_feature2d/py_orb/images/orb_kp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/images/svmicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/images/knnicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/images/kmeansicon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/images/kmeans_demo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/images/kmeans_begin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/images/oc_feature_representation.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/images/oc_color_quantization.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/images/oc_1d_testdata.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/images/oc_2d_clustered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/images/oc_1d_clustered.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/initial_labelling.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/tshirt_grouped.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/final_clusters.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/tshirt.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/update_centroid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_kmeans/py_kmeans_understanding/images/testdata.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_knn/images/knn_icon1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_knn/images/knn_icon2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_knn/py_knn_understanding/images/knn_simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_knn/py_knn_understanding/images/knn_theory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/images/svm_icon2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/images/svm_icon1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/py_svm_opencv/images/deskew.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/py_svm_basics/images/svm_basics1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/py_svm_basics/images/svm_basics3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_ml/py_svm/py_svm_basics/images/svm_basics2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/images/maths_tools.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/images/image_arithmetic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/images/pixel_ops.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/images/speed.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/py_image_arithmetics/images/blending.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/py_image_arithmetics/images/overlay.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/py_basic_ops/images/border.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_core/py_basic_ops/images/roi.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_grabcut/images/grabcut_output1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_grabcut/images/grabcut_rect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_grabcut/images/grabcut_scheme.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_grabcut/images/grabcut_mask.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_sqdiffn_6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_ccoeff_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/messi_face.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/res_mario.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_sqdiff_5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_ccorr_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_ccorrn_4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_template_matching/images/template_ccoeffn_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/pyramid.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/gradient.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/houghcircles.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/blurring.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/canny.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/houghlines.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/colorspace.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/grabcut.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/contours.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/morphology.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/transforms.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/thresh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/template.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/geometric.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/images/watershed.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_transforms/images/transform_fourier.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/images/fft1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/images/fft2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/images/fft5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/images/fft4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_filtering/images/gaussian.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_filtering/images/blur.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_filtering/images/median.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_filtering/images/bilateral.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_filtering/images/filter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_thresholding/images/ada_threshold.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_thresholding/images/threshold.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_thresholding/images/otsu.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_colorspaces/images/frame.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_gradients/images/gradients.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_gradients/images/double_edge.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghlines/images/houghlines5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghlines/images/houghlines3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghlines/images/houghlines2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghlines/images/houghlines4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghlines/images/houghlinesdemo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_geometric_transformations/images/affine.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_geometric_transformations/images/perspective.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_geometric_transformations/images/translation.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_geometric_transformations/images/rotation.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_canny/images/canny1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_canny/images/nms.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_canny/images/hysteresis.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/images/histograms_equ.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/images/histograms_2d.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/images/histograms_bp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/images/histograms_1d.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/images/histogram_rgb_plot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/images/histogram_matplotlib.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/images/histogram_sample.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/images/histogram_masking.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_2d_histogram/images/2dhist_matplotlib.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_2d_histogram/images/2dhist_opencv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/histogram_equalization.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/histeq_numpy1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/clahe_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/equalization_opencv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/histeq_numpy2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/images/clahe_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_histograms/py_histogram_backprojection/images/backproject_opencv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_marker.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_coins.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_dt.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_thresh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_watershed/images/water_fgbg.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_pyramids/images/lap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_pyramids/images/messipyr.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_pyramids/images/orapple.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_pyramids/images/messiup.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_houghcircles/images/houghcircles2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/images/contour_hierarchy.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/images/contour_features.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/images/contour_properties.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/images/contour_defects.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/images/contour_starting.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/circumcircle.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/fitellipse.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/approx.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/fitline.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/convexitydefects.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_features/images/boundingrect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/images/hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/images/tree_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/images/ccomp_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contour_properties/images/extremepoints.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_begin/images/none.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/images/matchshapes.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/images/defects.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/j.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/tophat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/closing.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/erosion.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/blackhat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/dilation.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_imgproc/py_morphological_ops/images/opening.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_objdetect/images/face_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_objdetect/py_face_detection/images/haar_features.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_objdetect/py_face_detection/images/haar.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_objdetect/py_face_detection/images/face.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/images/depthmap_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/images/epipolar_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/images/calibration_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/images/pose_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_pose/images/pose_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_pose/images/pose_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_calibration/images/calib_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_calibration/images/calib_pattern.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_calibration/images/calib_radial.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_depthmap/images/disparity_map.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_depthmap/images/stereo_depth.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_epipolar_geometry/images/essential_matrix.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_epipolar_geometry/images/epiresult.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_calib3d/py_epipolar_geometry/images/epipolar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/images/nlm_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/images/inpainticon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/images/hdr_icon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_non_local_means/images/nlm_multi.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_non_local_means/images/nlm_patch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_non_local_means/images/nlm_result1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_hdr/images/fusion_mertens.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_hdr/images/ldr_debvec.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_hdr/images/exposures.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_hdr/images/crf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_hdr/images/ldr_robertson.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_inpainting/images/inpaint_basics.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/py_tutorials/py_photo/py_inpainting/images/inpaint_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/gpu.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/feature2D.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/imgproc.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/introduction.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/retina.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/objdetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/calib3d.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/ml.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/core.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/photo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/highgui.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/video.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/general.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/images/viz.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/images/camera_calibration_square_chess.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/images/camera_calibration.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/images/real_time_pose_estimation.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/camera_calibration/images/fileListImage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/camera_calibration/images/fileListImageUnDist.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/camera_calibration/images/asymetricalPattern.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/real_time_pose/images/registration.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/calib3d/real_time_pose/images/pnp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/video/images/Background_Subtraction_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/video/background_subtraction/images/Background_Subtraction_Tutorial_Result_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/video/background_subtraction/images/Background_Subtraction_Tutorial_Scheme.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/video/background_subtraction/images/Background_Subtraction_Tutorial_Result_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Result1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Result2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/point_polygon_test/images/Point_Polygon_Test_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/point_polygon_test/images/Point_Polygon_Test_Source_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/images/Bounding_Rects_Circles_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/images/Bounding_Rects_Circles_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/hull/images/Hull_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/hull/images/Hull_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/find_contours/images/Find_Contours_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/find_contours/images/Find_Contours_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rotated_ellipses/images/Bounding_Rotated_Ellipses_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rotated_ellipses/images/Bounding_Rotated_Ellipses_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Pyramids_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Morphology_3_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Morphology_2_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Smoothing_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Morphology_1_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/Threshold_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Hull_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Find_Contours_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Bounding_Rotated_Ellipses_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Point_Polygon_Test_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Moments_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/shapedescriptors/Bounding_Rects_Circles_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Distance_Transformation_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Hough_Circle_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Remap_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Hough_Lines_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Warp_Affine_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/CopyMakeBorder_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Sobel_Derivatives_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Filter_2D_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Canny_Detector_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/imgtrans/Laplace_Operator_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/histograms/Histogram_Calculation_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/histograms/Histogram_Comparison_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/histograms/Histogram_Equalization_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/histograms/Template_Matching_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/images/histograms/Back_Projection_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/images/Smoothing_Tutorial_Result_Median_Filter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/images/Smoothing_Tutorial_theory_gaussian_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Erosion_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Original_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Dilation_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Erosion.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Dilation.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_PyrUp_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_PyrDown_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_Pyramid_Theory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Binary.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Zero_Inverted.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Base_Figure.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Result_Zero.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Binary_Inverted.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Zero.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Example.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Truncate.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Result_Binary_Inverted.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Opening.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_BlackHat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Closing.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_TopHat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_ddIntensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/filter_2d/images/filter_2d_tutorial_kernel_theory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/filter_2d/images/filter_2d_tutorial_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/final.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/sharp.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/black_bg.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/source.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/peaks.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/bin.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/markers.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/dist_transf.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/distance_transformation/images/laplace.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Result_Warp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Result_Warp_Rotate.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/copyMakeBorder/images/CopyMakeBorder_Tutorial_Results.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Theory_ddIntensity.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Theory_Previous.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_circle/images/Hough_Circle_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/hough_circle/images/Hough_Circle_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/canny_detector/images/Canny_Detector_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/imgtrans/canny_detector/images/Canny_Detector_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_BackProj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_Mask.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_BackProj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Theory_Hist0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Theory_Hist1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Original_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Equalized_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Equalized_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Summary.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Image_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Sliding.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/morph12.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/smooth.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/binary.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/morph61.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/linear_horiz.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/morph211.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/morph21.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/morph6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/horiz.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/src.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/imgproc/morph_lines_detection/images/linear_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/eclipse_cpp_logo.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/how_to_write_a_tutorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/visual_studio_image_watch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/windows_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/ubuntu-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/clojure-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/android_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/visual-studio-2010-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/gccegg-65.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/Java_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/eclipse-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/Display_Image_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/images/Load_Save_Image_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesRelease.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/OpenCV_Install_Directory.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertyPageExample.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VCDirectories2010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertyPageAddExisting.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesDebugSmple.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetInsideFolder.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesDebug.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetVS2010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLib.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/AddNewPropertySheet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VCDirectories2008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/NewProjectVisualStudio.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VisualStudioCommandLineArguments.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/OpenCVEditEnviromentVisual.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/SuccessVisualStudioWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVInclude.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_gcc_cmake/images/GCC_CMake_Example_Tutorial.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_run.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_run_face.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/ant_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/cmake_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_eclipse.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/Java_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/desktop_java/images/faceDetection.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/display_image/images/Display_Image_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/10-new-project-created.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/8-add-library.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/7_5-new-java-project.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/4-add-external-jars.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/7-user-library-final.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/5-native-library.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/3-library-name.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/1-window-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/2-user-library-new.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/9-select-user-lib.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/6-external-folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/java_eclipse/images/11-the-code.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/clojure_dev_intro/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/clojure_dev_intro/images/blurred.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/Sphinx_Install.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMake_Configure_Windows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/OpenCV_Install_Directory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/TortoiseSVNCheckout.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/IntelTBB.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/WindowsBuildInstall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMakePackageNotFoundWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMakeSelectBin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMakeOutputPackageNotFound.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/OpenCVBuildResultWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/visualstudiocommandprompt.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/WindowsOpenCVDirPath.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/SVNCheckOutProgress.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/TortoiseSVNCheckoutWindow.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/WindowsQtContoursOutput.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/WindowsBuildDoc.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMakeBuildOptionsOpenCV.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/CMakeBuildWithWindowsGUI.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/qtDownloadThisPackage.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/cmsdstartwindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/WindowsOpenCVInstaller.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/MiktexInstall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/PathEditorOpenCVSetPath.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/PathEditorOpenCVInsertNew.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_install/images/ChangeBuildVisualStudio.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/documenting_opencv/scholarship_cite_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/documenting_opencv/doxygen-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/documenting_opencv/doxygen-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/documenting_opencv/doxygen-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/visual_studio_image_watch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/viewer_context_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/toolwindow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/edges_zoom.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/input_zoom.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/help_button.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/vs_locals.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/breakpoint.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/viewer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/load_save_image/images/Load_Save_Image_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/load_save_image/images/Load_Save_Image_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/biicode/images/biicode.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/biicode/images/bii_lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/biicode/images/biiapp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a15.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/linux_eclipse/images/a10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_06.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_builders.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_refresh.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_main.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_10_crystal_clean.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_11_run_as.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_1a_locate_sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_08.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/emulator_canny.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/android_package_7zip.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_07.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_04.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_adt.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_6_import_existing_projects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_build_resources.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_03.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_ndk_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_opencv_dependency0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8a_target.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_specify_resources.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/device_details.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/AVD_empty.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_9_errors_dissapearing.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_7_select_projects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_build_options.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_1_choose_workspace.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_4_locate_sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/ndk_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/android_emulator_opencv_manager_fail.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8_false_alarm.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_builder_types.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_09.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_opencv_dependency1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_windows_environment.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_2_window_preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_NDK_build_success.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_3_preferences_android.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_cdt_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_cdt.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/android_sdk_and_avd_manager.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/dev_OCV_new_class.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/AVD_create.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_5_import_command.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/cmd_adb_devices.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/dev_OCV_reference.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_05.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_ubuntu.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8b_fix_props.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/images/video-input-psnr-ssim.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/images/Adding_Trackbars_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/images/gdal-io.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/images/video-write.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Trackbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/raster-gdal/images/gdal_flood-zone.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/raster-gdal/images/gdal_heat-map.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/raster-gdal/images/gdal_output.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/video-input-psnr-ssim/images/outputVideoInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/video-write/images/videoCompressSelect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/video-write/images/videoFileStructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/highgui/video-write/images/resultOutputWideoWrite.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/gpu/images/gpu-basics-similarity.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/photo/images/hdr.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/photo/hdr_imaging/images/fusion.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/photo/hdr_imaging/images/memorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/photo/hdr_imaging/images/ldr.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/images/image_effects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/images/facedetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/images/intro.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/transformations/images/global_view_point.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/transformations/images/camera_view_point.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/widget_pose/images/widgetpose.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/launching_viz/images/window_demo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/viz/creating_widgets/images/red_triangle.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Drawing_2_Tutorial_Result_7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/howToScanImages.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Basic_Linear_Transform_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Drawing_1_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/How_To_Use_IPPA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/interopOpenCV1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Adding_Images_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Smoothing_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/discrete_fourier_transform.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/matTheBasicImageStructure.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/matMaskFilter2DOp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/file_input_output_with_xml_yml.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/images/Morphology_1_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/how_to_use_ippa_conversion/images/How_To_Use_IPPA_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicImageForComputer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/interoperability_with_OpenCV_1/images/outputInteropOpenCV1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/mat-mask-operations/images/resultMatMaskFilter2D.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/basic_linear_transform/images/Basic_Linear_Transform_Tutorial_Result_big.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/basic_geometric_drawing/images/Drawing_1_Tutorial_Result_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/adding_images/images/Adding_Images_Tutorial_Result_Big.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/how_to_scan_images/tutorial_how_matrix_stored_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/how_to_scan_images/tutorial_how_matrix_stored_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/discrete_fourier_transform/images/result_normal.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/discrete_fourier_transform/images/result_rotated.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_big.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/images/image_effects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/images/facedetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/images/intro.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/hello/images/output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/hello/images/view_did_load.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/hello/images/header_directive.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/hello/images/linking_opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_framework_drag_and_drop.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_viewcontroller_layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_frameworks_add_dependencies.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ios/image_manipulation/images/output.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/objdetect/images/Cascade_Classifier_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/objdetect/cascade_classifier/images/Cascade_Classifier_Tutorial_Result_Haar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/objdetect/cascade_classifier/images/Cascade_Classifier_Tutorial_Result_LBP.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/images/introduction_to_svm.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/images/non_linear_svms.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/images/introduction_to_pca_cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_svm/images/optimal-hyperplane.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_svm/images/separating-lines.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_svm/images/svm_intro_result.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/non_linear_svms/images/sample-errors-dist.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/non_linear_svms/images/svm_non_linear_result.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_pca/images/output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_pca/images/pca_eigen.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_pca/images/pca_line.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/ml/introduction_to_pca/images/pca_test1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/AKAZE_Tracking_Tutorial_Cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/Feature_Description_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/AKAZE_Match_Tutorial_Cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/Feature_Detection_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/Feature_Flann_Matcher_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/Feature_Homography_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/detection_of_planar_objects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/trackingmotion/Generic_Corner_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/trackingmotion/Shi_Tomasi_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/trackingmotion/Corner_Subpixeles_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/images/trackingmotion/Harris_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_detection/images/Feature_Detection_Result_b.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_detection/images/Feature_Detection_Result_a.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_description/images/Feature_Description_BruteForce_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/akaze_tracking/images/frame.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_flann_matcher/images/Featur_FlannMatcher_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_flann_matcher/images/Feature_FlannMatcher_Keypoints_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/good_features_to_track/images/Feature_Detection_Result_b.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/good_features_to_track/images/Feature_Detection_Result_a.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/corner_subpixeles/images/Corner_Subpixeles_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/corner_subpixeles/images/Corner_Subpixeles_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/generic_corner_detector/images/My_Shi_Tomasi_corner_detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/generic_corner_detector/images/My_Harris_corner_detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/harris_detector/images/Harris_Detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/trackingmotion/harris_detector/images/Harris_Detector_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/feature_homography/images/Feature_Homography_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/akaze_matching/images/res.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/doc/tutorials/features2d/akaze_matching/images/graf.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/calib3d/doc/pics/stereo_undistort.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/calib3d/doc/pics/fisheye_undistorted.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/minenclosingtriangle.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/quadedge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/logpolar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/backprojectpatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/defects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/cornersubpix.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/inv_logpolar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/ellipse.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/threshold.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/subdiv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/bayer.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/houghp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/building_lsd.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/minareabox.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/contoursecarea.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/pointpolygon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/building.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/intersection.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/integral.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/boundingrect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_ocean.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_bone.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_winter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_mkpj1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_summer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_pink.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_hsv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_rainbow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_jet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_autumn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_cool.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_mkpj2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_spring.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_parula.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/imgproc/doc/pics/colormaps/colorscale_hot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/74.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/122.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/85.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/81.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/89.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/125.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/82.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/48.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/83.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/37.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/112.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/49.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/54.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/43.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/121.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/55.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/53.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/79.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/71.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/57.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/123.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/92.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/50.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/103.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/73.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/68.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/22.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/23.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/117.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/41.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/47.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/59.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/35.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/67.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/31.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/51.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/29.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/66.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/126.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/25.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/131.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/101.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/40.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/45.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/80.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/118.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/21.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/70.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/107.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/76.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/111.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/114.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/116.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/106.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/58.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/75.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/38.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/39.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/104.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/119.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/110.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/44.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/94.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/109.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/46.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/86.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/26.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/93.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/90.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/77.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/84.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/56.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/63.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/98.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/113.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/102.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/87.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/115.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/130.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/120.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/105.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/33.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/78.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/60.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/42.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/64.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/72.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/28.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/69.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/91.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/88.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/108.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/96.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/27.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/65.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/34.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/36.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/52.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/62.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/99.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/61.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/129.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/24.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/97.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/95.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/124.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/48/127.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/74.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/122.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/85.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/81.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/89.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/125.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/82.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/48.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/83.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/37.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/112.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/49.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/54.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/43.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/121.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/55.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/53.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/79.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/71.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/57.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/123.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/92.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/50.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/103.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/73.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/68.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/22.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/23.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/117.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/41.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/47.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/59.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/35.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/67.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/31.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/51.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/29.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/66.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/126.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/25.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/131.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/101.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/40.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/45.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/80.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/118.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/21.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/70.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/107.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/76.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/111.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/114.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/116.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/106.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/58.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/75.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/38.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/39.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/104.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/119.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/110.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/44.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/94.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/109.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/46.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/86.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/26.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/93.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/90.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/77.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/84.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/56.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/63.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/98.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/113.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/102.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/87.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/115.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/130.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/120.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/105.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/33.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/78.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/60.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/42.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/64.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/72.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/28.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/69.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/91.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/88.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/108.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/96.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/27.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/65.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/34.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/36.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/52.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/62.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/99.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/61.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/129.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/24.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/97.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/95.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/124.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/src/files_Qt/Milky/64/127.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/highgui/doc/pics/qtgui.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/viz/doc/images/cpw2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/viz/doc/images/cpw3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/viz/doc/images/cube_widget.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/viz/doc/images/cpw1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/doc/pics/memstorage1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/doc/pics/NormTypes_OneArray_1-2-INF.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/doc/pics/memstorage2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/core/doc/pics/rotatedrect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/objdetect/doc/pics/haarfeatures.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/java/common_test/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/java/common_test/res/drawable/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/java/common_test/res/drawable/chessboard.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/java/pure_test/lib/junit-4.11.jar",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/ml/doc/pics/SVM_Comparison.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/ml/doc/pics/neuron_model.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/ml/doc/pics/mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/ml/doc/pics/sigmoid_bipolar.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-3.1.0-iepi3qv64dcf5pae2aakjs77vig2djma/spack-src/modules/stitching/doc/StitchingPipeline.jpg"
    ],
    "total_files": 4616
}