{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine/jni/NativeService/PackageInfo.cpp": "#include \"EngineCommon.h\"\n#include \"PackageInfo.h\"\n#include \"HardwareDetector.h\"\n#include \"IOpenCVEngine.h\"\n#include \"StringUtils.h\"\n#include <assert.h>\n#include <vector>\n#include <utils/Log.h>\n#include <dlfcn.h>\n\nusing namespace std;\n\nmap<int, string> PackageInfo::InitPlatformNameMap()\n{\n    map<int, string> result;\n\n    // TODO: Do not forget to add Platrfom constant to HardwareDetector.h\n    result[PLATFORM_TEGRA] = PLATFORM_TEGRA_NAME;\n    result[PLATFORM_TEGRA2] = PLATFORM_TEGRA2_NAME;\n    result[PLATFORM_TEGRA3] = PLATFORM_TEGRA3_NAME;\n    result[PLATFORM_TEGRA4] = PLATFORM_TEGRA4_NAME;\n    result[PLATFORM_TEGRA4i] = PLATFORM_TEGRA4_NAME;\n    result[PLATFORM_TEGRA5] = PLATFORM_TEGRA5_NAME;\n\n    return result;\n}\n\nconst map<int, string> PackageInfo::PlatformNameMap = InitPlatformNameMap();\nconst string PackageInfo::BasePackageName = \"org.opencv.lib\";\nconst string  DEFAULT_ENGINE_INSTALL_PATH = \"/data/data/org.opencv.engine\";\n\ninline string JoinARMFeatures(int cpu_id)\n{\n    string result;\n\n    if (FEATURES_HAS_NEON2 & cpu_id)\n    {\n        if (!((ARCH_ARMv5 & cpu_id) || (ARCH_ARMv6 & cpu_id) ||(ARCH_ARMv7 & cpu_id)))\n            result = string(FEATURES_HAS_NEON2_NAME);\n    }\n    else if (FEATURES_HAS_NEON & cpu_id)\n    {\n        if (!((ARCH_ARMv5 & cpu_id) || (ARCH_ARMv6 & cpu_id)))\n            result = string(FEATURES_HAS_NEON_NAME);\n    }\n    else if (FEATURES_HAS_VFPv3 & cpu_id)\n    {\n        if ((ARCH_ARMv5 & cpu_id) || (ARCH_ARMv6 & cpu_id))\n            result = string(FEATURES_HAS_VFPv3_NAME);\n    }\n    else if (FEATURES_HAS_VFPv3d16 & cpu_id)\n    {\n        if ((ARCH_ARMv5 & cpu_id) || (ARCH_ARMv6 & cpu_id))\n            result = string(FEATURES_HAS_VFPv3d16_NAME);\n    }\n\n    return result;\n}\n\ninline int SplitARMFeatures(const vector<string>& features)\n{\n    int result = 0;\n\n    for (size_t i = 3; i < features.size(); i++)\n    {\n        if (FEATURES_HAS_VFPv3_NAME == features[i])\n        {\n            result |= FEATURES_HAS_VFPv3;\n        }\n        else if (FEATURES_HAS_VFPv3d16_NAME == features[i])\n        {\n            result |= FEATURES_HAS_VFPv3d16;\n        }\n        else if (FEATURES_HAS_NEON_NAME == features[i])\n        {\n            result |= FEATURES_HAS_NEON;\n        }\n        else if (FEATURES_HAS_NEON2_NAME == features[i])\n        {\n            result |= FEATURES_HAS_NEON2;\n        }\n    }\n\n    return result;\n}\n\ninline string JoinIntelFeatures(int cpu_id)\n{\n    string result;\n\n    if (FEATURES_HAS_SSSE3 & cpu_id)\n    {\n        result = FEATURES_HAS_SSSE3_NAME;\n    }\n    else if (FEATURES_HAS_SSE2 & cpu_id)\n    {\n        result = FEATURES_HAS_SSE2_NAME;\n    }\n    else if (FEATURES_HAS_SSE & cpu_id)\n    {\n        result = FEATURES_HAS_SSE_NAME;\n    }\n\n    return result;\n}\n\ninline int SplitIntelFeatures(const vector<string>& features)\n{\n    int result = 0;\n\n    for (size_t i = 3; i < features.size(); i++)\n    {\n        if (FEATURES_HAS_SSSE3_NAME == features[i])\n        {\n            result |= FEATURES_HAS_SSSE3;\n        }\n        else if (FEATURES_HAS_SSE2_NAME == features[i])\n        {\n            result |= FEATURES_HAS_SSE2;\n        }\n        else if (FEATURES_HAS_SSE_NAME == features[i])\n        {\n            result |= FEATURES_HAS_SSE;\n        }\n    }\n\n    return result;\n}\n\ninline int SplitVersion(const vector<string>& features, const string& package_version)\n{\n    int result = 0;\n\n    if ((features.size() > 1) && ('v' == features[1][0]))\n    {\n        // Taking major and minor mart of library version from package name\n        string tmp1 = features[1].substr(1);\n        result += atoi(tmp1.substr(0,1).c_str())*1000000 + atoi(tmp1.substr(1,1).c_str())*10000;\n\n        // Taking release and build number from package revision\n        vector<string> tmp2 = SplitStringVector(package_version, '.');\n        if (tmp2.size() == 2)\n        {\n            // the 2nd digit is revision\n            result += atoi(tmp2[0].c_str())*100 + 00;\n        }\n        else\n        {\n            // the 2nd digit is part of library version\n            // the 3rd digit is revision\n            result += atoi(tmp2[0].c_str())*100 + atoi(tmp2[1].c_str());\n        }\n    }\n    else\n    {\n        // TODO: Report package name format error\n    }\n\n    return result;\n}\n\ninline string JoinPlatform(int platform)\n{\n    string result;\n    map<int, string>::const_iterator it = PackageInfo::PlatformNameMap.find(platform);\n\n    assert(PackageInfo::PlatformNameMap.end() != it);\n    result = it->second;\n\n    return result;\n}\n\ninline int SplitPlatform(const vector<string>& features)\n{\n    int result = 0;\n\n    if (features.size() > 2)\n    {\n        string tmp = features[2];\n        if (PLATFORM_TEGRA_NAME == tmp)\n        {\n            result = PLATFORM_TEGRA;\n        }\n        else if (PLATFORM_TEGRA2_NAME == tmp)\n        {\n            result = PLATFORM_TEGRA2;\n        }\n        else if (PLATFORM_TEGRA3_NAME == tmp)\n        {\n            result = PLATFORM_TEGRA3;\n        }\n        else if (PLATFORM_TEGRA4_NAME == tmp)\n        {\n            result = PLATFORM_TEGRA4;\n        }\n    }\n    else\n    {\n        // TODO: Report package name format error\n    }\n\n    return result;\n}\n\n/* Package naming convention\n * All parts of package name separated by \"_\" symbol\n * First part is base namespace.\n * Second part is version. Version starts from \"v\" symbol. After \"v\" symbol version nomber without dot symbol added.\n * If platform is known third part is platform name\n * If platform is unknown it is defined by hardware capabilities using pattern: <arch>_<floating point and vectorization features>_<other features>\n * Example: armv7_neon\n */\nPackageInfo::PackageInfo(int version, int platform, int cpu_id, std::string install_path):\n    Version(version),\n    Platform(platform),\n    CpuID(cpu_id),\n    InstallPath(\"\")\n{\n    #ifndef __SUPPORT_TEGRA3\n    Platform = PLATFORM_UNKNOWN;\n    #endif\n\n    int major_version = version/1000000;\n    int minor_version = version/10000 - major_version*100;\n\n    char tmp[32];\n\n    sprintf(tmp, \"%d%d\", major_version, minor_version);\n\n    FullName = BasePackageName + std::string(\"_v\") + std::string(tmp);\n    if (PLATFORM_UNKNOWN != Platform)\n    {\n        FullName += string(\"_\") + JoinPlatform(platform);\n    }\n    else\n    {\n        if (ARCH_UNKNOWN != CpuID)\n        {\n            if (ARCH_X86 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch x86\");\n                FullName += string(\"_\") + ARCH_X86_NAME;\n                #ifdef __SUPPORT_INTEL_FEATURES\n                string features = JoinIntelFeatures(CpuID);\n                if (!features.empty())\n                {\n                    FullName += string(\"_\") + features;\n                }\n                #endif\n            }\n            else if (ARCH_X64 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch x64\");\n                #ifdef __SUPPORT_INTEL_x64\n                FullName += string(\"_\") + ARCH_X64_NAME;\n                #else\n                FullName += string(\"_\") + ARCH_X86_NAME;\n                #endif\n                #ifdef __SUPPORT_INTEL_FEATURES\n                string features = JoinIntelFeatures(CpuID);\n                if (!features.empty())\n                {\n                    FullName += string(\"_\") + features;\n                }\n                #endif\n            }\n            else if (ARCH_ARMv5 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch ARMv5\");\n                FullName += string(\"_\") + ARCH_ARMv5_NAME;\n                #ifdef __SUPPORT_ARMEABI_FEATURES\n                string features = JoinARMFeatures(CpuID);\n                if (!features.empty())\n                {\n                    FullName += string(\"_\") + features;\n                }\n                #endif\n            }\n            else if (ARCH_ARMv6 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch ARMv6\");\n                // NOTE: ARM v5 used instead ARM v6\n                //FullName += string(\"_\") + ARCH_ARMv6_NAME;\n                FullName += string(\"_\") + ARCH_ARMv5_NAME;\n                #ifdef __SUPPORT_ARMEABI_FEATURES\n                string features = JoinARMFeatures(CpuID);\n                if (!features.empty())\n                {\n                    FullName += string(\"_\") + features;\n                }\n                #endif\n            }\n            else if (ARCH_ARMv7 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch ARMv7\");\n                FullName += string(\"_\") + ARCH_ARMv7_NAME;\n                #ifdef __SUPPORT_ARMEABI_V7A_FEATURES\n                string features = JoinARMFeatures(CpuID);\n                if (!features.empty())\n                {\n                    FullName += string(\"_\") + features;\n                }\n                #endif\n            }\n            #ifdef __SUPPORT_AARCH64\n            else if (ARCH_AARCH64 & CpuID)\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch AARCH64\");\n                FullName += string(\"_\") + ARCH_AARCH64_NAME;\n            }\n            #endif\n            #ifdef __SUPPORT_MIPS\n            else if (ARCH_MIPS & CpuID)\n            {\n                FullName += string(\"_\") + ARCH_MIPS_NAME;\n            }\n            #endif\n            else\n            {\n                LOGD(\"PackageInfo::PackageInfo: package arch unknown\");\n                Version = 0;\n                CpuID = ARCH_UNKNOWN;\n                Platform = PLATFORM_UNKNOWN;\n            }\n        }\n        else\n        {\n            LOGD(\"PackageInfo::PackageInfo: package arch unknown\");\n            Version = 0;\n            CpuID = ARCH_UNKNOWN;\n            Platform = PLATFORM_UNKNOWN;\n        }\n    }\n\n    if (!FullName.empty())\n    {\n        InstallPath = install_path + FullName + \"/lib\";\n    }\n}\n\nPackageInfo::PackageInfo(const string& fullname, const string& install_path, string package_version):\nFullName(fullname),\nInstallPath(install_path)\n{\n    LOGD(\"PackageInfo::PackageInfo(\\\"%s\\\", \\\"%s\\\", \\\"%s\\\")\", fullname.c_str(), install_path.c_str(), package_version.c_str());\n\n    assert(!fullname.empty());\n    assert(!install_path.empty());\n\n    if (OPENCV_ENGINE_PACKAGE == fullname)\n    {\n        // Science version 1.7 OpenCV Manager has it's own version of OpenCV inside\n        // Load libopencv_info.so to understand OpenCV version, platform and other features\n        std::string tmp;\n        if (install_path.empty())\n        {\n            tmp = std::string(DEFAULT_ENGINE_INSTALL_PATH) + \"/\" + LIB_OPENCV_INFO_NAME;\n        }\n        else\n        {\n            tmp = install_path + \"/\" + LIB_OPENCV_INFO_NAME;\n        }\n\n        LOGD(\"Trying to load info library \\\"%s\\\"\", tmp.c_str());\n\n            void* handle;\n            InfoFunctionType name_func;\n            InfoFunctionType revision_func;\n\n            handle = dlopen(tmp.c_str(), RTLD_LAZY);\n            if (handle)\n            {\n                const char* error;\n\n                dlerror();\n                name_func = (InfoFunctionType)dlsym(handle, \"GetPackageName\");\n                revision_func = (InfoFunctionType)dlsym(handle, \"GetRevision\");\n                error = dlerror();\n\n                if (!error && revision_func && name_func)\n                {\n                    FullName = std::string((*name_func)());\n                    package_version = std::string((*revision_func)());\n                    dlclose(handle);\n                    LOGI(\"OpenCV package \\\"%s\\\" revision \\\"%s\\\" found\", FullName.c_str(), package_version.c_str());\n                }\n                else\n                {\n                    LOGE(\"Library loading error (%p, %p): \\\"%s\\\"\", name_func, revision_func, error);\n                }\n            }\n            else\n            {\n                LOGI(\"Info library not found in package\");\n                LOGI(\"OpenCV Manager package does not contain any verison of OpenCV library\");\n                Version = 0;\n                CpuID = ARCH_UNKNOWN;\n                Platform = PLATFORM_UNKNOWN;\n                return;\n            }\n    }\n\n    vector<string> features = SplitStringVector(FullName, '_');\n\n    if (!features.empty() && (BasePackageName == features[0]))\n    {\n        Version = SplitVersion(features, package_version);\n        if (0 == Version)\n        {\n            CpuID = ARCH_UNKNOWN;\n            Platform = PLATFORM_UNKNOWN;\n            return;\n        }\n\n        Platform = SplitPlatform(features);\n        if (PLATFORM_UNKNOWN != Platform)\n        {\n            switch (Platform)\n            {\n                case PLATFORM_TEGRA2:\n                {\n                    CpuID = ARCH_ARMv7 | FEATURES_HAS_VFPv3d16;\n                } break;\n                case PLATFORM_TEGRA3:\n                {\n                    CpuID = ARCH_ARMv7 | FEATURES_HAS_VFPv3 | FEATURES_HAS_NEON;\n                } break;\n                case PLATFORM_TEGRA4:\n                {\n                    CpuID = ARCH_ARMv7 | FEATURES_HAS_VFPv3 | FEATURES_HAS_NEON;\n                } break;\n            }\n        }\n        else\n        {\n            if (features.size() < 3)\n            {\n                LOGD(\"It is not OpenCV library package for this platform\");\n                Version = 0;\n                CpuID = ARCH_UNKNOWN;\n                Platform = PLATFORM_UNKNOWN;\n                return;\n            }\n            else if (ARCH_ARMv5_NAME == features[2])\n            {\n                CpuID = ARCH_ARMv5 | SplitARMFeatures(features);\n            }\n            else if (ARCH_ARMv6_NAME == features[2])\n            {\n                CpuID = ARCH_ARMv6 | SplitARMFeatures(features);\n            }\n            else if (ARCH_ARMv7_NAME == features[2])\n            {\n                CpuID = ARCH_ARMv7 | SplitARMFeatures(features);\n            }\n            #ifdef __SUPPORT_AARCH64\n            else if (ARCH_AARCH64_NAME == features[2])\n            {\n                CpuID = ARCH_AARCH64 | SplitARMFeatures(features);\n            }\n            #endif\n            else if (ARCH_X86_NAME == features[2])\n            {\n                CpuID = ARCH_X86 | SplitIntelFeatures(features);\n            }\n            #ifdef __SUPPORT_INTEL_x64\n            else if (ARCH_X64_NAME == features[2])\n            {\n                CpuID = ARCH_X64 | SplitIntelFeatures(features);\n            }\n            #endif\n            #ifdef __SUPPORT_MIPS\n            else if (ARCH_MIPS_NAME == features[2])\n            {\n                CpuID = ARCH_MIPS;\n            }\n            #endif\n            else\n            {\n                LOGD(\"It is not OpenCV library package for this platform\");\n                Version = 0;\n                CpuID = ARCH_UNKNOWN;\n                Platform = PLATFORM_UNKNOWN;\n                return;\n            }\n        }\n    }\n    else\n    {\n        LOGD(\"It is not OpenCV library package for this platform\");\n        Version = 0;\n        CpuID = ARCH_UNKNOWN;\n        Platform = PLATFORM_UNKNOWN;\n        return;\n    }\n}\n\nbool PackageInfo::IsValid() const\n{\n    return !((0 == Version) && (PLATFORM_UNKNOWN == Platform) && (ARCH_UNKNOWN == CpuID));\n}\n\nint PackageInfo::GetPlatform() const\n{\n    return Platform;\n}\n\nint PackageInfo::GetCpuID() const\n{\n    return CpuID;\n}\n\nstring PackageInfo::GetFullName() const\n{\n    return FullName;\n}\n\nint PackageInfo::GetVersion() const\n{\n    return Version;\n}\n\nstring PackageInfo::GetInstalationPath() const\n{\n    return InstallPath;\n}\n\nbool PackageInfo::operator==(const PackageInfo& package) const\n{\n    return (package.FullName == FullName);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine/jni/JNIWrapper/OpenCVLibraryInfo.cpp": "#include \"OpenCVLibraryInfo.h\"\n#include \"EngineCommon.h\"\n#include <utils/Log.h>\n#include <dlfcn.h>\n\nJNIEXPORT jlong JNICALL Java_org_opencv_engine_OpenCVLibraryInfo_open\n  (JNIEnv * env, jobject, jstring str)\n{\n    const char* infoLibPath = env->GetStringUTFChars(str, NULL);\n    if (infoLibPath == NULL)\n        return 0;\n\n    LOGD(\"Trying to load info library \\\"%s\\\"\", infoLibPath);\n\n    void* handle;\n\n    handle = dlopen(infoLibPath, RTLD_LAZY);\n    if (handle == NULL)\n        LOGI(\"Info library not found by path \\\"%s\\\"\", infoLibPath);\n\n    return (jlong)handle;\n}\n\nJNIEXPORT jstring JNICALL Java_org_opencv_engine_OpenCVLibraryInfo_getPackageName\n  (JNIEnv* env, jobject, jlong handle)\n{\n    InfoFunctionType info_func;\n    const char* result;\n    const char* error;\n\n    dlerror();\n    info_func = (InfoFunctionType)dlsym((void*)handle, \"GetPackageName\");\n    if ((error = dlerror()) == NULL)\n        result = (*info_func)();\n    else\n    {\n        LOGE(\"dlsym error: \\\"%s\\\"\", error);\n        result = \"unknown\";\n    }\n\n    return env->NewStringUTF(result);\n}\n\nJNIEXPORT jstring JNICALL Java_org_opencv_engine_OpenCVLibraryInfo_getLibraryList\n  (JNIEnv* env, jobject, jlong handle)\n{\n    InfoFunctionType info_func;\n    const char* result;\n    const char* error;\n\n    dlerror();\n    info_func = (InfoFunctionType)dlsym((void*)handle, \"GetLibraryList\");\n    if ((error = dlerror()) == NULL)\n        result = (*info_func)();\n    else\n    {\n        LOGE(\"dlsym error: \\\"%s\\\"\", error);\n        result = \"unknown\";\n    }\n\n    return env->NewStringUTF(result);\n}\n\nJNIEXPORT jstring JNICALL Java_org_opencv_engine_OpenCVLibraryInfo_getVersionName\n  (JNIEnv* env, jobject, jlong handle)\n{\n    InfoFunctionType info_func;\n    const char* result;\n    const char* error;\n\n    dlerror();\n    info_func = (InfoFunctionType)dlsym((void*)handle, \"GetRevision\");\n    if ((error = dlerror()) == NULL)\n        result = (*info_func)();\n    else\n    {\n        LOGE(\"dlsym error: \\\"%s\\\"\", error);\n        result = \"unknown\";\n    }\n\n    return env->NewStringUTF(result);\n}\n\nJNIEXPORT void JNICALL Java_org_opencv_engine_OpenCVLibraryInfo_close\n  (JNIEnv*, jobject, jlong handle)\n{\n    dlclose((void*)handle);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine/jni/BinderComponent/OpenCVEngine.cpp": "#include \"EngineCommon.h\"\n#include \"OpenCVEngine.h\"\n#include \"HardwareDetector.h\"\n#include \"StringUtils.h\"\n#include <utils/Log.h>\n#include <assert.h>\n#include <string>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <dlfcn.h>\n\nusing namespace android;\n\nconst int OpenCVEngine::Platform = DetectKnownPlatforms();\nconst int OpenCVEngine::CpuID = GetCpuID();\nconst int OpenCVEngine::KnownVersions[] = {2040000, 2040100, 2040200, 2040300, 2040301, 2040302, 2040400, 2040500, 2040600, 2040700, 2040701, 2040800, 2040900, 2041000, 2041100, 2041200};\n\nbool OpenCVEngine::ValidateVersion(int version)\n{\n    for (size_t i = 0; i < sizeof(KnownVersions)/sizeof(int); i++)\n        if (KnownVersions[i] == version)\n            return true;\n\n    return false;\n}\n\nint OpenCVEngine::NormalizeVersionString(std::string version)\n{\n    int result = 0;\n\n    if (version.empty())\n    {\n        return result;\n    }\n\n    std::vector<std::string> parts = SplitStringVector(version, '.');\n\n    // Use only 4 digits of the version, i.e. 1.2.3.4.\n    // Other digits will be ignored.\n    if (parts.size() > 4)\n        parts.erase(parts.begin()+4, parts.end());\n\n    int multiplyer = 1000000;\n    for (std::vector<std::string>::const_iterator it = parts.begin(); it != parts.end(); ++it)\n    {\n        int digit = atoi(it->c_str());\n        result += multiplyer*digit;\n        multiplyer /= 100;\n    }\n\n    if (!ValidateVersion(result))\n        result  = 0;\n\n    return result;\n}\n\nOpenCVEngine::OpenCVEngine(IPackageManager* PkgManager):\n    PackageManager(PkgManager)\n{\n    assert(PkgManager);\n}\n\nint32_t OpenCVEngine::GetVersion()\n{\n    return OPEN_CV_ENGINE_VERSION;\n}\n\nString16 OpenCVEngine::GetLibPathByVersion(android::String16 version)\n{\n    std::string std_version(String8(version).string());\n    int norm_version;\n    std::string path;\n\n    LOGD(\"OpenCVEngine::GetLibPathByVersion(%s) impl\", String8(version).string());\n\n    norm_version = NormalizeVersionString(std_version);\n\n    if (0 != norm_version)\n    {\n        path = PackageManager->GetPackagePathByVersion(norm_version, Platform, CpuID);\n        if (path.empty())\n        {\n            LOGI(\"Package OpenCV of version \\\"%s\\\" (%d) is not installed. Try to install it :)\", String8(version).string(), norm_version);\n        }\n        else\n        {\n            FixPermissions(path);\n        }\n    }\n    else\n    {\n        LOGE(\"OpenCV version \\\"%s\\\" (%d) is not supported\", String8(version).string(), norm_version);\n    }\n\n    return String16(path.c_str());\n}\n\nandroid::String16 OpenCVEngine::GetLibraryList(android::String16 version)\n{\n    std::string std_version = String8(version).string();\n    int norm_version;\n    String16 result;\n    norm_version = NormalizeVersionString(std_version);\n\n    if (0 != norm_version)\n    {\n        std::string tmp = PackageManager->GetPackagePathByVersion(norm_version, Platform, CpuID);\n        if (!tmp.empty())\n        {\n            tmp += (std::string(\"/\") + LIB_OPENCV_INFO_NAME);\n\n            LOGD(\"Trying to load info library \\\"%s\\\"\", tmp.c_str());\n\n            void* handle;\n            InfoFunctionType info_func;\n\n            handle = dlopen(tmp.c_str(), RTLD_LAZY);\n            if (handle)\n            {\n                const char* error;\n\n                dlerror();\n                info_func = (InfoFunctionType)dlsym(handle, \"GetLibraryList\");\n                if ((error = dlerror()) == NULL)\n                {\n                    result = String16((*info_func)());\n                    dlclose(handle);\n                }\n                else\n                {\n                    LOGE(\"Library loading error: \\\"%s\\\"\", error);\n                }\n            }\n            else\n            {\n                LOGI(\"Info library not found in package\");\n            }\n        }\n        else\n        {\n            LOGI(\"Package OpenCV of version \\\"%s\\\" (%d) is not installed. Try to install it :)\", std_version.c_str(), norm_version);\n        }\n    }\n    else\n    {\n        LOGE(\"OpenCV version \\\"%s\\\" is not supported\", std_version.c_str());\n    }\n\n    return result;\n}\n\nbool OpenCVEngine::InstallVersion(android::String16 version)\n{\n    std::string std_version = String8(version).string();\n    int norm_version;\n    bool result = false;\n\n    LOGD(\"OpenCVEngine::InstallVersion() begin\");\n\n    norm_version = NormalizeVersionString(std_version);\n\n    if (0 != norm_version)\n    {\n        LOGD(\"PackageManager->InstallVersion call\");\n        result = PackageManager->InstallVersion(norm_version, Platform, CpuID);\n    }\n    else\n    {\n        LOGE(\"OpenCV version \\\"%s\\\" (%d) is not supported\", std_version.c_str(), norm_version);\n    }\n\n    LOGD(\"OpenCVEngine::InstallVersion() end\");\n\n    return result;\n}\n\nbool OpenCVEngine::FixPermissions(const std::string& path)\n{\n    LOGD(\"Fixing permissions for folder: \\\"%s\\\"\", path.c_str());\n    chmod(path.c_str(), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\n    DIR* dir = opendir(path.c_str());\n    if (!dir)\n    {\n        LOGD(\"Fixing permissions error\");\n        return false;\n    }\n\n    dirent* files = readdir(dir);\n    while (files)\n    {\n        LOGD(\"Fix permissions for \\\"%s\\\"\", files->d_name);\n        chmod((path + std::string(\"/\") + std::string(files->d_name)).c_str(), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n        files = readdir(dir);\n    }\n\n    closedir(dir);\n\n    return true;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/androidcamera/src/camera_activity.cpp": "#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <android/log.h>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <opencv2/core/version.hpp>\n#include \"camera_activity.hpp\"\n#include \"camera_wrapper.h\"\n#include \"EngineCommon.h\"\n\n#undef LOG_TAG\n#undef LOGE\n#undef LOGD\n#undef LOGI\n\n#define LOG_TAG \"OpenCV::camera\"\n#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))\n#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__))\n#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))\n\n///////\n// Debug\n#include <stdio.h>\n#include <sys/types.h>\n#include <dirent.h>\n\n\nusing namespace std;\n\nclass CameraWrapperConnector\n{\npublic:\n    static CameraActivity::ErrorCode connect(int cameraId, CameraActivity* pCameraActivity, void** camera);\n    static CameraActivity::ErrorCode disconnect(void** camera);\n    static CameraActivity::ErrorCode setProperty(void* camera, int propIdx, double value);\n    static CameraActivity::ErrorCode getProperty(void* camera, int propIdx, double* value);\n    static CameraActivity::ErrorCode applyProperties(void** ppcamera);\n\n    static void setPathLibFolder(const std::string& path);\n\nprivate:\n    static std::string pathLibFolder;\n    static bool isConnectedToLib;\n\n    static std::string getPathLibFolder();\n    static std::string getDefaultPathLibFolder();\n    static CameraActivity::ErrorCode connectToLib();\n    static CameraActivity::ErrorCode getSymbolFromLib(void * libHandle, const char* symbolName, void** ppSymbol);\n    static void fillListWrapperLibs(const string& folderPath, vector<string>& listLibs);\n\n    static InitCameraConnectC pInitCameraC;\n    static CloseCameraConnectC pCloseCameraC;\n    static GetCameraPropertyC pGetPropertyC;\n    static SetCameraPropertyC pSetPropertyC;\n    static ApplyCameraPropertiesC pApplyPropertiesC;\n\n    friend bool nextFrame(void* buffer, size_t bufferSize, void* userData);\n};\n\nstd::string CameraWrapperConnector::pathLibFolder;\n\nbool CameraWrapperConnector::isConnectedToLib = false;\nInitCameraConnectC  CameraWrapperConnector::pInitCameraC = 0;\nCloseCameraConnectC  CameraWrapperConnector::pCloseCameraC = 0;\nGetCameraPropertyC CameraWrapperConnector::pGetPropertyC = 0;\nSetCameraPropertyC CameraWrapperConnector::pSetPropertyC = 0;\nApplyCameraPropertiesC CameraWrapperConnector::pApplyPropertiesC = 0;\n\n#define INIT_CAMERA_SYMBOL_NAME \"initCameraConnectC\"\n#define CLOSE_CAMERA_SYMBOL_NAME \"closeCameraConnectC\"\n#define SET_CAMERA_PROPERTY_SYMBOL_NAME \"setCameraPropertyC\"\n#define GET_CAMERA_PROPERTY_SYMBOL_NAME \"getCameraPropertyC\"\n#define APPLY_CAMERA_PROPERTIES_SYMBOL_NAME \"applyCameraPropertiesC\"\n#define PREFIX_CAMERA_WRAPPER_LIB \"libnative_camera\"\n\n\nbool nextFrame(void* buffer, size_t bufferSize, void* userData)\n{\n    if (userData == NULL)\n        return true;\n\n    return ((CameraActivity*)userData)->onFrameBuffer(buffer, bufferSize);\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::connect(int cameraId, CameraActivity* pCameraActivity, void** camera)\n{\n    if (pCameraActivity == NULL)\n    {\n        LOGE(\"CameraWrapperConnector::connect error: wrong pointer to CameraActivity object\");\n        return CameraActivity::ERROR_WRONG_POINTER_CAMERA_WRAPPER;\n    }\n\n    CameraActivity::ErrorCode errcode=connectToLib();\n    if (errcode) return errcode;\n\n    void* cmr = (*pInitCameraC)((void*)nextFrame, cameraId, (void*)pCameraActivity);\n    if (!cmr)\n    {\n        LOGE(\"CameraWrapperConnector::connectWrapper ERROR: the initializing function returned false\");\n        return CameraActivity::ERROR_CANNOT_INITIALIZE_CONNECTION;\n    }\n\n    *camera = cmr;\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::disconnect(void** camera)\n{\n    if (camera == NULL || *camera == NULL)\n    {\n        LOGE(\"CameraWrapperConnector::disconnect error: wrong pointer to camera object\");\n        return CameraActivity::ERROR_WRONG_POINTER_CAMERA_WRAPPER;\n    }\n\n    CameraActivity::ErrorCode errcode=connectToLib();\n    if (errcode) return errcode;\n\n    (*pCloseCameraC)(camera);\n\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::setProperty(void* camera, int propIdx, double value)\n{\n    if (camera == NULL)\n    {\n        LOGE(\"CameraWrapperConnector::setProperty error: wrong pointer to camera object\");\n        return CameraActivity::ERROR_WRONG_POINTER_CAMERA_WRAPPER;\n    }\n\n    (*pSetPropertyC)(camera, propIdx, value);\n\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::getProperty(void* camera, int propIdx, double* value)\n{\n    if (camera == NULL)\n    {\n        LOGE(\"CameraWrapperConnector::getProperty error: wrong pointer to camera object\");\n        return CameraActivity::ERROR_WRONG_POINTER_CAMERA_WRAPPER;\n    }\n    LOGE(\"calling (*pGetPropertyC)(%p, %d)\", camera, propIdx);\n    *value = (*pGetPropertyC)(camera, propIdx);\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::applyProperties(void** ppcamera)\n{\n    if ((ppcamera == NULL) || (*ppcamera == NULL))\n    {\n        LOGE(\"CameraWrapperConnector::applyProperties error: wrong pointer to camera object\");\n        return CameraActivity::ERROR_WRONG_POINTER_CAMERA_WRAPPER;\n    }\n\n    (*pApplyPropertiesC)(ppcamera);\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::connectToLib()\n{\n    if (isConnectedToLib) {\n        return CameraActivity::NO_ERROR;\n    }\n\n    dlerror();\n    string folderPath = getPathLibFolder();\n    if (folderPath.empty())\n    {\n        LOGD(\"Trying to find native camera in default OpenCV packages\");\n        folderPath = getDefaultPathLibFolder();\n    }\n\n    LOGD(\"CameraWrapperConnector::connectToLib: folderPath=%s\", folderPath.c_str());\n\n    vector<string> listLibs;\n    fillListWrapperLibs(folderPath, listLibs);\n    std::sort(listLibs.begin(), listLibs.end(), std::greater<string>());\n\n    void * libHandle=0;\n    string cur_path;\n    for(size_t i = 0; i < listLibs.size(); i++) {\n        cur_path=folderPath + listLibs[i];\n        LOGD(\"try to load library '%s'\", listLibs[i].c_str());\n        libHandle=dlopen(cur_path.c_str(), RTLD_LAZY);\n        if (libHandle) {\n            LOGD(\"Loaded library '%s'\", cur_path.c_str());\n            break;\n        } else {\n            LOGD(\"CameraWrapperConnector::connectToLib ERROR: cannot dlopen camera wrapper library %s, dlerror=\\\"%s\\\"\",\n                 cur_path.c_str(), dlerror());\n        }\n    }\n\n    if (!libHandle) {\n        LOGE(\"CameraWrapperConnector::connectToLib ERROR: cannot dlopen camera wrapper library\");\n        return CameraActivity::ERROR_CANNOT_OPEN_CAMERA_WRAPPER_LIB;\n    }\n\n    InitCameraConnectC pInit_C;\n    CloseCameraConnectC pClose_C;\n    GetCameraPropertyC pGetProp_C;\n    SetCameraPropertyC pSetProp_C;\n    ApplyCameraPropertiesC pApplyProp_C;\n\n    CameraActivity::ErrorCode res;\n\n    res = getSymbolFromLib(libHandle, (const char*)INIT_CAMERA_SYMBOL_NAME, (void**)(&pInit_C));\n    if (res) return res;\n\n    res = getSymbolFromLib(libHandle, CLOSE_CAMERA_SYMBOL_NAME, (void**)(&pClose_C));\n    if (res) return res;\n\n    res = getSymbolFromLib(libHandle, GET_CAMERA_PROPERTY_SYMBOL_NAME, (void**)(&pGetProp_C));\n    if (res) return res;\n\n    res = getSymbolFromLib(libHandle, SET_CAMERA_PROPERTY_SYMBOL_NAME, (void**)(&pSetProp_C));\n    if (res) return res;\n\n    res = getSymbolFromLib(libHandle, APPLY_CAMERA_PROPERTIES_SYMBOL_NAME, (void**)(&pApplyProp_C));\n    if (res) return res;\n\n    pInitCameraC  = pInit_C;\n    pCloseCameraC = pClose_C;\n    pGetPropertyC = pGetProp_C;\n    pSetPropertyC = pSetProp_C;\n    pApplyPropertiesC = pApplyProp_C;\n    isConnectedToLib=true;\n\n    return CameraActivity::NO_ERROR;\n}\n\nCameraActivity::ErrorCode CameraWrapperConnector::getSymbolFromLib(void* libHandle, const char* symbolName, void** ppSymbol)\n{\n    dlerror();\n    *(void **) (ppSymbol)=dlsym(libHandle, symbolName);\n\n    const char* error_dlsym_init=dlerror();\n    if (error_dlsym_init) {\n        LOGE(\"CameraWrapperConnector::getSymbolFromLib ERROR: cannot get symbol of the function '%s' from the camera wrapper library, dlerror=\\\"%s\\\"\",\n             symbolName, error_dlsym_init);\n        return CameraActivity::ERROR_CANNOT_GET_FUNCTION_FROM_CAMERA_WRAPPER_LIB;\n    }\n    return CameraActivity::NO_ERROR;\n}\n\nvoid CameraWrapperConnector::fillListWrapperLibs(const string& folderPath, vector<string>& listLibs)\n{\n    DIR *dp;\n    struct dirent *ep;\n\n    dp = opendir (folderPath.c_str());\n    if (dp != NULL)\n    {\n        while ((ep = readdir (dp))) {\n            const char* cur_name=ep->d_name;\n            if (strstr(cur_name, PREFIX_CAMERA_WRAPPER_LIB)) {\n                listLibs.push_back(cur_name);\n                LOGE(\"||%s\", cur_name);\n            }\n        }\n        (void) closedir (dp);\n    }\n}\n\nstd::string CameraWrapperConnector::getDefaultPathLibFolder()\n{\n    #define BIN_PACKAGE_NAME(x) \"org.opencv.lib_v\" CVAUX_STR(CV_VERSION_EPOCH) CVAUX_STR(CV_VERSION_MAJOR) \"_\" x\n    const char* const packageList[] = {BIN_PACKAGE_NAME(\"armv7a\"), OPENCV_ENGINE_PACKAGE};\n    for (size_t i = 0; i < sizeof(packageList)/sizeof(packageList[0]); i++)\n    {\n        char path[128];\n        sprintf(path, \"/data/data/%s/lib/\", packageList[i]);\n        LOGD(\"Trying package \\\"%s\\\" (\\\"%s\\\")\", packageList[i], path);\n\n        DIR* dir = opendir(path);\n        if (!dir)\n        {\n            LOGD(\"Package not found\");\n            continue;\n        }\n        else\n        {\n            closedir(dir);\n            return path;\n        }\n    }\n\n    return string();\n}\n\nstd::string CameraWrapperConnector::getPathLibFolder()\n{\n    if (!pathLibFolder.empty())\n        return pathLibFolder;\n\n    Dl_info dl_info;\n    if(0 != dladdr((void *)nextFrame, &dl_info))\n    {\n        LOGD(\"Library name: %s\", dl_info.dli_fname);\n        LOGD(\"Library base address: %p\", dl_info.dli_fbase);\n\n        const char* libName=dl_info.dli_fname;\n        while( ((*libName)=='/') || ((*libName)=='.') )\n        libName++;\n\n        char lineBuf[2048];\n        FILE* file = fopen(\"/proc/self/smaps\", \"rt\");\n\n        if(file)\n        {\n            while (fgets(lineBuf, sizeof lineBuf, file) != NULL)\n            {\n                //verify that line ends with library name\n                int lineLength = strlen(lineBuf);\n                int libNameLength = strlen(libName);\n\n                //trim end\n                for(int i = lineLength - 1; i >= 0 && isspace(lineBuf[i]); --i)\n                {\n                    lineBuf[i] = 0;\n                    --lineLength;\n                }\n\n                if (0 != strncmp(lineBuf + lineLength - libNameLength, libName, libNameLength))\n                {\n                //the line does not contain the library name\n                    continue;\n                }\n\n                //extract path from smaps line\n                char* pathBegin = strchr(lineBuf, '/');\n                if (0 == pathBegin)\n                {\n                    LOGE(\"Strange error: could not find path beginning in lin \\\"%s\\\"\", lineBuf);\n                    continue;\n                }\n\n                char* pathEnd = strrchr(pathBegin, '/');\n                pathEnd[1] = 0;\n\n                LOGD(\"Libraries folder found: %s\", pathBegin);\n\n                fclose(file);\n                return pathBegin;\n            }\n            fclose(file);\n            LOGE(\"Could not find library path\");\n        }\n        else\n        {\n            LOGE(\"Could not read /proc/self/smaps\");\n        }\n    }\n    else\n    {\n        LOGE(\"Could not get library name and base address\");\n    }\n\n    return string();\n}\n\nvoid CameraWrapperConnector::setPathLibFolder(const string& path)\n{\n    pathLibFolder=path;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nCameraActivity::CameraActivity() : camera(0), frameWidth(-1), frameHeight(-1)\n{\n}\n\nCameraActivity::~CameraActivity()\n{\n    if (camera != 0)\n        disconnect();\n}\n\nbool CameraActivity::onFrameBuffer(void* /*buffer*/, int /*bufferSize*/)\n{\n    LOGD(\"CameraActivity::onFrameBuffer - empty callback\");\n    return true;\n}\n\nvoid CameraActivity::disconnect()\n{\n    CameraWrapperConnector::disconnect(&camera);\n}\n\nbool CameraActivity::isConnected() const\n{\n    return camera != 0;\n}\n\nCameraActivity::ErrorCode CameraActivity::connect(int cameraId)\n{\n    ErrorCode rescode = CameraWrapperConnector::connect(cameraId, this, &camera);\n    if (rescode) return rescode;\n\n    return NO_ERROR;\n}\n\ndouble CameraActivity::getProperty(int propIdx)\n{\n    double propVal;\n    ErrorCode rescode = CameraWrapperConnector::getProperty(camera, propIdx, &propVal);\n    if (rescode) return -1;\n    return propVal;\n}\n\nvoid CameraActivity::setProperty(int propIdx, double value)\n{\n    CameraWrapperConnector::setProperty(camera, propIdx, value);\n}\n\nvoid CameraActivity::applyProperties()\n{\n    frameWidth = -1;\n    frameHeight = -1;\n    CameraWrapperConnector::applyProperties(&camera);\n    frameWidth = getProperty(ANDROID_CAMERA_PROPERTY_FRAMEWIDTH);\n    frameHeight = getProperty(ANDROID_CAMERA_PROPERTY_FRAMEHEIGHT);\n}\n\nint CameraActivity::getFrameWidth()\n{\n    if (frameWidth <= 0)\n        frameWidth = getProperty(ANDROID_CAMERA_PROPERTY_FRAMEWIDTH);\n    return frameWidth;\n}\n\nint CameraActivity::getFrameHeight()\n{\n    if (frameHeight <= 0)\n        frameHeight = getProperty(ANDROID_CAMERA_PROPERTY_FRAMEHEIGHT);\n    return frameHeight;\n}\n\nvoid CameraActivity::setPathLibFolder(const char* path)\n{\n    CameraWrapperConnector::setPathLibFolder(path);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/androidcamera/camera_wrapper/camera_wrapper.cpp": "#if !defined(ANDROID_r2_2_0) && !defined(ANDROID_r2_3_3) && !defined(ANDROID_r3_0_1) && \\\n !defined(ANDROID_r4_0_0) && !defined(ANDROID_r4_0_3) && !defined(ANDROID_r4_1_1) && \\\n !defined(ANDROID_r4_2_0) && !defined(ANDROID_r4_3_0) && !defined(ANDROID_r4_4_0)\n# error Building camera wrapper for your version of Android is not supported by OpenCV.\\\n You need to modify OpenCV sources in order to compile camera wrapper for your version of Android.\n#endif\n\n#include <camera/Camera.h>\n#include <camera/CameraParameters.h>\n\n#if defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3)\n# include <system/camera.h>\n#endif //defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3)\n\n#include \"camera_wrapper.h\"\n#include \"../include/camera_properties.h\"\n\n#if defined(ANDROID_r3_0_1) || defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3) || defined(ANDROID_r4_1_1)\n//Include SurfaceTexture.h file with the SurfaceTexture class\n# include <gui/SurfaceTexture.h>\n# define MAGIC_OPENCV_TEXTURE_ID (0x10)\n#elif defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0)\n# include <gui/ISurface.h>\n# include <gui/BufferQueue.h>\n#elif defined(ANDROID_r4_3_0) || defined(ANDROID_r4_4_0)\n# include <gui/IGraphicBufferProducer.h>\n# include <gui/BufferQueue.h>\n# include <ui/GraphicBuffer.h>\n#else\n# include <surfaceflinger/ISurface.h>\n#endif\n\n#include <string>\n#include <fstream>\n\n//undef logging macro from /system/core/libcutils/loghack.h\n#ifdef LOGD\n# undef LOGD\n#endif\n\n#ifdef LOGI\n# undef LOGI\n#endif\n\n#ifdef LOGW\n# undef LOGW\n#endif\n\n#ifdef LOGE\n# undef LOGE\n#endif\n\n// LOGGING\n#include <android/log.h>\n#define CAMERA_LOG_TAG \"OpenCV_NativeCamera\"\n#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, CAMERA_LOG_TAG, __VA_ARGS__))\n#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, CAMERA_LOG_TAG, __VA_ARGS__))\n#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, CAMERA_LOG_TAG, __VA_ARGS__))\n#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, CAMERA_LOG_TAG, __VA_ARGS__))\n\n#include <dlfcn.h>\n\nusing namespace android;\n\n// non-public camera related classes are not binary compatible\n// objects of these classes have different sizeof on different platforms\n// additional memory tail to all system objects to overcome sizeof issue\n#define MAGIC_TAIL 4096\n\n\nvoid debugShowFPS();\n\n#if defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) || defined(ANDROID_r4_3_0)\nclass ConsumerListenerStub: public BufferQueue::ConsumerListener\n{\npublic:\n    virtual void onFrameAvailable()\n    {\n    }\n    virtual void onBuffersReleased()\n    {\n    }\n};\n#elif defined(ANDROID_r4_4_0)\nclass ConsumerListenerStub: public android::BnConsumerListener\n{\npublic:\n    virtual void onFrameAvailable()\n    {\n    }\n    virtual void onBuffersReleased()\n    {\n    }\n    virtual ~ConsumerListenerStub()\n    {\n    }\n};\n#endif\n\n\nstd::string getProcessName()\n{\n    std::string result;\n    std::ifstream f;\n\n    f.open(\"/proc/self/cmdline\");\n    if (f.is_open())\n    {\n        std::string fullPath;\n        std::getline(f, fullPath, '\\0');\n        if (!fullPath.empty())\n        {\n            int i = fullPath.size()-1;\n            while ((i >= 0) && (fullPath[i] != '/')) i--;\n            result = fullPath.substr(i+1, std::string::npos);\n        }\n    }\n\n    f.close();\n\n    return result;\n}\n\nvoid debugShowFPS()\n{\n    static int mFrameCount = 0;\n    static int mLastFrameCount = 0;\n    static nsecs_t mLastFpsTime = systemTime();\n    static float mFps = 0;\n\n    mFrameCount++;\n\n    if (( mFrameCount % 30 ) != 0)\n        return;\n\n    nsecs_t now = systemTime();\n    nsecs_t diff = now - mLastFpsTime;\n\n    if (diff==0)\n        return;\n\n    mFps =  ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;\n    mLastFpsTime = now;\n    mLastFrameCount = mFrameCount;\n    LOGI(\"### Camera FPS ### [%d] Frames, %.2f FPS\", mFrameCount, mFps);\n}\n\nclass CameraHandler: public CameraListener\n{\nprotected:\n    int cameraId;\n    sp<Camera> camera;\n#if defined(ANDROID_r3_0_1) || defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3)\n    sp<SurfaceTexture> surface;\n#endif\n#if defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) || defined(ANDROID_r4_3_0) || defined(ANDROID_r4_4_0)\n    sp<BufferQueue> queue;\n    sp<ConsumerListenerStub> listener;\n#endif\n    CameraParameters* params;\n    CameraCallback cameraCallback;\n    void* userData;\n\n    int emptyCameraCallbackReported;\n\n    int width;\n    int height;\n\n    static const char* flashModesNames[ANDROID_CAMERA_FLASH_MODES_NUM];\n    static const char* focusModesNames[ANDROID_CAMERA_FOCUS_MODES_NUM];\n    static const char* whiteBalanceModesNames[ANDROID_CAMERA_WHITE_BALANCE_MODES_NUM];\n    static const char* antibandingModesNames[ANDROID_CAMERA_ANTIBANDING_MODES_NUM];\n\n    void doCall(void* buffer, size_t bufferSize)\n    {\n        if (cameraCallback == 0)\n        {\n            if (!emptyCameraCallbackReported)\n                LOGE(\"CameraHandler::doCall(void*, size_t): Camera callback is empty!\");\n\n            emptyCameraCallbackReported++;\n        }\n        else\n        {\n            bool res = (*cameraCallback)(buffer, bufferSize, userData);\n\n            if(!res)\n            {\n                LOGE(\"CameraHandler::doCall(void*, size_t): cameraCallback returns false (camera connection will be closed)\");\n                closeCameraConnect();\n            }\n        }\n    }\n\n    void doCall(const sp<IMemory>& dataPtr)\n    {\n        if (dataPtr == NULL)\n        {\n            LOGE(\"CameraHandler::doCall(const sp<IMemory>&): dataPtr==NULL (no frame to handle)\");\n            return;\n        }\n\n        size_t size = dataPtr->size();\n        if (size <= 0)\n        {\n            LOGE(\"CameraHandler::doCall(const sp<IMemory>&): IMemory object is of zero size\");\n            return;\n        }\n\n        void* buffer = (void *)dataPtr->pointer();\n        if (!buffer)\n        {\n            LOGE(\"CameraHandler::doCall(const sp<IMemory>&): Buffer pointer is NULL\");\n            return;\n        }\n\n        doCall(buffer, size);\n    }\n\n    virtual void postDataTimestamp(nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr)\n    {\n        static uint32_t count = 0;\n        count++;\n\n        LOGE(\"Recording cb: %d %lld %%p Offset:%%d Stride:%%d\\n\", msgType, timestamp);\n\n        if (dataPtr == NULL)\n        {\n            LOGE(\"postDataTimestamp: dataPtr IS ZERO -- returning\");\n            camera->releaseRecordingFrame(dataPtr);\n            LOGE(\"postDataTimestamp:  camera->releaseRecordingFrame(dataPtr) is done\");\n            return;\n        }\n\n        uint8_t *ptr = (uint8_t*) dataPtr->pointer();\n        if (ptr)\n            LOGE(\"VID_CB: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], ptr[8], ptr[9]);\n        else\n            LOGE(\"postDataTimestamp: Ptr is zero\");\n\n        camera->releaseRecordingFrame(dataPtr);\n    }\n\n    // Split list of floats, returns number of floats found\n    static int split_float(const char *str, float* out, char delim, int max_elem_num,\n                           char **endptr = NULL)\n    {\n        // Find the first float.\n        char *end = const_cast<char*>(str);\n        int elem_num = 0;\n        for(; elem_num < max_elem_num; elem_num++ ){\n            char* curr_end;\n            out[elem_num] = (float)strtof(end, &curr_end);\n            // No other numbers found, finish the loop\n            if(end == curr_end){\n                break;\n            }\n            if (*curr_end != delim) {\n                // When end of string, finish the loop\n                if (*curr_end == 0){\n                    elem_num++;\n                    break;\n                }\n                else {\n                    LOGE(\"Cannot find delimeter (%c) in str=%s\", delim, str);\n                    return -1;\n                }\n            }\n            // Skip the delimiter character\n            end = curr_end + 1;\n        }\n        if (endptr)\n            *endptr = end;\n        return elem_num;\n    }\n\n    int is_supported(const char* supp_modes_key, const char* mode)\n    {\n        const char* supported_modes = params->get(supp_modes_key);\n        return (supported_modes && mode && (strstr(supported_modes, mode) > 0));\n    }\n\n    float getFocusDistance(int focus_distance_type)\n    {\n#if !defined(ANDROID_r2_2_0)\n        if (focus_distance_type >= 0 && focus_distance_type < 3)\n    {\n            float focus_distances[3];\n            const char* output = params->get(CameraParameters::KEY_FOCUS_DISTANCES);\n            int val_num = CameraHandler::split_float(output, focus_distances, ',', 3);\n            if(val_num == 3)\n        {\n                return focus_distances[focus_distance_type];\n            }\n            else\n        {\n                LOGE(\"Invalid focus distances.\");\n            }\n        }\n#endif\n    return -1;\n    }\n\n    static int getModeNum(const char** modes, const int modes_num, const char* mode_name)\n    {\n        for (int i = 0; i < modes_num; i++){\n            if(!strcmp(modes[i],mode_name))\n                return i;\n        }\n        return -1;\n    }\n\npublic:\n    CameraHandler(CameraCallback callback = 0, void* _userData = 0):\n        cameraId(0),\n        cameraCallback(callback),\n        userData(_userData),\n        emptyCameraCallbackReported(0)\n    {\n        LOGD(\"Instantiated new CameraHandler (%p, %p)\", callback, _userData);\n        void* params_buffer = operator new(sizeof(CameraParameters) + MAGIC_TAIL);\n        params = new(params_buffer) CameraParameters();\n    }\n\n    virtual ~CameraHandler()\n    {\n        if (params)\n            params->~CameraParameters();\n            operator delete(params);\n        LOGD(\"CameraHandler destructor is called\");\n    }\n\n    virtual void notify(int32_t msgType, int32_t ext1, int32_t ext2)\n    {\n        LOGE(\"CameraHandler::Notify: msgType=%d ext1=%d ext2=%d\\n\", msgType, ext1, ext2);\n#if 0\n        if ( msgType & CAMERA_MSG_FOCUS )\n            LOGE(\"CameraHandler::Notify  AutoFocus %s in %llu us\\n\", (ext1) ? \"OK\" : \"FAIL\", timevalDelay(&autofocus_start));\n\n        if ( msgType & CAMERA_MSG_SHUTTER )\n            LOGE(\"CameraHandler::Notify  Shutter done in %llu us\\n\", timeval_delay(&picture_start));\n#endif\n    }\n\n    virtual void postData(int32_t msgType, const sp<IMemory>& dataPtr\n#if defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3) || defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) \\\n || defined(ANDROID_r4_3_0) || defined(ANDROID_r4_4_0)\n                          ,camera_frame_metadata_t*\n#endif\n                          )\n    {\n        debugShowFPS();\n\n        if ( msgType & CAMERA_MSG_PREVIEW_FRAME )\n        {\n            doCall(dataPtr);\n            return;\n        }\n\n        //if (msgType != CAMERA_MSG_PREVIEW_FRAME)\n            //LOGE(\"CameraHandler::postData  Recieved message %d is not equal to CAMERA_MSG_PREVIEW_FRAME (%d)\", (int) msgType, CAMERA_MSG_PREVIEW_FRAME);\n\n        if ( msgType & CAMERA_MSG_RAW_IMAGE )\n            LOGE(\"CameraHandler::postData  Unexpected data format: RAW\\n\");\n\n        if (msgType & CAMERA_MSG_POSTVIEW_FRAME)\n            LOGE(\"CameraHandler::postData  Unexpected data format: Postview frame\\n\");\n\n        if (msgType & CAMERA_MSG_COMPRESSED_IMAGE )\n            LOGE(\"CameraHandler::postData  Unexpected data format: JPEG\");\n    }\n\n    static CameraHandler* initCameraConnect(const CameraCallback& callback, int cameraId, void* userData, CameraParameters* prevCameraParameters);\n    void closeCameraConnect();\n    double getProperty(int propIdx);\n    void setProperty(int propIdx, double value);\n    static void applyProperties(CameraHandler** ppcameraHandler);\n\n    std::string cameraPropertySupportedPreviewSizesString;\n    std::string cameraPropertyPreviewFormatString;\n};\n\nconst char* CameraHandler::flashModesNames[ANDROID_CAMERA_FLASH_MODES_NUM] =\n{\n    CameraParameters::FLASH_MODE_AUTO,\n    CameraParameters::FLASH_MODE_OFF,\n    CameraParameters::FLASH_MODE_ON,\n    CameraParameters::FLASH_MODE_RED_EYE,\n    CameraParameters::FLASH_MODE_TORCH\n};\n\nconst char* CameraHandler::focusModesNames[ANDROID_CAMERA_FOCUS_MODES_NUM] =\n{\n    CameraParameters::FOCUS_MODE_AUTO,\n#if !defined(ANDROID_r2_2_0)\n    CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO,\n#else\n    CameraParameters::FOCUS_MODE_AUTO,\n#endif\n    CameraParameters::FOCUS_MODE_EDOF,\n    CameraParameters::FOCUS_MODE_FIXED,\n    CameraParameters::FOCUS_MODE_INFINITY,\n    CameraParameters::FOCUS_MODE_MACRO,\n#if !defined(ANDROID_r2_2_0) && !defined(ANDROID_r2_3_3) && !defined(ANDROID_r3_0_1)\n    CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE\n#else\n    CameraParameters::FOCUS_MODE_AUTO\n#endif\n};\n\nconst char* CameraHandler::whiteBalanceModesNames[ANDROID_CAMERA_WHITE_BALANCE_MODES_NUM] =\n{\n    CameraParameters::WHITE_BALANCE_AUTO,\n    CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT,\n    CameraParameters::WHITE_BALANCE_DAYLIGHT,\n    CameraParameters::WHITE_BALANCE_FLUORESCENT,\n    CameraParameters::WHITE_BALANCE_INCANDESCENT,\n    CameraParameters::WHITE_BALANCE_SHADE,\n    CameraParameters::WHITE_BALANCE_TWILIGHT\n};\n\nconst char* CameraHandler::antibandingModesNames[ANDROID_CAMERA_ANTIBANDING_MODES_NUM] =\n{\n    CameraParameters::ANTIBANDING_50HZ,\n    CameraParameters::ANTIBANDING_60HZ,\n    CameraParameters::ANTIBANDING_AUTO\n};\n\n\nCameraHandler* CameraHandler::initCameraConnect(const CameraCallback& callback, int cameraId, void* userData, CameraParameters* prevCameraParameters)\n{\n\n    typedef sp<Camera> (*Android22ConnectFuncType)();\n    typedef sp<Camera> (*Android23ConnectFuncType)(int);\n    typedef sp<Camera> (*Android3DConnectFuncType)(int, int);\n    typedef sp<Camera> (*Android43ConnectFuncType)(int, const String16&, int);\n\n    const int ANY_CAMERA_INDEX = -1;\n    const int BACK_CAMERA_INDEX = 99;\n    const int FRONT_CAMERA_INDEX = 98;\n\n    enum {\n    CAMERA_SUPPORT_MODE_2D = 0x01, /* Camera Sensor supports 2D mode. */\n    CAMERA_SUPPORT_MODE_3D = 0x02, /* Camera Sensor supports 3D mode. */\n    CAMERA_SUPPORT_MODE_NONZSL = 0x04, /* Camera Sensor in NON-ZSL mode. */\n    CAMERA_SUPPORT_MODE_ZSL = 0x08 /* Camera Sensor supports ZSL mode. */\n    };\n\n    // used for Android 4.3\n    enum {\n        USE_CALLING_UID = -1\n    };\n\n    const char Android22ConnectName[] = \"_ZN7android6Camera7connectEv\";\n    const char Android23ConnectName[] = \"_ZN7android6Camera7connectEi\";\n    const char Android3DConnectName[] = \"_ZN7android6Camera7connectEii\";\n    const char Android43ConnectName[] = \"_ZN7android6Camera7connectEiRKNS_8String16Ei\";\n\n    int localCameraIndex = cameraId;\n\n    if (cameraId == ANY_CAMERA_INDEX)\n    {\n        localCameraIndex = 0;\n    }\n#if !defined(ANDROID_r2_2_0)\n    else if (cameraId == BACK_CAMERA_INDEX)\n    {\n        LOGD(\"Back camera selected\");\n        for (int i = 0; i < Camera::getNumberOfCameras(); i++)\n        {\n            CameraInfo info;\n            Camera::getCameraInfo(i, &info);\n            if (info.facing == CAMERA_FACING_BACK)\n            {\n                localCameraIndex = i;\n                break;\n            }\n        }\n    }\n    else if (cameraId == FRONT_CAMERA_INDEX)\n    {\n        LOGD(\"Front camera selected\");\n        for (int i = 0; i < Camera::getNumberOfCameras(); i++)\n        {\n            CameraInfo info;\n            Camera::getCameraInfo(i, &info);\n            if (info.facing == CAMERA_FACING_FRONT)\n            {\n                localCameraIndex = i;\n                break;\n            }\n        }\n    }\n\n    if (localCameraIndex == BACK_CAMERA_INDEX)\n    {\n        LOGE(\"Back camera not found!\");\n        return NULL;\n    }\n    else if (localCameraIndex == FRONT_CAMERA_INDEX)\n    {\n        LOGE(\"Front camera not found!\");\n        return NULL;\n    }\n#endif\n\n    LOGD(\"CameraHandler::initCameraConnect(%p, %d, %p, %p)\", callback, localCameraIndex, userData, prevCameraParameters);\n\n    sp<Camera> camera = 0;\n\n    void* CameraHALHandle = dlopen(\"libcamera_client.so\", RTLD_LAZY);\n\n    if (!CameraHALHandle)\n    {\n        LOGE(\"Cannot link to \\\"libcamera_client.so\\\"\");\n        return NULL;\n    }\n\n    // reset errors\n    dlerror();\n\n    if (Android22ConnectFuncType Android22Connect = (Android22ConnectFuncType)dlsym(CameraHALHandle, Android22ConnectName))\n    {\n        LOGD(\"Connecting to CameraService v 2.2\");\n        camera = Android22Connect();\n    }\n    else if (Android23ConnectFuncType Android23Connect = (Android23ConnectFuncType)dlsym(CameraHALHandle, Android23ConnectName))\n    {\n        LOGD(\"Connecting to CameraService v 2.3\");\n        camera = Android23Connect(localCameraIndex);\n    }\n    else if (Android3DConnectFuncType Android3DConnect = (Android3DConnectFuncType)dlsym(CameraHALHandle, Android3DConnectName))\n    {\n        LOGD(\"Connecting to CameraService v 3D\");\n        camera = Android3DConnect(localCameraIndex, CAMERA_SUPPORT_MODE_2D);\n    }\n    else if (Android43ConnectFuncType Android43Connect = (Android43ConnectFuncType)dlsym(CameraHALHandle, Android43ConnectName))\n    {\n        std::string currentProcName = getProcessName();\n        LOGD(\"Current process name for camera init: %s\", currentProcName.c_str());\n        camera = Android43Connect(localCameraIndex, String16(currentProcName.c_str()), USE_CALLING_UID);\n    }\n    else\n    {\n        dlclose(CameraHALHandle);\n        LOGE(\"Cannot connect to CameraService. Connect method was not found!\");\n        return NULL;\n    }\n\n    dlclose(CameraHALHandle);\n\n    if ( 0 == camera.get() )\n    {\n        LOGE(\"initCameraConnect: Unable to connect to CameraService\\n\");\n        return 0;\n    }\n\n    CameraHandler* handler = new CameraHandler(callback, userData);\n    camera->setListener(handler);\n\n    handler->camera = camera;\n    handler->cameraId = localCameraIndex;\n\n    if (prevCameraParameters != NULL)\n    {\n        LOGI(\"initCameraConnect: Setting paramers from previous camera handler\");\n        camera->setParameters(prevCameraParameters->flatten());\n        handler->params->unflatten(prevCameraParameters->flatten());\n    }\n    else\n    {\n        android::String8 params_str = camera->getParameters();\n        LOGI(\"initCameraConnect: [%s]\", params_str.string());\n\n        handler->params->unflatten(params_str);\n\n        LOGD(\"Supported Cameras: %s\", handler->params->get(\"camera-indexes\"));\n        LOGD(\"Supported Picture Sizes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES));\n        LOGD(\"Supported Picture Formats: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS));\n        LOGD(\"Supported Preview Sizes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES));\n        LOGD(\"Supported Preview Formats: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS));\n        LOGD(\"Supported Preview Frame Rates: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES));\n        LOGD(\"Supported Thumbnail Sizes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES));\n        LOGD(\"Supported Whitebalance Modes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE));\n        LOGD(\"Supported Effects: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_EFFECTS));\n        LOGD(\"Supported Scene Modes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_SCENE_MODES));\n        LOGD(\"Supported Focus Modes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES));\n        LOGD(\"Supported Antibanding Options: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_ANTIBANDING));\n        LOGD(\"Supported Flash Modes: %s\", handler->params->get(CameraParameters::KEY_SUPPORTED_FLASH_MODES));\n\n#if !defined(ANDROID_r2_2_0)\n        // Set focus mode to continuous-video if supported\n        const char* available_focus_modes = handler->params->get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES);\n        if (available_focus_modes != 0)\n        {\n            if (strstr(available_focus_modes, \"continuous-video\") != NULL)\n            {\n                handler->params->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO);\n\n                status_t resParams = handler->camera->setParameters(handler->params->flatten());\n\n                if (resParams != 0)\n                {\n                    LOGE(\"initCameraConnect: failed to set autofocus mode to \\\"continuous-video\\\"\");\n                }\n                else\n                {\n                    LOGD(\"initCameraConnect: autofocus is set to mode \\\"continuous-video\\\"\");\n                }\n            }\n        }\n#endif\n\n        //check if yuv420sp format available. Set this format as preview format.\n        const char* available_formats = handler->params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS);\n        if (available_formats != 0)\n        {\n            const char* format_to_set = 0;\n            const char* pos = available_formats;\n            const char* ptr = pos;\n            while(true)\n            {\n                while(*ptr != 0 && *ptr != ',') ++ptr;\n                if (ptr != pos)\n                {\n                    if (0 == strncmp(pos, \"yuv420sp\", ptr - pos))\n                    {\n                        format_to_set = \"yuv420sp\";\n                        break;\n                    }\n                    if (0 == strncmp(pos, \"yvu420sp\", ptr - pos))\n                        format_to_set = \"yvu420sp\";\n                }\n                if (*ptr == 0)\n                    break;\n                pos = ++ptr;\n            }\n\n            if (0 != format_to_set)\n            {\n                handler->params->setPreviewFormat(format_to_set);\n\n                status_t resParams = handler->camera->setParameters(handler->params->flatten());\n\n                if (resParams != 0)\n                    LOGE(\"initCameraConnect: failed to set preview format to %s\", format_to_set);\n                else\n                    LOGD(\"initCameraConnect: preview format is set to %s\", format_to_set);\n            }\n        }\n\n        handler->params->setPreviewSize(640, 480);\n        status_t resParams = handler->camera->setParameters(handler->params->flatten());\n        if (resParams != 0)\n            LOGE(\"initCameraConnect: failed to set preview resolution to 640x480\");\n        else\n            LOGD(\"initCameraConnect: preview format is set to 640x480\");\n    }\n\n    status_t bufferStatus;\n#if defined(ANDROID_r2_2_0)\n    bufferStatus = camera->setPreviewDisplay(sp<ISurface>(0 /*new DummySurface*/));\n    if (bufferStatus != 0)\n        LOGE(\"initCameraConnect: failed setPreviewDisplay(0) call (status %d); camera might not work correctly on some devices\", bufferStatus);\n#elif defined(ANDROID_r2_3_3)\n    /* Do nothing in case of 2.3 for now */\n#elif defined(ANDROID_r3_0_1) || defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3)\n    void* surface_texture_obj = operator new(sizeof(SurfaceTexture) + MAGIC_TAIL);\n    handler->surface = new(surface_texture_obj) SurfaceTexture(MAGIC_OPENCV_TEXTURE_ID);\n    bufferStatus = camera->setPreviewTexture(handler->surface);\n    if (bufferStatus != 0)\n        LOGE(\"initCameraConnect: failed setPreviewTexture call (status %d); camera might not work correctly\", bufferStatus);\n#elif defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) || defined(ANDROID_r4_3_0)\n    void* buffer_queue_obj = operator new(sizeof(BufferQueue) + MAGIC_TAIL);\n    handler->queue = new(buffer_queue_obj) BufferQueue();\n    void* consumer_listener_obj = operator new(sizeof(ConsumerListenerStub) + MAGIC_TAIL);\n    handler->listener = new(consumer_listener_obj) ConsumerListenerStub();\n    handler->queue->consumerConnect(handler->listener);\n    bufferStatus = camera->setPreviewTexture(handler->queue);\n    if (bufferStatus != 0)\n        LOGE(\"initCameraConnect: failed setPreviewTexture call; camera might not work correctly\");\n# elif defined(ANDROID_r4_4_0)\n    void* buffer_queue_obj = operator new(sizeof(BufferQueue) + MAGIC_TAIL);\n    handler->queue = new(buffer_queue_obj) BufferQueue();\n    handler->queue->setConsumerUsageBits(GraphicBuffer::USAGE_HW_TEXTURE);\n    void* consumer_listener_obj = operator new(sizeof(ConsumerListenerStub) + MAGIC_TAIL);\n    handler->listener = new(consumer_listener_obj) ConsumerListenerStub();\n    handler->queue->consumerConnect(handler->listener, true);\n    bufferStatus = handler->camera->setPreviewTarget(handler->queue);\n    if (bufferStatus != 0)\n        LOGE(\"applyProperties: failed setPreviewTexture call; camera might not work correctly\");\n# endif\n\n#if (defined(ANDROID_r2_2_0) || defined(ANDROID_r2_3_3) || defined(ANDROID_r3_0_1))\n# if 1\n    ////ATTENTION: switching between two versions: with and without copying memory inside Android OS\n    //// see the method  CameraService::Client::copyFrameAndPostCopiedFrame and where it is used\n    camera->setPreviewCallbackFlags( FRAME_CALLBACK_FLAG_ENABLE_MASK | FRAME_CALLBACK_FLAG_COPY_OUT_MASK);//with copy\n# else\n    camera->setPreviewCallbackFlags( FRAME_CALLBACK_FLAG_ENABLE_MASK );//without copy\n# endif\n#else\n    camera->setPreviewCallbackFlags( CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK | CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK);//with copy\n#endif //!(defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3))\n\n    LOGD(\"Starting preview\");\n    status_t previewStatus = camera->startPreview();\n\n    if (previewStatus != 0)\n    {\n        LOGE(\"initCameraConnect: startPreview() fails. Closing camera connection...\");\n        handler->closeCameraConnect();\n        handler = 0;\n    }\n    else\n    {\n        LOGD(\"Preview started successfully\");\n    }\n\n    return handler;\n}\n\nvoid CameraHandler::closeCameraConnect()\n{\n    if (camera == NULL)\n    {\n        LOGI(\"... camera is already NULL\");\n        return;\n    }\n\n    camera->stopPreview();\n#if defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3) || defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) \\\n || defined(ANDROID_r4_3_0) || defined(ANDROID_r4_4_0)\n    camera->setPreviewCallbackFlags(CAMERA_FRAME_CALLBACK_FLAG_NOOP);\n#endif\n    camera->disconnect();\n    camera.clear();\n    camera=NULL;\n    // ATTENTION!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // When we set\n    //    camera=NULL\n    // above, the pointed instance of android::Camera object is destructed,\n    // since this member `camera' has type android::sp<Camera> (android smart pointer template class),\n    // and this is the only pointer to it.\n    //\n    // BUT this instance of CameraHandler is set as a listener for that android::Camera object\n    // (see the function CameraHandler::initCameraConnect above),\n    // so this instance of CameraHandler is pointed from that android::Camera object as\n    //     sp<CameraListener>  mListener\n    // and there is no other android smart pointers to this.\n    //\n    // It means, when that instance of the android::Camera object is destructed,\n    // it calls destructor for this CameraHandler instance too.\n    //\n    // So, this line `camera=NULL' causes to the call `delete this'\n    // (see destructor of the template class android::sp)\n    //\n    // So, we must not call `delete this' after the line, since it just has been called indeed\n}\n\ndouble CameraHandler::getProperty(int propIdx)\n{\n    LOGD(\"CameraHandler::getProperty(%d)\", propIdx);\n\n    switch (propIdx)\n    {\n    case ANDROID_CAMERA_PROPERTY_FRAMEWIDTH:\n    {\n        int w,h;\n        params->getPreviewSize(&w, &h);\n        return w;\n    }\n    case ANDROID_CAMERA_PROPERTY_FRAMEHEIGHT:\n    {\n        int w,h;\n        params->getPreviewSize(&w, &h);\n        return h;\n    }\n    case ANDROID_CAMERA_PROPERTY_SUPPORTED_PREVIEW_SIZES_STRING:\n    {\n        cameraPropertySupportedPreviewSizesString = params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES);\n        union {const char* str;double res;} u;\n        memset(&u.res, 0, sizeof(u.res));\n        u.str = cameraPropertySupportedPreviewSizesString.c_str();\n        return u.res;\n    }\n    case ANDROID_CAMERA_PROPERTY_PREVIEW_FORMAT_STRING:\n    {\n        const char* fmt = params->get(CameraParameters::KEY_PREVIEW_FORMAT);\n        if (fmt == CameraParameters::PIXEL_FORMAT_YUV422SP)\n            fmt = \"yuv422sp\";\n        else if (fmt == CameraParameters::PIXEL_FORMAT_YUV420SP)\n            fmt = \"yuv420sp\";\n        else if (fmt == CameraParameters::PIXEL_FORMAT_YUV422I)\n            fmt = \"yuv422i\";\n        else if (fmt == CameraParameters::PIXEL_FORMAT_RGB565)\n            fmt = \"rgb565\";\n        else if (fmt == CameraParameters::PIXEL_FORMAT_JPEG)\n            fmt = \"jpeg\";\n        cameraPropertyPreviewFormatString = fmt;\n\n        union {const char* str;double res;} u;\n        memset(&u.res, 0, sizeof(u.res));\n        u.str = cameraPropertyPreviewFormatString.c_str();\n        return u.res;\n    }\n    case ANDROID_CAMERA_PROPERTY_EXPOSURE:\n    {\n        int exposure = params->getInt(CameraParameters::KEY_EXPOSURE_COMPENSATION);\n        return exposure;\n    }\n    case ANDROID_CAMERA_PROPERTY_FPS:\n    {\n        return params->getPreviewFrameRate();\n    }\n    case ANDROID_CAMERA_PROPERTY_FLASH_MODE:\n    {\n        int flash_mode = getModeNum(CameraHandler::flashModesNames,\n                                    ANDROID_CAMERA_FLASH_MODES_NUM,\n                                    params->get(CameraParameters::KEY_FLASH_MODE));\n        return flash_mode;\n    }\n    case ANDROID_CAMERA_PROPERTY_FOCUS_MODE:\n    {\n        int focus_mode = getModeNum(CameraHandler::focusModesNames,\n                                    ANDROID_CAMERA_FOCUS_MODES_NUM,\n                                    params->get(CameraParameters::KEY_FOCUS_MODE));\n        return focus_mode;\n    }\n    case ANDROID_CAMERA_PROPERTY_WHITE_BALANCE:\n    {\n        int white_balance = getModeNum(CameraHandler::whiteBalanceModesNames,\n                                       ANDROID_CAMERA_WHITE_BALANCE_MODES_NUM,\n                                       params->get(CameraParameters::KEY_WHITE_BALANCE));\n        return white_balance;\n    }\n    case ANDROID_CAMERA_PROPERTY_ANTIBANDING:\n    {\n        int antibanding = getModeNum(CameraHandler::antibandingModesNames,\n                                     ANDROID_CAMERA_ANTIBANDING_MODES_NUM,\n                                     params->get(CameraParameters::KEY_ANTIBANDING));\n        return antibanding;\n    }\n    case ANDROID_CAMERA_PROPERTY_FOCAL_LENGTH:\n    {\n        float focal_length = params->getFloat(CameraParameters::KEY_FOCAL_LENGTH);\n        return focal_length;\n    }\n    case ANDROID_CAMERA_PROPERTY_FOCUS_DISTANCE_NEAR:\n    {\n        return getFocusDistance(ANDROID_CAMERA_FOCUS_DISTANCE_NEAR_INDEX);\n    }\n    case ANDROID_CAMERA_PROPERTY_FOCUS_DISTANCE_OPTIMAL:\n    {\n        return getFocusDistance(ANDROID_CAMERA_FOCUS_DISTANCE_OPTIMAL_INDEX);\n    }\n    case ANDROID_CAMERA_PROPERTY_FOCUS_DISTANCE_FAR:\n    {\n        return getFocusDistance(ANDROID_CAMERA_FOCUS_DISTANCE_FAR_INDEX);\n    }\n#if !defined(ANDROID_r2_2_0) && !defined(ANDROID_r2_3_3) && !defined(ANDROID_r3_0_1)\n    case ANDROID_CAMERA_PROPERTY_WHITEBALANCE_LOCK:\n    {\n        const char* status = params->get(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK);\n        if (status == CameraParameters::TRUE)\n            return 1.;\n        else\n            return 0.;\n    }\n    case ANDROID_CAMERA_PROPERTY_EXPOSE_LOCK:\n    {\n        const char* status = params->get(CameraParameters::KEY_AUTO_EXPOSURE_LOCK);\n        if (status == CameraParameters::TRUE)\n            return 1.;\n        else\n            return 0.;\n    }\n#endif\n    default:\n        LOGW(\"CameraHandler::getProperty - Unsupported property.\");\n    };\n    return -1;\n}\n\nvoid CameraHandler::setProperty(int propIdx, double value)\n{\n    LOGD(\"CameraHandler::setProperty(%d, %f)\", propIdx, value);\n\n    android::String8 params_str;\n    params_str = camera->getParameters();\n    LOGI(\"Params before set: [%s]\", params_str.string());\n\n    switch (propIdx)\n    {\n    case ANDROID_CAMERA_PROPERTY_FRAMEWIDTH:\n    {\n        int w,h;\n        params->getPreviewSize(&w, &h);\n        width = (int)value;\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_FRAMEHEIGHT:\n    {\n        int w,h;\n        params->getPreviewSize(&w, &h);\n        height = (int)value;\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_EXPOSURE:\n    {\n        int max_exposure = params->getInt(\"max-exposure-compensation\");\n        int min_exposure = params->getInt(\"min-exposure-compensation\");\n        if(max_exposure && min_exposure)\n        {\n            int exposure = (int)value;\n            if(exposure >= min_exposure && exposure <= max_exposure)\n                params->set(\"exposure-compensation\", exposure);\n            else\n                LOGE(\"Exposure compensation not in valid range (%i,%i).\", min_exposure, max_exposure);\n        } else\n            LOGE(\"Exposure compensation adjust is not supported.\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_FLASH_MODE:\n    {\n        int new_val = (int)value;\n        if(new_val >= 0 && new_val < ANDROID_CAMERA_FLASH_MODES_NUM)\n        {\n            const char* mode_name = flashModesNames[new_val];\n            if(is_supported(CameraParameters::KEY_SUPPORTED_FLASH_MODES, mode_name))\n                params->set(CameraParameters::KEY_FLASH_MODE, mode_name);\n            else\n                LOGE(\"Flash mode %s is not supported.\", mode_name);\n        }\n        else\n            LOGE(\"Flash mode value not in valid range.\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_FOCUS_MODE:\n    {\n        int new_val = (int)value;\n        if(new_val >= 0 && new_val < ANDROID_CAMERA_FOCUS_MODES_NUM)\n        {\n            const char* mode_name = focusModesNames[new_val];\n            if(is_supported(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, mode_name))\n                params->set(CameraParameters::KEY_FOCUS_MODE, mode_name);\n            else\n                LOGE(\"Focus mode %s is not supported.\", mode_name);\n        }\n        else\n            LOGE(\"Focus mode value not in valid range.\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_WHITE_BALANCE:\n    {\n        int new_val = (int)value;\n        if(new_val >= 0 && new_val < ANDROID_CAMERA_WHITE_BALANCE_MODES_NUM)\n        {\n            const char* mode_name = whiteBalanceModesNames[new_val];\n            if(is_supported(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, mode_name))\n                params->set(CameraParameters::KEY_WHITE_BALANCE, mode_name);\n            else\n                LOGE(\"White balance mode %s is not supported.\", mode_name);\n        }\n        else\n            LOGE(\"White balance mode value not in valid range.\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_ANTIBANDING:\n    {\n        int new_val = (int)value;\n        if(new_val >= 0 && new_val < ANDROID_CAMERA_ANTIBANDING_MODES_NUM)\n        {\n            const char* mode_name = antibandingModesNames[new_val];\n            if(is_supported(CameraParameters::KEY_SUPPORTED_ANTIBANDING, mode_name))\n                params->set(CameraParameters::KEY_ANTIBANDING, mode_name);\n            else\n                LOGE(\"Antibanding mode %s is not supported.\", mode_name);\n        }\n        else\n            LOGE(\"Antibanding mode value not in valid range.\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n#if !defined(ANDROID_r2_2_0) && !defined(ANDROID_r2_3_3) && !defined(ANDROID_r3_0_1)\n    case ANDROID_CAMERA_PROPERTY_EXPOSE_LOCK:\n    {\n        if (is_supported(CameraParameters::KEY_AUTO_EXPOSURE_LOCK_SUPPORTED, \"true\"))\n        {\n            if (value != 0)\n                params->set(CameraParameters::KEY_AUTO_EXPOSURE_LOCK, CameraParameters::TRUE);\n            else\n                params->set(CameraParameters::KEY_AUTO_EXPOSURE_LOCK, CameraParameters::FALSE);\n            LOGE(\"Expose lock is set\");\n        }\n        else\n            LOGE(\"Expose lock is not supported\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n    case ANDROID_CAMERA_PROPERTY_WHITEBALANCE_LOCK:\n    {\n        if (is_supported(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED, \"true\"))\n        {\n            if (value != 0)\n                params->set(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK, CameraParameters::TRUE);\n            else\n                params->set(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK, CameraParameters::FALSE);\n            LOGE(\"White balance lock is set\");\n        }\n        else\n            LOGE(\"White balance lock is not supported\");\n\n        camera->setParameters(params->flatten());\n    }\n    break;\n#endif\n    default:\n        LOGW(\"CameraHandler::setProperty - Unsupported property.\");\n    };\n\n    params_str = camera->getParameters();\n    LOGI(\"Params after set: [%s]\", params_str.string());\n}\n\nvoid CameraHandler::applyProperties(CameraHandler** ppcameraHandler)\n{\n    LOGD(\"CameraHandler::applyProperties()\");\n\n    if (ppcameraHandler == 0)\n    {\n        LOGE(\"applyProperties: Passed NULL ppcameraHandler\");\n        return;\n    }\n\n    if (*ppcameraHandler == 0)\n    {\n        LOGE(\"applyProperties: Passed NULL *ppcameraHandler\");\n        return;\n    }\n\n    // delayed resolution setup to exclude errors during other parameres setup on the fly\n    // without camera restart\n    if (((*ppcameraHandler)->width != 0) && ((*ppcameraHandler)->height != 0))\n        (*ppcameraHandler)->params->setPreviewSize((*ppcameraHandler)->width, (*ppcameraHandler)->height);\n\n#if defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3) || defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) \\\n || defined(ANDROID_r4_3_0) || defined(ANDROID_r4_4_0)\n    CameraHandler* handler=*ppcameraHandler;\n\n    handler->camera->stopPreview();\n    handler->camera->setPreviewCallbackFlags(CAMERA_FRAME_CALLBACK_FLAG_NOOP);\n\n    status_t reconnectStatus = handler->camera->reconnect();\n    if (reconnectStatus != 0)\n    {\n        LOGE(\"applyProperties: failed to reconnect camera (status %d)\", reconnectStatus);\n        return;\n    }\n\n    handler->camera->setParameters((*ppcameraHandler)->params->flatten());\n\n    status_t bufferStatus;\n# if defined(ANDROID_r4_0_0) || defined(ANDROID_r4_0_3)\n    void* surface_texture_obj = operator new(sizeof(SurfaceTexture) + MAGIC_TAIL);\n    handler->surface = new(surface_texture_obj) SurfaceTexture(MAGIC_OPENCV_TEXTURE_ID);\n    bufferStatus = handler->camera->setPreviewTexture(handler->surface);\n    if (bufferStatus != 0)\n        LOGE(\"applyProperties: failed setPreviewTexture call (status %d); camera might not work correctly\", bufferStatus);\n# elif defined(ANDROID_r4_1_1) || defined(ANDROID_r4_2_0) || defined(ANDROID_r4_3_0)\n    void* buffer_queue_obj = operator new(sizeof(BufferQueue) + MAGIC_TAIL);\n    handler->queue = new(buffer_queue_obj) BufferQueue();\n    handler->queue->consumerConnect(handler->listener);\n    bufferStatus = handler->camera->setPreviewTexture(handler->queue);\n    if (bufferStatus != 0)\n        LOGE(\"applyProperties: failed setPreviewTexture call; camera might not work correctly\");\n# elif defined(ANDROID_r4_4_0)\n    void* buffer_queue_obj = operator new(sizeof(BufferQueue) + MAGIC_TAIL);\n    handler->queue = new(buffer_queue_obj) BufferQueue();\n    handler->queue->setConsumerUsageBits(GraphicBuffer::USAGE_HW_TEXTURE);\n    handler->queue->consumerConnect(handler->listener, true);\n    bufferStatus = handler->camera->setPreviewTarget(handler->queue);\n    if (bufferStatus != 0)\n        LOGE(\"applyProperties: failed setPreviewTexture call; camera might not work correctly\");\n# endif\n\n    handler->camera->setPreviewCallbackFlags( CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK | CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK);//with copy\n\n    LOGD(\"Starting preview\");\n    status_t previewStatus = handler->camera->startPreview();\n\n    if (previewStatus != 0)\n    {\n        LOGE(\"initCameraConnect: startPreview() fails. Closing camera connection...\");\n        handler->closeCameraConnect();\n        handler = NULL;\n    }\n    else\n    {\n        LOGD(\"Preview started successfully\");\n    }\n#else\n    CameraHandler* previousCameraHandler=*ppcameraHandler;\n    CameraCallback cameraCallback=previousCameraHandler->cameraCallback;\n    void* userData=previousCameraHandler->userData;\n    int cameraId=previousCameraHandler->cameraId;\n\n    LOGD(\"CameraHandler::applyProperties(): before previousCameraHandler->closeCameraConnect\");\n    previousCameraHandler->closeCameraConnect();\n    LOGD(\"CameraHandler::applyProperties(): after previousCameraHandler->closeCameraConnect\");\n\n    LOGD(\"CameraHandler::applyProperties(): before initCameraConnect\");\n    CameraHandler* handler=initCameraConnect(cameraCallback, cameraId, userData, (*ppcameraHandler)->params);\n    LOGD(\"CameraHandler::applyProperties(): after initCameraConnect, handler=0x%x\", (int)handler);\n    if (handler == NULL) {\n        LOGE(\"ERROR in applyProperties --- cannot reinit camera\");\n        handler=initCameraConnect(cameraCallback, cameraId, userData, NULL);\n        LOGD(\"CameraHandler::applyProperties(): repeate initCameraConnect after ERROR, handler=0x%x\", (int)handler);\n        if (handler == NULL) {\n            LOGE(\"ERROR in applyProperties --- cannot reinit camera AGAIN --- cannot do anything else\");\n        }\n    }\n    (*ppcameraHandler)=handler;\n#endif\n}\n\n\nextern \"C\" {\n\nvoid* initCameraConnectC(void* callback, int cameraId, void* userData)\n{\n    return CameraHandler::initCameraConnect((CameraCallback)callback, cameraId, userData, NULL);\n}\n\nvoid closeCameraConnectC(void** camera)\n{\n    CameraHandler** cc = (CameraHandler**)camera;\n    (*cc)->closeCameraConnect();\n    *cc = 0;\n}\n\ndouble getCameraPropertyC(void* camera, int propIdx)\n{\n    return ((CameraHandler*)camera)->getProperty(propIdx);\n}\n\nvoid setCameraPropertyC(void* camera, int propIdx, double value)\n{\n    ((CameraHandler*)camera)->setProperty(propIdx,value);\n}\n\nvoid applyCameraPropertiesC(void** camera)\n{\n    CameraHandler::applyProperties((CameraHandler**)camera);\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/src/gl_core_3_1.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include <string>\n#include <sstream>\n#include \"cvconfig.h\"\n#include \"opencv2/core/core.hpp\"\n#include \"gl_core_3_1.hpp\"\n\n#ifdef HAVE_OPENGL\n\n    #ifdef __APPLE__\n        #include <dlfcn.h>\n\n        static void* AppleGLGetProcAddress (const char* name)\n        {\n            static bool initialized = false;\n            static void * handle = NULL;\n            if (!handle)\n            {\n                if (!initialized)\n                {\n                    initialized = true;\n                    const char * const path = \"/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL\";\n\n                    handle = dlopen(path, RTLD_LAZY | RTLD_GLOBAL);\n                }\n                if (!handle)\n                    return NULL;\n            }\n            return dlsym(handle, name);\n        }\n    #endif // __APPLE__\n\n    #if defined(__sgi) || defined (__sun)\n        #include <dlfcn.h>\n        #include <stdio.h>\n\n        static void* SunGetProcAddress (const char* name)\n        {\n            typedef void* (func_t*)(const GLubyte*);\n\n            static void* h = 0;\n            static func_t gpa = 0;\n\n            if (!h)\n            {\n                h = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL);\n                if (!h)\n                    return 0;\n                gpa = (func_t) dlsym(h, \"glXGetProcAddress\");\n            }\n\n            return gpa ? gpa((const GLubyte*) name) : dlsym(h, name);\n        }\n    #endif // __sgi || __sun\n\n    #if defined(_WIN32)\n        #ifdef _MSC_VER\n            #pragma warning(disable: 4055)\n            #pragma warning(disable: 4054)\n        #endif\n\n        static int TestPointer(const PROC pTest)\n        {\n            if(!pTest)\n                return 0;\n\n            ptrdiff_t iTest = (ptrdiff_t) pTest;\n\n            if (iTest == 1 || iTest == 2 || iTest == 3 || iTest == -1)\n                return 0;\n\n            return 1;\n        }\n\n        static PROC WinGetProcAddress(const char* name)\n        {\n            PROC pFunc = wglGetProcAddress((LPCSTR) name);\n            if (TestPointer(pFunc))\n                return pFunc;\n\n            HMODULE glMod = GetModuleHandleA(\"OpenGL32.dll\");\n            return (PROC) GetProcAddress(glMod, (LPCSTR) name);\n        }\n    #endif // _WIN32\n\n    #if defined(_WIN32)\n        #define CV_GL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n    #elif defined(__APPLE__)\n        #define CV_GL_GET_PROC_ADDRESS(name) AppleGLGetProcAddress(name)\n    #elif defined(__sgi) || defined(__sun)\n        #define CV_GL_GET_PROC_ADDRESS(name) SunGetProcAddress(name)\n    #else // GLX\n        #include <GL/glx.h>\n\n        #define CV_GL_GET_PROC_ADDRESS(name) glXGetProcAddressARB((const GLubyte*) name)\n    #endif\n\n    static void* IntGetProcAddress(const char* name)\n    {\n        void* func =  (void*) CV_GL_GET_PROC_ADDRESS(name);\n        if (!func)\n        {\n            std::ostringstream msg;\n            msg << \"Can't load OpenGL extension [\" << name << \"]\";\n            CV_Error(CV_OpenGlApiCallError, msg.str());\n        }\n        return func;\n    }\n#else\n    static void* IntGetProcAddress(const char*)\n    {\n        CV_Error(CV_OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n        return 0;\n    }\n#endif\n\nnamespace gl\n{\n    //////////////////////////////////////////////\n    // Function pointer types\n\n    // Extension: 1.1\n    typedef void (CODEGEN_FUNCPTR *PFNCULLFACEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFRONTFACEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNHINTPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLINEWIDTHPROC)(GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTSIZEPROC)(GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOLYGONMODEPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSCISSORPROC)(GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERFPROC)(GLenum , GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERFVPROC)(GLenum , GLenum , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIPROC)(GLenum , GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIVPROC)(GLenum , GLenum , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLint , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXIMAGE2DPROC)(GLenum , GLint , GLint , GLsizei , GLsizei , GLint , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARPROC)(GLbitfield );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARCOLORPROC)(GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARSTENCILPROC)(GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARDEPTHPROC)(GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILMASKPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORMASKPROC)(GLboolean , GLboolean , GLboolean , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHMASKPROC)(GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFINISHPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNFLUSHPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDFUNCPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLOGICOPPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILFUNCPROC)(GLenum , GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILOPPROC)(GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHFUNCPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNPIXELSTOREFPROC)(GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPIXELSTOREIPROC)(GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNREADBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNREADPIXELSPROC)(GLint , GLint , GLsizei , GLsizei , GLenum , GLenum , GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBOOLEANVPROC)(GLenum , GLboolean *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETDOUBLEVPROC)(GLenum , GLdouble *);\n    typedef GLenum (CODEGEN_FUNCPTR *PFNGETERRORPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNGETFLOATVPROC)(GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETINTEGERVPROC)(GLenum , GLint *);\n    typedef const GLubyte * (CODEGEN_FUNCPTR *PFNGETSTRINGPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXIMAGEPROC)(GLenum , GLint , GLenum , GLenum , GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERFVPROC)(GLenum , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXLEVELPARAMETERFVPROC)(GLenum , GLint , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXLEVELPARAMETERIVPROC)(GLenum , GLint , GLenum , GLint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISENABLEDPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDEPTHRANGEPROC)(GLdouble , GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNVIEWPORTPROC)(GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWARRAYSPROC)(GLenum , GLint , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWELEMENTSPROC)(GLenum , GLsizei , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPOINTERVPROC)(GLenum , GLvoid* *);\n    typedef void (CODEGEN_FUNCPTR *PFNPOLYGONOFFSETPROC)(GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXIMAGE1DPROC)(GLenum , GLint , GLenum , GLint , GLint , GLsizei , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXIMAGE2DPROC)(GLenum , GLint , GLenum , GLint , GLint , GLsizei , GLsizei , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLint , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLsizei , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDTEXTUREPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETETEXTURESPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENTEXTURESPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISTEXTUREPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNINDEXUBPROC)(GLubyte );\n    typedef void (CODEGEN_FUNCPTR *PFNINDEXUBVPROC)(const GLubyte *);\n\n    // Extension: 1.2\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDCOLORPROC)(GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDEQUATIONPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWRANGEELEMENTSPROC)(GLenum , GLuint , GLuint , GLsizei , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei , GLsizei , GLsizei , GLenum , GLenum , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLint , GLint , GLsizei , GLsizei );\n\n    // Extension: 1.3\n    typedef void (CODEGEN_FUNCPTR *PFNACTIVETEXTUREPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSAMPLECOVERAGEPROC)(GLfloat , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE3DPROC)(GLenum , GLint , GLenum , GLsizei , GLsizei , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE2DPROC)(GLenum , GLint , GLenum , GLsizei , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXIMAGE1DPROC)(GLenum , GLint , GLenum , GLsizei , GLint , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum , GLint , GLint , GLint , GLint , GLsizei , GLsizei , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum , GLint , GLint , GLint , GLsizei , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum , GLint , GLint , GLsizei , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETCOMPRESSEDTEXIMAGEPROC)(GLenum , GLint , GLvoid *);\n\n    // Extension: 1.4\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDFUNCSEPARATEPROC)(GLenum , GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNMULTIDRAWARRAYSPROC)(GLenum , const GLint *, const GLsizei *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNMULTIDRAWELEMENTSPROC)(GLenum , const GLsizei *, GLenum , const GLvoid* const *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERFPROC)(GLenum , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERFVPROC)(GLenum , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERIPROC)(GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNPOINTPARAMETERIVPROC)(GLenum , const GLint *);\n\n    // Extension: 1.5\n    typedef void (CODEGEN_FUNCPTR *PFNGENQUERIESPROC)(GLsizei , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEQUERIESPROC)(GLsizei , const GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISQUERYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINQUERYPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNENDQUERYPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYOBJECTIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETQUERYOBJECTUIVPROC)(GLuint , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENBUFFERSPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBUFFERDATAPROC)(GLenum , GLsizeiptr , const GLvoid *, GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBUFFERSUBDATAPROC)(GLenum , GLintptr , GLsizeiptr , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERSUBDATAPROC)(GLenum , GLintptr , GLsizeiptr , GLvoid *);\n    typedef GLvoid* (CODEGEN_FUNCPTR *PFNMAPBUFFERPROC)(GLenum , GLenum );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNUNMAPBUFFERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETBUFFERPOINTERVPROC)(GLenum , GLenum , GLvoid* *);\n\n    // Extension: 2.0\n    typedef void (CODEGEN_FUNCPTR *PFNBLENDEQUATIONSEPARATEPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWBUFFERSPROC)(GLsizei , const GLenum *);\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILOPSEPARATEPROC)(GLenum , GLenum , GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILFUNCSEPARATEPROC)(GLenum , GLenum , GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSTENCILMASKSEPARATEPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNATTACHSHADERPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDATTRIBLOCATIONPROC)(GLuint , GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOMPILESHADERPROC)(GLuint );\n    typedef GLuint (CODEGEN_FUNCPTR *PFNCREATEPROGRAMPROC)();\n    typedef GLuint (CODEGEN_FUNCPTR *PFNCREATESHADERPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETESHADERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDETACHSHADERPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEVERTEXATTRIBARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEVERTEXATTRIBARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEATTRIBPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLint *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLint *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETATTACHEDSHADERSPROC)(GLuint , GLsizei , GLsizei *, GLuint *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETATTRIBLOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPROGRAMIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETPROGRAMINFOLOGPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERINFOLOGPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETSHADERSOURCEPROC)(GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETUNIFORMLOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMFVPROC)(GLuint , GLint , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMIVPROC)(GLuint , GLint , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBDVPROC)(GLuint , GLenum , GLdouble *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBFVPROC)(GLuint , GLenum , GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBPOINTERVPROC)(GLuint , GLenum , GLvoid* *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISPROGRAMPROC)(GLuint );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISSHADERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNLINKPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNSHADERSOURCEPROC)(GLuint , GLsizei , const GLchar* const *, const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUSEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1FPROC)(GLint , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2FPROC)(GLint , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3FPROC)(GLint , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4FPROC)(GLint , GLfloat , GLfloat , GLfloat , GLfloat );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1IPROC)(GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2IPROC)(GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3IPROC)(GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4IPROC)(GLint , GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4FVPROC)(GLint , GLsizei , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4IVPROC)(GLint , GLsizei , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNVALIDATEPROGRAMPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBPOINTERPROC)(GLuint , GLint , GLenum , GLboolean , GLsizei , const GLvoid *);\n\n    // Extension: 2.1\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2X3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3X2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX2X4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4X2FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX3X4FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMMATRIX4X3FVPROC)(GLint , GLsizei , GLboolean , const GLfloat *);\n\n    // Extension: ARB_vertex_array_object\n    typedef void (CODEGEN_FUNCPTR *PFNBINDVERTEXARRAYPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEVERTEXARRAYSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENVERTEXARRAYSPROC)(GLsizei , GLuint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISVERTEXARRAYPROC)(GLuint );\n\n    // Extension: ARB_map_buffer_range\n    typedef GLvoid* (CODEGEN_FUNCPTR *PFNMAPBUFFERRANGEPROC)(GLenum , GLintptr , GLsizeiptr , GLbitfield );\n    typedef void (CODEGEN_FUNCPTR *PFNFLUSHMAPPEDBUFFERRANGEPROC)(GLenum , GLintptr , GLsizeiptr );\n\n    // Extension: ARB_framebuffer_object\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISRENDERBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDRENDERBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETERENDERBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENRENDERBUFFERSPROC)(GLsizei , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNRENDERBUFFERSTORAGEPROC)(GLenum , GLenum , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNGETRENDERBUFFERPARAMETERIVPROC)(GLenum , GLenum , GLint *);\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISFRAMEBUFFERPROC)(GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDFRAMEBUFFERPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDELETEFRAMEBUFFERSPROC)(GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENFRAMEBUFFERSPROC)(GLsizei , GLuint *);\n    typedef GLenum (CODEGEN_FUNCPTR *PFNCHECKFRAMEBUFFERSTATUSPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE1DPROC)(GLenum , GLenum , GLenum , GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE2DPROC)(GLenum , GLenum , GLenum , GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURE3DPROC)(GLenum , GLenum , GLenum , GLuint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERRENDERBUFFERPROC)(GLenum , GLenum , GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum , GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGENERATEMIPMAPPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBLITFRAMEBUFFERPROC)(GLint , GLint , GLint , GLint , GLint , GLint , GLint , GLint , GLbitfield , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum , GLsizei , GLenum , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNFRAMEBUFFERTEXTURELAYERPROC)(GLenum , GLenum , GLuint , GLint , GLint );\n\n    // Extension: 3.0\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORMASKIPROC)(GLuint , GLboolean , GLboolean , GLboolean , GLboolean );\n    typedef void (CODEGEN_FUNCPTR *PFNGETBOOLEANI_VPROC)(GLenum , GLuint , GLboolean *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETINTEGERI_VPROC)(GLenum , GLuint , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNENABLEIPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLEIPROC)(GLenum , GLuint );\n    typedef GLboolean (CODEGEN_FUNCPTR *PFNISENABLEDIPROC)(GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINTRANSFORMFEEDBACKPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENDTRANSFORMFEEDBACKPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERRANGEPROC)(GLenum , GLuint , GLuint , GLintptr , GLsizeiptr );\n    typedef void (CODEGEN_FUNCPTR *PFNBINDBUFFERBASEPROC)(GLenum , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNTRANSFORMFEEDBACKVARYINGSPROC)(GLuint , GLsizei , const GLchar* const *, GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLsizei *, GLenum *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLAMPCOLORPROC)(GLenum , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNBEGINCONDITIONALRENDERPROC)(GLuint , GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNENDCONDITIONALRENDERPROC)();\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBIPOINTERPROC)(GLuint , GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIIVPROC)(GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETVERTEXATTRIBIUIVPROC)(GLuint , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1IPROC)(GLuint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2IPROC)(GLuint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3IPROC)(GLuint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4IPROC)(GLuint , GLint , GLint , GLint , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1UIPROC)(GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2UIPROC)(GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3UIPROC)(GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UIPROC)(GLuint , GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4IVPROC)(GLuint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI1UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI2UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI3UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UIVPROC)(GLuint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4BVPROC)(GLuint , const GLbyte *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4SVPROC)(GLuint , const GLshort *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4UBVPROC)(GLuint , const GLubyte *);\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXATTRIBI4USVPROC)(GLuint , const GLushort *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMUIVPROC)(GLuint , GLint , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNBINDFRAGDATALOCATIONPROC)(GLuint , GLuint , const GLchar *);\n    typedef GLint (CODEGEN_FUNCPTR *PFNGETFRAGDATALOCATIONPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1UIPROC)(GLint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2UIPROC)(GLint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3UIPROC)(GLint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4UIPROC)(GLint , GLuint , GLuint , GLuint , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM1UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM2UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM3UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORM4UIVPROC)(GLint , GLsizei , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIIVPROC)(GLenum , GLenum , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXPARAMETERIUIVPROC)(GLenum , GLenum , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIIVPROC)(GLenum , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETTEXPARAMETERIUIVPROC)(GLenum , GLenum , GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERIVPROC)(GLenum , GLint , const GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERUIVPROC)(GLenum , GLint , const GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERFVPROC)(GLenum , GLint , const GLfloat *);\n    typedef void (CODEGEN_FUNCPTR *PFNCLEARBUFFERFIPROC)(GLenum , GLint , GLfloat , GLint );\n    typedef const GLubyte * (CODEGEN_FUNCPTR *PFNGETSTRINGIPROC)(GLenum , GLuint );\n\n    // Extension: ARB_uniform_buffer_object\n    typedef void (CODEGEN_FUNCPTR *PFNGETUNIFORMINDICESPROC)(GLuint , GLsizei , const GLchar* const *, GLuint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMSIVPROC)(GLuint , GLsizei , const GLuint *, GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMNAMEPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef GLuint (CODEGEN_FUNCPTR *PFNGETUNIFORMBLOCKINDEXPROC)(GLuint , const GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMBLOCKIVPROC)(GLuint , GLuint , GLenum , GLint *);\n    typedef void (CODEGEN_FUNCPTR *PFNGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint , GLuint , GLsizei , GLsizei *, GLchar *);\n    typedef void (CODEGEN_FUNCPTR *PFNUNIFORMBLOCKBINDINGPROC)(GLuint , GLuint , GLuint );\n\n    // Extension: ARB_copy_buffer\n    typedef void (CODEGEN_FUNCPTR *PFNCOPYBUFFERSUBDATAPROC)(GLenum , GLenum , GLintptr , GLintptr , GLsizeiptr );\n\n    // Extension: 3.1\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWARRAYSINSTANCEDPROC)(GLenum , GLint , GLsizei , GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNDRAWELEMENTSINSTANCEDPROC)(GLenum , GLsizei , GLenum , const GLvoid *, GLsizei );\n    typedef void (CODEGEN_FUNCPTR *PFNTEXBUFFERPROC)(GLenum , GLenum , GLuint );\n    typedef void (CODEGEN_FUNCPTR *PFNPRIMITIVERESTARTINDEXPROC)(GLuint );\n\n    // Legacy\n    typedef void (CODEGEN_FUNCPTR *PFNENABLECLIENTSTATEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNDISABLECLIENTSTATEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNVERTEXPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNNORMALPOINTERPROC)(GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNCOLORPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXCOORDPOINTERPROC)(GLint , GLenum , GLsizei , const GLvoid *);\n    typedef void (CODEGEN_FUNCPTR *PFNTEXENVIPROC)(GLenum , GLenum , GLint );\n    typedef void (CODEGEN_FUNCPTR *PFNMATRIXMODEPROC)(GLenum );\n    typedef void (CODEGEN_FUNCPTR *PFNLOADIDENTITYPROC)(void);\n    typedef void (CODEGEN_FUNCPTR *PFNORTHOPROC)(GLdouble , GLdouble , GLdouble , GLdouble , GLdouble , GLdouble );\n    typedef void (CODEGEN_FUNCPTR *PFNCOLOR3DPROC)(GLdouble , GLdouble , GLdouble );\n\n    //////////////////////////////////////////////\n    // Function pointers\n\n    // Extension: 1.1\n    PFNCULLFACEPROC CullFace;\n    PFNFRONTFACEPROC FrontFace;\n    PFNHINTPROC Hint;\n    PFNLINEWIDTHPROC LineWidth;\n    PFNPOINTSIZEPROC PointSize;\n    PFNPOLYGONMODEPROC PolygonMode;\n    PFNSCISSORPROC Scissor;\n    PFNTEXPARAMETERFPROC TexParameterf;\n    PFNTEXPARAMETERFVPROC TexParameterfv;\n    PFNTEXPARAMETERIPROC TexParameteri;\n    PFNTEXPARAMETERIVPROC TexParameteriv;\n    PFNTEXIMAGE1DPROC TexImage1D;\n    PFNTEXIMAGE2DPROC TexImage2D;\n    PFNDRAWBUFFERPROC DrawBuffer;\n    PFNCLEARPROC Clear;\n    PFNCLEARCOLORPROC ClearColor;\n    PFNCLEARSTENCILPROC ClearStencil;\n    PFNCLEARDEPTHPROC ClearDepth;\n    PFNSTENCILMASKPROC StencilMask;\n    PFNCOLORMASKPROC ColorMask;\n    PFNDEPTHMASKPROC DepthMask;\n    PFNDISABLEPROC Disable;\n    PFNENABLEPROC Enable;\n    PFNFINISHPROC Finish;\n    PFNFLUSHPROC Flush;\n    PFNBLENDFUNCPROC BlendFunc;\n    PFNLOGICOPPROC LogicOp;\n    PFNSTENCILFUNCPROC StencilFunc;\n    PFNSTENCILOPPROC StencilOp;\n    PFNDEPTHFUNCPROC DepthFunc;\n    PFNPIXELSTOREFPROC PixelStoref;\n    PFNPIXELSTOREIPROC PixelStorei;\n    PFNREADBUFFERPROC ReadBuffer;\n    PFNREADPIXELSPROC ReadPixels;\n    PFNGETBOOLEANVPROC GetBooleanv;\n    PFNGETDOUBLEVPROC GetDoublev;\n    PFNGETERRORPROC GetError;\n    PFNGETFLOATVPROC GetFloatv;\n    PFNGETINTEGERVPROC GetIntegerv;\n    PFNGETSTRINGPROC GetString;\n    PFNGETTEXIMAGEPROC GetTexImage;\n    PFNGETTEXPARAMETERFVPROC GetTexParameterfv;\n    PFNGETTEXPARAMETERIVPROC GetTexParameteriv;\n    PFNGETTEXLEVELPARAMETERFVPROC GetTexLevelParameterfv;\n    PFNGETTEXLEVELPARAMETERIVPROC GetTexLevelParameteriv;\n    PFNISENABLEDPROC IsEnabled;\n    PFNDEPTHRANGEPROC DepthRange;\n    PFNVIEWPORTPROC Viewport;\n    PFNDRAWARRAYSPROC DrawArrays;\n    PFNDRAWELEMENTSPROC DrawElements;\n    PFNGETPOINTERVPROC GetPointerv;\n    PFNPOLYGONOFFSETPROC PolygonOffset;\n    PFNCOPYTEXIMAGE1DPROC CopyTexImage1D;\n    PFNCOPYTEXIMAGE2DPROC CopyTexImage2D;\n    PFNCOPYTEXSUBIMAGE1DPROC CopyTexSubImage1D;\n    PFNCOPYTEXSUBIMAGE2DPROC CopyTexSubImage2D;\n    PFNTEXSUBIMAGE1DPROC TexSubImage1D;\n    PFNTEXSUBIMAGE2DPROC TexSubImage2D;\n    PFNBINDTEXTUREPROC BindTexture;\n    PFNDELETETEXTURESPROC DeleteTextures;\n    PFNGENTEXTURESPROC GenTextures;\n    PFNISTEXTUREPROC IsTexture;\n    PFNINDEXUBPROC Indexub;\n    PFNINDEXUBVPROC Indexubv;\n\n    // Extension: 1.2\n    PFNBLENDCOLORPROC BlendColor;\n    PFNBLENDEQUATIONPROC BlendEquation;\n    PFNDRAWRANGEELEMENTSPROC DrawRangeElements;\n    PFNTEXSUBIMAGE3DPROC TexSubImage3D;\n    PFNCOPYTEXSUBIMAGE3DPROC CopyTexSubImage3D;\n\n    // Extension: 1.3\n    PFNACTIVETEXTUREPROC ActiveTexture;\n    PFNSAMPLECOVERAGEPROC SampleCoverage;\n    PFNCOMPRESSEDTEXIMAGE3DPROC CompressedTexImage3D;\n    PFNCOMPRESSEDTEXIMAGE2DPROC CompressedTexImage2D;\n    PFNCOMPRESSEDTEXIMAGE1DPROC CompressedTexImage1D;\n    PFNCOMPRESSEDTEXSUBIMAGE3DPROC CompressedTexSubImage3D;\n    PFNCOMPRESSEDTEXSUBIMAGE2DPROC CompressedTexSubImage2D;\n    PFNCOMPRESSEDTEXSUBIMAGE1DPROC CompressedTexSubImage1D;\n    PFNGETCOMPRESSEDTEXIMAGEPROC GetCompressedTexImage;\n\n    // Extension: 1.4\n    PFNBLENDFUNCSEPARATEPROC BlendFuncSeparate;\n    PFNMULTIDRAWARRAYSPROC MultiDrawArrays;\n    PFNMULTIDRAWELEMENTSPROC MultiDrawElements;\n    PFNPOINTPARAMETERFPROC PointParameterf;\n    PFNPOINTPARAMETERFVPROC PointParameterfv;\n    PFNPOINTPARAMETERIPROC PointParameteri;\n    PFNPOINTPARAMETERIVPROC PointParameteriv;\n\n    // Extension: 1.5\n    PFNGENQUERIESPROC GenQueries;\n    PFNDELETEQUERIESPROC DeleteQueries;\n    PFNISQUERYPROC IsQuery;\n    PFNBEGINQUERYPROC BeginQuery;\n    PFNENDQUERYPROC EndQuery;\n    PFNGETQUERYIVPROC GetQueryiv;\n    PFNGETQUERYOBJECTIVPROC GetQueryObjectiv;\n    PFNGETQUERYOBJECTUIVPROC GetQueryObjectuiv;\n    PFNBINDBUFFERPROC BindBuffer;\n    PFNDELETEBUFFERSPROC DeleteBuffers;\n    PFNGENBUFFERSPROC GenBuffers;\n    PFNISBUFFERPROC IsBuffer;\n    PFNBUFFERDATAPROC BufferData;\n    PFNBUFFERSUBDATAPROC BufferSubData;\n    PFNGETBUFFERSUBDATAPROC GetBufferSubData;\n    PFNMAPBUFFERPROC MapBuffer;\n    PFNUNMAPBUFFERPROC UnmapBuffer;\n    PFNGETBUFFERPARAMETERIVPROC GetBufferParameteriv;\n    PFNGETBUFFERPOINTERVPROC GetBufferPointerv;\n\n    // Extension: 2.0\n    PFNBLENDEQUATIONSEPARATEPROC BlendEquationSeparate;\n    PFNDRAWBUFFERSPROC DrawBuffers;\n    PFNSTENCILOPSEPARATEPROC StencilOpSeparate;\n    PFNSTENCILFUNCSEPARATEPROC StencilFuncSeparate;\n    PFNSTENCILMASKSEPARATEPROC StencilMaskSeparate;\n    PFNATTACHSHADERPROC AttachShader;\n    PFNBINDATTRIBLOCATIONPROC BindAttribLocation;\n    PFNCOMPILESHADERPROC CompileShader;\n    PFNCREATEPROGRAMPROC CreateProgram;\n    PFNCREATESHADERPROC CreateShader;\n    PFNDELETEPROGRAMPROC DeleteProgram;\n    PFNDELETESHADERPROC DeleteShader;\n    PFNDETACHSHADERPROC DetachShader;\n    PFNDISABLEVERTEXATTRIBARRAYPROC DisableVertexAttribArray;\n    PFNENABLEVERTEXATTRIBARRAYPROC EnableVertexAttribArray;\n    PFNGETACTIVEATTRIBPROC GetActiveAttrib;\n    PFNGETACTIVEUNIFORMPROC GetActiveUniform;\n    PFNGETATTACHEDSHADERSPROC GetAttachedShaders;\n    PFNGETATTRIBLOCATIONPROC GetAttribLocation;\n    PFNGETPROGRAMIVPROC GetProgramiv;\n    PFNGETPROGRAMINFOLOGPROC GetProgramInfoLog;\n    PFNGETSHADERIVPROC GetShaderiv;\n    PFNGETSHADERINFOLOGPROC GetShaderInfoLog;\n    PFNGETSHADERSOURCEPROC GetShaderSource;\n    PFNGETUNIFORMLOCATIONPROC GetUniformLocation;\n    PFNGETUNIFORMFVPROC GetUniformfv;\n    PFNGETUNIFORMIVPROC GetUniformiv;\n    PFNGETVERTEXATTRIBDVPROC GetVertexAttribdv;\n    PFNGETVERTEXATTRIBFVPROC GetVertexAttribfv;\n    PFNGETVERTEXATTRIBIVPROC GetVertexAttribiv;\n    PFNGETVERTEXATTRIBPOINTERVPROC GetVertexAttribPointerv;\n    PFNISPROGRAMPROC IsProgram;\n    PFNISSHADERPROC IsShader;\n    PFNLINKPROGRAMPROC LinkProgram;\n    PFNSHADERSOURCEPROC ShaderSource;\n    PFNUSEPROGRAMPROC UseProgram;\n    PFNUNIFORM1FPROC Uniform1f;\n    PFNUNIFORM2FPROC Uniform2f;\n    PFNUNIFORM3FPROC Uniform3f;\n    PFNUNIFORM4FPROC Uniform4f;\n    PFNUNIFORM1IPROC Uniform1i;\n    PFNUNIFORM2IPROC Uniform2i;\n    PFNUNIFORM3IPROC Uniform3i;\n    PFNUNIFORM4IPROC Uniform4i;\n    PFNUNIFORM1FVPROC Uniform1fv;\n    PFNUNIFORM2FVPROC Uniform2fv;\n    PFNUNIFORM3FVPROC Uniform3fv;\n    PFNUNIFORM4FVPROC Uniform4fv;\n    PFNUNIFORM1IVPROC Uniform1iv;\n    PFNUNIFORM2IVPROC Uniform2iv;\n    PFNUNIFORM3IVPROC Uniform3iv;\n    PFNUNIFORM4IVPROC Uniform4iv;\n    PFNUNIFORMMATRIX2FVPROC UniformMatrix2fv;\n    PFNUNIFORMMATRIX3FVPROC UniformMatrix3fv;\n    PFNUNIFORMMATRIX4FVPROC UniformMatrix4fv;\n    PFNVALIDATEPROGRAMPROC ValidateProgram;\n    PFNVERTEXATTRIBPOINTERPROC VertexAttribPointer;\n\n    // Extension: 2.1\n    PFNUNIFORMMATRIX2X3FVPROC UniformMatrix2x3fv;\n    PFNUNIFORMMATRIX3X2FVPROC UniformMatrix3x2fv;\n    PFNUNIFORMMATRIX2X4FVPROC UniformMatrix2x4fv;\n    PFNUNIFORMMATRIX4X2FVPROC UniformMatrix4x2fv;\n    PFNUNIFORMMATRIX3X4FVPROC UniformMatrix3x4fv;\n    PFNUNIFORMMATRIX4X3FVPROC UniformMatrix4x3fv;\n\n    // Extension: ARB_vertex_array_object\n    PFNBINDVERTEXARRAYPROC BindVertexArray;\n    PFNDELETEVERTEXARRAYSPROC DeleteVertexArrays;\n    PFNGENVERTEXARRAYSPROC GenVertexArrays;\n    PFNISVERTEXARRAYPROC IsVertexArray;\n\n    // Extension: ARB_map_buffer_range\n    PFNMAPBUFFERRANGEPROC MapBufferRange;\n    PFNFLUSHMAPPEDBUFFERRANGEPROC FlushMappedBufferRange;\n\n    // Extension: ARB_framebuffer_object\n    PFNISRENDERBUFFERPROC IsRenderbuffer;\n    PFNBINDRENDERBUFFERPROC BindRenderbuffer;\n    PFNDELETERENDERBUFFERSPROC DeleteRenderbuffers;\n    PFNGENRENDERBUFFERSPROC GenRenderbuffers;\n    PFNRENDERBUFFERSTORAGEPROC RenderbufferStorage;\n    PFNGETRENDERBUFFERPARAMETERIVPROC GetRenderbufferParameteriv;\n    PFNISFRAMEBUFFERPROC IsFramebuffer;\n    PFNBINDFRAMEBUFFERPROC BindFramebuffer;\n    PFNDELETEFRAMEBUFFERSPROC DeleteFramebuffers;\n    PFNGENFRAMEBUFFERSPROC GenFramebuffers;\n    PFNCHECKFRAMEBUFFERSTATUSPROC CheckFramebufferStatus;\n    PFNFRAMEBUFFERTEXTURE1DPROC FramebufferTexture1D;\n    PFNFRAMEBUFFERTEXTURE2DPROC FramebufferTexture2D;\n    PFNFRAMEBUFFERTEXTURE3DPROC FramebufferTexture3D;\n    PFNFRAMEBUFFERRENDERBUFFERPROC FramebufferRenderbuffer;\n    PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC GetFramebufferAttachmentParameteriv;\n    PFNGENERATEMIPMAPPROC GenerateMipmap;\n    PFNBLITFRAMEBUFFERPROC BlitFramebuffer;\n    PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC RenderbufferStorageMultisample;\n    PFNFRAMEBUFFERTEXTURELAYERPROC FramebufferTextureLayer;\n\n    // Extension: 3.0\n    PFNCOLORMASKIPROC ColorMaski;\n    PFNGETBOOLEANI_VPROC GetBooleani_v;\n    PFNGETINTEGERI_VPROC GetIntegeri_v;\n    PFNENABLEIPROC Enablei;\n    PFNDISABLEIPROC Disablei;\n    PFNISENABLEDIPROC IsEnabledi;\n    PFNBEGINTRANSFORMFEEDBACKPROC BeginTransformFeedback;\n    PFNENDTRANSFORMFEEDBACKPROC EndTransformFeedback;\n    PFNBINDBUFFERRANGEPROC BindBufferRange;\n    PFNBINDBUFFERBASEPROC BindBufferBase;\n    PFNTRANSFORMFEEDBACKVARYINGSPROC TransformFeedbackVaryings;\n    PFNGETTRANSFORMFEEDBACKVARYINGPROC GetTransformFeedbackVarying;\n    PFNCLAMPCOLORPROC ClampColor;\n    PFNBEGINCONDITIONALRENDERPROC BeginConditionalRender;\n    PFNENDCONDITIONALRENDERPROC EndConditionalRender;\n    PFNVERTEXATTRIBIPOINTERPROC VertexAttribIPointer;\n    PFNGETVERTEXATTRIBIIVPROC GetVertexAttribIiv;\n    PFNGETVERTEXATTRIBIUIVPROC GetVertexAttribIuiv;\n    PFNVERTEXATTRIBI1IPROC VertexAttribI1i;\n    PFNVERTEXATTRIBI2IPROC VertexAttribI2i;\n    PFNVERTEXATTRIBI3IPROC VertexAttribI3i;\n    PFNVERTEXATTRIBI4IPROC VertexAttribI4i;\n    PFNVERTEXATTRIBI1UIPROC VertexAttribI1ui;\n    PFNVERTEXATTRIBI2UIPROC VertexAttribI2ui;\n    PFNVERTEXATTRIBI3UIPROC VertexAttribI3ui;\n    PFNVERTEXATTRIBI4UIPROC VertexAttribI4ui;\n    PFNVERTEXATTRIBI1IVPROC VertexAttribI1iv;\n    PFNVERTEXATTRIBI2IVPROC VertexAttribI2iv;\n    PFNVERTEXATTRIBI3IVPROC VertexAttribI3iv;\n    PFNVERTEXATTRIBI4IVPROC VertexAttribI4iv;\n    PFNVERTEXATTRIBI1UIVPROC VertexAttribI1uiv;\n    PFNVERTEXATTRIBI2UIVPROC VertexAttribI2uiv;\n    PFNVERTEXATTRIBI3UIVPROC VertexAttribI3uiv;\n    PFNVERTEXATTRIBI4UIVPROC VertexAttribI4uiv;\n    PFNVERTEXATTRIBI4BVPROC VertexAttribI4bv;\n    PFNVERTEXATTRIBI4SVPROC VertexAttribI4sv;\n    PFNVERTEXATTRIBI4UBVPROC VertexAttribI4ubv;\n    PFNVERTEXATTRIBI4USVPROC VertexAttribI4usv;\n    PFNGETUNIFORMUIVPROC GetUniformuiv;\n    PFNBINDFRAGDATALOCATIONPROC BindFragDataLocation;\n    PFNGETFRAGDATALOCATIONPROC GetFragDataLocation;\n    PFNUNIFORM1UIPROC Uniform1ui;\n    PFNUNIFORM2UIPROC Uniform2ui;\n    PFNUNIFORM3UIPROC Uniform3ui;\n    PFNUNIFORM4UIPROC Uniform4ui;\n    PFNUNIFORM1UIVPROC Uniform1uiv;\n    PFNUNIFORM2UIVPROC Uniform2uiv;\n    PFNUNIFORM3UIVPROC Uniform3uiv;\n    PFNUNIFORM4UIVPROC Uniform4uiv;\n    PFNTEXPARAMETERIIVPROC TexParameterIiv;\n    PFNTEXPARAMETERIUIVPROC TexParameterIuiv;\n    PFNGETTEXPARAMETERIIVPROC GetTexParameterIiv;\n    PFNGETTEXPARAMETERIUIVPROC GetTexParameterIuiv;\n    PFNCLEARBUFFERIVPROC ClearBufferiv;\n    PFNCLEARBUFFERUIVPROC ClearBufferuiv;\n    PFNCLEARBUFFERFVPROC ClearBufferfv;\n    PFNCLEARBUFFERFIPROC ClearBufferfi;\n    PFNGETSTRINGIPROC GetStringi;\n\n    // Extension: ARB_uniform_buffer_object\n    PFNGETUNIFORMINDICESPROC GetUniformIndices;\n    PFNGETACTIVEUNIFORMSIVPROC GetActiveUniformsiv;\n    PFNGETACTIVEUNIFORMNAMEPROC GetActiveUniformName;\n    PFNGETUNIFORMBLOCKINDEXPROC GetUniformBlockIndex;\n    PFNGETACTIVEUNIFORMBLOCKIVPROC GetActiveUniformBlockiv;\n    PFNGETACTIVEUNIFORMBLOCKNAMEPROC GetActiveUniformBlockName;\n    PFNUNIFORMBLOCKBINDINGPROC UniformBlockBinding;\n\n    // Extension: ARB_copy_buffer\n    PFNCOPYBUFFERSUBDATAPROC CopyBufferSubData;\n\n    // Extension: 3.1\n    PFNDRAWARRAYSINSTANCEDPROC DrawArraysInstanced;\n    PFNDRAWELEMENTSINSTANCEDPROC DrawElementsInstanced;\n    PFNTEXBUFFERPROC TexBuffer;\n    PFNPRIMITIVERESTARTINDEXPROC PrimitiveRestartIndex;\n\n    // Legacy\n    PFNENABLECLIENTSTATEPROC EnableClientState;\n    PFNDISABLECLIENTSTATEPROC DisableClientState;\n    PFNVERTEXPOINTERPROC VertexPointer;\n    PFNNORMALPOINTERPROC NormalPointer;\n    PFNCOLORPOINTERPROC ColorPointer;\n    PFNTEXCOORDPOINTERPROC TexCoordPointer;\n\n    PFNTEXENVIPROC TexEnvi;\n\n    PFNMATRIXMODEPROC MatrixMode;\n    PFNLOADIDENTITYPROC LoadIdentity;\n    PFNORTHOPROC Ortho;\n\n    PFNCOLOR3DPROC Color3d;\n\n    //////////////////////////////////////////////\n    // Switch functions\n\n    // Extension: 1.1\n\n    static void CODEGEN_FUNCPTR Switch_CullFace(GLenum mode)\n    {\n        CullFace = (PFNCULLFACEPROC)IntGetProcAddress(\"glCullFace\");\n        CullFace(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FrontFace(GLenum mode)\n    {\n        FrontFace = (PFNFRONTFACEPROC)IntGetProcAddress(\"glFrontFace\");\n        FrontFace(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Hint(GLenum target, GLenum mode)\n    {\n        Hint = (PFNHINTPROC)IntGetProcAddress(\"glHint\");\n        Hint(target, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LineWidth(GLfloat width)\n    {\n        LineWidth = (PFNLINEWIDTHPROC)IntGetProcAddress(\"glLineWidth\");\n        LineWidth(width);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointSize(GLfloat size)\n    {\n        PointSize = (PFNPOINTSIZEPROC)IntGetProcAddress(\"glPointSize\");\n        PointSize(size);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PolygonMode(GLenum face, GLenum mode)\n    {\n        PolygonMode = (PFNPOLYGONMODEPROC)IntGetProcAddress(\"glPolygonMode\");\n        PolygonMode(face, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Scissor(GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        Scissor = (PFNSCISSORPROC)IntGetProcAddress(\"glScissor\");\n        Scissor(x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterf(GLenum target, GLenum pname, GLfloat param)\n    {\n        TexParameterf = (PFNTEXPARAMETERFPROC)IntGetProcAddress(\"glTexParameterf\");\n        TexParameterf(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)\n    {\n        TexParameterfv = (PFNTEXPARAMETERFVPROC)IntGetProcAddress(\"glTexParameterfv\");\n        TexParameterfv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameteri(GLenum target, GLenum pname, GLint param)\n    {\n        TexParameteri = (PFNTEXPARAMETERIPROC)IntGetProcAddress(\"glTexParameteri\");\n        TexParameteri(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameteriv(GLenum target, GLenum pname, const GLint *params)\n    {\n        TexParameteriv = (PFNTEXPARAMETERIVPROC)IntGetProcAddress(\"glTexParameteriv\");\n        TexParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexImage1D = (PFNTEXIMAGE1DPROC)IntGetProcAddress(\"glTexImage1D\");\n        TexImage1D(target, level, internalformat, width, border, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexImage2D = (PFNTEXIMAGE2DPROC)IntGetProcAddress(\"glTexImage2D\");\n        TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawBuffer(GLenum mode)\n    {\n        DrawBuffer = (PFNDRAWBUFFERPROC)IntGetProcAddress(\"glDrawBuffer\");\n        DrawBuffer(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Clear(GLbitfield mask)\n    {\n        Clear = (PFNCLEARPROC)IntGetProcAddress(\"glClear\");\n        Clear(mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)\n    {\n        ClearColor = (PFNCLEARCOLORPROC)IntGetProcAddress(\"glClearColor\");\n        ClearColor(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearStencil(GLint s)\n    {\n        ClearStencil = (PFNCLEARSTENCILPROC)IntGetProcAddress(\"glClearStencil\");\n        ClearStencil(s);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearDepth(GLdouble depth)\n    {\n        ClearDepth = (PFNCLEARDEPTHPROC)IntGetProcAddress(\"glClearDepth\");\n        ClearDepth(depth);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilMask(GLuint mask)\n    {\n        StencilMask = (PFNSTENCILMASKPROC)IntGetProcAddress(\"glStencilMask\");\n        StencilMask(mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)\n    {\n        ColorMask = (PFNCOLORMASKPROC)IntGetProcAddress(\"glColorMask\");\n        ColorMask(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthMask(GLboolean flag)\n    {\n        DepthMask = (PFNDEPTHMASKPROC)IntGetProcAddress(\"glDepthMask\");\n        DepthMask(flag);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Disable(GLenum cap)\n    {\n        Disable = (PFNDISABLEPROC)IntGetProcAddress(\"glDisable\");\n        Disable(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Enable(GLenum cap)\n    {\n        Enable = (PFNENABLEPROC)IntGetProcAddress(\"glEnable\");\n        Enable(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Finish()\n    {\n        Finish = (PFNFINISHPROC)IntGetProcAddress(\"glFinish\");\n        Finish();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Flush()\n    {\n        Flush = (PFNFLUSHPROC)IntGetProcAddress(\"glFlush\");\n        Flush();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlendFunc(GLenum sfactor, GLenum dfactor)\n    {\n        BlendFunc = (PFNBLENDFUNCPROC)IntGetProcAddress(\"glBlendFunc\");\n        BlendFunc(sfactor, dfactor);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LogicOp(GLenum opcode)\n    {\n        LogicOp = (PFNLOGICOPPROC)IntGetProcAddress(\"glLogicOp\");\n        LogicOp(opcode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilFunc(GLenum func, GLint ref, GLuint mask)\n    {\n        StencilFunc = (PFNSTENCILFUNCPROC)IntGetProcAddress(\"glStencilFunc\");\n        StencilFunc(func, ref, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilOp(GLenum fail, GLenum zfail, GLenum zpass)\n    {\n        StencilOp = (PFNSTENCILOPPROC)IntGetProcAddress(\"glStencilOp\");\n        StencilOp(fail, zfail, zpass);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthFunc(GLenum func)\n    {\n        DepthFunc = (PFNDEPTHFUNCPROC)IntGetProcAddress(\"glDepthFunc\");\n        DepthFunc(func);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PixelStoref(GLenum pname, GLfloat param)\n    {\n        PixelStoref = (PFNPIXELSTOREFPROC)IntGetProcAddress(\"glPixelStoref\");\n        PixelStoref(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PixelStorei(GLenum pname, GLint param)\n    {\n        PixelStorei = (PFNPIXELSTOREIPROC)IntGetProcAddress(\"glPixelStorei\");\n        PixelStorei(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ReadBuffer(GLenum mode)\n    {\n        ReadBuffer = (PFNREADBUFFERPROC)IntGetProcAddress(\"glReadBuffer\");\n        ReadBuffer(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)\n    {\n        ReadPixels = (PFNREADPIXELSPROC)IntGetProcAddress(\"glReadPixels\");\n        ReadPixels(x, y, width, height, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBooleanv(GLenum pname, GLboolean *params)\n    {\n        GetBooleanv = (PFNGETBOOLEANVPROC)IntGetProcAddress(\"glGetBooleanv\");\n        GetBooleanv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetDoublev(GLenum pname, GLdouble *params)\n    {\n        GetDoublev = (PFNGETDOUBLEVPROC)IntGetProcAddress(\"glGetDoublev\");\n        GetDoublev(pname, params);\n    }\n\n    static GLenum CODEGEN_FUNCPTR Switch_GetError()\n    {\n        GetError = (PFNGETERRORPROC)IntGetProcAddress(\"glGetError\");\n        return GetError();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetFloatv(GLenum pname, GLfloat *params)\n    {\n        GetFloatv = (PFNGETFLOATVPROC)IntGetProcAddress(\"glGetFloatv\");\n        GetFloatv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetIntegerv(GLenum pname, GLint *params)\n    {\n        GetIntegerv = (PFNGETINTEGERVPROC)IntGetProcAddress(\"glGetIntegerv\");\n        GetIntegerv(pname, params);\n    }\n\n    static const GLubyte * CODEGEN_FUNCPTR Switch_GetString(GLenum name)\n    {\n        GetString = (PFNGETSTRINGPROC)IntGetProcAddress(\"glGetString\");\n        return GetString(name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)\n    {\n        GetTexImage = (PFNGETTEXIMAGEPROC)IntGetProcAddress(\"glGetTexImage\");\n        GetTexImage(target, level, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)\n    {\n        GetTexParameterfv = (PFNGETTEXPARAMETERFVPROC)IntGetProcAddress(\"glGetTexParameterfv\");\n        GetTexParameterfv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetTexParameteriv = (PFNGETTEXPARAMETERIVPROC)IntGetProcAddress(\"glGetTexParameteriv\");\n        GetTexParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)\n    {\n        GetTexLevelParameterfv = (PFNGETTEXLEVELPARAMETERFVPROC)IntGetProcAddress(\"glGetTexLevelParameterfv\");\n        GetTexLevelParameterfv(target, level, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)\n    {\n        GetTexLevelParameteriv = (PFNGETTEXLEVELPARAMETERIVPROC)IntGetProcAddress(\"glGetTexLevelParameteriv\");\n        GetTexLevelParameteriv(target, level, pname, params);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsEnabled(GLenum cap)\n    {\n        IsEnabled = (PFNISENABLEDPROC)IntGetProcAddress(\"glIsEnabled\");\n        return IsEnabled(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DepthRange(GLdouble ren_near, GLdouble ren_far)\n    {\n        DepthRange = (PFNDEPTHRANGEPROC)IntGetProcAddress(\"glDepthRange\");\n        DepthRange(ren_near, ren_far);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Viewport(GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        Viewport = (PFNVIEWPORTPROC)IntGetProcAddress(\"glViewport\");\n        Viewport(x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawArrays(GLenum mode, GLint first, GLsizei count)\n    {\n        DrawArrays = (PFNDRAWARRAYSPROC)IntGetProcAddress(\"glDrawArrays\");\n        DrawArrays(mode, first, count);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)\n    {\n        DrawElements = (PFNDRAWELEMENTSPROC)IntGetProcAddress(\"glDrawElements\");\n        DrawElements(mode, count, type, indices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetPointerv(GLenum pname, GLvoid* *params)\n    {\n        GetPointerv = (PFNGETPOINTERVPROC)IntGetProcAddress(\"glGetPointerv\");\n        GetPointerv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PolygonOffset(GLfloat factor, GLfloat units)\n    {\n        PolygonOffset = (PFNPOLYGONOFFSETPROC)IntGetProcAddress(\"glPolygonOffset\");\n        PolygonOffset(factor, units);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)\n    {\n        CopyTexImage1D = (PFNCOPYTEXIMAGE1DPROC)IntGetProcAddress(\"glCopyTexImage1D\");\n        CopyTexImage1D(target, level, internalformat, x, y, width, border);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)\n    {\n        CopyTexImage2D = (PFNCOPYTEXIMAGE2DPROC)IntGetProcAddress(\"glCopyTexImage2D\");\n        CopyTexImage2D(target, level, internalformat, x, y, width, height, border);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)\n    {\n        CopyTexSubImage1D = (PFNCOPYTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glCopyTexSubImage1D\");\n        CopyTexSubImage1D(target, level, xoffset, x, y, width);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        CopyTexSubImage2D = (PFNCOPYTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glCopyTexSubImage2D\");\n        CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage1D = (PFNTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glTexSubImage1D\");\n        TexSubImage1D(target, level, xoffset, width, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage2D = (PFNTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glTexSubImage2D\");\n        TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindTexture(GLenum target, GLuint texture)\n    {\n        BindTexture = (PFNBINDTEXTUREPROC)IntGetProcAddress(\"glBindTexture\");\n        BindTexture(target, texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteTextures(GLsizei n, const GLuint *textures)\n    {\n        DeleteTextures = (PFNDELETETEXTURESPROC)IntGetProcAddress(\"glDeleteTextures\");\n        DeleteTextures(n, textures);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenTextures(GLsizei n, GLuint *textures)\n    {\n        GenTextures = (PFNGENTEXTURESPROC)IntGetProcAddress(\"glGenTextures\");\n        GenTextures(n, textures);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsTexture(GLuint texture)\n    {\n        IsTexture = (PFNISTEXTUREPROC)IntGetProcAddress(\"glIsTexture\");\n        return IsTexture(texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Indexub(GLubyte c)\n    {\n        Indexub = (PFNINDEXUBPROC)IntGetProcAddress(\"glIndexub\");\n        Indexub(c);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Indexubv(const GLubyte *c)\n    {\n        Indexubv = (PFNINDEXUBVPROC)IntGetProcAddress(\"glIndexubv\");\n        Indexubv(c);\n    }\n\n    // Extension: 1.2\n\n    static void CODEGEN_FUNCPTR Switch_BlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)\n    {\n        BlendColor = (PFNBLENDCOLORPROC)IntGetProcAddress(\"glBlendColor\");\n        BlendColor(red, green, blue, alpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlendEquation(GLenum mode)\n    {\n        BlendEquation = (PFNBLENDEQUATIONPROC)IntGetProcAddress(\"glBlendEquation\");\n        BlendEquation(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)\n    {\n        DrawRangeElements = (PFNDRAWRANGEELEMENTSPROC)IntGetProcAddress(\"glDrawRangeElements\");\n        DrawRangeElements(mode, start, end, count, type, indices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)\n    {\n        TexSubImage3D = (PFNTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glTexSubImage3D\");\n        TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)\n    {\n        CopyTexSubImage3D = (PFNCOPYTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glCopyTexSubImage3D\");\n        CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);\n    }\n\n    // Extension: 1.3\n\n    static void CODEGEN_FUNCPTR Switch_ActiveTexture(GLenum texture)\n    {\n        ActiveTexture = (PFNACTIVETEXTUREPROC)IntGetProcAddress(\"glActiveTexture\");\n        ActiveTexture(texture);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_SampleCoverage(GLfloat value, GLboolean invert)\n    {\n        SampleCoverage = (PFNSAMPLECOVERAGEPROC)IntGetProcAddress(\"glSampleCoverage\");\n        SampleCoverage(value, invert);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage3D = (PFNCOMPRESSEDTEXIMAGE3DPROC)IntGetProcAddress(\"glCompressedTexImage3D\");\n        CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage2D = (PFNCOMPRESSEDTEXIMAGE2DPROC)IntGetProcAddress(\"glCompressedTexImage2D\");\n        CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexImage1D = (PFNCOMPRESSEDTEXIMAGE1DPROC)IntGetProcAddress(\"glCompressedTexImage1D\");\n        CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage3D = (PFNCOMPRESSEDTEXSUBIMAGE3DPROC)IntGetProcAddress(\"glCompressedTexSubImage3D\");\n        CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage2D = (PFNCOMPRESSEDTEXSUBIMAGE2DPROC)IntGetProcAddress(\"glCompressedTexSubImage2D\");\n        CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)\n    {\n        CompressedTexSubImage1D = (PFNCOMPRESSEDTEXSUBIMAGE1DPROC)IntGetProcAddress(\"glCompressedTexSubImage1D\");\n        CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetCompressedTexImage(GLenum target, GLint level, GLvoid *img)\n    {\n        GetCompressedTexImage = (PFNGETCOMPRESSEDTEXIMAGEPROC)IntGetProcAddress(\"glGetCompressedTexImage\");\n        GetCompressedTexImage(target, level, img);\n    }\n\n    // Extension: 1.4\n\n    static void CODEGEN_FUNCPTR Switch_BlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)\n    {\n        BlendFuncSeparate = (PFNBLENDFUNCSEPARATEPROC)IntGetProcAddress(\"glBlendFuncSeparate\");\n        BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount)\n    {\n        MultiDrawArrays = (PFNMULTIDRAWARRAYSPROC)IntGetProcAddress(\"glMultiDrawArrays\");\n        MultiDrawArrays(mode, first, count, drawcount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount)\n    {\n        MultiDrawElements = (PFNMULTIDRAWELEMENTSPROC)IntGetProcAddress(\"glMultiDrawElements\");\n        MultiDrawElements(mode, count, type, indices, drawcount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameterf(GLenum pname, GLfloat param)\n    {\n        PointParameterf = (PFNPOINTPARAMETERFPROC)IntGetProcAddress(\"glPointParameterf\");\n        PointParameterf(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameterfv(GLenum pname, const GLfloat *params)\n    {\n        PointParameterfv = (PFNPOINTPARAMETERFVPROC)IntGetProcAddress(\"glPointParameterfv\");\n        PointParameterfv(pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameteri(GLenum pname, GLint param)\n    {\n        PointParameteri = (PFNPOINTPARAMETERIPROC)IntGetProcAddress(\"glPointParameteri\");\n        PointParameteri(pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PointParameteriv(GLenum pname, const GLint *params)\n    {\n        PointParameteriv = (PFNPOINTPARAMETERIVPROC)IntGetProcAddress(\"glPointParameteriv\");\n        PointParameteriv(pname, params);\n    }\n\n    // Extension: 1.5\n\n    static void CODEGEN_FUNCPTR Switch_GenQueries(GLsizei n, GLuint *ids)\n    {\n        GenQueries = (PFNGENQUERIESPROC)IntGetProcAddress(\"glGenQueries\");\n        GenQueries(n, ids);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteQueries(GLsizei n, const GLuint *ids)\n    {\n        DeleteQueries = (PFNDELETEQUERIESPROC)IntGetProcAddress(\"glDeleteQueries\");\n        DeleteQueries(n, ids);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsQuery(GLuint id)\n    {\n        IsQuery = (PFNISQUERYPROC)IntGetProcAddress(\"glIsQuery\");\n        return IsQuery(id);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginQuery(GLenum target, GLuint id)\n    {\n        BeginQuery = (PFNBEGINQUERYPROC)IntGetProcAddress(\"glBeginQuery\");\n        BeginQuery(target, id);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndQuery(GLenum target)\n    {\n        EndQuery = (PFNENDQUERYPROC)IntGetProcAddress(\"glEndQuery\");\n        EndQuery(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryiv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetQueryiv = (PFNGETQUERYIVPROC)IntGetProcAddress(\"glGetQueryiv\");\n        GetQueryiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryObjectiv(GLuint id, GLenum pname, GLint *params)\n    {\n        GetQueryObjectiv = (PFNGETQUERYOBJECTIVPROC)IntGetProcAddress(\"glGetQueryObjectiv\");\n        GetQueryObjectiv(id, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)\n    {\n        GetQueryObjectuiv = (PFNGETQUERYOBJECTUIVPROC)IntGetProcAddress(\"glGetQueryObjectuiv\");\n        GetQueryObjectuiv(id, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBuffer(GLenum target, GLuint buffer)\n    {\n        BindBuffer = (PFNBINDBUFFERPROC)IntGetProcAddress(\"glBindBuffer\");\n        BindBuffer(target, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteBuffers(GLsizei n, const GLuint *buffers)\n    {\n        DeleteBuffers = (PFNDELETEBUFFERSPROC)IntGetProcAddress(\"glDeleteBuffers\");\n        DeleteBuffers(n, buffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenBuffers(GLsizei n, GLuint *buffers)\n    {\n        GenBuffers = (PFNGENBUFFERSPROC)IntGetProcAddress(\"glGenBuffers\");\n        GenBuffers(n, buffers);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsBuffer(GLuint buffer)\n    {\n        IsBuffer = (PFNISBUFFERPROC)IntGetProcAddress(\"glIsBuffer\");\n        return IsBuffer(buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)\n    {\n        BufferData = (PFNBUFFERDATAPROC)IntGetProcAddress(\"glBufferData\");\n        BufferData(target, size, data, usage);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)\n    {\n        BufferSubData = (PFNBUFFERSUBDATAPROC)IntGetProcAddress(\"glBufferSubData\");\n        BufferSubData(target, offset, size, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)\n    {\n        GetBufferSubData = (PFNGETBUFFERSUBDATAPROC)IntGetProcAddress(\"glGetBufferSubData\");\n        GetBufferSubData(target, offset, size, data);\n    }\n\n    static GLvoid* CODEGEN_FUNCPTR Switch_MapBuffer(GLenum target, GLenum access)\n    {\n        MapBuffer = (PFNMAPBUFFERPROC)IntGetProcAddress(\"glMapBuffer\");\n        return MapBuffer(target, access);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_UnmapBuffer(GLenum target)\n    {\n        UnmapBuffer = (PFNUNMAPBUFFERPROC)IntGetProcAddress(\"glUnmapBuffer\");\n        return UnmapBuffer(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetBufferParameteriv = (PFNGETBUFFERPARAMETERIVPROC)IntGetProcAddress(\"glGetBufferParameteriv\");\n        GetBufferParameteriv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBufferPointerv(GLenum target, GLenum pname, GLvoid* *params)\n    {\n        GetBufferPointerv = (PFNGETBUFFERPOINTERVPROC)IntGetProcAddress(\"glGetBufferPointerv\");\n        GetBufferPointerv(target, pname, params);\n    }\n\n    // Extension: 2.0\n\n    static void CODEGEN_FUNCPTR Switch_BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)\n    {\n        BlendEquationSeparate = (PFNBLENDEQUATIONSEPARATEPROC)IntGetProcAddress(\"glBlendEquationSeparate\");\n        BlendEquationSeparate(modeRGB, modeAlpha);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawBuffers(GLsizei n, const GLenum *bufs)\n    {\n        DrawBuffers = (PFNDRAWBUFFERSPROC)IntGetProcAddress(\"glDrawBuffers\");\n        DrawBuffers(n, bufs);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)\n    {\n        StencilOpSeparate = (PFNSTENCILOPSEPARATEPROC)IntGetProcAddress(\"glStencilOpSeparate\");\n        StencilOpSeparate(face, sfail, dpfail, dppass);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)\n    {\n        StencilFuncSeparate = (PFNSTENCILFUNCSEPARATEPROC)IntGetProcAddress(\"glStencilFuncSeparate\");\n        StencilFuncSeparate(face, func, ref, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_StencilMaskSeparate(GLenum face, GLuint mask)\n    {\n        StencilMaskSeparate = (PFNSTENCILMASKSEPARATEPROC)IntGetProcAddress(\"glStencilMaskSeparate\");\n        StencilMaskSeparate(face, mask);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_AttachShader(GLuint program, GLuint shader)\n    {\n        AttachShader = (PFNATTACHSHADERPROC)IntGetProcAddress(\"glAttachShader\");\n        AttachShader(program, shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindAttribLocation(GLuint program, GLuint index, const GLchar *name)\n    {\n        BindAttribLocation = (PFNBINDATTRIBLOCATIONPROC)IntGetProcAddress(\"glBindAttribLocation\");\n        BindAttribLocation(program, index, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_CompileShader(GLuint shader)\n    {\n        CompileShader = (PFNCOMPILESHADERPROC)IntGetProcAddress(\"glCompileShader\");\n        CompileShader(shader);\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_CreateProgram()\n    {\n        CreateProgram = (PFNCREATEPROGRAMPROC)IntGetProcAddress(\"glCreateProgram\");\n        return CreateProgram();\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_CreateShader(GLenum type)\n    {\n        CreateShader = (PFNCREATESHADERPROC)IntGetProcAddress(\"glCreateShader\");\n        return CreateShader(type);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteProgram(GLuint program)\n    {\n        DeleteProgram = (PFNDELETEPROGRAMPROC)IntGetProcAddress(\"glDeleteProgram\");\n        DeleteProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteShader(GLuint shader)\n    {\n        DeleteShader = (PFNDELETESHADERPROC)IntGetProcAddress(\"glDeleteShader\");\n        DeleteShader(shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DetachShader(GLuint program, GLuint shader)\n    {\n        DetachShader = (PFNDETACHSHADERPROC)IntGetProcAddress(\"glDetachShader\");\n        DetachShader(program, shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DisableVertexAttribArray(GLuint index)\n    {\n        DisableVertexAttribArray = (PFNDISABLEVERTEXATTRIBARRAYPROC)IntGetProcAddress(\"glDisableVertexAttribArray\");\n        DisableVertexAttribArray(index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EnableVertexAttribArray(GLuint index)\n    {\n        EnableVertexAttribArray = (PFNENABLEVERTEXATTRIBARRAYPROC)IntGetProcAddress(\"glEnableVertexAttribArray\");\n        EnableVertexAttribArray(index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)\n    {\n        GetActiveAttrib = (PFNGETACTIVEATTRIBPROC)IntGetProcAddress(\"glGetActiveAttrib\");\n        GetActiveAttrib(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)\n    {\n        GetActiveUniform = (PFNGETACTIVEUNIFORMPROC)IntGetProcAddress(\"glGetActiveUniform\");\n        GetActiveUniform(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj)\n    {\n        GetAttachedShaders = (PFNGETATTACHEDSHADERSPROC)IntGetProcAddress(\"glGetAttachedShaders\");\n        GetAttachedShaders(program, maxCount, count, obj);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetAttribLocation(GLuint program, const GLchar *name)\n    {\n        GetAttribLocation = (PFNGETATTRIBLOCATIONPROC)IntGetProcAddress(\"glGetAttribLocation\");\n        return GetAttribLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetProgramiv(GLuint program, GLenum pname, GLint *params)\n    {\n        GetProgramiv = (PFNGETPROGRAMIVPROC)IntGetProcAddress(\"glGetProgramiv\");\n        GetProgramiv(program, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)\n    {\n        GetProgramInfoLog = (PFNGETPROGRAMINFOLOGPROC)IntGetProcAddress(\"glGetProgramInfoLog\");\n        GetProgramInfoLog(program, bufSize, length, infoLog);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderiv(GLuint shader, GLenum pname, GLint *params)\n    {\n        GetShaderiv = (PFNGETSHADERIVPROC)IntGetProcAddress(\"glGetShaderiv\");\n        GetShaderiv(shader, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)\n    {\n        GetShaderInfoLog = (PFNGETSHADERINFOLOGPROC)IntGetProcAddress(\"glGetShaderInfoLog\");\n        GetShaderInfoLog(shader, bufSize, length, infoLog);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)\n    {\n        GetShaderSource = (PFNGETSHADERSOURCEPROC)IntGetProcAddress(\"glGetShaderSource\");\n        GetShaderSource(shader, bufSize, length, source);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetUniformLocation(GLuint program, const GLchar *name)\n    {\n        GetUniformLocation = (PFNGETUNIFORMLOCATIONPROC)IntGetProcAddress(\"glGetUniformLocation\");\n        return GetUniformLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformfv(GLuint program, GLint location, GLfloat *params)\n    {\n        GetUniformfv = (PFNGETUNIFORMFVPROC)IntGetProcAddress(\"glGetUniformfv\");\n        GetUniformfv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformiv(GLuint program, GLint location, GLint *params)\n    {\n        GetUniformiv = (PFNGETUNIFORMIVPROC)IntGetProcAddress(\"glGetUniformiv\");\n        GetUniformiv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)\n    {\n        GetVertexAttribdv = (PFNGETVERTEXATTRIBDVPROC)IntGetProcAddress(\"glGetVertexAttribdv\");\n        GetVertexAttribdv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)\n    {\n        GetVertexAttribfv = (PFNGETVERTEXATTRIBFVPROC)IntGetProcAddress(\"glGetVertexAttribfv\");\n        GetVertexAttribfv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)\n    {\n        GetVertexAttribiv = (PFNGETVERTEXATTRIBIVPROC)IntGetProcAddress(\"glGetVertexAttribiv\");\n        GetVertexAttribiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid* *pointer)\n    {\n        GetVertexAttribPointerv = (PFNGETVERTEXATTRIBPOINTERVPROC)IntGetProcAddress(\"glGetVertexAttribPointerv\");\n        GetVertexAttribPointerv(index, pname, pointer);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsProgram(GLuint program)\n    {\n        IsProgram = (PFNISPROGRAMPROC)IntGetProcAddress(\"glIsProgram\");\n        return IsProgram(program);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsShader(GLuint shader)\n    {\n        IsShader = (PFNISSHADERPROC)IntGetProcAddress(\"glIsShader\");\n        return IsShader(shader);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LinkProgram(GLuint program)\n    {\n        LinkProgram = (PFNLINKPROGRAMPROC)IntGetProcAddress(\"glLinkProgram\");\n        LinkProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ShaderSource(GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length)\n    {\n        ShaderSource = (PFNSHADERSOURCEPROC)IntGetProcAddress(\"glShaderSource\");\n        ShaderSource(shader, count, string, length);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UseProgram(GLuint program)\n    {\n        UseProgram = (PFNUSEPROGRAMPROC)IntGetProcAddress(\"glUseProgram\");\n        UseProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1f(GLint location, GLfloat v0)\n    {\n        Uniform1f = (PFNUNIFORM1FPROC)IntGetProcAddress(\"glUniform1f\");\n        Uniform1f(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2f(GLint location, GLfloat v0, GLfloat v1)\n    {\n        Uniform2f = (PFNUNIFORM2FPROC)IntGetProcAddress(\"glUniform2f\");\n        Uniform2f(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)\n    {\n        Uniform3f = (PFNUNIFORM3FPROC)IntGetProcAddress(\"glUniform3f\");\n        Uniform3f(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)\n    {\n        Uniform4f = (PFNUNIFORM4FPROC)IntGetProcAddress(\"glUniform4f\");\n        Uniform4f(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1i(GLint location, GLint v0)\n    {\n        Uniform1i = (PFNUNIFORM1IPROC)IntGetProcAddress(\"glUniform1i\");\n        Uniform1i(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2i(GLint location, GLint v0, GLint v1)\n    {\n        Uniform2i = (PFNUNIFORM2IPROC)IntGetProcAddress(\"glUniform2i\");\n        Uniform2i(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)\n    {\n        Uniform3i = (PFNUNIFORM3IPROC)IntGetProcAddress(\"glUniform3i\");\n        Uniform3i(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)\n    {\n        Uniform4i = (PFNUNIFORM4IPROC)IntGetProcAddress(\"glUniform4i\");\n        Uniform4i(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform1fv = (PFNUNIFORM1FVPROC)IntGetProcAddress(\"glUniform1fv\");\n        Uniform1fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform2fv = (PFNUNIFORM2FVPROC)IntGetProcAddress(\"glUniform2fv\");\n        Uniform2fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform3fv = (PFNUNIFORM3FVPROC)IntGetProcAddress(\"glUniform3fv\");\n        Uniform3fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4fv(GLint location, GLsizei count, const GLfloat *value)\n    {\n        Uniform4fv = (PFNUNIFORM4FVPROC)IntGetProcAddress(\"glUniform4fv\");\n        Uniform4fv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform1iv = (PFNUNIFORM1IVPROC)IntGetProcAddress(\"glUniform1iv\");\n        Uniform1iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform2iv = (PFNUNIFORM2IVPROC)IntGetProcAddress(\"glUniform2iv\");\n        Uniform2iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform3iv = (PFNUNIFORM3IVPROC)IntGetProcAddress(\"glUniform3iv\");\n        Uniform3iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4iv(GLint location, GLsizei count, const GLint *value)\n    {\n        Uniform4iv = (PFNUNIFORM4IVPROC)IntGetProcAddress(\"glUniform4iv\");\n        Uniform4iv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2fv = (PFNUNIFORMMATRIX2FVPROC)IntGetProcAddress(\"glUniformMatrix2fv\");\n        UniformMatrix2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3fv = (PFNUNIFORMMATRIX3FVPROC)IntGetProcAddress(\"glUniformMatrix3fv\");\n        UniformMatrix3fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4fv = (PFNUNIFORMMATRIX4FVPROC)IntGetProcAddress(\"glUniformMatrix4fv\");\n        UniformMatrix4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ValidateProgram(GLuint program)\n    {\n        ValidateProgram = (PFNVALIDATEPROGRAMPROC)IntGetProcAddress(\"glValidateProgram\");\n        ValidateProgram(program);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)\n    {\n        VertexAttribPointer = (PFNVERTEXATTRIBPOINTERPROC)IntGetProcAddress(\"glVertexAttribPointer\");\n        VertexAttribPointer(index, size, type, normalized, stride, pointer);\n    }\n\n    // Extension: 2.1\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2x3fv = (PFNUNIFORMMATRIX2X3FVPROC)IntGetProcAddress(\"glUniformMatrix2x3fv\");\n        UniformMatrix2x3fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3x2fv = (PFNUNIFORMMATRIX3X2FVPROC)IntGetProcAddress(\"glUniformMatrix3x2fv\");\n        UniformMatrix3x2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix2x4fv = (PFNUNIFORMMATRIX2X4FVPROC)IntGetProcAddress(\"glUniformMatrix2x4fv\");\n        UniformMatrix2x4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4x2fv = (PFNUNIFORMMATRIX4X2FVPROC)IntGetProcAddress(\"glUniformMatrix4x2fv\");\n        UniformMatrix4x2fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix3x4fv = (PFNUNIFORMMATRIX3X4FVPROC)IntGetProcAddress(\"glUniformMatrix3x4fv\");\n        UniformMatrix3x4fv(location, count, transpose, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)\n    {\n        UniformMatrix4x3fv = (PFNUNIFORMMATRIX4X3FVPROC)IntGetProcAddress(\"glUniformMatrix4x3fv\");\n        UniformMatrix4x3fv(location, count, transpose, value);\n    }\n\n    // Extension: ARB_vertex_array_object\n\n    static void CODEGEN_FUNCPTR Switch_BindVertexArray(GLuint ren_array)\n    {\n        BindVertexArray = (PFNBINDVERTEXARRAYPROC)IntGetProcAddress(\"glBindVertexArray\");\n        BindVertexArray(ren_array);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteVertexArrays(GLsizei n, const GLuint *arrays)\n    {\n        DeleteVertexArrays = (PFNDELETEVERTEXARRAYSPROC)IntGetProcAddress(\"glDeleteVertexArrays\");\n        DeleteVertexArrays(n, arrays);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenVertexArrays(GLsizei n, GLuint *arrays)\n    {\n        GenVertexArrays = (PFNGENVERTEXARRAYSPROC)IntGetProcAddress(\"glGenVertexArrays\");\n        GenVertexArrays(n, arrays);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsVertexArray(GLuint ren_array)\n    {\n        IsVertexArray = (PFNISVERTEXARRAYPROC)IntGetProcAddress(\"glIsVertexArray\");\n        return IsVertexArray(ren_array);\n    }\n\n    // Extension: ARB_map_buffer_range\n\n    static GLvoid* CODEGEN_FUNCPTR Switch_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)\n    {\n        MapBufferRange = (PFNMAPBUFFERRANGEPROC)IntGetProcAddress(\"glMapBufferRange\");\n        return MapBufferRange(target, offset, length, access);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)\n    {\n        FlushMappedBufferRange = (PFNFLUSHMAPPEDBUFFERRANGEPROC)IntGetProcAddress(\"glFlushMappedBufferRange\");\n        FlushMappedBufferRange(target, offset, length);\n    }\n\n    // Extension: ARB_framebuffer_object\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsRenderbuffer(GLuint renderbuffer)\n    {\n        IsRenderbuffer = (PFNISRENDERBUFFERPROC)IntGetProcAddress(\"glIsRenderbuffer\");\n        return IsRenderbuffer(renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindRenderbuffer(GLenum target, GLuint renderbuffer)\n    {\n        BindRenderbuffer = (PFNBINDRENDERBUFFERPROC)IntGetProcAddress(\"glBindRenderbuffer\");\n        BindRenderbuffer(target, renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)\n    {\n        DeleteRenderbuffers = (PFNDELETERENDERBUFFERSPROC)IntGetProcAddress(\"glDeleteRenderbuffers\");\n        DeleteRenderbuffers(n, renderbuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenRenderbuffers(GLsizei n, GLuint *renderbuffers)\n    {\n        GenRenderbuffers = (PFNGENRENDERBUFFERSPROC)IntGetProcAddress(\"glGenRenderbuffers\");\n        GenRenderbuffers(n, renderbuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)\n    {\n        RenderbufferStorage = (PFNRENDERBUFFERSTORAGEPROC)IntGetProcAddress(\"glRenderbufferStorage\");\n        RenderbufferStorage(target, internalformat, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetRenderbufferParameteriv = (PFNGETRENDERBUFFERPARAMETERIVPROC)IntGetProcAddress(\"glGetRenderbufferParameteriv\");\n        GetRenderbufferParameteriv(target, pname, params);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsFramebuffer(GLuint framebuffer)\n    {\n        IsFramebuffer = (PFNISFRAMEBUFFERPROC)IntGetProcAddress(\"glIsFramebuffer\");\n        return IsFramebuffer(framebuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindFramebuffer(GLenum target, GLuint framebuffer)\n    {\n        BindFramebuffer = (PFNBINDFRAMEBUFFERPROC)IntGetProcAddress(\"glBindFramebuffer\");\n        BindFramebuffer(target, framebuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)\n    {\n        DeleteFramebuffers = (PFNDELETEFRAMEBUFFERSPROC)IntGetProcAddress(\"glDeleteFramebuffers\");\n        DeleteFramebuffers(n, framebuffers);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenFramebuffers(GLsizei n, GLuint *framebuffers)\n    {\n        GenFramebuffers = (PFNGENFRAMEBUFFERSPROC)IntGetProcAddress(\"glGenFramebuffers\");\n        GenFramebuffers(n, framebuffers);\n    }\n\n    static GLenum CODEGEN_FUNCPTR Switch_CheckFramebufferStatus(GLenum target)\n    {\n        CheckFramebufferStatus = (PFNCHECKFRAMEBUFFERSTATUSPROC)IntGetProcAddress(\"glCheckFramebufferStatus\");\n        return CheckFramebufferStatus(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)\n    {\n        FramebufferTexture1D = (PFNFRAMEBUFFERTEXTURE1DPROC)IntGetProcAddress(\"glFramebufferTexture1D\");\n        FramebufferTexture1D(target, attachment, textarget, texture, level);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)\n    {\n        FramebufferTexture2D = (PFNFRAMEBUFFERTEXTURE2DPROC)IntGetProcAddress(\"glFramebufferTexture2D\");\n        FramebufferTexture2D(target, attachment, textarget, texture, level);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)\n    {\n        FramebufferTexture3D = (PFNFRAMEBUFFERTEXTURE3DPROC)IntGetProcAddress(\"glFramebufferTexture3D\");\n        FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)\n    {\n        FramebufferRenderbuffer = (PFNFRAMEBUFFERRENDERBUFFERPROC)IntGetProcAddress(\"glFramebufferRenderbuffer\");\n        FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)\n    {\n        GetFramebufferAttachmentParameteriv = (PFNGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)IntGetProcAddress(\"glGetFramebufferAttachmentParameteriv\");\n        GetFramebufferAttachmentParameteriv(target, attachment, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GenerateMipmap(GLenum target)\n    {\n        GenerateMipmap = (PFNGENERATEMIPMAPPROC)IntGetProcAddress(\"glGenerateMipmap\");\n        GenerateMipmap(target);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)\n    {\n        BlitFramebuffer = (PFNBLITFRAMEBUFFERPROC)IntGetProcAddress(\"glBlitFramebuffer\");\n        BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)\n    {\n        RenderbufferStorageMultisample = (PFNRENDERBUFFERSTORAGEMULTISAMPLEPROC)IntGetProcAddress(\"glRenderbufferStorageMultisample\");\n        RenderbufferStorageMultisample(target, samples, internalformat, width, height);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)\n    {\n        FramebufferTextureLayer = (PFNFRAMEBUFFERTEXTURELAYERPROC)IntGetProcAddress(\"glFramebufferTextureLayer\");\n        FramebufferTextureLayer(target, attachment, texture, level, layer);\n    }\n\n    // Extension: 3.0\n\n    static void CODEGEN_FUNCPTR Switch_ColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)\n    {\n        ColorMaski = (PFNCOLORMASKIPROC)IntGetProcAddress(\"glColorMaski\");\n        ColorMaski(index, r, g, b, a);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetBooleani_v(GLenum target, GLuint index, GLboolean *data)\n    {\n        GetBooleani_v = (PFNGETBOOLEANI_VPROC)IntGetProcAddress(\"glGetBooleani_v\");\n        GetBooleani_v(target, index, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetIntegeri_v(GLenum target, GLuint index, GLint *data)\n    {\n        GetIntegeri_v = (PFNGETINTEGERI_VPROC)IntGetProcAddress(\"glGetIntegeri_v\");\n        GetIntegeri_v(target, index, data);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Enablei(GLenum target, GLuint index)\n    {\n        Enablei = (PFNENABLEIPROC)IntGetProcAddress(\"glEnablei\");\n        Enablei(target, index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Disablei(GLenum target, GLuint index)\n    {\n        Disablei = (PFNDISABLEIPROC)IntGetProcAddress(\"glDisablei\");\n        Disablei(target, index);\n    }\n\n    static GLboolean CODEGEN_FUNCPTR Switch_IsEnabledi(GLenum target, GLuint index)\n    {\n        IsEnabledi = (PFNISENABLEDIPROC)IntGetProcAddress(\"glIsEnabledi\");\n        return IsEnabledi(target, index);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginTransformFeedback(GLenum primitiveMode)\n    {\n        BeginTransformFeedback = (PFNBEGINTRANSFORMFEEDBACKPROC)IntGetProcAddress(\"glBeginTransformFeedback\");\n        BeginTransformFeedback(primitiveMode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndTransformFeedback()\n    {\n        EndTransformFeedback = (PFNENDTRANSFORMFEEDBACKPROC)IntGetProcAddress(\"glEndTransformFeedback\");\n        EndTransformFeedback();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)\n    {\n        BindBufferRange = (PFNBINDBUFFERRANGEPROC)IntGetProcAddress(\"glBindBufferRange\");\n        BindBufferRange(target, index, buffer, offset, size);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindBufferBase(GLenum target, GLuint index, GLuint buffer)\n    {\n        BindBufferBase = (PFNBINDBUFFERBASEPROC)IntGetProcAddress(\"glBindBufferBase\");\n        BindBufferBase(target, index, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode)\n    {\n        TransformFeedbackVaryings = (PFNTRANSFORMFEEDBACKVARYINGSPROC)IntGetProcAddress(\"glTransformFeedbackVaryings\");\n        TransformFeedbackVaryings(program, count, varyings, bufferMode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)\n    {\n        GetTransformFeedbackVarying = (PFNGETTRANSFORMFEEDBACKVARYINGPROC)IntGetProcAddress(\"glGetTransformFeedbackVarying\");\n        GetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClampColor(GLenum target, GLenum clamp)\n    {\n        ClampColor = (PFNCLAMPCOLORPROC)IntGetProcAddress(\"glClampColor\");\n        ClampColor(target, clamp);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BeginConditionalRender(GLuint id, GLenum mode)\n    {\n        BeginConditionalRender = (PFNBEGINCONDITIONALRENDERPROC)IntGetProcAddress(\"glBeginConditionalRender\");\n        BeginConditionalRender(id, mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_EndConditionalRender()\n    {\n        EndConditionalRender = (PFNENDCONDITIONALRENDERPROC)IntGetProcAddress(\"glEndConditionalRender\");\n        EndConditionalRender();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)\n    {\n        VertexAttribIPointer = (PFNVERTEXATTRIBIPOINTERPROC)IntGetProcAddress(\"glVertexAttribIPointer\");\n        VertexAttribIPointer(index, size, type, stride, pointer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)\n    {\n        GetVertexAttribIiv = (PFNGETVERTEXATTRIBIIVPROC)IntGetProcAddress(\"glGetVertexAttribIiv\");\n        GetVertexAttribIiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)\n    {\n        GetVertexAttribIuiv = (PFNGETVERTEXATTRIBIUIVPROC)IntGetProcAddress(\"glGetVertexAttribIuiv\");\n        GetVertexAttribIuiv(index, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1i(GLuint index, GLint x)\n    {\n        VertexAttribI1i = (PFNVERTEXATTRIBI1IPROC)IntGetProcAddress(\"glVertexAttribI1i\");\n        VertexAttribI1i(index, x);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2i(GLuint index, GLint x, GLint y)\n    {\n        VertexAttribI2i = (PFNVERTEXATTRIBI2IPROC)IntGetProcAddress(\"glVertexAttribI2i\");\n        VertexAttribI2i(index, x, y);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)\n    {\n        VertexAttribI3i = (PFNVERTEXATTRIBI3IPROC)IntGetProcAddress(\"glVertexAttribI3i\");\n        VertexAttribI3i(index, x, y, z);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)\n    {\n        VertexAttribI4i = (PFNVERTEXATTRIBI4IPROC)IntGetProcAddress(\"glVertexAttribI4i\");\n        VertexAttribI4i(index, x, y, z, w);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1ui(GLuint index, GLuint x)\n    {\n        VertexAttribI1ui = (PFNVERTEXATTRIBI1UIPROC)IntGetProcAddress(\"glVertexAttribI1ui\");\n        VertexAttribI1ui(index, x);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2ui(GLuint index, GLuint x, GLuint y)\n    {\n        VertexAttribI2ui = (PFNVERTEXATTRIBI2UIPROC)IntGetProcAddress(\"glVertexAttribI2ui\");\n        VertexAttribI2ui(index, x, y);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)\n    {\n        VertexAttribI3ui = (PFNVERTEXATTRIBI3UIPROC)IntGetProcAddress(\"glVertexAttribI3ui\");\n        VertexAttribI3ui(index, x, y, z);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)\n    {\n        VertexAttribI4ui = (PFNVERTEXATTRIBI4UIPROC)IntGetProcAddress(\"glVertexAttribI4ui\");\n        VertexAttribI4ui(index, x, y, z, w);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI1iv = (PFNVERTEXATTRIBI1IVPROC)IntGetProcAddress(\"glVertexAttribI1iv\");\n        VertexAttribI1iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI2iv = (PFNVERTEXATTRIBI2IVPROC)IntGetProcAddress(\"glVertexAttribI2iv\");\n        VertexAttribI2iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI3iv = (PFNVERTEXATTRIBI3IVPROC)IntGetProcAddress(\"glVertexAttribI3iv\");\n        VertexAttribI3iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4iv(GLuint index, const GLint *v)\n    {\n        VertexAttribI4iv = (PFNVERTEXATTRIBI4IVPROC)IntGetProcAddress(\"glVertexAttribI4iv\");\n        VertexAttribI4iv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI1uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI1uiv = (PFNVERTEXATTRIBI1UIVPROC)IntGetProcAddress(\"glVertexAttribI1uiv\");\n        VertexAttribI1uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI2uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI2uiv = (PFNVERTEXATTRIBI2UIVPROC)IntGetProcAddress(\"glVertexAttribI2uiv\");\n        VertexAttribI2uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI3uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI3uiv = (PFNVERTEXATTRIBI3UIVPROC)IntGetProcAddress(\"glVertexAttribI3uiv\");\n        VertexAttribI3uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4uiv(GLuint index, const GLuint *v)\n    {\n        VertexAttribI4uiv = (PFNVERTEXATTRIBI4UIVPROC)IntGetProcAddress(\"glVertexAttribI4uiv\");\n        VertexAttribI4uiv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4bv(GLuint index, const GLbyte *v)\n    {\n        VertexAttribI4bv = (PFNVERTEXATTRIBI4BVPROC)IntGetProcAddress(\"glVertexAttribI4bv\");\n        VertexAttribI4bv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4sv(GLuint index, const GLshort *v)\n    {\n        VertexAttribI4sv = (PFNVERTEXATTRIBI4SVPROC)IntGetProcAddress(\"glVertexAttribI4sv\");\n        VertexAttribI4sv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4ubv(GLuint index, const GLubyte *v)\n    {\n        VertexAttribI4ubv = (PFNVERTEXATTRIBI4UBVPROC)IntGetProcAddress(\"glVertexAttribI4ubv\");\n        VertexAttribI4ubv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexAttribI4usv(GLuint index, const GLushort *v)\n    {\n        VertexAttribI4usv = (PFNVERTEXATTRIBI4USVPROC)IntGetProcAddress(\"glVertexAttribI4usv\");\n        VertexAttribI4usv(index, v);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformuiv(GLuint program, GLint location, GLuint *params)\n    {\n        GetUniformuiv = (PFNGETUNIFORMUIVPROC)IntGetProcAddress(\"glGetUniformuiv\");\n        GetUniformuiv(program, location, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_BindFragDataLocation(GLuint program, GLuint color, const GLchar *name)\n    {\n        BindFragDataLocation = (PFNBINDFRAGDATALOCATIONPROC)IntGetProcAddress(\"glBindFragDataLocation\");\n        BindFragDataLocation(program, color, name);\n    }\n\n    static GLint CODEGEN_FUNCPTR Switch_GetFragDataLocation(GLuint program, const GLchar *name)\n    {\n        GetFragDataLocation = (PFNGETFRAGDATALOCATIONPROC)IntGetProcAddress(\"glGetFragDataLocation\");\n        return GetFragDataLocation(program, name);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1ui(GLint location, GLuint v0)\n    {\n        Uniform1ui = (PFNUNIFORM1UIPROC)IntGetProcAddress(\"glUniform1ui\");\n        Uniform1ui(location, v0);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2ui(GLint location, GLuint v0, GLuint v1)\n    {\n        Uniform2ui = (PFNUNIFORM2UIPROC)IntGetProcAddress(\"glUniform2ui\");\n        Uniform2ui(location, v0, v1);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)\n    {\n        Uniform3ui = (PFNUNIFORM3UIPROC)IntGetProcAddress(\"glUniform3ui\");\n        Uniform3ui(location, v0, v1, v2);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)\n    {\n        Uniform4ui = (PFNUNIFORM4UIPROC)IntGetProcAddress(\"glUniform4ui\");\n        Uniform4ui(location, v0, v1, v2, v3);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform1uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform1uiv = (PFNUNIFORM1UIVPROC)IntGetProcAddress(\"glUniform1uiv\");\n        Uniform1uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform2uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform2uiv = (PFNUNIFORM2UIVPROC)IntGetProcAddress(\"glUniform2uiv\");\n        Uniform2uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform3uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform3uiv = (PFNUNIFORM3UIVPROC)IntGetProcAddress(\"glUniform3uiv\");\n        Uniform3uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Uniform4uiv(GLint location, GLsizei count, const GLuint *value)\n    {\n        Uniform4uiv = (PFNUNIFORM4UIVPROC)IntGetProcAddress(\"glUniform4uiv\");\n        Uniform4uiv(location, count, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)\n    {\n        TexParameterIiv = (PFNTEXPARAMETERIIVPROC)IntGetProcAddress(\"glTexParameterIiv\");\n        TexParameterIiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)\n    {\n        TexParameterIuiv = (PFNTEXPARAMETERIUIVPROC)IntGetProcAddress(\"glTexParameterIuiv\");\n        TexParameterIuiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)\n    {\n        GetTexParameterIiv = (PFNGETTEXPARAMETERIIVPROC)IntGetProcAddress(\"glGetTexParameterIiv\");\n        GetTexParameterIiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)\n    {\n        GetTexParameterIuiv = (PFNGETTEXPARAMETERIUIVPROC)IntGetProcAddress(\"glGetTexParameterIuiv\");\n        GetTexParameterIuiv(target, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)\n    {\n        ClearBufferiv = (PFNCLEARBUFFERIVPROC)IntGetProcAddress(\"glClearBufferiv\");\n        ClearBufferiv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)\n    {\n        ClearBufferuiv = (PFNCLEARBUFFERUIVPROC)IntGetProcAddress(\"glClearBufferuiv\");\n        ClearBufferuiv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)\n    {\n        ClearBufferfv = (PFNCLEARBUFFERFVPROC)IntGetProcAddress(\"glClearBufferfv\");\n        ClearBufferfv(buffer, drawbuffer, value);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)\n    {\n        ClearBufferfi = (PFNCLEARBUFFERFIPROC)IntGetProcAddress(\"glClearBufferfi\");\n        ClearBufferfi(buffer, drawbuffer, depth, stencil);\n    }\n\n    static const GLubyte * CODEGEN_FUNCPTR Switch_GetStringi(GLenum name, GLuint index)\n    {\n        GetStringi = (PFNGETSTRINGIPROC)IntGetProcAddress(\"glGetStringi\");\n        return GetStringi(name, index);\n    }\n\n    // Extension: ARB_uniform_buffer_object\n\n    static void CODEGEN_FUNCPTR Switch_GetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices)\n    {\n        GetUniformIndices = (PFNGETUNIFORMINDICESPROC)IntGetProcAddress(\"glGetUniformIndices\");\n        GetUniformIndices(program, uniformCount, uniformNames, uniformIndices);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)\n    {\n        GetActiveUniformsiv = (PFNGETACTIVEUNIFORMSIVPROC)IntGetProcAddress(\"glGetActiveUniformsiv\");\n        GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)\n    {\n        GetActiveUniformName = (PFNGETACTIVEUNIFORMNAMEPROC)IntGetProcAddress(\"glGetActiveUniformName\");\n        GetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);\n    }\n\n    static GLuint CODEGEN_FUNCPTR Switch_GetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)\n    {\n        GetUniformBlockIndex = (PFNGETUNIFORMBLOCKINDEXPROC)IntGetProcAddress(\"glGetUniformBlockIndex\");\n        return GetUniformBlockIndex(program, uniformBlockName);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)\n    {\n        GetActiveUniformBlockiv = (PFNGETACTIVEUNIFORMBLOCKIVPROC)IntGetProcAddress(\"glGetActiveUniformBlockiv\");\n        GetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_GetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)\n    {\n        GetActiveUniformBlockName = (PFNGETACTIVEUNIFORMBLOCKNAMEPROC)IntGetProcAddress(\"glGetActiveUniformBlockName\");\n        GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_UniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)\n    {\n        UniformBlockBinding = (PFNUNIFORMBLOCKBINDINGPROC)IntGetProcAddress(\"glUniformBlockBinding\");\n        UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);\n    }\n\n    // Extension: ARB_copy_buffer\n\n    static void CODEGEN_FUNCPTR Switch_CopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)\n    {\n        CopyBufferSubData = (PFNCOPYBUFFERSUBDATAPROC)IntGetProcAddress(\"glCopyBufferSubData\");\n        CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);\n    }\n\n    // Extension: 3.1\n\n    static void CODEGEN_FUNCPTR Switch_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)\n    {\n        DrawArraysInstanced = (PFNDRAWARRAYSINSTANCEDPROC)IntGetProcAddress(\"glDrawArraysInstanced\");\n        DrawArraysInstanced(mode, first, count, instancecount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount)\n    {\n        DrawElementsInstanced = (PFNDRAWELEMENTSINSTANCEDPROC)IntGetProcAddress(\"glDrawElementsInstanced\");\n        DrawElementsInstanced(mode, count, type, indices, instancecount);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexBuffer(GLenum target, GLenum internalformat, GLuint buffer)\n    {\n        TexBuffer = (PFNTEXBUFFERPROC)IntGetProcAddress(\"glTexBuffer\");\n        TexBuffer(target, internalformat, buffer);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_PrimitiveRestartIndex(GLuint index)\n    {\n        PrimitiveRestartIndex = (PFNPRIMITIVERESTARTINDEXPROC)IntGetProcAddress(\"glPrimitiveRestartIndex\");\n        PrimitiveRestartIndex(index);\n    }\n\n    // Legacy\n\n    static void CODEGEN_FUNCPTR Switch_EnableClientState(GLenum cap)\n    {\n        EnableClientState = (PFNENABLECLIENTSTATEPROC)IntGetProcAddress(\"glEnableClientState\");\n        EnableClientState(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_DisableClientState(GLenum cap)\n    {\n        DisableClientState = (PFNDISABLECLIENTSTATEPROC)IntGetProcAddress(\"glDisableClientState\");\n        DisableClientState(cap);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        VertexPointer = (PFNVERTEXPOINTERPROC)IntGetProcAddress(\"glVertexPointer\");\n        VertexPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        NormalPointer = (PFNNORMALPOINTERPROC)IntGetProcAddress(\"glNormalPointer\");\n        NormalPointer(type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        ColorPointer = (PFNCOLORPOINTERPROC)IntGetProcAddress(\"glColorPointer\");\n        ColorPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)\n    {\n        TexCoordPointer = (PFNTEXCOORDPOINTERPROC)IntGetProcAddress(\"glTexCoordPointer\");\n        TexCoordPointer(size, type, stride, ptr);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_TexEnvi(GLenum target, GLenum pname, GLint param)\n    {\n        TexEnvi = (PFNTEXENVIPROC)IntGetProcAddress(\"glTexEnvi\");\n        TexEnvi(target, pname, param);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_MatrixMode(GLenum mode)\n    {\n        MatrixMode = (PFNMATRIXMODEPROC)IntGetProcAddress(\"glMatrixMode\");\n        MatrixMode(mode);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_LoadIdentity(void)\n    {\n        LoadIdentity = (PFNLOADIDENTITYPROC)IntGetProcAddress(\"glLoadIdentity\");\n        LoadIdentity();\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Ortho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)\n    {\n        Ortho = (PFNORTHOPROC)IntGetProcAddress(\"glOrtho\");\n        Ortho(left, right, bottom, top, near_val, far_val);\n    }\n\n    static void CODEGEN_FUNCPTR Switch_Color3d(GLdouble red, GLdouble green, GLdouble blue)\n    {\n        Color3d = (PFNCOLOR3DPROC)IntGetProcAddress(\"glColor3d\");\n        Color3d(red, green, blue);\n    }\n\n    struct InitializeVariables\n    {\n        InitializeVariables()\n        {\n            // Extension: 1.1\n            CullFace = Switch_CullFace;\n            FrontFace = Switch_FrontFace;\n            Hint = Switch_Hint;\n            LineWidth = Switch_LineWidth;\n            PointSize = Switch_PointSize;\n            PolygonMode = Switch_PolygonMode;\n            Scissor = Switch_Scissor;\n            TexParameterf = Switch_TexParameterf;\n            TexParameterfv = Switch_TexParameterfv;\n            TexParameteri = Switch_TexParameteri;\n            TexParameteriv = Switch_TexParameteriv;\n            TexImage1D = Switch_TexImage1D;\n            TexImage2D = Switch_TexImage2D;\n            DrawBuffer = Switch_DrawBuffer;\n            Clear = Switch_Clear;\n            ClearColor = Switch_ClearColor;\n            ClearStencil = Switch_ClearStencil;\n            ClearDepth = Switch_ClearDepth;\n            StencilMask = Switch_StencilMask;\n            ColorMask = Switch_ColorMask;\n            DepthMask = Switch_DepthMask;\n            Disable = Switch_Disable;\n            Enable = Switch_Enable;\n            Finish = Switch_Finish;\n            Flush = Switch_Flush;\n            BlendFunc = Switch_BlendFunc;\n            LogicOp = Switch_LogicOp;\n            StencilFunc = Switch_StencilFunc;\n            StencilOp = Switch_StencilOp;\n            DepthFunc = Switch_DepthFunc;\n            PixelStoref = Switch_PixelStoref;\n            PixelStorei = Switch_PixelStorei;\n            ReadBuffer = Switch_ReadBuffer;\n            ReadPixels = Switch_ReadPixels;\n            GetBooleanv = Switch_GetBooleanv;\n            GetDoublev = Switch_GetDoublev;\n            GetError = Switch_GetError;\n            GetFloatv = Switch_GetFloatv;\n            GetIntegerv = Switch_GetIntegerv;\n            GetString = Switch_GetString;\n            GetTexImage = Switch_GetTexImage;\n            GetTexParameterfv = Switch_GetTexParameterfv;\n            GetTexParameteriv = Switch_GetTexParameteriv;\n            GetTexLevelParameterfv = Switch_GetTexLevelParameterfv;\n            GetTexLevelParameteriv = Switch_GetTexLevelParameteriv;\n            IsEnabled = Switch_IsEnabled;\n            DepthRange = Switch_DepthRange;\n            Viewport = Switch_Viewport;\n            DrawArrays = Switch_DrawArrays;\n            DrawElements = Switch_DrawElements;\n            GetPointerv = Switch_GetPointerv;\n            PolygonOffset = Switch_PolygonOffset;\n            CopyTexImage1D = Switch_CopyTexImage1D;\n            CopyTexImage2D = Switch_CopyTexImage2D;\n            CopyTexSubImage1D = Switch_CopyTexSubImage1D;\n            CopyTexSubImage2D = Switch_CopyTexSubImage2D;\n            TexSubImage1D = Switch_TexSubImage1D;\n            TexSubImage2D = Switch_TexSubImage2D;\n            BindTexture = Switch_BindTexture;\n            DeleteTextures = Switch_DeleteTextures;\n            GenTextures = Switch_GenTextures;\n            IsTexture = Switch_IsTexture;\n            Indexub = Switch_Indexub;\n            Indexubv = Switch_Indexubv;\n\n            // Extension: 1.2\n            BlendColor = Switch_BlendColor;\n            BlendEquation = Switch_BlendEquation;\n            DrawRangeElements = Switch_DrawRangeElements;\n            TexSubImage3D = Switch_TexSubImage3D;\n            CopyTexSubImage3D = Switch_CopyTexSubImage3D;\n\n            // Extension: 1.3\n            ActiveTexture = Switch_ActiveTexture;\n            SampleCoverage = Switch_SampleCoverage;\n            CompressedTexImage3D = Switch_CompressedTexImage3D;\n            CompressedTexImage2D = Switch_CompressedTexImage2D;\n            CompressedTexImage1D = Switch_CompressedTexImage1D;\n            CompressedTexSubImage3D = Switch_CompressedTexSubImage3D;\n            CompressedTexSubImage2D = Switch_CompressedTexSubImage2D;\n            CompressedTexSubImage1D = Switch_CompressedTexSubImage1D;\n            GetCompressedTexImage = Switch_GetCompressedTexImage;\n\n            // Extension: 1.4\n            BlendFuncSeparate = Switch_BlendFuncSeparate;\n            MultiDrawArrays = Switch_MultiDrawArrays;\n            MultiDrawElements = Switch_MultiDrawElements;\n            PointParameterf = Switch_PointParameterf;\n            PointParameterfv = Switch_PointParameterfv;\n            PointParameteri = Switch_PointParameteri;\n            PointParameteriv = Switch_PointParameteriv;\n\n            // Extension: 1.5\n            GenQueries = Switch_GenQueries;\n            DeleteQueries = Switch_DeleteQueries;\n            IsQuery = Switch_IsQuery;\n            BeginQuery = Switch_BeginQuery;\n            EndQuery = Switch_EndQuery;\n            GetQueryiv = Switch_GetQueryiv;\n            GetQueryObjectiv = Switch_GetQueryObjectiv;\n            GetQueryObjectuiv = Switch_GetQueryObjectuiv;\n            BindBuffer = Switch_BindBuffer;\n            DeleteBuffers = Switch_DeleteBuffers;\n            GenBuffers = Switch_GenBuffers;\n            IsBuffer = Switch_IsBuffer;\n            BufferData = Switch_BufferData;\n            BufferSubData = Switch_BufferSubData;\n            GetBufferSubData = Switch_GetBufferSubData;\n            MapBuffer = Switch_MapBuffer;\n            UnmapBuffer = Switch_UnmapBuffer;\n            GetBufferParameteriv = Switch_GetBufferParameteriv;\n            GetBufferPointerv = Switch_GetBufferPointerv;\n\n            // Extension: 2.0\n            BlendEquationSeparate = Switch_BlendEquationSeparate;\n            DrawBuffers = Switch_DrawBuffers;\n            StencilOpSeparate = Switch_StencilOpSeparate;\n            StencilFuncSeparate = Switch_StencilFuncSeparate;\n            StencilMaskSeparate = Switch_StencilMaskSeparate;\n            AttachShader = Switch_AttachShader;\n            BindAttribLocation = Switch_BindAttribLocation;\n            CompileShader = Switch_CompileShader;\n            CreateProgram = Switch_CreateProgram;\n            CreateShader = Switch_CreateShader;\n            DeleteProgram = Switch_DeleteProgram;\n            DeleteShader = Switch_DeleteShader;\n            DetachShader = Switch_DetachShader;\n            DisableVertexAttribArray = Switch_DisableVertexAttribArray;\n            EnableVertexAttribArray = Switch_EnableVertexAttribArray;\n            GetActiveAttrib = Switch_GetActiveAttrib;\n            GetActiveUniform = Switch_GetActiveUniform;\n            GetAttachedShaders = Switch_GetAttachedShaders;\n            GetAttribLocation = Switch_GetAttribLocation;\n            GetProgramiv = Switch_GetProgramiv;\n            GetProgramInfoLog = Switch_GetProgramInfoLog;\n            GetShaderiv = Switch_GetShaderiv;\n            GetShaderInfoLog = Switch_GetShaderInfoLog;\n            GetShaderSource = Switch_GetShaderSource;\n            GetUniformLocation = Switch_GetUniformLocation;\n            GetUniformfv = Switch_GetUniformfv;\n            GetUniformiv = Switch_GetUniformiv;\n            GetVertexAttribdv = Switch_GetVertexAttribdv;\n            GetVertexAttribfv = Switch_GetVertexAttribfv;\n            GetVertexAttribiv = Switch_GetVertexAttribiv;\n            GetVertexAttribPointerv = Switch_GetVertexAttribPointerv;\n            IsProgram = Switch_IsProgram;\n            IsShader = Switch_IsShader;\n            LinkProgram = Switch_LinkProgram;\n            ShaderSource = Switch_ShaderSource;\n            UseProgram = Switch_UseProgram;\n            Uniform1f = Switch_Uniform1f;\n            Uniform2f = Switch_Uniform2f;\n            Uniform3f = Switch_Uniform3f;\n            Uniform4f = Switch_Uniform4f;\n            Uniform1i = Switch_Uniform1i;\n            Uniform2i = Switch_Uniform2i;\n            Uniform3i = Switch_Uniform3i;\n            Uniform4i = Switch_Uniform4i;\n            Uniform1fv = Switch_Uniform1fv;\n            Uniform2fv = Switch_Uniform2fv;\n            Uniform3fv = Switch_Uniform3fv;\n            Uniform4fv = Switch_Uniform4fv;\n            Uniform1iv = Switch_Uniform1iv;\n            Uniform2iv = Switch_Uniform2iv;\n            Uniform3iv = Switch_Uniform3iv;\n            Uniform4iv = Switch_Uniform4iv;\n            UniformMatrix2fv = Switch_UniformMatrix2fv;\n            UniformMatrix3fv = Switch_UniformMatrix3fv;\n            UniformMatrix4fv = Switch_UniformMatrix4fv;\n            ValidateProgram = Switch_ValidateProgram;\n            VertexAttribPointer = Switch_VertexAttribPointer;\n\n            // Extension: 2.1\n            UniformMatrix2x3fv = Switch_UniformMatrix2x3fv;\n            UniformMatrix3x2fv = Switch_UniformMatrix3x2fv;\n            UniformMatrix2x4fv = Switch_UniformMatrix2x4fv;\n            UniformMatrix4x2fv = Switch_UniformMatrix4x2fv;\n            UniformMatrix3x4fv = Switch_UniformMatrix3x4fv;\n            UniformMatrix4x3fv = Switch_UniformMatrix4x3fv;\n\n            // Extension: ARB_vertex_array_object\n            BindVertexArray = Switch_BindVertexArray;\n            DeleteVertexArrays = Switch_DeleteVertexArrays;\n            GenVertexArrays = Switch_GenVertexArrays;\n            IsVertexArray = Switch_IsVertexArray;\n\n            // Extension: ARB_map_buffer_range\n            MapBufferRange = Switch_MapBufferRange;\n            FlushMappedBufferRange = Switch_FlushMappedBufferRange;\n\n            // Extension: ARB_framebuffer_object\n            IsRenderbuffer = Switch_IsRenderbuffer;\n            BindRenderbuffer = Switch_BindRenderbuffer;\n            DeleteRenderbuffers = Switch_DeleteRenderbuffers;\n            GenRenderbuffers = Switch_GenRenderbuffers;\n            RenderbufferStorage = Switch_RenderbufferStorage;\n            GetRenderbufferParameteriv = Switch_GetRenderbufferParameteriv;\n            IsFramebuffer = Switch_IsFramebuffer;\n            BindFramebuffer = Switch_BindFramebuffer;\n            DeleteFramebuffers = Switch_DeleteFramebuffers;\n            GenFramebuffers = Switch_GenFramebuffers;\n            CheckFramebufferStatus = Switch_CheckFramebufferStatus;\n            FramebufferTexture1D = Switch_FramebufferTexture1D;\n            FramebufferTexture2D = Switch_FramebufferTexture2D;\n            FramebufferTexture3D = Switch_FramebufferTexture3D;\n            FramebufferRenderbuffer = Switch_FramebufferRenderbuffer;\n            GetFramebufferAttachmentParameteriv = Switch_GetFramebufferAttachmentParameteriv;\n            GenerateMipmap = Switch_GenerateMipmap;\n            BlitFramebuffer = Switch_BlitFramebuffer;\n            RenderbufferStorageMultisample = Switch_RenderbufferStorageMultisample;\n            FramebufferTextureLayer = Switch_FramebufferTextureLayer;\n\n            // Extension: 3.0\n            ColorMaski = Switch_ColorMaski;\n            GetBooleani_v = Switch_GetBooleani_v;\n            GetIntegeri_v = Switch_GetIntegeri_v;\n            Enablei = Switch_Enablei;\n            Disablei = Switch_Disablei;\n            IsEnabledi = Switch_IsEnabledi;\n            BeginTransformFeedback = Switch_BeginTransformFeedback;\n            EndTransformFeedback = Switch_EndTransformFeedback;\n            BindBufferRange = Switch_BindBufferRange;\n            BindBufferBase = Switch_BindBufferBase;\n            TransformFeedbackVaryings = Switch_TransformFeedbackVaryings;\n            GetTransformFeedbackVarying = Switch_GetTransformFeedbackVarying;\n            ClampColor = Switch_ClampColor;\n            BeginConditionalRender = Switch_BeginConditionalRender;\n            EndConditionalRender = Switch_EndConditionalRender;\n            VertexAttribIPointer = Switch_VertexAttribIPointer;\n            GetVertexAttribIiv = Switch_GetVertexAttribIiv;\n            GetVertexAttribIuiv = Switch_GetVertexAttribIuiv;\n            VertexAttribI1i = Switch_VertexAttribI1i;\n            VertexAttribI2i = Switch_VertexAttribI2i;\n            VertexAttribI3i = Switch_VertexAttribI3i;\n            VertexAttribI4i = Switch_VertexAttribI4i;\n            VertexAttribI1ui = Switch_VertexAttribI1ui;\n            VertexAttribI2ui = Switch_VertexAttribI2ui;\n            VertexAttribI3ui = Switch_VertexAttribI3ui;\n            VertexAttribI4ui = Switch_VertexAttribI4ui;\n            VertexAttribI1iv = Switch_VertexAttribI1iv;\n            VertexAttribI2iv = Switch_VertexAttribI2iv;\n            VertexAttribI3iv = Switch_VertexAttribI3iv;\n            VertexAttribI4iv = Switch_VertexAttribI4iv;\n            VertexAttribI1uiv = Switch_VertexAttribI1uiv;\n            VertexAttribI2uiv = Switch_VertexAttribI2uiv;\n            VertexAttribI3uiv = Switch_VertexAttribI3uiv;\n            VertexAttribI4uiv = Switch_VertexAttribI4uiv;\n            VertexAttribI4bv = Switch_VertexAttribI4bv;\n            VertexAttribI4sv = Switch_VertexAttribI4sv;\n            VertexAttribI4ubv = Switch_VertexAttribI4ubv;\n            VertexAttribI4usv = Switch_VertexAttribI4usv;\n            GetUniformuiv = Switch_GetUniformuiv;\n            BindFragDataLocation = Switch_BindFragDataLocation;\n            GetFragDataLocation = Switch_GetFragDataLocation;\n            Uniform1ui = Switch_Uniform1ui;\n            Uniform2ui = Switch_Uniform2ui;\n            Uniform3ui = Switch_Uniform3ui;\n            Uniform4ui = Switch_Uniform4ui;\n            Uniform1uiv = Switch_Uniform1uiv;\n            Uniform2uiv = Switch_Uniform2uiv;\n            Uniform3uiv = Switch_Uniform3uiv;\n            Uniform4uiv = Switch_Uniform4uiv;\n            TexParameterIiv = Switch_TexParameterIiv;\n            TexParameterIuiv = Switch_TexParameterIuiv;\n            GetTexParameterIiv = Switch_GetTexParameterIiv;\n            GetTexParameterIuiv = Switch_GetTexParameterIuiv;\n            ClearBufferiv = Switch_ClearBufferiv;\n            ClearBufferuiv = Switch_ClearBufferuiv;\n            ClearBufferfv = Switch_ClearBufferfv;\n            ClearBufferfi = Switch_ClearBufferfi;\n            GetStringi = Switch_GetStringi;\n\n            // Extension: ARB_uniform_buffer_object\n            GetUniformIndices = Switch_GetUniformIndices;\n            GetActiveUniformsiv = Switch_GetActiveUniformsiv;\n            GetActiveUniformName = Switch_GetActiveUniformName;\n            GetUniformBlockIndex = Switch_GetUniformBlockIndex;\n            GetActiveUniformBlockiv = Switch_GetActiveUniformBlockiv;\n            GetActiveUniformBlockName = Switch_GetActiveUniformBlockName;\n            UniformBlockBinding = Switch_UniformBlockBinding;\n\n            // Extension: ARB_copy_buffer\n            CopyBufferSubData = Switch_CopyBufferSubData;\n\n            // Extension: 3.1\n            DrawArraysInstanced = Switch_DrawArraysInstanced;\n            DrawElementsInstanced = Switch_DrawElementsInstanced;\n            TexBuffer = Switch_TexBuffer;\n            PrimitiveRestartIndex = Switch_PrimitiveRestartIndex;\n\n            // Legacy\n            EnableClientState = Switch_EnableClientState;\n            DisableClientState = Switch_DisableClientState;\n            VertexPointer = Switch_VertexPointer;\n            NormalPointer = Switch_NormalPointer;\n            ColorPointer = Switch_ColorPointer;\n            TexCoordPointer = Switch_TexCoordPointer;\n            TexEnvi = Switch_TexEnvi;\n            MatrixMode = Switch_MatrixMode;\n            LoadIdentity = Switch_LoadIdentity;\n            Ortho = Switch_Ortho;\n            Color3d = Switch_Color3d;\n        }\n    };\n\n    InitializeVariables g_initVariables;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/src/gpumat.cpp": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n#include \"opencv2/core/gpumat.hpp\"\n#include <iostream>\n\n#if defined(HAVE_CUDA)\n# include <cuda_runtime.h>\n# include <npp.h>\n\n# define CUDART_MINIMUM_REQUIRED_VERSION 4020\n# define NPP_MINIMUM_REQUIRED_VERSION 4200\n\n# if (CUDART_VERSION < CUDART_MINIMUM_REQUIRED_VERSION)\n#  error \"Insufficient Cuda Runtime library version, please update it.\"\n# endif\n\n# if (NPP_VERSION_MAJOR * 1000 + NPP_VERSION_MINOR * 100 + NPP_VERSION_BUILD < NPP_MINIMUM_REQUIRED_VERSION)\n#  error \"Insufficient NPP version, please update it.\"\n# endif\n#endif\n\n#ifdef DYNAMIC_CUDA_SUPPORT\n# include <dlfcn.h>\n# include <sys/types.h>\n# include <sys/stat.h>\n# include <dirent.h>\n#endif\n\n#ifdef ANDROID\n# ifdef LOG_TAG\n#  undef LOG_TAG\n# endif\n# ifdef LOGE\n#  undef LOGE\n# endif\n# ifdef LOGD\n#  undef LOGD\n# endif\n# ifdef LOGI\n#  undef LOGI\n# endif\n\n# include <android/log.h>\n\n# define LOG_TAG \"OpenCV::CUDA\"\n# define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))\n# define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__))\n# define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))\n#endif\n\nusing namespace std;\nusing namespace cv;\nusing namespace cv::gpu;\n\n#define throw_nogpu CV_Error(CV_GpuNotSupported, \"The library is compiled without CUDA support\")\n\n#include \"opencv2/dynamicuda/dynamicuda.hpp\"\n\n#ifdef DYNAMIC_CUDA_SUPPORT\n\ntypedef GpuFuncTable* (*GpuFactoryType)();\ntypedef DeviceInfoFuncTable* (*DeviceInfoFactoryType)();\n\nstatic GpuFactoryType gpuFactory = NULL;\nstatic DeviceInfoFactoryType deviceInfoFactory = NULL;\n\n# if defined(__linux__) || defined(__APPLE__) || defined (ANDROID)\n\nconst std::string DYNAMIC_CUDA_LIB_NAME = \"libopencv_dynamicuda.so\";\n\n#  ifdef ANDROID\nstatic const std::string getCudaSupportLibName()\n{\n    Dl_info dl_info;\n    if(0 != dladdr((void *)getCudaSupportLibName, &dl_info))\n    {\n        LOGD(\"Library name: %s\", dl_info.dli_fname);\n        LOGD(\"Library base address: %p\", dl_info.dli_fbase);\n\n        const char* libName=dl_info.dli_fname;\n        while( ((*libName)=='/') || ((*libName)=='.') )\n        libName++;\n\n        char lineBuf[2048];\n        FILE* file = fopen(\"/proc/self/smaps\", \"rt\");\n\n        if(file)\n        {\n            while (fgets(lineBuf, sizeof lineBuf, file) != NULL)\n            {\n                //verify that line ends with library name\n                int lineLength = strlen(lineBuf);\n                int libNameLength = strlen(libName);\n\n                //trim end\n                for(int i = lineLength - 1; i >= 0 && isspace(lineBuf[i]); --i)\n                {\n                    lineBuf[i] = 0;\n                    --lineLength;\n                }\n\n                if (0 != strncmp(lineBuf + lineLength - libNameLength, libName, libNameLength))\n                {\n                //the line does not contain the library name\n                    continue;\n                }\n\n                //extract path from smaps line\n                char* pathBegin = strchr(lineBuf, '/');\n                if (0 == pathBegin)\n                {\n                    LOGE(\"Strange error: could not find path beginning in lin \\\"%s\\\"\", lineBuf);\n                    continue;\n                }\n\n                char* pathEnd = strrchr(pathBegin, '/');\n                pathEnd[1] = 0;\n\n                LOGD(\"Libraries folder found: %s\", pathBegin);\n\n                fclose(file);\n                return std::string(pathBegin) + DYNAMIC_CUDA_LIB_NAME;\n            }\n            fclose(file);\n            LOGE(\"Could not find library path\");\n        }\n        else\n        {\n            LOGE(\"Could not read /proc/self/smaps\");\n        }\n    }\n    else\n    {\n        LOGE(\"Could not get library name and base address\");\n    }\n\n    return string();\n}\n\n#  else\nstatic const std::string getCudaSupportLibName()\n{\n    return DYNAMIC_CUDA_LIB_NAME;\n}\n#  endif\n\nstatic bool loadCudaSupportLib()\n{\n    void* handle;\n    const std::string name = getCudaSupportLibName();\n    dlerror();\n    handle = dlopen(name.c_str(), RTLD_LAZY);\n    if (!handle)\n    {\n        LOGE(\"Cannot dlopen %s: %s\", name.c_str(), dlerror());\n        return false;\n    }\n\n    deviceInfoFactory = (DeviceInfoFactoryType)dlsym(handle, \"deviceInfoFactory\");\n    if (!deviceInfoFactory)\n    {\n        LOGE(\"Cannot dlsym deviceInfoFactory: %s\", dlerror());\n        dlclose(handle);\n        return false;\n    }\n\n    gpuFactory = (GpuFactoryType)dlsym(handle, \"gpuFactory\");\n    if (!gpuFactory)\n    {\n        LOGE(\"Cannot dlsym gpuFactory: %s\", dlerror());\n        dlclose(handle);\n        return false;\n    }\n\n    return true;\n}\n\n# else\n#  error \"Dynamic CUDA support is not implemented for this platform!\"\n# endif\n\n#endif\n\nstatic GpuFuncTable* gpuFuncTable()\n{\n#ifdef DYNAMIC_CUDA_SUPPORT\n   static EmptyFuncTable stub;\n   static GpuFuncTable* libFuncTable = loadCudaSupportLib() ? gpuFactory(): (GpuFuncTable*)&stub;\n   static GpuFuncTable *funcTable = libFuncTable ? libFuncTable : (GpuFuncTable*)&stub;\n#else\n# ifdef USE_CUDA\n   static CudaFuncTable impl;\n   static GpuFuncTable* funcTable = &impl;\n#else\n   static EmptyFuncTable stub;\n   static GpuFuncTable* funcTable = &stub;\n#endif\n#endif\n   return funcTable;\n}\n\nstatic DeviceInfoFuncTable* deviceInfoFuncTable()\n{\n#ifdef DYNAMIC_CUDA_SUPPORT\n   static EmptyDeviceInfoFuncTable stub;\n   static DeviceInfoFuncTable* libFuncTable = loadCudaSupportLib() ? deviceInfoFactory(): (DeviceInfoFuncTable*)&stub;\n   static DeviceInfoFuncTable* funcTable = libFuncTable ? libFuncTable : (DeviceInfoFuncTable*)&stub;\n#else\n# ifdef USE_CUDA\n   static CudaDeviceInfoFuncTable impl;\n   static DeviceInfoFuncTable* funcTable = &impl;\n#else\n   static EmptyDeviceInfoFuncTable stub;\n   static DeviceInfoFuncTable* funcTable = &stub;\n#endif\n#endif\n   return funcTable;\n}\n\n\n//////////////////////////////// Initialization & Info ////////////////////////\n\nint cv::gpu::getCudaEnabledDeviceCount() { return deviceInfoFuncTable()->getCudaEnabledDeviceCount(); }\n\nvoid cv::gpu::setDevice(int device) { deviceInfoFuncTable()->setDevice(device); }\nint cv::gpu::getDevice() { return deviceInfoFuncTable()->getDevice(); }\n\nvoid cv::gpu::resetDevice() { deviceInfoFuncTable()->resetDevice(); }\n\nbool cv::gpu::deviceSupports(FeatureSet feature_set) { return deviceInfoFuncTable()->deviceSupports(feature_set); }\n\nbool cv::gpu::TargetArchs::builtWith(FeatureSet feature_set) { return deviceInfoFuncTable()->builtWith(feature_set); }\nbool cv::gpu::TargetArchs::has(int major, int minor) { return deviceInfoFuncTable()->has(major, minor); }\nbool cv::gpu::TargetArchs::hasPtx(int major, int minor) {  return deviceInfoFuncTable()->hasPtx(major, minor); }\nbool cv::gpu::TargetArchs::hasBin(int major, int minor) { return deviceInfoFuncTable()->hasBin(major, minor);  }\nbool cv::gpu::TargetArchs::hasEqualOrLessPtx(int major, int minor) { return deviceInfoFuncTable()->hasEqualOrLessPtx(major, minor); }\nbool cv::gpu::TargetArchs::hasEqualOrGreater(int major, int minor) { return deviceInfoFuncTable()->hasEqualOrGreater(major, minor); }\nbool cv::gpu::TargetArchs::hasEqualOrGreaterPtx(int major, int minor) { return deviceInfoFuncTable()->hasEqualOrGreaterPtx(major, minor); }\nbool cv::gpu::TargetArchs::hasEqualOrGreaterBin(int major, int minor) { return deviceInfoFuncTable()->hasEqualOrGreaterBin(major, minor); }\n\nsize_t cv::gpu::DeviceInfo::sharedMemPerBlock() const { return deviceInfoFuncTable()->sharedMemPerBlock(device_id_); }\nvoid cv::gpu::DeviceInfo::queryMemory(size_t& total_memory, size_t& free_memory) const { deviceInfoFuncTable()->queryMemory(device_id_, total_memory, free_memory); }\nsize_t cv::gpu::DeviceInfo::freeMemory() const { return deviceInfoFuncTable()->freeMemory(device_id_); }\nsize_t cv::gpu::DeviceInfo::totalMemory() const { return deviceInfoFuncTable()->totalMemory(device_id_); }\nbool cv::gpu::DeviceInfo::supports(FeatureSet feature_set) const { return deviceInfoFuncTable()->supports(device_id_, feature_set); }\nbool cv::gpu::DeviceInfo::isCompatible() const { return deviceInfoFuncTable()->isCompatible(device_id_); }\n\nvoid cv::gpu::DeviceInfo::query()\n{\n    name_ = deviceInfoFuncTable()->name(device_id_);\n    multi_processor_count_ = deviceInfoFuncTable()->multiProcessorCount(device_id_);\n    majorVersion_ = deviceInfoFuncTable()->majorVersion(device_id_);\n    minorVersion_ = deviceInfoFuncTable()->minorVersion(device_id_);\n}\n\nvoid cv::gpu::printCudaDeviceInfo(int device) { deviceInfoFuncTable()->printCudaDeviceInfo(device); }\nvoid cv::gpu::printShortCudaDeviceInfo(int device) { deviceInfoFuncTable()->printShortCudaDeviceInfo(device); }\n\nnamespace cv { namespace gpu\n{\n    CV_EXPORTS void copyWithMask(const cv::gpu::GpuMat&, cv::gpu::GpuMat&, const cv::gpu::GpuMat&, cudaStream_t);\n    CV_EXPORTS void convertTo(const cv::gpu::GpuMat&, cv::gpu::GpuMat&);\n    CV_EXPORTS void convertTo(const cv::gpu::GpuMat&, cv::gpu::GpuMat&, double, double, cudaStream_t = 0);\n    CV_EXPORTS void setTo(cv::gpu::GpuMat&, cv::Scalar, cudaStream_t);\n    CV_EXPORTS void setTo(cv::gpu::GpuMat&, cv::Scalar, const cv::gpu::GpuMat&, cudaStream_t);\n    CV_EXPORTS void setTo(cv::gpu::GpuMat&, cv::Scalar);\n    CV_EXPORTS void setTo(cv::gpu::GpuMat&, cv::Scalar, const cv::gpu::GpuMat&);\n}}\n\n//////////////////////////////// GpuMat ///////////////////////////////\n\ncv::gpu::GpuMat::GpuMat(const GpuMat& m)\n    : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend)\n{\n    if (refcount)\n        CV_XADD(refcount, 1);\n}\n\ncv::gpu::GpuMat::GpuMat(int rows_, int cols_, int type_, void* data_, size_t step_) :\n    flags(Mat::MAGIC_VAL + (type_ & TYPE_MASK)), rows(rows_), cols(cols_),\n    step(step_), data((uchar*)data_), refcount(0),\n    datastart((uchar*)data_), dataend((uchar*)data_)\n{\n    size_t minstep = cols * elemSize();\n\n    if (step == Mat::AUTO_STEP)\n    {\n        step = minstep;\n        flags |= Mat::CONTINUOUS_FLAG;\n    }\n    else\n    {\n        if (rows == 1)\n            step = minstep;\n\n        CV_DbgAssert(step >= minstep);\n\n        flags |= step == minstep ? Mat::CONTINUOUS_FLAG : 0;\n    }\n    dataend += step * (rows - 1) + minstep;\n}\n\ncv::gpu::GpuMat::GpuMat(Size size_, int type_, void* data_, size_t step_) :\n    flags(Mat::MAGIC_VAL + (type_ & TYPE_MASK)), rows(size_.height), cols(size_.width),\n    step(step_), data((uchar*)data_), refcount(0),\n    datastart((uchar*)data_), dataend((uchar*)data_)\n{\n    size_t minstep = cols * elemSize();\n\n    if (step == Mat::AUTO_STEP)\n    {\n        step = minstep;\n        flags |= Mat::CONTINUOUS_FLAG;\n    }\n    else\n    {\n        if (rows == 1)\n            step = minstep;\n\n        CV_DbgAssert(step >= minstep);\n\n        flags |= step == minstep ? Mat::CONTINUOUS_FLAG : 0;\n    }\n    dataend += step * (rows - 1) + minstep;\n}\n\ncv::gpu::GpuMat::GpuMat(const GpuMat& m, Range _rowRange, Range _colRange)\n{\n    flags = m.flags;\n    step = m.step; refcount = m.refcount;\n    data = m.data; datastart = m.datastart; dataend = m.dataend;\n\n    if (_rowRange == Range::all())\n        rows = m.rows;\n    else\n    {\n        CV_Assert(0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows);\n\n        rows = _rowRange.size();\n        data += step*_rowRange.start;\n    }\n\n    if (_colRange == Range::all())\n        cols = m.cols;\n    else\n    {\n        CV_Assert(0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols);\n\n        cols = _colRange.size();\n        data += _colRange.start*elemSize();\n        flags &= cols < m.cols ? ~Mat::CONTINUOUS_FLAG : -1;\n    }\n\n    if (rows == 1)\n        flags |= Mat::CONTINUOUS_FLAG;\n\n    if (refcount)\n        CV_XADD(refcount, 1);\n\n    if (rows <= 0 || cols <= 0)\n        rows = cols = 0;\n}\n\ncv::gpu::GpuMat::GpuMat(const GpuMat& m, Rect roi) :\n    flags(m.flags), rows(roi.height), cols(roi.width),\n    step(m.step), data(m.data + roi.y*step), refcount(m.refcount),\n    datastart(m.datastart), dataend(m.dataend)\n{\n    flags &= roi.width < m.cols ? ~Mat::CONTINUOUS_FLAG : -1;\n    data += roi.x * elemSize();\n\n    CV_Assert(0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows);\n\n    if (refcount)\n        CV_XADD(refcount, 1);\n\n    if (rows <= 0 || cols <= 0)\n        rows = cols = 0;\n}\n\ncv::gpu::GpuMat::GpuMat(const Mat& m) :\n    flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)\n{\n    upload(m);\n}\n\nGpuMat& cv::gpu::GpuMat::operator = (const GpuMat& m)\n{\n    if (this != &m)\n    {\n        GpuMat temp(m);\n        swap(temp);\n    }\n\n    return *this;\n}\n\nvoid cv::gpu::GpuMat::swap(GpuMat& b)\n{\n    std::swap(flags, b.flags);\n    std::swap(rows, b.rows);\n    std::swap(cols, b.cols);\n    std::swap(step, b.step);\n    std::swap(data, b.data);\n    std::swap(datastart, b.datastart);\n    std::swap(dataend, b.dataend);\n    std::swap(refcount, b.refcount);\n}\n\nvoid cv::gpu::GpuMat::locateROI(Size& wholeSize, Point& ofs) const\n{\n    size_t esz = elemSize();\n    ptrdiff_t delta1 = data - datastart;\n    ptrdiff_t delta2 = dataend - datastart;\n\n    CV_DbgAssert(step > 0);\n\n    if (delta1 == 0)\n        ofs.x = ofs.y = 0;\n    else\n    {\n        ofs.y = static_cast<int>(delta1 / step);\n        ofs.x = static_cast<int>((delta1 - step * ofs.y) / esz);\n\n        CV_DbgAssert(data == datastart + ofs.y * step + ofs.x * esz);\n    }\n\n    size_t minstep = (ofs.x + cols) * esz;\n\n    wholeSize.height = std::max(static_cast<int>((delta2 - minstep) / step + 1), ofs.y + rows);\n    wholeSize.width = std::max(static_cast<int>((delta2 - step * (wholeSize.height - 1)) / esz), ofs.x + cols);\n}\n\nGpuMat& cv::gpu::GpuMat::adjustROI(int dtop, int dbottom, int dleft, int dright)\n{\n    Size wholeSize;\n    Point ofs;\n    locateROI(wholeSize, ofs);\n\n    size_t esz = elemSize();\n\n    int row1 = std::max(ofs.y - dtop, 0);\n    int row2 = std::min(ofs.y + rows + dbottom, wholeSize.height);\n\n    int col1 = std::max(ofs.x - dleft, 0);\n    int col2 = std::min(ofs.x + cols + dright, wholeSize.width);\n\n    data += (row1 - ofs.y) * step + (col1 - ofs.x) * esz;\n    rows = row2 - row1;\n    cols = col2 - col1;\n\n    if (esz * cols == step || rows == 1)\n        flags |= Mat::CONTINUOUS_FLAG;\n    else\n        flags &= ~Mat::CONTINUOUS_FLAG;\n\n    return *this;\n}\n\nGpuMat cv::gpu::GpuMat::reshape(int new_cn, int new_rows) const\n{\n    GpuMat hdr = *this;\n\n    int cn = channels();\n    if (new_cn == 0)\n        new_cn = cn;\n\n    int total_width = cols * cn;\n\n    if ((new_cn > total_width || total_width % new_cn != 0) && new_rows == 0)\n        new_rows = rows * total_width / new_cn;\n\n    if (new_rows != 0 && new_rows != rows)\n    {\n        int total_size = total_width * rows;\n\n        if (!isContinuous())\n            CV_Error(CV_BadStep, \"The matrix is not continuous, thus its number of rows can not be changed\");\n\n        if ((unsigned)new_rows > (unsigned)total_size)\n            CV_Error(CV_StsOutOfRange, \"Bad new number of rows\");\n\n        total_width = total_size / new_rows;\n\n        if (total_width * new_rows != total_size)\n            CV_Error(CV_StsBadArg, \"The total number of matrix elements is not divisible by the new number of rows\");\n\n        hdr.rows = new_rows;\n        hdr.step = total_width * elemSize1();\n    }\n\n    int new_width = total_width / new_cn;\n\n    if (new_width * new_cn != total_width)\n        CV_Error(CV_BadNumChannels, \"The total width is not divisible by the new number of channels\");\n\n    hdr.cols = new_width;\n    hdr.flags = (hdr.flags & ~CV_MAT_CN_MASK) | ((new_cn - 1) << CV_CN_SHIFT);\n\n    return hdr;\n}\n\ncv::Mat::Mat(const GpuMat& m) : flags(0), dims(0), rows(0), cols(0), data(0), refcount(0), datastart(0), dataend(0), datalimit(0), allocator(0), size(&rows)\n{\n    m.download(*this);\n}\n\nvoid cv::gpu::createContinuous(int rows, int cols, int type, GpuMat& m)\n{\n    int area = rows * cols;\n    if (m.empty() || m.type() != type || !m.isContinuous() || m.size().area() < area)\n        m.create(1, area, type);\n\n    m.cols = cols;\n    m.rows = rows;\n    m.step = m.elemSize() * cols;\n    m.flags |= Mat::CONTINUOUS_FLAG;\n}\n\nvoid cv::gpu::ensureSizeIsEnough(int rows, int cols, int type, GpuMat& m)\n{\n    if (m.empty() || m.type() != type || m.data != m.datastart)\n        m.create(rows, cols, type);\n    else\n    {\n        const size_t esz = m.elemSize();\n        const ptrdiff_t delta2 = m.dataend - m.datastart;\n\n        const size_t minstep = m.cols * esz;\n\n        Size wholeSize;\n        wholeSize.height = std::max(static_cast<int>((delta2 - minstep) / m.step + 1), m.rows);\n        wholeSize.width = std::max(static_cast<int>((delta2 - m.step * (wholeSize.height - 1)) / esz), m.cols);\n\n        if (wholeSize.height < rows || wholeSize.width < cols)\n            m.create(rows, cols, type);\n        else\n        {\n            m.cols = cols;\n            m.rows = rows;\n        }\n    }\n}\n\nGpuMat cv::gpu::allocMatFromBuf(int rows, int cols, int type, GpuMat &mat)\n{\n    if (!mat.empty() && mat.type() == type && mat.rows >= rows && mat.cols >= cols)\n        return mat(Rect(0, 0, cols, rows));\n    return mat = GpuMat(rows, cols, type);\n}\n\nvoid cv::gpu::GpuMat::upload(const Mat& m)\n{\n    CV_DbgAssert(!m.empty());\n\n    create(m.size(), m.type());\n\n    gpuFuncTable()->copy(m, *this);\n}\n\nvoid cv::gpu::GpuMat::download(Mat& m) const\n{\n    CV_DbgAssert(!empty());\n\n    m.create(size(), type());\n\n    gpuFuncTable()->copy(*this, m);\n}\n\nvoid cv::gpu::GpuMat::copyTo(GpuMat& m) const\n{\n    CV_DbgAssert(!empty());\n\n    m.create(size(), type());\n\n    gpuFuncTable()->copy(*this, m);\n}\n\nvoid cv::gpu::GpuMat::copyTo(GpuMat& mat, const GpuMat& mask) const\n{\n    if (mask.empty())\n    {\n        copyTo(mat);\n    }\n    else\n    {\n        uchar* data0 = mat.data;\n\n        mat.create(size(), type());\n\n        // do not leave dst uninitialized\n        if (mat.data != data0)\n            mat.setTo(Scalar::all(0));\n\n        gpuFuncTable()->copyWithMask(*this, mat, mask);\n    }\n}\n\nvoid cv::gpu::GpuMat::convertTo(GpuMat& dst, int rtype, double alpha, double beta) const\n{\n    bool noScale = fabs(alpha - 1) < numeric_limits<double>::epsilon() && fabs(beta) < numeric_limits<double>::epsilon();\n\n    if (rtype < 0)\n        rtype = type();\n    else\n        rtype = CV_MAKETYPE(CV_MAT_DEPTH(rtype), channels());\n\n    int sdepth = depth();\n    int ddepth = CV_MAT_DEPTH(rtype);\n    if (sdepth == ddepth && noScale)\n    {\n        copyTo(dst);\n        return;\n    }\n\n    GpuMat temp;\n    const GpuMat* psrc = this;\n    if (sdepth != ddepth && psrc == &dst)\n    {\n        temp = *this;\n        psrc = &temp;\n    }\n\n    dst.create(size(), rtype);\n\n    if (noScale)\n        cv::gpu::convertTo(*psrc, dst);\n    else\n        cv::gpu::convertTo(*psrc, dst, alpha, beta);\n}\n\nGpuMat& cv::gpu::GpuMat::setTo(Scalar s, const GpuMat& mask)\n{\n    CV_Assert(mask.empty() || mask.type() == CV_8UC1);\n    CV_DbgAssert(!empty());\n\n    gpu::setTo(*this, s, mask);\n\n    return *this;\n}\n\nvoid cv::gpu::GpuMat::create(int _rows, int _cols, int _type)\n{\n    _type &= TYPE_MASK;\n\n    if (rows == _rows && cols == _cols && type() == _type && data)\n        return;\n\n    if (data)\n        release();\n\n    CV_DbgAssert(_rows >= 0 && _cols >= 0);\n\n    if (_rows > 0 && _cols > 0)\n    {\n        flags = Mat::MAGIC_VAL + _type;\n        rows = _rows;\n        cols = _cols;\n\n        size_t esz = elemSize();\n\n        void* devPtr;\n        gpuFuncTable()->mallocPitch(&devPtr, &step, esz * cols, rows);\n\n        // Single row must be continuous\n        if (rows == 1)\n            step = esz * cols;\n\n        if (esz * cols == step)\n            flags |= Mat::CONTINUOUS_FLAG;\n\n        int64 _nettosize = static_cast<int64>(step) * rows;\n        size_t nettosize = static_cast<size_t>(_nettosize);\n\n        datastart = data = static_cast<uchar*>(devPtr);\n        dataend = data + nettosize;\n\n        refcount = static_cast<int*>(fastMalloc(sizeof(*refcount)));\n        *refcount = 1;\n    }\n}\n\nvoid cv::gpu::GpuMat::release()\n{\n    if (refcount && CV_XADD(refcount, -1) == 1)\n    {\n        fastFree(refcount);\n\n        gpuFuncTable()->free(datastart);\n    }\n\n    data = datastart = dataend = 0;\n    step = rows = cols = 0;\n    refcount = 0;\n}\n\nnamespace cv { namespace gpu\n{\n    void convertTo(const GpuMat& src, GpuMat& dst)\n    {\n        gpuFuncTable()->convert(src, dst);\n    }\n\n    void convertTo(const GpuMat& src, GpuMat& dst, double alpha, double beta, cudaStream_t stream)\n    {\n        gpuFuncTable()->convert(src, dst, alpha, beta, stream);\n    }\n\n    void setTo(GpuMat& src, Scalar s, cudaStream_t stream)\n    {\n        gpuFuncTable()->setTo(src, s, cv::gpu::GpuMat(), stream);\n    }\n\n    void setTo(GpuMat& src, Scalar s, const GpuMat& mask, cudaStream_t stream)\n    {\n        gpuFuncTable()->setTo(src, s, mask, stream);\n    }\n\n    void setTo(GpuMat& src, Scalar s)\n    {\n        setTo(src, s, 0);\n    }\n\n    void setTo(GpuMat& src, Scalar s, const GpuMat& mask)\n    {\n        setTo(src, s, mask, 0);\n    }\n}}\n\n////////////////////////////////////////////////////////////////////////\n// Error handling\n\nvoid cv::gpu::error(const char *error_string, const char *file, const int line, const char *func)\n{\n    int code = CV_GpuApiCallError;\n\n    if (uncaught_exception())\n    {\n        const char* errorStr = cvErrorStr(code);\n        const char* function = func ? func : \"unknown function\";\n\n        cerr << \"OpenCV Error: \" << errorStr << \"(\" << error_string << \") in \" << function << \", file \" << file << \", line \" << line;\n        cerr.flush();\n    }\n    else\n        cv::error( cv::Exception(code, error_string, func, file, line) );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/src/cl_runtime/clamdfft_runtime.cpp": "//\n// AUTOGENERATED, DO NOT EDIT\n//\n#include \"precomp.hpp\"\n\n#ifdef HAVE_CLAMDFFT\n\n#include \"opencv2/ocl/cl_runtime/cl_runtime.hpp\"\n#include \"opencv2/ocl/cl_runtime/clamdfft_runtime.hpp\"\n\n#if defined(_WIN32)\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdFft.Runtime.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdFft.Runtime.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdFft.Runtime.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\n// generated by parser_clamdfft.py\nenum OPENCLAMDFFT_FN_ID {\n    OPENCLAMDFFT_FN_clAmdFftSetup = 0,\n    OPENCLAMDFFT_FN_clAmdFftTeardown,\n    OPENCLAMDFFT_FN_clAmdFftGetVersion,\n    OPENCLAMDFFT_FN_clAmdFftCreateDefaultPlan,\n    OPENCLAMDFFT_FN_clAmdFftCopyPlan,\n    OPENCLAMDFFT_FN_clAmdFftBakePlan,\n    OPENCLAMDFFT_FN_clAmdFftDestroyPlan,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanContext,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanPrecision,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanPrecision,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanScale,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanScale,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanBatchSize,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanBatchSize,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanDim,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanDim,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanLength,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanLength,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanInStride,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanInStride,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanOutStride,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanOutStride,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanDistance,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanDistance,\n    OPENCLAMDFFT_FN_clAmdFftGetLayout,\n    OPENCLAMDFFT_FN_clAmdFftSetLayout,\n    OPENCLAMDFFT_FN_clAmdFftGetResultLocation,\n    OPENCLAMDFFT_FN_clAmdFftSetResultLocation,\n    OPENCLAMDFFT_FN_clAmdFftGetPlanTransposeResult,\n    OPENCLAMDFFT_FN_clAmdFftSetPlanTransposeResult,\n    OPENCLAMDFFT_FN_clAmdFftGetTmpBufSize,\n    OPENCLAMDFFT_FN_clAmdFftEnqueueTransform,\n};\n// generated by parser_clamdfft.py\nconst char* openclamdfft_fn_names[] = {\n    \"clAmdFftSetup\",\n    \"clAmdFftTeardown\",\n    \"clAmdFftGetVersion\",\n    \"clAmdFftCreateDefaultPlan\",\n    \"clAmdFftCopyPlan\",\n    \"clAmdFftBakePlan\",\n    \"clAmdFftDestroyPlan\",\n    \"clAmdFftGetPlanContext\",\n    \"clAmdFftGetPlanPrecision\",\n    \"clAmdFftSetPlanPrecision\",\n    \"clAmdFftGetPlanScale\",\n    \"clAmdFftSetPlanScale\",\n    \"clAmdFftGetPlanBatchSize\",\n    \"clAmdFftSetPlanBatchSize\",\n    \"clAmdFftGetPlanDim\",\n    \"clAmdFftSetPlanDim\",\n    \"clAmdFftGetPlanLength\",\n    \"clAmdFftSetPlanLength\",\n    \"clAmdFftGetPlanInStride\",\n    \"clAmdFftSetPlanInStride\",\n    \"clAmdFftGetPlanOutStride\",\n    \"clAmdFftSetPlanOutStride\",\n    \"clAmdFftGetPlanDistance\",\n    \"clAmdFftSetPlanDistance\",\n    \"clAmdFftGetLayout\",\n    \"clAmdFftSetLayout\",\n    \"clAmdFftGetResultLocation\",\n    \"clAmdFftSetResultLocation\",\n    \"clAmdFftGetPlanTransposeResult\",\n    \"clAmdFftSetPlanTransposeResult\",\n    \"clAmdFftGetTmpBufSize\",\n    \"clAmdFftEnqueueTransform\",\n};\n\nstatic void* openclamdfft_check_fn(int ID)\n{\n    void* func = CV_CL_GET_PROC_ADDRESS(openclamdfft_fn_names[ID]);\n    if (!func)\n    {\n        std::ostringstream msg;\n        msg << \"OpenCL AMD FFT function is not available: [\" << openclamdfft_fn_names[ID] << \"]\";\n        CV_Error(CV_StsBadFunc, msg.str());\n    }\n    extern void* openclamdfft_fn_ptrs[];\n    *(void**)(openclamdfft_fn_ptrs[ID]) = func;\n    return func;\n}\n\nnamespace {\n// generated by parser_clamdfft.py\ntemplate <int ID, typename _R>\nstruct openclamdfft_fn0\n{\n    typedef _R (*FN)();\n    static _R switch_fn()\n    { return ((FN)openclamdfft_check_fn(ID))(); }\n};\n\ntemplate <int ID, typename _R, typename _T1>\nstruct openclamdfft_fn1\n{\n    typedef _R (*FN)(_T1);\n    static _R switch_fn(_T1 p1)\n    { return ((FN)openclamdfft_check_fn(ID))(p1); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2>\nstruct openclamdfft_fn2\n{\n    typedef _R (*FN)(_T1, _T2);\n    static _R switch_fn(_T1 p1, _T2 p2)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3>\nstruct openclamdfft_fn3\n{\n    typedef _R (*FN)(_T1, _T2, _T3);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4>\nstruct openclamdfft_fn4\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5>\nstruct openclamdfft_fn5\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6>\nstruct openclamdfft_fn6\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7>\nstruct openclamdfft_fn7\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8>\nstruct openclamdfft_fn8\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9>\nstruct openclamdfft_fn9\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10>\nstruct openclamdfft_fn10\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11>\nstruct openclamdfft_fn11\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12>\nstruct openclamdfft_fn12\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13>\nstruct openclamdfft_fn13\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14>\nstruct openclamdfft_fn14\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15>\nstruct openclamdfft_fn15\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16>\nstruct openclamdfft_fn16\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17>\nstruct openclamdfft_fn17\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18>\nstruct openclamdfft_fn18\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19>\nstruct openclamdfft_fn19\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20>\nstruct openclamdfft_fn20\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20, typename _T21>\nstruct openclamdfft_fn21\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20, _T21);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20, _T21 p21)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20, typename _T21, typename _T22>\nstruct openclamdfft_fn22\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20, _T21, _T22);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20, _T21 p21, _T22 p22)\n    { return ((FN)openclamdfft_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); }\n};\n\n}\n\n// generated by parser_clamdfft.py\nclAmdFftStatus (*clAmdFftSetup)(const clAmdFftSetupData*) = openclamdfft_fn1<OPENCLAMDFFT_FN_clAmdFftSetup, clAmdFftStatus, const clAmdFftSetupData*>::switch_fn;\nclAmdFftStatus (*clAmdFftTeardown)() = openclamdfft_fn0<OPENCLAMDFFT_FN_clAmdFftTeardown, clAmdFftStatus>::switch_fn;\nclAmdFftStatus (*clAmdFftGetVersion)(cl_uint*, cl_uint*, cl_uint*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetVersion, clAmdFftStatus, cl_uint*, cl_uint*, cl_uint*>::switch_fn;\nclAmdFftStatus (*clAmdFftCreateDefaultPlan)(clAmdFftPlanHandle*, cl_context, const clAmdFftDim, const size_t*) = openclamdfft_fn4<OPENCLAMDFFT_FN_clAmdFftCreateDefaultPlan, clAmdFftStatus, clAmdFftPlanHandle*, cl_context, const clAmdFftDim, const size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftCopyPlan)(clAmdFftPlanHandle*, cl_context, clAmdFftPlanHandle) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftCopyPlan, clAmdFftStatus, clAmdFftPlanHandle*, cl_context, clAmdFftPlanHandle>::switch_fn;\nclAmdFftStatus (*clAmdFftBakePlan)(clAmdFftPlanHandle, cl_uint, cl_command_queue*, void (CL_CALLBACK*) (clAmdFftPlanHandle plHandle, void* user_data), void*) = openclamdfft_fn5<OPENCLAMDFFT_FN_clAmdFftBakePlan, clAmdFftStatus, clAmdFftPlanHandle, cl_uint, cl_command_queue*, void (CL_CALLBACK*) (clAmdFftPlanHandle plHandle, void* user_data), void*>::switch_fn;\nclAmdFftStatus (*clAmdFftDestroyPlan)(clAmdFftPlanHandle*) = openclamdfft_fn1<OPENCLAMDFFT_FN_clAmdFftDestroyPlan, clAmdFftStatus, clAmdFftPlanHandle*>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanContext)(const clAmdFftPlanHandle, cl_context*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetPlanContext, clAmdFftStatus, const clAmdFftPlanHandle, cl_context*>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanPrecision)(const clAmdFftPlanHandle, clAmdFftPrecision*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetPlanPrecision, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftPrecision*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanPrecision)(clAmdFftPlanHandle, clAmdFftPrecision) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftSetPlanPrecision, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftPrecision>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanScale)(const clAmdFftPlanHandle, clAmdFftDirection, cl_float*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanScale, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftDirection, cl_float*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanScale)(clAmdFftPlanHandle, clAmdFftDirection, cl_float) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetPlanScale, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftDirection, cl_float>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanBatchSize)(const clAmdFftPlanHandle, size_t*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetPlanBatchSize, clAmdFftStatus, const clAmdFftPlanHandle, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanBatchSize)(clAmdFftPlanHandle, size_t) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftSetPlanBatchSize, clAmdFftStatus, clAmdFftPlanHandle, size_t>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanDim)(const clAmdFftPlanHandle, clAmdFftDim*, cl_uint*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanDim, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftDim*, cl_uint*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanDim)(clAmdFftPlanHandle, const clAmdFftDim) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftSetPlanDim, clAmdFftStatus, clAmdFftPlanHandle, const clAmdFftDim>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanLength)(const clAmdFftPlanHandle, const clAmdFftDim, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanLength, clAmdFftStatus, const clAmdFftPlanHandle, const clAmdFftDim, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanLength)(clAmdFftPlanHandle, const clAmdFftDim, const size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetPlanLength, clAmdFftStatus, clAmdFftPlanHandle, const clAmdFftDim, const size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanInStride)(const clAmdFftPlanHandle, const clAmdFftDim, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanInStride, clAmdFftStatus, const clAmdFftPlanHandle, const clAmdFftDim, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanInStride)(clAmdFftPlanHandle, const clAmdFftDim, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetPlanInStride, clAmdFftStatus, clAmdFftPlanHandle, const clAmdFftDim, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanOutStride)(const clAmdFftPlanHandle, const clAmdFftDim, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanOutStride, clAmdFftStatus, const clAmdFftPlanHandle, const clAmdFftDim, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanOutStride)(clAmdFftPlanHandle, const clAmdFftDim, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetPlanOutStride, clAmdFftStatus, clAmdFftPlanHandle, const clAmdFftDim, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanDistance)(const clAmdFftPlanHandle, size_t*, size_t*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetPlanDistance, clAmdFftStatus, const clAmdFftPlanHandle, size_t*, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanDistance)(clAmdFftPlanHandle, size_t, size_t) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetPlanDistance, clAmdFftStatus, clAmdFftPlanHandle, size_t, size_t>::switch_fn;\nclAmdFftStatus (*clAmdFftGetLayout)(const clAmdFftPlanHandle, clAmdFftLayout*, clAmdFftLayout*) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftGetLayout, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftLayout*, clAmdFftLayout*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetLayout)(clAmdFftPlanHandle, clAmdFftLayout, clAmdFftLayout) = openclamdfft_fn3<OPENCLAMDFFT_FN_clAmdFftSetLayout, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftLayout, clAmdFftLayout>::switch_fn;\nclAmdFftStatus (*clAmdFftGetResultLocation)(const clAmdFftPlanHandle, clAmdFftResultLocation*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetResultLocation, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftResultLocation*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetResultLocation)(clAmdFftPlanHandle, clAmdFftResultLocation) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftSetResultLocation, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftResultLocation>::switch_fn;\nclAmdFftStatus (*clAmdFftGetPlanTransposeResult)(const clAmdFftPlanHandle, clAmdFftResultTransposed*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetPlanTransposeResult, clAmdFftStatus, const clAmdFftPlanHandle, clAmdFftResultTransposed*>::switch_fn;\nclAmdFftStatus (*clAmdFftSetPlanTransposeResult)(clAmdFftPlanHandle, clAmdFftResultTransposed) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftSetPlanTransposeResult, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftResultTransposed>::switch_fn;\nclAmdFftStatus (*clAmdFftGetTmpBufSize)(const clAmdFftPlanHandle, size_t*) = openclamdfft_fn2<OPENCLAMDFFT_FN_clAmdFftGetTmpBufSize, clAmdFftStatus, const clAmdFftPlanHandle, size_t*>::switch_fn;\nclAmdFftStatus (*clAmdFftEnqueueTransform)(clAmdFftPlanHandle, clAmdFftDirection, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*, cl_mem*, cl_mem*, cl_mem) = openclamdfft_fn10<OPENCLAMDFFT_FN_clAmdFftEnqueueTransform, clAmdFftStatus, clAmdFftPlanHandle, clAmdFftDirection, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*, cl_mem*, cl_mem*, cl_mem>::switch_fn;\n\n// generated by parser_clamdfft.py\nvoid* openclamdfft_fn_ptrs[] = {\n    &clAmdFftSetup,\n    &clAmdFftTeardown,\n    &clAmdFftGetVersion,\n    &clAmdFftCreateDefaultPlan,\n    &clAmdFftCopyPlan,\n    &clAmdFftBakePlan,\n    &clAmdFftDestroyPlan,\n    &clAmdFftGetPlanContext,\n    &clAmdFftGetPlanPrecision,\n    &clAmdFftSetPlanPrecision,\n    &clAmdFftGetPlanScale,\n    &clAmdFftSetPlanScale,\n    &clAmdFftGetPlanBatchSize,\n    &clAmdFftSetPlanBatchSize,\n    &clAmdFftGetPlanDim,\n    &clAmdFftSetPlanDim,\n    &clAmdFftGetPlanLength,\n    &clAmdFftSetPlanLength,\n    &clAmdFftGetPlanInStride,\n    &clAmdFftSetPlanInStride,\n    &clAmdFftGetPlanOutStride,\n    &clAmdFftSetPlanOutStride,\n    &clAmdFftGetPlanDistance,\n    &clAmdFftSetPlanDistance,\n    &clAmdFftGetLayout,\n    &clAmdFftSetLayout,\n    &clAmdFftGetResultLocation,\n    &clAmdFftSetResultLocation,\n    &clAmdFftGetPlanTransposeResult,\n    &clAmdFftSetPlanTransposeResult,\n    &clAmdFftGetTmpBufSize,\n    &clAmdFftEnqueueTransform,\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/src/cl_runtime/cl_runtime.cpp": "#include \"precomp.hpp\"\n\n#if defined(HAVE_OPENCL) && !defined(HAVE_OPENCL_STATIC)\n\n#include \"opencv2/ocl/cl_runtime/cl_runtime.hpp\"\n\n#if defined(__APPLE__)\n    #include <dlfcn.h>\n\n    static void* AppleCLGetProcAddress(const char* name)\n    {\n        static void * image = NULL;\n        if (!image)\n        {\n            image = dlopen(\"/System/Library/Frameworks/OpenCL.framework/Versions/Current/OpenCL\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!image)\n                return NULL;\n        }\n\n        return dlsym(image, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) AppleCLGetProcAddress(name)\n#endif // __APPLE__\n\n#if defined(_WIN32)\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"OpenCL.dll\");\n            if (!opencl_module)\n            {\n                const char* name = \"OpenCL.dll\";\n                const char* envOpenCLBinary = getenv(\"OPENCV_OPENCL_BINARY\");\n                if (envOpenCLBinary)\n                    name = envOpenCLBinary;\n                opencl_module = LoadLibraryA(name);\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            const char* name = \"libOpenCL.so\";\n            const char* envOpenCLBinary = getenv(\"OPENCV_OPENCL_BINARY\");\n            if (envOpenCLBinary)\n                name = envOpenCLBinary;\n            h = dlopen(name, RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\nstatic void* opencl_check_fn(int ID)\n{\n    extern const char* opencl_fn_names[];\n    void* func = CV_CL_GET_PROC_ADDRESS(opencl_fn_names[ID]);\n    if (!func)\n    {\n        std::ostringstream msg;\n        msg << \"OpenCL function is not available: [\" << opencl_fn_names[ID] << \"]\";\n        CV_Error(CV_StsBadFunc, msg.str());\n    }\n    extern void* opencl_fn_ptrs[];\n    *(void**)(opencl_fn_ptrs[ID]) = func;\n    return func;\n}\n\n#include \"cl_runtime_opencl_impl.hpp\"\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/src/cl_runtime/clamdblas_runtime.cpp": "//\n// AUTOGENERATED, DO NOT EDIT\n//\n#include \"precomp.hpp\"\n\n#ifdef HAVE_CLAMDBLAS\n\n#include \"opencv2/ocl/cl_runtime/cl_runtime.hpp\"\n#include \"opencv2/ocl/cl_runtime/clamdblas_runtime.hpp\"\n\n#if defined(_WIN32)\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdBlas.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdBlas.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdBlas.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\n// generated by parser_clamdblas.py\nenum OPENCLAMDBLAS_FN_ID {\n    OPENCLAMDBLAS_FN_clAmdBlasGetVersion = 0,\n    OPENCLAMDBLAS_FN_clAmdBlasSetup,\n    OPENCLAMDBLAS_FN_clAmdBlasTeardown,\n    OPENCLAMDBLAS_FN_clAmdBlasAddScratchImage,\n    OPENCLAMDBLAS_FN_clAmdBlasRemoveScratchImage,\n    OPENCLAMDBLAS_FN_clAmdBlasSswap,\n    OPENCLAMDBLAS_FN_clAmdBlasDswap,\n    OPENCLAMDBLAS_FN_clAmdBlasCswap,\n    OPENCLAMDBLAS_FN_clAmdBlasZswap,\n    OPENCLAMDBLAS_FN_clAmdBlasSscal,\n    OPENCLAMDBLAS_FN_clAmdBlasDscal,\n    OPENCLAMDBLAS_FN_clAmdBlasCscal,\n    OPENCLAMDBLAS_FN_clAmdBlasZscal,\n    OPENCLAMDBLAS_FN_clAmdBlasCsscal,\n    OPENCLAMDBLAS_FN_clAmdBlasZdscal,\n    OPENCLAMDBLAS_FN_clAmdBlasScopy,\n    OPENCLAMDBLAS_FN_clAmdBlasDcopy,\n    OPENCLAMDBLAS_FN_clAmdBlasCcopy,\n    OPENCLAMDBLAS_FN_clAmdBlasZcopy,\n    OPENCLAMDBLAS_FN_clAmdBlasSaxpy,\n    OPENCLAMDBLAS_FN_clAmdBlasDaxpy,\n    OPENCLAMDBLAS_FN_clAmdBlasCaxpy,\n    OPENCLAMDBLAS_FN_clAmdBlasZaxpy,\n    OPENCLAMDBLAS_FN_clAmdBlasSdot,\n    OPENCLAMDBLAS_FN_clAmdBlasDdot,\n    OPENCLAMDBLAS_FN_clAmdBlasCdotu,\n    OPENCLAMDBLAS_FN_clAmdBlasZdotu,\n    OPENCLAMDBLAS_FN_clAmdBlasCdotc,\n    OPENCLAMDBLAS_FN_clAmdBlasZdotc,\n    OPENCLAMDBLAS_FN_clAmdBlasSrotg,\n    OPENCLAMDBLAS_FN_clAmdBlasDrotg,\n    OPENCLAMDBLAS_FN_clAmdBlasCrotg,\n    OPENCLAMDBLAS_FN_clAmdBlasZrotg,\n    OPENCLAMDBLAS_FN_clAmdBlasSrotmg,\n    OPENCLAMDBLAS_FN_clAmdBlasDrotmg,\n    OPENCLAMDBLAS_FN_clAmdBlasSrot,\n    OPENCLAMDBLAS_FN_clAmdBlasDrot,\n    OPENCLAMDBLAS_FN_clAmdBlasCsrot,\n    OPENCLAMDBLAS_FN_clAmdBlasZdrot,\n    OPENCLAMDBLAS_FN_clAmdBlasSrotm,\n    OPENCLAMDBLAS_FN_clAmdBlasDrotm,\n    OPENCLAMDBLAS_FN_clAmdBlasSnrm2,\n    OPENCLAMDBLAS_FN_clAmdBlasDnrm2,\n    OPENCLAMDBLAS_FN_clAmdBlasScnrm2,\n    OPENCLAMDBLAS_FN_clAmdBlasDznrm2,\n    OPENCLAMDBLAS_FN_clAmdBlasiSamax,\n    OPENCLAMDBLAS_FN_clAmdBlasiDamax,\n    OPENCLAMDBLAS_FN_clAmdBlasiCamax,\n    OPENCLAMDBLAS_FN_clAmdBlasiZamax,\n    OPENCLAMDBLAS_FN_clAmdBlasSasum,\n    OPENCLAMDBLAS_FN_clAmdBlasDasum,\n    OPENCLAMDBLAS_FN_clAmdBlasScasum,\n    OPENCLAMDBLAS_FN_clAmdBlasDzasum,\n    OPENCLAMDBLAS_FN_clAmdBlasSgemv,\n    OPENCLAMDBLAS_FN_clAmdBlasDgemv,\n    OPENCLAMDBLAS_FN_clAmdBlasCgemv,\n    OPENCLAMDBLAS_FN_clAmdBlasZgemv,\n    OPENCLAMDBLAS_FN_clAmdBlasSgemvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDgemvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCgemvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZgemvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasSsymv,\n    OPENCLAMDBLAS_FN_clAmdBlasDsymv,\n    OPENCLAMDBLAS_FN_clAmdBlasSsymvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDsymvEx,\n    OPENCLAMDBLAS_FN_clAmdBlasChemv,\n    OPENCLAMDBLAS_FN_clAmdBlasZhemv,\n    OPENCLAMDBLAS_FN_clAmdBlasStrmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrmv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrmv,\n    OPENCLAMDBLAS_FN_clAmdBlasStrsv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrsv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrsv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrsv,\n    OPENCLAMDBLAS_FN_clAmdBlasSger,\n    OPENCLAMDBLAS_FN_clAmdBlasDger,\n    OPENCLAMDBLAS_FN_clAmdBlasCgeru,\n    OPENCLAMDBLAS_FN_clAmdBlasZgeru,\n    OPENCLAMDBLAS_FN_clAmdBlasCgerc,\n    OPENCLAMDBLAS_FN_clAmdBlasZgerc,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyr,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyr,\n    OPENCLAMDBLAS_FN_clAmdBlasCher,\n    OPENCLAMDBLAS_FN_clAmdBlasZher,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyr2,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyr2,\n    OPENCLAMDBLAS_FN_clAmdBlasCher2,\n    OPENCLAMDBLAS_FN_clAmdBlasZher2,\n    OPENCLAMDBLAS_FN_clAmdBlasStpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasStpsv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtpsv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtpsv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtpsv,\n    OPENCLAMDBLAS_FN_clAmdBlasSspmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDspmv,\n    OPENCLAMDBLAS_FN_clAmdBlasChpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZhpmv,\n    OPENCLAMDBLAS_FN_clAmdBlasSspr,\n    OPENCLAMDBLAS_FN_clAmdBlasDspr,\n    OPENCLAMDBLAS_FN_clAmdBlasChpr,\n    OPENCLAMDBLAS_FN_clAmdBlasZhpr,\n    OPENCLAMDBLAS_FN_clAmdBlasSspr2,\n    OPENCLAMDBLAS_FN_clAmdBlasDspr2,\n    OPENCLAMDBLAS_FN_clAmdBlasChpr2,\n    OPENCLAMDBLAS_FN_clAmdBlasZhpr2,\n    OPENCLAMDBLAS_FN_clAmdBlasSgbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDgbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasCgbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZgbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasStbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasSsbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasDsbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasChbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasZhbmv,\n    OPENCLAMDBLAS_FN_clAmdBlasStbsv,\n    OPENCLAMDBLAS_FN_clAmdBlasDtbsv,\n    OPENCLAMDBLAS_FN_clAmdBlasCtbsv,\n    OPENCLAMDBLAS_FN_clAmdBlasZtbsv,\n    OPENCLAMDBLAS_FN_clAmdBlasSgemm,\n    OPENCLAMDBLAS_FN_clAmdBlasDgemm,\n    OPENCLAMDBLAS_FN_clAmdBlasCgemm,\n    OPENCLAMDBLAS_FN_clAmdBlasZgemm,\n    OPENCLAMDBLAS_FN_clAmdBlasSgemmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDgemmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCgemmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZgemmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasStrmm,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrmm,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrmm,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrmm,\n    OPENCLAMDBLAS_FN_clAmdBlasStrmmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrmmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrmmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrmmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasStrsm,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrsm,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrsm,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrsm,\n    OPENCLAMDBLAS_FN_clAmdBlasStrsmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDtrsmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCtrsmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZtrsmEx,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyrk,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyrk,\n    OPENCLAMDBLAS_FN_clAmdBlasCsyrk,\n    OPENCLAMDBLAS_FN_clAmdBlasZsyrk,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyrkEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyrkEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCsyrkEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZsyrkEx,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyr2k,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyr2k,\n    OPENCLAMDBLAS_FN_clAmdBlasCsyr2k,\n    OPENCLAMDBLAS_FN_clAmdBlasZsyr2k,\n    OPENCLAMDBLAS_FN_clAmdBlasSsyr2kEx,\n    OPENCLAMDBLAS_FN_clAmdBlasDsyr2kEx,\n    OPENCLAMDBLAS_FN_clAmdBlasCsyr2kEx,\n    OPENCLAMDBLAS_FN_clAmdBlasZsyr2kEx,\n    OPENCLAMDBLAS_FN_clAmdBlasSsymm,\n    OPENCLAMDBLAS_FN_clAmdBlasDsymm,\n    OPENCLAMDBLAS_FN_clAmdBlasCsymm,\n    OPENCLAMDBLAS_FN_clAmdBlasZsymm,\n    OPENCLAMDBLAS_FN_clAmdBlasChemm,\n    OPENCLAMDBLAS_FN_clAmdBlasZhemm,\n    OPENCLAMDBLAS_FN_clAmdBlasCherk,\n    OPENCLAMDBLAS_FN_clAmdBlasZherk,\n    OPENCLAMDBLAS_FN_clAmdBlasCher2k,\n    OPENCLAMDBLAS_FN_clAmdBlasZher2k,\n};\n// generated by parser_clamdblas.py\nconst char* openclamdblas_fn_names[] = {\n    \"clAmdBlasGetVersion\",\n    \"clAmdBlasSetup\",\n    \"clAmdBlasTeardown\",\n    \"clAmdBlasAddScratchImage\",\n    \"clAmdBlasRemoveScratchImage\",\n    \"clAmdBlasSswap\",\n    \"clAmdBlasDswap\",\n    \"clAmdBlasCswap\",\n    \"clAmdBlasZswap\",\n    \"clAmdBlasSscal\",\n    \"clAmdBlasDscal\",\n    \"clAmdBlasCscal\",\n    \"clAmdBlasZscal\",\n    \"clAmdBlasCsscal\",\n    \"clAmdBlasZdscal\",\n    \"clAmdBlasScopy\",\n    \"clAmdBlasDcopy\",\n    \"clAmdBlasCcopy\",\n    \"clAmdBlasZcopy\",\n    \"clAmdBlasSaxpy\",\n    \"clAmdBlasDaxpy\",\n    \"clAmdBlasCaxpy\",\n    \"clAmdBlasZaxpy\",\n    \"clAmdBlasSdot\",\n    \"clAmdBlasDdot\",\n    \"clAmdBlasCdotu\",\n    \"clAmdBlasZdotu\",\n    \"clAmdBlasCdotc\",\n    \"clAmdBlasZdotc\",\n    \"clAmdBlasSrotg\",\n    \"clAmdBlasDrotg\",\n    \"clAmdBlasCrotg\",\n    \"clAmdBlasZrotg\",\n    \"clAmdBlasSrotmg\",\n    \"clAmdBlasDrotmg\",\n    \"clAmdBlasSrot\",\n    \"clAmdBlasDrot\",\n    \"clAmdBlasCsrot\",\n    \"clAmdBlasZdrot\",\n    \"clAmdBlasSrotm\",\n    \"clAmdBlasDrotm\",\n    \"clAmdBlasSnrm2\",\n    \"clAmdBlasDnrm2\",\n    \"clAmdBlasScnrm2\",\n    \"clAmdBlasDznrm2\",\n    \"clAmdBlasiSamax\",\n    \"clAmdBlasiDamax\",\n    \"clAmdBlasiCamax\",\n    \"clAmdBlasiZamax\",\n    \"clAmdBlasSasum\",\n    \"clAmdBlasDasum\",\n    \"clAmdBlasScasum\",\n    \"clAmdBlasDzasum\",\n    \"clAmdBlasSgemv\",\n    \"clAmdBlasDgemv\",\n    \"clAmdBlasCgemv\",\n    \"clAmdBlasZgemv\",\n    \"clAmdBlasSgemvEx\",\n    \"clAmdBlasDgemvEx\",\n    \"clAmdBlasCgemvEx\",\n    \"clAmdBlasZgemvEx\",\n    \"clAmdBlasSsymv\",\n    \"clAmdBlasDsymv\",\n    \"clAmdBlasSsymvEx\",\n    \"clAmdBlasDsymvEx\",\n    \"clAmdBlasChemv\",\n    \"clAmdBlasZhemv\",\n    \"clAmdBlasStrmv\",\n    \"clAmdBlasDtrmv\",\n    \"clAmdBlasCtrmv\",\n    \"clAmdBlasZtrmv\",\n    \"clAmdBlasStrsv\",\n    \"clAmdBlasDtrsv\",\n    \"clAmdBlasCtrsv\",\n    \"clAmdBlasZtrsv\",\n    \"clAmdBlasSger\",\n    \"clAmdBlasDger\",\n    \"clAmdBlasCgeru\",\n    \"clAmdBlasZgeru\",\n    \"clAmdBlasCgerc\",\n    \"clAmdBlasZgerc\",\n    \"clAmdBlasSsyr\",\n    \"clAmdBlasDsyr\",\n    \"clAmdBlasCher\",\n    \"clAmdBlasZher\",\n    \"clAmdBlasSsyr2\",\n    \"clAmdBlasDsyr2\",\n    \"clAmdBlasCher2\",\n    \"clAmdBlasZher2\",\n    \"clAmdBlasStpmv\",\n    \"clAmdBlasDtpmv\",\n    \"clAmdBlasCtpmv\",\n    \"clAmdBlasZtpmv\",\n    \"clAmdBlasStpsv\",\n    \"clAmdBlasDtpsv\",\n    \"clAmdBlasCtpsv\",\n    \"clAmdBlasZtpsv\",\n    \"clAmdBlasSspmv\",\n    \"clAmdBlasDspmv\",\n    \"clAmdBlasChpmv\",\n    \"clAmdBlasZhpmv\",\n    \"clAmdBlasSspr\",\n    \"clAmdBlasDspr\",\n    \"clAmdBlasChpr\",\n    \"clAmdBlasZhpr\",\n    \"clAmdBlasSspr2\",\n    \"clAmdBlasDspr2\",\n    \"clAmdBlasChpr2\",\n    \"clAmdBlasZhpr2\",\n    \"clAmdBlasSgbmv\",\n    \"clAmdBlasDgbmv\",\n    \"clAmdBlasCgbmv\",\n    \"clAmdBlasZgbmv\",\n    \"clAmdBlasStbmv\",\n    \"clAmdBlasDtbmv\",\n    \"clAmdBlasCtbmv\",\n    \"clAmdBlasZtbmv\",\n    \"clAmdBlasSsbmv\",\n    \"clAmdBlasDsbmv\",\n    \"clAmdBlasChbmv\",\n    \"clAmdBlasZhbmv\",\n    \"clAmdBlasStbsv\",\n    \"clAmdBlasDtbsv\",\n    \"clAmdBlasCtbsv\",\n    \"clAmdBlasZtbsv\",\n    \"clAmdBlasSgemm\",\n    \"clAmdBlasDgemm\",\n    \"clAmdBlasCgemm\",\n    \"clAmdBlasZgemm\",\n    \"clAmdBlasSgemmEx\",\n    \"clAmdBlasDgemmEx\",\n    \"clAmdBlasCgemmEx\",\n    \"clAmdBlasZgemmEx\",\n    \"clAmdBlasStrmm\",\n    \"clAmdBlasDtrmm\",\n    \"clAmdBlasCtrmm\",\n    \"clAmdBlasZtrmm\",\n    \"clAmdBlasStrmmEx\",\n    \"clAmdBlasDtrmmEx\",\n    \"clAmdBlasCtrmmEx\",\n    \"clAmdBlasZtrmmEx\",\n    \"clAmdBlasStrsm\",\n    \"clAmdBlasDtrsm\",\n    \"clAmdBlasCtrsm\",\n    \"clAmdBlasZtrsm\",\n    \"clAmdBlasStrsmEx\",\n    \"clAmdBlasDtrsmEx\",\n    \"clAmdBlasCtrsmEx\",\n    \"clAmdBlasZtrsmEx\",\n    \"clAmdBlasSsyrk\",\n    \"clAmdBlasDsyrk\",\n    \"clAmdBlasCsyrk\",\n    \"clAmdBlasZsyrk\",\n    \"clAmdBlasSsyrkEx\",\n    \"clAmdBlasDsyrkEx\",\n    \"clAmdBlasCsyrkEx\",\n    \"clAmdBlasZsyrkEx\",\n    \"clAmdBlasSsyr2k\",\n    \"clAmdBlasDsyr2k\",\n    \"clAmdBlasCsyr2k\",\n    \"clAmdBlasZsyr2k\",\n    \"clAmdBlasSsyr2kEx\",\n    \"clAmdBlasDsyr2kEx\",\n    \"clAmdBlasCsyr2kEx\",\n    \"clAmdBlasZsyr2kEx\",\n    \"clAmdBlasSsymm\",\n    \"clAmdBlasDsymm\",\n    \"clAmdBlasCsymm\",\n    \"clAmdBlasZsymm\",\n    \"clAmdBlasChemm\",\n    \"clAmdBlasZhemm\",\n    \"clAmdBlasCherk\",\n    \"clAmdBlasZherk\",\n    \"clAmdBlasCher2k\",\n    \"clAmdBlasZher2k\",\n};\n\nstatic void* openclamdblas_check_fn(int ID)\n{\n    void* func = CV_CL_GET_PROC_ADDRESS(openclamdblas_fn_names[ID]);\n    if (!func)\n    {\n        std::ostringstream msg;\n        msg << \"OpenCL AMD BLAS function is not available: [\" << openclamdblas_fn_names[ID] << \"]\";\n        CV_Error(CV_StsBadFunc, msg.str());\n    }\n    extern void* openclamdblas_fn_ptrs[];\n    *(void**)(openclamdblas_fn_ptrs[ID]) = func;\n    return func;\n}\n\nnamespace {\n// generated by parser_clamdblas.py\ntemplate <int ID, typename _R>\nstruct openclamdblas_fn0\n{\n    typedef _R (*FN)();\n    static _R switch_fn()\n    { return ((FN)openclamdblas_check_fn(ID))(); }\n};\n\ntemplate <int ID, typename _R, typename _T1>\nstruct openclamdblas_fn1\n{\n    typedef _R (*FN)(_T1);\n    static _R switch_fn(_T1 p1)\n    { return ((FN)openclamdblas_check_fn(ID))(p1); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2>\nstruct openclamdblas_fn2\n{\n    typedef _R (*FN)(_T1, _T2);\n    static _R switch_fn(_T1 p1, _T2 p2)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3>\nstruct openclamdblas_fn3\n{\n    typedef _R (*FN)(_T1, _T2, _T3);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4>\nstruct openclamdblas_fn4\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5>\nstruct openclamdblas_fn5\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6>\nstruct openclamdblas_fn6\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7>\nstruct openclamdblas_fn7\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8>\nstruct openclamdblas_fn8\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9>\nstruct openclamdblas_fn9\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10>\nstruct openclamdblas_fn10\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11>\nstruct openclamdblas_fn11\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12>\nstruct openclamdblas_fn12\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13>\nstruct openclamdblas_fn13\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14>\nstruct openclamdblas_fn14\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15>\nstruct openclamdblas_fn15\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16>\nstruct openclamdblas_fn16\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17>\nstruct openclamdblas_fn17\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18>\nstruct openclamdblas_fn18\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19>\nstruct openclamdblas_fn19\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20>\nstruct openclamdblas_fn20\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20, typename _T21>\nstruct openclamdblas_fn21\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20, _T21);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20, _T21 p21)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); }\n};\n\ntemplate <int ID, typename _R, typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10, typename _T11, typename _T12, typename _T13, typename _T14, typename _T15, typename _T16, typename _T17, typename _T18, typename _T19, typename _T20, typename _T21, typename _T22>\nstruct openclamdblas_fn22\n{\n    typedef _R (*FN)(_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11, _T12, _T13, _T14, _T15, _T16, _T17, _T18, _T19, _T20, _T21, _T22);\n    static _R switch_fn(_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11, _T12 p12, _T13 p13, _T14 p14, _T15 p15, _T16 p16, _T17 p17, _T18 p18, _T19 p19, _T20 p20, _T21 p21, _T22 p22)\n    { return ((FN)openclamdblas_check_fn(ID))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); }\n};\n\n}\n\n// generated by parser_clamdblas.py\nclAmdBlasStatus (*clAmdBlasGetVersion)(cl_uint*, cl_uint*, cl_uint*) = openclamdblas_fn3<OPENCLAMDBLAS_FN_clAmdBlasGetVersion, clAmdBlasStatus, cl_uint*, cl_uint*, cl_uint*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSetup)() = openclamdblas_fn0<OPENCLAMDBLAS_FN_clAmdBlasSetup, clAmdBlasStatus>::switch_fn;\nvoid (*clAmdBlasTeardown)() = openclamdblas_fn0<OPENCLAMDBLAS_FN_clAmdBlasTeardown, void>::switch_fn;\ncl_ulong (*clAmdBlasAddScratchImage)(cl_context, size_t, size_t, clAmdBlasStatus*) = openclamdblas_fn4<OPENCLAMDBLAS_FN_clAmdBlasAddScratchImage, cl_ulong, cl_context, size_t, size_t, clAmdBlasStatus*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasRemoveScratchImage)(cl_ulong) = openclamdblas_fn1<OPENCLAMDBLAS_FN_clAmdBlasRemoveScratchImage, clAmdBlasStatus, cl_ulong>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSswap)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasSswap, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDswap)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDswap, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCswap)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasCswap, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZswap)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasZswap, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSscal)(size_t, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasSscal, clAmdBlasStatus, size_t, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDscal)(size_t, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasDscal, clAmdBlasStatus, size_t, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCscal)(size_t, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasCscal, clAmdBlasStatus, size_t, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZscal)(size_t, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasZscal, clAmdBlasStatus, size_t, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsscal)(size_t, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasCsscal, clAmdBlasStatus, size_t, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZdscal)(size_t, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn10<OPENCLAMDBLAS_FN_clAmdBlasZdscal, clAmdBlasStatus, size_t, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasScopy)(size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasScopy, clAmdBlasStatus, size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDcopy)(size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDcopy, clAmdBlasStatus, size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCcopy)(size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasCcopy, clAmdBlasStatus, size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZcopy)(size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasZcopy, clAmdBlasStatus, size_t, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSaxpy)(size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasSaxpy, clAmdBlasStatus, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDaxpy)(size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasDaxpy, clAmdBlasStatus, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCaxpy)(size_t, cl_float2, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasCaxpy, clAmdBlasStatus, size_t, cl_float2, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZaxpy)(size_t, cl_double2, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasZaxpy, clAmdBlasStatus, size_t, cl_double2, const cl_mem, size_t, int, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSdot)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasSdot, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDdot)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasDdot, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCdotu)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasCdotu, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZdotu)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasZdotu, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCdotc)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasCdotc, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZdotc)(size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasZdotc, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSrotg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasSrotg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDrotg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasDrotg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCrotg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasCrotg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZrotg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn13<OPENCLAMDBLAS_FN_clAmdBlasZrotg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSrotmg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasSrotmg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDrotmg)(cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasDrotmg, clAmdBlasStatus, cl_mem, size_t, cl_mem, size_t, cl_mem, size_t, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSrot)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_float, cl_float, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasSrot, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_float, cl_float, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDrot)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_double, cl_double, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasDrot, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_double, cl_double, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsrot)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_float, cl_float, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasCsrot, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_float, cl_float, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZdrot)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_double, cl_double, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasZdrot, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, cl_double, cl_double, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSrotm)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, const cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasSrotm, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, const cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDrotm)(size_t, cl_mem, size_t, int, cl_mem, size_t, int, const cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasDrotm, clAmdBlasStatus, size_t, cl_mem, size_t, int, cl_mem, size_t, int, const cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSnrm2)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasSnrm2, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDnrm2)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDnrm2, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasScnrm2)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasScnrm2, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDznrm2)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDznrm2, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasiSamax)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasiSamax, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasiDamax)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasiDamax, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasiCamax)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasiCamax, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasiZamax)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasiZamax, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSasum)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasSasum, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDasum)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDasum, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasScasum)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasScasum, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDzasum)(size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn12<OPENCLAMDBLAS_FN_clAmdBlasDzasum, clAmdBlasStatus, size_t, cl_mem, size_t, const cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSgemv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasSgemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDgemv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasDgemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgemv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasCgemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgemv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasZgemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSgemvEx)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasSgemvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDgemvEx)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasDgemvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgemvEx)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasCgemvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgemvEx)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasZgemvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsymv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSsymv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsymv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDsymv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsymvEx)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasSsymvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsymvEx)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasDsymvEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChemv)(clAmdBlasOrder, clAmdBlasUplo, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasChemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, FloatComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhemv)(clAmdBlasOrder, clAmdBlasUplo, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasZhemv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, int, DoubleComplex, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasStrmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasDtrmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasCtrmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasZtrmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasStrsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasDtrsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasCtrsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasZtrsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSger)(clAmdBlasOrder, size_t, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSger, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDger)(clAmdBlasOrder, size_t, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDger, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgeru)(clAmdBlasOrder, size_t, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCgeru, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgeru)(clAmdBlasOrder, size_t, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZgeru, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgerc)(clAmdBlasOrder, size_t, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCgerc, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgerc)(clAmdBlasOrder, size_t, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZgerc, clAmdBlasStatus, clAmdBlasOrder, size_t, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasSsyr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasDsyr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCher)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasCher, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZher)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasZher, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSsyr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDsyr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCher2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCher2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZher2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZher2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStpmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasStpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtpmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasDtpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtpmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasCtpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtpmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasZtpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStpsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasStpsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtpsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasDtpsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtpsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasCtpsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtpsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn15<OPENCLAMDBLAS_FN_clAmdBlasZtpsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, const cl_mem, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSspmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSspmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDspmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDspmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChpmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasChpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhpmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZhpmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSspr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasSspr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDspr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasDspr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChpr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasChpr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhpr)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn14<OPENCLAMDBLAS_FN_clAmdBlasZhpr, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSspr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasSspr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDspr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasDspr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChpr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasChpr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_float2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhpr2)(clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasZhpr2, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, cl_double2, const cl_mem, size_t, int, const cl_mem, size_t, int, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSgbmv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasSgbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDgbmv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasDgbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgbmv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasCgbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgbmv)(clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasZgbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, size_t, size_t, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStbmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasStbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtbmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDtbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtbmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCtbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtbmv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZtbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_mem, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsbmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasSsbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsbmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasDsbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChbmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasChbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_float2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhbmv)(clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn20<OPENCLAMDBLAS_FN_clAmdBlasZhbmv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, int, cl_double2, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStbsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasStbsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtbsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasDtbsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtbsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasCtbsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtbsv)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasZtbsv, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, const cl_mem, size_t, size_t, cl_mem, size_t, int, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSgemm)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasSgemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDgemm)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasDgemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgemm)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasCgemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgemm)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasZgemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSgemmEx)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasSgemmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDgemmEx)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasDgemmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCgemmEx)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasCgemmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZgemmEx)(clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn22<OPENCLAMDBLAS_FN_clAmdBlasZgemmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasTranspose, clAmdBlasTranspose, size_t, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrmm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasStrmm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrmm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasDtrmm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrmm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasCtrmm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrmm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasZtrmm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrmmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasStrmmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrmmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasDtrmmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrmmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasCtrmmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrmmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasZtrmmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrsm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasStrsm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrsm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasDtrsm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrsm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasCtrsm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrsm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn17<OPENCLAMDBLAS_FN_clAmdBlasZtrsm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasStrsmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasStrsmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDtrsmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasDtrsmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCtrsmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasCtrsmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZtrsmEx)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn19<OPENCLAMDBLAS_FN_clAmdBlasZtrsmEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, clAmdBlasTranspose, clAmdBlasDiag, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyrk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasSsyrk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyrk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasDsyrk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsyrk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasCsyrk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZsyrk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn16<OPENCLAMDBLAS_FN_clAmdBlasZsyrk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyrkEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSsyrkEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyrkEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDsyrkEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsyrkEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCsyrkEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZsyrkEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZsyrkEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyr2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasSsyr2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, const cl_mem, size_t, cl_float, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyr2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasDsyr2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, const cl_mem, size_t, cl_double, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsyr2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCsyr2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, const cl_mem, size_t, FloatComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZsyr2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZsyr2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, const cl_mem, size_t, DoubleComplex, cl_mem, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsyr2kEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasSsyr2kEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsyr2kEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasDsyr2kEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsyr2kEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasCsyr2kEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, FloatComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZsyr2kEx)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasZsyr2kEx, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, DoubleComplex, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasSsymm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasSsymm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasDsymm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasDsymm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCsymm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasCsymm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZsymm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasZsymm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasChemm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasChemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_float2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZhemm)(clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasZhemm, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasSide, clAmdBlasUplo, size_t, size_t, cl_double2, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double2, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCherk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, float, const cl_mem, size_t, size_t, float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasCherk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, float, const cl_mem, size_t, size_t, float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZherk)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, double, const cl_mem, size_t, size_t, double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn18<OPENCLAMDBLAS_FN_clAmdBlasZherk, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, double, const cl_mem, size_t, size_t, double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasCher2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasCher2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, FloatComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_float, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\nclAmdBlasStatus (*clAmdBlasZher2k)(clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*) = openclamdblas_fn21<OPENCLAMDBLAS_FN_clAmdBlasZher2k, clAmdBlasStatus, clAmdBlasOrder, clAmdBlasUplo, clAmdBlasTranspose, size_t, size_t, DoubleComplex, const cl_mem, size_t, size_t, const cl_mem, size_t, size_t, cl_double, cl_mem, size_t, size_t, cl_uint, cl_command_queue*, cl_uint, const cl_event*, cl_event*>::switch_fn;\n\n// generated by parser_clamdblas.py\nvoid* openclamdblas_fn_ptrs[] = {\n    &clAmdBlasGetVersion,\n    &clAmdBlasSetup,\n    &clAmdBlasTeardown,\n    &clAmdBlasAddScratchImage,\n    &clAmdBlasRemoveScratchImage,\n    &clAmdBlasSswap,\n    &clAmdBlasDswap,\n    &clAmdBlasCswap,\n    &clAmdBlasZswap,\n    &clAmdBlasSscal,\n    &clAmdBlasDscal,\n    &clAmdBlasCscal,\n    &clAmdBlasZscal,\n    &clAmdBlasCsscal,\n    &clAmdBlasZdscal,\n    &clAmdBlasScopy,\n    &clAmdBlasDcopy,\n    &clAmdBlasCcopy,\n    &clAmdBlasZcopy,\n    &clAmdBlasSaxpy,\n    &clAmdBlasDaxpy,\n    &clAmdBlasCaxpy,\n    &clAmdBlasZaxpy,\n    &clAmdBlasSdot,\n    &clAmdBlasDdot,\n    &clAmdBlasCdotu,\n    &clAmdBlasZdotu,\n    &clAmdBlasCdotc,\n    &clAmdBlasZdotc,\n    &clAmdBlasSrotg,\n    &clAmdBlasDrotg,\n    &clAmdBlasCrotg,\n    &clAmdBlasZrotg,\n    &clAmdBlasSrotmg,\n    &clAmdBlasDrotmg,\n    &clAmdBlasSrot,\n    &clAmdBlasDrot,\n    &clAmdBlasCsrot,\n    &clAmdBlasZdrot,\n    &clAmdBlasSrotm,\n    &clAmdBlasDrotm,\n    &clAmdBlasSnrm2,\n    &clAmdBlasDnrm2,\n    &clAmdBlasScnrm2,\n    &clAmdBlasDznrm2,\n    &clAmdBlasiSamax,\n    &clAmdBlasiDamax,\n    &clAmdBlasiCamax,\n    &clAmdBlasiZamax,\n    &clAmdBlasSasum,\n    &clAmdBlasDasum,\n    &clAmdBlasScasum,\n    &clAmdBlasDzasum,\n    &clAmdBlasSgemv,\n    &clAmdBlasDgemv,\n    &clAmdBlasCgemv,\n    &clAmdBlasZgemv,\n    &clAmdBlasSgemvEx,\n    &clAmdBlasDgemvEx,\n    &clAmdBlasCgemvEx,\n    &clAmdBlasZgemvEx,\n    &clAmdBlasSsymv,\n    &clAmdBlasDsymv,\n    &clAmdBlasSsymvEx,\n    &clAmdBlasDsymvEx,\n    &clAmdBlasChemv,\n    &clAmdBlasZhemv,\n    &clAmdBlasStrmv,\n    &clAmdBlasDtrmv,\n    &clAmdBlasCtrmv,\n    &clAmdBlasZtrmv,\n    &clAmdBlasStrsv,\n    &clAmdBlasDtrsv,\n    &clAmdBlasCtrsv,\n    &clAmdBlasZtrsv,\n    &clAmdBlasSger,\n    &clAmdBlasDger,\n    &clAmdBlasCgeru,\n    &clAmdBlasZgeru,\n    &clAmdBlasCgerc,\n    &clAmdBlasZgerc,\n    &clAmdBlasSsyr,\n    &clAmdBlasDsyr,\n    &clAmdBlasCher,\n    &clAmdBlasZher,\n    &clAmdBlasSsyr2,\n    &clAmdBlasDsyr2,\n    &clAmdBlasCher2,\n    &clAmdBlasZher2,\n    &clAmdBlasStpmv,\n    &clAmdBlasDtpmv,\n    &clAmdBlasCtpmv,\n    &clAmdBlasZtpmv,\n    &clAmdBlasStpsv,\n    &clAmdBlasDtpsv,\n    &clAmdBlasCtpsv,\n    &clAmdBlasZtpsv,\n    &clAmdBlasSspmv,\n    &clAmdBlasDspmv,\n    &clAmdBlasChpmv,\n    &clAmdBlasZhpmv,\n    &clAmdBlasSspr,\n    &clAmdBlasDspr,\n    &clAmdBlasChpr,\n    &clAmdBlasZhpr,\n    &clAmdBlasSspr2,\n    &clAmdBlasDspr2,\n    &clAmdBlasChpr2,\n    &clAmdBlasZhpr2,\n    &clAmdBlasSgbmv,\n    &clAmdBlasDgbmv,\n    &clAmdBlasCgbmv,\n    &clAmdBlasZgbmv,\n    &clAmdBlasStbmv,\n    &clAmdBlasDtbmv,\n    &clAmdBlasCtbmv,\n    &clAmdBlasZtbmv,\n    &clAmdBlasSsbmv,\n    &clAmdBlasDsbmv,\n    &clAmdBlasChbmv,\n    &clAmdBlasZhbmv,\n    &clAmdBlasStbsv,\n    &clAmdBlasDtbsv,\n    &clAmdBlasCtbsv,\n    &clAmdBlasZtbsv,\n    &clAmdBlasSgemm,\n    &clAmdBlasDgemm,\n    &clAmdBlasCgemm,\n    &clAmdBlasZgemm,\n    &clAmdBlasSgemmEx,\n    &clAmdBlasDgemmEx,\n    &clAmdBlasCgemmEx,\n    &clAmdBlasZgemmEx,\n    &clAmdBlasStrmm,\n    &clAmdBlasDtrmm,\n    &clAmdBlasCtrmm,\n    &clAmdBlasZtrmm,\n    &clAmdBlasStrmmEx,\n    &clAmdBlasDtrmmEx,\n    &clAmdBlasCtrmmEx,\n    &clAmdBlasZtrmmEx,\n    &clAmdBlasStrsm,\n    &clAmdBlasDtrsm,\n    &clAmdBlasCtrsm,\n    &clAmdBlasZtrsm,\n    &clAmdBlasStrsmEx,\n    &clAmdBlasDtrsmEx,\n    &clAmdBlasCtrsmEx,\n    &clAmdBlasZtrsmEx,\n    &clAmdBlasSsyrk,\n    &clAmdBlasDsyrk,\n    &clAmdBlasCsyrk,\n    &clAmdBlasZsyrk,\n    &clAmdBlasSsyrkEx,\n    &clAmdBlasDsyrkEx,\n    &clAmdBlasCsyrkEx,\n    &clAmdBlasZsyrkEx,\n    &clAmdBlasSsyr2k,\n    &clAmdBlasDsyr2k,\n    &clAmdBlasCsyr2k,\n    &clAmdBlasZsyr2k,\n    &clAmdBlasSsyr2kEx,\n    &clAmdBlasDsyr2kEx,\n    &clAmdBlasCsyr2kEx,\n    &clAmdBlasZsyr2kEx,\n    &clAmdBlasSsymm,\n    &clAmdBlasDsymm,\n    &clAmdBlasCsymm,\n    &clAmdBlasZsymm,\n    &clAmdBlasChemm,\n    &clAmdBlasZhemm,\n    &clAmdBlasCherk,\n    &clAmdBlasZherk,\n    &clAmdBlasCher2k,\n    &clAmdBlasZher2k,\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/src/cl_runtime/generator/template/clamdblas_runtime.cpp.in": "#include \"precomp.hpp\"\n\n#ifdef HAVE_CLAMDBLAS\n\n#include \"opencv2/ocl/cl_runtime/cl_runtime.hpp\"\n#include \"opencv2/ocl/cl_runtime/clamdblas_runtime.hpp\"\n\n#if defined(_WIN32)\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdBlas.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdBlas.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdBlas.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\n@CL_FN_ENUMS@\n@CL_FN_NAMES@\n\nstatic void* openclamdblas_check_fn(int ID)\n{\n    void* func = CV_CL_GET_PROC_ADDRESS(openclamdblas_fn_names[ID]);\n    if (!func)\n    {\n        std::ostringstream msg;\n        msg << \"OpenCL AMD BLAS function is not available: [\" << openclamdblas_fn_names[ID] << \"]\";\n        CV_Error(CV_StsBadFunc, msg.str());\n    }\n    extern void* openclamdblas_fn_ptrs[];\n    *(void**)(openclamdblas_fn_ptrs[ID]) = func;\n    return func;\n}\n\nnamespace {\n@CL_FN_SWITCH@\n}\n\n@CL_FN_DEFINITIONS@\n\n@CL_FN_PTRS@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/src/cl_runtime/generator/template/clamdfft_runtime.cpp.in": "#include \"precomp.hpp\"\n\n#ifdef HAVE_CLAMDFFT\n\n#include \"opencv2/ocl/cl_runtime/cl_runtime.hpp\"\n#include \"opencv2/ocl/cl_runtime/clamdfft_runtime.hpp\"\n\n#if defined(_WIN32)\n    static void* WinGetProcAddress(const char* name)\n    {\n        static HMODULE opencl_module = NULL;\n        if (!opencl_module)\n        {\n            opencl_module = GetModuleHandleA(\"clAmdFft.Runtime.dll\");\n            if (!opencl_module)\n            {\n                opencl_module = LoadLibraryA(\"clAmdFft.Runtime.dll\");\n                if (!opencl_module)\n                    return NULL;\n            }\n        }\n        return (void*)GetProcAddress(opencl_module, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) WinGetProcAddress(name)\n#endif // _WIN32\n\n#if defined(__linux__)\n    #include <dlfcn.h>\n    #include <stdio.h>\n\n    static void* GetProcAddress (const char* name)\n    {\n        static void* h = NULL;\n        if (!h)\n        {\n            h = dlopen(\"libclAmdFft.Runtime.so\", RTLD_LAZY | RTLD_GLOBAL);\n            if (!h)\n                return NULL;\n        }\n\n        return dlsym(h, name);\n    }\n    #define CV_CL_GET_PROC_ADDRESS(name) GetProcAddress(name)\n#endif\n\n#ifndef CV_CL_GET_PROC_ADDRESS\n#define CV_CL_GET_PROC_ADDRESS(name) NULL\n#endif\n\n@CL_FN_ENUMS@\n@CL_FN_NAMES@\n\nstatic void* openclamdfft_check_fn(int ID)\n{\n    void* func = CV_CL_GET_PROC_ADDRESS(openclamdfft_fn_names[ID]);\n    if (!func)\n    {\n        std::ostringstream msg;\n        msg << \"OpenCL AMD FFT function is not available: [\" << openclamdfft_fn_names[ID] << \"]\";\n        CV_Error(CV_StsBadFunc, msg.str());\n    }\n    extern void* openclamdfft_fn_ptrs[];\n    *(void**)(openclamdfft_fn_ptrs[ID]) = func;\n    return func;\n}\n\nnamespace {\n@CL_FN_SWITCH@\n}\n\n@CL_FN_DEFINITIONS@\n\n@CL_FN_PTRS@\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/data/haarcascades/haarcascade_mcs_rightear.xml",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/data/haarcascades/haarcascade_mcs_leftear.xml",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/data/vec_files/trainingfaces_24-24.vec",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine_test/res/drawable-ldpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine_test/res/drawable-mdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/engine_test/res/drawable-hdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/AndroidAppUsageModel.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/LibInstallAproved.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/LibInstalled.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/LibInstallCanceled.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/Structure.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/NoService.dia",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/NoService.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/Structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/LibInstallAproved.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/LibInstalled.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/LibInstallCanceled.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/service/doc/img/AndroidAppUsageModel.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/platforms/android/package/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavformat.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavutil.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavcodec.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavdevice.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavutil64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libcoldname_.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libwsock32_.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libgcc64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavcodec64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libwsock3264.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libmingwex_.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libswscale64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libswscale.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libgcc_.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libmingwex64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavformat64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/libavdevice64.a",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.4.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.3.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.1.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.0.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r4.0.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r2.3.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r2.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi-v7a/libnative_camera_r3.0.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r4.4.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r4.3.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r4.1.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r4.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r4.0.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r2.3.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/x86/libnative_camera_r3.0.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.4.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.3.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.1.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.0.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r4.0.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r2.3.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r2.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/armeabi/libnative_camera_r3.0.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/mips/libnative_camera_r4.4.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/mips/libnative_camera_r4.3.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/mips/libnative_camera_r4.1.1.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/mips/libnative_camera_r4.2.0.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/lib/mips/libnative_camera_r4.0.3.so",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/ffmpeg/opencv_ffmpeg.dll",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/ffmpeg/opencv_ffmpeg_64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/openexr/IlmImf/ImfPizCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/openexr/IlmImf/ImfZipCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/openexr/IlmImf/ImfRleCompressor.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/3rdparty/openexr/Half/half.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/ImageManipulations/assets/splash-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/ImageManipulations/assets/windows-sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/ImageManipulations/assets/opencv-logo-150.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/ImageManipulations/assets/opencv-logo-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/Lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/winrt/OcvImageProcessing/OcvImageProcessing/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/tutorial-3-cameracontrol/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/color-blob-detection/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/face-detection/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/camera-calibration/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/15-puzzle/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/tutorial-4-cuda/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/tutorial-1-camerapreview/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/tutorial-2-mixedprocessing/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/native-activity/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/android/image-manipulations/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/baboon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/tree.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/one_way_train_0000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/puzzle.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/box.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/box_in_scene.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/cat.xml",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/scene_r.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/lena.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/one_way_train_0001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/baboon200.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/JCB.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/stuff.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/fruits.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/cat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/airplane.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/scene_l.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/c/baboon200_rotated.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/road.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/rubberwhale2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/768x576.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/aloeR.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/basketball1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/tsucuba_right.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/aloeL.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/rubberwhale1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/tsucuba_left.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/gpu/basketball2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right02.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right12.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/baboon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tsukuba_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/logo_in_clutter.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left12.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right09.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left09.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/memorial.exr",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right07.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left13.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left01.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right06.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right08.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left03.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/templ.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left02.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left06.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right13.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right04.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/lena.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right03.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left14.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left07.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right11.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left04.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right05.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left11.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/board.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tsukuba_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/building.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left05.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/left08.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/stuff.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right14.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fruits.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/pic3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/right01.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0004.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0005.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0006.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0002.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0008.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0009.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0000.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0003.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/fabmap/stlucia_test_small0007.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/Qt_sample/cube4.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/matching_to_many_images/query.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/matching_to_many_images/train/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/matching_to_many_images/train/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/matching_to_many_images/train/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/baboon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/HappyFish.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/hand_sample2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/WindowsLogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/chicky_512.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/Megamind.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/imageTextR.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/LinuxLogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/yellowball.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/hand_sample1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/imageTextN.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/Megamind_alt.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/opencv-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/hand_sample3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/images/cat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/HighGUI/video-input-psnr-ssim/video/Megamind.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/tutorial_code/HighGUI/video-input-psnr-ssim/video/Megamind_bugy.avi",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/rgbdodometry/image_00000.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/rgbdodometry/depth_00000.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/rgbdodometry/depth_00002.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/cpp/rgbdodometry/image_00002.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/java/clojure/simple-sample/resources/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/java/sbt/src/main/resources/img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/java/sbt/src/main/resources/AverageMaleFace.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/java/sbt/src/main/resources/img2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/java/sbt/sbt/sbt-launch.jar",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/starry_night.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/aero1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/digits.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/text_defocus.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/licenseplate_motion.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/text_motion.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/samples/python2/data/aero3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/haartraining.htm",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/pattern.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/acircles_pattern.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv-logo2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/opencv.ico",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/vidsurv/Blob_Tracking_Tests.doc",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/vidsurv/TestSeq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/vidsurv/Blob_Tracking_Modules.doc",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/gpu.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/feature2D.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/imgproc.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/introduction.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/retina.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/objdetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/calib3d.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/ml.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/core.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/highgui.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/video.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/general.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/images/viz.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/calib3d/camera_calibration/images/fileListImage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/calib3d/camera_calibration/images/fileListImageUnDist.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/calib3d/camera_calibration/images/asymetricalPattern.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/calib3d/table_of_content_calib3d/images/camera_calibration_square_chess.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/calib3d/table_of_content_calib3d/images/camera_calibration.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Result1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/moments/images/Moments_Result2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/point_polygon_test/images/Point_Polygon_Test_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/point_polygon_test/images/Point_Polygon_Test_Source_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/images/Bounding_Rects_Circles_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/images/Bounding_Rects_Circles_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/hull/images/Hull_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/hull/images/Hull_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/find_contours/images/Find_Contours_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/find_contours/images/Find_Contours_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rotated_ellipses/images/Bounding_Rotated_Ellipses_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/shapedescriptors/bounding_rotated_ellipses/images/Bounding_Rotated_Ellipses_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/Pyramids_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/Morphology_2_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/Smoothing_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/Morphology_1_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/Threshold_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Hull_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Find_Contours_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Bounding_Rotated_Ellipses_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Point_Polygon_Test_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Moments_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/shapedescriptors/Bounding_Rects_Circles_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Hough_Circle_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Remap_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Hough_Lines_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Warp_Affine_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/CopyMakeBorder_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Sobel_Derivatives_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Filter_2D_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Canny_Detector_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/imgtrans/Laplace_Operator_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/histograms/Histogram_Calculation_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/histograms/Histogram_Comparison_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/histograms/Histogram_Equalization_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/histograms/Template_Matching_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/table_of_content_imgproc/images/histograms/Back_Projection_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/images/Smoothing_Tutorial_Result_Median_Filter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/images/Smoothing_Tutorial_theory_gaussian_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Erosion_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Original_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Dilation_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Erosion.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/erosion_dilatation/images/Morphology_1_Tutorial_Theory_Dilation.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_PyrUp_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_PyrDown_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/pyramids/images/Pyramids_Tutorial_Pyramid_Theory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Binary.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Zero_Inverted.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Base_Figure.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Result_Zero.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Binary_Inverted.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Zero.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Example.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Theory_Truncate.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/threshold/images/Threshold_Tutorial_Result_Binary_Inverted.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Opening.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_BlackHat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Closing.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_TopHat.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/opening_closing_hats/images/Morphology_2_Tutorial_Theory_Gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/sobel_derivatives/images/Sobel_Derivatives_Tutorial_Theory_ddIntensity_Function.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/filter_2d/images/filter_2d_tutorial_kernel_theory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/filter_2d/images/filter_2d_tutorial_result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Result_Warp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Result_Warp_Rotate.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/warp_affine/images/Warp_Affine_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/copyMakeBorder/images/CopyMakeBorder_Tutorial_Results.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_lines/images/Hough_Lines_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Theory_ddIntensity.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Theory_Previous.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/laplace_operator/images/Laplace_Operator_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_circle/images/Hough_Circle_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/hough_circle/images/Hough_Circle_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/remap/images/Remap_Tutorial_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/canny_detector/images/Canny_Detector_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/imgtrans/canny_detector/images/Canny_Detector_Tutorial_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_comparison/images/Histogram_Comparison_Source_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_BackProj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection2_Mask.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_Source_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection1_BackProj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/back_projection/images/Back_Projection_Theory2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Theory_Hist0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Theory_Hist1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_calculation/images/Histogram_Calculation_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Original_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Equalized_Histogram.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Theory_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/histogram_equalization/images/Histogram_Equalization_Equalized_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Summary.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Image_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Theory_Sliding.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Template_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/imgproc/histograms/template_matching/images/Template_Matching_Correl_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesRelease.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/OpenCV_Install_Directory.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertyPageExample.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VCDirectories2010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertyPageAddExisting.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesDebugSmple.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetInsideFolder.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLibrariesDebug.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetVS2010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVLib.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/AddNewPropertySheet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VCDirectories2008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/NewProjectVisualStudio.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/VisualStudioCommandLineArguments.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/OpenCVEditEnviromentVisual.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/SuccessVisualStudioWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_Opencv/images/PropertySheetOpenCVInclude.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_gcc_cmake/images/GCC_CMake_Example_Tutorial.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_run.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_run_face.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/ant_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/cmake_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/sbt_eclipse.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/Java_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/desktop_java/images/faceDetection.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/display_image/images/Display_Image_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/10-new-project-created.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/8-add-library.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/7_5-new-java-project.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/4-add-external-jars.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/7-user-library-final.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/5-native-library.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/3-library-name.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/1-window-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/2-user-library-new.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/9-select-user-lib.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/6-external-folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/java_eclipse/images/11-the-code.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/clojure_dev_intro/images/lena.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/clojure_dev_intro/images/blurred.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/eclipse_cpp_logo.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/how_to_write_a_tutorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/visual_studio_image_watch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/windows_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/ubuntu-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/clojure-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/android_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/visual-studio-2010-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/gccegg-65.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/Java_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/eclipse-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/Display_Image_Tutorial_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/table_of_content_introduction/images/Load_Save_Image_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/Sphinx_Install.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMake_Configure_Windows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/OpenCV_Install_Directory.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/TortoiseSVNCheckout.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/IntelTBB.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/WindowsBuildInstall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMakePackageNotFoundWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMakeSelectBin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMakeOutputPackageNotFound.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/OpenCVBuildResultWindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/visualstudiocommandprompt.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/WindowsOpenCVDirPath.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/SVNCheckOutProgress.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/TortoiseSVNCheckoutWindow.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/WindowsQtContoursOutput.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/WindowsBuildDoc.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMakeBuildOptionsOpenCV.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/CMakeBuildWithWindowsGUI.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/qtDownloadThisPackage.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/cmsdstartwindows.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/WindowsOpenCVInstaller.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/MiktexInstall.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/PathEditorOpenCVSetPath.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/PathEditorOpenCVInsertNew.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_install/images/ChangeBuildVisualStudio.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/visual_studio_image_watch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/viewer_context_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/toolwindow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/edges_zoom.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/input_zoom.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/help_button.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/vs_locals.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/breakpoint.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/windows_visual_studio_image_watch/images/viewer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/how_to_write_a_tutorial/images/matTheBasicImageStructure.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/load_save_image/images/Load_Save_Image_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/load_save_image/images/Load_Save_Image_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a15.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/linux_eclipse/images/a10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_06.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_builders.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_refresh.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_main.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_10_crystal_clean.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_11_run_as.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_1a_locate_sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_08.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/emulator_canny.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/android_package_7zip.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_07.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_04.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_adt.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_6_import_existing_projects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_build_resources.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_03.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_ndk_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_opencv_dependency0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8a_target.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_specify_resources.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/device_details.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/AVD_empty.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_9_errors_dissapearing.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_7_select_projects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_edit_configuration_build_options.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_1_choose_workspace.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_4_locate_sdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/ndk_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/android_emulator_opencv_manager_fail.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8_false_alarm.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_builder_types.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_09.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_opencv_dependency1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_windows_environment.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_2_window_preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_cdt_cfg8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_NDK_build_success.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_3_preferences_android.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_cdt_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_inst_cdt.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/android_sdk_and_avd_manager.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/dev_OCV_new_class.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/AVD_create.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_5_import_command.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/cmd_adb_devices.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/dev_OCV_reference.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_05.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_ubuntu.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/eclipse_8b_fix_props.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/introduction/android_binary_package/images/usb_device_connect_13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Trackbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/trackbar/images/Adding_Trackbars_Tutorial_Result_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/video-input-psnr-ssim/images/outputVideoInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/video-write/images/videoCompressSelect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/video-write/images/videoFileStructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/video-write/images/resultOutputWideoWrite.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/table_of_content_highgui/images/video-input-psnr-ssim.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/table_of_content_highgui/images/Adding_Trackbars_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/highgui/table_of_content_highgui/images/video-write.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/gpu/table_of_content_gpu/images/gpu-basics-similarity.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/transformations/images/global_view_point.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/transformations/images/camera_view_point.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/widget_pose/images/widgetpose.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/table_of_content_viz/images/image_effects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/table_of_content_viz/images/facedetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/table_of_content_viz/images/intro.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/launching_viz/images/window_demo.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/viz/creating_widgets/images/red_triangle.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Drawing_2_Tutorial_Result_7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/howToScanImages.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Basic_Linear_Transform_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Drawing_1_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/interopOpenCV1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Adding_Images_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Smoothing_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/discrete_fourier_transform.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/matTheBasicImageStructure.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/matMaskFilter2DOp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/file_input_output_with_xml_yml.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/table_of_content_core/images/Morphology_1_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicImageForComputer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat_the_basic_image_container/images/MatBasicContainerOut7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/interoperability_with_OpenCV_1/images/outputInteropOpenCV1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/mat-mask-operations/images/resultMatMaskFilter2D.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/basic_linear_transform/images/Basic_Linear_Transform_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/basic_geometric_drawing/images/Drawing_1_Tutorial_Result_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/adding_images/images/Adding_Images_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/discrete_fourier_transform/images/result_normal.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/discrete_fourier_transform/images/result_rotated.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/core/random_generator_and_text/images/Drawing_2_Tutorial_Result_3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/hello/images/output.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/hello/images/view_did_load.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/hello/images/header_directive.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/hello/images/linking_opencv_ios.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_framework_drag_and_drop.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_viewcontroller_layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/video_processing/images/xcode_hello_ios_frameworks_add_dependencies.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/image_manipulation/images/output.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/table_of_content_ios/images/image_effects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/table_of_content_ios/images/facedetect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ios/table_of_content_ios/images/intro.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/objdetect/table_of_content_objdetect/images/Cascade_Classifier_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/objdetect/cascade_classifier/images/Cascade_Classifier_Tutorial_Result_Haar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/objdetect/cascade_classifier/images/Cascade_Classifier_Tutorial_Result_LBP.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/table_of_content_contrib/images/retina_TreeHdr_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/retina_model/images/studentsSample_magno.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/retina_model/images/retina_TreeHdr_retina.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/retina_model/images/studentsSample_input.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/retina_model/images/studentsSample_parvo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/contrib/retina_model/images/retina_TreeHdr_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/introduction_to_svm/images/optimal-hyperplane.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/introduction_to_svm/images/separating-lines.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/introduction_to_svm/images/result.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/table_of_content_ml/images/introduction_to_svm.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/table_of_content_ml/images/non_linear_svms.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/non_linear_svms/images/sample-errors-dist.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/ml/non_linear_svms/images/result.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_detection/images/Feature_Detection_Result_b.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_detection/images/Feature_Detection_Result_a.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_description/images/Feature_Description_BruteForce_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_flann_matcher/images/Featur_FlannMatcher_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_flann_matcher/images/Feature_FlannMatcher_Keypoints_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/good_features_to_track/images/Feature_Detection_Result_b.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/good_features_to_track/images/Feature_Detection_Result_a.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/corner_subpixeles/images/Corner_Subpixeles_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/corner_subpixeles/images/Corner_Subpixeles_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/generic_corner_detector/images/My_Shi_Tomasi_corner_detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/generic_corner_detector/images/My_Harris_corner_detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/harris_detector/images/Harris_Detector_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/trackingmotion/harris_detector/images/Harris_Detector_Original_Image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/feature_homography/images/Feature_Homography_Result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/Feature_Description_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/Feature_Detection_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/Feature_Flann_Matcher_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/Feature_Homography_Tutorial_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/detection_of_planar_objects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/trackingmotion/Generic_Corner_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/trackingmotion/Shi_Tomasi_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/trackingmotion/Corner_Subpixeles_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/doc/tutorials/features2d/table_of_content_features2d/images/trackingmotion/Harris_Detector_Cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/calib3d/doc/pics/stereo_undistort.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/calib3d/doc/pics/fisheye_undistorted.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/quadedge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/logpolar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/backprojectpatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/defects.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/cornersubpix.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/inv_logpolar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/threshold.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/subdiv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/bayer.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/houghp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/minareabox.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/contoursecarea.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/pointpolygon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/building.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/integral.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/imgproc/doc/pics/boundingrect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/74.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/122.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/85.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/81.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/89.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/125.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/82.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/48.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/83.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/37.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/112.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/49.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/54.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/43.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/121.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/55.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/53.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/79.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/71.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/57.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/123.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/92.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/50.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/103.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/73.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/68.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/22.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/23.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/117.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/41.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/47.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/59.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/35.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/67.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/31.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/51.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/29.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/66.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/126.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/25.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/131.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/101.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/40.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/45.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/80.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/118.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/21.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/70.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/107.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/76.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/111.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/114.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/116.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/106.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/58.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/75.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/38.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/39.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/104.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/119.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/110.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/44.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/94.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/109.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/46.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/86.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/26.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/93.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/90.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/77.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/84.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/56.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/63.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/98.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/113.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/102.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/87.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/115.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/130.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/120.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/105.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/33.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/78.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/60.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/42.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/64.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/72.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/28.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/69.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/91.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/88.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/108.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/96.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/27.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/65.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/34.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/36.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/52.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/62.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/99.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/61.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/129.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/24.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/97.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/95.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/124.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/48/127.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/74.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/122.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/85.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/81.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/89.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/125.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/82.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/48.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/83.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/37.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/112.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/49.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/54.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/43.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/121.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/55.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/53.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/30.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/79.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/71.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/57.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/123.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/92.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/50.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/103.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/73.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/68.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/22.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/23.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/117.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/41.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/47.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/59.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/35.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/67.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/31.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/51.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/29.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/66.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/126.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/25.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/131.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/101.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/40.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/45.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/80.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/118.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/21.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/70.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/107.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/76.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/111.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/114.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/116.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/106.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/58.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/75.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/38.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/39.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/104.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/119.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/110.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/44.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/94.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/109.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/46.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/86.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/26.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/93.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/90.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/77.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/84.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/56.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/63.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/98.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/113.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/102.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/87.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/115.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/130.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/120.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/105.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/33.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/78.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/60.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/42.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/64.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/72.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/28.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/69.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/91.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/88.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/108.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/96.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/27.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/100.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/65.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/34.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/36.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/52.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/62.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/99.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/61.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/129.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/24.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/97.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/95.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/124.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/src/files_Qt/Milky/64/127.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/highgui/doc/pics/qtgui.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/gpu/perf4au/im2_1280x800.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/gpu/perf4au/im1_1280x800.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/viz/doc/images/cpw2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/viz/doc/images/cpw3.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/viz/doc/images/cube_widget.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/viz/doc/images/cpw1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/legacy/src/facedetection.h",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/legacy/doc/pics/quadedge.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/legacy/doc/pics/subdiv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/doc/pics/memstorage1.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/doc/pics/ellipse.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/doc/pics/memstorage2.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/core/doc/pics/rotatedrect.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/objdetect/doc/pics/haarfeatures.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/eigenface_reconstruction_opencv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/fisherfaces_opencv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/at_database_small_sample_size.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/eigenfaces_opencv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/fisherface_reconstruction_opencv.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/facerec_video/facerec_video.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/arnie_20_20_70_70.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/arnie_20_20_200_200.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/arnie_10_10_200_200.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/mean.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/fisherface_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/clooney_set.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/arnie_30_30_200_200.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/tutorial/gender_classification/fisherface_reconstruction_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_ocean.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_bone.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_winter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_mkpj1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_summer.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_pink.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_hsv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_rainbow.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_jet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_autumn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_cool.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_mkpj2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_spring.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/colormaps/colorscale_hot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/lbp/patterns.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/lbp/lbp_yale.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/contrib/doc/facerec/img/lbp/lbp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ocl/doc/images/adaptiveBilateralFilter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/java/android_test/res/drawable/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/java/android_test/res/drawable/lena.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/java/android_test/res/drawable/chessboard.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/java/test/lib/junit-4.11.jar",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ml/doc/pics/neuron_model.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ml/doc/pics/mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/ml/doc/pics/sigmoid_bipolar.png",
        "/tmp/vanessa/spack-stage/spack-stage-opencv-2.4.12.2-ryo6t2wlmagskacop5ybu7r3ejkg7xqm/spack-src/modules/stitching/doc/StitchingPipeline.jpg"
    ],
    "total_files": 4131
}