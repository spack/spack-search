{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lua/lua-5.2.3/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.111.1.1 2013/04/12 18:48:47 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n\n/*\n** if needed, includes windows header before everything else\n*/\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_PATH and LUA_CPATH are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH)\n#define LUA_PATH\t\"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH)\n#define LUA_CPATH\t\"LUA_CPATH\"\n#endif\n\n#define LUA_PATHSUFFIX\t\t\"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_PATHVERSION\t\tLUA_PATH LUA_PATHSUFFIX\n#define LUA_CPATHVERSION\tLUA_CPATH LUA_PATHSUFFIX\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_PATH_SEP)\n#define LUA_PATH_SEP\t\t\";\"\n#endif\n#if !defined (LUA_PATH_MARK)\n#define LUA_PATH_MARK\t\t\"?\"\n#endif\n#if !defined (LUA_EXEC_DIR)\n#define LUA_EXEC_DIR\t\t\"!\"\n#endif\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/* table (in the registry) that keeps handles for all loaded C libraries */\n#define CLIBS\t\t\"_CLIBS\"\n\n#define LIB_FAIL\t\"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n#define setprogdir(L)\t\t((void)0)\n\n\n/*\n** system-dependent functions\n*/\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path, int seeglb);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_USE_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#undef setprogdir\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\nstatic void *ll_checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\nstatic void ll_addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  int n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    ll_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = ll_load(L, path, *sym == '*');\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    ll_addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = ll_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module \" LUA_QS\n                         \" from file \" LUA_QS \":\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *funcname;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    funcname = lua_pushlstring(L, modname, mark - modname);\n    funcname = lua_pushfstring(L, LUA_POF\"%s\", funcname);\n    stat = ll_loadfunc(L, filename, funcname);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  funcname = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return ll_loadfunc(L, filename, funcname);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                         name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  lua_getfield(L, lua_upvalueindex(1), \"searchers\");  /* will be at index 3 */\n  if (!lua_istable(L, 3))\n    luaL_error(L, LUA_QL(\"package.searchers\") \" must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, 3, i);  /* get a searcher */\n    if (lua_isnil(L, -1)) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);  /* _LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_isnil(L, -1)) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname1,\n                                   const char *envname2, const char *def) {\n  const char *path = getenv(envname1);\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname2);  /* try alternative name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with pre-defined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  /* create table CLIBS to keep track of loaded C libraries */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_createtable(L, 0, 1);  /* metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  /* create `package' table */\n  luaL_newlib(L, pk_funcs);\n  createsearcherstable(L);\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field `loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n  /* set field 'path' */\n  setpath(L, \"path\", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);\n  /* set field 'cpath' */\n  setpath(L, \"cpath\", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osg/GLExtensions.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n#include <osg/GLExtensions>\n#include <osg/GL>\n#include <osg/Notify>\n#include <osg/Math>\n#include <osg/buffered_value>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <float.h>\n\n#include <string>\n#include <vector>\n#include <set>\n\n#if defined(WIN32)\n    #ifndef WIN32_LEAN_AND_MEAN\n        #define WIN32_LEAN_AND_MEAN\n    #endif // WIN32_LEAN_AND_MEAN\n    #ifndef NOMINMAX\n        #define NOMINMAX\n    #endif // NOMINMAX\n    #include <windows.h>\n#elif defined(__APPLE__)\n    // The NS*Symbol* stuff found in <mach-o/dyld.h> is deprecated.\n    // Since 10.3 (Panther) OS X has provided the dlopen/dlsym/dlclose\n    // family of functions under <dlfcn.h>. Since 10.4 (Tiger), Apple claimed\n    // the dlfcn family was significantly faster than the NS*Symbol* family.\n    // Since 'deprecated' needs to be taken very seriously with the\n    // coming of 10.5 (Leopard), it makes sense to use the dlfcn family when possible.\n    #include <AvailabilityMacros.h>\n    #if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n        #define USE_APPLE_LEGACY_NSSYMBOL\n        #include <mach-o/dyld.h>\n    #else\n        #include <dlfcn.h>\n    #endif\n#else\n    #include <dlfcn.h>\n#endif\n\nusing namespace osg;\n\ntypedef std::set<std::string>  ExtensionSet;\nstatic osg::buffered_object<ExtensionSet> s_glExtensionSetList;\nstatic osg::buffered_object<std::string> s_glRendererList;\nstatic osg::buffered_value<int> s_glInitializedList;\n\nstatic osg::buffered_object<ExtensionSet> s_gluExtensionSetList;\nstatic osg::buffered_object<std::string> s_gluRendererList;\nstatic osg::buffered_value<int> s_gluInitializedList;\n\nfloat osg::getGLVersionNumber()\n{\n    // needs to be extended to do proper things with subversions like 1.5.1, etc.\n    char *versionstring   = (char*) glGetString( GL_VERSION );\n    if (!versionstring) return 0.0;\n\n    return (findAsciiToFloat(versionstring));\n}\n\nbool osg::isExtensionInExtensionString(const char *extension, const char *extensionString)\n{\n    const char *startOfWord = extensionString;\n    const char *endOfWord;\n    while ((endOfWord = strchr(startOfWord,' ')) != 0)\n    {\n        if (strncmp(extension, startOfWord, endOfWord - startOfWord) == 0)\n            return true;\n        startOfWord = endOfWord+1;\n    }\n    if (*startOfWord && strcmp(extension, startOfWord) == 0)\n        return true;\n\n   return false;\n}\n\nbool osg::isGLExtensionSupported(unsigned int contextID, const char *extension)\n{\n    return osg::isGLExtensionOrVersionSupported(contextID, extension, FLT_MAX);\n}\n\nbool osg::isGLExtensionOrVersionSupported(unsigned int contextID, const char *extension, float requiredGLVersion)\n{\n    ExtensionSet& extensionSet = s_glExtensionSetList[contextID];\n    std::string& rendererString = s_glRendererList[contextID];\n\n    // first check to see if GL version number of recent enough.\n    bool result = requiredGLVersion <= osg::getGLVersionNumber();\n\n    if (!result)\n    {\n        // if not already set up, initialize all the per graphic context values.\n        if (!s_glInitializedList[contextID])\n        {\n            s_glInitializedList[contextID] = 1;\n\n            // set up the renderer\n            const GLubyte* renderer = glGetString(GL_RENDERER);\n            rendererString = renderer ? (const char*)renderer : \"\";\n\n            // get the extension list from OpenGL.\n            GLint numExt = 0;\n            #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)\n            if( osg::getGLVersionNumber() >= 3.0 )\n            {\n                // OpenGL 3.0 adds the concept of indexed strings and\n                // deprecates calls to glGetString( GL_EXTENSIONS ), which\n                // will now generate GL_INVALID_ENUM.\n\n                // Get extensions using new indexed string interface.\n\n                typedef const GLubyte * GL_APIENTRY PFNGLGETSTRINGIPROC( GLenum, GLuint );\n                PFNGLGETSTRINGIPROC* glGetStringi = 0;\n                setGLExtensionFuncPtr( glGetStringi, \"glGetStringi\");\n\n                if( glGetStringi != NULL )\n                {\n                    #  ifndef GL_NUM_EXTENSIONS\n                    #    define GL_NUM_EXTENSIONS 0x821D\n                    #  endif\n                    glGetIntegerv( GL_NUM_EXTENSIONS, &numExt );\n                    int idx;\n                    for( idx=0; idx<numExt; idx++ )\n                    {\n                        extensionSet.insert( std::string( (char*)( glGetStringi( GL_EXTENSIONS, idx ) ) ) );\n                    }\n                }\n                else\n                {\n                    OSG_WARN << \"isGLExtensionOrVersionSupported: Can't obtain glGetStringi function pointer.\" << std::endl;\n                }\n            }\n            #endif\n\n            // No extensions found so far, so try with glGetString\n            if (numExt == 0)\n            {\n                // Get extensions using GL1/2 interface.\n\n                const char* extensions = (const char*)glGetString(GL_EXTENSIONS);\n                if (extensions==NULL) return false;\n\n                // insert the ' ' delimiated extensions words into the extensionSet.\n                const char *startOfWord = extensions;\n                const char *endOfWord;\n                while ((endOfWord = strchr(startOfWord,' '))!=NULL)\n                {\n                    extensionSet.insert(std::string(startOfWord,endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord!=0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #if defined(WIN32) && (defined(OSG_GL1_AVAILABLE) || defined(OSG_GL2_AVAILABLE) || defined(OSG_GL3_AVAILABLE))\n\n            // add WGL extensions to the list\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGARB(HDC);\n            WGLGETEXTENSIONSSTRINGARB* wglGetExtensionsStringARB = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringARB, \"wglGetExtensionsStringARB\");\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGEXT();\n            WGLGETEXTENSIONSSTRINGEXT* wglGetExtensionsStringEXT = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringEXT, \"wglGetExtensionsStringEXT\");\n\n            const char* wglextensions = 0;\n\n            if (wglGetExtensionsStringARB)\n            {\n                HDC dc = wglGetCurrentDC();\n                wglextensions = wglGetExtensionsStringARB(dc);\n            }\n            else if (wglGetExtensionsStringEXT)\n            {\n                wglextensions = wglGetExtensionsStringEXT();\n            }\n\n            if (wglextensions)\n            {\n                const char* startOfWord = wglextensions;\n                const char* endOfWord;\n                while ((endOfWord = strchr(startOfWord, ' ')))\n                {\n                    extensionSet.insert(std::string(startOfWord, endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord != 0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #endif\n\n            OSG_NOTIFY(INFO)<<\"OpenGL extensions supported by installed OpenGL drivers are:\"<<std::endl;\n            for(ExtensionSet::iterator itr=extensionSet.begin();\n                itr!=extensionSet.end();\n                ++itr)\n            {\n                OSG_NOTIFY(INFO)<<\"    \"<<*itr<<std::endl;\n            }\n\n        }\n\n        // true if extension found in extensionSet.\n        result = extensionSet.find(extension)!=extensionSet.end();\n    }\n\n    // now see if extension is in the extension disabled list\n    bool extensionDisabled = false;\n    if (result)\n    {\n\n        const std::string& disableString = getGLExtensionDisableString();\n        if (!disableString.empty())\n        {\n\n            std::string::size_type pos=0;\n            while ( pos!=std::string::npos && (pos=disableString.find(extension,pos))!=std::string::npos )\n            {\n                std::string::size_type previousColon = disableString.find_last_of(':',pos);\n                std::string::size_type previousSemiColon = disableString.find_last_of(';',pos);\n\n                std::string renderer = \"\";\n                if (previousColon!=std::string::npos)\n                {\n                    if (previousSemiColon==std::string::npos) renderer = disableString.substr(0,previousColon);\n                    else if (previousSemiColon<previousColon) renderer = disableString.substr(previousSemiColon+1,previousColon-previousSemiColon-1);\n                }\n\n                if (!renderer.empty())\n                {\n\n                    // remove leading spaces if they exist.\n                    std::string::size_type leadingSpaces = renderer.find_first_not_of(' ');\n                    if (leadingSpaces==std::string::npos) renderer = \"\"; // nothing but spaces\n                    else if (leadingSpaces!=0) renderer.erase(0,leadingSpaces);\n\n                    // remove trailing spaces if they exist.\n                    std::string::size_type trailingSpaces = renderer.find_last_not_of(' ');\n                    if (trailingSpaces!=std::string::npos) renderer.erase(trailingSpaces+1,std::string::npos);\n\n                }\n\n                if (renderer.empty())\n                {\n                    extensionDisabled = true;\n                    break;\n                }\n\n                if (rendererString.find(renderer)!=std::string::npos)\n                {\n                    extensionDisabled = true;\n                    break;\n\n                }\n\n                // move the position in the disable string along so that the same extension is found multiple times\n                ++pos;\n            }\n\n        }\n    }\n\n    if (result)\n    {\n        if (!extensionDisabled)\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported.\"<<std::endl;\n        }\n        else\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported by OpenGL\\ndriver but has been disabled by osg::getGLExtensionDisableString().\"<<std::endl;\n        }\n    }\n    else\n    {\n        OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is not supported.\"<<std::endl;\n    }\n\n\n    return result && !extensionDisabled;\n}\n\nvoid osg::setGLExtensionDisableString(const std::string& disableString)\n{\n    getGLExtensionDisableString() = disableString;\n}\n\nstd::string& osg::getGLExtensionDisableString()\n{\n    static const char* envVar = getenv(\"OSG_GL_EXTENSION_DISABLE\");\n    static std::string s_GLExtensionDisableString(envVar?envVar:\"Nothing defined\");\n\n    return s_GLExtensionDisableString;\n}\n\nOSG_INIT_SINGLETON_PROXY(GLExtensionDisableStringInitializationProxy, osg::getGLExtensionDisableString())\n\n#ifdef OSG_GL_LIBRARY_STATIC\n\n    #include \"GLStaticLibrary.h\"\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        return GLStaticLibrary::getProcAddress(funcName);\n    }\n\n#else\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        // OSG_NOTICE<<\"osg::getGLExtensionFuncPtr(\"<<funcName<<\")\"<<std::endl;\n    #if defined(__ANDROID__)\n        #if defined(OSG_GLES1_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv1_CM.so\", RTLD_NOW);\n        #elif defined(OSG_GLES2_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv2.so\", RTLD_NOW);\n        #endif\n        return dlsym(handle, funcName);\n\n    #elif defined(WIN32)\n\n        #if defined(OSG_GLES2_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandle(TEXT(\"libGLESv2.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #elif defined(OSG_GLES1_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandleA(TEXT(\"libgles_cm.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #else\n            return convertPointerType<void*, PROC>(wglGetProcAddress(funcName));\n        #endif\n\n    #elif defined(__APPLE__)\n\n        #if defined(USE_APPLE_LEGACY_NSSYMBOL)\n            std::string temp( \"_\" );\n            temp += funcName;    // Mac OS X prepends an underscore on function names\n            if ( NSIsSymbolNameDefined( temp.c_str() ) )\n            {\n                NSSymbol symbol = NSLookupAndBindSymbol( temp.c_str() );\n                return NSAddressOfSymbol( symbol );\n            } else\n                return NULL;\n        #else\n            // I am uncertain of the correct and ideal usage of dlsym here.\n            // On the surface, it would seem that the FreeBSD implementation\n            // would be the ideal one to copy, but ELF and Mach-o are different\n            // and Apple's man page says the following about using RTLD_DEFAULT:\n            // \"This can be a costly search and should be avoided.\"\n            // The documentation mentions nothing about passing in 0 so I must\n            // assume the behavior is undefined.\n            // So I could try copying the Sun method which I think all this\n            // actually originated from.\n\n            // return dlsym( RTLD_DEFAULT, funcName );\n            static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n            return dlsym(handle, funcName);\n        #endif\n\n    #elif defined (__sun)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__sgi)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__FreeBSD__)\n\n        return dlsym( RTLD_DEFAULT, funcName );\n\n    #elif defined (__linux__)\n\n        typedef void (*__GLXextFuncPtr)(void);\n        typedef __GLXextFuncPtr (*GetProcAddressARBProc)(const char*);\n\n        #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)\n        static GetProcAddressARBProc s_glXGetProcAddressARB = convertPointerType<GetProcAddressARBProc, void*>(dlsym(0, \"glXGetProcAddressARB\"));\n        if (s_glXGetProcAddressARB)\n        {\n            return convertPointerType<void*, __GLXextFuncPtr>((s_glXGetProcAddressARB)(funcName));\n        }\n        #endif\n\n        return dlsym(0, funcName);\n\n    #elif defined (__QNX__)\n\n        return dlsym(RTLD_DEFAULT, funcName);\n\n    #else // all other unixes\n\n        return dlsym(0, funcName);\n\n    #endif\n    }\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n// Static array of percontext osg::GLExtensions instances\n\ntypedef osg::buffered_object< osg::ref_ptr<GLExtensions> > BufferedExtensions;\nstatic BufferedExtensions s_extensions;\n\nGLExtensions* GLExtensions::Get(unsigned int contextID, bool createIfNotInitalized)\n{\n    if (!s_extensions[contextID] && createIfNotInitalized)\n            s_extensions[contextID] = new GLExtensions(contextID);\n\n    return s_extensions[contextID].get();\n}\n\nvoid GLExtensions::Set(unsigned int contextID, GLExtensions* extensions)\n{\n    s_extensions[contextID] = extensions;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Extension function pointers for OpenGL v2.x\n\nGLExtensions::GLExtensions(unsigned int contextID)\n{\n    const char* version = (const char*) glGetString( GL_VERSION );\n    if (!version)\n    {\n        OSG_NOTIFY(osg::FATAL)<<\"Error: OpenGL version test failed, requires valid graphics context.\"<<std::endl;\n        return;\n    }\n\n    glVersion = findAsciiToFloat( version );\n    glslLanguageVersion = 0.0f;\n\n    bool shadersBuiltIn = OSG_GLES2_FEATURES || OSG_GL3_FEATURES;\n\n    isShaderObjectsSupported = shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_shader_objects\");\n    isVertexShaderSupported = shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_vertex_shader\");\n    isFragmentShaderSupported = shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_fragment_shader\");\n    isLanguage100Supported = shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_shading_language_100\");\n    isGeometryShader4Supported = osg::isGLExtensionSupported(contextID,\"GL_EXT_geometry_shader4\");\n    isGpuShader4Supported = osg::isGLExtensionSupported(contextID,\"GL_EXT_gpu_shader4\");\n    areTessellationShadersSupported = osg::isGLExtensionSupported(contextID, \"GL_ARB_tessellation_shader\");\n    isUniformBufferObjectSupported = osg::isGLExtensionSupported(contextID,\"GL_ARB_uniform_buffer_object\");\n    isGetProgramBinarySupported = osg::isGLExtensionSupported(contextID,\"GL_ARB_get_program_binary\");\n    isGpuShaderFp64Supported = osg::isGLExtensionSupported(contextID,\"GL_ARB_gpu_shader_fp64\");\n    isShaderAtomicCountersSupported = osg::isGLExtensionSupported(contextID,\"GL_ARB_shader_atomic_counters\");\n\n    isRectangleSupported = OSG_GL3_FEATURES ||\n                           isGLExtensionSupported(contextID,\"GL_ARB_texture_rectangle\") ||\n                           isGLExtensionSupported(contextID,\"GL_EXT_texture_rectangle\") ||\n                           isGLExtensionSupported(contextID,\"GL_NV_texture_rectangle\");\n\n    isCubeMapSupported = OSG_GLES2_FEATURES || OSG_GL3_FEATURES ||\n                          isGLExtensionSupported(contextID,\"GL_ARB_texture_cube_map\") ||\n                          isGLExtensionSupported(contextID,\"GL_EXT_texture_cube_map\") ||\n                          (glVersion >= 1.3f);\n\n    isClipControlSupported = isGLExtensionSupported(contextID,\"GL_ARB_clip_control\") ||\n                             (glVersion >= 4.5f);\n\n\n    isGlslSupported = ( glVersion >= 2.0f ) ||\n                      ( isShaderObjectsSupported &&\n                        isVertexShaderSupported &&\n                        isFragmentShaderSupported &&\n                        isLanguage100Supported );\n\n    if( isGlslSupported )\n    {\n        // If glGetString raises an error, assume initial release \"1.00\"\n        while(glGetError() != GL_NO_ERROR) {}        // reset error flag\n\n        const char* langVerStr = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);\n        if( (glGetError() == GL_NO_ERROR) && langVerStr )\n        {\n            glslLanguageVersion = (findAsciiToFloat(langVerStr));\n        }\n        else\n            glslLanguageVersion = 1.0f;\n    }\n\n    OSG_INFO\n            << \"glVersion=\" << glVersion << \", \"\n            << \"isGlslSupported=\" << (isGlslSupported ? \"YES\" : \"NO\") << \", \"\n            << \"glslLanguageVersion=\" << glslLanguageVersion\n            << std::endl;\n\n\n    setGLExtensionFuncPtr(glDrawBuffers, \"glDrawBuffers\", \"glDrawBuffersARB\");\n    setGLExtensionFuncPtr(glAttachShader, \"glAttachShader\", \"glAttachObjectARB\");\n    setGLExtensionFuncPtr(glBindAttribLocation, \"glBindAttribLocation\", \"glBindAttribLocationARB\");\n    setGLExtensionFuncPtr(glCompileShader, \"glCompileShader\", \"glCompileShaderARB\");\n    setGLExtensionFuncPtr(glCreateProgram, \"glCreateProgram\", \"glCreateProgramObjectARB\");\n    setGLExtensionFuncPtr(glCreateShader, \"glCreateShader\", \"glCreateShaderObjectARB\");\n    setGLExtensionFuncPtr(glDeleteProgram, \"glDeleteProgram\");\n    setGLExtensionFuncPtr(glDeleteShader, \"glDeleteShader\");\n    setGLExtensionFuncPtr(glDetachShader, \"glDetachShader\", \"glDetachObjectARB\");\n    setGLExtensionFuncPtr(glDisableVertexAttribArray, \"glDisableVertexAttribArray\");\n    setGLExtensionFuncPtr(glEnableVertexAttribArray, \"glEnableVertexAttribArray\");\n    setGLExtensionFuncPtr(glGetActiveAttrib, \"glGetActiveAttrib\", \"glGetActiveAttribARB\");\n    setGLExtensionFuncPtr(glGetActiveUniform, \"glGetActiveUniform\", \"glGetActiveUniformARB\");\n    setGLExtensionFuncPtr(glGetAttachedShaders, \"glGetAttachedShaders\", \"glGetAttachedObjectsARB\");\n    setGLExtensionFuncPtr(glGetAttribLocation, \"glGetAttribLocation\", \"glGetAttribLocationARB\");\n    setGLExtensionFuncPtr(glGetProgramiv, \"glGetProgramiv\");\n    setGLExtensionFuncPtr(glGetProgramInfoLog, \"glGetProgramInfoLog\");\n    setGLExtensionFuncPtr(glGetShaderiv, \"glGetShaderiv\");\n    setGLExtensionFuncPtr(glGetShaderInfoLog, \"glGetShaderInfoLog\");\n    setGLExtensionFuncPtr(glGetShaderSource, \"glGetShaderSource\", \"glGetShaderSourceARB\");\n    setGLExtensionFuncPtr(glGetUniformLocation, \"glGetUniformLocation\", \"glGetUniformLocationARB\");\n    setGLExtensionFuncPtr(glGetUniformfv, \"glGetUniformfv\", \"glGetUniformfvARB\");\n    setGLExtensionFuncPtr(glGetUniformiv, \"glGetUniformiv\", \"glGetUniformivARB\");\n    setGLExtensionFuncPtr(glGetVertexAttribdv, \"glGetVertexAttribdv\");\n    setGLExtensionFuncPtr(glGetVertexAttribfv, \"glGetVertexAttribfv\");\n    setGLExtensionFuncPtr(glGetVertexAttribiv, \"glGetVertexAttribiv\");\n    setGLExtensionFuncPtr(glGetVertexAttribPointerv, \"glGetVertexAttribPointerv\");\n    setGLExtensionFuncPtr(glIsProgram, \"glIsProgram\");\n    setGLExtensionFuncPtr(glIsShader, \"glIsShader\");\n    setGLExtensionFuncPtr(glLinkProgram, \"glLinkProgram\", \"glLinkProgramARB\");\n    setGLExtensionFuncPtr(glShaderSource, \"glShaderSource\", \"glShaderSourceARB\");\n    setGLExtensionFuncPtr(glUseProgram, \"glUseProgram\", \"glUseProgramObjectARB\");\n    setGLExtensionFuncPtr(glUniform1f, \"glUniform1f\", \"glUniform1fARB\");\n    setGLExtensionFuncPtr(glUniform2f, \"glUniform2f\", \"glUniform2fARB\");\n    setGLExtensionFuncPtr(glUniform3f, \"glUniform3f\", \"glUniform3fARB\");\n    setGLExtensionFuncPtr(glUniform4f, \"glUniform4f\", \"glUniform4fARB\");\n    setGLExtensionFuncPtr(glUniform1i, \"glUniform1i\", \"glUniform1iARB\");\n    setGLExtensionFuncPtr(glUniform2i, \"glUniform2i\", \"glUniform2iARB\");\n    setGLExtensionFuncPtr(glUniform3i, \"glUniform3i\", \"glUniform3iARB\");\n    setGLExtensionFuncPtr(glUniform4i, \"glUniform4i\", \"glUniform4iARB\");\n    setGLExtensionFuncPtr(glUniform1fv, \"glUniform1fv\", \"glUniform1fvARB\");\n    setGLExtensionFuncPtr(glUniform2fv, \"glUniform2fv\", \"glUniform2fvARB\");\n    setGLExtensionFuncPtr(glUniform3fv, \"glUniform3fv\", \"glUniform3fvARB\");\n    setGLExtensionFuncPtr(glUniform4fv, \"glUniform4fv\", \"glUniform4fvARB\");\n    setGLExtensionFuncPtr(glUniform1iv, \"glUniform1iv\", \"glUniform1ivARB\");\n    setGLExtensionFuncPtr(glUniform2iv, \"glUniform2iv\", \"glUniform2ivARB\");\n    setGLExtensionFuncPtr(glUniform3iv, \"glUniform3iv\", \"glUniform3ivARB\");\n    setGLExtensionFuncPtr(glUniform4iv, \"glUniform4iv\", \"glUniform4ivARB\");\n    setGLExtensionFuncPtr(glUniformMatrix2fv, \"glUniformMatrix2fv\", \"glUniformMatrix2fvARB\");\n    setGLExtensionFuncPtr(glUniformMatrix3fv, \"glUniformMatrix3fv\", \"glUniformMatrix3fvARB\");\n    setGLExtensionFuncPtr(glUniformMatrix4fv, \"glUniformMatrix4fv\", \"glUniformMatrix4fvARB\");\n    setGLExtensionFuncPtr(glValidateProgram, \"glValidateProgram\", \"glValidateProgramARB\");\n    setGLExtensionFuncPtr(glVertexAttrib1d, \"glVertexAttrib1d\");\n    setGLExtensionFuncPtr(glVertexAttrib1dv, \"glVertexAttrib1dv\");\n    setGLExtensionFuncPtr(glVertexAttrib1f, \"glVertexAttrib1f\");\n    setGLExtensionFuncPtr(glVertexAttrib1fv, \"glVertexAttrib1fv\");\n    setGLExtensionFuncPtr(glVertexAttrib1s, \"glVertexAttrib1s\");\n    setGLExtensionFuncPtr(glVertexAttrib1sv, \"glVertexAttrib1sv\");\n    setGLExtensionFuncPtr(glVertexAttrib2d, \"glVertexAttrib2d\");\n    setGLExtensionFuncPtr(glVertexAttrib2dv, \"glVertexAttrib2dv\");\n    setGLExtensionFuncPtr(glVertexAttrib2f, \"glVertexAttrib2f\");\n    setGLExtensionFuncPtr(glVertexAttrib2fv, \"glVertexAttrib2fv\");\n    setGLExtensionFuncPtr(glVertexAttrib2s, \"glVertexAttrib2s\");\n    setGLExtensionFuncPtr(glVertexAttrib2sv, \"glVertexAttrib2sv\");\n    setGLExtensionFuncPtr(glVertexAttrib3d, \"glVertexAttrib3d\");\n    setGLExtensionFuncPtr(glVertexAttrib3dv, \"glVertexAttrib3dv\");\n    setGLExtensionFuncPtr(glVertexAttrib3f, \"glVertexAttrib3f\");\n    setGLExtensionFuncPtr(glVertexAttrib3fv, \"glVertexAttrib3fv\");\n    setGLExtensionFuncPtr(glVertexAttrib3s, \"glVertexAttrib3s\");\n    setGLExtensionFuncPtr(glVertexAttrib3sv, \"glVertexAttrib3sv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nbv, \"glVertexAttrib4Nbv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Niv, \"glVertexAttrib4Niv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nsv, \"glVertexAttrib4Nsv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nub, \"glVertexAttrib4Nub\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nubv, \"glVertexAttrib4Nubv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nuiv, \"glVertexAttrib4Nuiv\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nusv, \"glVertexAttrib4Nusv\");\n    setGLExtensionFuncPtr(glVertexAttrib4bv, \"glVertexAttrib4bv\");\n    setGLExtensionFuncPtr(glVertexAttrib4d, \"glVertexAttrib4d\");\n    setGLExtensionFuncPtr(glVertexAttrib4dv, \"glVertexAttrib4dv\");\n    setGLExtensionFuncPtr(glVertexAttrib4f, \"glVertexAttrib4f\");\n    setGLExtensionFuncPtr(glVertexAttrib4fv, \"glVertexAttrib4fv\");\n    setGLExtensionFuncPtr(glVertexAttrib4iv, \"glVertexAttrib4iv\");\n    setGLExtensionFuncPtr(glVertexAttrib4s, \"glVertexAttrib4s\");\n    setGLExtensionFuncPtr(glVertexAttrib4sv, \"glVertexAttrib4sv\");\n    setGLExtensionFuncPtr(glVertexAttrib4ubv, \"glVertexAttrib4ubv\");\n    setGLExtensionFuncPtr(glVertexAttrib4uiv, \"glVertexAttrib4uiv\");\n    setGLExtensionFuncPtr(glVertexAttrib4usv, \"glVertexAttrib4usv\");\n    setGLExtensionFuncPtr(glVertexAttribPointer, \"glVertexAttribPointer\");\n    setGLExtensionFuncPtr(glVertexAttribDivisor, \"glVertexAttribDivisor\");\n\n    // v1.5-only ARB entry points, in case they're needed for fallback\n    setGLExtensionFuncPtr(glGetInfoLogARB, \"glGetInfoLogARB\");\n    setGLExtensionFuncPtr(glGetObjectParameterivARB, \"glGetObjectParameterivARB\");\n    setGLExtensionFuncPtr(glDeleteObjectARB, \"glDeleteObjectARB\");\n    setGLExtensionFuncPtr(glGetHandleARB, \"glGetHandleARB\");\n\n    // GL 2.1\n    setGLExtensionFuncPtr(glUniformMatrix2x3fv,  \"glUniformMatrix2x3fv\" );\n    setGLExtensionFuncPtr(glUniformMatrix3x2fv,  \"glUniformMatrix3x2fv\" );\n    setGLExtensionFuncPtr(glUniformMatrix2x4fv,  \"glUniformMatrix2x4fv\" );\n    setGLExtensionFuncPtr(glUniformMatrix4x2fv,  \"glUniformMatrix4x2fv\" );\n    setGLExtensionFuncPtr(glUniformMatrix3x4fv,  \"glUniformMatrix3x4fv\" );\n    setGLExtensionFuncPtr(glUniformMatrix4x3fv,  \"glUniformMatrix4x3fv\" );\n\n    // ARB_clip_control\n    setGLExtensionFuncPtr(glClipControl, \"glClipControl\");\n\n    // EXT_geometry_shader4\n    setGLExtensionFuncPtr(glProgramParameteri,  \"glProgramParameteri\", \"glProgramParameteriEXT\" );\n\n    // ARB_tesselation_shader\n    setGLExtensionFuncPtr(glPatchParameteri, \"glPatchParameteri\" );\n    setGLExtensionFuncPtr(glPatchParameterfv, \"glPatchParameterfv\");\n\n    // EXT_gpu_shader4\n    setGLExtensionFuncPtr(glGetUniformuiv,  \"glGetUniformuiv\", \"glGetUniformuivEXT\" );\n    setGLExtensionFuncPtr(glBindFragDataLocation,  \"glBindFragDataLocation\", \"glBindFragDataLocationEXT\" );\n    setGLExtensionFuncPtr(glGetFragDataLocation,  \"glGetFragDataLocation\", \"glGetFragDataLocationEXT\" );\n    setGLExtensionFuncPtr(glUniform1ui,  \"glUniform1ui\", \"glUniform1uiEXT\" );\n    setGLExtensionFuncPtr(glUniform2ui,  \"glUniform2ui\", \"glUniform2uiEXT\" );\n    setGLExtensionFuncPtr(glUniform3ui,  \"glUniform3ui\", \"glUniform3uiEXT\" );\n    setGLExtensionFuncPtr(glUniform4ui,  \"glUniform4ui\", \"glUniform4uiEXT\" );\n    setGLExtensionFuncPtr(glUniform1uiv,  \"glUniform1uiv\", \"glUniform1uivEXT\" );\n    setGLExtensionFuncPtr(glUniform2uiv,  \"glUniform2uiv\", \"glUniform2uivEXT\" );\n    setGLExtensionFuncPtr(glUniform3uiv,  \"glUniform3uiv\", \"glUniform3uivEXT\" );\n    setGLExtensionFuncPtr(glUniform4uiv,  \"glUniform4uiv\", \"glUniform4uivEXT\" );\n    // ARB_uniform_buffer_object\n    setGLExtensionFuncPtr(glGetUniformIndices, \"glGetUniformIndices\");\n    setGLExtensionFuncPtr(glGetActiveUniformsiv, \"glGetActiveUniformsiv\");\n    setGLExtensionFuncPtr(glGetActiveUniformName, \"glGetActiveUniformName\");\n    setGLExtensionFuncPtr(glGetUniformBlockIndex, \"glGetUniformBlockIndex\");\n    setGLExtensionFuncPtr(glGetActiveUniformBlockiv, \"glGetActiveUniformBlockiv\");\n    setGLExtensionFuncPtr(glGetActiveUniformBlockName, \"glGetActiveUniformBlockName\");\n    setGLExtensionFuncPtr(glUniformBlockBinding, \"glUniformBlockBinding\");\n\n    // ARB_get_program_binary\n    setGLExtensionFuncPtr(glGetProgramBinary, \"glGetProgramBinary\");\n    setGLExtensionFuncPtr(glProgramBinary, \"glProgramBinary\");\n\n    // ARB_gpu_shader_fp64\n    setGLExtensionFuncPtr(glUniform1d, \"glUniform1d\" );\n    setGLExtensionFuncPtr(glUniform2d, \"glUniform2d\" );\n    setGLExtensionFuncPtr(glUniform3d, \"glUniform3d\" );\n    setGLExtensionFuncPtr(glUniform4d, \"glUniform4d\" );\n    setGLExtensionFuncPtr(glUniform1dv, \"glUniform1dv\" );\n    setGLExtensionFuncPtr(glUniform2dv, \"glUniform2dv\" );\n    setGLExtensionFuncPtr(glUniform3dv, \"glUniform3dv\" );\n    setGLExtensionFuncPtr(glUniform4dv, \"glUniform4dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix2dv, \"glUniformMatrix2dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix3dv, \"glUniformMatrix3dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix4dv, \"glUniformMatrix4dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix2x3dv,  \"glUniformMatrix2x3dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix3x2dv,  \"glUniformMatrix3x2dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix2x4dv,  \"glUniformMatrix2x4dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix4x2dv,  \"glUniformMatrix4x2dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix3x4dv,  \"glUniformMatrix3x4dv\" );\n    setGLExtensionFuncPtr(glUniformMatrix4x3dv,  \"glUniformMatrix4x3dv\" );\n\n    // ARB_shader_atomic_counters\n    setGLExtensionFuncPtr(glGetActiveAtomicCounterBufferiv,  \"glGetActiveAtomicCounterBufferiv\" );\n\n    // ARB_compute_shader\n    setGLExtensionFuncPtr(glDispatchCompute,  \"glDispatchCompute\" );\n\n    setGLExtensionFuncPtr(glMemoryBarrier,  \"glMemoryBarrier\", \"glMemoryBarrierEXT\" );\n\n    // BufferObject extensions\n    setGLExtensionFuncPtr(glGenBuffers, \"glGenBuffers\",\"glGenBuffersARB\");\n    setGLExtensionFuncPtr(glBindBuffer, \"glBindBuffer\",\"glBindBufferARB\");\n    setGLExtensionFuncPtr(glBufferData, \"glBufferData\",\"glBufferDataARB\");\n    setGLExtensionFuncPtr(glBufferSubData, \"glBufferSubData\",\"glBufferSubDataARB\");\n    setGLExtensionFuncPtr(glDeleteBuffers, \"glDeleteBuffers\",\"glDeleteBuffersARB\");\n    setGLExtensionFuncPtr(glIsBuffer, \"glIsBuffer\",\"glIsBufferARB\");\n    setGLExtensionFuncPtr(glGetBufferSubData, \"glGetBufferSubData\",\"glGetBufferSubDataARB\");\n    setGLExtensionFuncPtr(glMapBuffer, \"glMapBuffer\",\"glMapBufferARB\");\n    setGLExtensionFuncPtr(glMapBufferRange,  \"glMapBufferRange\" );\n    setGLExtensionFuncPtr(glUnmapBuffer, \"glUnmapBuffer\",\"glUnmapBufferARB\");\n    setGLExtensionFuncPtr(glGetBufferParameteriv, \"glGetBufferParameteriv\",\"glGetBufferParameterivARB\");\n    setGLExtensionFuncPtr(glGetBufferPointerv, \"glGetBufferPointerv\",\"glGetBufferPointervARB\");\n    setGLExtensionFuncPtr(glBindBufferRange, \"glBindBufferRange\");\n    setGLExtensionFuncPtr(glBindBufferBase,  \"glBindBufferBase\", \"glBindBufferBaseEXT\", \"glBindBufferBaseNV\" );\n    setGLExtensionFuncPtr(glTexBuffer, \"glTexBuffer\",\"glTexBufferARB\" );\n\n    isPBOSupported = OSG_GL3_FEATURES || osg::isGLExtensionSupported(contextID,\"GL_ARB_pixel_buffer_object\");\n    isUniformBufferObjectSupported = osg::isGLExtensionSupported(contextID, \"GL_ARB_uniform_buffer_object\");\n    isTBOSupported = osg::isGLExtensionSupported(contextID,\"GL_ARB_texture_buffer_object\");\n    isVAOSupported = osg::isGLExtensionSupported(contextID, \"GL_ARB_vertex_array_object\");\n    isTransformFeedbackSupported = osg::isGLExtensionSupported(contextID, \"GL_ARB_transform_feedback2\");\n\n    // BlendFunc extensions\n    isBlendFuncSeparateSupported = OSG_GLES2_FEATURES || OSG_GL3_FEATURES ||\n                                    osg::isGLExtensionSupported(contextID, \"GL_EXT_blend_func_separate\") ||\n                                    (glVersion >= 1.4f);\n\n    setGLExtensionFuncPtr(glBlendFuncSeparate, \"glBlendFuncSeparate\", \"glBlendFuncSeparateEXT\");\n\n    setGLExtensionFuncPtr(glBlendFunci, \"glBlendFunci\", \"glBlendFunciARB\");\n    setGLExtensionFuncPtr(glBlendFuncSeparatei, \"glBlendFuncSeparatei\", \"glBlendFuncSeparateiARB\");\n\n\n    // Vertex Array extensions\n    isSecondaryColorSupported = isGLExtensionSupported(contextID,\"GL_EXT_secondary_color\");\n    isFogCoordSupported = isGLExtensionSupported(contextID,\"GL_EXT_fog_coord\");\n    isMultiTexSupported = isGLExtensionSupported(contextID,\"GL_ARB_multitexture\");\n    isOcclusionQuerySupported = osg::isGLExtensionSupported(contextID, \"GL_NV_occlusion_query\" );\n    isARBOcclusionQuerySupported = OSG_GL3_FEATURES || osg::isGLExtensionSupported(contextID, \"GL_ARB_occlusion_query\" );\n\n    isTimerQuerySupported = osg::isGLExtensionSupported(contextID, \"GL_EXT_timer_query\" );\n    isARBTimerQuerySupported = osg::isGLExtensionSupported(contextID, \"GL_ARB_timer_query\");\n\n    setGLExtensionFuncPtr(glFogCoordfv, \"glFogCoordfv\",\"glFogCoordfvEXT\");\n    setGLExtensionFuncPtr(glSecondaryColor3ubv, \"glSecondaryColor3ubv\",\"glSecondaryColor3ubvEXT\");\n    setGLExtensionFuncPtr(glSecondaryColor3fv, \"glSecondaryColor3fv\",\"glSecondaryColor3fvEXT\");\n    setGLExtensionFuncPtr(glMultiTexCoord1f, \"glMultiTexCoord1f\",\"glMultiTexCoord1fARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord1fv, \"glMultiTexCoord1fv\",\"glMultiTexCoord1fvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord2fv, \"glMultiTexCoord2fv\",\"glMultiTexCoord2fvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord3fv, \"glMultiTexCoord3fv\",\"glMultiTexCoord3fvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord4fv, \"glMultiTexCoord4fv\",\"glMultiTexCoord4fvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord1d, \"glMultiTexCoord1d\",\"glMultiTexCoorddfARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord2dv, \"glMultiTexCoord2dv\",\"glMultiTexCoord2dvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord3dv, \"glMultiTexCoord3dv\",\"glMultiTexCoord3dvARB\");\n    setGLExtensionFuncPtr(glMultiTexCoord4dv, \"glMultiTexCoord4dv\",\"glMultiTexCoord4dvARB\");\n\n    setGLExtensionFuncPtr(glVertexAttrib1s, \"glVertexAttrib1s\",\"glVertexAttrib1sARB\");\n    setGLExtensionFuncPtr(glVertexAttrib1f, \"glVertexAttrib1f\",\"glVertexAttrib1fARB\");\n    setGLExtensionFuncPtr(glVertexAttrib1d, \"glVertexAttrib1d\",\"glVertexAttrib1dARB\");\n    setGLExtensionFuncPtr(glVertexAttrib1fv, \"glVertexAttrib1fv\",\"glVertexAttrib1fvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib2fv, \"glVertexAttrib2fv\",\"glVertexAttrib2fvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib3fv, \"glVertexAttrib3fv\",\"glVertexAttrib3fvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib4fv, \"glVertexAttrib4fv\",\"glVertexAttrib4fvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib2dv, \"glVertexAttrib2dv\",\"glVertexAttrib2dvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib3dv, \"glVertexAttrib3dv\",\"glVertexAttrib3dvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib4dv, \"glVertexAttrib4dv\",\"glVertexAttrib4dvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib4ubv, \"glVertexAttrib4ubv\",\"glVertexAttrib4ubvARB\");\n    setGLExtensionFuncPtr(glVertexAttrib4Nubv, \"glVertexAttrib4Nubv\",\"glVertexAttrib4NubvARB\");\n\n    setGLExtensionFuncPtr(glGenBuffers, \"glGenBuffers\",\"glGenBuffersARB\");\n    setGLExtensionFuncPtr(glBindBuffer, \"glBindBuffer\",\"glBindBufferARB\");\n    setGLExtensionFuncPtr(glBufferData, \"glBufferData\",\"glBufferDataARB\");\n    setGLExtensionFuncPtr(glBufferSubData, \"glBufferSubData\",\"glBufferSubDataARB\");\n    setGLExtensionFuncPtr(glDeleteBuffers, \"glDeleteBuffers\",\"glDeleteBuffersARB\");\n    setGLExtensionFuncPtr(glIsBuffer, \"glIsBuffer\",\"glIsBufferARB\");\n    setGLExtensionFuncPtr(glGetBufferSubData, \"glGetBufferSubData\",\"glGetBufferSubDataARB\");\n    setGLExtensionFuncPtr(glMapBuffer, \"glMapBuffer\",\"glMapBufferARB\");\n    setGLExtensionFuncPtr(glUnmapBuffer, \"glUnmapBuffer\",\"glUnmapBufferARB\");\n    setGLExtensionFuncPtr(glGetBufferParameteriv, \"glGetBufferParameteriv\",\"glGetBufferParameterivARB\");\n    setGLExtensionFuncPtr(glGetBufferPointerv, \"glGetBufferPointerv\",\"glGetBufferPointervARB\");\n\n    setGLExtensionFuncPtr(glGenOcclusionQueries, \"glGenOcclusionQueries\",\"glGenOcclusionQueriesNV\");\n    setGLExtensionFuncPtr(glDeleteOcclusionQueries, \"glDeleteOcclusionQueries\",\"glDeleteOcclusionQueriesNV\");\n    setGLExtensionFuncPtr(glIsOcclusionQuery, \"glIsOcclusionQuery\",\"_glIsOcclusionQueryNV\");\n    setGLExtensionFuncPtr(glBeginOcclusionQuery, \"glBeginOcclusionQuery\",\"glBeginOcclusionQueryNV\");\n    setGLExtensionFuncPtr(glEndOcclusionQuery, \"glEndOcclusionQuery\",\"glEndOcclusionQueryNV\");\n    setGLExtensionFuncPtr(glGetOcclusionQueryiv, \"glGetOcclusionQueryiv\",\"glGetOcclusionQueryivNV\");\n    setGLExtensionFuncPtr(glGetOcclusionQueryuiv, \"glGetOcclusionQueryuiv\",\"glGetOcclusionQueryuivNV\");\n\n    setGLExtensionFuncPtr(glGenQueries, \"glGenQueries\", \"glGenQueriesARB\");\n    setGLExtensionFuncPtr(glDeleteQueries, \"glDeleteQueries\", \"glDeleteQueriesARB\");\n    setGLExtensionFuncPtr(glIsQuery, \"glIsQuery\", \"glIsQueryARB\");\n    setGLExtensionFuncPtr(glBeginQuery, \"glBeginQuery\", \"glBeginQueryARB\");\n    setGLExtensionFuncPtr(glEndQuery, \"glEndQuery\", \"glEndQueryARB\");\n    setGLExtensionFuncPtr(glGetQueryiv, \"glGetQueryiv\", \"glGetQueryivARB\");\n    setGLExtensionFuncPtr(glGetQueryObjectiv, \"glGetQueryObjectiv\",\"glGetQueryObjectivARB\");\n    setGLExtensionFuncPtr(glGetQueryObjectuiv, \"glGetQueryObjectuiv\",\"glGetQueryObjectuivARB\");\n    setGLExtensionFuncPtr(glGetQueryObjectui64v, \"glGetQueryObjectui64v\",\"glGetQueryObjectui64vEXT\");\n    setGLExtensionFuncPtr(glQueryCounter, \"glQueryCounter\");\n    setGLExtensionFuncPtr(glGetInteger64v, \"glGetInteger64v\");\n\n\n    // SampleMaski functionality\n    isTextureMultisampleSupported = isGLExtensionSupported(contextID, \"GL_ARB_texture_multisample\");\n    isOpenGL32upported = (glVersion >= 3.2f);\n\n    // function pointers\n    setGLExtensionFuncPtr(glSampleMaski, \"glSampleMaski\");\n    // protect against buggy drivers (maybe not necessary)\n    isSampleMaskiSupported = glSampleMaski!=0;\n\n\n\n    // old styple Vertex/Fragment Programs\n    isVertexProgramSupported = isGLExtensionSupported(contextID,\"GL_ARB_vertex_program\");\n    isFragmentProgramSupported = isGLExtensionSupported(contextID,\"GL_ARB_fragment_program\");\n\n    setGLExtensionFuncPtr(glBindProgram,\"glBindProgramARB\");\n    setGLExtensionFuncPtr(glGenPrograms, \"glGenProgramsARB\");\n    setGLExtensionFuncPtr(glDeletePrograms, \"glDeleteProgramsARB\");\n    setGLExtensionFuncPtr(glProgramString, \"glProgramStringARB\");\n    setGLExtensionFuncPtr(glProgramLocalParameter4fv, \"glProgramLocalParameter4fvARB\");\n\n\n\n    // Texture extensions\n    const char* renderer = (const char*) glGetString(GL_RENDERER);\n    std::string rendererString(renderer ? renderer : \"\");\n\n    bool radeonHardwareDetected = (rendererString.find(\"Radeon\")!=std::string::npos || rendererString.find(\"RADEON\")!=std::string::npos);\n    bool fireGLHardwareDetected = (rendererString.find(\"FireGL\")!=std::string::npos || rendererString.find(\"FIREGL\")!=std::string::npos);\n\n    bool builtInSupport = OSG_GLES2_FEATURES || OSG_GL3_FEATURES;\n\n    isMultiTexturingSupported = builtInSupport || OSG_GLES1_FEATURES ||\n                                 isGLExtensionOrVersionSupported( contextID,\"GL_ARB_multitexture\", 1.3f) ||\n                                 isGLExtensionOrVersionSupported(contextID,\"GL_EXT_multitexture\", 1.3f);\n\n    isTextureFilterAnisotropicSupported = isGLExtensionSupported(contextID,\"GL_EXT_texture_filter_anisotropic\");\n    isTextureSwizzleSupported = isGLExtensionSupported(contextID,\"GL_ARB_texture_swizzle\");\n    isTextureCompressionARBSupported = builtInSupport || isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_compression\", 1.3f);\n    isTextureCompressionS3TCSupported = isGLExtensionSupported(contextID,\"GL_EXT_texture_compression_s3tc\") || isGLExtensionSupported(contextID, \"GL_S3_s3tc\");\n    isTextureCompressionPVRTC2BPPSupported = isGLExtensionSupported(contextID,\"GL_IMG_texture_compression_pvrtc\");\n    isTextureCompressionPVRTC4BPPSupported = isTextureCompressionPVRTC2BPPSupported;//covered by same extension\n    isTextureCompressionETCSupported = isGLExtensionSupported(contextID,\"GL_OES_compressed_ETC1_RGB8_texture\");\n    isTextureCompressionETC2Supported = isGLExtensionSupported(contextID,\"GL_ARB_ES3_compatibility\");\n    isTextureCompressionRGTCSupported = isGLExtensionSupported(contextID,\"GL_EXT_texture_compression_rgtc\");\n    isTextureCompressionPVRTCSupported = isGLExtensionSupported(contextID,\"GL_IMG_texture_compression_pvrtc\");\n\n    isTextureMirroredRepeatSupported = builtInSupport ||\n                                       isGLExtensionOrVersionSupported(contextID,\"GL_IBM_texture_mirrored_repeat\", 1.4f) ||\n                                       isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_mirrored_repeat\", 1.4f);\n\n    isTextureEdgeClampSupported = builtInSupport ||\n                                   isGLExtensionOrVersionSupported(contextID,\"GL_EXT_texture_edge_clamp\", 1.2f) ||\n                                   isGLExtensionOrVersionSupported(contextID,\"GL_SGIS_texture_edge_clamp\", 1.2f);\n\n\n    isTextureBorderClampSupported = OSG_GL3_FEATURES || ((OSG_GL1_FEATURES || OSG_GL2_FEATURES) && isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_border_clamp\", 1.3f));\n    isGenerateMipMapSupported = builtInSupport || isGLExtensionOrVersionSupported(contextID,\"GL_SGIS_generate_mipmap\", 1.4f);\n    preferGenerateMipmapSGISForPowerOfTwo = (radeonHardwareDetected||fireGLHardwareDetected) ? false : true;\n    isTextureMultisampledSupported = isGLExtensionSupported(contextID,\"GL_ARB_texture_multisample\");\n    isShadowSupported = OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_ARB_shadow\");\n    isShadowAmbientSupported = isGLExtensionSupported(contextID,\"GL_ARB_shadow_ambient\");\n    isClientStorageSupported = isGLExtensionSupported(contextID,\"GL_APPLE_client_storage\");\n    isNonPowerOfTwoTextureNonMipMappedSupported = builtInSupport || isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_non_power_of_two\", 2.0) || isGLExtensionSupported(contextID,\"GL_APPLE_texture_2D_limited_npot\");\n    isNonPowerOfTwoTextureMipMappedSupported = builtInSupport || isNonPowerOfTwoTextureNonMipMappedSupported;\n    isTextureIntegerEXTSupported = OSG_GL3_FEATURES || isGLExtensionSupported(contextID, \"GL_EXT_texture_integer\");\n\n    if (rendererString.find(\"GeForce FX\")!=std::string::npos)\n    {\n        isNonPowerOfTwoTextureMipMappedSupported = false;\n        OSG_INFO<<\"Disabling _isNonPowerOfTwoTextureMipMappedSupported for GeForce FX hardware.\"<<std::endl;\n    }\n\n    maxTextureSize=0;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE,&maxTextureSize);\n\n    char *ptr;\n    if( (ptr = getenv(\"OSG_MAX_TEXTURE_SIZE\")) != 0)\n    {\n        GLint osg_max_size = atoi(ptr);\n\n        if (osg_max_size<maxTextureSize)\n        {\n\n            maxTextureSize = osg_max_size;\n        }\n    }\n\n    setGLExtensionFuncPtr(glTexStorage2D,\"glTexStorage2D\",\"glTexStorage2DARB\");\n    setGLExtensionFuncPtr(glCompressedTexImage2D,\"glCompressedTexImage2D\",\"glCompressedTexImage2DARB\");\n    setGLExtensionFuncPtr(glCompressedTexSubImage2D,\"glCompressedTexSubImage2D\",\"glCompressedTexSubImage2DARB\");\n    setGLExtensionFuncPtr(glGetCompressedTexImage,\"glGetCompressedTexImage\",\"glGetCompressedTexImageARB\");;\n    setGLExtensionFuncPtr(glTexImage2DMultisample, \"glTexImage2DMultisample\", \"glTexImage2DMultisampleARB\");\n\n    setGLExtensionFuncPtr(glTexParameterIiv, \"glTexParameterIiv\", \"glTexParameterIivARB\");\n    setGLExtensionFuncPtr(glTexParameterIuiv, \"glTexParameterIuiv\", \"glTexParameterIuivARB\");\n\n\n    if (glTexParameterIiv == NULL) setGLExtensionFuncPtr(glTexParameterIiv, \"glTexParameterIivEXT\");\n    if (glTexParameterIuiv == NULL) setGLExtensionFuncPtr(glTexParameterIuiv, \"glTexParameterIuivEXT\");\n\n    setGLExtensionFuncPtr(glBindImageTexture, \"glBindImageTexture\", \"glBindImageTextureARB\");\n\n    isTextureMaxLevelSupported = (glVersion >= 1.2f);\n\n    isTextureStorageEnabled = isTexStorage2DSupported();\n    if ( (ptr = getenv(\"OSG_GL_TEXTURE_STORAGE\"))  != 0 && isTexStorage2DSupported())\n    {\n        if (strcmp(ptr,\"OFF\")==0 || strcmp(ptr,\"DISABLE\")==0 ) isTextureStorageEnabled = false;\n        else isTextureStorageEnabled = true;\n    }\n\n\n    // Texture3D extensions\n    isTexture3DFast = OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_EXT_texture3D\");\n\n    if (isTexture3DFast) isTexture3DSupported = true;\n    else isTexture3DSupported = (glVersion >= 1.2f);\n\n    maxTexture3DSize = 0;\n    glGetIntegerv(GL_MAX_3D_TEXTURE_SIZE, &maxTexture3DSize);\n\n    setGLExtensionFuncPtr(glTexImage3D, \"glTexImage3D\",\"glTexImage3DEXT\");\n    setGLExtensionFuncPtr(glTexSubImage3D, \"glTexSubImage3D\",\"glTexSubImage3DEXT\");\n    setGLExtensionFuncPtr(glCompressedTexImage3D, \"glCompressedTexImage3D\",\"glCompressedTexImage3DARB\");\n    setGLExtensionFuncPtr(glCompressedTexSubImage3D, \"glCompressedTexSubImage3D\",\"glCompressedTexSubImage3DARB\");\n    setGLExtensionFuncPtr(glCopyTexSubImage3D, \"glCopyTexSubImage3D\",\"glCopyTexSubImage3DEXT\");\n\n\n    // Texture2DArray extensions\n    isTexture2DArraySupported = OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_EXT_texture_array\");\n\n    max2DSize = 0;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max2DSize);\n    maxLayerCount = 0;\n    glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS_EXT, &maxLayerCount);\n\n    // Blending\n    isBlendColorSupported = OSG_GLES2_FEATURES || OSG_GL3_FEATURES ||\n                            isGLExtensionSupported(contextID,\"GL_EXT_blend_color\") ||\n                            (glVersion >= 1.2f);\n\n    setGLExtensionFuncPtr(glBlendColor, \"glBlendColor\", \"glBlendColorEXT\");\n\n    bool bultInSupport = OSG_GLES2_FEATURES || OSG_GL3_FEATURES;\n    isBlendEquationSupported = bultInSupport ||\n        isGLExtensionSupported(contextID, \"GL_EXT_blend_equation\") ||\n        (glVersion >= 1.2f);\n\n\n    isBlendEquationSeparateSupported = bultInSupport ||\n        isGLExtensionSupported(contextID, \"GL_EXT_blend_equation_separate\") ||\n        (glVersion >= 2.0f);\n\n\n    isSGIXMinMaxSupported = isGLExtensionSupported(contextID, \"GL_SGIX_blend_alpha_minmax\");\n    isLogicOpSupported = isGLExtensionSupported(contextID, \"GL_EXT_blend_logic_op\");\n\n    setGLExtensionFuncPtr(glBlendEquation, \"glBlendEquation\", \"glBlendEquationEXT\");\n    setGLExtensionFuncPtr(glBlendEquationSeparate, \"glBlendEquationSeparate\", \"glBlendEquationSeparateEXT\");\n\n    setGLExtensionFuncPtr(glBlendEquationi, \"glBlendEquationi\", \"glBlendEquationiARB\");\n    setGLExtensionFuncPtr(glBlendEquationSeparatei, \"glBlendEquationSeparatei\", \"glBlendEquationSeparateiARB\");\n\n\n    // glEnablei/glDisabli\n    setGLExtensionFuncPtr(glEnablei, \"glEnablei\");\n    setGLExtensionFuncPtr(glDisablei, \"glDisablei\");\n\n\n    // Stencil`\n    isStencilWrapSupported = isGLExtensionOrVersionSupported(contextID, \"GL_EXT_stencil_wrap\", 1.4f);\n    isStencilTwoSidedSupported = isGLExtensionSupported(contextID, \"GL_EXT_stencil_two_side\");\n    isOpenGL20Supported = (glVersion >= 2.0f);\n    isSeparateStencilSupported = isGLExtensionSupported(contextID, \"GL_ATI_separate_stencil\");\n\n    // function pointers\n    setGLExtensionFuncPtr(glActiveStencilFace, \"glActiveStencilFaceEXT\");\n    setGLExtensionFuncPtr(glStencilOpSeparate, \"glStencilOpSeparate\", \"glStencilOpSeparateATI\");\n    setGLExtensionFuncPtr(glStencilMaskSeparate, \"glStencilMaskSeparate\");\n    setGLExtensionFuncPtr(glStencilFuncSeparate, \"glStencilFuncSeparate\", \"glStencilFuncSeparateATI\");\n    setGLExtensionFuncPtr(glStencilFuncSeparateATI, \"glStencilFuncSeparateATI\");\n\n\n    // Color Mask\n    setGLExtensionFuncPtr(glColorMaski, \"glColorMaski\", \"glColorMaskiARB\");\n\n\n    // ClampColor\n    isClampColorSupported = OSG_GL3_FEATURES ||\n                             isGLExtensionSupported(contextID,\"GL_ARB_color_buffer_float\") ||\n                             (glVersion >= 2.0f);\n\n    setGLExtensionFuncPtr(glClampColor, \"glClampColor\", \"glClampColorARB\");\n\n\n    // PrimitiveRestartIndex\n    setGLExtensionFuncPtr(glPrimitiveRestartIndex, \"glPrimitiveRestartIndex\", \"glPrimitiveRestartIndexNV\");\n\n\n    // Point\n    isPointParametersSupported = OSG_GL3_FEATURES || (glVersion >= 1.4f)  ||\n                                  isGLExtensionSupported(contextID,\"GL_ARB_point_parameters\") ||\n                                  isGLExtensionSupported(contextID,\"GL_EXT_point_parameters\") ||\n                                  isGLExtensionSupported(contextID,\"GL_SGIS_point_parameters\");\n\n\n    isPointSpriteSupported = OSG_GL3_FEATURES || isGLExtensionSupported(contextID, \"GL_ARB_point_sprite\") || isGLExtensionSupported(contextID, \"GL_OES_point_sprite\") || isGLExtensionSupported(contextID, \"GL_NV_point_sprite\");\n    isPointSpriteCoordOriginSupported = OSG_GL3_FEATURES || (glVersion >= 2.0f);\n\n\n    setGLExtensionFuncPtr(glPointParameteri, \"glPointParameteri\", \"glPointParameteriARB\");\n    if (!glPointParameteri) setGLExtensionFuncPtr(glPointParameteri, \"glPointParameteriEXT\", \"glPointParameteriSGIS\");\n\n    setGLExtensionFuncPtr(glPointParameterf, \"glPointParameterf\", \"glPointParameterfARB\");\n    if (!glPointParameterf) setGLExtensionFuncPtr(glPointParameterf, \"glPointParameterfEXT\", \"glPointParameterfSGIS\");\n\n    setGLExtensionFuncPtr(glPointParameterfv, \"glPointParameterfv\", \"glPointParameterfvARB\");\n    if (!glPointParameterfv) setGLExtensionFuncPtr(glPointParameterfv, \"glPointParameterfvEXT\", \"glPointParameterfvSGIS\");\n\n\n    // Multisample\n    isMultisampleSupported = OSG_GLES2_FEATURES || OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_ARB_multisample\");\n    isMultisampleFilterHintSupported = isGLExtensionSupported(contextID, \"GL_NV_multisample_filter_hint\");\n\n    setGLExtensionFuncPtr(glSampleCoverage, \"glSampleCoverageARB\");\n\n\n    // FrameBufferObject\n    setGLExtensionFuncPtr(glBindRenderbuffer, \"glBindRenderbuffer\", \"glBindRenderbufferEXT\", \"glBindRenderbufferOES\");\n    setGLExtensionFuncPtr(glDeleteRenderbuffers, \"glDeleteRenderbuffers\", \"glDeleteRenderbuffersEXT\", \"glDeleteRenderbuffersOES\");\n    setGLExtensionFuncPtr(glGenRenderbuffers, \"glGenRenderbuffers\", \"glGenRenderbuffersEXT\", \"glGenRenderbuffersOES\");\n    setGLExtensionFuncPtr(glRenderbufferStorage, \"glRenderbufferStorage\", \"glRenderbufferStorageEXT\", \"glRenderbufferStorageOES\");\n    setGLExtensionFuncPtr(glRenderbufferStorageMultisample, \"glRenderbufferStorageMultisample\", \"glRenderbufferStorageMultisampleEXT\", \"glRenderbufferStorageMultisampleOES\");\n    setGLExtensionFuncPtr(glRenderbufferStorageMultisampleCoverageNV, \"glRenderbufferStorageMultisampleCoverageNV\");\n    setGLExtensionFuncPtr(glBindFramebuffer, \"glBindFramebuffer\", \"glBindFramebufferEXT\", \"glBindFramebufferOES\");\n    setGLExtensionFuncPtr(glDeleteFramebuffers, \"glDeleteFramebuffers\", \"glDeleteFramebuffersEXT\", \"glDeleteFramebuffersOES\");\n    setGLExtensionFuncPtr(glGenFramebuffers, \"glGenFramebuffers\", \"glGenFramebuffersEXT\", \"glGenFramebuffersOES\");\n    setGLExtensionFuncPtr(glCheckFramebufferStatus, \"glCheckFramebufferStatus\", \"glCheckFramebufferStatusEXT\", \"glCheckFramebufferStatusOES\");\n\n    setGLExtensionFuncPtr(glFramebufferTexture1D, \"glFramebufferTexture1D\", \"glFramebufferTexture1DEXT\", \"glFramebufferTexture1DOES\");\n    setGLExtensionFuncPtr(glFramebufferTexture2D, \"glFramebufferTexture2D\", \"glFramebufferTexture2DEXT\", \"glFramebufferTexture2DOES\");\n    setGLExtensionFuncPtr(glFramebufferTexture3D, \"glFramebufferTexture3D\", \"glFramebufferTexture3DEXT\", \"glFramebufferTexture3DOES\");\n    setGLExtensionFuncPtr(glFramebufferTexture, \"glFramebufferTexture\", \"glFramebufferTextureEXT\", \"glFramebufferTextureOES\");\n    setGLExtensionFuncPtr(glFramebufferTextureLayer, \"glFramebufferTextureLayer\", \"glFramebufferTextureLayerEXT\", \"glFramebufferTextureLayerOES\");\n    setGLExtensionFuncPtr(glFramebufferTextureFace,  \"glFramebufferTextureFace\", \"glFramebufferTextureFaceEXT\", \"glFramebufferTextureFaceOES\" );\n    setGLExtensionFuncPtr(glFramebufferRenderbuffer, \"glFramebufferRenderbuffer\", \"glFramebufferRenderbufferEXT\", \"glFramebufferRenderbufferOES\");\n\n    setGLExtensionFuncPtr(glGenerateMipmap, \"glGenerateMipmap\", \"glGenerateMipmapEXT\", \"glGenerateMipmapOES\");\n    setGLExtensionFuncPtr(glBlitFramebuffer, \"glBlitFramebuffer\", \"glBlitFramebufferEXT\", \"glBlitFramebufferOES\");\n    setGLExtensionFuncPtr(glGetRenderbufferParameteriv, \"glGetRenderbufferParameteriv\", \"glGetRenderbufferParameterivEXT\", \"glGetRenderbufferParameterivOES\");\n\n    isFrameBufferObjectSupported =\n        glBindRenderbuffer != 0 &&\n        glDeleteRenderbuffers != 0 &&\n        glGenRenderbuffers != 0 &&\n        glRenderbufferStorage != 0 &&\n        glBindFramebuffer != 0 &&\n        glDeleteFramebuffers != 0 &&\n        glGenFramebuffers != 0 &&\n        glCheckFramebufferStatus != 0 &&\n        glFramebufferTexture2D != 0 &&\n        glFramebufferRenderbuffer != 0 &&\n        glGenerateMipmap != 0 &&\n        glGetRenderbufferParameteriv != 0 &&\n    ( OSG_GLES1_FEATURES || isGLExtensionOrVersionSupported(contextID, \"GL_EXT_framebuffer_object\",3.0f) );\n      \n\n    isPackedDepthStencilSupported = OSG_GL3_FEATURES ||\n        (isGLExtensionSupported(contextID, \"GL_EXT_packed_depth_stencil\")) ||\n        (isGLExtensionSupported(contextID, \"GL_OES_packed_depth_stencil\"));\n\n\n    // Sync\n    osg::setGLExtensionFuncPtr(glFenceSync, \"glFenceSync\");\n    osg::setGLExtensionFuncPtr(glIsSync, \"glIsSync\");\n    osg::setGLExtensionFuncPtr(glDeleteSync, \"glDeleteSync\");\n    osg::setGLExtensionFuncPtr(glClientWaitSync, \"glClientWaitSync\");\n    osg::setGLExtensionFuncPtr(glWaitSync, \"glWaitSync\");\n    osg::setGLExtensionFuncPtr(glGetSynciv, \"glGetSynciv\");\n\n\n    // Transform Feeedback\n    osg::setGLExtensionFuncPtr(glBeginTransformFeedback, \"glBeginTransformFeedback\", \"glBeginTransformFeedbackEXT\");\n    osg::setGLExtensionFuncPtr(glEndTransformFeedback, \"glEndTransformFeedback\", \"glEndTransformFeedbackEXT\");\n    osg::setGLExtensionFuncPtr(glTransformFeedbackVaryings, \"glTransformFeedbackVaryings\", \"glTransformFeedbackVaryingsEXT\");\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbackVarying, \"glGetTransformFeedbackVarying\", \"glGetTransformFeedbackVaryingEXT\");\n    osg::setGLExtensionFuncPtr(glBindTransformFeedback, \"glBindTransformFeedback\");\n    osg::setGLExtensionFuncPtr(glDeleteTransformFeedbacks, \"glDeleteTransformFeedbacks\");\n    osg::setGLExtensionFuncPtr(glGenTransformFeedbacks, \"glGenTransformFeedbacks\");\n    osg::setGLExtensionFuncPtr(glIsTransformFeedback, \"glIsTransformFeedback\");\n    osg::setGLExtensionFuncPtr(glPauseTransformFeedback, \"glPauseTransformFeedback\");\n    osg::setGLExtensionFuncPtr(glResumeTransformFeedback, \"glResumeTransformFeedback\");\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedback, \"glDrawTransformFeedback\");\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackStream, \"glDrawTransformFeedbackStream\");\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackInstanced, \"glDrawTransformFeedbackInstanced\");\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackStreamInstanced, \"glDrawTransformFeedbackStreamInstanced\");\n    osg::setGLExtensionFuncPtr(glCreateTransformFeedbacks, \"glCreateTransformFeedbacks\");\n    osg::setGLExtensionFuncPtr(glTransformFeedbackBufferBase, \"glTransformFeedbackBufferBase\");\n    osg::setGLExtensionFuncPtr(glTransformFeedbackBufferRange, \"glTransformFeedbackBufferRange\");\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbackiv, \"glGetTransformFeedbackiv\");\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbacki_v, \"glGetTransformFeedbacki_v\");\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbacki64_v, \"glGetTransformFeedbacki64_v\");\n\n    //Vertex Array Object\n    osg::setGLExtensionFuncPtr(glGenVertexArrays,\"glGenVertexArrays\");\n    osg::setGLExtensionFuncPtr(glBindVertexArray,\"glBindVertexArray\");\n    osg::setGLExtensionFuncPtr(glDeleteVertexArrays,\"glDeleteVertexArrays\");\n    osg::setGLExtensionFuncPtr(glIsVertexArray,\"glIsVertexArray\");\n    \n}\n\n\n\n///////////////////////////////////////////////////////////////////////////\n// C++-friendly convenience methods\n\nGLuint GLExtensions::getCurrentProgram() const\n{\n    if( glVersion >= 2.0f )\n    {\n        // GLSL as GL v2.0 core functionality\n        GLint result = 0;\n        glGetIntegerv( GL_CURRENT_PROGRAM, &result );\n        return static_cast<GLuint>(result);\n    }\n    else if (glGetHandleARB)\n    {\n        // fallback for GLSL as GL v1.5 ARB extension\n#ifndef GL_PROGRAM_OBJECT_ARB\n#define GL_PROGRAM_OBJECT_ARB 0x8B40\n#endif\n        return glGetHandleARB( GL_PROGRAM_OBJECT_ARB );\n    }\n    else\n    {\n        OSG_WARN<<\"Warning GLExtensions::getCurrentProgram not supported\"<<std::endl;;\n        return 0;\n    }\n}\n\n\nbool GLExtensions::getProgramInfoLog( GLuint program, std::string& result ) const\n{\n    GLsizei bufLen = 0;        // length of buffer to allocate\n    GLsizei strLen = 0;        // strlen GL actually wrote to buffer\n\n    glGetProgramiv( program, GL_INFO_LOG_LENGTH, &bufLen );\n    if( bufLen > 1 )\n    {\n        GLchar* infoLog = new GLchar[bufLen];\n        glGetProgramInfoLog( program, bufLen, &strLen, infoLog );\n        if( strLen > 0 ) result = reinterpret_cast<char*>(infoLog);\n        delete [] infoLog;\n    }\n    return (strLen > 0);\n}\n\n\nbool GLExtensions::getShaderInfoLog( GLuint shader, std::string& result ) const\n{\n    GLsizei bufLen = 0;        // length of buffer to allocate\n    GLsizei strLen = 0;        // strlen GL actually wrote to buffer\n\n    glGetShaderiv( shader, GL_INFO_LOG_LENGTH, &bufLen );\n    if( bufLen > 1 )\n    {\n        GLchar* infoLog = new GLchar[bufLen];\n        glGetShaderInfoLog( shader, bufLen, &strLen, infoLog );\n        if( strLen > 0 ) result = reinterpret_cast<char*>(infoLog);\n        delete [] infoLog;\n    }\n    return (strLen > 0);\n}\n\n\nbool GLExtensions::getAttribLocation( const char* attribName, GLuint& location ) const\n{\n    // is there an active GLSL program?\n    GLuint program = getCurrentProgram();\n    if( glIsProgram(program) == GL_FALSE ) return false;\n\n    // has that program been successfully linked?\n    GLint linked = GL_FALSE;\n    glGetProgramiv( program, GL_LINK_STATUS, &linked );\n    if( linked == GL_FALSE ) return false;\n\n    // is there such a named attribute?\n    GLint loc = glGetAttribLocation( program, reinterpret_cast<const GLchar*>(attribName) );\n    if( loc < 0 ) return false;\n\n    location = loc;\n    return true;\n}\n\n\nbool GLExtensions::getFragDataLocation( const char* fragDataName, GLuint& location ) const\n{\n    // is there an active GLSL program?\n    GLuint program = getCurrentProgram();\n    if( glIsProgram(program) == GL_FALSE ) return false;\n\n    // has that program been successfully linked?\n    GLint linked = GL_FALSE;\n    glGetProgramiv( program, GL_LINK_STATUS, &linked );\n    if( linked == GL_FALSE ) return false;\n\n    // check if supported\n    if (glGetFragDataLocation == NULL) return false;\n\n    // is there such a named attribute?\n    GLint loc = glGetFragDataLocation( program, reinterpret_cast<const GLchar*>(fragDataName) );\n    if( loc < 0 ) return false;\n\n    location = loc;\n    return true;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgDB/DynamicLibrary.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n\n//The dlopen calls were not adding to OS X until 10.3\n#ifdef __APPLE__\n#include <AvailabilityMacros.h>\n#if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n#define APPLE_PRE_10_3\n#endif\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#include <io.h>\n#include <windows.h>\n#include <winbase.h>\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n#include <mach-o/dyld.h>\n#else // all other unix\n#include <unistd.h>\n#ifdef __hpux\n// Although HP-UX has dlopen() it is broken! We therefore need to stick\n// to shl_load()/shl_unload()/shl_findsym()\n#include <dl.h>\n#include <errno.h>\n#else\n#include <dlfcn.h>\n#endif\n#endif\n\n#include <osg/Notify>\n#include <osg/GLExtensions>\n\n#include <osgDB/DynamicLibrary>\n#include <osgDB/FileUtils>\n#include <osgDB/FileNameUtils>\n#include <osgDB/ConvertUTF>\n\nusing namespace osgDB;\n\nDynamicLibrary::DynamicLibrary(const std::string& name, HANDLE handle)\n{\n    _name = name;\n    _handle = handle;\n    OSG_INFO<<\"Opened DynamicLibrary \"<<_name<<std::endl;\n}\n\nDynamicLibrary::~DynamicLibrary()\n{\n    if (_handle)\n    {\n        OSG_INFO<<\"Closing DynamicLibrary \"<<_name<<std::endl;\n#if defined(WIN32) && !defined(__CYGWIN__)\n        FreeLibrary((HMODULE)_handle);\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n        NSUnLinkModule(static_cast<NSModule>(_handle), FALSE);\n#elif defined(__hpux)\n        // fortunately, shl_t is a pointer\n        shl_unload (static_cast<shl_t>(_handle));\n#else // other unix\n        dlclose(_handle);\n#endif\n    }\n}\n\nDynamicLibrary* DynamicLibrary::loadLibrary(const std::string& libraryName)\n{\n\n    HANDLE handle = NULL;\n\n    std::string fullLibraryName = osgDB::findLibraryFile(libraryName);\n    if (!fullLibraryName.empty()) handle = getLibraryHandle( fullLibraryName ); // try the lib we have found\n    else handle = getLibraryHandle( libraryName ); // havn't found a lib ourselves, see if the OS can find it simply from the library name.\n\n    if (handle) return new DynamicLibrary(libraryName,handle);\n\n    // else no lib found so report errors.\n    OSG_INFO << \"DynamicLibrary::failed loading \\\"\"<<libraryName<<\"\\\"\"<<std::endl;\n\n    return NULL;\n}\n\nDynamicLibrary::HANDLE DynamicLibrary::getLibraryHandle( const std::string& libraryName)\n{\n    HANDLE handle = NULL;\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#ifdef OSG_USE_UTF8_FILENAME\n    handle = LoadLibraryW(  convertUTF8toUTF16(libraryName).c_str() );\n#else\n    handle = LoadLibrary( libraryName.c_str() );\n#endif\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    NSObjectFileImage image;\n    // NSModule os_handle = NULL;\n    if (NSCreateObjectFileImageFromFile(libraryName.c_str(), &image) == NSObjectFileImageSuccess) {\n        // os_handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        NSDestroyObjectFileImage(image);\n    }\n#elif defined(__hpux)\n    // BIND_FIRST is necessary for some reason\n    handle = shl_load ( libraryName.c_str(), BIND_DEFERRED|BIND_FIRST|BIND_VERBOSE, 0);\n    return handle;\n#else // other unix\n\n    // dlopen will not work with files in the current directory unless\n    // they are prefaced with './'  (DB - Nov 5, 2003).\n    std::string localLibraryName;\n    if( libraryName == osgDB::getSimpleFileName( libraryName ) )\n        localLibraryName = \"./\" + libraryName;\n    else\n        localLibraryName = libraryName;\n\n    handle = dlopen( localLibraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if( handle == NULL )\n    {\n        if (fileExists(localLibraryName))\n        {\n            OSG_WARN << \"Warning: dynamic library '\" << libraryName << \"' exists, but an error occurred while trying to open it:\" << std::endl;\n            OSG_WARN << dlerror() << std::endl;\n        }\n        else\n        {\n            OSG_INFO << \"Warning: dynamic library '\" << libraryName << \"' does not exist (or isn't readable):\" << std::endl;\n            OSG_INFO << dlerror() << std::endl;\n        }\n    }\n#endif\n    return handle;\n}\n\nDynamicLibrary::PROC_ADDRESS DynamicLibrary::getProcAddress(const std::string& procName)\n{\n    if (_handle==NULL) return NULL;\n#if defined(WIN32) && !defined(__CYGWIN__)\n    return osg::convertPointerType<DynamicLibrary::PROC_ADDRESS, FARPROC>( GetProcAddress( (HMODULE)_handle, procName.c_str() ) );\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    std::string temp(\"_\");\n    NSSymbol symbol;\n    temp += procName;   // Mac OS X prepends an underscore on function names\n    symbol = NSLookupSymbolInModule(static_cast<NSModule>(_handle), temp.c_str());\n    return NSAddressOfSymbol(symbol);\n#elif defined(__hpux)\n    void* result = NULL;\n    if (shl_findsym (reinterpret_cast<shl_t*>(&_handle), procName.c_str(), TYPE_PROCEDURE, result) == 0)\n    {\n        return result;\n    }\n    else\n    {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << strerror(errno) << std::endl;\n        return NULL;\n    }\n#else // other unix\n    void* sym = dlsym( _handle,  procName.c_str() );\n    if (!sym) {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << dlerror() << std::endl;\n    }\n    return sym;\n#endif\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/AUTHORS.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/applications/osgversion/Contributors.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/bsp/Q3BSPReader.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/bsp/Q3BSPReader.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/LightPointRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/RoadRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/DataInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/DataInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/AttrData.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/ReservedRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Vertex.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/ControlRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Registry.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/VertexRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Record.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/AncillaryRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Record.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/AttrData.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Pools.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Vertex.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Opcodes.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Pools.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/Registry.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/txp/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lua/lua-5.2.3/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lua/lua-5.2.3/doc/osi-certified-72x60.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lwo/old_lw.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lwo/old_lw.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgPlugins/lwo/README_osg.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/src/connectivity_graph.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/src/policy.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/tri_stripper.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/public_types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/heap_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/cache_simulator.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/connectivity_graph.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/policy.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osgUtil/tristripper/include/detail/graph_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/src/osg/dxtctool.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgviewerMFC/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDI.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDIDoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgsimplegl3/osgsimplegl3.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgcatch/osgcatch.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES2/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES2/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgviewerCocoa/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgviewerCocoa/English.lproj/MainMenu.nib/keyedobjects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES1/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES1/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/examples/osgparticle/osgparticle.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/osg.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg32.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg16-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg16.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg32-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg16-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg48-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg48-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg48.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg16-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg48-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg32-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/PlatformSpecifics/Windows/icons/src/osg32-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.4.0-hdtwm6qh2k7ybkt4s2g4q4fnp6zn3ax6/spack-src/CMakeModules/FindOpenVRML.cmake"
    ],
    "total_files": 2859
}