{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lua/lua-5.2.3/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.111.1.1 2013/04/12 18:48:47 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n\n/*\n** if needed, includes windows header before everything else\n*/\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_PATH and LUA_CPATH are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH)\n#define LUA_PATH\t\"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH)\n#define LUA_CPATH\t\"LUA_CPATH\"\n#endif\n\n#define LUA_PATHSUFFIX\t\t\"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_PATHVERSION\t\tLUA_PATH LUA_PATHSUFFIX\n#define LUA_CPATHVERSION\tLUA_CPATH LUA_PATHSUFFIX\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_PATH_SEP)\n#define LUA_PATH_SEP\t\t\";\"\n#endif\n#if !defined (LUA_PATH_MARK)\n#define LUA_PATH_MARK\t\t\"?\"\n#endif\n#if !defined (LUA_EXEC_DIR)\n#define LUA_EXEC_DIR\t\t\"!\"\n#endif\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/* table (in the registry) that keeps handles for all loaded C libraries */\n#define CLIBS\t\t\"_CLIBS\"\n\n#define LIB_FAIL\t\"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n#define setprogdir(L)\t\t((void)0)\n\n\n/*\n** system-dependent functions\n*/\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path, int seeglb);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_USE_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#undef setprogdir\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\nstatic void *ll_checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\nstatic void ll_addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  int n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    ll_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = ll_load(L, path, *sym == '*');\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    ll_addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = ll_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module \" LUA_QS\n                         \" from file \" LUA_QS \":\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *funcname;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    funcname = lua_pushlstring(L, modname, mark - modname);\n    funcname = lua_pushfstring(L, LUA_POF\"%s\", funcname);\n    stat = ll_loadfunc(L, filename, funcname);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  funcname = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return ll_loadfunc(L, filename, funcname);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                         name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  lua_getfield(L, lua_upvalueindex(1), \"searchers\");  /* will be at index 3 */\n  if (!lua_istable(L, 3))\n    luaL_error(L, LUA_QL(\"package.searchers\") \" must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, 3, i);  /* get a searcher */\n    if (lua_isnil(L, -1)) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);  /* _LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_isnil(L, -1)) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname1,\n                                   const char *envname2, const char *def) {\n  const char *path = getenv(envname1);\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname2);  /* try alternative name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with pre-defined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  /* create table CLIBS to keep track of loaded C libraries */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_createtable(L, 0, 1);  /* metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  /* create `package' table */\n  luaL_newlib(L, pk_funcs);\n  createsearcherstable(L);\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field `loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n  /* set field 'path' */\n  setpath(L, \"path\", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);\n  /* set field 'cpath' */\n  setpath(L, \"cpath\", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osg/GLExtensions.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n#include <osg/GLExtensions>\n#include <osg/GL>\n#include <osg/Notify>\n#include <osg/Math>\n#include <osg/buffered_value>\n#include <osg/os_utils>\n#include <osg/ApplicationUsage>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <float.h>\n\n#include <string>\n#include <set>\n#include <sstream>\n\n#if defined(WIN32)\n    #ifndef WIN32_LEAN_AND_MEAN\n        #define WIN32_LEAN_AND_MEAN\n    #endif // WIN32_LEAN_AND_MEAN\n    #ifndef NOMINMAX\n        #define NOMINMAX\n    #endif // NOMINMAX\n    #include <windows.h>\n#elif defined(__APPLE__)\n    // The NS*Symbol* stuff found in <mach-o/dyld.h> is deprecated.\n    // Since 10.3 (Panther) OS X has provided the dlopen/dlsym/dlclose\n    // family of functions under <dlfcn.h>. Since 10.4 (Tiger), Apple claimed\n    // the dlfcn family was significantly faster than the NS*Symbol* family.\n    // Since 'deprecated' needs to be taken very seriously with the\n    // coming of 10.5 (Leopard), it makes sense to use the dlfcn family when possible.\n    #include <AvailabilityMacros.h>\n    #if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n        #define USE_APPLE_LEGACY_NSSYMBOL\n        #include <mach-o/dyld.h>\n    #else\n        #include <dlfcn.h>\n    #endif\n#elif defined(__EMSCRIPTEN__)\n    // Emscripten ships EGL, which we use to get OpenGL function addresses.\n    #include <EGL/egl.h>\n#else\n    #include <dlfcn.h>\n#endif\n\nusing namespace osg;\n\ntypedef std::set<std::string>  ExtensionSet;\nstatic osg::buffered_object<ExtensionSet> s_glExtensionSetList;\nstatic osg::buffered_object<std::string> s_glRendererList;\nstatic osg::buffered_value<int> s_glInitializedList;\n\nstatic ApplicationUsageProxy GLEXtension_e0(ApplicationUsage::ENVIRONMENTAL_VARIABLE, \"OSG_GL_EXTENSION_DISABLE <value>\", \"Use space deliminarted list of GL extensions to disable associated GL extensions\");\nstatic ApplicationUsageProxy GLEXtension_e1(ApplicationUsage::ENVIRONMENTAL_VARIABLE, \"OSG_MAX_TEXTURE_SIZE <value>\", \"Clamp the maximum GL texture size to specified value.\");\n\nfloat osg::getGLVersionNumber()\n{\n    // needs to be extended to do proper things with subversions like 1.5.1, etc.\n    char *versionstring   = (char*) glGetString( GL_VERSION );\n    if (!versionstring) return 0.0;\n\n    return (findAsciiToFloat(versionstring));\n}\n\nbool osg::isExtensionInExtensionString(const char *extension, const char *extensionString)\n{\n    const char *startOfWord = extensionString;\n    const char *endOfWord;\n    while ((endOfWord = strchr(startOfWord,' ')) != 0)\n    {\n        if (strncmp(extension, startOfWord, endOfWord - startOfWord) == 0)\n            return true;\n        startOfWord = endOfWord+1;\n    }\n    if (*startOfWord && strcmp(extension, startOfWord) == 0)\n        return true;\n\n   return false;\n}\n\nbool osg::isGLExtensionSupported(unsigned int contextID, const char *extension)\n{\n    return osg::isGLExtensionOrVersionSupported(contextID, extension, FLT_MAX);\n}\n\nbool osg::isGLExtensionSupported(unsigned int contextID, const char *extension1, const char *extension2)\n{\n    return osg::isGLExtensionOrVersionSupported(contextID, extension1, FLT_MAX) ||\n           osg::isGLExtensionOrVersionSupported(contextID, extension2, FLT_MAX);\n}\n\nbool osg::isGLExtensionOrVersionSupported(unsigned int contextID, const char *extension, float requiredGLVersion)\n{\n    ExtensionSet& extensionSet = s_glExtensionSetList[contextID];\n    std::string& rendererString = s_glRendererList[contextID];\n\n    // first check to see if GL version number of recent enough.\n    bool result = requiredGLVersion <= osg::getGLVersionNumber();\n\n    if (!result)\n    {\n        // if not already set up, initialize all the per graphic context values.\n        if (!s_glInitializedList[contextID])\n        {\n            s_glInitializedList[contextID] = 1;\n\n            // set up the renderer\n            const GLubyte* renderer = glGetString(GL_RENDERER);\n            rendererString = renderer ? (const char*)renderer : \"\";\n\n            // get the extension list from OpenGL.\n            GLint numExt = 0;\n            #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)\n            if( osg::getGLVersionNumber() >= 3.0 )\n            {\n                // OpenGL 3.0 adds the concept of indexed strings and\n                // deprecates calls to glGetString( GL_EXTENSIONS ), which\n                // will now generate GL_INVALID_ENUM.\n\n                // Get extensions using new indexed string interface.\n\n                typedef const GLubyte * GL_APIENTRY MYGLGETSTRINGIPROC( GLenum, GLuint );\n                MYGLGETSTRINGIPROC* glGetStringi = 0;\n                setGLExtensionFuncPtr( glGetStringi, \"glGetStringi\", true);\n\n                if( glGetStringi != NULL )\n                {\n                    #  ifndef GL_NUM_EXTENSIONS\n                    #    define GL_NUM_EXTENSIONS 0x821D\n                    #  endif\n                    glGetIntegerv( GL_NUM_EXTENSIONS, &numExt );\n                    int idx;\n                    for( idx=0; idx<numExt; idx++ )\n                    {\n                        extensionSet.insert( std::string( (char*)( glGetStringi( GL_EXTENSIONS, idx ) ) ) );\n                    }\n                }\n                else\n                {\n                    OSG_WARN << \"isGLExtensionOrVersionSupported: Can't obtain glGetStringi function pointer.\" << std::endl;\n                }\n            }\n            #endif\n\n            // No extensions found so far, so try with glGetString\n            if (numExt == 0)\n            {\n                // Get extensions using GL1/2 interface.\n\n                const char* extensions = (const char*)glGetString(GL_EXTENSIONS);\n                if (extensions==NULL) return false;\n\n                // insert the ' ' delimiated extensions words into the extensionSet.\n                const char *startOfWord = extensions;\n                const char *endOfWord;\n                while ((endOfWord = strchr(startOfWord,' '))!=NULL)\n                {\n                    extensionSet.insert(std::string(startOfWord,endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord!=0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #if defined(WIN32) && (defined(OSG_GL1_AVAILABLE) || defined(OSG_GL2_AVAILABLE) || defined(OSG_GL3_AVAILABLE))\n\n            // add WGL extensions to the list\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGARB(HDC);\n            WGLGETEXTENSIONSSTRINGARB* wglGetExtensionsStringARB = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringARB, \"wglGetExtensionsStringARB\");\n\n            typedef const char* WINAPI WGLGETEXTENSIONSSTRINGEXT();\n            WGLGETEXTENSIONSSTRINGEXT* wglGetExtensionsStringEXT = 0;\n            setGLExtensionFuncPtr(wglGetExtensionsStringEXT, \"wglGetExtensionsStringEXT\");\n\n            const char* wglextensions = 0;\n\n            if (wglGetExtensionsStringARB)\n            {\n                HDC dc = wglGetCurrentDC();\n                wglextensions = wglGetExtensionsStringARB(dc);\n            }\n            else if (wglGetExtensionsStringEXT)\n            {\n                wglextensions = wglGetExtensionsStringEXT();\n            }\n\n            if (wglextensions)\n            {\n                const char* startOfWord = wglextensions;\n                const char* endOfWord;\n                while ((endOfWord = strchr(startOfWord, ' ')))\n                {\n                    extensionSet.insert(std::string(startOfWord, endOfWord));\n                    startOfWord = endOfWord+1;\n                }\n                if (*startOfWord != 0) extensionSet.insert(std::string(startOfWord));\n            }\n\n    #endif\n\n            OSG_NOTIFY(INFO)<<\"OpenGL extensions supported by installed OpenGL drivers are:\"<<std::endl;\n            for(ExtensionSet::iterator itr=extensionSet.begin();\n                itr!=extensionSet.end();\n                ++itr)\n            {\n                OSG_NOTIFY(INFO)<<\"    \"<<*itr<<std::endl;\n            }\n\n        }\n\n        // true if extension found in extensionSet.\n        result = extensionSet.find(extension)!=extensionSet.end();\n    }\n\n    // now see if extension is in the extension disabled list\n    bool extensionDisabled = false;\n    if (result)\n    {\n\n        const std::string& disableString = getGLExtensionDisableString();\n        if (!disableString.empty())\n        {\n\n            std::string::size_type pos=0;\n            while ( pos!=std::string::npos && (pos=disableString.find(extension,pos))!=std::string::npos )\n            {\n                std::string::size_type previousColon = disableString.find_last_of(':',pos);\n                std::string::size_type previousSemiColon = disableString.find_last_of(';',pos);\n\n                std::string renderer = \"\";\n                if (previousColon!=std::string::npos)\n                {\n                    if (previousSemiColon==std::string::npos) renderer = disableString.substr(0,previousColon);\n                    else if (previousSemiColon<previousColon) renderer = disableString.substr(previousSemiColon+1,previousColon-previousSemiColon-1);\n                }\n\n                if (!renderer.empty())\n                {\n\n                    // remove leading spaces if they exist.\n                    std::string::size_type leadingSpaces = renderer.find_first_not_of(' ');\n                    if (leadingSpaces==std::string::npos) renderer = \"\"; // nothing but spaces\n                    else if (leadingSpaces!=0) renderer.erase(0,leadingSpaces);\n\n                    // remove trailing spaces if they exist.\n                    std::string::size_type trailingSpaces = renderer.find_last_not_of(' ');\n                    if (trailingSpaces!=std::string::npos) renderer.erase(trailingSpaces+1,std::string::npos);\n\n                }\n\n                if (renderer.empty())\n                {\n                    extensionDisabled = true;\n                    break;\n                }\n\n                if (rendererString.find(renderer)!=std::string::npos)\n                {\n                    extensionDisabled = true;\n                    break;\n\n                }\n\n                // move the position in the disable string along so that the same extension is found multiple times\n                ++pos;\n            }\n\n        }\n    }\n\n    if (result)\n    {\n        if (!extensionDisabled)\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported.\"<<std::endl;\n        }\n        else\n        {\n            OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is supported by OpenGL\\ndriver but has been disabled by osg::getGLExtensionDisableString().\"<<std::endl;\n        }\n    }\n    else\n    {\n        OSG_NOTIFY(INFO)<<\"OpenGL extension '\"<<extension<<\"' is not supported.\"<<std::endl;\n    }\n\n\n    return result && !extensionDisabled;\n}\n\nvoid osg::setGLExtensionDisableString(const std::string& disableString)\n{\n    getGLExtensionDisableString() = disableString;\n}\n\nstd::string& osg::getGLExtensionDisableString()\n{\n    static std::string s_GLExtensionDisableString(getEnvVar(\"OSG_GL_EXTENSION_DISABLE\"));\n\n    return s_GLExtensionDisableString;\n}\n\nOSG_INIT_SINGLETON_PROXY(GLExtensionDisableStringInitializationProxy, osg::getGLExtensionDisableString())\n\n#ifdef OSG_GL_LIBRARY_STATIC\n\n    #include \"GLStaticLibrary.h\"\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        return GLStaticLibrary::getProcAddress(funcName);\n    }\n\n#else\n\n    void* osg::getGLExtensionFuncPtr(const char *funcName)\n    {\n        // OSG_NOTICE<<\"osg::getGLExtensionFuncPtr(\"<<funcName<<\")\"<<std::endl;\n    #if defined(__ANDROID__)\n        #if defined(OSG_GLES1_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv1_CM.so\", RTLD_NOW);\n        #elif defined(OSG_GLES2_AVAILABLE)\n            static void *handle = dlopen(\"libGLESv2.so\", RTLD_NOW);\n        #elif defined(OSG_GL1_AVAILABLE)\n            static void *handle = dlopen(\"libGL.so\", RTLD_NOW);\n        #endif\n        return dlsym(handle, funcName);\n\n    #elif defined(WIN32)\n\n        #if defined(OSG_GLES2_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandle(TEXT(\"libGLESv2.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #elif defined(OSG_GLES1_AVAILABLE)\n            static HMODULE hmodule = GetModuleHandleA(TEXT(\"libgles_cm.dll\"));\n            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));\n        #else\n            return convertPointerType<void*, PROC>(wglGetProcAddress(funcName));\n        #endif\n\n    #elif defined(__APPLE__)\n\n        #if defined(USE_APPLE_LEGACY_NSSYMBOL)\n            std::string temp( \"_\" );\n            temp += funcName;    // Mac OS X prepends an underscore on function names\n            if ( NSIsSymbolNameDefined( temp.c_str() ) )\n            {\n                NSSymbol symbol = NSLookupAndBindSymbol( temp.c_str() );\n                return NSAddressOfSymbol( symbol );\n            } else\n                return NULL;\n        #else\n            // I am uncertain of the correct and ideal usage of dlsym here.\n            // On the surface, it would seem that the FreeBSD implementation\n            // would be the ideal one to copy, but ELF and Mach-o are different\n            // and Apple's man page says the following about using RTLD_DEFAULT:\n            // \"This can be a costly search and should be avoided.\"\n            // The documentation mentions nothing about passing in 0 so I must\n            // assume the behavior is undefined.\n            // So I could try copying the Sun method which I think all this\n            // actually originated from.\n\n            // return dlsym( RTLD_DEFAULT, funcName );\n            static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n            return dlsym(handle, funcName);\n        #endif\n\n    #elif defined (__sun)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__sgi)\n\n        static void *handle = dlopen((const char *)0L, RTLD_LAZY);\n        return dlsym(handle, funcName);\n\n    #elif defined (__FreeBSD__)\n\n        return dlsym( RTLD_DEFAULT, funcName );\n\n    #elif defined (__linux__)\n\n        return dlsym(0, funcName);\n\n    #elif defined (__QNX__)\n\n        return dlsym(RTLD_DEFAULT, funcName);\n\n    #elif defined(__EMSCRIPTEN__)\n        // Use EGL to get OpenGL function address for Emscripten.\n        return convertPointerType<void*, __eglMustCastToProperFunctionPointerType>(eglGetProcAddress(funcName));\n\n    #else // all other unixes\n\n        return dlsym(0, funcName);\n\n    #endif\n    }\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n// Static array of percontext osg::GLExtensions instances\n\ntypedef osg::buffered_object< osg::ref_ptr<GLExtensions> > BufferedExtensions;\nstatic BufferedExtensions s_extensions;\n\nGLExtensions* GLExtensions::Get(unsigned int in_contextID, bool createIfNotInitalized)\n{\n    if (!s_extensions[in_contextID] && createIfNotInitalized)\n            s_extensions[in_contextID] = new GLExtensions(in_contextID);\n\n    return s_extensions[in_contextID].get();\n}\n\nvoid GLExtensions::Set(unsigned int in_contextID, GLExtensions* extensions)\n{\n    s_extensions[in_contextID] = extensions;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Extension function pointers for OpenGL v2.x\n\n\nGLExtensions::GLExtensions(unsigned int in_contextID):\n    contextID(in_contextID)\n{\n    const char* versionString = (const char*) glGetString( GL_VERSION );\n    bool validContext = versionString!=0;\n    if (!validContext)\n    {\n        OSG_NOTIFY(osg::FATAL)<<\"Error: OpenGL version test failed, requires valid graphics context.\"<<std::endl;\n    }\n\n    glVersion = validContext ? findAsciiToFloat( versionString ) : 0.0f;\n    glslLanguageVersion = 0.0f;\n\n    bool shadersBuiltIn = OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES;\n\n    isShaderObjectsSupported = validContext && (shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_shader_objects\"));\n    isVertexShaderSupported = validContext && (shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_vertex_shader\"));\n    isFragmentShaderSupported = validContext && (shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_fragment_shader\"));\n    isLanguage100Supported = validContext && (shadersBuiltIn || osg::isGLExtensionSupported(contextID,\"GL_ARB_shading_language_100\"));\n    isGeometryShader4Supported = validContext && (osg::isGLExtensionSupported(contextID,\"GL_EXT_geometry_shader4\") || osg::isGLExtensionSupported(contextID,\"GL_ARB_geometry_shader4\"));\n    isGpuShader4Supported = validContext && osg::isGLExtensionOrVersionSupported(contextID,\"GL_EXT_gpu_shader4\", 3.0f);\n    areTessellationShadersSupported = validContext && (osg::isGLExtensionOrVersionSupported(contextID, \"GL_ARB_tessellation_shader\", 4.0f) || osg::isGLExtensionSupported(contextID,\"GL_OES_tessellation_shader\"));\n    isUniformBufferObjectSupported = validContext && osg::isGLExtensionOrVersionSupported(contextID,\"GL_ARB_uniform_buffer_object\", 3.1f);\n    isGetProgramBinarySupported = validContext && osg::isGLExtensionOrVersionSupported(contextID,\"GL_ARB_get_program_binary\", 4.1f);\n    isGpuShaderFp64Supported = validContext && osg::isGLExtensionOrVersionSupported(contextID,\"GL_ARB_gpu_shader_fp64\", 4.0f);\n    isShaderAtomicCountersSupported = validContext && osg::isGLExtensionOrVersionSupported(contextID,\"GL_ARB_shader_atomic_counters\", 4.2f);\n\n    isRectangleSupported = validContext &&\n                           (OSG_GL3_FEATURES ||\n                           isGLExtensionSupported(contextID,\"GL_ARB_texture_rectangle\") ||\n                           isGLExtensionSupported(contextID,\"GL_EXT_texture_rectangle\") ||\n                           isGLExtensionSupported(contextID,\"GL_NV_texture_rectangle\"));\n\n    isCubeMapSupported = validContext &&\n                          (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES ||\n                          isGLExtensionSupported(contextID,\"GL_ARB_texture_cube_map\") ||\n                          isGLExtensionSupported(contextID,\"GL_EXT_texture_cube_map\") ||\n                          (glVersion >= 1.3f));\n\n    isClipControlSupported = validContext &&\n                             (isGLExtensionSupported(contextID,\"GL_ARB_clip_control\") ||\n                             (glVersion >= 4.5f));\n\n\n    isGlslSupported = validContext &&\n                      (( glVersion >= 2.0f ) ||\n                       (isShaderObjectsSupported &&\n                        isVertexShaderSupported &&\n                        isFragmentShaderSupported &&\n                        isLanguage100Supported ));\n\n    if( isGlslSupported )\n    {\n        // If glGetString raises an error, assume initial release \"1.00\"\n        while(glGetError() != GL_NO_ERROR) {}        // reset error flag\n\n        const char* langVerStr = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);\n        if( (glGetError() == GL_NO_ERROR) && langVerStr )\n        {\n            glslLanguageVersion = (findAsciiToFloat(langVerStr));\n        }\n        else\n            glslLanguageVersion = 1.0f;\n    }\n\n    OSG_INFO\n            << \"glVersion=\" << glVersion << \", \"\n            << \"isGlslSupported=\" << (isGlslSupported ? \"YES\" : \"NO\") << \", \"\n            << \"glslLanguageVersion=\" << glslLanguageVersion\n            << std::endl;\n\n\n    setGLExtensionFuncPtr(glDrawBuffers, \"glDrawBuffers\", \"glDrawBuffersARB\", validContext);\n    setGLExtensionFuncPtr(glAttachShader, \"glAttachShader\", \"glAttachObjectARB\", validContext);\n    setGLExtensionFuncPtr(glBindAttribLocation, \"glBindAttribLocation\", \"glBindAttribLocationARB\", validContext);\n    setGLExtensionFuncPtr(glCompileShader, \"glCompileShader\", \"glCompileShaderARB\", validContext);\n    setGLExtensionFuncPtr(glCreateProgram, \"glCreateProgram\", \"glCreateProgramObjectARB\", validContext);\n    setGLExtensionFuncPtr(glCreateShader, \"glCreateShader\", \"glCreateShaderObjectARB\", validContext);\n    setGLExtensionFuncPtr(glDeleteProgram, \"glDeleteProgram\", validContext);\n    setGLExtensionFuncPtr(glDeleteShader, \"glDeleteShader\", validContext);\n    setGLExtensionFuncPtr(glDetachShader, \"glDetachShader\", \"glDetachObjectARB\", validContext);\n    setGLExtensionFuncPtr(glDisableVertexAttribArray, \"glDisableVertexAttribArray\", validContext);\n    setGLExtensionFuncPtr(glEnableVertexAttribArray, \"glEnableVertexAttribArray\", validContext);\n    setGLExtensionFuncPtr(glGetActiveAttrib, \"glGetActiveAttrib\", \"glGetActiveAttribARB\", validContext);\n    setGLExtensionFuncPtr(glGetActiveUniform, \"glGetActiveUniform\", \"glGetActiveUniformARB\", validContext);\n    setGLExtensionFuncPtr(glGetAttachedShaders, \"glGetAttachedShaders\", \"glGetAttachedObjectsARB\", validContext);\n    setGLExtensionFuncPtr(glGetAttribLocation, \"glGetAttribLocation\", \"glGetAttribLocationARB\", validContext);\n    setGLExtensionFuncPtr(glGetProgramiv, \"glGetProgramiv\", validContext);\n    setGLExtensionFuncPtr(glGetProgramInfoLog, \"glGetProgramInfoLog\", validContext);\n    setGLExtensionFuncPtr(glGetShaderiv, \"glGetShaderiv\", validContext);\n    setGLExtensionFuncPtr(glGetShaderInfoLog, \"glGetShaderInfoLog\", validContext);\n    setGLExtensionFuncPtr(glGetShaderSource, \"glGetShaderSource\", \"glGetShaderSourceARB\", validContext);\n    setGLExtensionFuncPtr(glGetUniformLocation, \"glGetUniformLocation\", \"glGetUniformLocationARB\", validContext);\n    setGLExtensionFuncPtr(glGetUniformfv, \"glGetUniformfv\", \"glGetUniformfvARB\", validContext);\n    setGLExtensionFuncPtr(glGetUniformiv, \"glGetUniformiv\", \"glGetUniformivARB\", validContext);\n    setGLExtensionFuncPtr(glGetVertexAttribdv, \"glGetVertexAttribdv\", validContext);\n    setGLExtensionFuncPtr(glGetVertexAttribfv, \"glGetVertexAttribfv\", validContext);\n    setGLExtensionFuncPtr(glGetVertexAttribiv, \"glGetVertexAttribiv\", validContext);\n    setGLExtensionFuncPtr(glGetVertexAttribPointerv, \"glGetVertexAttribPointerv\", validContext);\n    setGLExtensionFuncPtr(glIsProgram, \"glIsProgram\", validContext);\n    setGLExtensionFuncPtr(glIsShader, \"glIsShader\", validContext);\n    setGLExtensionFuncPtr(glLinkProgram, \"glLinkProgram\", \"glLinkProgramARB\", validContext);\n    setGLExtensionFuncPtr(glShaderSource, \"glShaderSource\", \"glShaderSourceARB\", validContext);\n    setGLExtensionFuncPtr(glUseProgram, \"glUseProgram\", \"glUseProgramObjectARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1f, \"glUniform1f\", \"glUniform1fARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2f, \"glUniform2f\", \"glUniform2fARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3f, \"glUniform3f\", \"glUniform3fARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4f, \"glUniform4f\", \"glUniform4fARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1i, \"glUniform1i\", \"glUniform1iARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2i, \"glUniform2i\", \"glUniform2iARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3i, \"glUniform3i\", \"glUniform3iARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4i, \"glUniform4i\", \"glUniform4iARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1fv, \"glUniform1fv\", \"glUniform1fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2fv, \"glUniform2fv\", \"glUniform2fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3fv, \"glUniform3fv\", \"glUniform3fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4fv, \"glUniform4fv\", \"glUniform4fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1iv, \"glUniform1iv\", \"glUniform1ivARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2iv, \"glUniform2iv\", \"glUniform2ivARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3iv, \"glUniform3iv\", \"glUniform3ivARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4iv, \"glUniform4iv\", \"glUniform4ivARB\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix2fv, \"glUniformMatrix2fv\", \"glUniformMatrix2fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3fv, \"glUniformMatrix3fv\", \"glUniformMatrix3fvARB\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4fv, \"glUniformMatrix4fv\", \"glUniformMatrix4fvARB\", validContext);\n    setGLExtensionFuncPtr(glValidateProgram, \"glValidateProgram\", \"glValidateProgramARB\", validContext);\n\n    setGLExtensionFuncPtr(glVertexAttrib1d, \"glVertexAttrib1d\", \"glVertexAttrib1dARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib1dv, \"glVertexAttrib1dv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib1f, \"glVertexAttrib1f\", \"glVertexAttrib1fARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib1fv, \"glVertexAttrib1fv\", \"glVertexAttrib1fvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib1s, \"glVertexAttrib1s\", \"glVertexAttrib1sARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib1sv, \"glVertexAttrib1sv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2d, \"glVertexAttrib2d\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2dv, \"glVertexAttrib2dv\", \"glVertexAttrib2dvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2f, \"glVertexAttrib2f\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2fv, \"glVertexAttrib2fv\", \"glVertexAttrib2fvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2s, \"glVertexAttrib2s\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib2sv, \"glVertexAttrib2sv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3d, \"glVertexAttrib3d\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3dv, \"glVertexAttrib3dv\", \"glVertexAttrib3dvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3f, \"glVertexAttrib3f\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3fv, \"glVertexAttrib3fv\", \"glVertexAttrib3fvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3s, \"glVertexAttrib3s\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib3sv, \"glVertexAttrib3sv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nbv, \"glVertexAttrib4Nbv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Niv, \"glVertexAttrib4Niv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nsv, \"glVertexAttrib4Nsv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nub, \"glVertexAttrib4Nub\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nubv, \"glVertexAttrib4Nubv\", \"glVertexAttrib4NubvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nuiv, \"glVertexAttrib4Nuiv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4Nusv, \"glVertexAttrib4Nusv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4bv, \"glVertexAttrib4bv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4d, \"glVertexAttrib4d\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4dv, \"glVertexAttrib4dv\", \"glVertexAttrib4dvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4f, \"glVertexAttrib4f\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4fv, \"glVertexAttrib4fv\", \"glVertexAttrib4fvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4iv, \"glVertexAttrib4iv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4s, \"glVertexAttrib4s\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4sv, \"glVertexAttrib4sv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4ubv, \"glVertexAttrib4ubv\", \"glVertexAttrib4ubvARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4uiv, \"glVertexAttrib4uiv\", validContext);\n    setGLExtensionFuncPtr(glVertexAttrib4usv, \"glVertexAttrib4usv\", validContext);\n\n    setGLExtensionFuncPtr(glVertexAttribPointer, \"glVertexAttribPointer\",\"glVertexAttribPointerARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttribIPointer, \"glVertexAttribIPointer\",\"glVertexAttribIPointerARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttribLPointer, \"glVertexAttribLPointer\",\"glVertexAttribLPointerARB\", validContext);\n    setGLExtensionFuncPtr(glVertexAttribDivisor, \"glVertexAttribDivisor\", validContext);\n\n    // v1.5-only ARB entry points, in case they're needed for fallback\n    setGLExtensionFuncPtr(glGetInfoLogARB, \"glGetInfoLogARB\", validContext);\n    setGLExtensionFuncPtr(glGetObjectParameterivARB, \"glGetObjectParameterivARB\", validContext);\n    setGLExtensionFuncPtr(glDeleteObjectARB, \"glDeleteObjectARB\", validContext);\n    setGLExtensionFuncPtr(glGetHandleARB, \"glGetHandleARB\", validContext);\n\n    // GL 2.1\n    setGLExtensionFuncPtr(glUniformMatrix2x3fv, \"glUniformMatrix2x3fv\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3x2fv, \"glUniformMatrix3x2fv\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix2x4fv, \"glUniformMatrix2x4fv\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4x2fv, \"glUniformMatrix4x2fv\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3x4fv, \"glUniformMatrix3x4fv\", validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4x3fv, \"glUniformMatrix4x3fv\", validContext);\n\n    // ARB_clip_control\n    setGLExtensionFuncPtr(glClipControl, \"glClipControl\", validContext);\n\n    // EXT_geometry_shader4\n    setGLExtensionFuncPtr(glProgramParameteri,  \"glProgramParameteri\", \"glProgramParameteriEXT\", validContext);\n\n    // ARB_tesselation_shader\n    setGLExtensionFuncPtr(glPatchParameteri, \"glPatchParameteri\", validContext);\n    setGLExtensionFuncPtr(glPatchParameterfv, \"glPatchParameterfv\", validContext);\n\n    // EXT_gpu_shader4\n    setGLExtensionFuncPtr(glGetUniformuiv,  \"glGetUniformuiv\", \"glGetUniformuivEXT\", validContext);\n    setGLExtensionFuncPtr(glBindFragDataLocation,  \"glBindFragDataLocation\", \"glBindFragDataLocationEXT\", validContext);\n    setGLExtensionFuncPtr(glBindFragDataLocationIndexed,  \"glBindFragDataLocationIndexed\", \"glBindFragDataLocationIndexedEXT\", validContext);\n    setGLExtensionFuncPtr(glGetFragDataIndex,  \"glGetFragDataIndex\", \"glGetFragDataIndexEXT\", validContext);\n    setGLExtensionFuncPtr(glGetFragDataLocation,  \"glGetFragDataLocation\", \"glGetFragDataLocationEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform1ui,  \"glUniform1ui\", \"glUniform1uiEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform2ui,  \"glUniform2ui\", \"glUniform2uiEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform3ui,  \"glUniform3ui\", \"glUniform3uiEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform4ui,  \"glUniform4ui\", \"glUniform4uiEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform1uiv,  \"glUniform1uiv\", \"glUniform1uivEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform2uiv,  \"glUniform2uiv\", \"glUniform2uivEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform3uiv,  \"glUniform3uiv\", \"glUniform3uivEXT\", validContext);\n    setGLExtensionFuncPtr(glUniform4uiv,  \"glUniform4uiv\", \"glUniform4uivEXT\", validContext);\n\n    // ARB_gpu_shader_int64\n    setGLExtensionFuncPtr(glUniform1i64,  \"glUniform1i64\",  \"glUniform1i64ARB\",  validContext);\n    setGLExtensionFuncPtr(glUniform1ui64, \"glUniform1ui64\", \"glUniform1ui64ARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2i64,  \"glUniform2i64\",  \"glUniform2i64ARB\",  validContext);\n    setGLExtensionFuncPtr(glUniform2ui64, \"glUniform2ui64\", \"glUniform2ui64ARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3i64,  \"glUniform3i64\",  \"glUniform3i64ARB\",  validContext);\n    setGLExtensionFuncPtr(glUniform3ui64, \"glUniform3ui64\", \"glUniform3ui64ARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4i64,  \"glUniform4i64\",  \"glUniform4i64ARB\",  validContext);\n    setGLExtensionFuncPtr(glUniform4ui64, \"glUniform4ui64\", \"glUniform4ui64ARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1i64v, \"glUniform1i64v\", \"glUniform1i64vARB\", validContext);\n    setGLExtensionFuncPtr(glUniform1ui64v,\"glUniform1ui64v\",\"glUniform1ui64vARB\",validContext);\n    setGLExtensionFuncPtr(glUniform2i64v, \"glUniform2i64v\", \"glUniform2i64vARB\", validContext);\n    setGLExtensionFuncPtr(glUniform2ui64v,\"glUniform2ui64v\",\"glUniform2ui64vARB\",validContext);\n    setGLExtensionFuncPtr(glUniform3i64v, \"glUniform3i64v\", \"glUniform3i64vARB\", validContext);\n    setGLExtensionFuncPtr(glUniform3ui64v,\"glUniform3ui64v\",\"glUniform3ui64vARB\",validContext);\n    setGLExtensionFuncPtr(glUniform4i64v, \"glUniform4i64v\", \"glUniform4i64vARB\", validContext);\n    setGLExtensionFuncPtr(glUniform4ui64v,\"glUniform4ui64v\",\"glUniform4ui64vARB\",validContext);\n\n    // ARB_uniform_buffer_object\n    setGLExtensionFuncPtr(glGetUniformIndices, \"glGetUniformIndices\", validContext);\n    setGLExtensionFuncPtr(glGetActiveUniformsiv, \"glGetActiveUniformsiv\", validContext);\n    setGLExtensionFuncPtr(glGetActiveUniformName, \"glGetActiveUniformName\", validContext);\n    setGLExtensionFuncPtr(glGetUniformBlockIndex, \"glGetUniformBlockIndex\", validContext);\n    setGLExtensionFuncPtr(glGetActiveUniformBlockiv, \"glGetActiveUniformBlockiv\", validContext);\n    setGLExtensionFuncPtr(glGetActiveUniformBlockName, \"glGetActiveUniformBlockName\", validContext);\n    setGLExtensionFuncPtr(glUniformBlockBinding, \"glUniformBlockBinding\", validContext);\n\n    // ARB_get_program_binary\n    setGLExtensionFuncPtr(glGetProgramBinary, \"glGetProgramBinary\", validContext);\n    setGLExtensionFuncPtr(glProgramBinary, \"glProgramBinary\", validContext);\n\n    // ARB_gpu_shader_fp64\n    setGLExtensionFuncPtr(glUniform1d, \"glUniform1d\" , validContext);\n    setGLExtensionFuncPtr(glUniform2d, \"glUniform2d\" , validContext);\n    setGLExtensionFuncPtr(glUniform3d, \"glUniform3d\" , validContext);\n    setGLExtensionFuncPtr(glUniform4d, \"glUniform4d\" , validContext);\n    setGLExtensionFuncPtr(glUniform1dv, \"glUniform1dv\" , validContext);\n    setGLExtensionFuncPtr(glUniform2dv, \"glUniform2dv\" , validContext);\n    setGLExtensionFuncPtr(glUniform3dv, \"glUniform3dv\" , validContext);\n    setGLExtensionFuncPtr(glUniform4dv, \"glUniform4dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix2dv, \"glUniformMatrix2dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3dv, \"glUniformMatrix3dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4dv, \"glUniformMatrix4dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix2x3dv,  \"glUniformMatrix2x3dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3x2dv,  \"glUniformMatrix3x2dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix2x4dv,  \"glUniformMatrix2x4dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4x2dv,  \"glUniformMatrix4x2dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix3x4dv,  \"glUniformMatrix3x4dv\" , validContext);\n    setGLExtensionFuncPtr(glUniformMatrix4x3dv,  \"glUniformMatrix4x3dv\" , validContext);\n\n    // ARB_shader_atomic_counters\n    setGLExtensionFuncPtr(glGetActiveAtomicCounterBufferiv,  \"glGetActiveAtomicCounterBufferiv\" , validContext);\n\n    // ARB_compute_shader\n    setGLExtensionFuncPtr(glDispatchCompute,  \"glDispatchCompute\" , validContext);\n\n\n    setGLExtensionFuncPtr(glMemoryBarrier,  \"glMemoryBarrier\", \"glMemoryBarrierEXT\" , validContext);\n\n    // BufferObject extensions\n    setGLExtensionFuncPtr(glGenBuffers, \"glGenBuffers\",\"glGenBuffersARB\", validContext);\n    setGLExtensionFuncPtr(glBindBuffer, \"glBindBuffer\",\"glBindBufferARB\", validContext);\n    setGLExtensionFuncPtr(glBufferData, \"glBufferData\",\"glBufferDataARB\", validContext);\n    setGLExtensionFuncPtr(glBufferSubData, \"glBufferSubData\",\"glBufferSubDataARB\", validContext);\n    setGLExtensionFuncPtr(glDeleteBuffers, \"glDeleteBuffers\",\"glDeleteBuffersARB\", validContext);\n    setGLExtensionFuncPtr(glIsBuffer, \"glIsBuffer\",\"glIsBufferARB\", validContext);\n    setGLExtensionFuncPtr(glGetBufferSubData, \"glGetBufferSubData\",\"glGetBufferSubDataARB\", validContext);\n    setGLExtensionFuncPtr(glBufferStorage, \"glBufferStorage\",\"glBufferStorageARB\", validContext);\n    setGLExtensionFuncPtr(glNamedBufferStorage, \"glNamedBufferStorage\",\"glNamedBufferStorageARB\", validContext);\n    setGLExtensionFuncPtr(glMapBuffer, \"glMapBuffer\",\"glMapBufferARB\", validContext);\n    setGLExtensionFuncPtr(glMapBufferRange,  \"glMapBufferRange\", \"glMapBufferRangeARB\" , validContext);\n    setGLExtensionFuncPtr(glUnmapBuffer, \"glUnmapBuffer\",\"glUnmapBufferARB\", validContext);\n    setGLExtensionFuncPtr(glGetBufferParameteriv, \"glGetBufferParameteriv\",\"glGetBufferParameterivARB\", validContext);\n    setGLExtensionFuncPtr(glGetBufferPointerv, \"glGetBufferPointerv\",\"glGetBufferPointervARB\", validContext);\n    setGLExtensionFuncPtr(glBindBufferRange, \"glBindBufferRange\", validContext);\n    setGLExtensionFuncPtr(glBindBufferBase,  \"glBindBufferBase\", \"glBindBufferBaseEXT\", \"glBindBufferBaseNV\" , validContext);\n    setGLExtensionFuncPtr(glTexBuffer, \"glTexBuffer\",\"glTexBufferARB\" , validContext);\n\n    isVBOSupported = validContext && (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES || osg::isGLExtensionSupported(contextID,\"GL_ARB_vertex_buffer_object\"));\n    isPBOSupported = validContext && (OSG_GLES3_FEATURES || OSG_GL3_FEATURES || osg::isGLExtensionSupported(contextID,\"GL_ARB_pixel_buffer_object\"));\n    isTBOSupported = validContext && osg::isGLExtensionSupported(contextID,\"GL_ARB_texture_buffer_object\");\n    isVAOSupported = validContext && (OSG_GLES3_FEATURES || OSG_GL3_FEATURES  || osg::isGLExtensionSupported(contextID, \"GL_ARB_vertex_array_object\", \"GL_OES_vertex_array_object\"));\n    isTransformFeedbackSupported = validContext && osg::isGLExtensionSupported(contextID, \"GL_ARB_transform_feedback2\");\n    isBufferObjectSupported = isVBOSupported || isPBOSupported;\n\n\n    // BlendFunc extensions\n    isBlendFuncSeparateSupported = validContext &&\n                                    (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES ||\n                                    osg::isGLExtensionSupported(contextID, \"GL_EXT_blend_func_separate\") ||\n                                    (glVersion >= 1.4f));\n\n    setGLExtensionFuncPtr(glBlendFuncSeparate, \"glBlendFuncSeparate\", \"glBlendFuncSeparateEXT\", validContext);\n\n    setGLExtensionFuncPtr(glBlendFunci, \"glBlendFunci\", \"glBlendFunciARB\", validContext);\n    setGLExtensionFuncPtr(glBlendFuncSeparatei, \"glBlendFuncSeparatei\", \"glBlendFuncSeparateiARB\", validContext);\n\n\n    isSecondaryColorSupported = validContext && isGLExtensionSupported(contextID,\"GL_EXT_secondary_color\");\n    isFogCoordSupported = validContext && isGLExtensionSupported(contextID,\"GL_EXT_fog_coord\");\n    isMultiTexSupported = validContext && isGLExtensionSupported(contextID,\"GL_ARB_multitexture\");\n    isOcclusionQuerySupported = validContext && osg::isGLExtensionSupported(contextID, \"GL_NV_occlusion_query\");\n    isARBOcclusionQuerySupported = validContext && (OSG_GL3_FEATURES || osg::isGLExtensionSupported(contextID, \"GL_ARB_occlusion_query\"));\n\n    isTimerQuerySupported = validContext && osg::isGLExtensionSupported(contextID, \"GL_EXT_timer_query\");\n    isARBTimerQuerySupported = validContext && osg::isGLExtensionSupported(contextID, \"GL_ARB_timer_query\");\n\n\n    setGLExtensionFuncPtr(glDrawArraysInstanced, \"glDrawArraysInstanced\",\"glDrawArraysInstancedARB\",\"glDrawArraysInstancedEXT\", validContext);\n    setGLExtensionFuncPtr(glDrawElementsInstanced, \"glDrawElementsInstanced\",\"glDrawElementsInstancedARB\",\"glDrawElementsInstancedEXT\", validContext);\n\n\n    setGLExtensionFuncPtr(glFogCoordfv, \"glFogCoordfv\",\"glFogCoordfvEXT\", validContext);\n    setGLExtensionFuncPtr(glSecondaryColor3ubv, \"glSecondaryColor3ubv\",\"glSecondaryColor3ubvEXT\", validContext);\n    setGLExtensionFuncPtr(glSecondaryColor3fv, \"glSecondaryColor3fv\",\"glSecondaryColor3fvEXT\", validContext);\n\n    setGLExtensionFuncPtr(glMultiTexCoord1f, \"glMultiTexCoord1f\",\"glMultiTexCoord1fARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord4f, \"glMultiTexCoord4f\",\"glMultiTexCoord4fARB\", validContext);\n\n    setGLExtensionFuncPtr(glMultiTexCoord1fv, \"glMultiTexCoord1fv\",\"glMultiTexCoord1fvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord2fv, \"glMultiTexCoord2fv\",\"glMultiTexCoord2fvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord3fv, \"glMultiTexCoord3fv\",\"glMultiTexCoord3fvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord4fv, \"glMultiTexCoord4fv\",\"glMultiTexCoord4fvARB\", validContext);\n\n\n    setGLExtensionFuncPtr(glMultiTexCoord1d, \"glMultiTexCoord1d\",\"glMultiTexCoord1dARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord1dv, \"glMultiTexCoord1dv\",\"glMultiTexCoord1dvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord2dv, \"glMultiTexCoord2dv\",\"glMultiTexCoord2dvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord3dv, \"glMultiTexCoord3dv\",\"glMultiTexCoord3dvARB\", validContext);\n    setGLExtensionFuncPtr(glMultiTexCoord4dv, \"glMultiTexCoord4dv\",\"glMultiTexCoord4dvARB\", validContext);\n\n    setGLExtensionFuncPtr(glGenOcclusionQueries, \"glGenOcclusionQueries\",\"glGenOcclusionQueriesNV\", validContext);\n    setGLExtensionFuncPtr(glDeleteOcclusionQueries, \"glDeleteOcclusionQueries\",\"glDeleteOcclusionQueriesNV\", validContext);\n    setGLExtensionFuncPtr(glIsOcclusionQuery, \"glIsOcclusionQuery\",\"glIsOcclusionQueryNV\", validContext);\n    setGLExtensionFuncPtr(glBeginOcclusionQuery, \"glBeginOcclusionQuery\",\"glBeginOcclusionQueryNV\", validContext);\n    setGLExtensionFuncPtr(glEndOcclusionQuery, \"glEndOcclusionQuery\",\"glEndOcclusionQueryNV\", validContext);\n    setGLExtensionFuncPtr(glGetOcclusionQueryiv, \"glGetOcclusionQueryiv\",\"glGetOcclusionQueryivNV\", validContext);\n    setGLExtensionFuncPtr(glGetOcclusionQueryuiv, \"glGetOcclusionQueryuiv\",\"glGetOcclusionQueryuivNV\", validContext);\n\n    setGLExtensionFuncPtr(glGenQueries, \"glGenQueries\", \"glGenQueriesARB\", validContext);\n    setGLExtensionFuncPtr(glDeleteQueries, \"glDeleteQueries\", \"glDeleteQueriesARB\", validContext);\n    setGLExtensionFuncPtr(glIsQuery, \"glIsQuery\", \"glIsQueryARB\", validContext);\n    setGLExtensionFuncPtr(glBeginQuery, \"glBeginQuery\", \"glBeginQueryARB\", validContext);\n    setGLExtensionFuncPtr(glEndQuery, \"glEndQuery\", \"glEndQueryARB\", validContext);\n    setGLExtensionFuncPtr(glBeginQueryIndexed, \"glBeginQueryIndexed\", \"glBeginQueryIndexedARB\", validContext);\n    setGLExtensionFuncPtr(glEndQueryIndexed, \"glEndQueryIndexed\", \"glEndQueryIndexedARB\", validContext);\n    setGLExtensionFuncPtr(glGetQueryiv, \"glGetQueryiv\", \"glGetQueryivARB\", validContext);\n    setGLExtensionFuncPtr(glGetQueryObjectiv, \"glGetQueryObjectiv\",\"glGetQueryObjectivARB\", validContext);\n    setGLExtensionFuncPtr(glGetQueryObjectuiv, \"glGetQueryObjectuiv\",\"glGetQueryObjectuivARB\", validContext);\n    setGLExtensionFuncPtr(glGetQueryObjectui64v, \"glGetQueryObjectui64v\",\"glGetQueryObjectui64vEXT\", validContext);\n    setGLExtensionFuncPtr(glQueryCounter, \"glQueryCounter\", validContext);\n    setGLExtensionFuncPtr(glGetInteger64v, \"glGetInteger64v\", validContext);\n\n\n    // SampleMaski functionality\n    isTextureMultisampleSupported = validContext && isGLExtensionSupported(contextID, \"GL_ARB_texture_multisample\");\n    isOpenGL32upported = (glVersion >= 3.2f);\n\n    // function pointers\n    setGLExtensionFuncPtr(glSampleMaski, \"glSampleMaski\", validContext);\n    isSampleMaskiSupported = validContext && (isOpenGL32upported || isGLExtensionSupported(contextID,\"ARB_texture_multisample\"));\n\n\n    // old styple Vertex/Fragment Programs\n    isVertexProgramSupported = validContext && isGLExtensionSupported(contextID,\"GL_ARB_vertex_program\");\n    isFragmentProgramSupported = validContext && isGLExtensionSupported(contextID,\"GL_ARB_fragment_program\");\n\n    setGLExtensionFuncPtr(glBindProgram,\"glBindProgramARB\", validContext);\n    setGLExtensionFuncPtr(glGenPrograms, \"glGenProgramsARB\", validContext);\n    setGLExtensionFuncPtr(glDeletePrograms, \"glDeleteProgramsARB\", validContext);\n    setGLExtensionFuncPtr(glProgramString, \"glProgramStringARB\", validContext);\n    setGLExtensionFuncPtr(glProgramLocalParameter4fv, \"glProgramLocalParameter4fvARB\", validContext);\n\n    // Sample Extensions (OpenGL>=3.3)\n    setGLExtensionFuncPtr(glSamplerParameteri, \"glSamplerParameteri\", \"glSamplerParameteriARB\", validContext);\n    setGLExtensionFuncPtr(glSamplerParameterf, \"glSamplerParameterf\", \"glSamplerParameterfARB\", validContext);\n    setGLExtensionFuncPtr(glSamplerParameteriv, \"glSamplerParameteriv\", \"glSamplerParameterivARB\", validContext);\n    setGLExtensionFuncPtr(glSamplerParameterfv, \"glSamplerParameterfv\", \"glSamplerParameterfvARB\", validContext);\n    setGLExtensionFuncPtr(glSamplerParameterIiv, \"glSamplerParameterIiv\", \"glSamplerParameterIivARB\", validContext);\n    setGLExtensionFuncPtr(glSamplerParameterIuiv, \"glSamplerParameterIuiv\", \"glSamplerParameterIuivARB\", validContext);\n\n    setGLExtensionFuncPtr(glGetSamplerParameteriv, \"glGetSamplerParameteriv\", \"glGetSamplerParameterivARB\", validContext);\n    setGLExtensionFuncPtr(glGetSamplerParameterfv, \"glGetSamplerParameterfv\", \"glGetSamplerParameterfvARB\", validContext);\n    setGLExtensionFuncPtr(glGetSamplerParameterIiv, \"glGetSamplerParameterIiv\", \"glGetSamplerParameterIivARB\", validContext);\n    setGLExtensionFuncPtr(glGetSamplerParameterIuiv, \"glGetSamplerParameterIuiv\", \"glGetSamplerParameterIuivARB\", validContext);\n\n    setGLExtensionFuncPtr(glGenSamplers, \"glGenSamplers\", \"glGenSamplersARB\", validContext);\n    setGLExtensionFuncPtr(glDeleteSamplers, \"glDeleteSamplers\", \"glDeleteSamplersARB\", validContext);\n    setGLExtensionFuncPtr(glBindSampler, \"glBindSampler\", \"glBindSamplerARB\", validContext);\n    setGLExtensionFuncPtr(glIsSampler, \"glIsSampler\", \"glIsSamplerARB\", validContext);\n\n    // Texture extensions\n    const char* renderer = validContext ? (const char*) glGetString(GL_RENDERER) : 0;\n    std::string rendererString(renderer ? renderer : \"\");\n\n    bool radeonHardwareDetected = (rendererString.find(\"Radeon\")!=std::string::npos || rendererString.find(\"RADEON\")!=std::string::npos);\n    bool fireGLHardwareDetected = (rendererString.find(\"FireGL\")!=std::string::npos || rendererString.find(\"FIREGL\")!=std::string::npos);\n\n    bool builtInSupport = OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES;\n\n    isMultiTexturingSupported = validContext &&\n                                (builtInSupport || OSG_GLES1_FEATURES ||\n                                 isGLExtensionOrVersionSupported( contextID,\"GL_ARB_multitexture\", 1.3f) ||\n                                 isGLExtensionOrVersionSupported(contextID,\"GL_EXT_multitexture\", 1.3f));\n\n    isTextureFilterAnisotropicSupported = validContext && isGLExtensionSupported(contextID,\"GL_EXT_texture_filter_anisotropic\");\n    isTextureSwizzleSupported = validContext && isGLExtensionSupported(contextID,\"GL_ARB_texture_swizzle\");\n    isTextureCompressionARBSupported = validContext && (builtInSupport || isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_compression\", 1.3f));\n    isTextureCompressionS3TCSupported = validContext && (isGLExtensionSupported(contextID,\"GL_EXT_texture_compression_s3tc\") || isGLExtensionSupported(contextID, \"GL_S3_s3tc\"));\n    isTextureCompressionPVRTC2BPPSupported = validContext && isGLExtensionSupported(contextID,\"GL_IMG_texture_compression_pvrtc\");\n    isTextureCompressionPVRTC4BPPSupported = isTextureCompressionPVRTC2BPPSupported;//covered by same extension\n    isTextureCompressionETCSupported = validContext && isGLExtensionSupported(contextID,\"GL_OES_compressed_ETC1_RGB8_texture\");\n    isTextureCompressionETC2Supported = validContext && isGLExtensionSupported(contextID,\"GL_ARB_ES3_compatibility\");\n    isTextureCompressionRGTCSupported = validContext && isGLExtensionSupported(contextID,\"GL_EXT_texture_compression_rgtc\");\n    isTextureCompressionPVRTCSupported = validContext && isGLExtensionSupported(contextID,\"GL_IMG_texture_compression_pvrtc\");\n\n    isTextureMirroredRepeatSupported = validContext &&\n                                       (builtInSupport ||\n                                        isGLExtensionOrVersionSupported(contextID,\"GL_IBM_texture_mirrored_repeat\", 1.4f) ||\n                                        isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_mirrored_repeat\", 1.4f));\n\n    isTextureEdgeClampSupported = validContext &&\n                                  (builtInSupport ||\n                                   isGLExtensionOrVersionSupported(contextID,\"GL_EXT_texture_edge_clamp\", 1.2f) ||\n                                   isGLExtensionOrVersionSupported(contextID,\"GL_SGIS_texture_edge_clamp\", 1.2f));\n\n\n    isTextureBorderClampSupported = validContext &&\n                                    (OSG_GL3_FEATURES ||\n                                     ((OSG_GL1_FEATURES || OSG_GL2_FEATURES) && isGLExtensionOrVersionSupported(contextID,\"GL_ARB_texture_border_clamp\", 1.3f)) ||\n                                     ((OSG_GLES2_FEATURES || OSG_GLES3_FEATURES) && isGLExtensionSupported(contextID,\"GL_EXT_texture_border_clamp\")));\n\n    isGenerateMipMapSupported = validContext && (builtInSupport || isGLExtensionOrVersionSupported(contextID,\"GL_SGIS_generate_mipmap\", 1.4f));\n    preferGenerateMipmapSGISForPowerOfTwo = (radeonHardwareDetected||fireGLHardwareDetected) ? false : true;\n    isTextureMultisampledSupported = validContext && (isGLExtensionSupported(contextID,\"GL_ARB_texture_multisample\"));\n    isShadowSupported = validContext && (OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_ARB_shadow\"));\n    isShadowAmbientSupported = validContext && (isGLExtensionSupported(contextID,\"GL_ARB_shadow_ambient\"));\n    isClientStorageSupported = validContext && (isGLExtensionSupported(contextID,\"GL_APPLE_client_storage\"));\n    isNonPowerOfTwoTextureMipMappedSupported = validContext && (builtInSupport || isGLExtensionSupported(contextID, \"GL_OES_texture_npot\") || isGLExtensionOrVersionSupported(contextID, \"GL_ARB_texture_non_power_of_two\", 2.0));\n    isNonPowerOfTwoTextureNonMipMappedSupported = validContext && (isNonPowerOfTwoTextureMipMappedSupported || isGLExtensionSupported(contextID, \"GL_APPLE_texture_2D_limited_npot\"));\n    isTextureIntegerEXTSupported = validContext && (OSG_GL3_FEATURES || isGLExtensionSupported(contextID, \"GL_EXT_texture_integer\"));\n\n    if (rendererString.find(\"GeForce FX\")!=std::string::npos)\n    {\n        isNonPowerOfTwoTextureMipMappedSupported = false;\n        OSG_INFO<<\"Disabling _isNonPowerOfTwoTextureMipMappedSupported for GeForce FX hardware.\"<<std::endl;\n    }\n\n    maxTextureSize=0;\n    if (validContext) glGetIntegerv(GL_MAX_TEXTURE_SIZE,&maxTextureSize);\n\n    GLint osg_max_size = maxTextureSize;\n    if( (getEnvVar(\"OSG_MAX_TEXTURE_SIZE\", osg_max_size)) && osg_max_size<maxTextureSize)\n    {\n        maxTextureSize = osg_max_size;\n    }\n    isTextureMaxLevelSupported = (glVersion >= 1.2f);\n\n    isTextureStorageEnabled = validContext && ((glVersion >= 4.2f) || isGLExtensionSupported(contextID, \"GL_ARB_texture_storage\"));\n\n    if (isTextureStorageEnabled)\n    {\n        std::string value;\n        if (getEnvVar(\"OSG_GL_TEXTURE_STORAGE\", value))\n        {\n            if (value==\"OFF\" || value==\"DISABLE\") isTextureStorageEnabled = false;\n            else isTextureStorageEnabled = true;\n        }\n    }\n\n    setGLExtensionFuncPtr(glTexStorage1D,\"glTexStorage1D\",\"glTexStorage1DARB\", validContext);\n    setGLExtensionFuncPtr(glTextureStorage1D,\"glTextureStorage1D\",\"glTextureStorage1DARB\", validContext);\n    setGLExtensionFuncPtr(glTexStorage2D,\"glTexStorage2D\",\"glTexStorage2DARB\", validContext);\n    setGLExtensionFuncPtr(glTextureStorage2D,\"glTextureStorage2D\",\"glTextureStorage2DARB\", validContext);\n    setGLExtensionFuncPtr(glTexStorage3D, \"glTexStorage3D\",\"glTexStorage3DEXT\", validContext);\n    setGLExtensionFuncPtr(glTextureStorage3D, \"glTextureStorage3D\",\"glTextureStorage3DEXT\", validContext);\n    setGLExtensionFuncPtr(glTexStorage2DMultisample, \"glTextureStorage2DMultisample\",\"glTextureStorage2DMultisampleEXT\", validContext);\n    setGLExtensionFuncPtr(glTexStorage3DMultisample, \"glTextureStorage3DMultisample\",\"glTextureStorage3DMultisampleEXT\", validContext);\n    setGLExtensionFuncPtr(glTextureView, \"glTextureView\",\"glTextureViewEXT\", validContext);\n\n    setGLExtensionFuncPtr(glCompressedTexImage2D,\"glCompressedTexImage2D\",\"glCompressedTexImage2DARB\", validContext);\n    setGLExtensionFuncPtr(glCompressedTexSubImage2D,\"glCompressedTexSubImage2D\",\"glCompressedTexSubImage2DARB\", validContext);\n    setGLExtensionFuncPtr(glGetCompressedTexImage,\"glGetCompressedTexImage\",\"glGetCompressedTexImageARB\", validContext);;\n    setGLExtensionFuncPtr(glTexImage2DMultisample, \"glTexImage2DMultisample\", \"glTexImage2DMultisampleARB\", validContext);\n\n    setGLExtensionFuncPtr(glTexParameterIiv, \"glTexParameterIiv\", \"glTexParameterIivARB\", \"glTexParameterIivEXT\", validContext);\n    setGLExtensionFuncPtr(glTexParameterIuiv, \"glTexParameterIuiv\", \"glTexParameterIuivARB\", \"glTexParameterIuivEXT\", validContext);\n\n    setGLExtensionFuncPtr(glBindImageTexture, \"glBindImageTexture\", \"glBindImageTextureARB\", validContext);\n\n\n    // Texture3D extensions\n    isTexture3DFast = validContext && (OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_EXT_texture3D\"));\n\n    if (isTexture3DFast) isTexture3DSupported = true;\n    else isTexture3DSupported = validContext && (glVersion >= 1.2f);\n\n    maxTexture3DSize = 0;\n    if (validContext) glGetIntegerv(GL_MAX_3D_TEXTURE_SIZE, &maxTexture3DSize);\n\n    setGLExtensionFuncPtr(glTexImage3D, \"glTexImage3D\",\"glTexImage3DEXT\", validContext);\n    setGLExtensionFuncPtr(glTexSubImage3D, \"glTexSubImage3D\",\"glTexSubImage3DEXT\", validContext);\n\n    setGLExtensionFuncPtr(glCompressedTexImage3D, \"glCompressedTexImage3D\",\"glCompressedTexImage3DARB\", validContext);\n    setGLExtensionFuncPtr(glCompressedTexSubImage3D, \"glCompressedTexSubImage3D\",\"glCompressedTexSubImage3DARB\", validContext);\n\n    setGLExtensionFuncPtr(glTexImage3DMultisample, \"glTexImage3DMultisample\", validContext);\n    setGLExtensionFuncPtr(glGetMultisamplefv, \"glGetMultisamplefv\", validContext);\n\n    setGLExtensionFuncPtr(glCopyTexSubImage3D, \"glCopyTexSubImage3D\",\"glCopyTexSubImage3DEXT\", validContext);\n    setGLExtensionFuncPtr(glBeginConditionalRender, \"glBeginConditionalRender\", \"glBeginConditionalRenderARB\");\n    setGLExtensionFuncPtr(glEndConditionalRender, \"glEndConditionalRender\", \"glEndConditionalRenderARB\");\n\n    // Texture2DArray extensions\n    isTexture2DArraySupported = validContext && (OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_EXT_texture_array\"));\n\n    max2DSize = 0;\n    if (validContext) glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max2DSize);\n    maxLayerCount = 0;\n    if (validContext) glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS, &maxLayerCount);\n\n    // ARB_bindless_texture\n    setGLExtensionFuncPtr(glGetTextureHandle,             \"glGetTextureHandle\", \"glGetTextureHandleARB\",\"glGetTextureHandleNV\", validContext);\n    setGLExtensionFuncPtr(glGetTextureSamplerHandle,      \"glGetTextureSamplerHandle\",\"glGetTextureSamplerHandleARB\", \"glGetTextureSamplerHandleNV\", validContext);\n    setGLExtensionFuncPtr(glMakeTextureHandleResident,    \"glMakeTextureHandleResident\", \"glMakeTextureHandleResidentARB\",\"glMakeTextureHandleResidentNV\", validContext);\n    setGLExtensionFuncPtr(glMakeTextureHandleNonResident, \"glMakeTextureHandleNonResident\", \"glMakeTextureHandleNonResidentARB\", \"glMakeTextureHandleNonResidentNV\",validContext);\n    setGLExtensionFuncPtr(glIsTextureHandleResident,      \"glIsTextureHandleResident\",\"glIsTextureHandleResidentARB\", \"glIsTextureHandleResidentNV\", validContext);\n    setGLExtensionFuncPtr(glGetImageHandle,      \"glGetImageHandle\",\"glGetImageHandleARB\", \"glGetImageHandleNV\", validContext);\n    setGLExtensionFuncPtr(glMakeImageHandleResident,      \"glMakeImageHandleResident\",\"glMakeImageHandleResidentARB\", \"glMakeImageHandleResidentNV\", validContext);\n    setGLExtensionFuncPtr(glMakeImageHandleNonResident,      \"glMakeImageHandleNonResident\",\"glMakeImageHandleNonResidentARB\", \"glMakeImageHandleNonResidentNV\", validContext);\n    setGLExtensionFuncPtr(glIsImageHandleResident,      \"glIsImageHandleResident\",\"glIsImageHandleResidentARB\", \"glIsImageHandleResidentNV\", validContext);\n    setGLExtensionFuncPtr(glUniformHandleui64,            \"glUniformHandleui64\", \"glUniformHandleui64ARB\",\"glUniformHandleui64NV\", validContext);\n    setGLExtensionFuncPtr(glUniformHandleuiv64,      \"glUniformHandleuiv64\",\"glUniformHandleuiv64ARB\", \"glUniformHandleuiv64NV\", validContext);\n    setGLExtensionFuncPtr(glProgramUniformHandleui64,      \"glProgramUniformHandleui64\",\"glProgramUniformHandleui64ARB\", \"glProgramUniformHandleui64NV\", validContext);\n    setGLExtensionFuncPtr(glProgramUniformHandleuiv64,      \"glProgramUniformHandleuiv64\",\"glProgramUniformHandleuiv64ARB\", \"glProgramUniformHandleuiv64NV\", validContext);\n\n\n    // Blending\n    isBlendColorSupported = validContext &&\n                            (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES ||\n                             isGLExtensionSupported(contextID,\"GL_EXT_blend_color\") ||\n                             (glVersion >= 1.2f));\n\n    setGLExtensionFuncPtr(glBlendColor, \"glBlendColor\", \"glBlendColorEXT\", validContext);\n\n    bool bultInSupport = OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES;\n    isBlendEquationSupported = validContext &&\n                               (bultInSupport ||\n                                isGLExtensionSupported(contextID, \"GL_EXT_blend_equation\") ||\n                                (glVersion >= 1.2f));\n\n\n    isBlendEquationSeparateSupported = validContext &&\n                                       (bultInSupport ||\n                                        isGLExtensionSupported(contextID, \"GL_EXT_blend_equation_separate\") ||\n                                        (glVersion >= 2.0f));\n\n\n    isSGIXMinMaxSupported = validContext && isGLExtensionSupported(contextID, \"GL_SGIX_blend_alpha_minmax\");\n    isLogicOpSupported = validContext && isGLExtensionSupported(contextID, \"GL_EXT_blend_logic_op\");\n\n    setGLExtensionFuncPtr(glBlendEquation, \"glBlendEquation\", \"glBlendEquationEXT\", validContext);\n    setGLExtensionFuncPtr(glBlendEquationSeparate, \"glBlendEquationSeparate\", \"glBlendEquationSeparateEXT\", validContext);\n\n    setGLExtensionFuncPtr(glBlendEquationi, \"glBlendEquationi\", \"glBlendEquationiARB\", validContext);\n    setGLExtensionFuncPtr(glBlendEquationSeparatei, \"glBlendEquationSeparatei\", \"glBlendEquationSeparateiARB\", validContext);\n\n\n    // glEnablei/glDisabli\n    setGLExtensionFuncPtr(glEnablei, \"glEnablei\", validContext);\n    setGLExtensionFuncPtr(glDisablei, \"glDisablei\", validContext);\n\n\n    // Stencil`\n    isStencilWrapSupported = validContext && isGLExtensionOrVersionSupported(contextID, \"GL_EXT_stencil_wrap\", 1.4f);\n    isStencilTwoSidedSupported = validContext && isGLExtensionSupported(contextID, \"GL_EXT_stencil_two_side\");\n    isOpenGL20Supported = validContext && (glVersion >= 2.0f);\n    isSeparateStencilSupported = validContext && isGLExtensionSupported(contextID, \"GL_ATI_separate_stencil\");\n\n    // function pointers\n    setGLExtensionFuncPtr(glActiveStencilFace, \"glActiveStencilFaceEXT\", validContext);\n    setGLExtensionFuncPtr(glStencilOpSeparate, \"glStencilOpSeparate\", \"glStencilOpSeparateATI\", validContext);\n    setGLExtensionFuncPtr(glStencilMaskSeparate, \"glStencilMaskSeparate\", validContext);\n    setGLExtensionFuncPtr(glStencilFuncSeparate, \"glStencilFuncSeparate\", \"glStencilFuncSeparateATI\", validContext);\n    setGLExtensionFuncPtr(glStencilFuncSeparateATI, \"glStencilFuncSeparateATI\", validContext);\n\n\n    // Color Mask\n    setGLExtensionFuncPtr(glColorMaski, \"glColorMaski\", \"glColorMaskiARB\", validContext);\n\n\n    // ClampColor\n    isClampColorSupported = validContext &&\n                            (OSG_GL3_FEATURES ||\n                             isGLExtensionSupported(contextID,\"GL_ARB_color_buffer_float\") ||\n                             (glVersion >= 2.0f));\n\n    setGLExtensionFuncPtr(glClampColor, \"glClampColor\", \"glClampColorARB\", validContext);\n\n\n    // PrimitiveRestartIndex\n    setGLExtensionFuncPtr(glPrimitiveRestartIndex, \"glPrimitiveRestartIndex\", \"glPrimitiveRestartIndexNV\", validContext);\n\n\n    // Point\n    isPointParametersSupported = validContext &&\n                                 (OSG_GL3_FEATURES || (glVersion >= 1.4f)  ||\n                                  isGLExtensionSupported(contextID,\"GL_ARB_point_parameters\") ||\n                                  isGLExtensionSupported(contextID,\"GL_EXT_point_parameters\") ||\n                                  isGLExtensionSupported(contextID,\"GL_SGIS_point_parameters\"));\n\n\n    isPointSpriteSupported = validContext && (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES || isGLExtensionSupported(contextID, \"GL_ARB_point_sprite\") || isGLExtensionSupported(contextID, \"GL_OES_point_sprite\") || isGLExtensionSupported(contextID, \"GL_NV_point_sprite\"));\n    isPointSpriteModeSupported = isPointSpriteSupported && !OSG_GL3_FEATURES;\n    isPointSpriteCoordOriginSupported = validContext && (OSG_GL3_FEATURES || (glVersion >= 2.0f));\n\n\n    setGLExtensionFuncPtr(glPointParameteri, \"glPointParameteri\", \"glPointParameteriARB\", validContext);\n    if (!glPointParameteri) setGLExtensionFuncPtr(glPointParameteri, \"glPointParameteriEXT\", \"glPointParameteriSGIS\", validContext);\n\n    setGLExtensionFuncPtr(glPointParameterf, \"glPointParameterf\", \"glPointParameterfARB\", validContext);\n    if (!glPointParameterf) setGLExtensionFuncPtr(glPointParameterf, \"glPointParameterfEXT\", \"glPointParameterfSGIS\", validContext);\n\n    setGLExtensionFuncPtr(glPointParameterfv, \"glPointParameterfv\", \"glPointParameterfvARB\", validContext);\n    if (!glPointParameterfv) setGLExtensionFuncPtr(glPointParameterfv, \"glPointParameterfvEXT\", \"glPointParameterfvSGIS\", validContext);\n\n\n    // Multisample\n    isMultisampleSupported = validContext && (OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES || isGLExtensionSupported(contextID,\"GL_ARB_multisample\"));\n    isMultisampleFilterHintSupported = validContext && isGLExtensionSupported(contextID, \"GL_NV_multisample_filter_hint\");\n\n    setGLExtensionFuncPtr(glSampleCoverage, \"glSampleCoverage\", \"glSampleCoverageARB\", validContext);\n\n\n    // FrameBufferObject\n    setGLExtensionFuncPtr(glBindRenderbuffer, \"glBindRenderbuffer\", \"glBindRenderbufferEXT\", \"glBindRenderbufferOES\", validContext);\n    setGLExtensionFuncPtr(glDeleteRenderbuffers, \"glDeleteRenderbuffers\", \"glDeleteRenderbuffersEXT\", \"glDeleteRenderbuffersOES\", validContext);\n    setGLExtensionFuncPtr(glGenRenderbuffers, \"glGenRenderbuffers\", \"glGenRenderbuffersEXT\", \"glGenRenderbuffersOES\", validContext);\n    setGLExtensionFuncPtr(glRenderbufferStorage, \"glRenderbufferStorage\", \"glRenderbufferStorageEXT\", \"glRenderbufferStorageOES\", validContext);\n    setGLExtensionFuncPtr(glRenderbufferStorageMultisample, \"glRenderbufferStorageMultisample\", \"glRenderbufferStorageMultisampleEXT\", \"glRenderbufferStorageMultisampleOES\", validContext);\n    setGLExtensionFuncPtr(glRenderbufferStorageMultisampleCoverageNV, \"glRenderbufferStorageMultisampleCoverageNV\", validContext);\n    setGLExtensionFuncPtr(glBindFramebuffer, \"glBindFramebuffer\", \"glBindFramebufferEXT\", \"glBindFramebufferOES\", validContext);\n    setGLExtensionFuncPtr(glDeleteFramebuffers, \"glDeleteFramebuffers\", \"glDeleteFramebuffersEXT\", \"glDeleteFramebuffersOES\", validContext);\n    setGLExtensionFuncPtr(glGenFramebuffers, \"glGenFramebuffers\", \"glGenFramebuffersEXT\", \"glGenFramebuffersOES\", validContext);\n    setGLExtensionFuncPtr(glCheckFramebufferStatus, \"glCheckFramebufferStatus\", \"glCheckFramebufferStatusEXT\", \"glCheckFramebufferStatusOES\", validContext);\n\n    setGLExtensionFuncPtr(glFramebufferTexture1D, \"glFramebufferTexture1D\", \"glFramebufferTexture1DEXT\", \"glFramebufferTexture1DOES\", validContext);\n    setGLExtensionFuncPtr(glFramebufferTexture2D, \"glFramebufferTexture2D\", \"glFramebufferTexture2DEXT\", \"glFramebufferTexture2DOES\", validContext);\n    setGLExtensionFuncPtr(glFramebufferTexture3D, \"glFramebufferTexture3D\", \"glFramebufferTexture3DEXT\", \"glFramebufferTexture3DOES\", validContext);\n    setGLExtensionFuncPtr(glFramebufferTexture, \"glFramebufferTexture\", \"glFramebufferTextureEXT\", \"glFramebufferTextureOES\", validContext);\n    setGLExtensionFuncPtr(glFramebufferTextureLayer, \"glFramebufferTextureLayer\", \"glFramebufferTextureLayerEXT\", \"glFramebufferTextureLayerOES\", validContext);\n    setGLExtensionFuncPtr(glFramebufferTextureFace,  \"glFramebufferTextureFace\", \"glFramebufferTextureFaceEXT\", \"glFramebufferTextureFaceOES\" , validContext);\n    setGLExtensionFuncPtr(glFramebufferRenderbuffer, \"glFramebufferRenderbuffer\", \"glFramebufferRenderbufferEXT\", \"glFramebufferRenderbufferOES\", validContext);\n    //ARB_framebuffer_no_attachments\n    //OpenGL 4.3\n    setGLExtensionFuncPtr(glFramebufferParameteri, \"glFramebufferParameteri\", \"glFramebufferParameteriARB\", \"glFramebufferParameteriOES\", validContext);\n    setGLExtensionFuncPtr(glGetFramebufferParameteriv, \"glGetFramebufferParameteriv\", \"glGetFramebufferParameterivARB\", \"glGetFramebufferParameterivOES\", validContext);\n    //OpenGL 4.5 (EXT_direct_state_access required)\n    setGLExtensionFuncPtr(glNamedFramebufferParameteri, \"glNamedFramebufferParameteri\", \"glNamedFramebufferParameteriEXT\", \"glNamedFramebufferParameteriOES\", validContext);\n    setGLExtensionFuncPtr(glGetNamedFramebufferParameteriv, \"glGetNamedFramebufferParameteriv\", \"glGetNamedFramebufferParameterivEXT\", \"glGetNamedFramebufferParameterivOES\", validContext);\n\n    setGLExtensionFuncPtr(glGenerateMipmap, \"glGenerateMipmap\", \"glGenerateMipmapEXT\", \"glGenerateMipmapOES\", validContext);\n    setGLExtensionFuncPtr(glBlitFramebuffer, \"glBlitFramebuffer\", \"glBlitFramebufferEXT\", \"glBlitFramebufferOES\", validContext);\n    setGLExtensionFuncPtr(glGetRenderbufferParameteriv, \"glGetRenderbufferParameteriv\", \"glGetRenderbufferParameterivEXT\", \"glGetRenderbufferParameterivOES\", validContext);\n\n\n    isFrameBufferObjectSupported =\n        glBindRenderbuffer != 0 &&\n        glDeleteRenderbuffers != 0 &&\n        glGenRenderbuffers != 0 &&\n        glRenderbufferStorage != 0 &&\n        glBindFramebuffer != 0 &&\n        glDeleteFramebuffers != 0 &&\n        glGenFramebuffers != 0 &&\n        glCheckFramebufferStatus != 0 &&\n        glFramebufferTexture2D != 0 &&\n        glFramebufferRenderbuffer != 0 &&\n        glGenerateMipmap != 0 &&\n        glGetRenderbufferParameteriv != 0 &&\n    ( OSG_GLES2_FEATURES || OSG_GLES1_FEATURES || isGLExtensionOrVersionSupported(contextID, \"GL_EXT_framebuffer_object\",3.0f) );\n\n\n    isPackedDepthStencilSupported = validContext &&\n                                    (OSG_GL3_FEATURES ||\n                                     (isGLExtensionSupported(contextID, \"GL_EXT_packed_depth_stencil\")) ||\n                                     (isGLExtensionSupported(contextID, \"GL_OES_packed_depth_stencil\")));\n\n    //subroutine\n    osg::setGLExtensionFuncPtr(glGetSubroutineUniformLocation, \"glGetSubroutineUniformLocation\", validContext);\n    osg::setGLExtensionFuncPtr(glGetActiveSubroutineUniformName, \"glGetActiveSubroutineUniformName\", validContext);\n    osg::setGLExtensionFuncPtr(glGetActiveSubroutineUniformiv, \"glGetActiveSubroutineUniformiv\", validContext);\n    osg::setGLExtensionFuncPtr(glGetSubroutineIndex, \"glGetSubroutineIndex\", validContext);\n    osg::setGLExtensionFuncPtr(glGetActiveSubroutineName, \"glGetActiveSubroutineName\", validContext);\n    osg::setGLExtensionFuncPtr(glGetProgramStageiv, \"glGetProgramStageiv\", validContext);\n    osg::setGLExtensionFuncPtr(glUniformSubroutinesuiv, \"glUniformSubroutinesuiv\", validContext);\n    osg::setGLExtensionFuncPtr(glGetUniformSubroutineuiv, \"glGetUniformSubroutineuiv\", validContext);\n\n\n    // Sync\n    osg::setGLExtensionFuncPtr(glFenceSync, \"glFenceSync\", validContext);\n    osg::setGLExtensionFuncPtr(glIsSync, \"glIsSync\", validContext);\n    osg::setGLExtensionFuncPtr(glDeleteSync, \"glDeleteSync\", validContext);\n    osg::setGLExtensionFuncPtr(glClientWaitSync, \"glClientWaitSync\", validContext);\n    osg::setGLExtensionFuncPtr(glWaitSync, \"glWaitSync\", validContext);\n    osg::setGLExtensionFuncPtr(glGetSynciv, \"glGetSynciv\", validContext);\n\n    // Indirect Rendering\n    osg::setGLExtensionFuncPtr(glDrawArraysIndirect, \"glDrawArraysIndirect\", \"glDrawArraysIndirectEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glMultiDrawArraysIndirect, \"glMultiDrawArraysIndirect\", \"glMultiDrawArraysIndirectEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glDrawElementsIndirect, \"glDrawElementsIndirect\", \"glDrawElementsIndirectEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glMultiDrawElementsIndirect, \"glMultiDrawElementsIndirect\", \"glMultiDrawElementsIndirectEXT\", validContext);\n\n    // ARB_sparse_texture\n    osg::setGLExtensionFuncPtr(glTexPageCommitment, \"glTexPageCommitment\",\"glTexPageCommitmentARB\", \"glTexPageCommitmentEXT\", validContext);\n\n    // Transform Feeedback\n    osg::setGLExtensionFuncPtr(glBeginTransformFeedback, \"glBeginTransformFeedback\", \"glBeginTransformFeedbackEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glEndTransformFeedback, \"glEndTransformFeedback\", \"glEndTransformFeedbackEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glTransformFeedbackVaryings, \"glTransformFeedbackVaryings\", \"glTransformFeedbackVaryingsEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbackVarying, \"glGetTransformFeedbackVarying\", \"glGetTransformFeedbackVaryingEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glBindTransformFeedback, \"glBindTransformFeedback\", validContext);\n    osg::setGLExtensionFuncPtr(glDeleteTransformFeedbacks, \"glDeleteTransformFeedbacks\", validContext);\n    osg::setGLExtensionFuncPtr(glGenTransformFeedbacks, \"glGenTransformFeedbacks\", validContext);\n    osg::setGLExtensionFuncPtr(glIsTransformFeedback, \"glIsTransformFeedback\", validContext);\n    osg::setGLExtensionFuncPtr(glPauseTransformFeedback, \"glPauseTransformFeedback\", validContext);\n    osg::setGLExtensionFuncPtr(glResumeTransformFeedback, \"glResumeTransformFeedback\", validContext);\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedback, \"glDrawTransformFeedback\", validContext);\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackStream, \"glDrawTransformFeedbackStream\", validContext);\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackInstanced, \"glDrawTransformFeedbackInstanced\", validContext);\n    osg::setGLExtensionFuncPtr(glDrawTransformFeedbackStreamInstanced, \"glDrawTransformFeedbackStreamInstanced\", validContext);\n    osg::setGLExtensionFuncPtr(glCreateTransformFeedbacks, \"glCreateTransformFeedbacks\", validContext);\n    osg::setGLExtensionFuncPtr(glTransformFeedbackBufferBase, \"glTransformFeedbackBufferBase\", validContext);\n    osg::setGLExtensionFuncPtr(glTransformFeedbackBufferRange, \"glTransformFeedbackBufferRange\", validContext);\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbackiv, \"glGetTransformFeedbackiv\", validContext);\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbacki_v, \"glGetTransformFeedbacki_v\", validContext);\n    osg::setGLExtensionFuncPtr(glGetTransformFeedbacki64_v, \"glGetTransformFeedbacki64_v\", validContext);\n\n    //Vertex Array Object\n    osg::setGLExtensionFuncPtr(glGenVertexArrays, \"glGenVertexArrays\", \"glGenVertexArraysOES\", validContext);\n    osg::setGLExtensionFuncPtr(glBindVertexArray, \"glBindVertexArray\", \"glBindVertexArrayOES\", validContext);\n    osg::setGLExtensionFuncPtr(glDeleteVertexArrays, \"glDeleteVertexArrays\", \"glDeleteVertexArraysOES\", validContext);\n    osg::setGLExtensionFuncPtr(glIsVertexArray, \"glIsVertexArray\", \"glIsVertexArrayOES\", validContext);\n\n    // OpenGL 4.3 / ARB_vertex_attrib_binding\n    isVertexAttribBindingSupported = validContext && (isGLExtensionOrVersionSupported(contextID, \"GL_ARB_vertex_attrib_binding\", 4.3f));\n\n    osg::setGLExtensionFuncPtr(glBindVertexBuffer, \"glBindVertexBuffer\", \"glBindVertexBufferOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexArrayVertexBuffer, \"glVertexArrayVertexBuffer\", \"glVertexArrayVertexBufferOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexAttribBinding, \"glVertexAttribBinding\", \"glVertexAttribBindingOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexArrayAttribBinding, \"glVertexArrayAttribBinding\", \"glVertexArrayAttribBindingOES\", validContext);\n\n    osg::setGLExtensionFuncPtr(glVertexAttribFormat, \"glVertexAttribBinding\", \"glVertexAttribBindingOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexAttribIFormat, \"glVertexAttribBinding\", \"glVertexAttribBindingOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexAttribLFormat, \"glVertexAttribLFormat\", \"glVertexAttribLFormatOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexArrayAttribFormat, \"glVertexArrayAttribFormat\", \"glVertexArrayAttribFormatOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexArrayAttribIFormat, \"glVertexArrayAttribIFormat\", \"glVertexArrayAttribIFormatOES\", validContext);\n    osg::setGLExtensionFuncPtr(glVertexArrayAttribLFormat, \"glVertexArrayAttribLFormat\", \"glVertexArrayAttribLFormatOES\", validContext);\n\n    // MultiDrawArrays\n    setGLExtensionFuncPtr(glMultiDrawArrays, \"glMultiDrawArrays\", \"glMultiDrawArraysEXT\", validContext);\n    setGLExtensionFuncPtr(glMultiDrawElements, \"glMultiDrawElements\", \"glMultiDrawElementsEXT\");\n    setGLExtensionFuncPtr(glDrawArraysInstancedBaseInstance, \"glDrawArraysInstancedBaseInstance\", \"glDrawArraysInstancedBaseInstanceEXT\");\n    setGLExtensionFuncPtr(glDrawElementsInstancedBaseInstance, \"glDrawElementsInstancedBaseInstance\", \"glDrawElementsInstancedBaseInstanceEXT\");\n    setGLExtensionFuncPtr(glDrawElementsInstancedBaseVertexBaseInstance, \"glDrawElementsInstancedBaseVertexBaseInstance\", \"glDrawElementsInstancedBaseVertexBaseInstanceEXT\");\n\n    setGLExtensionFuncPtr(glDrawRangeElements, \"glDrawRangeElements\");\n    setGLExtensionFuncPtr(glDrawElementsBaseVertex, \"glDrawElementsBaseVertex\", \"glDrawElementsBaseVertexEXT\");\n    setGLExtensionFuncPtr(glDrawRangeElementsBaseVertex, \"glDrawRangeElementsBaseVertex\", \"glDrawRangeElementsBaseVertexEXT\");\n    setGLExtensionFuncPtr(glDrawElementsInstancedBaseVertex, \"glDrawElementsInstancedBaseVertex\", \"glDrawElementsInstancedBaseVertexEXT\");\n    setGLExtensionFuncPtr(glMultiDrawElementsBaseVertex, \"glMultiDrawElementsBaseVertex\", \"glMultiDrawElementsBaseVertexEXT\");\n    setGLExtensionFuncPtr(glProvokingVertex, \"glProvokingVertex\", \"glProvokingVertexEXT\");\n\n    setGLExtensionFuncPtr(glBeginConditionalRender, \"glBeginConditionalRender\", \"glBeginConditionalRenderEXT\");\n    setGLExtensionFuncPtr(glEndConditionalRender, \"glEndConditionalRender\", \"glEndConditionalRenderEXT\");\n\n    // ViewportArray\n    isViewportArraySupported = validContext && (isGLExtensionOrVersionSupported(contextID, \"GL_ARB_viewport_array\", 4.1f));\n\n    osg::setGLExtensionFuncPtr(glViewportArrayv, \"glViewportArrayv\", validContext);\n    osg::setGLExtensionFuncPtr(glViewportIndexedf, \"glViewportIndexedf\", validContext);\n    osg::setGLExtensionFuncPtr(glViewportIndexedfv, \"glViewportIndexedfv\", validContext);\n    osg::setGLExtensionFuncPtr(glScissorArrayv, \"glScissorArrayv\", validContext);\n    osg::setGLExtensionFuncPtr(glScissorIndexed, \"glScissorIndexed\", validContext);\n    osg::setGLExtensionFuncPtr(glScissorIndexedv, \"glScissorIndexedv\", validContext);\n    osg::setGLExtensionFuncPtr(glDepthRangeArrayv, \"glDepthRangeArrayv\", validContext);\n    osg::setGLExtensionFuncPtr(glDepthRangeIndexed, \"glDepthRangeIndexed\", validContext);\n    osg::setGLExtensionFuncPtr(glDepthRangeIndexedf, \"glDepthRangeIndexedfOES\", \"glDepthRangeIndexedfNV\", validContext);\n    osg::setGLExtensionFuncPtr(glGetFloati_v, \"glGetFloati_v\", validContext);\n    osg::setGLExtensionFuncPtr(glGetDoublei_v, \"glGetDoublei_v\", validContext);\n    osg::setGLExtensionFuncPtr(glGetIntegerIndexedvEXT, \"glGetIntegerIndexedvEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glEnableIndexedEXT, \"glEnableIndexedEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glDisableIndexedEXT, \"glDisableIndexedEXT\", validContext);\n    osg::setGLExtensionFuncPtr(glIsEnabledIndexedEXT, \"glIsEnabledIndexedEXT\", validContext);\n\n    setGLExtensionFuncPtr(glClientActiveTexture,\"glClientActiveTexture\",\"glClientActiveTextureARB\", validContext);\n    setGLExtensionFuncPtr(glActiveTexture, \"glActiveTexture\",\"glActiveTextureARB\", validContext);\n    setGLExtensionFuncPtr(glFogCoordPointer, \"glFogCoordPointer\",\"glFogCoordPointerEXT\", validContext);\n    setGLExtensionFuncPtr(glSecondaryColorPointer, \"glSecondaryColorPointer\",\"glSecondaryColorPointerEXT\", validContext);\n\n    if (validContext)\n    {\n        if (osg::getGLVersionNumber() >= 2.0 || osg::isGLExtensionSupported(contextID, \"GL_ARB_vertex_shader\") || OSG_GLES2_FEATURES || OSG_GLES3_FEATURES || OSG_GL3_FEATURES)\n        {\n            glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,&glMaxTextureUnits);\n            #ifdef OSG_GL_FIXED_FUNCTION_AVAILABLE\n                glGetIntegerv(GL_MAX_TEXTURE_COORDS, &glMaxTextureCoords);\n            #else\n                glMaxTextureCoords = glMaxTextureUnits;\n            #endif\n        }\n        #ifdef GL_MAX_TEXTURE_UNITS\n        else if ( osg::getGLVersionNumber() >= 1.3 ||\n                                    osg::isGLExtensionSupported(contextID,\"GL_ARB_multitexture\") ||\n                                    osg::isGLExtensionSupported(contextID,\"GL_EXT_multitexture\") ||\n                                    OSG_GLES1_FEATURES)\n        {\n            GLint maxTextureUnits = 0;\n            glGetIntegerv(GL_MAX_TEXTURE_UNITS,&maxTextureUnits);\n            glMaxTextureUnits = maxTextureUnits;\n            glMaxTextureCoords = maxTextureUnits;\n        }\n        #endif\n        else\n        {\n            glMaxTextureUnits = 1;\n            glMaxTextureCoords = 1;\n        }\n    }\n    else\n    {\n        glMaxTextureUnits = 0;\n        glMaxTextureCoords = 0;\n    }\n\n    osg::setGLExtensionFuncPtr(glObjectLabel, \"glObjectLabel\", validContext);\n\n}\n\nGLExtensions::~GLExtensions()\n{\n    // Remove s_gl*List\n    s_glExtensionSetList[contextID] = ExtensionSet();\n    s_glRendererList[contextID] = std::string();\n    s_glInitializedList[contextID] = 0;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// C++-friendly convenience methods\n\nGLuint GLExtensions::getCurrentProgram() const\n{\n    if( glVersion >= 2.0f )\n    {\n        // GLSL as GL v2.0 core functionality\n        GLint result = 0;\n        glGetIntegerv( GL_CURRENT_PROGRAM, &result );\n        return static_cast<GLuint>(result);\n    }\n    else if (glGetHandleARB)\n    {\n        // fallback for GLSL as GL v1.5 ARB extension\n#ifndef GL_PROGRAM_OBJECT_ARB\n#define GL_PROGRAM_OBJECT_ARB 0x8B40\n#endif\n        return glGetHandleARB( GL_PROGRAM_OBJECT_ARB );\n    }\n    else\n    {\n        OSG_WARN<<\"Warning GLExtensions::getCurrentProgram not supported\"<<std::endl;;\n        return 0;\n    }\n}\n\n\nbool GLExtensions::getProgramInfoLog( GLuint program, std::string& result ) const\n{\n    GLsizei bufLen = 0;        // length of buffer to allocate\n    GLsizei strLen = 0;        // strlen GL actually wrote to buffer\n\n    glGetProgramiv( program, GL_INFO_LOG_LENGTH, &bufLen );\n    if( bufLen > 1 )\n    {\n        GLchar* infoLog = new GLchar[bufLen];\n        glGetProgramInfoLog( program, bufLen, &strLen, infoLog );\n        if( strLen > 0 ) result = reinterpret_cast<char*>(infoLog);\n        delete [] infoLog;\n    }\n    return (strLen > 0);\n}\n\n\nbool GLExtensions::getShaderInfoLog( GLuint shader, std::string& result ) const\n{\n    GLsizei bufLen = 0;        // length of buffer to allocate\n    GLsizei strLen = 0;        // strlen GL actually wrote to buffer\n\n    glGetShaderiv( shader, GL_INFO_LOG_LENGTH, &bufLen );\n    if( bufLen > 1 )\n    {\n        GLchar* infoLog = new GLchar[bufLen];\n        glGetShaderInfoLog( shader, bufLen, &strLen, infoLog );\n        if( strLen > 0 ) result = reinterpret_cast<char*>(infoLog);\n        delete [] infoLog;\n    }\n    return (strLen > 0);\n}\n\n\nbool GLExtensions::getAttribLocation( const char* attribName, GLuint& location ) const\n{\n    // is there an active GLSL program?\n    GLuint program = getCurrentProgram();\n    if( glIsProgram(program) == GL_FALSE ) return false;\n\n    // has that program been successfully linked?\n    GLint linked = GL_FALSE;\n    glGetProgramiv( program, GL_LINK_STATUS, &linked );\n    if( linked == GL_FALSE ) return false;\n\n    // is there such a named attribute?\n    GLint loc = glGetAttribLocation( program, reinterpret_cast<const GLchar*>(attribName) );\n    if( loc < 0 ) return false;\n\n    location = loc;\n    return true;\n}\n\n\nbool GLExtensions::getFragDataLocation( const char* fragDataName, GLuint& location ) const\n{\n    // is there an active GLSL program?\n    GLuint program = getCurrentProgram();\n    if( glIsProgram(program) == GL_FALSE ) return false;\n\n    // has that program been successfully linked?\n    GLint linked = GL_FALSE;\n    glGetProgramiv( program, GL_LINK_STATUS, &linked );\n    if( linked == GL_FALSE ) return false;\n\n    // check if supported\n    if (glGetFragDataLocation == NULL) return false;\n\n    // is there such a named attribute?\n    GLint loc = glGetFragDataLocation( program, reinterpret_cast<const GLchar*>(fragDataName) );\n    if( loc < 0 ) return false;\n\n    location = loc;\n    return true;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgDB/DynamicLibrary.cpp": "/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield\n *\n * This library is open source and may be redistributed and/or modified under\n * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or\n * (at your option) any later version.  The full license is in LICENSE file\n * included with this distribution, and on the openscenegraph.org website.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * OpenSceneGraph Public License for more details.\n*/\n\n//The dlopen calls were not adding to OS X until 10.3\n#ifdef __APPLE__\n#include <AvailabilityMacros.h>\n#if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n#define APPLE_PRE_10_3\n#endif\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#include <io.h>\n#include <windows.h>\n#include <winbase.h>\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n#include <mach-o/dyld.h>\n#else // all other unix\n#include <unistd.h>\n#ifdef __hpux\n// Although HP-UX has dlopen() it is broken! We therefore need to stick\n// to shl_load()/shl_unload()/shl_findsym()\n#include <dl.h>\n#include <errno.h>\n#else\n#include <dlfcn.h>\n#endif\n#endif\n\n#include <osg/Notify>\n#include <osg/GLExtensions>\n\n#include <osgDB/DynamicLibrary>\n#include <osgDB/FileUtils>\n#include <osgDB/FileNameUtils>\n#include <osgDB/ConvertUTF>\n\nusing namespace osgDB;\n\nDynamicLibrary::DynamicLibrary(const std::string& name, HANDLE handle)\n{\n    _name = name;\n    _handle = handle;\n    OSG_INFO<<\"Opened DynamicLibrary \"<<_name<<std::endl;\n}\n\nDynamicLibrary::~DynamicLibrary()\n{\n    if (_handle)\n    {\n        OSG_INFO<<\"Closing DynamicLibrary \"<<_name<<std::endl;\n#if defined(WIN32) && !defined(__CYGWIN__)\n        FreeLibrary((HMODULE)_handle);\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n        NSUnLinkModule(static_cast<NSModule>(_handle), FALSE);\n#elif defined(__hpux)\n        // fortunately, shl_t is a pointer\n        shl_unload (static_cast<shl_t>(_handle));\n#else // other unix\n        dlclose(_handle);\n#endif\n    }\n}\n\nDynamicLibrary* DynamicLibrary::loadLibrary(const std::string& libraryName)\n{\n\n    HANDLE handle = NULL;\n\n    std::string fullLibraryName = osgDB::findLibraryFile(libraryName);\n    if (!fullLibraryName.empty()) handle = getLibraryHandle( fullLibraryName ); // try the lib we have found\n    else handle = getLibraryHandle( libraryName ); // haven't found a lib ourselves, see if the OS can find it simply from the library name.\n\n    if (handle) return new DynamicLibrary(libraryName,handle);\n\n    // else no lib found so report errors.\n    OSG_INFO << \"DynamicLibrary::failed loading \\\"\"<<libraryName<<\"\\\"\"<<std::endl;\n\n    return NULL;\n}\n\nDynamicLibrary::HANDLE DynamicLibrary::getLibraryHandle( const std::string& libraryName)\n{\n    HANDLE handle = NULL;\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#ifdef OSG_USE_UTF8_FILENAME\n    handle = LoadLibraryW(  convertUTF8toUTF16(libraryName).c_str() );\n#else\n    handle = LoadLibrary( libraryName.c_str() );\n#endif\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    NSObjectFileImage image;\n    // NSModule os_handle = NULL;\n    if (NSCreateObjectFileImageFromFile(libraryName.c_str(), &image) == NSObjectFileImageSuccess) {\n        // os_handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        handle = NSLinkModule(image, libraryName.c_str(), TRUE);\n        NSDestroyObjectFileImage(image);\n    }\n#elif defined(__hpux)\n    // BIND_FIRST is necessary for some reason\n    handle = shl_load ( libraryName.c_str(), BIND_DEFERRED|BIND_FIRST|BIND_VERBOSE, 0);\n    return handle;\n#else // other unix\n\n#if defined(__ANDROID__)\n    // Library can be found in APK/lib/armeabi-v7a etc.\n    // Should not be prefaced with './'\n    std::string localLibraryName = libraryName;\n#else\n    // dlopen will not work with files in the current directory unless\n    // they are prefaced with './'  (DB - Nov 5, 2003).\n    std::string localLibraryName;\n    if( libraryName == osgDB::getSimpleFileName( libraryName ) )\n        localLibraryName = \"./\" + libraryName;\n    else\n        localLibraryName = libraryName;\n#endif\n\n    handle = dlopen( localLibraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if( handle == NULL )\n    {\n        if (fileExists(localLibraryName))\n        {\n            OSG_WARN << \"Warning: dynamic library '\" << libraryName << \"' exists, but an error occurred while trying to open it:\" << std::endl;\n            OSG_WARN << dlerror() << std::endl;\n        }\n        else\n        {\n            OSG_INFO << \"Warning: dynamic library '\" << libraryName << \"' does not exist (or isn't readable):\" << std::endl;\n            OSG_INFO << dlerror() << std::endl;\n        }\n    }\n#endif\n    return handle;\n}\n\nDynamicLibrary::PROC_ADDRESS DynamicLibrary::getProcAddress(const std::string& procName)\n{\n    if (_handle==NULL) return NULL;\n#if defined(WIN32) && !defined(__CYGWIN__)\n    return osg::convertPointerType<DynamicLibrary::PROC_ADDRESS, FARPROC>( GetProcAddress( (HMODULE)_handle, procName.c_str() ) );\n#elif defined(__APPLE__) && defined(APPLE_PRE_10_3)\n    std::string temp(\"_\");\n    NSSymbol symbol;\n    temp += procName;   // Mac OS X prepends an underscore on function names\n    symbol = NSLookupSymbolInModule(static_cast<NSModule>(_handle), temp.c_str());\n    return NSAddressOfSymbol(symbol);\n#elif defined(__hpux)\n    void* result = NULL;\n    if (shl_findsym (reinterpret_cast<shl_t*>(&_handle), procName.c_str(), TYPE_PROCEDURE, result) == 0)\n    {\n        return result;\n    }\n    else\n    {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << strerror(errno) << std::endl;\n        return NULL;\n    }\n#else // other unix\n    void* sym = dlsym( _handle,  procName.c_str() );\n    if (!sym) {\n        OSG_WARN << \"DynamicLibrary::failed looking up \" << procName << std::endl;\n        OSG_WARN << \"DynamicLibrary::error \" << dlerror() << std::endl;\n    }\n    return sym;\n#endif\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/AUTHORS.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/applications/osgversion/Contributors.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/bsp/Q3BSPReader.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/LightPointRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/RoadRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/DataInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/DataInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/AttrData.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/ReservedRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Vertex.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/ControlRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Registry.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/VertexRecords.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Record.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/AttrData.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Pools.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Vertex.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Opcodes.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Pools.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/Registry.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/OpenFlight/RecordInputStream.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/txp/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lua/lua-5.2.3/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lua/lua-5.2.3/doc/osi-certified-72x60.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lwo/old_lw.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lwo/old_lw.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgPlugins/lwo/README_osg.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/src/connectivity_graph.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/src/policy.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/tri_stripper.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/public_types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/heap_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/cache_simulator.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/connectivity_graph.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/policy.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/types.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osgUtil/tristripper/include/detail/graph_array.h",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/src/osg/dxtctool.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgviewerMFC/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDI.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgviewerMFC/res/MFC_OSG_MDIDoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgsimplegl3/osgsimplegl3.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgcatch/osgcatch.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES2/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES2/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES2/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgviewerCocoa/English.lproj/MainMenu.nib/keyedobjects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES1/res/drawable-ldpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES1/res/drawable-mdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/osg.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/examples/osgAndroidExampleGLES1/res/drawable-hdpi/web_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/osg.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg32.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg16-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg16.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg32-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg16-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg48-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg48-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg48.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg16-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg48-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg32-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/PlatformSpecifics/Windows/icons/src/osg32-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-openscenegraph-3.6.4-3oyhanv4rgae5wahonre6rph4s6bz75r/spack-src/CMakeModules/FindOpenVRML.cmake"
    ],
    "total_files": 2874
}