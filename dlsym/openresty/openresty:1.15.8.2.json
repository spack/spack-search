{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/LuaJIT-2.1-20190507/src/lib_package.c": "/*\n** Package library.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n**\n** Major portions taken verbatim or adapted from the Lua interpreter.\n** Copyright (C) 1994-2012 Lua.org, PUC-Rio. See Copyright Notice in lua.h\n*/\n\n#define lib_package_c\n#define LUA_LIB\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n#include \"lj_obj.h\"\n#include \"lj_err.h\"\n#include \"lj_lib.h\"\n\n/* ------------------------------------------------------------------------ */\n\n/* Error codes for ll_loadfunc. */\n#define PACKAGE_ERR_LIB\t\t1\n#define PACKAGE_ERR_FUNC\t2\n#define PACKAGE_ERR_LOAD\t3\n\n/* Redefined in platform specific part. */\n#define PACKAGE_LIB_FAIL\t\"open\"\n#define setprogdir(L)\t\t((void)0)\n\n/* Symbol name prefixes. */\n#define SYMPREFIX_CF\t\t\"luaopen_%s\"\n#define SYMPREFIX_BC\t\t\"luaJIT_BC_%s\"\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib(void *lib)\n{\n  dlclose(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  void *lib = dlopen(path, RTLD_NOW | (gl ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n#if defined(RTLD_DEFAULT)\n  if (lib == NULL) lib = RTLD_DEFAULT;\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n  if (lib == NULL) lib = (void *)(intptr_t)-2;\n#endif\n  return (const char *)dlsym(lib, sym);\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS  4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT  2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#if LJ_TARGET_UWP\nvoid *LJ_WIN_LOADLIBA(const char *path)\n{\n  DWORD err = GetLastError();\n  wchar_t wpath[256];\n  HANDLE lib = NULL;\n  if (MultiByteToWideChar(CP_ACP, 0, path, -1, wpath, 256) > 0) {\n    lib = LoadPackagedLibrary(wpath, 0);\n  }\n  SetLastError(err);\n  return lib;\n}\n#endif\n\n#undef setprogdir\n\nstatic void setprogdir(lua_State *L)\n{\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL) {\n    luaL_error(L, \"unable to get ModuleFileName\");\n  } else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\nstatic void pusherror(lua_State *L)\n{\n  DWORD error = GetLastError();\n#if LJ_TARGET_XBOXONE\n  wchar_t wbuffer[128];\n  char buffer[128*2];\n  if (FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, wbuffer, sizeof(wbuffer)/sizeof(wchar_t), NULL) &&\n      WideCharToMultiByte(CP_ACP, 0, wbuffer, 128, buffer, 128*2, NULL, NULL))\n#else\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n#endif\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib(void *lib)\n{\n  FreeLibrary((HINSTANCE)lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  HINSTANCE lib = LJ_WIN_LOADLIBA(path);\n  if (lib == NULL) pusherror(L);\n  UNUSED(gl);\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n#if LJ_TARGET_UWP\nEXTERN_C IMAGE_DOS_HEADER __ImageBase;\n#endif\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  if (lib) {\n    return (const char *)GetProcAddress((HINSTANCE)lib, sym);\n  } else {\n#if LJ_TARGET_UWP\n    return (const char *)GetProcAddress((HINSTANCE)&__ImageBase, sym);\n#else\n    HINSTANCE h = GetModuleHandleA(NULL);\n    const char *p = (const char *)GetProcAddress(h, sym);\n    if (p == NULL && GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t\t\t(const char *)ll_bcsym, &h))\n      p = (const char *)GetProcAddress(h, sym);\n    return p;\n#endif\n  }\n}\n\n#else\n\n#undef PACKAGE_LIB_FAIL\n#define PACKAGE_LIB_FAIL\t\"absent\"\n\n#define DLMSG\t\"dynamic libraries not enabled; no support for target OS\"\n\nstatic void ll_unloadlib(void *lib)\n{\n  UNUSED(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  UNUSED(path); UNUSED(gl);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  return NULL;\n}\n\n#endif\n\n/* ------------------------------------------------------------------------ */\n\nstatic void **ll_register(lua_State *L, const char *path)\n{\n  void **plib;\n  lua_pushfstring(L, \"LOADLIB: %s\", path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1)) {  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  } else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(void *));\n    *plib = NULL;\n    luaL_setmetatable(L, \"_LOADLIB\");\n    lua_pushfstring(L, \"LOADLIB: %s\", path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\nstatic const char *mksymname(lua_State *L, const char *modname,\n\t\t\t     const char *prefix)\n{\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", \"_\");\n  funcname = lua_pushfstring(L, prefix, funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\nstatic int ll_loadfunc(lua_State *L, const char *path, const char *name, int r)\n{\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path, (*name == '*'));\n  if (*reg == NULL) {\n    return PACKAGE_ERR_LIB;  /* Unable to load library. */\n  } else if (*name == '*') {  /* Only load library into global namespace. */\n    lua_pushboolean(L, 1);\n    return 0;\n  } else {\n    const char *sym = r ? name : mksymname(L, name, SYMPREFIX_CF);\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f) {\n      lua_pushcfunction(L, f);\n      return 0;\n    }\n    if (!r) {\n      const char *bcdata = ll_bcsym(*reg, mksymname(L, name, SYMPREFIX_BC));\n      lua_pop(L, 1);\n      if (bcdata) {\n\tif (luaL_loadbuffer(L, bcdata, LJ_MAX_BUF, name) != 0)\n\t  return PACKAGE_ERR_LOAD;\n\treturn 0;\n      }\n    }\n    return PACKAGE_ERR_FUNC;  /* Unable to find function. */\n  }\n}\n\nstatic int lj_cf_package_loadlib(lua_State *L)\n{\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int st = ll_loadfunc(L, path, init, 1);\n  if (st == 0) {  /* no errors? */\n    return 1;  /* return the loaded function */\n  } else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (st == PACKAGE_ERR_LIB) ?  PACKAGE_LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\nstatic int lj_cf_package_unloadlib(lua_State *L)\n{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic int readable(const char *filename)\n{\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\nstatic const char *pushnexttemplate(lua_State *L, const char *path)\n{\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, (size_t)(l - path));  /* template */\n  return l;\n}\n\nstatic const char *searchpath (lua_State *L, const char *name,\n\t\t\t       const char *path, const char *sep,\n\t\t\t       const char *dirsep)\n{\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n\t\t\t\t     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\nstatic int lj_cf_package_searchpath(lua_State *L)\n{\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n\t\t\t\tluaL_checkstring(L, 2),\n\t\t\t\tluaL_optstring(L, 3, \".\"),\n\t\t\t\tluaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) {\n    return 1;\n  } else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\nstatic const char *findfile(lua_State *L, const char *name,\n\t\t\t    const char *pname)\n{\n  const char *path;\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", LUA_DIRSEP);\n}\n\nstatic void loaderror(lua_State *L, const char *filename)\n{\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n\t     lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\nstatic int lj_cf_package_loader_lua(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_c(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (ll_loadfunc(L, filename, name, 0) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_croot(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int st;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, (size_t)(p - name));\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  if ((st = ll_loadfunc(L, filename, name, 0)) != 0) {\n    if (st != PACKAGE_ERR_FUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n\t\t    name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\nstatic int lj_cf_package_loader_preload(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1)) {  /* Not found? */\n    const char *bcname = mksymname(L, name, SYMPREFIX_BC);\n    const char *bcdata = ll_bcsym(NULL, bcname);\n    if (bcdata == NULL || luaL_loadbuffer(L, bcdata, LJ_MAX_BUF, name) != 0)\n      lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  }\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define sentinel\t((void *)0x4004)\n\nstatic int lj_cf_package_require(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n\t\t name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  lj_lib_checkfpu(L);\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic void setfenv(lua_State *L)\n{\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\nstatic void dooptions(lua_State *L, int n)\n{\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\nstatic void modinit(lua_State *L, const char *modname)\n{\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname; else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, (size_t)(dot - modname));\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\nstatic int lj_cf_package_module(lua_State *L)\n{\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = (int)(L->top - L->base);\n  luaL_pushmodule(L, modname, 1);\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1)) {  /* Module already initialized? */\n    lua_pop(L, 1);\n  } else {\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, lastarg);\n  return LJ_52;\n}\n\nstatic int lj_cf_package_seeall(lua_State *L)\n{\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath(lua_State *L, const char *fieldname, const char *envname,\n\t\t    const char *def, int noenv)\n{\n#if LJ_TARGET_CONSOLE\n  const char *path = NULL;\n  UNUSED(envname);\n#else\n  const char *path = getenv(envname);\n#endif\n  if (path == NULL || noenv) {\n    lua_pushstring(L, def);\n  } else {\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n\t\t\t      LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\nstatic const luaL_Reg package_lib[] = {\n  { \"loadlib\",\tlj_cf_package_loadlib },\n  { \"searchpath\",  lj_cf_package_searchpath },\n  { \"seeall\",\tlj_cf_package_seeall },\n  { NULL, NULL }\n};\n\nstatic const luaL_Reg package_global[] = {\n  { \"module\",\tlj_cf_package_module },\n  { \"require\",\tlj_cf_package_require },\n  { NULL, NULL }\n};\n\nstatic const lua_CFunction package_loaders[] =\n{\n  lj_cf_package_loader_preload,\n  lj_cf_package_loader_lua,\n  lj_cf_package_loader_c,\n  lj_cf_package_loader_croot,\n  NULL\n};\n\nLUALIB_API int luaopen_package(lua_State *L)\n{\n  int i;\n  int noenv;\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lj_lib_pushcf(L, lj_cf_package_unloadlib, 1);\n  lua_setfield(L, -2, \"__gc\");\n  luaL_register(L, LUA_LOADLIBNAME, package_lib);\n  lua_copy(L, -1, LUA_ENVIRONINDEX);\n  lua_createtable(L, sizeof(package_loaders)/sizeof(package_loaders[0])-1, 0);\n  for (i = 0; package_loaders[i] != NULL; i++) {\n    lj_lib_pushcf(L, package_loaders[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if LJ_52\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, \"searchers\");\n#endif\n  lua_setfield(L, -2, \"loaders\");\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  noenv = lua_toboolean(L, -1);\n  lua_pop(L, 1);\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT, noenv);\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT, noenv);\n  lua_pushliteral(L, LUA_PATH_CONFIG);\n  lua_setfield(L, -2, \"config\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 16);\n  lua_setfield(L, -2, \"loaded\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\", 4);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, package_global);\n  lua_pop(L, 1);\n  return 1;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/LuaJIT-2.1-20190507/src/lj_clib.c": "/*\n** FFI C library loader.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n*/\n\n#include \"lj_obj.h\"\n\n#if LJ_HASFFI\n\n#include \"lj_gc.h\"\n#include \"lj_err.h\"\n#include \"lj_tab.h\"\n#include \"lj_str.h\"\n#include \"lj_udata.h\"\n#include \"lj_ctype.h\"\n#include \"lj_cconv.h\"\n#include \"lj_cdata.h\"\n#include \"lj_clib.h\"\n#include \"lj_strfmt.h\"\n\n/* -- OS-specific functions ----------------------------------------------- */\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n#include <stdio.h>\n\n#if defined(RTLD_DEFAULT)\n#define CLIB_DEFHANDLE\tRTLD_DEFAULT\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n#define CLIB_DEFHANDLE\t((void *)(intptr_t)-2)\n#else\n#define CLIB_DEFHANDLE\tNULL\n#endif\n\nLJ_NORET LJ_NOINLINE static void clib_error_(lua_State *L)\n{\n  lj_err_callermsg(L, dlerror());\n}\n\n#define clib_error(L, fmt, name)\tclib_error_(L)\n\n#if LJ_TARGET_CYGWIN\n#define CLIB_SOPREFIX\t\"cyg\"\n#else\n#define CLIB_SOPREFIX\t\"lib\"\n#endif\n\n#if LJ_TARGET_OSX\n#define CLIB_SOEXT\t\"%s.dylib\"\n#elif LJ_TARGET_CYGWIN\n#define CLIB_SOEXT\t\"%s.dll\"\n#else\n#define CLIB_SOEXT\t\"%s.so\"\n#endif\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (!strchr(name, '/')\n#if LJ_TARGET_CYGWIN\n      && !strchr(name, '\\\\')\n#endif\n     ) {\n    if (!strchr(name, '.')) {\n      name = lj_strfmt_pushf(L, CLIB_SOEXT, name);\n      L->top--;\n#if LJ_TARGET_CYGWIN\n    } else {\n      return name;\n#endif\n    }\n    if (!(name[0] == CLIB_SOPREFIX[0] && name[1] == CLIB_SOPREFIX[1] &&\n\t  name[2] == CLIB_SOPREFIX[2])) {\n      name = lj_strfmt_pushf(L, CLIB_SOPREFIX \"%s\", name);\n      L->top--;\n    }\n  }\n  return name;\n}\n\n/* Check for a recognized ld script line. */\nstatic const char *clib_check_lds(lua_State *L, const char *buf)\n{\n  char *p, *e;\n  if ((!strncmp(buf, \"GROUP\", 5) || !strncmp(buf, \"INPUT\", 5)) &&\n      (p = strchr(buf, '('))) {\n    while (*++p == ' ') ;\n    for (e = p; *e && *e != ' ' && *e != ')'; e++) ;\n    return strdata(lj_str_new(L, p, e-p));\n  }\n  return NULL;\n}\n\n/* Quick and dirty solution to resolve shared library name from ld script. */\nstatic const char *clib_resolve_lds(lua_State *L, const char *name)\n{\n  FILE *fp = fopen(name, \"r\");\n  const char *p = NULL;\n  if (fp) {\n    char buf[256];\n    if (fgets(buf, sizeof(buf), fp)) {\n      if (!strncmp(buf, \"/* GNU ld script\", 16)) {  /* ld script magic? */\n\twhile (fgets(buf, sizeof(buf), fp)) {  /* Check all lines. */\n\t  p = clib_check_lds(L, buf);\n\t  if (p) break;\n\t}\n      } else {  /* Otherwise check only the first line. */\n\tp = clib_check_lds(L, buf);\n      }\n    }\n    fclose(fp);\n  }\n  return p;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  void *h = dlopen(clib_extname(L, name),\n\t\t   RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n  if (!h) {\n    const char *e, *err = dlerror();\n    if (*err == '/' && (e = strchr(err, ':')) &&\n\t(name = clib_resolve_lds(L, strdata(lj_str_new(L, err, e-err))))) {\n      h = dlopen(name, RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n      if (h) return h;\n      err = dlerror();\n    }\n    lj_err_callermsg(L, err);\n  }\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle && cl->handle != CLIB_DEFHANDLE)\n    dlclose(cl->handle);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = dlsym(cl->handle, name);\n  return p;\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\t4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT\t2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#define CLIB_DEFHANDLE\t((void *)-1)\n\n/* Default libraries. */\nenum {\n  CLIB_HANDLE_EXE,\n#if !LJ_TARGET_UWP\n  CLIB_HANDLE_DLL,\n  CLIB_HANDLE_CRT,\n  CLIB_HANDLE_KERNEL32,\n  CLIB_HANDLE_USER32,\n  CLIB_HANDLE_GDI32,\n#endif\n  CLIB_HANDLE_MAX\n};\n\nstatic void *clib_def_handle[CLIB_HANDLE_MAX];\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  DWORD err = GetLastError();\n#if LJ_TARGET_XBOXONE\n  wchar_t wbuf[128];\n  char buf[128*2];\n  if (!FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, err, 0, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL) ||\n      !WideCharToMultiByte(CP_ACP, 0, wbuf, 128, buf, 128*2, NULL, NULL))\n#else\n  char buf[128];\n  if (!FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, err, 0, buf, sizeof(buf), NULL))\n#endif\n    buf[0] = '\\0';\n  lj_err_callermsg(L, lj_strfmt_pushf(L, fmt, name, buf));\n}\n\nstatic int clib_needext(const char *s)\n{\n  while (*s) {\n    if (*s == '/' || *s == '\\\\' || *s == '.') return 0;\n    s++;\n  }\n  return 1;\n}\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (clib_needext(name)) {\n    name = lj_strfmt_pushf(L, \"%s.dll\", name);\n    L->top--;\n  }\n  return name;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  DWORD oldwerr = GetLastError();\n  void *h = LJ_WIN_LOADLIBA(clib_extname(L, name));\n  if (!h) clib_error(L, \"cannot load module \" LUA_QS \": %s\", name);\n  SetLastError(oldwerr);\n  UNUSED(global);\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle == CLIB_DEFHANDLE) {\n#if !LJ_TARGET_UWP\n    MSize i;\n    for (i = CLIB_HANDLE_KERNEL32; i < CLIB_HANDLE_MAX; i++) {\n      void *h = clib_def_handle[i];\n      if (h) {\n\tclib_def_handle[i] = NULL;\n\tFreeLibrary((HINSTANCE)h);\n      }\n    }\n#endif\n  } else if (cl->handle) {\n    FreeLibrary((HINSTANCE)cl->handle);\n  }\n}\n\n#if LJ_TARGET_UWP\nEXTERN_C IMAGE_DOS_HEADER __ImageBase;\n#endif\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = NULL;\n  if (cl->handle == CLIB_DEFHANDLE) {  /* Search default libraries. */\n    MSize i;\n    for (i = 0; i < CLIB_HANDLE_MAX; i++) {\n      HINSTANCE h = (HINSTANCE)clib_def_handle[i];\n      if (!(void *)h) {  /* Resolve default library handles (once). */\n#if LJ_TARGET_UWP\n\th = (HINSTANCE)&__ImageBase;\n#else\n\tswitch (i) {\n\tcase CLIB_HANDLE_EXE: GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, NULL, &h); break;\n\tcase CLIB_HANDLE_DLL:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)clib_def_handle, &h);\n\t  break;\n\tcase CLIB_HANDLE_CRT:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)&_fmode, &h);\n\t  break;\n\tcase CLIB_HANDLE_KERNEL32: h = LJ_WIN_LOADLIBA(\"kernel32.dll\"); break;\n\tcase CLIB_HANDLE_USER32: h = LJ_WIN_LOADLIBA(\"user32.dll\"); break;\n\tcase CLIB_HANDLE_GDI32: h = LJ_WIN_LOADLIBA(\"gdi32.dll\"); break;\n\t}\n\tif (!h) continue;\n#endif\n\tclib_def_handle[i] = (void *)h;\n      }\n      p = (void *)GetProcAddress(h, name);\n      if (p) break;\n    }\n  } else {\n    p = (void *)GetProcAddress((HINSTANCE)cl->handle, name);\n  }\n  return p;\n}\n\n#else\n\n#define CLIB_DEFHANDLE\tNULL\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  lj_err_callermsg(L, lj_strfmt_pushf(L, fmt, name, \"no support for this OS\"));\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  lj_err_callermsg(L, \"no support for loading dynamic libraries for this OS\");\n  UNUSED(name); UNUSED(global);\n  return NULL;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  UNUSED(cl);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  UNUSED(cl); UNUSED(name);\n  return NULL;\n}\n\n#endif\n\n/* -- C library indexing -------------------------------------------------- */\n\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n/* Compute argument size for fastcall/stdcall functions. */\nstatic CTSize clib_func_argsize(CTState *cts, CType *ct)\n{\n  CTSize n = 0;\n  while (ct->sib) {\n    CType *d;\n    ct = ctype_get(cts, ct->sib);\n    if (ctype_isfield(ct->info)) {\n      d = ctype_rawchild(cts, ct);\n      n += ((d->size + 3) & ~3);\n    }\n  }\n  return n;\n}\n#endif\n\n/* Get redirected or mangled external symbol. */\nstatic const char *clib_extsym(CTState *cts, CType *ct, GCstr *name)\n{\n  if (ct->sib) {\n    CType *ctf = ctype_get(cts, ct->sib);\n    if (ctype_isxattrib(ctf->info, CTA_REDIR))\n      return strdata(gco2str(gcref(ctf->name)));\n  }\n  return strdata(name);\n}\n\n/* Index a C library by name. */\nTValue *lj_clib_index(lua_State *L, CLibrary *cl, GCstr *name)\n{\n  TValue *tv = lj_tab_setstr(L, cl->cache, name);\n  if (LJ_UNLIKELY(tvisnil(tv))) {\n    CTState *cts = ctype_cts(L);\n    CType *ct;\n    CTypeID id = lj_ctype_getname(cts, &ct, name, CLNS_INDEX);\n    if (!id)\n      lj_err_callerv(L, LJ_ERR_FFI_NODECL, strdata(name));\n    if (ctype_isconstval(ct->info)) {\n      CType *ctt = ctype_child(cts, ct);\n      lua_assert(ctype_isinteger(ctt->info) && ctt->size <= 4);\n      if ((ctt->info & CTF_UNSIGNED) && (int32_t)ct->size < 0)\n\tsetnumV(tv, (lua_Number)(uint32_t)ct->size);\n      else\n\tsetintV(tv, (int32_t)ct->size);\n    } else {\n      const char *sym = clib_extsym(cts, ct, name);\n#if LJ_TARGET_WINDOWS\n      DWORD oldwerr = GetLastError();\n#endif\n      void *p = clib_getsym(cl, sym);\n      GCcdata *cd;\n      lua_assert(ctype_isfunc(ct->info) || ctype_isextern(ct->info));\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n      /* Retry with decorated name for fastcall/stdcall functions. */\n      if (!p && ctype_isfunc(ct->info)) {\n\tCTInfo cconv = ctype_cconv(ct->info);\n\tif (cconv == CTCC_FASTCALL || cconv == CTCC_STDCALL) {\n\t  CTSize sz = clib_func_argsize(cts, ct);\n\t  const char *symd = lj_strfmt_pushf(L,\n\t\t\t       cconv == CTCC_FASTCALL ? \"@%s@%d\" : \"_%s@%d\",\n\t\t\t       sym, sz);\n\t  L->top--;\n\t  p = clib_getsym(cl, symd);\n\t}\n      }\n#endif\n      if (!p)\n\tclib_error(L, \"cannot resolve symbol \" LUA_QS \": %s\", sym);\n#if LJ_TARGET_WINDOWS\n      SetLastError(oldwerr);\n#endif\n      cd = lj_cdata_new(cts, id, CTSIZE_PTR);\n      *(void **)cdataptr(cd) = p;\n      setcdataV(L, tv, cd);\n      lj_gc_anybarriert(L, cl->cache);\n    }\n  }\n  return tv;\n}\n\n/* -- C library management ------------------------------------------------ */\n\n/* Create a new CLibrary object and push it on the stack. */\nstatic CLibrary *clib_new(lua_State *L, GCtab *mt)\n{\n  GCtab *t = lj_tab_new(L, 0, 0);\n  GCudata *ud = lj_udata_new(L, sizeof(CLibrary), t);\n  CLibrary *cl = (CLibrary *)uddata(ud);\n  cl->cache = t;\n  ud->udtype = UDTYPE_FFI_CLIB;\n  /* NOBARRIER: The GCudata is new (marked white). */\n  setgcref(ud->metatable, obj2gco(mt));\n  setudataV(L, L->top++, ud);\n  return cl;\n}\n\n/* Load a C library. */\nvoid lj_clib_load(lua_State *L, GCtab *mt, GCstr *name, int global)\n{\n  void *handle = clib_loadlib(L, strdata(name), global);\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = handle;\n}\n\n/* Unload a C library. */\nvoid lj_clib_unload(CLibrary *cl)\n{\n  clib_unloadlib(cl);\n  cl->handle = NULL;\n}\n\n/* Create the default C library object. */\nvoid lj_clib_default(lua_State *L, GCtab *mt)\n{\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = CLIB_DEFHANDLE;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/src/core/nginx.c": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n\n\nstatic void ngx_show_version_info(void);\nstatic ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);\nstatic void ngx_cleanup_environment(void *data);\nstatic ngx_int_t ngx_get_options(int argc, char *const *argv);\nstatic ngx_int_t ngx_process_options(ngx_cycle_t *cycle);\nstatic ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);\nstatic void *ngx_core_module_create_conf(ngx_cycle_t *cycle);\nstatic char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);\nstatic char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n#if (NGX_HAVE_DLOPEN)\nstatic void ngx_unload_module(void *data);\n#endif\n\n\nstatic ngx_conf_enum_t  ngx_debug_points[] = {\n    { ngx_string(\"stop\"), NGX_DEBUG_POINTS_STOP },\n    { ngx_string(\"abort\"), NGX_DEBUG_POINTS_ABORT },\n    { ngx_null_string, 0 }\n};\n\n\nstatic ngx_command_t  ngx_core_commands[] = {\n\n    { ngx_string(\"daemon\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, daemon),\n      NULL },\n\n    { ngx_string(\"master_process\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, master),\n      NULL },\n\n    { ngx_string(\"timer_resolution\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, timer_resolution),\n      NULL },\n\n    { ngx_string(\"pid\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, pid),\n      NULL },\n\n    { ngx_string(\"lock_file\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, lock_file),\n      NULL },\n\n    { ngx_string(\"worker_processes\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_worker_processes,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"debug_points\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_enum_slot,\n      0,\n      offsetof(ngx_core_conf_t, debug_points),\n      &ngx_debug_points },\n\n    { ngx_string(\"user\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE12,\n      ngx_set_user,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_priority\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_priority,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_cpu_affinity\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,\n      ngx_set_cpu_affinity,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_rlimit_nofile\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_nofile),\n      NULL },\n\n    { ngx_string(\"worker_rlimit_core\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_off_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_core),\n      NULL },\n\n    { ngx_string(\"worker_shutdown_timeout\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, shutdown_timeout),\n      NULL },\n\n    { ngx_string(\"working_directory\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, working_directory),\n      NULL },\n\n    { ngx_string(\"env\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_env,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"load_module\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_load_module,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_core_module_ctx = {\n    ngx_string(\"core\"),\n    ngx_core_module_create_conf,\n    ngx_core_module_init_conf\n};\n\n\nngx_module_t  ngx_core_module = {\n    NGX_MODULE_V1,\n    &ngx_core_module_ctx,                  /* module context */\n    ngx_core_commands,                     /* module directives */\n    NGX_CORE_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_uint_t   ngx_show_help;\nstatic ngx_uint_t   ngx_show_version;\nstatic ngx_uint_t   ngx_show_configure;\nstatic u_char      *ngx_prefix;\nstatic u_char      *ngx_conf_file;\nstatic u_char      *ngx_conf_params;\nstatic char        *ngx_signal;\n\n\nstatic char **ngx_os_environ;\n\n\nint ngx_cdecl\nmain(int argc, char *const *argv)\n{\n    ngx_buf_t        *b;\n    ngx_log_t        *log;\n    ngx_uint_t        i;\n    ngx_cycle_t      *cycle, init_cycle;\n    ngx_conf_dump_t  *cd;\n    ngx_core_conf_t  *ccf;\n\n    ngx_debug_init();\n\n    if (ngx_strerror_init() != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_get_options(argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_show_version) {\n        ngx_show_version_info();\n\n        if (!ngx_test_config) {\n            return 0;\n        }\n    }\n\n    /* TODO */ ngx_max_sockets = -1;\n\n    ngx_time_init();\n\n#if (NGX_PCRE)\n    ngx_regex_init();\n#endif\n\n    ngx_pid = ngx_getpid();\n    ngx_parent = ngx_getppid();\n\n    log = ngx_log_init(ngx_prefix);\n    if (log == NULL) {\n        return 1;\n    }\n\n    /* STUB */\n#if (NGX_OPENSSL)\n    ngx_ssl_init(log);\n#endif\n\n    /*\n     * init_cycle->log is required for signal handlers and\n     * ngx_process_options()\n     */\n\n    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));\n    init_cycle.log = log;\n    ngx_cycle = &init_cycle;\n\n    init_cycle.pool = ngx_create_pool(1024, log);\n    if (init_cycle.pool == NULL) {\n        return 1;\n    }\n\n    if (ngx_save_argv(&init_cycle, argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_process_options(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_os_init(log) != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()\n     */\n\n    if (ngx_crc32_table_init() != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_slab_sizes_init() requires ngx_pagesize set in ngx_os_init()\n     */\n\n    ngx_slab_sizes_init();\n\n    if (ngx_add_inherited_sockets(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_preinit_modules() != NGX_OK) {\n        return 1;\n    }\n\n    cycle = ngx_init_cycle(&init_cycle);\n    if (cycle == NULL) {\n        if (ngx_test_config) {\n            ngx_log_stderr(0, \"configuration file %s test failed\",\n                           init_cycle.conf_file.data);\n        }\n\n        return 1;\n    }\n\n    if (ngx_test_config) {\n        if (!ngx_quiet_mode) {\n            ngx_log_stderr(0, \"configuration file %s test is successful\",\n                           cycle->conf_file.data);\n        }\n\n        if (ngx_dump_config) {\n            cd = cycle->config_dump.elts;\n\n            for (i = 0; i < cycle->config_dump.nelts; i++) {\n\n                ngx_write_stdout(\"# configuration file \");\n                (void) ngx_write_fd(ngx_stdout, cd[i].name.data,\n                                    cd[i].name.len);\n                ngx_write_stdout(\":\" NGX_LINEFEED);\n\n                b = cd[i].buffer;\n\n                (void) ngx_write_fd(ngx_stdout, b->pos, b->last - b->pos);\n                ngx_write_stdout(NGX_LINEFEED);\n            }\n        }\n\n        return 0;\n    }\n\n    if (ngx_signal) {\n        return ngx_signal_process(cycle, ngx_signal);\n    }\n\n    ngx_os_status(cycle->log);\n\n    ngx_cycle = cycle;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_process = NGX_PROCESS_MASTER;\n    }\n\n#if !(NGX_WIN32)\n\n    if (ngx_init_signals(cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (!ngx_inherited && ccf->daemon) {\n        if (ngx_daemon(cycle->log) != NGX_OK) {\n            return 1;\n        }\n\n        ngx_daemonized = 1;\n    }\n\n    if (ngx_inherited) {\n        ngx_daemonized = 1;\n    }\n\n#endif\n\n    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (log->file->fd != ngx_stderr) {\n        if (ngx_close_file(log->file->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_close_file_n \" built-in log failed\");\n        }\n    }\n\n    ngx_use_stderr = 0;\n\n    if (ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_single_process_cycle(cycle);\n\n    } else {\n        ngx_master_process_cycle(cycle);\n    }\n\n    return 0;\n}\n\n\nstatic void\nngx_show_version_info(void)\n{\n    ngx_write_stderr(\"nginx version: \" NGINX_VER_BUILD NGX_LINEFEED);\n\n    if (ngx_show_help) {\n        ngx_write_stderr(\n            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n                         NGX_LINEFEED\n            \"Options:\" NGX_LINEFEED\n            \"  -?,-h         : this help\" NGX_LINEFEED\n            \"  -v            : show version and exit\" NGX_LINEFEED\n            \"  -V            : show version and configure options then exit\"\n                               NGX_LINEFEED\n            \"  -t            : test configuration and exit\" NGX_LINEFEED\n            \"  -T            : test configuration, dump it and exit\"\n                               NGX_LINEFEED\n            \"  -q            : suppress non-error messages \"\n                               \"during configuration testing\" NGX_LINEFEED\n            \"  -s signal     : send signal to a master process: \"\n                               \"stop, quit, reopen, reload\" NGX_LINEFEED\n#ifdef NGX_PREFIX\n            \"  -p prefix     : set prefix path (default: \" NGX_PREFIX \")\"\n                               NGX_LINEFEED\n#else\n            \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n#endif\n            \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n                               \")\" NGX_LINEFEED\n            \"  -g directives : set global directives out of configuration \"\n                               \"file\" NGX_LINEFEED NGX_LINEFEED\n        );\n    }\n\n    if (ngx_show_configure) {\n\n#ifdef NGX_COMPILER\n        ngx_write_stderr(\"built by \" NGX_COMPILER NGX_LINEFEED);\n#endif\n\n#if (NGX_SSL)\n        if (ngx_strcmp(ngx_ssl_version(), OPENSSL_VERSION_TEXT) == 0) {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT NGX_LINEFEED);\n        } else {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT\n                             \" (running with \");\n            ngx_write_stderr((char *) (uintptr_t) ngx_ssl_version());\n            ngx_write_stderr(\")\" NGX_LINEFEED);\n        }\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n        ngx_write_stderr(\"TLS SNI support enabled\" NGX_LINEFEED);\n#else\n        ngx_write_stderr(\"TLS SNI support disabled\" NGX_LINEFEED);\n#endif\n#endif\n\n        ngx_write_stderr(\"configure arguments:\" NGX_CONFIGURE NGX_LINEFEED);\n    }\n}\n\n\nstatic ngx_int_t\nngx_add_inherited_sockets(ngx_cycle_t *cycle)\n{\n    u_char           *p, *v, *inherited;\n    ngx_int_t         s;\n    ngx_listening_t  *ls;\n\n    inherited = (u_char *) getenv(NGINX_VAR);\n\n    if (inherited == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,\n                  \"using inherited sockets from \\\"%s\\\"\", inherited);\n\n    if (ngx_array_init(&cycle->listening, cycle->pool, 10,\n                       sizeof(ngx_listening_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for (p = inherited, v = p; *p; p++) {\n        if (*p == ':' || *p == ';') {\n            s = ngx_atoi(v, p - v);\n            if (s == NGX_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                              \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                              \" environment variable, ignoring the rest\"\n                              \" of the variable\", v);\n                break;\n            }\n\n            v = p + 1;\n\n            ls = ngx_array_push(&cycle->listening);\n            if (ls == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memzero(ls, sizeof(ngx_listening_t));\n\n            ls->fd = (ngx_socket_t) s;\n        }\n    }\n\n    if (v != p) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                      \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                      \" environment variable, ignoring\", v);\n    }\n\n    ngx_inherited = 1;\n\n    return ngx_set_inherited_sockets(cycle);\n}\n\n\nchar **\nngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)\n{\n    char                **p, **env;\n    ngx_str_t            *var;\n    ngx_uint_t            i, n;\n    ngx_core_conf_t      *ccf;\n    ngx_pool_cleanup_t   *cln;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (last == NULL && ccf->environment) {\n        return ccf->environment;\n    }\n\n    var = ccf->env.elts;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n        if (ngx_strcmp(var[i].data, \"TZ\") == 0\n            || ngx_strncmp(var[i].data, \"TZ=\", 3) == 0)\n        {\n            goto tz_found;\n        }\n    }\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NULL;\n    }\n\n    var->len = 2;\n    var->data = (u_char *) \"TZ\";\n\n    var = ccf->env.elts;\n\ntz_found:\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            n++;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                n++;\n                break;\n            }\n        }\n    }\n\n    if (last) {\n        env = ngx_alloc((*last + n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        *last = n;\n\n    } else {\n        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n        if (cln == NULL) {\n            return NULL;\n        }\n\n        env = ngx_alloc((n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        cln->handler = ngx_cleanup_environment;\n        cln->data = env;\n    }\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            env[n++] = (char *) var[i].data;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                env[n++] = *p;\n                break;\n            }\n        }\n    }\n\n    env[n] = NULL;\n\n    if (last == NULL) {\n        ccf->environment = env;\n        environ = env;\n    }\n\n    return env;\n}\n\n\nstatic void\nngx_cleanup_environment(void *data)\n{\n    char  **env = data;\n\n    if (environ == env) {\n\n        /*\n         * if the environment is still used, as it happens on exit,\n         * the only option is to leak it\n         */\n\n        return;\n    }\n\n    ngx_free(env);\n}\n\n\nngx_pid_t\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\n{\n    char             **env, *var;\n    u_char            *p;\n    ngx_uint_t         i, n;\n    ngx_pid_t          pid;\n    ngx_exec_ctx_t     ctx;\n    ngx_core_conf_t   *ccf;\n    ngx_listening_t   *ls;\n\n    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));\n\n    ctx.path = argv[0];\n    ctx.name = \"new binary process\";\n    ctx.argv = argv;\n\n    n = 2;\n    env = ngx_set_environment(cycle, &n);\n    if (env == NULL) {\n        return NGX_INVALID_PID;\n    }\n\n    var = ngx_alloc(sizeof(NGINX_VAR)\n                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,\n                    cycle->log);\n    if (var == NULL) {\n        ngx_free(env);\n        return NGX_INVALID_PID;\n    }\n\n    p = ngx_cpymem(var, NGINX_VAR \"=\", sizeof(NGINX_VAR));\n\n    ls = cycle->listening.elts;\n    for (i = 0; i < cycle->listening.nelts; i++) {\n        p = ngx_sprintf(p, \"%ud;\", ls[i].fd);\n    }\n\n    *p = '\\0';\n\n    env[n++] = var;\n\n#if (NGX_SETPROCTITLE_USES_ENV)\n\n    /* allocate the spare 300 bytes for the new binary process title */\n\n    env[n++] = \"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n\n#endif\n\n    env[n] = NULL;\n\n#if (NGX_DEBUG)\n    {\n    char  **e;\n    for (e = env; *e; e++) {\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"env: %s\", *e);\n    }\n    }\n#endif\n\n    ctx.envp = (char *const *) env;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      ngx_rename_file_n \" %s to %s failed \"\n                      \"before executing new binary process \\\"%s\\\"\",\n                      ccf->pid.data, ccf->oldpid.data, argv[0]);\n\n        ngx_free(env);\n        ngx_free(var);\n\n        return NGX_INVALID_PID;\n    }\n\n    pid = ngx_execute(cycle, &ctx);\n\n    if (pid == NGX_INVALID_PID) {\n        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data)\n            == NGX_FILE_ERROR)\n        {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_rename_file_n \" %s back to %s failed after \"\n                          \"an attempt to execute new binary process \\\"%s\\\"\",\n                          ccf->oldpid.data, ccf->pid.data, argv[0]);\n        }\n    }\n\n    ngx_free(env);\n    ngx_free(var);\n\n    return pid;\n}\n\n\nstatic ngx_int_t\nngx_get_options(int argc, char *const *argv)\n{\n    u_char     *p;\n    ngx_int_t   i;\n\n    for (i = 1; i < argc; i++) {\n\n        p = (u_char *) argv[i];\n\n        if (*p++ != '-') {\n            ngx_log_stderr(0, \"invalid option: \\\"%s\\\"\", argv[i]);\n            return NGX_ERROR;\n        }\n\n        while (*p) {\n\n            switch (*p++) {\n\n            case '?':\n            case 'h':\n                ngx_show_version = 1;\n                ngx_show_help = 1;\n                break;\n\n            case 'v':\n                ngx_show_version = 1;\n                break;\n\n            case 'V':\n                ngx_show_version = 1;\n                ngx_show_configure = 1;\n                break;\n\n            case 't':\n                ngx_test_config = 1;\n                break;\n\n            case 'T':\n                ngx_test_config = 1;\n                ngx_dump_config = 1;\n                break;\n\n            case 'q':\n                ngx_quiet_mode = 1;\n                break;\n\n            case 'p':\n                if (*p) {\n                    ngx_prefix = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_prefix = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n                return NGX_ERROR;\n\n            case 'c':\n                if (*p) {\n                    ngx_conf_file = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_file = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-c\\\" requires file name\");\n                return NGX_ERROR;\n\n            case 'g':\n                if (*p) {\n                    ngx_conf_params = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_params = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-g\\\" requires parameter\");\n                return NGX_ERROR;\n\n            case 's':\n                if (*p) {\n                    ngx_signal = (char *) p;\n\n                } else if (argv[++i]) {\n                    ngx_signal = argv[i];\n\n                } else {\n                    ngx_log_stderr(0, \"option \\\"-s\\\" requires parameter\");\n                    return NGX_ERROR;\n                }\n\n                if (ngx_strcmp(ngx_signal, \"stop\") == 0\n                    || ngx_strcmp(ngx_signal, \"quit\") == 0\n                    || ngx_strcmp(ngx_signal, \"reopen\") == 0\n                    || ngx_strcmp(ngx_signal, \"reload\") == 0)\n                {\n                    ngx_process = NGX_PROCESS_SIGNALLER;\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"invalid option: \\\"-s %s\\\"\", ngx_signal);\n                return NGX_ERROR;\n\n            default:\n                ngx_log_stderr(0, \"invalid option: \\\"%c\\\"\", *(p - 1));\n                return NGX_ERROR;\n            }\n        }\n\n    next:\n\n        continue;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)\n{\n#if (NGX_FREEBSD)\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n    ngx_argv = (char **) argv;\n\n#else\n    size_t     len;\n    ngx_int_t  i;\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n\n    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);\n    if (ngx_argv == NULL) {\n        return NGX_ERROR;\n    }\n\n    for (i = 0; i < argc; i++) {\n        len = ngx_strlen(argv[i]) + 1;\n\n        ngx_argv[i] = ngx_alloc(len, cycle->log);\n        if (ngx_argv[i] == NULL) {\n            return NGX_ERROR;\n        }\n\n        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);\n    }\n\n    ngx_argv[i] = NULL;\n\n#endif\n\n    ngx_os_environ = environ;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_process_options(ngx_cycle_t *cycle)\n{\n    u_char  *p;\n    size_t   len;\n\n    if (ngx_prefix) {\n        len = ngx_strlen(ngx_prefix);\n        p = ngx_prefix;\n\n        if (len && !ngx_path_separator(p[len - 1])) {\n            p = ngx_pnalloc(cycle->pool, len + 1);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(p, ngx_prefix, len);\n            p[len++] = '/';\n        }\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n    } else {\n\n#ifndef NGX_PREFIX\n\n        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {\n            ngx_log_stderr(ngx_errno, \"[emerg]: \" ngx_getcwd_n \" failed\");\n            return NGX_ERROR;\n        }\n\n        len = ngx_strlen(p);\n\n        p[len++] = '/';\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n#else\n\n#ifdef NGX_CONF_PREFIX\n        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);\n#else\n        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);\n#endif\n        ngx_str_set(&cycle->prefix, NGX_PREFIX);\n\n#endif\n    }\n\n    if (ngx_conf_file) {\n        cycle->conf_file.len = ngx_strlen(ngx_conf_file);\n        cycle->conf_file.data = ngx_conf_file;\n\n    } else {\n        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &cycle->conf_file, 0) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;\n         p > cycle->conf_file.data;\n         p--)\n    {\n        if (ngx_path_separator(*p)) {\n            cycle->conf_prefix.len = p - cycle->conf_file.data + 1;\n            cycle->conf_prefix.data = cycle->conf_file.data;\n            break;\n        }\n    }\n\n    if (ngx_conf_params) {\n        cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n        cycle->conf_param.data = ngx_conf_params;\n    }\n\n    if (ngx_test_config) {\n        cycle->log->log_level = NGX_LOG_INFO;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_core_module_create_conf(ngx_cycle_t *cycle)\n{\n    ngx_core_conf_t  *ccf;\n\n    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));\n    if (ccf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc()\n     *\n     *     ccf->pid = NULL;\n     *     ccf->oldpid = NULL;\n     *     ccf->priority = 0;\n     *     ccf->cpu_affinity_auto = 0;\n     *     ccf->cpu_affinity_n = 0;\n     *     ccf->cpu_affinity = NULL;\n     */\n\n    ccf->daemon = NGX_CONF_UNSET;\n    ccf->master = NGX_CONF_UNSET;\n    ccf->privileged_agent = NGX_CONF_UNSET;\n    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;\n    ccf->shutdown_timeout = NGX_CONF_UNSET_MSEC;\n\n    ccf->worker_processes = NGX_CONF_UNSET;\n    ccf->debug_points = NGX_CONF_UNSET;\n\n    ccf->rlimit_nofile = NGX_CONF_UNSET;\n    ccf->rlimit_core = NGX_CONF_UNSET;\n\n    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;\n    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;\n\n    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return ccf;\n}\n\n\nstatic char *\nngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_conf_init_value(ccf->daemon, 1);\n    ngx_conf_init_value(ccf->master, 1);\n    ngx_conf_init_value(ccf->privileged_agent, 0);\n    ngx_conf_init_msec_value(ccf->timer_resolution, 0);\n    ngx_conf_init_msec_value(ccf->shutdown_timeout, 0);\n\n    ngx_conf_init_value(ccf->worker_processes, 1);\n    ngx_conf_init_value(ccf->debug_points, 0);\n\n#if (NGX_HAVE_CPU_AFFINITY)\n\n    if (!ccf->cpu_affinity_auto\n        && ccf->cpu_affinity_n\n        && ccf->cpu_affinity_n != 1\n        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)\n    {\n        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n                      \"the number of \\\"worker_processes\\\" is not equal to \"\n                      \"the number of \\\"worker_cpu_affinity\\\" masks, \"\n                      \"using last mask for remaining worker processes\");\n    }\n\n#endif\n\n\n    if (ccf->pid.len == 0) {\n        ngx_str_set(&ccf->pid, NGX_PID_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->pid, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->oldpid.len = ccf->pid.len + sizeof(NGX_OLDPID_EXT);\n\n    ccf->oldpid.data = ngx_pnalloc(cycle->pool, ccf->oldpid.len);\n    if (ccf->oldpid.data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memcpy(ngx_cpymem(ccf->oldpid.data, ccf->pid.data, ccf->pid.len),\n               NGX_OLDPID_EXT, sizeof(NGX_OLDPID_EXT));\n\n\n#if !(NGX_WIN32)\n\n    if (ccf->user == (uid_t) NGX_CONF_UNSET_UINT && geteuid() == 0) {\n        struct group   *grp;\n        struct passwd  *pwd;\n\n        ngx_set_errno(0);\n        pwd = getpwnam(NGX_USER);\n        if (pwd == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getpwnam(\\\"\" NGX_USER \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->username = NGX_USER;\n        ccf->user = pwd->pw_uid;\n\n        ngx_set_errno(0);\n        grp = getgrnam(NGX_GROUP);\n        if (grp == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getgrnam(\\\"\" NGX_GROUP \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->group = grp->gr_gid;\n    }\n\n\n    if (ccf->lock_file.len == 0) {\n        ngx_str_set(&ccf->lock_file, NGX_LOCK_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->lock_file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    {\n    ngx_str_t  lock_file;\n\n    lock_file = cycle->old_cycle->lock_file;\n\n    if (lock_file.len) {\n        lock_file.len--;\n\n        if (ccf->lock_file.len != lock_file.len\n            || ngx_strncmp(ccf->lock_file.data, lock_file.data, lock_file.len)\n               != 0)\n        {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                          \"\\\"lock_file\\\" could not be changed, ignored\");\n        }\n\n        cycle->lock_file.len = lock_file.len + 1;\n        lock_file.len += sizeof(\".accept\");\n\n        cycle->lock_file.data = ngx_pstrdup(cycle->pool, &lock_file);\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n    } else {\n        cycle->lock_file.len = ccf->lock_file.len + 1;\n        cycle->lock_file.data = ngx_pnalloc(cycle->pool,\n                                      ccf->lock_file.len + sizeof(\".accept\"));\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_memcpy(ngx_cpymem(cycle->lock_file.data, ccf->lock_file.data,\n                              ccf->lock_file.len),\n                   \".accept\", sizeof(\".accept\"));\n    }\n    }\n\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_WIN32)\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"user\\\" is not supported, ignored\");\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_core_conf_t  *ccf = conf;\n\n    char             *group;\n    struct passwd    *pwd;\n    struct group     *grp;\n    ngx_str_t        *value;\n\n    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {\n        return \"is duplicate\";\n    }\n\n    if (geteuid() != 0) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"the \\\"user\\\" directive makes sense only \"\n                           \"if the master process runs \"\n                           \"with super-user privileges, ignored\");\n        return NGX_CONF_OK;\n    }\n\n    value = cf->args->elts;\n\n    ccf->username = (char *) value[1].data;\n\n    ngx_set_errno(0);\n    pwd = getpwnam((const char *) value[1].data);\n    if (pwd == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getpwnam(\\\"%s\\\") failed\", value[1].data);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->user = pwd->pw_uid;\n\n    group = (char *) ((cf->args->nelts == 2) ? value[1].data : value[2].data);\n\n    ngx_set_errno(0);\n    grp = getgrnam(group);\n    if (grp == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getgrnam(\\\"%s\\\") failed\", group);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->group = grp->gr_gid;\n\n    return NGX_CONF_OK;\n\n#endif\n}\n\n\nstatic char *\nngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t   *value, *var;\n    ngx_uint_t   i;\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n    *var = value[1];\n\n    for (i = 0; i < value[1].len; i++) {\n\n        if (value[1].data[i] == '=') {\n\n            var->len = i;\n\n            return NGX_CONF_OK;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t        *value;\n    ngx_uint_t        n, minus;\n\n    if (ccf->priority != 0) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (value[1].data[0] == '-') {\n        n = 1;\n        minus = 1;\n\n    } else if (value[1].data[0] == '+') {\n        n = 1;\n        minus = 0;\n\n    } else {\n        n = 0;\n        minus = 0;\n    }\n\n    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);\n    if (ccf->priority == NGX_ERROR) {\n        return \"invalid number\";\n    }\n\n    if (minus) {\n        ccf->priority = -ccf->priority;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_core_conf_t  *ccf = conf;\n\n    u_char            ch, *p;\n    ngx_str_t        *value;\n    ngx_uint_t        i, n;\n    ngx_cpuset_t     *mask;\n\n    if (ccf->cpu_affinity) {\n        return \"is duplicate\";\n    }\n\n    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));\n    if (mask == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->cpu_affinity_n = cf->args->nelts - 1;\n    ccf->cpu_affinity = mask;\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n\n        if (cf->args->nelts > 3) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid number of arguments in \"\n                               \"\\\"worker_cpu_affinity\\\" directive\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->cpu_affinity_auto = 1;\n\n        CPU_ZERO(&mask[0]);\n        for (i = 0; i < (ngx_uint_t) ngx_min(ngx_ncpu, CPU_SETSIZE); i++) {\n            CPU_SET(i, &mask[0]);\n        }\n\n        n = 2;\n\n    } else {\n        n = 1;\n    }\n\n    for ( /* void */ ; n < cf->args->nelts; n++) {\n\n        if (value[n].len > CPU_SETSIZE) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"\\\"worker_cpu_affinity\\\" supports up to %d CPUs only\",\n                         CPU_SETSIZE);\n            return NGX_CONF_ERROR;\n        }\n\n        i = 0;\n        CPU_ZERO(&mask[n - 1]);\n\n        for (p = value[n].data + value[n].len - 1;\n             p >= value[n].data;\n             p--)\n        {\n            ch = *p;\n\n            if (ch == ' ') {\n                continue;\n            }\n\n            i++;\n\n            if (ch == '0') {\n                continue;\n            }\n\n            if (ch == '1') {\n                CPU_SET(i - 1, &mask[n - 1]);\n                continue;\n            }\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                          \"invalid character \\\"%c\\\" in \\\"worker_cpu_affinity\\\"\",\n                          ch);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"worker_cpu_affinity\\\" is not supported \"\n                       \"on this platform, ignored\");\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nngx_cpuset_t *\nngx_get_cpu_affinity(ngx_uint_t n)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_uint_t        i, j;\n    ngx_cpuset_t     *mask;\n    ngx_core_conf_t  *ccf;\n\n    static ngx_cpuset_t  result;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                           ngx_core_module);\n\n    if (ccf->cpu_affinity == NULL) {\n        return NULL;\n    }\n\n    if (ccf->cpu_affinity_auto) {\n        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n        for (i = 0, j = n; /* void */ ; i++) {\n\n            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {\n                break;\n            }\n\n            if (i == CPU_SETSIZE && j == n) {\n                /* empty mask */\n                return NULL;\n            }\n\n            /* void */\n        }\n\n        CPU_ZERO(&result);\n        CPU_SET(i % CPU_SETSIZE, &result);\n\n        return &result;\n    }\n\n    if (ccf->cpu_affinity_n > n) {\n        return &ccf->cpu_affinity[n];\n    }\n\n    return &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n#else\n\n    return NULL;\n\n#endif\n}\n\n\nstatic char *\nngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_str_t        *value;\n    ngx_core_conf_t  *ccf;\n\n    ccf = (ngx_core_conf_t *) conf;\n\n    if (ccf->worker_processes != NGX_CONF_UNSET) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n        ccf->worker_processes = ngx_ncpu;\n        return NGX_CONF_OK;\n    }\n\n    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);\n\n    if (ccf->worker_processes == NGX_ERROR) {\n        return \"invalid value\";\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_DLOPEN)\n    void                *handle;\n    char               **names, **order;\n    ngx_str_t           *value, file;\n    ngx_uint_t           i;\n    ngx_module_t        *module, **modules;\n    ngx_pool_cleanup_t  *cln;\n\n    if (cf->cycle->modules_used) {\n        return \"is specified too late\";\n    }\n\n    value = cf->args->elts;\n\n    file = value[1];\n\n    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);\n    if (cln == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    handle = ngx_dlopen(file.data);\n    if (handle == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlopen_n \" \\\"%s\\\" failed (%s)\",\n                           file.data, ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    cln->handler = ngx_unload_module;\n    cln->data = handle;\n\n    modules = ngx_dlsym(handle, \"ngx_modules\");\n    if (modules == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_modules\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    names = ngx_dlsym(handle, \"ngx_module_names\");\n    if (names == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_module_names\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    order = ngx_dlsym(handle, \"ngx_module_order\");\n\n    for (i = 0; modules[i]; i++) {\n        module = modules[i];\n        module->name = names[i];\n\n        if (ngx_add_module(cf, &file, module, order) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cf->log, 0, \"module: %s i:%ui\",\n                       module->name, module->index);\n    }\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"\\\"load_module\\\" is not supported \"\n                       \"on this platform\");\n    return NGX_CONF_ERROR;\n\n#endif\n}\n\n\n#if (NGX_HAVE_DLOPEN)\n\nstatic void\nngx_unload_module(void *data)\n{\n    void  *handle = data;\n\n    if (ngx_dlclose(handle) != 0) {\n        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                      ngx_dlclose_n \" failed (%s)\", ngx_dlerror());\n    }\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/src/core/nginx.c.orig": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n\n\nstatic void ngx_show_version_info(void);\nstatic ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);\nstatic void ngx_cleanup_environment(void *data);\nstatic ngx_int_t ngx_get_options(int argc, char *const *argv);\nstatic ngx_int_t ngx_process_options(ngx_cycle_t *cycle);\nstatic ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);\nstatic void *ngx_core_module_create_conf(ngx_cycle_t *cycle);\nstatic char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);\nstatic char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n#if (NGX_HAVE_DLOPEN)\nstatic void ngx_unload_module(void *data);\n#endif\n\n\nstatic ngx_conf_enum_t  ngx_debug_points[] = {\n    { ngx_string(\"stop\"), NGX_DEBUG_POINTS_STOP },\n    { ngx_string(\"abort\"), NGX_DEBUG_POINTS_ABORT },\n    { ngx_null_string, 0 }\n};\n\n\nstatic ngx_command_t  ngx_core_commands[] = {\n\n    { ngx_string(\"daemon\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, daemon),\n      NULL },\n\n    { ngx_string(\"master_process\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, master),\n      NULL },\n\n    { ngx_string(\"timer_resolution\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, timer_resolution),\n      NULL },\n\n    { ngx_string(\"pid\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, pid),\n      NULL },\n\n    { ngx_string(\"lock_file\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, lock_file),\n      NULL },\n\n    { ngx_string(\"worker_processes\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_worker_processes,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"debug_points\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_enum_slot,\n      0,\n      offsetof(ngx_core_conf_t, debug_points),\n      &ngx_debug_points },\n\n    { ngx_string(\"user\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE12,\n      ngx_set_user,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_priority\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_priority,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_cpu_affinity\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,\n      ngx_set_cpu_affinity,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_rlimit_nofile\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_nofile),\n      NULL },\n\n    { ngx_string(\"worker_rlimit_core\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_off_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_core),\n      NULL },\n\n    { ngx_string(\"worker_shutdown_timeout\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, shutdown_timeout),\n      NULL },\n\n    { ngx_string(\"working_directory\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, working_directory),\n      NULL },\n\n    { ngx_string(\"env\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_env,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"load_module\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_load_module,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_core_module_ctx = {\n    ngx_string(\"core\"),\n    ngx_core_module_create_conf,\n    ngx_core_module_init_conf\n};\n\n\nngx_module_t  ngx_core_module = {\n    NGX_MODULE_V1,\n    &ngx_core_module_ctx,                  /* module context */\n    ngx_core_commands,                     /* module directives */\n    NGX_CORE_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_uint_t   ngx_show_help;\nstatic ngx_uint_t   ngx_show_version;\nstatic ngx_uint_t   ngx_show_configure;\nstatic u_char      *ngx_prefix;\nstatic u_char      *ngx_conf_file;\nstatic u_char      *ngx_conf_params;\nstatic char        *ngx_signal;\n\n\nstatic char **ngx_os_environ;\n\n\nint ngx_cdecl\nmain(int argc, char *const *argv)\n{\n    ngx_buf_t        *b;\n    ngx_log_t        *log;\n    ngx_uint_t        i;\n    ngx_cycle_t      *cycle, init_cycle;\n    ngx_conf_dump_t  *cd;\n    ngx_core_conf_t  *ccf;\n\n    ngx_debug_init();\n\n    if (ngx_strerror_init() != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_get_options(argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_show_version) {\n        ngx_show_version_info();\n\n        if (!ngx_test_config) {\n            return 0;\n        }\n    }\n\n    /* TODO */ ngx_max_sockets = -1;\n\n    ngx_time_init();\n\n#if (NGX_PCRE)\n    ngx_regex_init();\n#endif\n\n    ngx_pid = ngx_getpid();\n    ngx_parent = ngx_getppid();\n\n    log = ngx_log_init(ngx_prefix);\n    if (log == NULL) {\n        return 1;\n    }\n\n    /* STUB */\n#if (NGX_OPENSSL)\n    ngx_ssl_init(log);\n#endif\n\n    /*\n     * init_cycle->log is required for signal handlers and\n     * ngx_process_options()\n     */\n\n    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));\n    init_cycle.log = log;\n    ngx_cycle = &init_cycle;\n\n    init_cycle.pool = ngx_create_pool(1024, log);\n    if (init_cycle.pool == NULL) {\n        return 1;\n    }\n\n    if (ngx_save_argv(&init_cycle, argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_process_options(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_os_init(log) != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()\n     */\n\n    if (ngx_crc32_table_init() != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_slab_sizes_init() requires ngx_pagesize set in ngx_os_init()\n     */\n\n    ngx_slab_sizes_init();\n\n    if (ngx_add_inherited_sockets(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_preinit_modules() != NGX_OK) {\n        return 1;\n    }\n\n    cycle = ngx_init_cycle(&init_cycle);\n    if (cycle == NULL) {\n        if (ngx_test_config) {\n            ngx_log_stderr(0, \"configuration file %s test failed\",\n                           init_cycle.conf_file.data);\n        }\n\n        return 1;\n    }\n\n    if (ngx_test_config) {\n        if (!ngx_quiet_mode) {\n            ngx_log_stderr(0, \"configuration file %s test is successful\",\n                           cycle->conf_file.data);\n        }\n\n        if (ngx_dump_config) {\n            cd = cycle->config_dump.elts;\n\n            for (i = 0; i < cycle->config_dump.nelts; i++) {\n\n                ngx_write_stdout(\"# configuration file \");\n                (void) ngx_write_fd(ngx_stdout, cd[i].name.data,\n                                    cd[i].name.len);\n                ngx_write_stdout(\":\" NGX_LINEFEED);\n\n                b = cd[i].buffer;\n\n                (void) ngx_write_fd(ngx_stdout, b->pos, b->last - b->pos);\n                ngx_write_stdout(NGX_LINEFEED);\n            }\n        }\n\n        return 0;\n    }\n\n    if (ngx_signal) {\n        return ngx_signal_process(cycle, ngx_signal);\n    }\n\n    ngx_os_status(cycle->log);\n\n    ngx_cycle = cycle;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_process = NGX_PROCESS_MASTER;\n    }\n\n#if !(NGX_WIN32)\n\n    if (ngx_init_signals(cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (!ngx_inherited && ccf->daemon) {\n        if (ngx_daemon(cycle->log) != NGX_OK) {\n            return 1;\n        }\n\n        ngx_daemonized = 1;\n    }\n\n    if (ngx_inherited) {\n        ngx_daemonized = 1;\n    }\n\n#endif\n\n    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (log->file->fd != ngx_stderr) {\n        if (ngx_close_file(log->file->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_close_file_n \" built-in log failed\");\n        }\n    }\n\n    ngx_use_stderr = 0;\n\n    if (ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_single_process_cycle(cycle);\n\n    } else {\n        ngx_master_process_cycle(cycle);\n    }\n\n    return 0;\n}\n\n\nstatic void\nngx_show_version_info(void)\n{\n    ngx_write_stderr(\"nginx version: \" NGINX_VER_BUILD NGX_LINEFEED);\n\n    if (ngx_show_help) {\n        ngx_write_stderr(\n            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n                         NGX_LINEFEED\n            \"Options:\" NGX_LINEFEED\n            \"  -?,-h         : this help\" NGX_LINEFEED\n            \"  -v            : show version and exit\" NGX_LINEFEED\n            \"  -V            : show version and configure options then exit\"\n                               NGX_LINEFEED\n            \"  -t            : test configuration and exit\" NGX_LINEFEED\n            \"  -T            : test configuration, dump it and exit\"\n                               NGX_LINEFEED\n            \"  -q            : suppress non-error messages \"\n                               \"during configuration testing\" NGX_LINEFEED\n            \"  -s signal     : send signal to a master process: \"\n                               \"stop, quit, reopen, reload\" NGX_LINEFEED\n#ifdef NGX_PREFIX\n            \"  -p prefix     : set prefix path (default: \" NGX_PREFIX \")\"\n                               NGX_LINEFEED\n#else\n            \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n#endif\n            \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n                               \")\" NGX_LINEFEED\n            \"  -g directives : set global directives out of configuration \"\n                               \"file\" NGX_LINEFEED NGX_LINEFEED\n        );\n    }\n\n    if (ngx_show_configure) {\n\n#ifdef NGX_COMPILER\n        ngx_write_stderr(\"built by \" NGX_COMPILER NGX_LINEFEED);\n#endif\n\n#if (NGX_SSL)\n        if (ngx_strcmp(ngx_ssl_version(), OPENSSL_VERSION_TEXT) == 0) {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT NGX_LINEFEED);\n        } else {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT\n                             \" (running with \");\n            ngx_write_stderr((char *) (uintptr_t) ngx_ssl_version());\n            ngx_write_stderr(\")\" NGX_LINEFEED);\n        }\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n        ngx_write_stderr(\"TLS SNI support enabled\" NGX_LINEFEED);\n#else\n        ngx_write_stderr(\"TLS SNI support disabled\" NGX_LINEFEED);\n#endif\n#endif\n\n        ngx_write_stderr(\"configure arguments:\" NGX_CONFIGURE NGX_LINEFEED);\n    }\n}\n\n\nstatic ngx_int_t\nngx_add_inherited_sockets(ngx_cycle_t *cycle)\n{\n    u_char           *p, *v, *inherited;\n    ngx_int_t         s;\n    ngx_listening_t  *ls;\n\n    inherited = (u_char *) getenv(NGINX_VAR);\n\n    if (inherited == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,\n                  \"using inherited sockets from \\\"%s\\\"\", inherited);\n\n    if (ngx_array_init(&cycle->listening, cycle->pool, 10,\n                       sizeof(ngx_listening_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for (p = inherited, v = p; *p; p++) {\n        if (*p == ':' || *p == ';') {\n            s = ngx_atoi(v, p - v);\n            if (s == NGX_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                              \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                              \" environment variable, ignoring the rest\"\n                              \" of the variable\", v);\n                break;\n            }\n\n            v = p + 1;\n\n            ls = ngx_array_push(&cycle->listening);\n            if (ls == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memzero(ls, sizeof(ngx_listening_t));\n\n            ls->fd = (ngx_socket_t) s;\n        }\n    }\n\n    if (v != p) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                      \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                      \" environment variable, ignoring\", v);\n    }\n\n    ngx_inherited = 1;\n\n    return ngx_set_inherited_sockets(cycle);\n}\n\n\nchar **\nngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)\n{\n    char                **p, **env;\n    ngx_str_t            *var;\n    ngx_uint_t            i, n;\n    ngx_core_conf_t      *ccf;\n    ngx_pool_cleanup_t   *cln;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (last == NULL && ccf->environment) {\n        return ccf->environment;\n    }\n\n    var = ccf->env.elts;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n        if (ngx_strcmp(var[i].data, \"TZ\") == 0\n            || ngx_strncmp(var[i].data, \"TZ=\", 3) == 0)\n        {\n            goto tz_found;\n        }\n    }\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NULL;\n    }\n\n    var->len = 2;\n    var->data = (u_char *) \"TZ\";\n\n    var = ccf->env.elts;\n\ntz_found:\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            n++;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                n++;\n                break;\n            }\n        }\n    }\n\n    if (last) {\n        env = ngx_alloc((*last + n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        *last = n;\n\n    } else {\n        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n        if (cln == NULL) {\n            return NULL;\n        }\n\n        env = ngx_alloc((n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        cln->handler = ngx_cleanup_environment;\n        cln->data = env;\n    }\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            env[n++] = (char *) var[i].data;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                env[n++] = *p;\n                break;\n            }\n        }\n    }\n\n    env[n] = NULL;\n\n    if (last == NULL) {\n        ccf->environment = env;\n        environ = env;\n    }\n\n    return env;\n}\n\n\nstatic void\nngx_cleanup_environment(void *data)\n{\n    char  **env = data;\n\n    if (environ == env) {\n\n        /*\n         * if the environment is still used, as it happens on exit,\n         * the only option is to leak it\n         */\n\n        return;\n    }\n\n    ngx_free(env);\n}\n\n\nngx_pid_t\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\n{\n    char             **env, *var;\n    u_char            *p;\n    ngx_uint_t         i, n;\n    ngx_pid_t          pid;\n    ngx_exec_ctx_t     ctx;\n    ngx_core_conf_t   *ccf;\n    ngx_listening_t   *ls;\n\n    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));\n\n    ctx.path = argv[0];\n    ctx.name = \"new binary process\";\n    ctx.argv = argv;\n\n    n = 2;\n    env = ngx_set_environment(cycle, &n);\n    if (env == NULL) {\n        return NGX_INVALID_PID;\n    }\n\n    var = ngx_alloc(sizeof(NGINX_VAR)\n                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,\n                    cycle->log);\n    if (var == NULL) {\n        ngx_free(env);\n        return NGX_INVALID_PID;\n    }\n\n    p = ngx_cpymem(var, NGINX_VAR \"=\", sizeof(NGINX_VAR));\n\n    ls = cycle->listening.elts;\n    for (i = 0; i < cycle->listening.nelts; i++) {\n        p = ngx_sprintf(p, \"%ud;\", ls[i].fd);\n    }\n\n    *p = '\\0';\n\n    env[n++] = var;\n\n#if (NGX_SETPROCTITLE_USES_ENV)\n\n    /* allocate the spare 300 bytes for the new binary process title */\n\n    env[n++] = \"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n\n#endif\n\n    env[n] = NULL;\n\n#if (NGX_DEBUG)\n    {\n    char  **e;\n    for (e = env; *e; e++) {\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"env: %s\", *e);\n    }\n    }\n#endif\n\n    ctx.envp = (char *const *) env;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      ngx_rename_file_n \" %s to %s failed \"\n                      \"before executing new binary process \\\"%s\\\"\",\n                      ccf->pid.data, ccf->oldpid.data, argv[0]);\n\n        ngx_free(env);\n        ngx_free(var);\n\n        return NGX_INVALID_PID;\n    }\n\n    pid = ngx_execute(cycle, &ctx);\n\n    if (pid == NGX_INVALID_PID) {\n        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data)\n            == NGX_FILE_ERROR)\n        {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_rename_file_n \" %s back to %s failed after \"\n                          \"an attempt to execute new binary process \\\"%s\\\"\",\n                          ccf->oldpid.data, ccf->pid.data, argv[0]);\n        }\n    }\n\n    ngx_free(env);\n    ngx_free(var);\n\n    return pid;\n}\n\n\nstatic ngx_int_t\nngx_get_options(int argc, char *const *argv)\n{\n    u_char     *p;\n    ngx_int_t   i;\n\n    for (i = 1; i < argc; i++) {\n\n        p = (u_char *) argv[i];\n\n        if (*p++ != '-') {\n            ngx_log_stderr(0, \"invalid option: \\\"%s\\\"\", argv[i]);\n            return NGX_ERROR;\n        }\n\n        while (*p) {\n\n            switch (*p++) {\n\n            case '?':\n            case 'h':\n                ngx_show_version = 1;\n                ngx_show_help = 1;\n                break;\n\n            case 'v':\n                ngx_show_version = 1;\n                break;\n\n            case 'V':\n                ngx_show_version = 1;\n                ngx_show_configure = 1;\n                break;\n\n            case 't':\n                ngx_test_config = 1;\n                break;\n\n            case 'T':\n                ngx_test_config = 1;\n                ngx_dump_config = 1;\n                break;\n\n            case 'q':\n                ngx_quiet_mode = 1;\n                break;\n\n            case 'p':\n                if (*p) {\n                    ngx_prefix = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_prefix = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n                return NGX_ERROR;\n\n            case 'c':\n                if (*p) {\n                    ngx_conf_file = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_file = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-c\\\" requires file name\");\n                return NGX_ERROR;\n\n            case 'g':\n                if (*p) {\n                    ngx_conf_params = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_params = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-g\\\" requires parameter\");\n                return NGX_ERROR;\n\n            case 's':\n                if (*p) {\n                    ngx_signal = (char *) p;\n\n                } else if (argv[++i]) {\n                    ngx_signal = argv[i];\n\n                } else {\n                    ngx_log_stderr(0, \"option \\\"-s\\\" requires parameter\");\n                    return NGX_ERROR;\n                }\n\n                if (ngx_strcmp(ngx_signal, \"stop\") == 0\n                    || ngx_strcmp(ngx_signal, \"quit\") == 0\n                    || ngx_strcmp(ngx_signal, \"reopen\") == 0\n                    || ngx_strcmp(ngx_signal, \"reload\") == 0)\n                {\n                    ngx_process = NGX_PROCESS_SIGNALLER;\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"invalid option: \\\"-s %s\\\"\", ngx_signal);\n                return NGX_ERROR;\n\n            default:\n                ngx_log_stderr(0, \"invalid option: \\\"%c\\\"\", *(p - 1));\n                return NGX_ERROR;\n            }\n        }\n\n    next:\n\n        continue;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)\n{\n#if (NGX_FREEBSD)\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n    ngx_argv = (char **) argv;\n\n#else\n    size_t     len;\n    ngx_int_t  i;\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n\n    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);\n    if (ngx_argv == NULL) {\n        return NGX_ERROR;\n    }\n\n    for (i = 0; i < argc; i++) {\n        len = ngx_strlen(argv[i]) + 1;\n\n        ngx_argv[i] = ngx_alloc(len, cycle->log);\n        if (ngx_argv[i] == NULL) {\n            return NGX_ERROR;\n        }\n\n        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);\n    }\n\n    ngx_argv[i] = NULL;\n\n#endif\n\n    ngx_os_environ = environ;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_process_options(ngx_cycle_t *cycle)\n{\n    u_char  *p;\n    size_t   len;\n\n    if (ngx_prefix) {\n        len = ngx_strlen(ngx_prefix);\n        p = ngx_prefix;\n\n        if (len && !ngx_path_separator(p[len - 1])) {\n            p = ngx_pnalloc(cycle->pool, len + 1);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(p, ngx_prefix, len);\n            p[len++] = '/';\n        }\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n    } else {\n\n#ifndef NGX_PREFIX\n\n        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {\n            ngx_log_stderr(ngx_errno, \"[emerg]: \" ngx_getcwd_n \" failed\");\n            return NGX_ERROR;\n        }\n\n        len = ngx_strlen(p);\n\n        p[len++] = '/';\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n#else\n\n#ifdef NGX_CONF_PREFIX\n        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);\n#else\n        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);\n#endif\n        ngx_str_set(&cycle->prefix, NGX_PREFIX);\n\n#endif\n    }\n\n    if (ngx_conf_file) {\n        cycle->conf_file.len = ngx_strlen(ngx_conf_file);\n        cycle->conf_file.data = ngx_conf_file;\n\n    } else {\n        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &cycle->conf_file, 0) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;\n         p > cycle->conf_file.data;\n         p--)\n    {\n        if (ngx_path_separator(*p)) {\n            cycle->conf_prefix.len = p - cycle->conf_file.data + 1;\n            cycle->conf_prefix.data = cycle->conf_file.data;\n            break;\n        }\n    }\n\n    if (ngx_conf_params) {\n        cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n        cycle->conf_param.data = ngx_conf_params;\n    }\n\n    if (ngx_test_config) {\n        cycle->log->log_level = NGX_LOG_INFO;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_core_module_create_conf(ngx_cycle_t *cycle)\n{\n    ngx_core_conf_t  *ccf;\n\n    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));\n    if (ccf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc()\n     *\n     *     ccf->pid = NULL;\n     *     ccf->oldpid = NULL;\n     *     ccf->priority = 0;\n     *     ccf->cpu_affinity_auto = 0;\n     *     ccf->cpu_affinity_n = 0;\n     *     ccf->cpu_affinity = NULL;\n     */\n\n    ccf->daemon = NGX_CONF_UNSET;\n    ccf->master = NGX_CONF_UNSET;\n    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;\n    ccf->shutdown_timeout = NGX_CONF_UNSET_MSEC;\n\n    ccf->worker_processes = NGX_CONF_UNSET;\n    ccf->debug_points = NGX_CONF_UNSET;\n\n    ccf->rlimit_nofile = NGX_CONF_UNSET;\n    ccf->rlimit_core = NGX_CONF_UNSET;\n\n    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;\n    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;\n\n    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return ccf;\n}\n\n\nstatic char *\nngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_conf_init_value(ccf->daemon, 1);\n    ngx_conf_init_value(ccf->master, 1);\n    ngx_conf_init_msec_value(ccf->timer_resolution, 0);\n    ngx_conf_init_msec_value(ccf->shutdown_timeout, 0);\n\n    ngx_conf_init_value(ccf->worker_processes, 1);\n    ngx_conf_init_value(ccf->debug_points, 0);\n\n#if (NGX_HAVE_CPU_AFFINITY)\n\n    if (!ccf->cpu_affinity_auto\n        && ccf->cpu_affinity_n\n        && ccf->cpu_affinity_n != 1\n        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)\n    {\n        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n                      \"the number of \\\"worker_processes\\\" is not equal to \"\n                      \"the number of \\\"worker_cpu_affinity\\\" masks, \"\n                      \"using last mask for remaining worker processes\");\n    }\n\n#endif\n\n\n    if (ccf->pid.len == 0) {\n        ngx_str_set(&ccf->pid, NGX_PID_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->pid, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->oldpid.len = ccf->pid.len + sizeof(NGX_OLDPID_EXT);\n\n    ccf->oldpid.data = ngx_pnalloc(cycle->pool, ccf->oldpid.len);\n    if (ccf->oldpid.data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memcpy(ngx_cpymem(ccf->oldpid.data, ccf->pid.data, ccf->pid.len),\n               NGX_OLDPID_EXT, sizeof(NGX_OLDPID_EXT));\n\n\n#if !(NGX_WIN32)\n\n    if (ccf->user == (uid_t) NGX_CONF_UNSET_UINT && geteuid() == 0) {\n        struct group   *grp;\n        struct passwd  *pwd;\n\n        ngx_set_errno(0);\n        pwd = getpwnam(NGX_USER);\n        if (pwd == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getpwnam(\\\"\" NGX_USER \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->username = NGX_USER;\n        ccf->user = pwd->pw_uid;\n\n        ngx_set_errno(0);\n        grp = getgrnam(NGX_GROUP);\n        if (grp == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getgrnam(\\\"\" NGX_GROUP \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->group = grp->gr_gid;\n    }\n\n\n    if (ccf->lock_file.len == 0) {\n        ngx_str_set(&ccf->lock_file, NGX_LOCK_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->lock_file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    {\n    ngx_str_t  lock_file;\n\n    lock_file = cycle->old_cycle->lock_file;\n\n    if (lock_file.len) {\n        lock_file.len--;\n\n        if (ccf->lock_file.len != lock_file.len\n            || ngx_strncmp(ccf->lock_file.data, lock_file.data, lock_file.len)\n               != 0)\n        {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                          \"\\\"lock_file\\\" could not be changed, ignored\");\n        }\n\n        cycle->lock_file.len = lock_file.len + 1;\n        lock_file.len += sizeof(\".accept\");\n\n        cycle->lock_file.data = ngx_pstrdup(cycle->pool, &lock_file);\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n    } else {\n        cycle->lock_file.len = ccf->lock_file.len + 1;\n        cycle->lock_file.data = ngx_pnalloc(cycle->pool,\n                                      ccf->lock_file.len + sizeof(\".accept\"));\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_memcpy(ngx_cpymem(cycle->lock_file.data, ccf->lock_file.data,\n                              ccf->lock_file.len),\n                   \".accept\", sizeof(\".accept\"));\n    }\n    }\n\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_WIN32)\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"user\\\" is not supported, ignored\");\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_core_conf_t  *ccf = conf;\n\n    char             *group;\n    struct passwd    *pwd;\n    struct group     *grp;\n    ngx_str_t        *value;\n\n    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {\n        return \"is duplicate\";\n    }\n\n    if (geteuid() != 0) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"the \\\"user\\\" directive makes sense only \"\n                           \"if the master process runs \"\n                           \"with super-user privileges, ignored\");\n        return NGX_CONF_OK;\n    }\n\n    value = cf->args->elts;\n\n    ccf->username = (char *) value[1].data;\n\n    ngx_set_errno(0);\n    pwd = getpwnam((const char *) value[1].data);\n    if (pwd == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getpwnam(\\\"%s\\\") failed\", value[1].data);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->user = pwd->pw_uid;\n\n    group = (char *) ((cf->args->nelts == 2) ? value[1].data : value[2].data);\n\n    ngx_set_errno(0);\n    grp = getgrnam(group);\n    if (grp == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getgrnam(\\\"%s\\\") failed\", group);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->group = grp->gr_gid;\n\n    return NGX_CONF_OK;\n\n#endif\n}\n\n\nstatic char *\nngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t   *value, *var;\n    ngx_uint_t   i;\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n    *var = value[1];\n\n    for (i = 0; i < value[1].len; i++) {\n\n        if (value[1].data[i] == '=') {\n\n            var->len = i;\n\n            return NGX_CONF_OK;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t        *value;\n    ngx_uint_t        n, minus;\n\n    if (ccf->priority != 0) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (value[1].data[0] == '-') {\n        n = 1;\n        minus = 1;\n\n    } else if (value[1].data[0] == '+') {\n        n = 1;\n        minus = 0;\n\n    } else {\n        n = 0;\n        minus = 0;\n    }\n\n    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);\n    if (ccf->priority == NGX_ERROR) {\n        return \"invalid number\";\n    }\n\n    if (minus) {\n        ccf->priority = -ccf->priority;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_core_conf_t  *ccf = conf;\n\n    u_char            ch, *p;\n    ngx_str_t        *value;\n    ngx_uint_t        i, n;\n    ngx_cpuset_t     *mask;\n\n    if (ccf->cpu_affinity) {\n        return \"is duplicate\";\n    }\n\n    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));\n    if (mask == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->cpu_affinity_n = cf->args->nelts - 1;\n    ccf->cpu_affinity = mask;\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n\n        if (cf->args->nelts > 3) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid number of arguments in \"\n                               \"\\\"worker_cpu_affinity\\\" directive\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->cpu_affinity_auto = 1;\n\n        CPU_ZERO(&mask[0]);\n        for (i = 0; i < (ngx_uint_t) ngx_min(ngx_ncpu, CPU_SETSIZE); i++) {\n            CPU_SET(i, &mask[0]);\n        }\n\n        n = 2;\n\n    } else {\n        n = 1;\n    }\n\n    for ( /* void */ ; n < cf->args->nelts; n++) {\n\n        if (value[n].len > CPU_SETSIZE) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"\\\"worker_cpu_affinity\\\" supports up to %d CPUs only\",\n                         CPU_SETSIZE);\n            return NGX_CONF_ERROR;\n        }\n\n        i = 0;\n        CPU_ZERO(&mask[n - 1]);\n\n        for (p = value[n].data + value[n].len - 1;\n             p >= value[n].data;\n             p--)\n        {\n            ch = *p;\n\n            if (ch == ' ') {\n                continue;\n            }\n\n            i++;\n\n            if (ch == '0') {\n                continue;\n            }\n\n            if (ch == '1') {\n                CPU_SET(i - 1, &mask[n - 1]);\n                continue;\n            }\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                          \"invalid character \\\"%c\\\" in \\\"worker_cpu_affinity\\\"\",\n                          ch);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"worker_cpu_affinity\\\" is not supported \"\n                       \"on this platform, ignored\");\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nngx_cpuset_t *\nngx_get_cpu_affinity(ngx_uint_t n)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_uint_t        i, j;\n    ngx_cpuset_t     *mask;\n    ngx_core_conf_t  *ccf;\n\n    static ngx_cpuset_t  result;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                           ngx_core_module);\n\n    if (ccf->cpu_affinity == NULL) {\n        return NULL;\n    }\n\n    if (ccf->cpu_affinity_auto) {\n        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n        for (i = 0, j = n; /* void */ ; i++) {\n\n            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {\n                break;\n            }\n\n            if (i == CPU_SETSIZE && j == n) {\n                /* empty mask */\n                return NULL;\n            }\n\n            /* void */\n        }\n\n        CPU_ZERO(&result);\n        CPU_SET(i % CPU_SETSIZE, &result);\n\n        return &result;\n    }\n\n    if (ccf->cpu_affinity_n > n) {\n        return &ccf->cpu_affinity[n];\n    }\n\n    return &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n#else\n\n    return NULL;\n\n#endif\n}\n\n\nstatic char *\nngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_str_t        *value;\n    ngx_core_conf_t  *ccf;\n\n    ccf = (ngx_core_conf_t *) conf;\n\n    if (ccf->worker_processes != NGX_CONF_UNSET) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n        ccf->worker_processes = ngx_ncpu;\n        return NGX_CONF_OK;\n    }\n\n    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);\n\n    if (ccf->worker_processes == NGX_ERROR) {\n        return \"invalid value\";\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_DLOPEN)\n    void                *handle;\n    char               **names, **order;\n    ngx_str_t           *value, file;\n    ngx_uint_t           i;\n    ngx_module_t        *module, **modules;\n    ngx_pool_cleanup_t  *cln;\n\n    if (cf->cycle->modules_used) {\n        return \"is specified too late\";\n    }\n\n    value = cf->args->elts;\n\n    file = value[1];\n\n    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);\n    if (cln == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    handle = ngx_dlopen(file.data);\n    if (handle == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlopen_n \" \\\"%s\\\" failed (%s)\",\n                           file.data, ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    cln->handler = ngx_unload_module;\n    cln->data = handle;\n\n    modules = ngx_dlsym(handle, \"ngx_modules\");\n    if (modules == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_modules\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    names = ngx_dlsym(handle, \"ngx_module_names\");\n    if (names == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_module_names\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    order = ngx_dlsym(handle, \"ngx_module_order\");\n\n    for (i = 0; modules[i]; i++) {\n        module = modules[i];\n        module->name = names[i];\n\n        if (ngx_add_module(cf, &file, module, order) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cf->log, 0, \"module: %s i:%ui\",\n                       module->name, module->index);\n    }\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"\\\"load_module\\\" is not supported \"\n                       \"on this platform\");\n    return NGX_CONF_ERROR;\n\n#endif\n}\n\n\n#if (NGX_HAVE_DLOPEN)\n\nstatic void\nngx_unload_module(void *data)\n{\n    void  *handle = data;\n\n    if (ngx_dlclose(handle) != 0) {\n        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                      ngx_dlclose_n \" failed (%s)\", ngx_dlerror());\n    }\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/src/os/unix/ngx_dlopen.h": "\n/*\n * Copyright (C) Maxim Dounin\n * Copyright (C) Nginx, Inc.\n */\n\n\n#ifndef _NGX_DLOPEN_H_INCLUDED_\n#define _NGX_DLOPEN_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n#define ngx_dlopen(path)           dlopen((char *) path, RTLD_NOW | RTLD_GLOBAL)\n#define ngx_dlopen_n               \"dlopen()\"\n\n#define ngx_dlsym(handle, symbol)  dlsym(handle, symbol)\n#define ngx_dlsym_n                \"dlsym()\"\n\n#define ngx_dlclose(handle)        dlclose(handle)\n#define ngx_dlclose_n              \"dlclose()\"\n\n\n#if (NGX_HAVE_DLOPEN)\nchar *ngx_dlerror(void);\n#endif\n\n\n#endif /* _NGX_DLOPEN_H_INCLUDED_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/src/os/win32/ngx_dlopen.h": "\n/*\n * Copyright (C) Maxim Dounin\n * Copyright (C) Nginx, Inc.\n */\n\n\n#ifndef _NGX_DLOPEN_H_INCLUDED_\n#define _NGX_DLOPEN_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n#define NGX_HAVE_DLOPEN  1\n\n\n#define ngx_dlopen(path)           LoadLibrary((char *) path)\n#define ngx_dlopen_n               \"LoadLibrary()\"\n\n#define ngx_dlsym(handle, symbol)  (void *) GetProcAddress(handle, symbol)\n#define ngx_dlsym_n                \"GetProcAddress()\"\n\n#define ngx_dlclose(handle)        (FreeLibrary(handle) ? 0 : -1)\n#define ngx_dlclose_n              \"FreeLibrary()\"\n\n\nchar *ngx_dlerror(void);\n\n\n#endif /* _NGX_DLOPEN_H_INCLUDED_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/auto/unix.orig": "\n# Copyright (C) Igor Sysoev\n# Copyright (C) Nginx, Inc.\n\n\nNGX_USER=${NGX_USER:-nobody}\n\nif [ -z \"$NGX_GROUP\" ]; then\n    if [ $NGX_USER = nobody ]; then\n        if grep nobody /etc/group 2>&1 >/dev/null; then\n            echo \"checking for nobody group ... found\"\n            NGX_GROUP=nobody\n        else\n            echo \"checking for nobody group ... not found\"\n\n            if grep nogroup /etc/group 2>&1 >/dev/null; then\n                echo \"checking for nogroup group ... found\"\n                NGX_GROUP=nogroup\n            else\n                echo \"checking for nogroup group ... not found\"\n                NGX_GROUP=nobody\n            fi\n        fi\n    else\n        NGX_GROUP=$NGX_USER\n    fi\nfi\n\n\nngx_feature=\"poll()\"\nngx_feature_name=\nngx_feature_run=no\nngx_feature_incs=\"#include <poll.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"int  n; struct pollfd  pl;\n                  pl.fd = 0;\n                  pl.events = 0;\n                  pl.revents = 0;\n                  n = poll(&pl, 1, 0);\n                  if (n == -1) return 1\"\n. auto/feature\n\nif [ $ngx_found = no ]; then\n    EVENT_POLL=NONE\nfi\n\n\nngx_feature=\"/dev/poll\"\nngx_feature_name=\"NGX_HAVE_DEVPOLL\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/devpoll.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"int  n, dp; struct dvpoll  dvp;\n                  dp = 0;\n                  dvp.dp_fds = NULL;\n                  dvp.dp_nfds = 0;\n                  dvp.dp_timeout = 0;\n                  n = ioctl(dp, DP_POLL, &dvp);\n                  if (n == -1) return 1\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    CORE_SRCS=\"$CORE_SRCS $DEVPOLL_SRCS\"\n    EVENT_MODULES=\"$EVENT_MODULES $DEVPOLL_MODULE\"\n    EVENT_FOUND=YES\nfi\n\n\nif test -z \"$NGX_KQUEUE_CHECKED\"; then\n    ngx_feature=\"kqueue\"\n    ngx_feature_name=\"NGX_HAVE_KQUEUE\"\n    ngx_feature_run=no\n    ngx_feature_incs=\"#include <sys/event.h>\"\n    ngx_feature_path=\n    ngx_feature_libs=\n    ngx_feature_test=\"(void) kqueue()\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n\n        have=NGX_HAVE_CLEAR_EVENT . auto/have\n        EVENT_MODULES=\"$EVENT_MODULES $KQUEUE_MODULE\"\n        CORE_SRCS=\"$CORE_SRCS $KQUEUE_SRCS\"\n        EVENT_FOUND=YES\n\n        ngx_feature=\"kqueue's NOTE_LOWAT\"\n        ngx_feature_name=\"NGX_HAVE_LOWAT_EVENT\"\n        ngx_feature_run=no\n        ngx_feature_incs=\"#include <sys/event.h>\"\n        ngx_feature_path=\n        ngx_feature_libs=\n        ngx_feature_test=\"struct kevent  kev;\n                          kev.fflags = NOTE_LOWAT;\n                          (void) kev\"\n        . auto/feature\n\n\n        ngx_feature=\"kqueue's EVFILT_TIMER\"\n        ngx_feature_name=\"NGX_HAVE_TIMER_EVENT\"\n        ngx_feature_run=yes\n        ngx_feature_incs=\"#include <sys/event.h>\n                          #include <sys/time.h>\"\n        ngx_feature_path=\n        ngx_feature_libs=\n        ngx_feature_test=\"int      kq;\n                  struct kevent    kev;\n                  struct timespec  ts;\n\n                  if ((kq = kqueue()) == -1) return 1;\n\n                  kev.ident = 0;\n                  kev.filter = EVFILT_TIMER;\n                  kev.flags = EV_ADD|EV_ENABLE;\n                  kev.fflags = 0;\n                  kev.data = 1000;\n                  kev.udata = 0;\n\n                  ts.tv_sec = 0;\n                  ts.tv_nsec = 0;\n\n                  if (kevent(kq, &kev, 1, &kev, 1, &ts) == -1) return 1;\n\n                  if (kev.flags & EV_ERROR) return 1;\"\n\n        . auto/feature\n    fi\nfi\n\n\nif [ \"$NGX_SYSTEM\" = \"NetBSD\" ]; then\n\n    # NetBSD 2.0 incompatibly defines kevent.udata as \"intptr_t\"\n\n    cat << END >> $NGX_AUTO_CONFIG_H\n\n#define NGX_KQUEUE_UDATA_T\n\nEND\n\nelse\n    cat << END >> $NGX_AUTO_CONFIG_H\n\n#define NGX_KQUEUE_UDATA_T  (void *)\n\nEND\n\nfi\n\n\nngx_feature=\"crypt()\"\nngx_feature_name=\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"crypt(\\\"test\\\", \\\"salt\\\");\"\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    ngx_feature=\"crypt() in libcrypt\"\n    ngx_feature_name=\n    ngx_feature_run=no\n    ngx_feature_incs=\n    ngx_feature_path=\n    ngx_feature_libs=-lcrypt\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CRYPT_LIB=\"-lcrypt\"\n    fi\nfi\n\n\nngx_feature=\"F_READAHEAD\"\nngx_feature_name=\"NGX_HAVE_F_READAHEAD\"\nngx_feature_run=no\nngx_feature_incs=\"#include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"fcntl(0, F_READAHEAD, 1);\"\n. auto/feature\n\n\nngx_feature=\"posix_fadvise()\"\nngx_feature_name=\"NGX_HAVE_POSIX_FADVISE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL);\"\n. auto/feature\n\n\nngx_feature=\"O_DIRECT\"\nngx_feature_name=\"NGX_HAVE_O_DIRECT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"fcntl(0, F_SETFL, O_DIRECT);\"\n. auto/feature\n\n\nif [ $ngx_found = yes -a \"$NGX_SYSTEM\" = \"Linux\" ]; then\n    have=NGX_HAVE_ALIGNED_DIRECTIO . auto/have\nfi\n\nngx_feature=\"F_NOCACHE\"\nngx_feature_name=\"NGX_HAVE_F_NOCACHE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"fcntl(0, F_NOCACHE, 1);\"\n. auto/feature\n\n\nngx_feature=\"directio()\"\nngx_feature_name=\"NGX_HAVE_DIRECTIO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/types.h>\n                  #include <sys/fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"directio(0, DIRECTIO_ON);\"\n. auto/feature\n\n\nngx_feature=\"statfs()\"\nngx_feature_name=\"NGX_HAVE_STATFS\"\nngx_feature_run=no\nngx_feature_incs=\"$NGX_INCLUDE_SYS_PARAM_H\n                  $NGX_INCLUDE_SYS_MOUNT_H\n                  $NGX_INCLUDE_SYS_VFS_H\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct statfs  fs;\n                  statfs(\\\".\\\", &fs);\"\n. auto/feature\n\n\nngx_feature=\"statvfs()\"\nngx_feature_name=\"NGX_HAVE_STATVFS\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/types.h>\n                  #include <sys/statvfs.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct statvfs  fs;\n                  statvfs(\\\".\\\", &fs);\"\n. auto/feature\n\n\nngx_feature=\"dlopen()\"\nngx_feature_name=\"NGX_HAVE_DLOPEN\"\nngx_feature_run=no\nngx_feature_incs=\"#include <dlfcn.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"dlopen(NULL, RTLD_NOW | RTLD_GLOBAL); dlsym(NULL, \\\"\\\")\"\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    ngx_feature=\"dlopen() in libdl\"\n    ngx_feature_libs=\"-ldl\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_LIBS=\"$CORE_LIBS -ldl\"\n        NGX_LIBDL=\"-ldl\"\n    fi\nfi\n\n\nngx_feature=\"sched_yield()\"\nngx_feature_name=\"NGX_HAVE_SCHED_YIELD\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sched.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"sched_yield()\"\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    ngx_feature=\"sched_yield() in librt\"\n    ngx_feature_libs=\"-lrt\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_LIBS=\"$CORE_LIBS -lrt\"\n    fi\nfi\n\n\nngx_feature=\"sched_setaffinity()\"\nngx_feature_name=\"NGX_HAVE_SCHED_SETAFFINITY\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sched.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"cpu_set_t mask;\n                  CPU_ZERO(&mask);\n                  sched_setaffinity(0, sizeof(cpu_set_t), &mask)\"\n. auto/feature\n\n\nngx_feature=\"SO_SETFIB\"\nngx_feature_name=\"NGX_HAVE_SETFIB\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_SETFIB, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"SO_REUSEPORT\"\nngx_feature_name=\"NGX_HAVE_REUSEPORT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_REUSEPORT, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"SO_ACCEPTFILTER\"\nngx_feature_name=\"NGX_HAVE_DEFERRED_ACCEPT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_ACCEPTFILTER, NULL, 0)\"\n. auto/feature\n\n\n# OpenBSD bind to any address for transparent proxying\n\nngx_feature=\"SO_BINDANY\"\nngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_BINDANY, NULL, 0)\"\n. auto/feature\n\n\n# Linux transparent proxying\n\nngx_feature=\"IP_TRANSPARENT\"\nngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_TRANSPARENT, NULL, 0)\"\n. auto/feature\n\n\n# FreeBSD bind to any address for transparent proxying\n\nngx_feature=\"IP_BINDANY\"\nngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_BINDANY, NULL, 0)\"\n. auto/feature\n\n\n# Linux IP_BIND_ADDRESS_NO_PORT\n\nngx_feature=\"IP_BIND_ADDRESS_NO_PORT\"\nngx_feature_name=\"NGX_HAVE_IP_BIND_ADDRESS_NO_PORT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_BIND_ADDRESS_NO_PORT, NULL, 0)\"\n. auto/feature\n\n\n# BSD way to get IPv4 datagram destination address\n\nngx_feature=\"IP_RECVDSTADDR\"\nngx_feature_name=\"NGX_HAVE_IP_RECVDSTADDR\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_RECVDSTADDR, NULL, 0)\"\n. auto/feature\n\n\n# BSD way to set IPv4 datagram source address\n\nngx_feature=\"IP_SENDSRCADDR\"\nngx_feature_name=\"NGX_HAVE_IP_SENDSRCADDR\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_SENDSRCADDR, NULL, 0)\"\n. auto/feature\n\n\n# Linux way to get IPv4 datagram destination address\n\nngx_feature=\"IP_PKTINFO\"\nngx_feature_name=\"NGX_HAVE_IP_PKTINFO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct in_pktinfo  pkt;\n                  pkt.ipi_spec_dst.s_addr = INADDR_ANY;\n                  (void) pkt;\n                  setsockopt(0, IPPROTO_IP, IP_PKTINFO, NULL, 0)\"\n. auto/feature\n\n\n# RFC 3542 way to get IPv6 datagram destination address\n\nngx_feature=\"IPV6_RECVPKTINFO\"\nngx_feature_name=\"NGX_HAVE_IPV6_RECVPKTINFO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_IPV6, IPV6_RECVPKTINFO, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"TCP_DEFER_ACCEPT\"\nngx_feature_name=\"NGX_HAVE_DEFERRED_ACCEPT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\n                  #include <netinet/tcp.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_DEFER_ACCEPT, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"TCP_KEEPIDLE\"\nngx_feature_name=\"NGX_HAVE_KEEPALIVE_TUNABLE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\n                  #include <netinet/tcp.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_KEEPIDLE, NULL, 0);\n                  setsockopt(0, IPPROTO_TCP, TCP_KEEPINTVL, NULL, 0);\n                  setsockopt(0, IPPROTO_TCP, TCP_KEEPCNT, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"TCP_FASTOPEN\"\nngx_feature_name=\"NGX_HAVE_TCP_FASTOPEN\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\n                  #include <netinet/tcp.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_FASTOPEN, NULL, 0)\"\n. auto/feature\n\n\nngx_feature=\"TCP_INFO\"\nngx_feature_name=\"NGX_HAVE_TCP_INFO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\n                  #include <netinet/tcp.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"socklen_t optlen = sizeof(struct tcp_info);\n                  struct tcp_info ti;\n                  ti.tcpi_rtt = 0;\n                  ti.tcpi_rttvar = 0;\n                  ti.tcpi_snd_cwnd = 0;\n                  ti.tcpi_rcv_space = 0;\n                  getsockopt(0, IPPROTO_TCP, TCP_INFO, &ti, &optlen)\"\n. auto/feature\n\n\nngx_feature=\"accept4()\"\nngx_feature_name=\"NGX_HAVE_ACCEPT4\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"accept4(0, NULL, NULL, SOCK_NONBLOCK)\"\n. auto/feature\n\nif [ $NGX_FILE_AIO = YES ]; then\n\n    ngx_feature=\"kqueue AIO support\"\n    ngx_feature_name=\"NGX_HAVE_FILE_AIO\"\n    ngx_feature_run=no\n    ngx_feature_incs=\"#include <aio.h>\"\n    ngx_feature_path=\n    ngx_feature_libs=\n    ngx_feature_test=\"struct aiocb  iocb;\n                      iocb.aio_sigevent.sigev_notify = SIGEV_KEVENT;\n                      (void) aio_read(&iocb)\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_SRCS=\"$CORE_SRCS $FILE_AIO_SRCS\"\n    fi\n\n    if [ $ngx_found = no ]; then\n\n        ngx_feature=\"Linux AIO support\"\n        ngx_feature_name=\"NGX_HAVE_FILE_AIO\"\n        ngx_feature_run=no\n        ngx_feature_incs=\"#include <linux/aio_abi.h>\n                          #include <sys/eventfd.h>\"\n        ngx_feature_path=\n        ngx_feature_libs=\n        ngx_feature_test=\"struct iocb  iocb;\n                          iocb.aio_lio_opcode = IOCB_CMD_PREAD;\n                          iocb.aio_flags = IOCB_FLAG_RESFD;\n                          iocb.aio_resfd = -1;\n                          (void) iocb;\n                          (void) eventfd(0, 0)\"\n        . auto/feature\n\n        if [ $ngx_found = yes ]; then\n            have=NGX_HAVE_EVENTFD . auto/have\n            have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n            CORE_SRCS=\"$CORE_SRCS $LINUX_AIO_SRCS\"\n        fi\n    fi\n\n    if [ $ngx_found = no ]; then\n\n        ngx_feature=\"Linux AIO support (SYS_eventfd)\"\n        ngx_feature_incs=\"#include <linux/aio_abi.h>\n                          #include <sys/syscall.h>\"\n        ngx_feature_test=\"struct iocb  iocb;\n                          iocb.aio_lio_opcode = IOCB_CMD_PREAD;\n                          iocb.aio_flags = IOCB_FLAG_RESFD;\n                          iocb.aio_resfd = -1;\n                          (void) iocb;\n                          (void) SYS_eventfd\"\n        . auto/feature\n\n        if [ $ngx_found = yes ]; then\n            have=NGX_HAVE_EVENTFD . auto/have\n            CORE_SRCS=\"$CORE_SRCS $LINUX_AIO_SRCS\"\n        fi\n    fi\n\n    if [ $ngx_found = no ]; then\n        cat << END\n\n$0: no supported file AIO was found\nCurrently file AIO is supported on FreeBSD 4.3+ and Linux 2.6.22+ only\n\nEND\n        exit 1\n    fi\n\nelse\n\n    ngx_feature=\"eventfd()\"\n    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n    ngx_feature_run=no\n    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n    ngx_feature_path=\n    ngx_feature_libs=\n    ngx_feature_test=\"(void) eventfd(0, 0)\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n    fi\n\n    if [ $ngx_found = no ]; then\n\n        ngx_feature=\"eventfd() (SYS_eventfd)\"\n        ngx_feature_incs=\"#include <sys/syscall.h>\"\n        ngx_feature_test=\"(void) SYS_eventfd\"\n        . auto/feature\n    fi\nfi\n\n\nhave=NGX_HAVE_UNIX_DOMAIN . auto/have\n\nngx_feature_libs=\n\n\n# C types\n\nngx_type=\"int\"; . auto/types/sizeof\n\nngx_type=\"long\"; . auto/types/sizeof\n\nngx_type=\"long long\"; . auto/types/sizeof\n\nngx_type=\"void *\"; . auto/types/sizeof; ngx_ptr_size=$ngx_size\nngx_param=NGX_PTR_SIZE; ngx_value=$ngx_size; . auto/types/value\n\n\n# POSIX types\n\nNGX_INCLUDE_AUTO_CONFIG_H=\"#include \\\"ngx_auto_config.h\\\"\"\n\nngx_type=\"uint32_t\"; ngx_types=\"u_int32_t\"; . auto/types/typedef\nngx_type=\"uint64_t\"; ngx_types=\"u_int64_t\"; . auto/types/typedef\n\nngx_type=\"sig_atomic_t\"; ngx_types=\"int\"; . auto/types/typedef\n. auto/types/sizeof\nngx_param=NGX_SIG_ATOMIC_T_SIZE; ngx_value=$ngx_size; . auto/types/value\n\nngx_type=\"socklen_t\"; ngx_types=\"int\"; . auto/types/typedef\n\nngx_type=\"in_addr_t\"; ngx_types=\"uint32_t u_int32_t\"; . auto/types/typedef\n\nngx_type=\"in_port_t\"; ngx_types=\"u_short\"; . auto/types/typedef\n\nngx_type=\"rlim_t\"; ngx_types=\"int\"; . auto/types/typedef\n\n. auto/types/uintptr_t\n\n. auto/endianness\n\nngx_type=\"size_t\"; . auto/types/sizeof\nngx_param=NGX_MAX_SIZE_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\nngx_param=NGX_SIZE_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\n\nngx_type=\"off_t\"; . auto/types/sizeof\nngx_param=NGX_MAX_OFF_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\nngx_param=NGX_OFF_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\n\nngx_type=\"time_t\"; . auto/types/sizeof\nngx_param=NGX_TIME_T_SIZE; ngx_value=$ngx_size; . auto/types/value\nngx_param=NGX_TIME_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\nngx_param=NGX_MAX_TIME_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\n\n\n# syscalls, libc calls and some features\n\n\nngx_feature=\"AF_INET6\"\nngx_feature_name=\"NGX_HAVE_INET6\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <netinet/in.h>\n                  #include <arpa/inet.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct sockaddr_in6  sin6;\n                  sin6.sin6_family = AF_INET6;\n                  (void) sin6\"\n. auto/feature\n\n\nngx_feature=\"setproctitle()\"\nngx_feature_name=\"NGX_HAVE_SETPROCTITLE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <stdlib.h>\"\nngx_feature_path=\nngx_feature_libs=$NGX_SETPROCTITLE_LIB\nngx_feature_test=\"setproctitle(\\\"test\\\");\"\n. auto/feature\n\n\nngx_feature=\"pread()\"\nngx_feature_name=\"NGX_HAVE_PREAD\"\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"char buf[1]; ssize_t n; n = pread(0, buf, 1, 0);\n                  if (n == -1) return 1\"\n. auto/feature\n\n\nngx_feature=\"pwrite()\"\nngx_feature_name=\"NGX_HAVE_PWRITE\"\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"char buf[1]; ssize_t n; n = pwrite(1, buf, 1, 0);\n                  if (n == -1) return 1\"\n. auto/feature\n\n\n# pwritev() was introduced in FreeBSD 6 and Linux 2.6.30, glibc 2.10\n\nngx_feature=\"pwritev()\"\nngx_feature_name=\"NGX_HAVE_PWRITEV\"\nngx_feature_run=no\nngx_feature_incs='#include <sys/uio.h>'\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"char buf[1]; struct iovec vec[1]; ssize_t n;\n                  vec[0].iov_base = buf;\n                  vec[0].iov_len = 1;\n                  n = pwritev(1, vec, 1, 0);\n                  if (n == -1) return 1\"\n. auto/feature\n\n\nngx_feature=\"sys_nerr\"\nngx_feature_name=\"NGX_SYS_NERR\"\nngx_feature_run=value\nngx_feature_incs='#include <errno.h>\n                  #include <stdio.h>'\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test='printf(\"%d\", sys_nerr);'\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    # Cygiwn defines _sys_nerr\n    ngx_feature=\"_sys_nerr\"\n    ngx_feature_name=\"NGX_SYS_NERR\"\n    ngx_feature_run=value\n    ngx_feature_incs='#include <errno.h>\n                      #include <stdio.h>'\n    ngx_feature_path=\n    ngx_feature_libs=\n    ngx_feature_test='printf(\"%d\", _sys_nerr);'\n    . auto/feature\nfi\n\n\nif [ $ngx_found = no ]; then\n\n    # Solaris has no sys_nerr\n    ngx_feature='maximum errno'\n    ngx_feature_name=NGX_SYS_NERR\n    ngx_feature_run=value\n    ngx_feature_incs='#include <errno.h>\n                      #include <string.h>\n                      #include <stdio.h>'\n    ngx_feature_path=\n    ngx_feature_libs=\n    ngx_feature_test='int  n;\n                      char *p;\n                      for (n = 1; n < 1000; n++) {\n                          errno = 0;\n                          p = strerror(n);\n                          if (errno == EINVAL\n                              || p == NULL\n                              || strncmp(p, \"Unknown error\", 13) == 0)\n                          {\n                              break;\n                          }\n                      }\n                      printf(\"%d\", n);'\n    . auto/feature\nfi\n\n\nngx_feature=\"localtime_r()\"\nngx_feature_name=\"NGX_HAVE_LOCALTIME_R\"\nngx_feature_run=no\nngx_feature_incs=\"#include <time.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct tm t; time_t c=0; localtime_r(&c, &t)\"\n. auto/feature\n\n\nngx_feature=\"clock_gettime(CLOCK_MONOTONIC)\"\nngx_feature_name=\"NGX_HAVE_CLOCK_MONOTONIC\"\nngx_feature_run=no\nngx_feature_incs=\"#include <time.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts)\"\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    # Linux before glibc 2.17, notably CentOS 6\n\n    ngx_feature=\"clock_gettime(CLOCK_MONOTONIC) in librt\"\n    ngx_feature_libs=\"-lrt\"\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_LIBS=\"$CORE_LIBS -lrt\"\n    fi\nfi\n\n\nngx_feature=\"posix_memalign()\"\nngx_feature_name=\"NGX_HAVE_POSIX_MEMALIGN\"\nngx_feature_run=no\nngx_feature_incs=\"#include <stdlib.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"void *p; int n; n = posix_memalign(&p, 4096, 4096);\n                  if (n != 0) return 1\"\n. auto/feature\n\n\nngx_feature=\"memalign()\"\nngx_feature_name=\"NGX_HAVE_MEMALIGN\"\nngx_feature_run=no\nngx_feature_incs=\"#include <stdlib.h>\n                  #include <malloc.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"void *p; p = memalign(4096, 4096);\n                  if (p == NULL) return 1\"\n. auto/feature\n\n\nngx_feature=\"mmap(MAP_ANON|MAP_SHARED)\"\nngx_feature_name=\"NGX_HAVE_MAP_ANON\"\nngx_feature_run=yes\nngx_feature_incs=\"#include <sys/mman.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"void *p;\n                  p = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n                           MAP_ANON|MAP_SHARED, -1, 0);\n                  if (p == MAP_FAILED) return 1;\"\n. auto/feature\n\n\nngx_feature='mmap(\"/dev/zero\", MAP_SHARED)'\nngx_feature_name=\"NGX_HAVE_MAP_DEVZERO\"\nngx_feature_run=yes\nngx_feature_incs=\"#include <sys/mman.h>\n                  #include <sys/stat.h>\n                  #include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test='void *p; int  fd;\n                  fd = open(\"/dev/zero\", O_RDWR);\n                  p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n                  if (p == MAP_FAILED) return 1;'\n. auto/feature\n\n\nngx_feature=\"System V shared memory\"\nngx_feature_name=\"NGX_HAVE_SYSVSHM\"\nngx_feature_run=yes\nngx_feature_incs=\"#include <sys/ipc.h>\n                  #include <sys/shm.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"int  id;\n                  id = shmget(IPC_PRIVATE, 4096, (SHM_R|SHM_W|IPC_CREAT));\n                  if (id == -1) return 1;\n                  shmctl(id, IPC_RMID, NULL);\"\n. auto/feature\n\n\nngx_feature=\"POSIX semaphores\"\nngx_feature_name=\"NGX_HAVE_POSIX_SEM\"\nngx_feature_run=yes\nngx_feature_incs=\"#include <semaphore.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"sem_t  sem;\n                  if (sem_init(&sem, 1, 0) == -1) return 1;\n                  sem_destroy(&sem);\"\n. auto/feature\n\n\nif [ $ngx_found = no ]; then\n\n    # Linux has POSIX semaphores in libpthread\n    ngx_feature=\"POSIX semaphores in libpthread\"\n    ngx_feature_libs=-lpthread\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_LIBS=\"$CORE_LIBS -lpthread\"\n        NGX_LIBPTHREAD=\"-lpthread\"\n    fi\nfi\n\n\nif [ $ngx_found = no ]; then\n\n    # Solaris has POSIX semaphores in librt\n    ngx_feature=\"POSIX semaphores in librt\"\n    ngx_feature_libs=-lrt\n    . auto/feature\n\n    if [ $ngx_found = yes ]; then\n        CORE_LIBS=\"$CORE_LIBS -lrt\"\n    fi\nfi\n\n\nngx_feature=\"struct msghdr.msg_control\"\nngx_feature_name=\"NGX_HAVE_MSGHDR_MSG_CONTROL\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/socket.h>\n                  #include <stdio.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct msghdr  msg;\n                  printf(\\\"%d\\\", (int) sizeof(msg.msg_control))\"\n. auto/feature\n\n\nngx_feature=\"ioctl(FIONBIO)\"\nngx_feature_name=\"NGX_HAVE_FIONBIO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/ioctl.h>\n                  #include <stdio.h>\n                  $NGX_INCLUDE_SYS_FILIO_H\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"int i = FIONBIO; printf(\\\"%d\\\", i)\"\n. auto/feature\n\n\nngx_feature=\"struct tm.tm_gmtoff\"\nngx_feature_name=\"NGX_HAVE_GMTOFF\"\nngx_feature_run=no\nngx_feature_incs=\"#include <time.h>\n                  #include <stdio.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct tm  tm; tm.tm_gmtoff = 0;\n                  printf(\\\"%d\\\", (int) tm.tm_gmtoff)\"\n. auto/feature\n\n\nngx_feature=\"struct dirent.d_namlen\"\nngx_feature_name=\"NGX_HAVE_D_NAMLEN\"\nngx_feature_run=no\nngx_feature_incs=\"#include <dirent.h>\n                  #include <stdio.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct dirent  dir; dir.d_namlen = 0;\n                  printf(\\\"%d\\\", (int) dir.d_namlen)\"\n. auto/feature\n\n\nngx_feature=\"struct dirent.d_type\"\nngx_feature_name=\"NGX_HAVE_D_TYPE\"\nngx_feature_run=no\nngx_feature_incs=\"#include <dirent.h>\n                  #include <stdio.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct dirent  dir; dir.d_type = DT_REG;\n                  printf(\\\"%d\\\", (int) dir.d_type)\"\n. auto/feature\n\n\nngx_feature=\"sysconf(_SC_NPROCESSORS_ONLN)\"\nngx_feature_name=\"NGX_HAVE_SC_NPROCESSORS_ONLN\"\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"sysconf(_SC_NPROCESSORS_ONLN)\"\n. auto/feature\n\n\nngx_feature=\"sysconf(_SC_LEVEL1_DCACHE_LINESIZE)\"\nngx_feature_name=\"NGX_HAVE_LEVEL1_DCACHE_LINESIZE\"\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"sysconf(_SC_LEVEL1_DCACHE_LINESIZE)\"\n. auto/feature\n\n\nngx_feature=\"openat(), fstatat()\"\nngx_feature_name=\"NGX_HAVE_OPENAT\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/types.h>\n                  #include <sys/stat.h>\n                  #include <fcntl.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test=\"struct stat sb;\n                  openat(AT_FDCWD, \\\".\\\", O_RDONLY|O_NOFOLLOW);\n                  fstatat(AT_FDCWD, \\\".\\\", &sb, AT_SYMLINK_NOFOLLOW);\"\n. auto/feature\n\n\nngx_feature=\"getaddrinfo()\"\nngx_feature_name=\"NGX_HAVE_GETADDRINFO\"\nngx_feature_run=no\nngx_feature_incs=\"#include <sys/types.h>\n                  #include <sys/socket.h>\n                  #include <netdb.h>\"\nngx_feature_path=\nngx_feature_libs=\nngx_feature_test='struct addrinfo *res;\n                  if (getaddrinfo(\"localhost\", NULL, NULL, &res) != 0) return 1;\n                  freeaddrinfo(res)'\n. auto/feature\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/test.key.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/test.crt.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/chain/test-com.key.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/chain/chain.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/ocsp-resp-no-certs.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/ocsp-resp-signed-by-orphaned-no-certs.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/revoked-ocsp-resp.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/ocsp-resp-signed-by-orphaned.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/ocsp-resp.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-resty-core-0.1.17/t/cert/ocsp/ocsp-req.der",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/opm-0.0.5/web/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/lua-cjson-2.1.0.7/tests/octets-escaped.dat",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/LuaJIT-2.1-20190507/doc/img/contact.png",
        "/tmp/vanessa/spack-stage/spack-stage-openresty-1.15.8.2-pfvpp25cxqnur4lj67qku5d5mjnudw4r/spack-src/bundle/nginx-1.15.8/src/os/win32/nginx.ico"
    ],
    "total_files": 2345
}