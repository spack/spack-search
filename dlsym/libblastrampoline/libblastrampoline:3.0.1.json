{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-3.0.1-o6lxa2bafeudsssodm3gyzdleo42u7vm/spack-src/src/dl_utils.c": "#include \"libblastrampoline_internal.h\"\n\nvoid throw_dl_error(const char * path) {\n    fprintf(stderr, \"ERROR: Unable to load dependent library %s\\n\", path);\n#if defined(_OS_WINDOWS_)\n    LPWSTR wmsg = TEXT(\"\");\n    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                    FORMAT_MESSAGE_FROM_SYSTEM |\n                    FORMAT_MESSAGE_IGNORE_INSERTS |\n                    FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                    NULL, GetLastError(),\n                    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                    (LPWSTR)&wmsg, 0, NULL);\n    char err[256] = {0};\n    wchar_to_utf8(wmsg, err, 255);        \n#else\n    const char * err = dlerror();\n#endif\n    fprintf(stderr, \"Message: %s\\n\", err);\n}\n\n\n/*\n * Load the given `path`, using `RTLD_NOW | RTLD_LOCAL` and `RTLD_DEEPBIND`, if available\n */\nvoid * load_library(const char * path) {\n    void * new_handle = NULL;\n\n#if defined(_OS_WINDOWS_)\n    wchar_t wpath[2*PATH_MAX + 1] = {0};\n    if (!utf8_to_wchar(path, wpath, 2*PATH_MAX)) {\n        fprintf(stderr, \"ERROR: Unable to convert path %s to wide string!\\n\", path);\n        exit(1);\n    }\n    new_handle = (void *)LoadLibraryExW(wpath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    // If we have `RTLD_DEEPBIND`, use it!\n#if defined(RTLD_DEEPBIND)\n    new_handle = dlopen(path, RTLD_NOW | RTLD_LOCAL | RTLD_DEEPBIND);\n#else\n    new_handle = dlopen(path, RTLD_NOW | RTLD_LOCAL);\n#endif\n#endif\n    if (new_handle == NULL) {\n        throw_dl_error(path);\n    }\n    return new_handle;\n}\n\n/*\n * Close the given library handle\n */\nvoid close_library(void * handle) {\n#if defined(_OS_WINDOWS_)\n    FreeLibrary((HMODULE)handle);\n#else\n    dlclose(handle);\n#endif\n}\n\n/*\n * Look up the given symbol within the given library denoted by `handle`.\n */\nvoid * lookup_symbol(const void * handle, const char * symbol_name) {\n#if defined(_OS_WINDOWS_)\n    return GetProcAddress((HMODULE) handle, symbol_name);\n#else\n    return dlsym((void *)handle, symbol_name);\n#endif\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-3.0.1-o6lxa2bafeudsssodm3gyzdleo42u7vm/spack-src/src/libblastrampoline.h": "#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// This shamelessly stolen from https://github.com/JuliaLang/julia/blob/master/src/support/platform.h\n#if defined(__FreeBSD__)\n#define _OS_FREEBSD_\n#elif defined(__linux__)\n#define _OS_LINUX_\n#elif defined(_WIN32) || defined(_WIN64)\n#define _OS_WINDOWS_\n#elif defined(__APPLE__) && defined(__MACH__)\n#define _OS_DARWIN_\n#elif defined(__EMSCRIPTEN__)\n#define _OS_EMSCRIPTEN_\n#endif\n\n// Borrow definition from `support/dtypes.h`\n#ifdef _OS_WINDOWS_\n# ifdef LIBRARY_EXPORTS\n#  define LBT_DLLEXPORT __declspec(dllexport)\n# else\n#  define LBT_DLLEXPORT __declspec(dllimport)\n# endif\n# define LBT_HIDDEN\n#else\n# if defined(LIBRARY_EXPORTS) && defined(_OS_LINUX)\n#  define LBT_DLLEXPORT __attribute__ ((visibility(\"protected\")))\n# else\n#  define LBT_DLLEXPORT __attribute__ ((visibility(\"default\")))\n# endif\n# define LBT_HIDDEN    __attribute__ ((visibility(\"hidden\")))\n#endif\n\n#define BF_CHUNK(array, idx)           (array[((uint32_t)(idx/8))])\n#define BF_MASK(idx)                   ((uint8_t)(0x1 << (idx % 8)))\n#define BITFIELD_GET(array, idx)      ((BF_CHUNK(array, idx) &  BF_MASK(idx)) >> (idx % 8))\n#define BITFIELD_CLEAR(array, idx)      BF_CHUNK(array, idx) &= ~(BF_MASK(idx))\n#define BITFIELD_SET(array, idx)        BF_CHUNK(array, idx) |=   BF_MASK(idx)\n\n\n// The metadata stored on each loaded library\ntypedef struct {\n    // The library name as passed to `lbt_forward()`.\n    // To get the absolute path to the library, use `dlpath()` or similar on `handle`.\n    char * libname;\n    void * handle;\n    // The suffix used within this library as autodetected by `lbt_forward`.\n    // Common values are `\"\"` or `\"64_\"`.\n    const char * suffix;\n    // bitfield (in uint8_t form) representing the active forwards for this library.\n    // Use the `BITFIELD_{SET,GET}` macros to look at particular indices within this field.\n    // Note that if you use the footgun API (e.g. \"lbt_set_forward()\") these values will be\n    // zeroed out and you must track them manually if you need to.\n    uint8_t * active_forwards;\n    // The interface type  as autodetected by `lbt_forward`, see `LBT_INTERFACE_XXX` below\n    int32_t interface;\n    // The `f2c` status  as autodetected by `lbt_forward`, see `LBT_F2C_XXX` below\n    int32_t f2c;\n} lbt_library_info_t;\n\n// Possible values for `interface` in `lbt_library_info_t`\n#define LBT_INTERFACE_LP64              32\n#define LBT_INTERFACE_ILP64             64\n#define LBT_INTERFACE_UNKNOWN          -1\n\n// Possible values for `f2c` in `lbt_library_info_t`\n#define LBT_F2C_PLAIN                   0\n#define LBT_F2C_REQUIRED                1\n#define LBT_F2C_UNKNOWN                -1\n\n// The config type you get back from `lbt_get_config()`\ntypedef struct {\n    // The NULL-terminated list of libraries loaded via `lbt_forward()`.\n    // This list is emptied if `clear` is set to `1` in a future `lbt_forward()` call.\n    lbt_library_info_t ** loaded_libs;\n    // Flags that describe this `libblastrampoline`'s build configuration.\n    // See `LBT_BUILDFLAGS_XXX` below.\n    uint32_t build_flags;\n    // The names of the symbols that we export.  We do not list both `dgemm_` and `dgemm_64_`, just `dgemm_`.\n    const char ** exported_symbols;\n    uint32_t num_exported_symbols;\n} lbt_config_t;\n\n// Possible values for `build_flags` in `lbt_config_t`\n#define LBT_BUILDFLAGS_DEEPBINDLESS     0x01\n#define LBT_BUILDFLAGS_F2C_CAPABLE      0x02\n\n/*\n * Load the given `libname`, lookup all registered symbols within our configured list of exported\n * symbols and `dlsym()` the symbols to load the addresses for forwarding into that library.\n *\n * If `clear` is set to a non-zero value, all symbol addresses will be reset to a pre-set value\n * before they are looked up in `libname`.  If `clear` is set to zero, symbols that do not exist in\n * `libname` will keep their previous value, which allows for loading a base library, then overriding\n * some symbols with a second shim library, integrating separate BLAS and LAPACK libraries, merging an\n * LP64 and ILP64 library into one, or all three use cases at the same time.  See the docstring for\n * `lbt_set_default_func` for how to control what `clear` sets.\n *\n * Note that on certain platforms (currently musl linux and freebsd) you cannot load a non-suffixed\n * ILP64 and an LP64 BLAS at the same time.  Read the note in the README about `RTLD_DEEPBIND`\n * support in the system libc for more details.\n *\n * If `verbose` is set to a non-zero value, it will print out debugging information.\n */\nLBT_DLLEXPORT int32_t lbt_forward(const char * libname, int32_t clear, int32_t verbose);\n\n/*\n * Returns a structure describing the currently-loaded libraries as well as the build configuration\n * of this `libblastrampoline` instance.  See the definition of `lbt_config_t` in this header file\n * for more details.\n */\nLBT_DLLEXPORT const lbt_config_t * lbt_get_config();\n\n/*\n * Returns the number of threads configured by the underlying BLAS library.  In the event that\n * multiple libraries are loaded, returns the maximum over all returned values.  The functions\n * it calls to determine the number of threads are configurable at runtime, see the docstring\n * for the `lbt_register_thread_interface()` function, although many common functions (such as\n * those for `OpenBLAS`, `MKL` and `BLIS`) are already registered by default.\n */\nLBT_DLLEXPORT int32_t lbt_get_num_threads();\n\n/*\n * Sets the number of threads in the underlying BLAS library.  In the event that multiple\n * libraries are loaded, sets them all to the same value.  The functions it calls to actually\n * set the number of threads are configurable at runtime, see the docstring for the\n * `lbt_register_thread_interface()` function, although many common functions (such as those\n * for `OpenBLAS`, `MKL` and `BLIS`) are already registered by default.\n */\nLBT_DLLEXPORT void lbt_set_num_threads(int32_t num_threads);\n\n/*\n * Register a new `get_num_threads()`/`set_num_threads()` pair.  These functions are assumed to be\n * callable via the function prototypes `int32_t getter()` and `void setter(int32_t num_threads)`.\n * Note that due to register zero-extension on `x86_64` it is permissible that the setter actually\n * expects an `int64_t`, and the getter may return an `int64_t` as long as the value itself is not\n * larger than the maximum permissable `int64_t`.\n *\n * While `libblastrampoline` has built-in knowledge of some BLAS libraries' getter/setter\n * functions (such as those for `OpenBLAS`, `MKL` and `BLIS`) and will call them from\n * `lbt_{get,set}_num_threads()`, if the user loads some exotic BLAS that uses a different symbol\n * name for this functionality, they must register those getter/setter functions here to have them\n * automatically called whenever `lbt_{get,set}_num_threads()` is called.\n */\nLBT_DLLEXPORT void lbt_register_thread_interface(const char * getter, const char * setter);\n\n/*\n * Function that simply prints out to `stderr` that someone called an uninitialized function.\n * This is the default default function, see `lbt_set_default_func()` for how to override it.\n */\nLBT_DLLEXPORT void lbt_default_func_print_error();\n\n/*\n * Returns the currently-configured default function that gets called if no mapping has been set\n * for an exported symbol.  Can return `NULL` if it was set as the default function.\n */\nLBT_DLLEXPORT const void * lbt_get_default_func();\n\n/*\n * Sets the default function that gets called if no mapping has been set for an exported symbol.\n * `NULL` is a valid address, if a segfault upon calling an uninitialized function is desirable.\n * Note that this will not be retroactively applied to already-set pointers, so you should call\n * this function immediately before calling `lbt_forward()` with `clear` set.\n */\nLBT_DLLEXPORT void lbt_set_default_func(const void * addr);\n\n/*\n * Returns the currently-configured forward target for the given `symbol_name`, according to the\n * requested `interface`.  If `f2c` is set to `LBT_F2C_REQUIRED`, then if there is an f2c\n * workaround shim in effect for this symbol, this method will thread through that to return the\n * \"true\" symbol address.  If `f2c` is set to any other value, then if there is an f2c workaround\n * shim in effect, the address of the shim will be returned.  (This allows passing this address\n * to a 3rd party library which does not want to have to deal with f2c conversion, for instance).\n * If this is not an f2c-capable LBT build, `f2c` is ignored completely.\n */\nLBT_DLLEXPORT const void * lbt_get_forward(const char * symbol_name, int32_t interface, int32_t f2c);\n\n/*\n * Allows directly setting a symbol to be forwarded to a particular address, for the given\n * interface.  If `f2c` is set to `LBT_F2C_REQUIRED` and this is an f2c-capable LBT build, an\n * f2c wrapper function will be interposed between the exported symbol and the targeted address.\n * If `verbose` is set to a non-zero value, status messages will be printed out to `stdout`.\n * If `addr` is set to `NULL` it will be set as the default function, see `lbt_set_default_func()`\n * for how to set the default function pointer.\n */\nLBT_DLLEXPORT int32_t lbt_set_forward(const char * symbol_name, const void * addr, int32_t interface, int32_t f2c, int32_t verbose);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-3.0.1-o6lxa2bafeudsssodm3gyzdleo42u7vm/spack-src/test/direct.jl": "using Libdl, Test, OpenBLAS_jll, OpenBLAS32_jll\n\ninclude(\"utils.jl\")\n\nfunction unpack_loaded_libraries(config::lbt_config_t)\n    libs = LBTLibraryInfo[]\n    idx = 1\n    lib_ptr = unsafe_load(config.loaded_libs, idx)\n    while lib_ptr != C_NULL\n        push!(libs, LBTLibraryInfo(unsafe_load(lib_ptr), config.num_exported_symbols))\n\n        idx += 1\n        lib_ptr = unsafe_load(config.loaded_libs, idx)\n    end\n    return libs\nend\n\nfunction find_symbol_offset(config::lbt_config_t, symbol::String)\n    for sym_idx in 1:config.num_exported_symbols\n        if unsafe_string(unsafe_load(config.exported_symbols, sym_idx)) == symbol\n            return UInt32(sym_idx - 1)\n        end\n    end\n    return nothing\nend\n\nfunction bitfield_get(field::Vector{UInt8}, symbol_idx::UInt32)\n    return field[div(symbol_idx,8)+1] & (UInt8(0x01) << (symbol_idx%8))\nend\n\nlbt_prefix = get_blastrampoline_dir()\nlbt_handle = dlopen(\"$(lbt_prefix)/$(binlib)/libblastrampoline.$(shlib_ext)\", RTLD_GLOBAL | RTLD_DEEPBIND)\n\n@testset \"Config\" begin\n    @test lbt_handle != C_NULL\n\n    # Get immediate config, ensure that nothing is loaded\n    config = lbt_get_config(lbt_handle)\n    @test isempty(unpack_loaded_libraries(config))\n\n    # Load OpenBLAS and OpenBLAS32_jll and then OpenBLAS_jll again\n    lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path; clear=true)\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path)\n    lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path)\n\n    # Get config\n    config = lbt_get_config(lbt_handle)\n\n    # If we're x86_64, ensure LBT thinks it's f2c-adapter capable\n    if Sys.ARCH == :x86_64\n        @test (config.build_flags & LBT_BUILDFLAGS_F2C_CAPABLE) != 0\n    end\n\n    # Check to make sure that `dgemm_` is part of the exported symbols:\n    dgemm_idx = find_symbol_offset(config, \"dgemm_\")\n    @test dgemm_idx !== nothing\n\n    # Walk the libraries and check we have two\n    libs = unpack_loaded_libraries(config)\n    @test length(libs) == 2\n\n    # First check OpenBLAS_jll which may or may not be ILP64\n    @test libs[1].libname == OpenBLAS_jll.libopenblas_path\n    if Sys.WORD_SIZE == 64 && Sys.ARCH != :aarch64\n        @test libs[1].suffix == \"64_\"\n        @test libs[1].interface == LBT_INTERFACE_ILP64\n    else\n        @test libs[1].suffix == \"\"\n        @test libs[1].interface == LBT_INTERFACE_LP64\n    end\n    @test libs[1].f2c == LBT_F2C_PLAIN\n    @test bitfield_get(libs[1].active_forwards, dgemm_idx) != 0\n\n    # Next check OpenBLAS32_jll which is always LP64\n    @test libs[2].libname == OpenBLAS32_jll.libopenblas_path\n    @test libs[2].suffix == \"\"\n    @test libs[2].interface == LBT_INTERFACE_LP64\n    @test libs[2].f2c == LBT_F2C_PLAIN\n\n    # If OpenBLAS32 and OpenBLAS are the same interface (e.g. i686)\n    # then libs[2].active_forwards should be all zero!\n    if libs[1].interface == libs[2].interface\n        @test bitfield_get(libs[2].active_forwards, dgemm_idx) == 0\n    else\n        @test bitfield_get(libs[2].active_forwards, dgemm_idx) != 0\n    end\n\n    # Load OpenBLAS32_jll again, but this time clearing it and ensure the config gets cleared too\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n    config = lbt_get_config(lbt_handle)\n    libs = unpack_loaded_libraries(config)\n    @test length(libs) == 1\n    @test libs[1].libname == OpenBLAS32_jll.libopenblas_path\n    @test libs[1].suffix == \"\"\n    @test libs[1].interface == LBT_INTERFACE_LP64\n    @test libs[1].f2c == LBT_F2C_PLAIN\nend\n\n@testset \"get/set threads\" begin\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n\n    # get/set threads\n    nthreads = ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ())\n    @test lbt_get_num_threads(lbt_handle) == nthreads\n    nthreads = div(nthreads, 2)\n    lbt_set_num_threads(lbt_handle, nthreads)\n    @test ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ()) == nthreads\n    @test lbt_get_num_threads(lbt_handle) == nthreads\n\n    # If we're on a 64-bit system, load OpenBLAS_jll in and cause a mismatch in the threading\n    if Sys.WORD_SIZE == 64 && Sys.ARCH != :aarch64\n        lbt_forward(lbt_handle, OpenBLAS_jll.libopenblas_path)\n\n        lbt_set_num_threads(lbt_handle, 1)\n        @test lbt_get_num_threads(lbt_handle) == 1\n        @test ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_get_num_threads), Cint, ()) == 1\n\n        ccall(dlsym(OpenBLAS32_jll.libopenblas_handle, :openblas_set_num_threads), Cvoid, (Cint,), 2)\n        @test lbt_get_num_threads(lbt_handle) == 2\n        lbt_set_num_threads(lbt_handle, 1)\n        @test lbt_get_num_threads(lbt_handle) == 1\n    end\nend\n\nslamch_args = []\nfunction record_slamch_args(str::Cstring)\n    push!(slamch_args, unsafe_string(str))\n    return 13.37f0\nend\n\n# This \"default function\" will keep track of everyone who tries to call an uninitialized BLAS function\nstacktraces = []\nfunction default_capture_stacktrace()\n    push!(stacktraces, stacktrace(true))\n    return nothing\nend\n\n@testset \"footgun API\" begin\n    # Load OpenBLAS32\n    lbt_forward(lbt_handle, OpenBLAS32_jll.libopenblas_path; clear=true)\n\n    # Test that we can get the `dgemm_` symbol address, and that it is what we expect\n    slamch_32 = dlsym(OpenBLAS32_jll.libopenblas_handle, :slamch_)\n    @test slamch_32 != C_NULL\n    @test lbt_get_forward(lbt_handle, \"slamch_\", LBT_INTERFACE_LP64) == slamch_32\n\n    # Ensure that the libs show that `slamch_` is forwarded by this library:\n    config = lbt_get_config(lbt_handle)\n    libs = unpack_loaded_libraries(config)\n    @test length(libs) == 1\n\n    slamch_idx = find_symbol_offset(config, \"slamch_\")\n    @test slamch_idx !== nothing\n    @test bitfield_get(libs[1].active_forwards, slamch_idx) != 0\n    orig_forwards = copy(libs[1].active_forwards)\n\n    # Now, test that we can muck this up\n    my_slamch = @cfunction(record_slamch_args, Float32, (Cstring,))\n    @test lbt_set_forward(lbt_handle, \"slamch_\", my_slamch, LBT_INTERFACE_LP64) == 0\n    @test lbt_get_forward(lbt_handle, \"slamch_\", LBT_INTERFACE_LP64) == my_slamch\n\n    config = lbt_get_config(lbt_handle)\n    libs = unpack_loaded_libraries(config)\n    @test bitfield_get(libs[1].active_forwards, slamch_idx) == 0\n\n    # Ensure that we actually overrode the symbol\n    @test ccall(dlsym(lbt_handle, \"slamch_\"), Float32, (Cstring,), \"test\") == 13.37f0\n    @test slamch_args == [\"test\"]\n\n    # Override the default function to keep track of people who try to call uninitialized BLAS functions\n    @test lbt_get_default_func(lbt_handle) != C_NULL\n    my_default_func = @cfunction(default_capture_stacktrace, Cvoid, ())\n    lbt_set_default_func(lbt_handle, my_default_func)\n    @test lbt_get_default_func(lbt_handle) == my_default_func\n\n    # Now, set `slamch_64_` to it\n    @test lbt_set_forward(lbt_handle, \"slamch_\", C_NULL, LBT_INTERFACE_ILP64) == 0\n    ccall(dlsym(lbt_handle, \"slamch_64_\"), Float32, (Cstring,), \"this will call the default function\")\n    @test length(stacktraces) == 1\n    self_traces = filter(entry -> string(entry.file) == @__FILE__, stacktraces[1])\n    @test length(self_traces) == 3\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-libblastrampoline-3.0.1-o6lxa2bafeudsssodm3gyzdleo42u7vm/spack-src/test/utils.jl": "if Sys.iswindows()\n    LIBPATH_env = \"PATH\"\n    LIBPATH_default = \"\"\n    pathsep = ';'\n    binlib = \"bin\"\n    shlib_ext = \"dll\"\nelseif Sys.isapple()\n    LIBPATH_env = \"DYLD_FALLBACK_LIBRARY_PATH\"\n    LIBPATH_default = \"~/lib:/usr/local/lib:/lib:/usr/lib\"\n    pathsep = ':'\n    binlib = \"lib\"\n    shlib_ext = \"dylib\"\nelse\n    LIBPATH_env = \"LD_LIBRARY_PATH\"\n    LIBPATH_default = \"\"\n    pathsep = ':'\n    binlib = \"lib\"\n    shlib_ext = \"so\"\nend\n\nfunction append_libpath(paths::Vector{<:AbstractString})\n    return join(vcat(paths..., get(ENV, LIBPATH_env, String[])), pathsep)\nend\n\nfunction capture_output(cmd::Cmd; verbose::Bool = false)\n    out_pipe = Pipe()\n    if verbose\n        ld_env = filter(e -> startswith(e, \"LBT_\") || startswith(e, \"LD_\") || startswith(e, \"DYLD_\"), something(cmd.env, String[]))\n        @info(\"Running $(basename(cmd.exec[1]))\", ld_env)\n    end\n    p = run(pipeline(ignorestatus(cmd), stdout=out_pipe, stderr=out_pipe), wait=false)\n    close(out_pipe.in)\n    output = @async read(out_pipe, String)\n    wait(p)\n    return fetch(output)\nend\n\ncc = something(\n    get(ENV, \"CC\", nothing),\n    Sys.which(\"cc\"),\n    Sys.which(\"gcc\"),\n    Sys.which(\"clang\"),\n)\n\n# Escape paths on windows by using forward slash so we don't get into escaping hell\npathesc(path::String) = replace(path, \"\\\\\" => \"/\")\n\n@static if Sys.isfreebsd()\n    make = \"gmake\"\nelse\n    make = \"make\"\nend\n\nneeds_m32() = startswith(capture_output(`$(cc) -dumpmachine`), \"x86_64\") && Sys.WORD_SIZE == 32\n\n\n# Build blastrampoline into a temporary directory, and return that\nblastrampoline_build_dir = nothing\nfunction get_blastrampoline_dir()\n    if blastrampoline_build_dir !== nothing\n        return blastrampoline_build_dir\n    end\n\n    cflags_add = needs_m32() ? \"-m32\" : \"\"\n    dir = mktempdir()\n    srcdir = joinpath(dirname(@__DIR__), \"src\")\n    run(`$(make) -sC $(pathesc(srcdir)) CFLAGS_add=$(cflags_add) ARCH=$(Sys.ARCH) clean`)\n    run(`$(make) -sC $(pathesc(srcdir)) CFLAGS_add=$(cflags_add) ARCH=$(Sys.ARCH) install builddir=$(pathesc(dir))/build prefix=$(pathesc(dir))/output`)\n    global blastrampoline_build_dir = joinpath(dir, \"output\")\n    return blastrampoline_build_dir\nend\n\n\n# Keep these in sync with `src/libblastrampoline_internal.h`\nstruct lbt_library_info_t\n    libname::Cstring\n    handle::Ptr{Cvoid}\n    suffix::Cstring\n    active_forwards::Ptr{UInt8}\n    interface::Int32\n    f2c::Int32\nend\nstruct LBTLibraryInfo\n    libname::String\n    handle::Ptr{Cvoid}\n    suffix::String\n    active_forwards::Vector{UInt8}\n    interface::Int32\n    f2c::Int32\n\n    LBTLibraryInfo(x::lbt_library_info_t, num_symbols::UInt32) = new(unsafe_string(x.libname), x.handle, unsafe_string(x.suffix), unsafe_wrap(Vector{UInt8}, x.active_forwards, div(num_symbols,8)+1), x.interface, x.f2c)\nend\nconst LBT_INTERFACE_LP64 = 32\nconst LBT_INTERFACE_ILP64 = 64\nconst LBT_F2C_PLAIN = 0\n\nstruct lbt_config_t\n    loaded_libs::Ptr{Ptr{lbt_library_info_t}}\n    build_flags::UInt32\n    exported_symbols::Ptr{Cstring}\n    num_exported_symbols::UInt32\nend\nconst LBT_BUILDFLAGS_F2C_CAPABLE = 0x02\n\nfunction lbt_forward(handle, path; clear::Bool = false, verbose::Bool = false)\n    ccall(dlsym(handle, :lbt_forward), Int32, (Cstring, Int32, Int32), path, clear ? 1 : 0, verbose ? 1 : 0)\nend\n\nfunction lbt_get_config(handle)\n    return unsafe_load(ccall(dlsym(handle, :lbt_get_config), Ptr{lbt_config_t}, ()))\nend\n\nfunction lbt_get_num_threads(handle)\n    return ccall(dlsym(handle, :lbt_get_num_threads), Int32, ())\nend\n\nfunction lbt_set_num_threads(handle, nthreads)\n    return ccall(dlsym(handle, :lbt_set_num_threads), Cvoid, (Int32,), nthreads)\nend\n\nfunction lbt_get_forward(handle, symbol_name, interface, f2c = LBT_F2C_PLAIN)\n    return ccall(dlsym(handle, :lbt_get_forward), Ptr{Cvoid}, (Cstring, Int32, Int32), symbol_name, interface, f2c)\nend\n\nfunction lbt_set_forward(handle, symbol_name, addr, interface, f2c = LBT_F2C_PLAIN; verbose::Bool = false)\n    return ccall(dlsym(handle, :lbt_set_forward), Int32, (Cstring, Ptr{Cvoid}, Int32, Int32, Int32), symbol_name, addr, interface, f2c, verbose ? 1 : 0)\nend\n\nfunction lbt_set_default_func(handle, addr)\n    return ccall(dlsym(handle, :lbt_set_default_func), Cvoid, (Ptr{Cvoid},), addr)\nend\n\nfunction lbt_get_default_func(handle)\n    return ccall(dlsym(handle, :lbt_get_default_func), Ptr{Cvoid}, ())\nend"
    },
    "skipped": [],
    "total_files": 272
}