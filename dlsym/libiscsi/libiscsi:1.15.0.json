{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libiscsi-1.15.0-dqtrqlklpgkgp5tplkzmraegqzguvvtw/spack-src/test-tool/iscsi-test-cu.c": "/*\n   iscsi-test tool\n\n   Copyright (C) 2012 by Lee Duncan <lee@gonzoleeman.net>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"config.h\"\n\n#define _GNU_SOURCE\n#include <sys/syscall.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <string.h>\n#include <getopt.h>\n#include <fnmatch.h>\n#include <ctype.h>\n\n#ifdef HAVE_SG_IO\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <scsi/sg.h>\n#include <sys/mount.h>\n#endif\n\n#include <CUnit/CUnit.h>\n#include <CUnit/Basic.h>\n#include <CUnit/Automated.h>\n\n#include \"iscsi.h\"\n#include \"scsi-lowlevel.h\"\n#include \"iscsi-private.h\"\n\n#include \"iscsi-support.h\"\n#include \"iscsi-test-cu.h\"\n#include \"iscsi-support.h\"\n#include \"iscsi-multipath.h\"\n\n#define\tPROG\t\"iscsi-test-cu\"\n\nint loglevel = LOG_NORMAL;\nstruct scsi_device *sd = NULL;\t/* mp_sds[0] alias */\nstatic unsigned int maxsectbytes;\n\n/*\n * this allows us to redefine how PDU are queued, at times, for\n * testing purposes\n */\nint (*real_iscsi_queue_pdu)(struct iscsi_context *iscsi, struct iscsi_pdu *pdu);\n\n/*****************************************************************\n *\n * list of tests and test suites\n *\n *****************************************************************/\nstatic CU_TestInfo tests_compareandwrite[] = {\n\t{ (char *)\"Simple\", test_compareandwrite_simple },\n\t{ (char *)\"DpoFua\", test_compareandwrite_dpofua },\n\t{ (char *)\"Miscompare\", test_compareandwrite_miscompare },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_get_lba_status[] = {\n\t{ (char *)\"Simple\", test_get_lba_status_simple },\n\t{ (char *)\"BeyondEol\", test_get_lba_status_beyond_eol },\n\t{ (char *)\"UnmapSingle\", test_get_lba_status_unmap_single },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_inquiry[] = {\n\t{ (char *)\"Standard\", test_inquiry_standard },\n\t{ (char *)\"AllocLength\", test_inquiry_alloc_length},\n\t{ (char *)\"EVPD\", test_inquiry_evpd},\n\t{ (char *)\"BlockLimits\", test_inquiry_block_limits},\n\t{ (char *)\"MandatoryVPDSBC\", test_inquiry_mandatory_vpd_sbc},\n\t{ (char *)\"SupportedVPD\", test_inquiry_supported_vpd},\n\t{ (char *)\"VersionDescriptors\", test_inquiry_version_descriptors},\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_mandatory[] = {\n\t{ (char *)\"MandatorySBC\", test_mandatory_sbc },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_modesense6[] = {\n\t{ (char *)\"AllPages\", test_modesense6_all_pages },\n\t{ (char *)\"Control\", test_modesense6_control },\n\t{ (char *)\"Control-D_SENSE\", test_modesense6_control_d_sense },\n\t{ (char *)\"Control-SWP\", test_modesense6_control_swp },\n\t{ (char *)\"Residuals\", test_modesense6_residuals },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_nomedia[] = {\n\t{ (char *)\"NoMediaSBC\", test_nomedia_sbc },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_orwrite[] = {\n\t{ (char *)\"Simple\", test_orwrite_simple },\n\t{ (char *)\"BeyondEol\", test_orwrite_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_orwrite_0blocks },\n\t{ (char *)\"Protect\", test_orwrite_wrprotect },\n\t{ (char *)\"DpoFua\", test_orwrite_dpofua },\n\t{ (char *)\"Verify\", test_orwrite_verify },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prefetch10[] = {\n\t{ (char *)\"Simple\", test_prefetch10_simple },\n\t{ (char *)\"BeyondEol\", test_prefetch10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_prefetch10_0blocks },\n\t{ (char *)\"Flags\", test_prefetch10_flags },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prefetch16[] = {\n\t{ (char *)\"Simple\", test_prefetch16_simple },\n\t{ (char *)\"BeyondEol\", test_prefetch16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_prefetch16_0blocks },\n\t{ (char *)\"Flags\", test_prefetch16_flags },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_preventallow[] = {\n\t{ (char *)\"Simple\", test_preventallow_simple },\n\t{ (char *)\"Eject\", test_preventallow_eject },\n\t{ (char *)\"ITNexusLoss\", test_preventallow_itnexus_loss },\n\t{ (char *)\"Logout\", test_preventallow_logout },\n\t{ (char *)\"WarmReset\", test_preventallow_warm_reset },\n\t{ (char *)\"ColdReset\", test_preventallow_cold_reset },\n\t{ (char *)\"LUNReset\", test_preventallow_lun_reset },\n\t{ (char *)\"2ITNexuses\", test_preventallow_2_itnexuses },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prin_read_keys[] = {\n\t{ (char *)\"Simple\", test_prin_read_keys_simple },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_register[] = {\n\t{ (char *)\"Simple\", test_prout_register_simple },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_reserve[] = {\n\t{ (char *)\"Simple\",\n\t  test_prout_reserve_simple },\n\t{ (char *)\"AccessEA\",\n\t  test_prout_reserve_access_ea },\n\t{ (char *)\"AccessWE\",\n\t  test_prout_reserve_access_we },\n\t{ (char *)\"AccessEARO\",\n\t  test_prout_reserve_access_earo },\n\t{ (char *)\"AccessWERO\",\n\t  test_prout_reserve_access_wero },\n\t{ (char *)\"AccessEAAR\",\n\t  test_prout_reserve_access_eaar },\n\t{ (char *)\"AccessWEAR\",\n\t  test_prout_reserve_access_wear },\n\t{ (char *)\"OwnershipEA\",\n\t  test_prout_reserve_ownership_ea },\n\t{ (char *)\"OwnershipWE\",\n\t  test_prout_reserve_ownership_we },\n\t{ (char *)\"OwnershipEARO\",\n\t  test_prout_reserve_ownership_earo },\n\t{ (char *)\"OwnershipWERO\",\n\t  test_prout_reserve_ownership_wero },\n\t{ (char *)\"OwnershipEAAR\",\n\t  test_prout_reserve_ownership_eaar },\n\t{ (char *)\"OwnershipWEAR\",\n\t  test_prout_reserve_ownership_wear },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prin_serviceaction_range[] = {\n\t{ (char *)\"Range\", test_prin_serviceaction_range },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read6[] = {\n\t{ (char *)\"Simple\", test_read6_simple },\n\t{ (char *)\"BeyondEol\", test_read6_beyond_eol },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read10[] = {\n\t{ (char *)\"Simple\", test_read10_simple },\n\t{ (char *)\"BeyondEol\", test_read10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_read10_0blocks },\n\t{ (char *)\"ReadProtect\", test_read10_rdprotect },\n\t{ (char *)\"DpoFua\", test_read10_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read12[] = {\n\t{ (char *)\"Simple\", test_read12_simple },\n\t{ (char *)\"BeyondEol\", test_read12_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_read12_0blocks },\n\t{ (char *)\"ReadProtect\", test_read12_rdprotect },\n\t{ (char *)\"DpoFua\", test_read12_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read16[] = {\n\t{ (char *)\"Simple\", test_read16_simple },\n\t{ (char *)\"BeyondEol\", test_read16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_read16_0blocks },\n\t{ (char *)\"ReadProtect\", test_read16_rdprotect },\n\t{ (char *)\"DpoFua\", test_read16_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readcapacity10[] = {\n\t{ (char *)\"Simple\", test_readcapacity10_simple },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readcapacity16[] = {\n\t{ (char *)\"Simple\", test_readcapacity16_simple },\n\t{ (char *)\"Alloclen\", test_readcapacity16_alloclen },\n\t{ (char *)\"PI\", test_readcapacity16_protection },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readonly[] = {\n\t{ (char *)\"ReadOnlySBC\", test_readonly_sbc },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_sanitize[] = {\n\t{ (char *)\"BlockErase\", test_sanitize_block_erase },\n\t{ (char *)\"BlockEraseReserved\", test_sanitize_block_erase_reserved },\n\t{ (char *)\"CryptoErase\", test_sanitize_crypto_erase },\n\t{ (char *)\"CryptoEraseReserved\", test_sanitize_crypto_erase_reserved },\n\t{ (char *)\"ExitFailureMode\", test_sanitize_exit_failure_mode },\n\t{ (char *)\"InvalidServiceAction\", test_sanitize_invalid_serviceaction },\n\t{ (char *)\"Overwrite\", test_sanitize_overwrite },\n\t{ (char *)\"OverwriteReserved\", test_sanitize_overwrite_reserved },\n\t{ (char *)\"Readonly\", test_sanitize_readonly },\n\t{ (char *)\"Reservations\", test_sanitize_reservations },\n\t{ (char *)\"Reset\", test_sanitize_reset },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_report_supported_opcodes[] = {\n\t{ (char *)\"Simple\", test_report_supported_opcodes_simple },\n\t{ (char *)\"OneCommand\", test_report_supported_opcodes_one_command },\n\t{ (char *)\"RCTD\", test_report_supported_opcodes_rctd },\n\t{ (char *)\"SERVACTV\", test_report_supported_opcodes_servactv },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_reserve6[] = {\n\t{ (char *)\"Simple\", test_reserve6_simple },\n\t{ (char *)\"2Initiators\", test_reserve6_2initiators },\n\t{ (char *)\"Logout\", test_reserve6_logout },\n\t{ (char *)\"ITNexusLoss\", test_reserve6_itnexus_loss },\n\t{ (char *)\"TargetColdReset\", test_reserve6_target_cold_reset },\n\t{ (char *)\"TargetWarmReset\", test_reserve6_target_warm_reset },\n\t{ (char *)\"LUNReset\", test_reserve6_lun_reset },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_testunitready[] = {\n\t{ (char *)\"Simple\", test_testunitready_simple },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_startstopunit[] = {\n\t{ (char *)\"Simple\", test_startstopunit_simple },\n\t{ (char *)\"PwrCnd\", test_startstopunit_pwrcnd },\n\t{ (char *)\"NoLoej\", test_startstopunit_noloej },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_unmap[] = {\n\t{ (char *)\"Simple\", test_unmap_simple },\n\t{ (char *)\"VPD\", test_unmap_vpd },\n\t{ (char *)\"ZeroBlocks\", test_unmap_0blocks },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify10[] = {\n\t{ (char *)\"Simple\", test_verify10_simple },\n\t{ (char *)\"BeyondEol\", test_verify10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_verify10_0blocks },\n\t{ (char *)\"VerifyProtect\", test_verify10_vrprotect },\n\t{ (char *)\"Flags\", test_verify10_flags },\n\t{ (char *)\"Dpo\", test_verify10_dpo },\n\t{ (char *)\"Mismatch\", test_verify10_mismatch },\n\t{ (char *)\"MismatchNoCmp\", test_verify10_mismatch_no_cmp },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify12[] = {\n\t{ (char *)\"Simple\", test_verify12_simple },\n\t{ (char *)\"BeyondEol\", test_verify12_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_verify12_0blocks },\n\t{ (char *)\"VerifyProtect\", test_verify12_vrprotect },\n\t{ (char *)\"Flags\", test_verify12_flags },\n\t{ (char *)\"Dpo\", test_verify12_dpo },\n\t{ (char *)\"Mismatch\", test_verify12_mismatch },\n\t{ (char *)\"MismatchNoCmp\", test_verify12_mismatch_no_cmp },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify16[] = {\n\t{ (char *)\"Simple\", test_verify16_simple },\n\t{ (char *)\"BeyondEol\", test_verify16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_verify16_0blocks },\n\t{ (char *)\"VerifyProtect\", test_verify16_vrprotect },\n\t{ (char *)\"Flags\", test_verify16_flags },\n\t{ (char *)\"Dpo\", test_verify16_dpo },\n\t{ (char *)\"Mismatch\", test_verify16_mismatch },\n\t{ (char *)\"MismatchNoCmp\", test_verify16_mismatch_no_cmp },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write10[] = {\n\t{ (char *)\"Simple\", test_write10_simple },\n\t{ (char *)\"BeyondEol\", test_write10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_write10_0blocks },\n\t{ (char *)\"WriteProtect\", test_write10_wrprotect },\n\t{ (char *)\"DpoFua\", test_write10_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write12[] = {\n\t{ (char *)\"Simple\", test_write12_simple },\n\t{ (char *)\"BeyondEol\", test_write12_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_write12_0blocks },\n\t{ (char *)\"WriteProtect\", test_write12_wrprotect },\n\t{ (char *)\"DpoFua\", test_write12_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write16[] = {\n\t{ (char *)\"Simple\", test_write16_simple },\n\t{ (char *)\"BeyondEol\", test_write16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_write16_0blocks },\n\t{ (char *)\"WriteProtect\", test_write16_wrprotect },\n\t{ (char *)\"DpoFua\", test_write16_dpofua },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writesame10[] = {\n\t{ (char *)\"Simple\", test_writesame10_simple },\n\t{ (char *)\"BeyondEol\", test_writesame10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_writesame10_0blocks },\n\t{ (char *)\"WriteProtect\", test_writesame10_wrprotect },\n\t{ (char *)\"Unmap\", test_writesame10_unmap },\n\t{ (char *)\"UnmapUnaligned\", test_writesame10_unmap_unaligned },\n\t{ (char *)\"UnmapUntilEnd\", test_writesame10_unmap_until_end },\n\t{ (char *)\"UnmapVPD\", test_writesame10_unmap_vpd },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writesame16[] = {\n\t{ (char *)\"Simple\", test_writesame16_simple },\n\t{ (char *)\"BeyondEol\", test_writesame16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_writesame16_0blocks },\n\t{ (char *)\"WriteProtect\", test_writesame16_wrprotect },\n\t{ (char *)\"Unmap\", test_writesame16_unmap },\n\t{ (char *)\"UnmapUnaligned\", test_writesame16_unmap_unaligned },\n\t{ (char *)\"UnmapUntilEnd\", test_writesame16_unmap_until_end },\n\t{ (char *)\"UnmapVPD\", test_writesame16_unmap_vpd },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify10[] = {\n\t{ (char *)\"Simple\", test_writeverify10_simple },\n\t{ (char *)\"BeyondEol\", test_writeverify10_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_writeverify10_0blocks },\n\t{ (char *)\"WriteProtect\", test_writeverify10_wrprotect },\n\t{ (char *)\"Flags\", test_writeverify10_flags },\n\t{ (char *)\"Dpo\", test_writeverify10_dpo },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify12[] = {\n\t{ (char *)\"Simple\", test_writeverify12_simple },\n\t{ (char *)\"BeyondEol\", test_writeverify12_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_writeverify12_0blocks },\n\t{ (char *)\"WriteProtect\", test_writeverify12_wrprotect },\n\t{ (char *)\"Flags\", test_writeverify12_flags },\n\t{ (char *)\"Dpo\", test_writeverify12_dpo },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify16[] = {\n\t{ (char *)\"Simple\", test_writeverify16_simple },\n\t{ (char *)\"BeyondEol\", test_writeverify16_beyond_eol },\n\t{ (char *)\"ZeroBlocks\", test_writeverify16_0blocks },\n\t{ (char *)\"WriteProtect\", test_writeverify16_wrprotect },\n\t{ (char *)\"Flags\", test_writeverify16_flags },\n\t{ (char *)\"Dpo\", test_writeverify16_dpo },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_multipathio[] = {\n\t{ (char *)\"Simple\", test_multipathio_simple },\n\tCU_TEST_INFO_NULL\n};\n\ntypedef struct libiscsi_suite_info {\n        const char       *pName;         /**< Suite name. */\n        CU_InitializeFunc pInitFunc;     /**< Suite initialization function. */\n        CU_CleanupFunc    pCleanupFunc;  /**< Suite cleanup function */\n        CU_SetUpFunc      pSetUpFunc;    /**< Test setup function. */\n        CU_TearDownFunc   pTearDownFunc; /**< Test tear down function */\n        CU_TestInfo      *pTests;        /**< Test case array - must be NULL terminated. */\n} libiscsi_suite_info;\n\n#define NON_PGR_FUNCS suite_init, suite_cleanup, test_setup, test_teardown\n\n/* SCSI protocol tests */\nstatic libiscsi_suite_info scsi_suites[] = {\n\t{ \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n\t{ \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n\t{ \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n\t{ \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n\t{ \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n\t{ \"NoMedia\", NON_PGR_FUNCS, tests_nomedia },\n\t{ \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n\t{ \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n\t{ \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n\t{ \"PreventAllow\", NON_PGR_FUNCS, tests_preventallow },\n\t{ \"PrinReadKeys\", NON_PGR_FUNCS, tests_prin_read_keys },\n\t{ \"PrinServiceactionRange\", NON_PGR_FUNCS, tests_prin_serviceaction_range },\n\t{ \"ProutRegister\", NON_PGR_FUNCS, tests_prout_register },\n\t{ \"ProutReserve\", NON_PGR_FUNCS, tests_prout_reserve },\n\t{ \"Read6\", NON_PGR_FUNCS, tests_read6 },\n\t{ \"Read10\", NON_PGR_FUNCS, tests_read10 },\n\t{ \"Read12\", NON_PGR_FUNCS, tests_read12 },\n\t{ \"Read16\", NON_PGR_FUNCS, tests_read16 },\n\t{ \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n\t{ \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n\t{ \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n\t{ \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n\t  tests_report_supported_opcodes },\n\t{ \"Reserve6\", NON_PGR_FUNCS, tests_reserve6 },\n\t{ \"Sanitize\", NON_PGR_FUNCS, tests_sanitize },\n\t{ \"StartStopUnit\", NON_PGR_FUNCS, tests_startstopunit },\n\t{ \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n\t{ \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n\t{ \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n\t{ \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n\t{ \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n\t{ \"Write10\", NON_PGR_FUNCS, tests_write10 },\n\t{ \"Write12\", NON_PGR_FUNCS, tests_write12 },\n\t{ \"Write16\", NON_PGR_FUNCS, tests_write16 },\n\t{ \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n\t{ \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n\t{ \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n\t{ \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n\t{ \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n\t{ \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n\t{ NULL, NULL, NULL, NULL, NULL, NULL }\n};\n\nstatic CU_TestInfo tests_iscsi_cmdsn[] = {\n\t{ (char *)\"iSCSICmdSnTooHigh\", test_iscsi_cmdsn_toohigh },\n\t{ (char *)\"iSCSICmdSnTooLow\", test_iscsi_cmdsn_toolow },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_iscsi_datasn[] = {\n\t{ (char *)\"iSCSIDataSnInvalid\", test_iscsi_datasn_invalid },\n\tCU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_iscsi_residuals[] = {\n\t{ (char *)\"Read10Invalid\", test_read10_invalid },\n\t{ (char *)\"Read10Residuals\", test_read10_residuals },\n\t{ (char *)\"Read12Residuals\", test_read12_residuals },\n\t{ (char *)\"Read16Residuals\", test_read16_residuals },\n\t{ (char *)\"Write10Residuals\", test_write10_residuals },\n\t{ (char *)\"Write12Residuals\", test_write12_residuals },\n\t{ (char *)\"Write16Residuals\", test_write16_residuals },\n\t{ (char *)\"WriteVerify10Residuals\", test_writeverify10_residuals },\n\t{ (char *)\"WriteVerify12Residuals\", test_writeverify12_residuals },\n\t{ (char *)\"WriteVerify16Residuals\", test_writeverify16_residuals },\n\tCU_TEST_INFO_NULL\n};\n\n/* iSCSI protocol tests */\nstatic libiscsi_suite_info iscsi_suites[] = {\n\t{ \"iSCSIcmdsn\", NON_PGR_FUNCS,\n\t  tests_iscsi_cmdsn },\n\t{ \"iSCSIdatasn\", NON_PGR_FUNCS,\n\t  tests_iscsi_datasn },\n\t{ \"iSCSIResiduals\", NON_PGR_FUNCS,\n\t  tests_iscsi_residuals },\n\t{ NULL, NULL, NULL, NULL, NULL, NULL }\n};\n\n/* All tests */\nstatic libiscsi_suite_info all_suites[] = {\n\t{ \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n\t{ \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n\t{ \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n\t{ \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n\t{ \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n\t{ \"NoMedia\", NON_PGR_FUNCS, tests_nomedia },\n\t{ \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n\t{ \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n\t{ \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n\t{ \"PreventAllow\", NON_PGR_FUNCS, tests_preventallow },\n\t{ \"PrinReadKeys\", NON_PGR_FUNCS, tests_prin_read_keys },\n\t{ \"PrinServiceactionRange\", NON_PGR_FUNCS,\n\t  tests_prin_serviceaction_range },\n\t{ \"ProutRegister\", NON_PGR_FUNCS, tests_prout_register },\n\t{ \"ProutReserve\", NON_PGR_FUNCS, tests_prout_reserve },\n\t{ \"Read6\", NON_PGR_FUNCS, tests_read6 },\n\t{ \"Read10\", NON_PGR_FUNCS, tests_read10 },\n\t{ \"Read12\", NON_PGR_FUNCS, tests_read12 },\n\t{ \"Read16\", NON_PGR_FUNCS, tests_read16 },\n\t{ \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n\t{ \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n\t{ \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n\t{ \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n\t  tests_report_supported_opcodes },\n\t{ \"Reserve6\", NON_PGR_FUNCS, tests_reserve6 },\n\t{ \"Sanitize\", NON_PGR_FUNCS, tests_sanitize },\n\t{ \"StartStopUnit\", NON_PGR_FUNCS, tests_startstopunit },\n\t{ \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n\t{ \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n\t{ \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n\t{ \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n\t{ \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n\t{ \"Write10\", NON_PGR_FUNCS, tests_write10 },\n\t{ \"Write12\", NON_PGR_FUNCS, tests_write12 },\n\t{ \"Write16\", NON_PGR_FUNCS, tests_write16 },\n\t{ \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n\t{ \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n\t{ \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n\t{ \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n\t{ \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n\t{ \"iSCSIcmdsn\", NON_PGR_FUNCS, tests_iscsi_cmdsn },\n\t{ \"iSCSIdatasn\", NON_PGR_FUNCS, tests_iscsi_datasn },\n\t{ \"iSCSIResiduals\", NON_PGR_FUNCS, tests_iscsi_residuals },\n\t{ \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n\t{ NULL, NULL, NULL, NULL, NULL, NULL },\n};\n\nstatic libiscsi_suite_info linux_suites[] = {\n\t{ \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n\t{ \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n\t{ \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n\t{ \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n\t{ \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n\t{ \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n\t{ \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n\t{ \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n\t{ \"Read10\", NON_PGR_FUNCS, tests_read10 },\n\t{ \"Read12\", NON_PGR_FUNCS, tests_read12 },\n\t{ \"Read16\", NON_PGR_FUNCS, tests_read16 },\n\t{ \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n\t{ \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n\t{ \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n\t{ \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n\t  tests_report_supported_opcodes },\n\t{ \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n\t{ \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n\t{ \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n\t{ \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n\t{ \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n\t{ \"Write10\", NON_PGR_FUNCS, tests_write10 },\n\t{ \"Write12\", NON_PGR_FUNCS, tests_write12 },\n\t{ \"Write16\", NON_PGR_FUNCS, tests_write16 },\n\t{ \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n\t{ \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n\t{ \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n\t{ \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n\t{ \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n\t{ \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n\t{ NULL, NULL, NULL, NULL, NULL, NULL },\n};\n\nstruct test_family {\n       const char *name;\n       libiscsi_suite_info *suites;\n};\n\nstatic struct test_family families[] = {\n\t{ \"ALL\",\t\tall_suites },\n\t{ \"SCSI\",\t\tscsi_suites },\n\t{ \"iSCSI\",\t\tiscsi_suites },\n\t{ \"LINUX\",\t\tlinux_suites },\n\t{ NULL, NULL}\n};\n\n/*\n * globals for test setup and teardown\n */\nstruct scsi_task *task;\nunsigned char *read_write_buf;\n\nstatic void\nprint_usage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: %s [-?|--help]    print this message and exit\\n\",\n\t    PROG);\n\tfprintf(stderr,\n\t    \"or     %s [OPTIONS] <iscsi-url> [multipath-iscsi-url]\\n\", PROG);\n\tfprintf(stderr,\n\t    \"Where OPTIONS are from:\\n\");\n\tfprintf(stderr,\n\t    \"  -i|--initiator-name=iqn-name     Initiatorname to use [%s]\\n\",\n\t\tinitiatorname1);\n\tfprintf(stderr,\n\t    \"  -I|--initiator-name-2=iqn-name   2nd Initiatorname to use [%s]\\n\",\n\t\tinitiatorname2);\n\tfprintf(stderr,\n\t    \"  -t|--test=test-name-reg-exp      Test(s) to run [ALL] <NOT YET IMPLEMENTED>\\n\");\n\tfprintf(stderr,\n\t    \"  -l|--list                        List all tests and exit\\n\");\n\tfprintf(stderr,\n\t    \"  -d|--dataloss                    Allow destructive tests\\n\");\n\tfprintf(stderr,\n\t    \"  -S|--allow-sanitize              Allow sanitize-opcode tests\\n\");\n\tfprintf(stderr,\n\t    \"  -g|--ignore                      Error Action: Ignore test errors [DEFAULT]\\n\");\n\tfprintf(stderr,\n\t    \"  -f|--fail                        Error Action: FAIL if any tests fail\\n\");\n\tfprintf(stderr,\n\t    \"  -A|--abort                       Error Action: ABORT if any tests fail\\n\");\n\tfprintf(stderr,\n\t    \"  -s|--silent                      Test Mode: Silent\\n\");\n\tfprintf(stderr,\n\t    \"  -n|--normal                      Test Mode: Normal\\n\");\n\tfprintf(stderr,\n\t    \"  -v|--verbose                     Test Mode: Verbose [DEFAULT]\\n\");\n\tfprintf(stderr,\n\t    \"  -x|--xml                         Test Mode: XML\\n\");\n\tfprintf(stderr,\n\t    \"  -V|--Verbose-scsi                Enable verbose SCSI logging [default SILENT]\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr,\n\t    \"Where <iscsi-url> iSCSI URL format is: %s\\n\", ISCSI_URL_SYNTAX);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr,\n\t    \"<host> is one of:\\n\");\n\tfprintf(stderr,\n\t    \"  \\\"hostname\\\"       e.g. iscsi.example\\n\");\n\tfprintf(stderr,\n\t    \"  \\\"ipv4-address\\\"   e.g. 10.1.1.27\\n\");\n\tfprintf(stderr,\n\t    \"  \\\"ipv6-address\\\"   e.g. [fce0::1]\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr,\n\t    \"and <test-name-reg-exp> is of the form: FAMILY[.SUITE[.TEST]]\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid\ntest_setup(void)\n{\n\ttask = NULL;\n\tread_write_buf = NULL;\n}\n\nvoid\ntest_teardown(void)\n{\n\tfree(read_write_buf);\n\tread_write_buf = NULL;\n\tscsi_free_scsi_task(task);\n\ttask = NULL;\n}\n\nint\nsuite_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < mp_num_sds; i++) {\n\t\tif (!mp_sds[i]->iscsi_url) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp_sds[i]->iscsi_ctx) {\n\t\t\tiscsi_logout_sync(mp_sds[i]->iscsi_ctx);\n\t\t\tiscsi_destroy_context(mp_sds[i]->iscsi_ctx);\n\t\t}\n\t\tmp_sds[i]->iscsi_ctx = iscsi_context_login(initiatorname1,\n\t\t\t\t\t\t\tmp_sds[i]->iscsi_url,\n\t\t\t\t\t\t\t&mp_sds[i]->iscsi_lun);\n\t\tif (mp_sds[i]->iscsi_ctx == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"error: Failed to login to target for test set-up\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifndef HAVE_CU_SUITEINFO_PSETUPFUNC\n\t/* libcunit version 1 */\n\ttest_setup();\n#endif\n\treturn 0;\n}\n\nint\nsuite_cleanup(void)\n{\n\tint i;\n\n#ifndef HAVE_CU_SUITEINFO_PSETUPFUNC\n\t/* libcunit version 1 */\n\ttest_teardown();\n#endif\n\tfor (i = 0; i < mp_num_sds; i++) {\n\t\tif (mp_sds[i]->iscsi_url) {\n\t\t\tif (mp_sds[i]->iscsi_ctx) {\n\t\t\t\tiscsi_logout_sync(mp_sds[i]->iscsi_ctx);\n\t\t\t\tiscsi_destroy_context(mp_sds[i]->iscsi_ctx);\n\t\t\t\tmp_sds[i]->iscsi_ctx = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nlist_all_tests(void)\n{\n\tstruct test_family *fp;\n\tlibiscsi_suite_info *sp;\n\tCU_TestInfo *tp;\n\n\tfor (fp = families; fp->name; fp++) {\n\t\tprintf(\"%s\\n\", fp->name);\n\t\tfor (sp = fp->suites; sp->pName != NULL; sp++) {\n\t\t\tprintf(\"%s.%s\\n\", fp->name,sp->pName);\n\t\t\tfor (tp = sp->pTests; tp->pName != NULL; tp++) {\n\t\t\t\tprintf(\"%s.%s.%s\\n\", fp->name,sp->pName,\n\t\t\t\t\ttp->pName);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic CU_ErrorCode\nadd_tests(const char *testname_re)\n{\n\tchar *family_re = NULL;\n\tchar *suite_re = NULL;\n\tchar *test_re = NULL;\n\tchar *cp;\n\tstruct test_family *fp;\n\tlibiscsi_suite_info *sp;\n\tCU_TestInfo *tp;\n\n\n\t/* if not testname(s) register all tests */\n\tif (!testname_re) {\n\t\tfamily_re = strdup(\"*\");\n\t\tsuite_re = strdup(\"*\");\n\t\ttest_re = strdup(\"*\");\n\t} else {\n\t\t/*\n\t\t * break testname_re into family/suite/test\n\t\t *\n\t\t * syntax is:  FAMILY[.SUITE[.TEST]]\n\t\t */\n\t\tfamily_re = strdup(testname_re);\n\t\tif ((cp = strchr(family_re, '.')) != NULL) {\n\t\t\t*cp++ = 0;\n\t\t\tsuite_re = strdup(cp);\n\t\t\tif ((cp = strchr(suite_re, '.')) != NULL) {\n\t\t\t\t*cp++ = 0;\n\t\t\t\ttest_re = strdup(cp);\n\t\t\t}\n\t\t}\n\t\tif (!suite_re)\n\t\t\tsuite_re = strdup(\"*\");\n\t\tif (!test_re)\n\t\t\ttest_re = strdup(\"*\");\n\t\tif (!family_re) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"error: can't parse test family name: %s\\n\",\n\t\t\t\tfamily_re);\n\t\t\treturn CUE_NOTEST;\n\t\t}\n\t}\n\n\t/*\n\t * cycle through the test families/suites/tests, adding\n\t * ones that match\n\t */\n\tfor (fp = families; fp->name; fp++) {\n\t\tif (fnmatch(family_re, fp->name, 0) != 0)\n\t\t    continue;\n\n\t\tfor (sp = fp->suites; sp->pName != NULL; sp++) {\n\t\t\tint suite_added = 0;\n\t\t\tCU_pSuite pSuite = NULL;\n\n\t\t\tif (fnmatch(suite_re, sp->pName, 0) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tfor (tp = sp->pTests; tp->pName != NULL; tp++) {\n\t\t\t\tif (fnmatch(test_re, tp->pName, 0) != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!suite_added) {\n\t\t\t\t\tsuite_added++;\n#ifdef HAVE_CU_SUITEINFO_PSETUPFUNC\n\t\tpSuite = CU_add_suite_with_setup_and_teardown(sp->pName,\n\t\t\t\t\tsp->pInitFunc, sp->pCleanupFunc,\n\t\t\t\t\tsp->pSetUpFunc, sp->pTearDownFunc);\n#else\n\t\t\t\t\tpSuite = CU_add_suite(sp->pName,\n\t\t\t\t\t\tsp->pInitFunc, sp->pCleanupFunc);\n#endif\n\t\t\t\t}\n\t\t\t\tCU_add_test(pSuite, tp->pName, tp->pTestFunc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* all done -- clean up */\n\tfree(family_re);\n\tfree(suite_re);\n\tfree(test_re);\n\n\treturn CUE_SUCCESS;\n}\n\nstatic void parse_and_add_tests(char *testname_re);\n\nstatic void parse_and_add_test(const char *test)\n{\n\tif (test && access(test, F_OK) == 0) {\n\t\tFILE *fh;\n\t\tchar t[256];\n\n\t\tif ((fh = fopen(test, \"r\")) == NULL) {\n\t\t\tprintf(\"Failed to open test-list file %s\\n\", test);\n\t\t\texit(10);\n\t\t}\n\t\twhile (fgets(t, sizeof(t), fh) != NULL) {\n\t\t\twhile (1) {\n\t\t\t\tint len = strlen(t);\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isprint(t[--len])) {\n\t\t\t\t\tt[len] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tparse_and_add_tests(t);\n\t\t}\n\t\tfclose(fh);\n\t\treturn;\n\t}\n\n\tif (add_tests(test) != CUE_SUCCESS) {\n\t\tfprintf(stderr, \"error: suite registration failed: %s\\n\",\n\t\t    CU_get_error_msg());\n\t\texit(1);\n\t}\n}\n\nstatic void parse_and_add_tests(char *testname_re)\n{\n\tif (testname_re != NULL) {\n\t\tchar *testname;\n\t\twhile ((testname = strrchr(testname_re, ',')) != NULL) {\n\t\t\tparse_and_add_test(testname + 1);\n\t\t\t*testname = 0;\n\t\t}\n\t}\n\tparse_and_add_test(testname_re);\n}\n\nstatic int connect_scsi_device(struct scsi_device *sdev, const char *initiatorname)\n{\n\tif (sdev->iscsi_url) {\n\t\tsdev->iscsi_ctx = iscsi_context_login(initiatorname, sdev->iscsi_url, &sdev->iscsi_lun);\n\t\tif (sdev->iscsi_ctx == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n#ifdef HAVE_SG_IO\n\tif (sdev->sgio_dev) {\n\t\tint version;\n\n\t\tif ((sdev->sgio_fd = open(sdev->sgio_dev, O_RDWR|O_NONBLOCK)) == -1) {\n\t\t\tfprintf(stderr, \"Failed to open SG_IO device %s. Error:%s\\n\", sdev->sgio_dev,\n\t\t\t\tstrerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tif ((ioctl(sdev->sgio_fd, SG_GET_VERSION_NUM, &version) < 0) || (version < 30000)) {\n\t\t\tfprintf(stderr, \"%s is not a SCSI device node\\n\", sdev->sgio_dev);\n\t\t\tclose(sdev->sgio_fd);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ioctl(sdev->sgio_fd, BLKSECTGET, &maxsectbytes) < 0) {\n\t\t\tfprintf(stderr, \"%s failed to read BLKMAXSECT\\n\", sdev->sgio_dev);\n\t\t\tclose(sdev->sgio_fd);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\treturn -1;\n}\n\nstatic void free_scsi_device(struct scsi_device *sdev)\n{\n\tif (sdev->error_str) {\n\t\tfree(discard_const(sdev->error_str));\n\t\tsdev->error_str = NULL;\n\t}\n\tif (sdev->iscsi_url) {\n\t\tfree(discard_const(sdev->iscsi_url));\n\t\tsdev->iscsi_url = NULL;\n\t}\n\tif (sdev->iscsi_ctx) {\n\t\tiscsi_logout_sync(sdev->iscsi_ctx);\n\t\tiscsi_destroy_context(sdev->iscsi_ctx);\n\t\tsdev->iscsi_ctx = NULL;\n\t}\n\n\tif (sdev->sgio_dev) {\n\t\tfree(discard_const(sdev->sgio_dev));\n\t\tsdev->sgio_dev = NULL;\n\t}\n\tif (sdev->sgio_fd != -1) {\n\t\tclose(sdev->sgio_fd);\n\t\tsdev->sgio_fd = -1;\n\t}\n\tfree(sdev);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tchar *testname_re = NULL;\n\tCU_BasicRunMode mode = CU_BRM_VERBOSE;\n\tCU_ErrorAction error_action = CUEA_IGNORE;\n\tint res;\n\tstruct scsi_readcapacity10 *rc10;\n\tstruct scsi_task *inq_task = NULL;\n\tstruct scsi_task *inq_lbp_task = NULL;\n\tstruct scsi_task *inq_bdc_task = NULL;\n\tstruct scsi_task *inq_bl_task = NULL;\n\tstruct scsi_task *rc16_task = NULL;\n\tstruct scsi_task *rsop_task = NULL;\n\tint full_size;\n\tint xml_mode = 0;\n\tstatic struct option long_opts[] = {\n\t\t{ \"help\", no_argument, 0, '?' },\n\t\t{ \"list\", no_argument, 0, 'l' },\n\t\t{ \"initiator-name\", required_argument, 0, 'i' },\n\t\t{ \"initiator-name-2\", required_argument, 0, 'I' },\n\t\t{ \"test\", required_argument, 0, 't' },\n\t\t{ \"dataloss\", no_argument, 0, 'd' },\n\t\t{ \"allow-sanitize\", no_argument, 0, 'S' },\n\t\t{ \"ignore\", no_argument, 0, 'g' },\n\t\t{ \"fail\", no_argument, 0, 'f' },\n\t\t{ \"abort\", no_argument, 0, 'A' },\n\t\t{ \"silent\", no_argument, 0, 's' },\n\t\t{ \"normal\", no_argument, 0, 'n' },\n\t\t{ \"verbose\", no_argument, 0, 'v' },\n\t\t{ \"xml\", no_argument, 0, 'x' },\n\t\t{ \"Verbose-scsi\", no_argument, 0, 'V' },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tint i, c;\n\tint opt_idx = 0;\n\n\twhile ((c = getopt_long(argc, argv, \"?hli:I:t:sdgfAsSnvxV\", long_opts,\n\t\t    &opt_idx)) > 0) {\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tprint_usage();\n\t\t\treturn 0;\n\t\tcase 'l':\n\t\t\tlist_all_tests();\n\t\t\treturn 0;\n\t\tcase 'i':\n\t\t\tinitiatorname1 = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tinitiatorname2 = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttestname_re = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdata_loss++;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\terror_action = CUEA_IGNORE; /* default */\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\terror_action = CUEA_FAIL;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\terror_action = CUEA_ABORT;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmode = CU_BRM_SILENT;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tallow_sanitize = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmode = CU_BRM_NORMAL;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmode = CU_BRM_VERBOSE;\t/* default */\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t        xml_mode = 1;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tloglevel = LOG_VERBOSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr,\n\t\t\t    \"error: unknown option return: %c (option %s)\\n\",\n\t\t\t    c, argv[optind]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* parse all trailing arguments as device paths */\n\tmp_num_sds = 0;\n\twhile (optind < argc) {\n\t\tif (mp_num_sds >= MPATH_MAX_DEVS) {\n\t\t\tfprintf(stderr, \"Too many multipath device URLs\\n\");\n\t\t\tprint_usage();\n\t\t\tfree(testname_re);\n\t\t\treturn 10;\n\t\t}\n\n\t\tmp_sds[mp_num_sds] = malloc(sizeof(struct scsi_device));\n\t\tmemset(mp_sds[mp_num_sds], '\\0', sizeof(struct scsi_device));\n\t\tmp_sds[mp_num_sds]->sgio_fd = -1;\n\n\t\tif (!strncmp(argv[optind], \"iscsi://\", 8)) {\n\t\t\tmp_sds[mp_num_sds]->iscsi_url = strdup(argv[optind++]);\n#ifdef HAVE_SG_IO\n\t\t} else {\n\t\t\tmp_sds[mp_num_sds]->sgio_dev = strdup(argv[optind++]);\n#endif\n\t\t}\n\t\tmp_num_sds++;\n\t}\n\n\t/* So that we can override iscsi_queue_pdu in tests\n\t * and replace or mutate the blob that we are about to write to the\n\t * wire.\n\t * This allows such tests to do their mutates and then call out\n\t * to the real queueing function once they have modified the data.\n\t */\n\treal_iscsi_queue_pdu = dlsym(RTLD_NEXT, \"iscsi_queue_pdu\");\n\n\tif ((mp_num_sds == 0) || (mp_sds[0]->iscsi_url == NULL\n\t\t\t\t\t&& mp_sds[0]->sgio_dev == NULL)) {\n#ifdef HAVE_SG_IO\n\t\tfprintf(stderr, \"You must specify either an iSCSI URL or a device file\\n\");\n#else\n\t\tfprintf(stderr, \"You must specify an iSCSI URL\\n\");\n#endif\n\t\tprint_usage();\n\t\tif (testname_re)\n\t\t\tfree(testname_re);\n\t\treturn 10;\n\t}\n\n\t/* sd remains an alias for the first device */\n\tsd = mp_sds[0];\n\n\tfor (i = 0; i < mp_num_sds; i++) {\n\t\tres = connect_scsi_device(mp_sds[i], initiatorname1);\n\t\tif (res < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to connect to SCSI device %d\\n\", i);\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\n\tif (mp_num_sds > 1) {\n\t\t/* check that all multipath sds identify as the same LU */\n\t\tres = mpath_check_matching_ids(mp_num_sds, mp_sds);\n\t\tif (res < 0) {\n\t\t\tfprintf(stderr, \"multipath devices don't match\\n\");\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\n\t/*\n\t * find the size of the LUN\n\t * All devices support readcapacity10 but only some support\n\t * readcapacity16\n\t */\n\ttask = NULL;\n\treadcapacity10(sd, &task, 0, 0, EXPECT_STATUS_GOOD);\n\tif (task == NULL) {\n\t\tprintf(\"Failed to send READCAPACITY10 command: %s\\n\", sd->error_str);\n\t\tgoto err_sds_free;\n\t}\n\tif (task->status != SCSI_STATUS_GOOD) {\n\t\tprintf(\"READCAPACITY10 command: failed with sense. %s\\n\", sd->error_str);\n\t\tscsi_free_scsi_task(task);\n\t\tgoto err_sds_free;\n\t}\n\trc10 = scsi_datain_unmarshall(task);\n\tif (rc10 == NULL) {\n\t\tprintf(\"failed to unmarshall READCAPACITY10 data.\\n\");\n\t\tscsi_free_scsi_task(task);\n\t\tgoto err_sds_free;\n\t}\n\tblock_size = rc10->block_size;\n\tnum_blocks = rc10->lba + 1;\n\tscsi_free_scsi_task(task);\n\n\trc16_task = NULL;\n\treadcapacity16(sd, &rc16_task, 96, EXPECT_STATUS_GOOD);\n\tif (rc16_task == NULL) {\n\t\tprintf(\"Failed to send READCAPACITY16 command: %s\\n\", sd->error_str);\n\t\tgoto err_sds_free;\n\t}\n\tif (rc16_task->status == SCSI_STATUS_GOOD) {\n\t\trc16 = scsi_datain_unmarshall(rc16_task);\n\t\tif (rc16 == NULL) {\n\t\t\tprintf(\"failed to unmarshall READCAPACITY16 data. %s\\n\", sd->error_str);\n\t\t\tscsi_free_scsi_task(rc16_task);\n\t\t\tgoto err_sds_free;\n\t\t}\n\t\tblock_size = rc16->block_length;\n\t\tnum_blocks = rc16->returned_lba + 1;\n\t\tlbppb = 1 << rc16->lbppbe;\n\t}\n\n\tinq_task = NULL;\n\tinquiry(sd, &inq_task, 0, 0, 64, EXPECT_STATUS_GOOD);\n\tif (inq_task == NULL || inq_task->status != SCSI_STATUS_GOOD) {\n\t\tprintf(\"Inquiry command failed : %s\\n\", sd->error_str);\n\t\tgoto err_sds_free;\n\t}\n\tfull_size = scsi_datain_getfullsize(inq_task);\n\tif (full_size > inq_task->datain.size) {\n\t\tscsi_free_scsi_task(inq_task);\n\n\t\t/* we need more data for the full list */\n\t\tinq_task = NULL;\n\t\tinquiry(sd, &inq_task, 0, 0, full_size, EXPECT_STATUS_GOOD);\n\t\tif (inq_task == NULL) {\n\t\t\tprintf(\"Inquiry command failed : %s\\n\", sd->error_str);\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\tinq = scsi_datain_unmarshall(inq_task);\n\tif (inq == NULL) {\n\t\tprintf(\"failed to unmarshall inquiry datain blob\\n\");\n\t\tscsi_free_scsi_task(inq_task);\n\t\tgoto err_sds_free;\n\t}\n\n\tsbc3_support = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (inq->version_descriptor[i] == 0x04C0) {\n\t\t\tsbc3_support = 1;\n\t\t}\n\t}\n\n\t/* try reading block limits vpd */\n\tinq_bl_task = NULL;\n\tinquiry(sd, &inq_bl_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS, 64, EXPECT_STATUS_GOOD);\n\tif (inq_bl_task && inq_bl_task->status != SCSI_STATUS_GOOD) {\n\t\tscsi_free_scsi_task(inq_bl_task);\n\t\tinq_bl_task = NULL;\n\t}\n\tif (inq_bl_task) {\n\t\tfull_size = scsi_datain_getfullsize(inq_bl_task);\n\t\tif (full_size > inq_bl_task->datain.size) {\n\t\t\tscsi_free_scsi_task(inq_bl_task);\n\n\t\t\tinq_bl_task = NULL;\n\t\t\tinquiry(sd, &inq_bl_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS, full_size,\n\t\t\t\tEXPECT_STATUS_GOOD);\n\t\t\tif (inq_bl_task == NULL) {\n\t\t\t\tprintf(\"Inquiry command failed : %s\\n\", sd->error_str);\n\t\t\t\tgoto err_sds_free;\n\t\t\t}\n\t\t}\n\n\t\tinq_bl = scsi_datain_unmarshall(inq_bl_task);\n\t\tif (inq_bl == NULL) {\n\t\t\tprintf(\"failed to unmarshall inquiry datain blob\\n\");\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\n\t/* try reading block device characteristics vpd */\n\tinquiry(sd, &inq_bdc_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_DEVICE_CHARACTERISTICS, 255,\n\t\tEXPECT_STATUS_GOOD);\n\tif (inq_bdc_task == NULL || inq_bdc_task->status != SCSI_STATUS_GOOD) {\n\t\tprintf(\"Failed to read Block Device Characteristics page\\n\");\n\t} else {\n\t\tinq_bdc = scsi_datain_unmarshall(inq_bdc_task);\n\t\tif (inq_bdc == NULL) {\n\t\t\tprintf(\"failed to unmarshall inquiry datain blob\\n\");\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\n\t/* if thin provisioned we also need to read the VPD page for it */\n\tif (rc16 && rc16->lbpme != 0){\n\t\tinq_lbp_task = NULL;\n\t\tinquiry(sd, &inq_lbp_task, 1, SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING, 64,\n\t\t\tEXPECT_STATUS_GOOD);\n\t\tif (inq_lbp_task == NULL || inq_lbp_task->status != SCSI_STATUS_GOOD) {\n\t\t\tprintf(\"Inquiry command failed : %s\\n\", sd->error_str);\n\t\t\tgoto err_sds_free;\n\t\t}\n\t\tfull_size = scsi_datain_getfullsize(inq_lbp_task);\n\t\tif (full_size > inq_lbp_task->datain.size) {\n\t\t\tscsi_free_scsi_task(inq_lbp_task);\n\n\t\t\t/* we need more data for the full list */\n\t\t\tinq_lbp_task = NULL;\n\t\t\tinquiry(sd, &inq_lbp_task, 1, SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,\n\t\t\t\tfull_size, EXPECT_STATUS_GOOD);\n\t\t\tif (inq_lbp_task == NULL) {\n\t\t\t\tprintf(\"Inquiry command failed : %s\\n\", sd->error_str);\n\t\t\t\tgoto err_sds_free;\n\t\t\t}\n\t\t}\n\n\t\tinq_lbp = scsi_datain_unmarshall(inq_lbp_task);\n\t\tif (inq_lbp == NULL) {\n\t\t\tprintf(\"failed to unmarshall inquiry datain blob\\n\");\n\t\t\tgoto err_sds_free;\n\t\t}\n\t}\n\n\trsop_task = NULL;\n\treport_supported_opcodes(sd, &rsop_task, 1, SCSI_REPORT_SUPPORTING_OPS_ALL, 0, 0, 65535,\n\t\t\t\t EXPECT_STATUS_GOOD);\n\tif (rsop_task == NULL) {\n\t\tprintf(\"Failed to send REPORT_SUPPORTED_OPCODES command: %s\\n\", sd->error_str);\n\t\tgoto err_sds_free;\n\t}\n\tif (rsop_task->status == SCSI_STATUS_GOOD) {\n\t\trsop = scsi_datain_unmarshall(rsop_task);\n\t\tif (rsop == NULL) {\n\t\t\tprintf(\"failed to unmarshall REPORT_SUPPORTED_OPCODES data.\\n\");\n\t\t\tscsi_free_scsi_task(rsop_task);\n\t\t}\n\t}\n\n\t/* check if the device is write protected or not */\n\ttask = NULL;\n\tmodesense6(sd, &task, 0, SCSI_MODESENSE_PC_CURRENT, SCSI_MODEPAGE_RETURN_ALL_PAGES, 0, 255,\n\t\t   EXPECT_STATUS_GOOD);\n\tif (task == NULL) {\n\t\tprintf(\"Failed to send MODE_SENSE6 command: %s\\n\", sd->error_str);\n\t\tgoto err_sds_free;\n\t}\n\tif (task->status == SCSI_STATUS_GOOD) {\n\t\tstruct scsi_mode_sense *ms;\n\n\t\tms = scsi_datain_unmarshall(task);\n\t\tif (ms == NULL) {\n\t\t\tprintf(\"failed to unmarshall mode sense datain blob\\n\");\n\t\t\tscsi_free_scsi_task(task);\n\t\t\tgoto err_sds_free;\n\t\t}\n\t\treadonly = !!(ms->device_specific_parameter & 0x80);\n\t}\n\tscsi_free_scsi_task(task);\n\n\tif (maxsectbytes) {\n\t\tmaximum_transfer_length = maxsectbytes / block_size;\n\t\tprintf(\"Bus transfer size is limited to %d bytes. Clamping \"\n\t\t       \"max transfers accordingly.\\n\", maxsectbytes);\n\t}\n\n\tif (CU_initialize_registry() != 0) {\n\t\tfprintf(stderr, \"error: unable to initialize test registry\\n\");\n\t\tgoto err_sds_free;\n\t}\n\tif (CU_is_test_running()) {\n\t\tfprintf(stderr, \"error: test suite(s) already running!?\\n\");\n\t\texit(1);\n\t}\n\n\tparse_and_add_tests(testname_re);\n\tif (testname_re)\n\t\tfree(testname_re);\n\n\tCU_basic_set_mode(mode);\n\tCU_set_error_action(error_action);\n\tprintf(\"\\n\");\n\n\t/*\n\t * this actually runs the tests ...\n\t */\n\n\tif (xml_mode) {\n\t  CU_list_tests_to_file();\n\t  CU_automated_run_tests();\n\t} else {\n\t  res = CU_basic_run_tests();\n\t  printf(\"Tests completed with return value: %d\\n\", res);\n\t}\n\n\tCU_cleanup_registry();\n\n\tif (inq_task != NULL) {\n\t\tscsi_free_scsi_task(inq_task);\n\t}\n\tif (inq_bl_task != NULL) {\n\t\tscsi_free_scsi_task(inq_bl_task);\n\t}\n\tif (inq_lbp_task != NULL) {\n\t\tscsi_free_scsi_task(inq_lbp_task);\n\t}\n\tif (inq_bdc_task != NULL) {\n\t\tscsi_free_scsi_task(inq_bdc_task);\n\t}\n\tif (rc16_task != NULL) {\n\t\tscsi_free_scsi_task(rc16_task);\n\t}\n\tif (rsop_task != NULL) {\n\t\tscsi_free_scsi_task(rsop_task);\n\t}\n\tfor (i = 0; i < mp_num_sds; i++) {\n\t\tfree_scsi_device(mp_sds[i]);\n\t}\n\n\treturn 0;\n\nerr_sds_free:\n\tfor (i = 0; i < mp_num_sds; i++) {\n\t\tfree_scsi_device(mp_sds[i]);\n\t}\n\treturn -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libiscsi-1.15.0-dqtrqlklpgkgp5tplkzmraegqzguvvtw/spack-src/examples/ld_iscsi.c": "/*\n   Copyright (C) 2011, 2012 by Ronnie Sahlberg <ronniesahlberg@gmail.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation; either version 2.1 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define _GNU_SOURCE\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <asm/fcntl.h>\n\n#include \"iscsi.h\"\n#include \"iscsi-private.h\"\n#include \"scsi-lowlevel.h\"\n\n#include <sys/syscall.h>\n#include <dlfcn.h>\n#include <inttypes.h>\n\nstatic const char *initiator = \"iqn.2007-10.com.github:sahlberg:libiscsi:ld-iscsi\";\n\n#define ISCSI_MAX_FD  255\n\nstatic int debug = 0;\n\n#define LD_ISCSI_DPRINTF(level,fmt,args...) do { if ((debug) >= level) {fprintf(stderr,\"ld_iscsi: \");fprintf(stderr, (fmt), ##args); fprintf(stderr,\"\\n\");} } while (0);\n\nstruct iscsi_fd_list {\n       int is_iscsi;\n       int dup2fd;\n       int in_flight;\n       struct iscsi_context *iscsi;\n       int lun;\n       uint32_t block_size;\n       uint64_t num_blocks;\n       off_t offset;\n       mode_t mode;\n       int get_lba_status;\n       struct scsi_lba_status_descriptor lbasd_cached;\n       int lbasd_cache_valid;\n};\n\nstatic struct iscsi_fd_list iscsi_fd_list[ISCSI_MAX_FD];\n\nint (*real_open)(__const char *path, int flags, mode_t mode);\n\nint open(const char *path, int flags, mode_t mode)\n{\n\tint fd;\n\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tstruct iscsi_context *iscsi;\n\t\tstruct iscsi_url *iscsi_url;\n\t\tstruct scsi_task *task;\n\t\tstruct scsi_readcapacity16 *rc16;\n\n\t\tif (mode & O_NONBLOCK) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Non-blocking I/O is currently not supported\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi = iscsi_create_context(initiator);\n\t\tif (iscsi == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Failed to create context\");\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_url = iscsi_parse_full_url(iscsi, path);\n\t\tif (iscsi_url == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Failed to parse URL: %s\\n\", iscsi_get_error(iscsi));\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL);\n\t\tiscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\t\tif (iscsi_full_connect_sync(iscsi, iscsi_url->portal, iscsi_url->lun) != 0) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Login Failed. %s\\n\", iscsi_get_error(iscsi));\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\ttask = iscsi_readcapacity16_sync(iscsi, iscsi_url->lun);\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send readcapacity command\");\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\trc16 = scsi_datain_unmarshall(task);\n\t\tif (rc16 == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to unmarshall readcapacity10 data\");\n\t\t\tscsi_free_scsi_task(task);\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n        LD_ISCSI_DPRINTF(4,\"readcapacity16_sync: block_size: %d, num_blocks: %\"PRIu64,rc16->block_length,rc16->returned_lba + 1);\n\n\t\tfd = iscsi_get_fd(iscsi);\n\t\tif (fd >= ISCSI_MAX_FD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Too many files open\");\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = ENFILE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_fd_list[fd].is_iscsi   = 1;\n\t\tiscsi_fd_list[fd].dup2fd     = -1;\n\t\tiscsi_fd_list[fd].iscsi      = iscsi;\n\t\tiscsi_fd_list[fd].block_size = rc16->block_length;\n\t\tiscsi_fd_list[fd].num_blocks = rc16->returned_lba + 1;\n\t\tiscsi_fd_list[fd].offset     = 0;\n\t\tiscsi_fd_list[fd].lun        = iscsi_url->lun;\n\t\tiscsi_fd_list[fd].mode       = mode;\n\n\t\tif (getenv(\"LD_ISCSI_GET_LBA_STATUS\") != NULL) {\n\t\t\tiscsi_fd_list[fd].get_lba_status = atoi(getenv(\"LD_ISCSI_GET_LBA_STATUS\"));\n\t\t\tif (rc16->lbpme == 0){\n\t\t\t\tLD_ISCSI_DPRINTF(1,\"Logical unit is fully provisioned. Will skip get_lba_status tasks\");\n\t\t\t\tiscsi_fd_list[fd].get_lba_status = 0;\n\t\t\t}\n\t\t}\n\n\t\tscsi_free_scsi_task(task);\n\t\tiscsi_destroy_url(iscsi_url);\n\n\t\treturn fd;\n\t}\n\n\treturn real_open(path, flags, mode);\n}\n\nint open64(const char *path, int flags, mode_t mode)\n{\n\treturn open(path, flags | O_LARGEFILE, mode);\n}\n\nint (*real_close)(int fd);\n\nint close(int fd)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tint i;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\tiscsi_fd_list[fd].is_iscsi = 0;\n\t\t\tiscsi_fd_list[fd].dup2fd   = -1;\n\t\t\treal_close(fd);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* are there any FDs dup2ed onto this ? */\n\t\tfor(i = 0; i < ISCSI_MAX_FD; i++) {\n\t\t\tif (iscsi_fd_list[i].dup2fd == fd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < ISCSI_MAX_FD) {\n\t\t\tint j;\n\n\t\t\t/* yes there are DUPs onto fd, make i the new real device and repoint all other\n\t\t\t * duplicates\n\t\t\t */\n\t\t\tmemcpy(&iscsi_fd_list[i], &iscsi_fd_list[fd], sizeof(struct iscsi_fd_list));\n\t\t\tiscsi_fd_list[i].dup2fd = -1;\n\n\t\t\tmemset(&iscsi_fd_list[fd], 0, sizeof(struct iscsi_fd_list));\n\t\t\tiscsi_fd_list[fd].dup2fd = -1;\n\n\t\t\tiscsi_fd_list[i].iscsi->fd = i;\n\t\t\treal_close(fd);\n\n\t\t\tfor(j = 0; j < ISCSI_MAX_FD; j++) {\n\t\t\t\tif (j != i && iscsi_fd_list[j].dup2fd == fd) {\n\t\t\t\t\tiscsi_fd_list[j].dup2fd = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tiscsi_fd_list[fd].is_iscsi = 0;\n\t\tiscsi_fd_list[fd].dup2fd   = -1;\n\t\tiscsi_destroy_context(iscsi_fd_list[fd].iscsi);\n\t\tiscsi_fd_list[fd].iscsi    = NULL;\n\n\t\treturn 0;\n\t}\n\n        return real_close(fd);\n}\n\nint (*real_fxstat)(int ver, int fd, struct stat *buf);\n\nint __fxstat(int ver, int fd, struct stat *buf)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn __fxstat(ver, iscsi_fd_list[fd].dup2fd, buf);\n\t\t}\n\n\t\tmemset(buf, 0, sizeof(struct stat));\n\t\tbuf->st_mode = S_IRUSR | S_IRGRP | S_IROTH | S_IFREG;\n\t\tbuf->st_size = iscsi_fd_list[fd].num_blocks * iscsi_fd_list[fd].block_size;\n\n\t\treturn 0;\n\t}\n\n\treturn real_fxstat(ver, fd, buf);\n}\n\n\nint (*real_lxstat)(int ver, __const char *path, struct stat *buf);\n\nint __lxstat(int ver, const char *path, struct stat *buf)\n{\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tint fd, ret;\n\n\t\tfd = open(path, 0, 0);\n\t\tif (fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\n\t\tret = __fxstat(ver, fd, buf);\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\n\treturn real_lxstat(ver, path, buf);\n}\n\nint (*real_xstat)(int ver, __const char *path, struct stat *buf);\n\nint __xstat(int ver, const char *path, struct stat *buf)\n{\n\treturn __lxstat(ver, path, buf);\n}\n\noff_t (*real_lseek)(int fd, off_t offset, int whence);\n\noff_t lseek(int fd, off_t offset, int whence) {\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\toff_t new_offset;\n\t\toff_t size = iscsi_fd_list[fd].num_blocks*iscsi_fd_list[fd].block_size;\n\t\tswitch (whence) {\n\t\t\tcase SEEK_SET:\n\t\t\t\tnew_offset = offset;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_CUR:\n\t\t\t\tnew_offset = iscsi_fd_list[fd].offset+offset;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_END:\n\t\t\t\tnew_offset = size + offset;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (new_offset < 0 || new_offset > size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tiscsi_fd_list[fd].offset=new_offset;\n\t\treturn iscsi_fd_list[fd].offset;\n\t}\n\n\treturn real_lseek(fd, offset, whence);\n}\n\nssize_t (*real_read)(int fd, void *buf, size_t count);\n\nssize_t read(int fd, void *buf, size_t count)\n{\n\tif ((iscsi_fd_list[fd].is_iscsi == 1) && (iscsi_fd_list[fd].in_flight == 0)) {\n\t\tuint64_t offset;\n\t\tuint64_t num_blocks, lba;\n\t\tstruct scsi_task *task;\n\t\tstruct scsi_get_lba_status *lbas;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn read(iscsi_fd_list[fd].dup2fd, buf, count);\n\t\t}\n\t\toffset = iscsi_fd_list[fd].offset / iscsi_fd_list[fd].block_size * iscsi_fd_list[fd].block_size;\n\t\tnum_blocks = (iscsi_fd_list[fd].offset - offset + count + iscsi_fd_list[fd].block_size - 1) / iscsi_fd_list[fd].block_size;\n\t\tlba = offset / iscsi_fd_list[fd].block_size;\n\n\t\t/* Don't try to read beyond the last LBA */\n\t\tif (lba >= iscsi_fd_list[fd].num_blocks) {\n\t\t\treturn 0;\n\t\t}\n\t\t/* Trim num_blocks requested to last lba */\n\t\tif ((lba + num_blocks) > iscsi_fd_list[fd].num_blocks) {\n\t\t\tnum_blocks = iscsi_fd_list[fd].num_blocks - lba;\n\t\t\tcount = num_blocks * iscsi_fd_list[fd].block_size;\n\t\t}\n\n\t\tiscsi_fd_list[fd].in_flight = 1;\n        if (iscsi_fd_list[fd].get_lba_status != 0) {\n\t\t\tuint32_t i;\n\t\t\tuint32_t _num_allocated=0;\n\t\t\tuint32_t _num_blocks=0;\n\n\t\t\tif (iscsi_fd_list[fd].lbasd_cache_valid==1) {\n\t\t\t\tLD_ISCSI_DPRINTF(5,\"cached get_lba_status_descriptor is lba %\"PRIu64\", num_blocks %d, provisioning %d\",iscsi_fd_list[fd].lbasd_cached.lba,iscsi_fd_list[fd].lbasd_cached.num_blocks,iscsi_fd_list[fd].lbasd_cached.provisioning);\n\t\t\t    if (iscsi_fd_list[fd].lbasd_cached.provisioning != 0x00 && lba >= iscsi_fd_list[fd].lbasd_cached.lba && lba+num_blocks < iscsi_fd_list[fd].lbasd_cached.lba+iscsi_fd_list[fd].lbasd_cached.num_blocks)\n\t\t\t    {\n\t\t\t\t\tLD_ISCSI_DPRINTF(4,\"skipped read16_sync for non-allocated blocks: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\t\t\t\tmemset(buf, 0x00, count);\n\t\t\t\t\tiscsi_fd_list[fd].offset += count;\n\t\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLD_ISCSI_DPRINTF(4,\"get_lba_status_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64,iscsi_fd_list[fd].lun,lba,num_blocks);\n\t\t\ttask = iscsi_get_lba_status_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, 8+16);\n\t\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send get_lba_status command\");\n\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\terrno = EIO;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlbas = scsi_datain_unmarshall(task);\n\t\t\tif (lbas == NULL) {\n\t\t\t\tLD_ISCSI_DPRINTF(0,\"failed to unmarshall get_lba_status data\");\n\t\t\t\tscsi_free_scsi_task(task);\n\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\terrno = EIO;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tLD_ISCSI_DPRINTF(5,\"get_lba_status: num_descriptors: %d\",lbas->num_descriptors);\n\t\t\tfor (i=0;i<lbas->num_descriptors;i++) {\n\t\t\t\tstruct scsi_lba_status_descriptor *lbasd = &lbas->descriptors[i];\n\t\t\t\tLD_ISCSI_DPRINTF(5,\"get_lba_status_descriptor %d, lba %\"PRIu64\", num_blocks %d, provisioning %d\",i,lbasd->lba,lbasd->num_blocks,lbasd->provisioning);\n\t\t\t\tif (lbasd->lba != _num_blocks+lba) {\n\t\t\t\t\tLD_ISCSI_DPRINTF(0,\"get_lba_status response is non-continuous\");\n\t\t\t\t\tscsi_free_scsi_task(task);\n\t\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\t\terrno = EIO;\n\t\t\t\t\treturn -1;\n\t\t\t    }\n\t\t\t\t_num_allocated+=(lbasd->provisioning==0x00)?lbasd->num_blocks:0;\n\t\t\t\t_num_blocks+=lbasd->num_blocks;\n\t\t\t\tiscsi_fd_list[fd].lbasd_cached=lbas->descriptors[i];\n\t\t\t\tiscsi_fd_list[fd].lbasd_cache_valid=1;\n\t\t\t}\n\t\t\tscsi_free_scsi_task(task);\n            if (_num_allocated == 0 && _num_blocks >= num_blocks) {\n\t\t        LD_ISCSI_DPRINTF(4,\"skipped read16_sync for non-allocated blocks: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\t\t\tmemset(buf, 0x00, count);\n\t\t        iscsi_fd_list[fd].offset += count;\n\t\t        iscsi_fd_list[fd].in_flight = 0;\n\t\t        return count;\n\t\t\t}\n\t\t}\n\n\t\tLD_ISCSI_DPRINTF(4,\"read16_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\n\t\ttask = iscsi_read16_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, num_blocks * iscsi_fd_list[fd].block_size, iscsi_fd_list[fd].block_size, 0, 0, 0, 0, 0);\n\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send read16 command\");\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(buf, &task->datain.data[iscsi_fd_list[fd].offset - offset], count);\n\t\tiscsi_fd_list[fd].offset += count;\n\n\t\tscsi_free_scsi_task(task);\n\n\t\treturn count;\n\t}\n\n\treturn real_read(fd, buf, count);\n}\n\nssize_t (*real_pread)(int fd, void *buf, size_t count, off_t offset);\nssize_t pread(int fd, void *buf, size_t count, off_t offset) {\n\tif ((iscsi_fd_list[fd].is_iscsi == 1 && iscsi_fd_list[fd].in_flight == 0)) {\n\t\toff_t old_offset;\n\t\tif ((old_offset = lseek(fd, 0, SEEK_CUR)) < 0) {\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\t\tif (lseek(fd, offset, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(fd, buf, count) < 0) {\n\t\t\tlseek(fd, old_offset, SEEK_SET);\n\t\t\treturn -1;\n\t\t}\n\t\tlseek(fd, old_offset, SEEK_SET);\n\t\treturn count;\n\t}\n\treturn real_pread(fd, buf, count, offset);\n}\n\nssize_t (*real_write)(int fd, const void *buf, size_t count);\n\nssize_t write(int fd, const void *buf, size_t count)\n{\n\tif ((iscsi_fd_list[fd].is_iscsi == 1) && (iscsi_fd_list[fd].in_flight == 0)) {\n\t\tuint64_t offset;\n\t\tuint64_t num_blocks, lba;\n\t\tstruct scsi_task *task;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn write(iscsi_fd_list[fd].dup2fd, buf, count);\n\t\t}\n\t\tif (iscsi_fd_list[fd].offset%iscsi_fd_list[fd].block_size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif (count%iscsi_fd_list[fd].block_size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n                iscsi_fd_list[fd].lbasd_cache_valid = 0;\n\n\t\toffset = iscsi_fd_list[fd].offset;\n\t\tnum_blocks = count/iscsi_fd_list[fd].block_size;\n\t\tlba = offset / iscsi_fd_list[fd].block_size;\n\n\t\t/* Don't try to read beyond the last LBA */\n\t\tif (lba >= iscsi_fd_list[fd].num_blocks) {\n\t\t\treturn 0;\n\t\t}\n\t\t/* Trim num_blocks requested to last lba */\n\t\tif ((lba + num_blocks) > iscsi_fd_list[fd].num_blocks) {\n\t\t\tnum_blocks = iscsi_fd_list[fd].num_blocks - lba;\n\t\t\tcount = num_blocks * iscsi_fd_list[fd].block_size;\n\t\t}\n\n\t\tiscsi_fd_list[fd].in_flight = 1;\n\t\tLD_ISCSI_DPRINTF(4,\"write16_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\ttask = iscsi_write16_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, (unsigned char *) buf, count, iscsi_fd_list[fd].block_size, 0, 0, 0, 0, 0);\n\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send write16 command\");\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_fd_list[fd].offset += count;\n\t\tscsi_free_scsi_task(task);\n\n\t\treturn count;\n\t}\n\n\treturn real_write(fd, buf, count);\n}\n\nssize_t (*real_pwrite)(int fd, const void *buf, size_t count, off_t offset);\nssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) {\n\tif ((iscsi_fd_list[fd].is_iscsi == 1 && iscsi_fd_list[fd].in_flight == 0)) {\n\t\toff_t old_offset;\n\t\tif ((old_offset = lseek(fd, 0, SEEK_CUR)) < 0) {\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\t\tif (lseek(fd, offset, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (write(fd, buf, count) < 0) {\n\t\t\tlseek(fd, old_offset, SEEK_SET);\n\t\t\treturn -1;\n\t\t}\n\t\tlseek(fd, old_offset, SEEK_SET);\n\t\treturn count;\n\t}\n\treturn real_pwrite(fd, buf, count, offset);\n}\n\nint (*real_dup2)(int oldfd, int newfd);\n\nint dup2(int oldfd, int newfd)\n{\n\tif (iscsi_fd_list[newfd].is_iscsi) {\n\t\treturn real_dup2(oldfd, newfd);\n\t}\n\n\tclose(newfd);\n\n\tif (iscsi_fd_list[oldfd].is_iscsi == 1) {\n\t\tint ret;\n\t\tif (iscsi_fd_list[oldfd].dup2fd >= 0) {\n\t\t\treturn dup2(iscsi_fd_list[oldfd].dup2fd, newfd);\n\t\t}\n\n\t\tret = real_dup2(oldfd, newfd);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tiscsi_fd_list[newfd].is_iscsi = 1;\n\t\tiscsi_fd_list[newfd].dup2fd   = oldfd;\n\n\t\treturn newfd;\n\t}\n\n\treturn real_dup2(oldfd, newfd);\n}\n\n#if defined(_LARGEFILE64_SOURCE) && _FILE_OFFSET_BITS != 64\n\nint (*real_fxstat64)(int ver, int fd, struct stat64 *buf);\n\nint __fxstat64(int ver, int fd, struct stat64 *buf)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn __fxstat64(ver, iscsi_fd_list[fd].dup2fd, buf);\n\t\t}\n\n\t\tmemset(buf, 0, sizeof(struct stat64));\n\t\tbuf->st_mode = S_IRUSR | S_IRGRP | S_IROTH | S_IFREG;\n\t\tbuf->st_size = iscsi_fd_list[fd].num_blocks * iscsi_fd_list[fd].block_size;\n\t\treturn 0;\n\t}\n\n\treturn real_fxstat64(ver, fd, buf);\n}\n\n\nint (*real_lxstat64)(int ver, __const char *path, struct stat64 *buf);\n\nint __lxstat64(int ver, const char *path, struct stat64 *buf)\n{\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tint fd, ret;\n\n\t\tfd = open64(path, 0, 0);\n\t\tif (fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\n\t\tret = __fxstat64(ver, fd, buf);\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\n\treturn real_lxstat64(ver, path, buf);\n}\n\n\nint (*real_xstat64)(int ver, __const char *path, struct stat64 *buf);\n\nint __xstat64(int ver, const char *path, struct stat64 *buf)\n{\n\treturn __lxstat64(ver, path, buf);\n}\n\n#endif\n\nstatic void __attribute__((constructor)) _init(void)\n{\n\tint i;\n\n\tfor(i = 0; i < ISCSI_MAX_FD; i++) {\n\t\tiscsi_fd_list[i].dup2fd = -1;\n\t}\n\n\tif (getenv(\"LD_ISCSI_DEBUG\") != NULL) {\n\t\tdebug = atoi(getenv(\"LD_ISCSI_DEBUG\"));\n\t}\n\n\treal_open = dlsym(RTLD_NEXT, \"open\");\n\tif (real_open == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(open)\");\n\t\texit(10);\n\t}\n\n\treal_close = dlsym(RTLD_NEXT, \"close\");\n\tif (real_close == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(close)\");\n\t\texit(10);\n\t}\n\n\treal_fxstat = dlsym(RTLD_NEXT, \"__fxstat\");\n\tif (real_fxstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__fxstat)\");\n\t\texit(10);\n\t}\n\n\treal_lxstat = dlsym(RTLD_NEXT, \"__lxstat\");\n\tif (real_lxstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__lxstat)\");\n\t\texit(10);\n\t}\n\treal_xstat = dlsym(RTLD_NEXT, \"__xstat\");\n\tif (real_xstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__xstat)\");\n\t\texit(10);\n\t}\n\n\treal_lseek = dlsym(RTLD_NEXT, \"lseek\");\n\tif (real_lseek == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(lseek)\");\n\t\texit(10);\n\t}\n\n\treal_read = dlsym(RTLD_NEXT, \"read\");\n\tif (real_read == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(read)\");\n\t\texit(10);\n\t}\n\n\treal_pread = dlsym(RTLD_NEXT, \"pread\");\n\tif (real_pread == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(pread)\");\n\t\texit(10);\n\t}\n\n\treal_write = dlsym(RTLD_NEXT, \"write\");\n\tif (real_write == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(write)\");\n\t\texit(10);\n\t}\n\n\treal_pwrite = dlsym(RTLD_NEXT, \"pwrite\");\n\tif (real_pwrite == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(pwrite)\");\n\t\texit(10);\n\t}\n\n\treal_dup2 = dlsym(RTLD_NEXT, \"dup2\");\n\tif (real_dup2 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(dup2)\");\n\t\texit(10);\n\t}\n\n#if defined(_LARGEFILE64_SOURCE) && _FILE_OFFSET_BITS != 64\n\treal_fxstat64 = dlsym(RTLD_NEXT, \"__fxstat64\");\n\tif (real_fxstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__fxstat64)\");\n\t}\n\n\treal_lxstat64 = dlsym(RTLD_NEXT, \"__lxstat64\");\n\tif (real_lxstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(_lxstat64)\");\n\t}\n\n\treal_xstat64 = dlsym(RTLD_NEXT, \"__xstat64\");\n\tif (real_xstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__xstat64)\");\n\t}\n#endif\n}\n"
    },
    "skipped": [],
    "total_files": 269
}