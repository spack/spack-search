{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libiscsi-1.18.0-owrt5aol3rvh4wopzgsfagjft6l7i3ns/spack-src/test-tool/iscsi-test-cu.c": "/* -*-  mode:c; tab-width:8; c-basic-offset:8; indent-tabs-mode:nil;  -*- */\n/*\n   iscsi-test tool\n\n   Copyright (C) 2012 by Lee Duncan <lee@gonzoleeman.net>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"config.h\"\n\n#define _GNU_SOURCE\n#include <sys/syscall.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <string.h>\n#include <getopt.h>\n#include <fnmatch.h>\n#include <ctype.h>\n\n#ifdef HAVE_SG_IO\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <scsi/sg.h>\n#include <sys/mount.h>\n#endif\n\n#include <CUnit/CUnit.h>\n#include <CUnit/Basic.h>\n#include <CUnit/Automated.h>\n\n#include \"iscsi.h\"\n#include \"scsi-lowlevel.h\"\n#include \"iscsi-private.h\"\n\n#include \"iscsi-support.h\"\n#include \"iscsi-test-cu.h\"\n#include \"iscsi-support.h\"\n#include \"iscsi-multipath.h\"\n\n#define        PROG        \"iscsi-test-cu\"\n\nint loglevel = LOG_NORMAL;\nstruct scsi_device *sd = NULL;        /* mp_sds[0] alias */\nstatic unsigned int maxsectors;\n\n/*\n * this allows us to redefine how PDU are queued, at times, for\n * testing purposes\n */\nint (*real_iscsi_queue_pdu)(struct iscsi_context *iscsi, struct iscsi_pdu *pdu);\n\n/*****************************************************************\n *\n * list of tests and test suites\n *\n *****************************************************************/\nstatic CU_TestInfo tests_compareandwrite[] = {\n        { (char *)\"Simple\", test_compareandwrite_simple },\n        { (char *)\"DpoFua\", test_compareandwrite_dpofua },\n        { (char *)\"Miscompare\", test_compareandwrite_miscompare },\n        { (char *)\"Unwritten\", test_compareandwrite_unwritten },\n        { (char *)\"InvalidDataOutSize\",\n          test_compareandwrite_invalid_dataout_size },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_get_lba_status[] = {\n        { (char *)\"Simple\", test_get_lba_status_simple },\n        { (char *)\"BeyondEol\", test_get_lba_status_beyond_eol },\n        { (char *)\"UnmapSingle\", test_get_lba_status_unmap_single },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_inquiry[] = {\n        { (char *)\"Standard\", test_inquiry_standard },\n        { (char *)\"AllocLength\", test_inquiry_alloc_length},\n        { (char *)\"EVPD\", test_inquiry_evpd},\n        { (char *)\"BlockLimits\", test_inquiry_block_limits},\n        { (char *)\"MandatoryVPDSBC\", test_inquiry_mandatory_vpd_sbc},\n        { (char *)\"SupportedVPD\", test_inquiry_supported_vpd},\n        { (char *)\"VersionDescriptors\", test_inquiry_version_descriptors},\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_mandatory[] = {\n        { (char *)\"MandatorySBC\", test_mandatory_sbc },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_modesense6[] = {\n        { (char *)\"AllPages\", test_modesense6_all_pages },\n        { (char *)\"Control\", test_modesense6_control },\n        { (char *)\"Control-D_SENSE\", test_modesense6_control_d_sense },\n        { (char *)\"Control-SWP\", test_modesense6_control_swp },\n        { (char *)\"Residuals\", test_modesense6_residuals },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_nomedia[] = {\n        { (char *)\"NoMediaSBC\", test_nomedia_sbc },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_orwrite[] = {\n        { (char *)\"Simple\", test_orwrite_simple },\n        { (char *)\"BeyondEol\", test_orwrite_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_orwrite_0blocks },\n        { (char *)\"Protect\", test_orwrite_wrprotect },\n        { (char *)\"DpoFua\", test_orwrite_dpofua },\n        { (char *)\"Verify\", test_orwrite_verify },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prefetch10[] = {\n        { (char *)\"Simple\", test_prefetch10_simple },\n        { (char *)\"BeyondEol\", test_prefetch10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_prefetch10_0blocks },\n        { (char *)\"Flags\", test_prefetch10_flags },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prefetch16[] = {\n        { (char *)\"Simple\", test_prefetch16_simple },\n        { (char *)\"BeyondEol\", test_prefetch16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_prefetch16_0blocks },\n        { (char *)\"Flags\", test_prefetch16_flags },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_preventallow[] = {\n        { (char *)\"Simple\", test_preventallow_simple },\n        { (char *)\"Eject\", test_preventallow_eject },\n        { (char *)\"ITNexusLoss\", test_preventallow_itnexus_loss },\n        { (char *)\"Logout\", test_preventallow_logout },\n        { (char *)\"WarmReset\", test_preventallow_warm_reset },\n        { (char *)\"ColdReset\", test_preventallow_cold_reset },\n        { (char *)\"LUNReset\", test_preventallow_lun_reset },\n        { (char *)\"2ITNexuses\", test_preventallow_2_itnexuses },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prin_read_keys[] = {\n        { (char *)\"Simple\", test_prin_read_keys_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prin_report_caps[] = {\n        { (char *)\"Simple\", test_prin_report_caps_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_register[] = {\n        { (char *)\"Simple\", test_prout_register_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_reserve[] = {\n        { (char *)\"Simple\",\n          test_prout_reserve_simple },\n        { (char *)\"AccessEA\",\n          test_prout_reserve_access_ea },\n        { (char *)\"AccessWE\",\n          test_prout_reserve_access_we },\n        { (char *)\"AccessEARO\",\n          test_prout_reserve_access_earo },\n        { (char *)\"AccessWERO\",\n          test_prout_reserve_access_wero },\n        { (char *)\"AccessEAAR\",\n          test_prout_reserve_access_eaar },\n        { (char *)\"AccessWEAR\",\n          test_prout_reserve_access_wear },\n        { (char *)\"OwnershipEA\",\n          test_prout_reserve_ownership_ea },\n        { (char *)\"OwnershipWE\",\n          test_prout_reserve_ownership_we },\n        { (char *)\"OwnershipEARO\",\n          test_prout_reserve_ownership_earo },\n        { (char *)\"OwnershipWERO\",\n          test_prout_reserve_ownership_wero },\n        { (char *)\"OwnershipEAAR\",\n          test_prout_reserve_ownership_eaar },\n        { (char *)\"OwnershipWEAR\",\n          test_prout_reserve_ownership_wear },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_clear[] = {\n        { (char *)\"Simple\",\n          test_prout_clear_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prout_preempt[] = {\n        { (char *)\"RemoveRegistration\",\n          test_prout_preempt_rm_reg },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_prin_serviceaction_range[] = {\n        { (char *)\"Range\", test_prin_serviceaction_range },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read6[] = {\n        { (char *)\"Simple\", test_read6_simple },\n        { (char *)\"BeyondEol\", test_read6_beyond_eol },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read10[] = {\n        { (char *)\"Simple\", test_read10_simple },\n        { (char *)\"BeyondEol\", test_read10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_read10_0blocks },\n        { (char *)\"ReadProtect\", test_read10_rdprotect },\n        { (char *)\"DpoFua\", test_read10_dpofua },\n        { (char *)\"Async\", test_async_read },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read12[] = {\n        { (char *)\"Simple\", test_read12_simple },\n        { (char *)\"BeyondEol\", test_read12_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_read12_0blocks },\n        { (char *)\"ReadProtect\", test_read12_rdprotect },\n        { (char *)\"DpoFua\", test_read12_dpofua },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_read16[] = {\n        { (char *)\"Simple\", test_read16_simple },\n        { (char *)\"BeyondEol\", test_read16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_read16_0blocks },\n        { (char *)\"ReadProtect\", test_read16_rdprotect },\n        { (char *)\"DpoFua\", test_read16_dpofua },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readcapacity10[] = {\n        { (char *)\"Simple\", test_readcapacity10_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readcapacity16[] = {\n        { (char *)\"Simple\", test_readcapacity16_simple },\n        { (char *)\"Alloclen\", test_readcapacity16_alloclen },\n        { (char *)\"PI\", test_readcapacity16_protection },\n        { (char *)\"Support\", test_readcapacity16_support },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readdefectdata10[] = {\n        { (char *)\"Simple\", test_readdefectdata10_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readdefectdata12[] = {\n        { (char *)\"Simple\", test_readdefectdata12_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_readonly[] = {\n        { (char *)\"ReadOnlySBC\", test_readonly_sbc },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_sanitize[] = {\n        { (char *)\"BlockErase\", test_sanitize_block_erase },\n        { (char *)\"BlockEraseReserved\", test_sanitize_block_erase_reserved },\n        { (char *)\"CryptoErase\", test_sanitize_crypto_erase },\n        { (char *)\"CryptoEraseReserved\", test_sanitize_crypto_erase_reserved },\n        { (char *)\"ExitFailureMode\", test_sanitize_exit_failure_mode },\n        { (char *)\"InvalidServiceAction\", test_sanitize_invalid_serviceaction },\n        { (char *)\"Overwrite\", test_sanitize_overwrite },\n        { (char *)\"OverwriteReserved\", test_sanitize_overwrite_reserved },\n        { (char *)\"Readonly\", test_sanitize_readonly },\n        { (char *)\"Reservations\", test_sanitize_reservations },\n        { (char *)\"Reset\", test_sanitize_reset },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_extended_copy[] = {\n        { (char *)\"Simple\", test_extendedcopy_simple },\n        { (char *)\"ParamHdr\", test_extendedcopy_param },\n        { (char *)\"DescrLimits\", test_extendedcopy_descr_limits },\n        { (char *)\"DescrType\", test_extendedcopy_descr_type },\n        { (char *)\"ValidTgtDescr\", test_extendedcopy_validate_tgt_descr },\n        { (char *)\"ValidSegDescr\", test_extendedcopy_validate_seg_descr },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_receive_copy_results[] = {\n        { (char *)\"CopyStatus\", test_receive_copy_results_copy_status },\n        { (char *)\"OpParams\", test_receive_copy_results_op_params },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_report_supported_opcodes[] = {\n        { (char *)\"Simple\", test_report_supported_opcodes_simple },\n        { (char *)\"OneCommand\", test_report_supported_opcodes_one_command },\n        { (char *)\"RCTD\", test_report_supported_opcodes_rctd },\n        { (char *)\"SERVACTV\", test_report_supported_opcodes_servactv },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_reserve6[] = {\n        { (char *)\"Simple\", test_reserve6_simple },\n        { (char *)\"2Initiators\", test_reserve6_2initiators },\n        { (char *)\"Logout\", test_reserve6_logout },\n        { (char *)\"ITNexusLoss\", test_reserve6_itnexus_loss },\n        { (char *)\"TargetColdReset\", test_reserve6_target_cold_reset },\n        { (char *)\"TargetWarmReset\", test_reserve6_target_warm_reset },\n        { (char *)\"LUNReset\", test_reserve6_lun_reset },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_testunitready[] = {\n        { (char *)\"Simple\", test_testunitready_simple },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_startstopunit[] = {\n        { (char *)\"Simple\", test_startstopunit_simple },\n        { (char *)\"PwrCnd\", test_startstopunit_pwrcnd },\n        { (char *)\"NoLoej\", test_startstopunit_noloej },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_unmap[] = {\n        { (char *)\"Simple\", test_unmap_simple },\n        { (char *)\"VPD\", test_unmap_vpd },\n        { (char *)\"ZeroBlocks\", test_unmap_0blocks },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify10[] = {\n        { (char *)\"Simple\", test_verify10_simple },\n        { (char *)\"BeyondEol\", test_verify10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_verify10_0blocks },\n        { (char *)\"VerifyProtect\", test_verify10_vrprotect },\n        { (char *)\"Flags\", test_verify10_flags },\n        { (char *)\"Dpo\", test_verify10_dpo },\n        { (char *)\"Mismatch\", test_verify10_mismatch },\n        { (char *)\"MismatchNoCmp\", test_verify10_mismatch_no_cmp },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify12[] = {\n        { (char *)\"Simple\", test_verify12_simple },\n        { (char *)\"BeyondEol\", test_verify12_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_verify12_0blocks },\n        { (char *)\"VerifyProtect\", test_verify12_vrprotect },\n        { (char *)\"Flags\", test_verify12_flags },\n        { (char *)\"Dpo\", test_verify12_dpo },\n        { (char *)\"Mismatch\", test_verify12_mismatch },\n        { (char *)\"MismatchNoCmp\", test_verify12_mismatch_no_cmp },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_verify16[] = {\n        { (char *)\"Simple\", test_verify16_simple },\n        { (char *)\"BeyondEol\", test_verify16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_verify16_0blocks },\n        { (char *)\"VerifyProtect\", test_verify16_vrprotect },\n        { (char *)\"Flags\", test_verify16_flags },\n        { (char *)\"Dpo\", test_verify16_dpo },\n        { (char *)\"Mismatch\", test_verify16_mismatch },\n        { (char *)\"MismatchNoCmp\", test_verify16_mismatch_no_cmp },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write10[] = {\n        { (char *)\"Simple\", test_write10_simple },\n        { (char *)\"BeyondEol\", test_write10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_write10_0blocks },\n        { (char *)\"WriteProtect\", test_write10_wrprotect },\n        { (char *)\"DpoFua\", test_write10_dpofua },\n        { (char *)\"Async\", test_async_write },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write12[] = {\n        { (char *)\"Simple\", test_write12_simple },\n        { (char *)\"BeyondEol\", test_write12_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_write12_0blocks },\n        { (char *)\"WriteProtect\", test_write12_wrprotect },\n        { (char *)\"DpoFua\", test_write12_dpofua },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_write16[] = {\n        { (char *)\"Simple\", test_write16_simple },\n        { (char *)\"BeyondEol\", test_write16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_write16_0blocks },\n        { (char *)\"WriteProtect\", test_write16_wrprotect },\n        { (char *)\"DpoFua\", test_write16_dpofua },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeatomic16[] = {\n        { (char *)\"Simple\", test_writeatomic16_simple },\n        { (char *)\"BeyondEol\", test_writeatomic16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writeatomic16_0blocks },\n        { (char *)\"WriteProtect\", test_writeatomic16_wrprotect },\n        { (char *)\"DpoFua\", test_writeatomic16_dpofua },\n        { (char *)\"VPD\", test_writeatomic16_vpd },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writesame10[] = {\n        { (char *)\"Simple\", test_writesame10_simple },\n        { (char *)\"BeyondEol\", test_writesame10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writesame10_0blocks },\n        { (char *)\"WriteProtect\", test_writesame10_wrprotect },\n        { (char *)\"Unmap\", test_writesame10_unmap },\n        { (char *)\"UnmapUnaligned\", test_writesame10_unmap_unaligned },\n        { (char *)\"UnmapUntilEnd\", test_writesame10_unmap_until_end },\n        { (char *)\"UnmapVPD\", test_writesame10_unmap_vpd },\n        { (char *)\"Check\", test_writesame10_check },\n        { (char *)\"InvalidDataOutSize\", test_writesame10_invalid_dataout_size },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writesame16[] = {\n        { (char *)\"Simple\", test_writesame16_simple },\n        { (char *)\"BeyondEol\", test_writesame16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writesame16_0blocks },\n        { (char *)\"WriteProtect\", test_writesame16_wrprotect },\n        { (char *)\"Unmap\", test_writesame16_unmap },\n        { (char *)\"UnmapUnaligned\", test_writesame16_unmap_unaligned },\n        { (char *)\"UnmapUntilEnd\", test_writesame16_unmap_until_end },\n        { (char *)\"UnmapVPD\", test_writesame16_unmap_vpd },\n        { (char *)\"Check\", test_writesame16_check },\n        { (char *)\"InvalidDataOutSize\", test_writesame16_invalid_dataout_size },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify10[] = {\n        { (char *)\"Simple\", test_writeverify10_simple },\n        { (char *)\"BeyondEol\", test_writeverify10_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writeverify10_0blocks },\n        { (char *)\"WriteProtect\", test_writeverify10_wrprotect },\n        { (char *)\"Flags\", test_writeverify10_flags },\n        { (char *)\"Dpo\", test_writeverify10_dpo },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify12[] = {\n        { (char *)\"Simple\", test_writeverify12_simple },\n        { (char *)\"BeyondEol\", test_writeverify12_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writeverify12_0blocks },\n        { (char *)\"WriteProtect\", test_writeverify12_wrprotect },\n        { (char *)\"Flags\", test_writeverify12_flags },\n        { (char *)\"Dpo\", test_writeverify12_dpo },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_writeverify16[] = {\n        { (char *)\"Simple\", test_writeverify16_simple },\n        { (char *)\"BeyondEol\", test_writeverify16_beyond_eol },\n        { (char *)\"ZeroBlocks\", test_writeverify16_0blocks },\n        { (char *)\"WriteProtect\", test_writeverify16_wrprotect },\n        { (char *)\"Flags\", test_writeverify16_flags },\n        { (char *)\"Dpo\", test_writeverify16_dpo },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_multipathio[] = {\n        { (char *)\"Simple\", test_multipathio_simple },\n        { (char *)\"Reset\", test_multipathio_reset },\n        { (char *)\"CompareAndWrite\", test_multipathio_compareandwrite },\n        { (char *)\"CompareAndWriteAsync\", test_mpio_async_caw },\n        CU_TEST_INFO_NULL\n};\n\ntypedef struct libiscsi_suite_info {\n        const char       *pName;         /**< Suite name. */\n        CU_InitializeFunc pInitFunc;     /**< Suite initialization function. */\n        CU_CleanupFunc    pCleanupFunc;  /**< Suite cleanup function */\n        CU_SetUpFunc      pSetUpFunc;    /**< Test setup function. */\n        CU_TearDownFunc   pTearDownFunc; /**< Test tear down function */\n        CU_TestInfo      *pTests;        /**< Test case array - must be NULL terminated. */\n} libiscsi_suite_info;\n\n#define NON_PGR_FUNCS suite_init, suite_cleanup, test_setup, test_teardown\n\n/* SCSI protocol tests */\nstatic libiscsi_suite_info scsi_suites[] = {\n        { \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n        { \"ExtendedCopy\", NON_PGR_FUNCS, tests_extended_copy },\n        { \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n        { \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n        { \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n        { \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n        { \"NoMedia\", NON_PGR_FUNCS, tests_nomedia },\n        { \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n        { \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n        { \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n        { \"PreventAllow\", NON_PGR_FUNCS, tests_preventallow },\n        { \"PrinReadKeys\", NON_PGR_FUNCS, tests_prin_read_keys },\n        { \"PrinServiceactionRange\", NON_PGR_FUNCS, tests_prin_serviceaction_range },\n        { \"PrinReportCapabilities\", NON_PGR_FUNCS, tests_prin_report_caps },\n        { \"ProutRegister\", NON_PGR_FUNCS, tests_prout_register },\n        { \"ProutReserve\", NON_PGR_FUNCS, tests_prout_reserve },\n        { \"ProutClear\", NON_PGR_FUNCS, tests_prout_clear },\n        { \"ProutPreempt\", NON_PGR_FUNCS, tests_prout_preempt },\n        { \"Read6\", NON_PGR_FUNCS, tests_read6 },\n        { \"Read10\", NON_PGR_FUNCS, tests_read10 },\n        { \"Read12\", NON_PGR_FUNCS, tests_read12 },\n        { \"Read16\", NON_PGR_FUNCS, tests_read16 },\n        { \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n        { \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n        { \"ReadDefectData10\", NON_PGR_FUNCS, tests_readdefectdata10 },\n        { \"ReadDefectData12\", NON_PGR_FUNCS, tests_readdefectdata12 },\n        { \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n        { \"ReceiveCopyResults\", NON_PGR_FUNCS, tests_receive_copy_results },\n        { \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n          tests_report_supported_opcodes },\n        { \"Reserve6\", NON_PGR_FUNCS, tests_reserve6 },\n        { \"Sanitize\", NON_PGR_FUNCS, tests_sanitize },\n        { \"StartStopUnit\", NON_PGR_FUNCS, tests_startstopunit },\n        { \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n        { \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n        { \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n        { \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n        { \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n        { \"Write10\", NON_PGR_FUNCS, tests_write10 },\n        { \"Write12\", NON_PGR_FUNCS, tests_write12 },\n        { \"Write16\", NON_PGR_FUNCS, tests_write16 },\n        { \"WriteAtomic16\", NON_PGR_FUNCS, tests_writeatomic16 },\n        { \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n        { \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n        { \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n        { \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n        { \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n        { \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n        { NULL, NULL, NULL, NULL, NULL, NULL }\n};\n\nstatic CU_TestInfo tests_iscsi_cmdsn[] = {\n        { (char *)\"iSCSICmdSnTooHigh\", test_iscsi_cmdsn_toohigh },\n        { (char *)\"iSCSICmdSnTooLow\", test_iscsi_cmdsn_toolow },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_iscsi_datasn[] = {\n        { (char *)\"iSCSIDataSnInvalid\", test_iscsi_datasn_invalid },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_iscsi_residuals[] = {\n        { (char *)\"Read10Invalid\", test_read10_invalid },\n        { (char *)\"Read10Residuals\", test_read10_residuals },\n        { (char *)\"Read12Residuals\", test_read12_residuals },\n        { (char *)\"Read16Residuals\", test_read16_residuals },\n        { (char *)\"Write10Residuals\", test_write10_residuals },\n        { (char *)\"Write12Residuals\", test_write12_residuals },\n        { (char *)\"Write16Residuals\", test_write16_residuals },\n        { (char *)\"WriteVerify10Residuals\", test_writeverify10_residuals },\n        { (char *)\"WriteVerify12Residuals\", test_writeverify12_residuals },\n        { (char *)\"WriteVerify16Residuals\", test_writeverify16_residuals },\n        CU_TEST_INFO_NULL\n};\n\nstatic CU_TestInfo tests_iscsi_tmf[] = {\n        { (char *)\"AbortTaskSimpleAsync\", test_async_abort_simple },\n        { (char *)\"LUNResetSimpleAsync\", test_async_lu_reset_simple },\n        CU_TEST_INFO_NULL\n};\n\n/* iSCSI protocol tests */\nstatic libiscsi_suite_info iscsi_suites[] = {\n        { \"iSCSIcmdsn\", NON_PGR_FUNCS,\n          tests_iscsi_cmdsn },\n        { \"iSCSIdatasn\", NON_PGR_FUNCS,\n          tests_iscsi_datasn },\n        { \"iSCSIResiduals\", NON_PGR_FUNCS,\n          tests_iscsi_residuals },\n\t{ \"iSCSITMF\", NON_PGR_FUNCS,\n\t  tests_iscsi_tmf },\n        { NULL, NULL, NULL, NULL, NULL, NULL }\n};\n\n/* All tests */\nstatic libiscsi_suite_info all_suites[] = {\n        { \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n        { \"ExtendedCopy\", NON_PGR_FUNCS, tests_extended_copy },\n        { \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n        { \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n        { \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n        { \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n        { \"NoMedia\", NON_PGR_FUNCS, tests_nomedia },\n        { \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n        { \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n        { \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n        { \"PreventAllow\", NON_PGR_FUNCS, tests_preventallow },\n        { \"PrinReadKeys\", NON_PGR_FUNCS, tests_prin_read_keys },\n        { \"PrinServiceactionRange\", NON_PGR_FUNCS,\n          tests_prin_serviceaction_range },\n        { \"PrinReportCapabilities\", NON_PGR_FUNCS, tests_prin_report_caps },\n        { \"ProutRegister\", NON_PGR_FUNCS, tests_prout_register },\n        { \"ProutReserve\", NON_PGR_FUNCS, tests_prout_reserve },\n        { \"ProutClear\", NON_PGR_FUNCS, tests_prout_clear },\n        { \"ProutPreempt\", NON_PGR_FUNCS, tests_prout_preempt },\n        { \"Read6\", NON_PGR_FUNCS, tests_read6 },\n        { \"Read10\", NON_PGR_FUNCS, tests_read10 },\n        { \"Read12\", NON_PGR_FUNCS, tests_read12 },\n        { \"Read16\", NON_PGR_FUNCS, tests_read16 },\n        { \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n        { \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n        { \"ReadDefectData10\", NON_PGR_FUNCS, tests_readdefectdata10 },\n        { \"ReadDefectData12\", NON_PGR_FUNCS, tests_readdefectdata12 },\n        { \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n        { \"ReceiveCopyResults\", NON_PGR_FUNCS, tests_receive_copy_results },\n        { \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n          tests_report_supported_opcodes },\n        { \"Reserve6\", NON_PGR_FUNCS, tests_reserve6 },\n        { \"Sanitize\", NON_PGR_FUNCS, tests_sanitize },\n        { \"StartStopUnit\", NON_PGR_FUNCS, tests_startstopunit },\n        { \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n        { \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n        { \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n        { \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n        { \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n        { \"Write10\", NON_PGR_FUNCS, tests_write10 },\n        { \"Write12\", NON_PGR_FUNCS, tests_write12 },\n        { \"Write16\", NON_PGR_FUNCS, tests_write16 },\n        { \"WriteAtomic16\", NON_PGR_FUNCS, tests_writeatomic16 },\n        { \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n        { \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n        { \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n        { \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n        { \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n        { \"iSCSIcmdsn\", NON_PGR_FUNCS, tests_iscsi_cmdsn },\n        { \"iSCSIdatasn\", NON_PGR_FUNCS, tests_iscsi_datasn },\n        { \"iSCSIResiduals\", NON_PGR_FUNCS, tests_iscsi_residuals },\n\t{ \"iSCSITMF\", NON_PGR_FUNCS, tests_iscsi_tmf },\n        { \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n        { NULL, NULL, NULL, NULL, NULL, NULL },\n};\n\nstatic libiscsi_suite_info linux_suites[] = {\n        { \"CompareAndWrite\", NON_PGR_FUNCS, tests_compareandwrite },\n        { \"GetLBAStatus\", NON_PGR_FUNCS, tests_get_lba_status },\n        { \"Inquiry\", NON_PGR_FUNCS, tests_inquiry },\n        { \"Mandatory\", NON_PGR_FUNCS, tests_mandatory },\n        { \"ModeSense6\", NON_PGR_FUNCS, tests_modesense6 },\n        { \"OrWrite\", NON_PGR_FUNCS, tests_orwrite },\n        { \"Prefetch10\", NON_PGR_FUNCS, tests_prefetch10 },\n        { \"Prefetch16\", NON_PGR_FUNCS, tests_prefetch16 },\n        { \"Read10\", NON_PGR_FUNCS, tests_read10 },\n        { \"Read12\", NON_PGR_FUNCS, tests_read12 },\n        { \"Read16\", NON_PGR_FUNCS, tests_read16 },\n        { \"ReadCapacity10\", NON_PGR_FUNCS, tests_readcapacity10 },\n        { \"ReadCapacity16\", NON_PGR_FUNCS, tests_readcapacity16 },\n        { \"ReadDefectData10\", NON_PGR_FUNCS, tests_readdefectdata10 },\n        { \"ReadDefectData12\", NON_PGR_FUNCS, tests_readdefectdata12 },\n        { \"ReadOnly\", NON_PGR_FUNCS, tests_readonly },\n        { \"ReportSupportedOpcodes\", NON_PGR_FUNCS,\n          tests_report_supported_opcodes },\n        { \"TestUnitReady\", NON_PGR_FUNCS, tests_testunitready },\n        { \"Unmap\", NON_PGR_FUNCS, tests_unmap },\n        { \"Verify10\", NON_PGR_FUNCS, tests_verify10 },\n        { \"Verify12\", NON_PGR_FUNCS, tests_verify12 },\n        { \"Verify16\", NON_PGR_FUNCS, tests_verify16 },\n        { \"Write10\", NON_PGR_FUNCS, tests_write10 },\n        { \"Write12\", NON_PGR_FUNCS, tests_write12 },\n        { \"Write16\", NON_PGR_FUNCS, tests_write16 },\n        { \"WriteAtomic16\", NON_PGR_FUNCS, tests_writeatomic16 },\n        { \"WriteSame10\", NON_PGR_FUNCS, tests_writesame10 },\n        { \"WriteSame16\", NON_PGR_FUNCS, tests_writesame16 },\n        { \"WriteVerify10\", NON_PGR_FUNCS, tests_writeverify10 },\n        { \"WriteVerify12\", NON_PGR_FUNCS, tests_writeverify12 },\n        { \"WriteVerify16\", NON_PGR_FUNCS, tests_writeverify16 },\n        { \"MultipathIO\", NON_PGR_FUNCS, tests_multipathio },\n        { NULL, NULL, NULL, NULL, NULL, NULL },\n};\n\nstruct test_family {\n       const char *name;\n       libiscsi_suite_info *suites;\n};\n\nstatic struct test_family families[] = {\n        { \"ALL\",                all_suites },\n        { \"SCSI\",                scsi_suites },\n        { \"iSCSI\",                iscsi_suites },\n        { \"LINUX\",                linux_suites },\n        { NULL, NULL}\n};\n\n/*\n * globals for test setup and teardown\n */\nstruct scsi_task *task;\nunsigned char *read_write_buf;\n\nstatic void\nprint_usage(void)\n{\n        fprintf(stderr,\n            \"Usage: %s [-?|--help]    print this message and exit\\n\",\n            PROG);\n        fprintf(stderr,\n            \"or     %s [OPTIONS] <iscsi-url> [multipath-iscsi-url]\\n\", PROG);\n        fprintf(stderr,\n            \"Where OPTIONS are from:\\n\");\n        fprintf(stderr,\n            \"  -i|--initiator-name=iqn-name     Initiatorname to use [%s]\\n\",\n                initiatorname1);\n        fprintf(stderr,\n            \"  -I|--initiator-name-2=iqn-name   2nd Initiatorname to use [%s]\\n\",\n                initiatorname2);\n        fprintf(stderr,\n            \"  -t|--test=test-name-reg-exp      Test(s) to run [ALL] <NOT YET IMPLEMENTED>\\n\");\n        fprintf(stderr,\n            \"  -l|--list                        List all tests and exit\\n\");\n        fprintf(stderr,\n            \"  -d|--dataloss                    Allow destructive tests\\n\");\n        fprintf(stderr,\n            \"  -S|--allow-sanitize              Allow sanitize-opcode tests\\n\");\n        fprintf(stderr,\n            \"  -g|--ignore                      Error Action: Ignore test errors [DEFAULT]\\n\");\n        fprintf(stderr,\n            \"  -f|--fail                        Error Action: FAIL if any tests fail\\n\");\n        fprintf(stderr,\n            \"  -A|--abort                       Error Action: ABORT if any tests fail\\n\");\n        fprintf(stderr,\n            \"  -s|--silent                      Test Mode: Silent\\n\");\n        fprintf(stderr,\n            \"  -n|--normal                      Test Mode: Normal\\n\");\n        fprintf(stderr,\n            \"  -v|--verbose                     Test Mode: Verbose [DEFAULT]\\n\");\n        fprintf(stderr,\n            \"  -x|--xml                         Test Mode: XML\\n\");\n        fprintf(stderr,\n            \"  -V|--Verbose-scsi                Enable verbose SCSI logging [default SILENT]\\n\");\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr,\n            \"Where <iscsi-url> iSCSI URL format is: %s\\n\", ISCSI_URL_SYNTAX);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr,\n            \"<host> is one of:\\n\");\n        fprintf(stderr,\n            \"  \\\"hostname\\\"       e.g. iscsi.example\\n\");\n        fprintf(stderr,\n            \"  \\\"ipv4-address\\\"   e.g. 10.1.1.27\\n\");\n        fprintf(stderr,\n            \"  \\\"ipv6-address\\\"   e.g. [fce0::1]\\n\");\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr,\n            \"and <test-name-reg-exp> is of the form: FAMILY[.SUITE[.TEST]]\\n\");\n        fprintf(stderr, \"\\n\");\n}\n\nvoid\ntest_setup(void)\n{\n        task = NULL;\n        read_write_buf = NULL;\n        local_iscsi_queue_pdu = NULL;\n}\n\nvoid\ntest_teardown(void)\n{\n        free(read_write_buf);\n        read_write_buf = NULL;\n        scsi_free_scsi_task(task);\n        task = NULL;\n}\n\nint\nsuite_init(void)\n{\n        int i;\n        char const *initiatornames[MPATH_MAX_DEVS] = { initiatorname1, initiatorname2 };\n\n        for (i = 0; i < mp_num_sds; i++) {\n                if (!mp_sds[i]->iscsi_url) {\n                        continue;\n                }\n                if (mp_sds[i]->iscsi_ctx) {\n                        iscsi_logout_sync(mp_sds[i]->iscsi_ctx);\n                        iscsi_destroy_context(mp_sds[i]->iscsi_ctx);\n                }\n                mp_sds[i]->iscsi_ctx = iscsi_context_login(initiatornames[i],\n                                                        mp_sds[i]->iscsi_url,\n                                                        &mp_sds[i]->iscsi_lun);\n                if (mp_sds[i]->iscsi_ctx == NULL) {\n                        fprintf(stderr,\n                                \"error: Failed to login to target for test set-up\\n\");\n                        return 1;\n                }\n                iscsi_set_no_ua_on_reconnect(mp_sds[i]->iscsi_ctx, 1);\n        }\n#ifndef HAVE_CU_SUITEINFO_PSETUPFUNC\n        /* libcunit version 1 */\n        test_setup();\n#endif\n        return 0;\n}\n\nint\nsuite_cleanup(void)\n{\n        int i;\n\n#ifndef HAVE_CU_SUITEINFO_PSETUPFUNC\n        /* libcunit version 1 */\n        test_teardown();\n#endif\n        for (i = 0; i < mp_num_sds; i++) {\n                if (mp_sds[i]->iscsi_url) {\n                        if (mp_sds[i]->iscsi_ctx) {\n                                iscsi_logout_sync(mp_sds[i]->iscsi_ctx);\n                                iscsi_destroy_context(mp_sds[i]->iscsi_ctx);\n                                mp_sds[i]->iscsi_ctx = NULL;\n                        }\n                }\n        }\n        return 0;\n}\n\nstatic void\nlist_all_tests(void)\n{\n        struct test_family *fp;\n        libiscsi_suite_info *sp;\n        CU_TestInfo *tp;\n\n        for (fp = families; fp->name; fp++) {\n                printf(\"%s\\n\", fp->name);\n                for (sp = fp->suites; sp->pName != NULL; sp++) {\n                        printf(\"%s.%s\\n\", fp->name,sp->pName);\n                        for (tp = sp->pTests; tp->pName != NULL; tp++) {\n                                printf(\"%s.%s.%s\\n\", fp->name,sp->pName,\n                                        tp->pName);\n                        }\n                }\n        }\n}\n\n\nstatic CU_ErrorCode\nadd_tests(const char *testname_re)\n{\n        char *family_re = NULL;\n        char *suite_re = NULL;\n        char *test_re = NULL;\n        char *cp;\n        struct test_family *fp;\n        libiscsi_suite_info *sp;\n        CU_TestInfo *tp;\n\n\n        /* if not testname(s) register all tests */\n        if (!testname_re) {\n                family_re = strdup(\"*\");\n                suite_re = strdup(\"*\");\n                test_re = strdup(\"*\");\n        } else {\n                /*\n                 * break testname_re into family/suite/test\n                 *\n                 * syntax is:  FAMILY[.SUITE[.TEST]]\n                 */\n                family_re = strdup(testname_re);\n                if ((cp = strchr(family_re, '.')) != NULL) {\n                        *cp++ = 0;\n                        suite_re = strdup(cp);\n                        if ((cp = strchr(suite_re, '.')) != NULL) {\n                                *cp++ = 0;\n                                test_re = strdup(cp);\n                        }\n                }\n                if (!suite_re)\n                        suite_re = strdup(\"*\");\n                if (!test_re)\n                        test_re = strdup(\"*\");\n                if (!family_re) {\n                        fprintf(stderr,\n                                \"error: can't parse test family name: %s\\n\",\n                                family_re);\n                        return CUE_NOTEST;\n                }\n        }\n\n        /*\n         * cycle through the test families/suites/tests, adding\n         * ones that match\n         */\n        for (fp = families; fp->name; fp++) {\n                if (fnmatch(family_re, fp->name, 0) != 0)\n                    continue;\n\n                for (sp = fp->suites; sp->pName != NULL; sp++) {\n                        int suite_added = 0;\n                        CU_pSuite pSuite = NULL;\n\n                        if (fnmatch(suite_re, sp->pName, 0) != 0)\n                                continue;\n\n                        for (tp = sp->pTests; tp->pName != NULL; tp++) {\n                                if (fnmatch(test_re, tp->pName, 0) != 0) {\n                                        continue;\n                                }\n                                if (!suite_added) {\n                                        suite_added++;\n#ifdef HAVE_CU_SUITEINFO_PSETUPFUNC\n                pSuite = CU_add_suite_with_setup_and_teardown(sp->pName,\n                                        sp->pInitFunc, sp->pCleanupFunc,\n                                        sp->pSetUpFunc, sp->pTearDownFunc);\n#else\n                                        pSuite = CU_add_suite(sp->pName,\n                                                sp->pInitFunc, sp->pCleanupFunc);\n#endif\n                                }\n                                CU_add_test(pSuite, tp->pName, tp->pTestFunc);\n                        }\n                }\n        }\n\n        /* all done -- clean up */\n        free(family_re);\n        free(suite_re);\n        free(test_re);\n\n        return CUE_SUCCESS;\n}\n\nstatic void parse_and_add_tests(char *testname_re);\n\nstatic void parse_and_add_test(const char *test)\n{\n        if (test && access(test, F_OK) == 0) {\n                FILE *fh;\n                char t[256];\n\n                if ((fh = fopen(test, \"r\")) == NULL) {\n                        printf(\"Failed to open test-list file %s\\n\", test);\n                        exit(10);\n                }\n                while (fgets(t, sizeof(t), fh) != NULL) {\n                        while (1) {\n                                int len = strlen(t);\n                                if (len == 0) {\n                                        break;\n                                }\n                                if (!isprint(t[--len])) {\n                                        t[len] = 0;\n                                        continue;\n                                }\n                                break;        \n                        }\n                        parse_and_add_tests(t);\n                }\n                fclose(fh);\n                return;\n        }\n\n        if (add_tests(test) != CUE_SUCCESS) {\n                fprintf(stderr, \"error: suite registration failed: %s\\n\",\n                    CU_get_error_msg());\n                exit(1);\n        }\n}\n\nstatic void parse_and_add_tests(char *testname_re)\n{\n        if (testname_re != NULL) {\n                char *testname;\n                while ((testname = strrchr(testname_re, ',')) != NULL) {\n                        parse_and_add_test(testname + 1);\n                        *testname = 0;\n                }\n        }\n        parse_and_add_test(testname_re);\n}\n\nstatic int connect_scsi_device(struct scsi_device *sdev, const char *initiatorname)\n{\n        if (sdev->iscsi_url) {\n                sdev->iscsi_ctx = iscsi_context_login(initiatorname, sdev->iscsi_url, &sdev->iscsi_lun);\n                if (sdev->iscsi_ctx == NULL) {\n                        return -1;\n                }\n                iscsi_set_no_ua_on_reconnect(sdev->iscsi_ctx, 1);\n                return 0;\n        }\n#ifdef HAVE_SG_IO\n        if (sdev->sgio_dev) {\n                int version;\n\n                if ((sdev->sgio_fd = open(sdev->sgio_dev, O_RDWR|O_NONBLOCK)) == -1) {\n                        fprintf(stderr, \"Failed to open SG_IO device %s. Error:%s\\n\", sdev->sgio_dev,\n                                strerror(errno));\n                        return -1;\n                }\n                if ((ioctl(sdev->sgio_fd, SG_GET_VERSION_NUM, &version) < 0) || (version < 30000)) {\n                        fprintf(stderr, \"%s is not a SCSI device node\\n\", sdev->sgio_dev);\n                        close(sdev->sgio_fd);\n                        return -1;\n                }\n                if (!strncmp(sdev->sgio_dev, \"/dev/sg\", 7)) {\n                        /* We can not set this until we have the block-size */\n                        printf(\"Can not use BLKSECTGET for /dev/sg devices\\n\");\n                        return 0;\n                }\n                if (ioctl(sdev->sgio_fd, BLKSECTGET, &maxsectors) < 0) {\n                        fprintf(stderr, \"%s failed to read BLKSECTGET\\n\", sdev->sgio_dev);\n                        close(sdev->sgio_fd);\n                        return -1;\n                }\n                return 0;\n        }\n#endif\n        return -1;\n}\n\nstatic void free_scsi_device(struct scsi_device *sdev)\n{\n        if (sdev->error_str) {\n                free(sdev->error_str);\n                sdev->error_str = NULL;\n        }\n        if (sdev->iscsi_url) {\n                free(sdev->iscsi_url);\n                sdev->iscsi_url = NULL;\n        }\n        if (sdev->iscsi_ctx) {\n                iscsi_logout_sync(sdev->iscsi_ctx);\n                iscsi_destroy_context(sdev->iscsi_ctx);\n                sdev->iscsi_ctx = NULL;\n        }\n\n        if (sdev->sgio_dev) {\n                free(sdev->sgio_dev);\n                sdev->sgio_dev = NULL;\n        }\n        if (sdev->sgio_fd != -1) {\n                close(sdev->sgio_fd);\n                sdev->sgio_fd = -1;\n        }\n        free(sdev);\n}\n\n/* Clear persistent reservations and reservation keys left by a previous run */\nstatic int clear_pr(struct scsi_device *sdev)\n{\n        int i, res;\n        struct scsi_task *pr_task;\n        struct scsi_persistent_reserve_in_read_keys *rk;\n\n        res = 0;\n        if (prin_read_keys(sdev, &pr_task, &rk) != 0)\n                goto out;\n\n        res = -1;\n        if (rk->num_keys && data_loss == 0)\n                goto out;\n\n        res = 0;\n        for (i = 0; i < rk->num_keys; i++) {\n                prout_register_and_ignore(sdev, rk->keys[i]);\n                prout_register_key(sdev, 0, rk->keys[i]);\n        }\n\n        scsi_free_scsi_task(pr_task);\n\nout:\n        return res;\n}\n\nint\nmain(int argc, char *argv[])\n{\n        char *testname_re = NULL;\n        CU_BasicRunMode mode = CU_BRM_VERBOSE;\n        CU_ErrorAction error_action = CUEA_IGNORE;\n        int res;\n        struct scsi_readcapacity10 *rc10;\n        struct scsi_task *inq_task = NULL;\n        struct scsi_task *inq_lbp_task = NULL;\n        struct scsi_task *inq_bdc_task = NULL;\n        struct scsi_task *inq_bl_task = NULL;\n        struct scsi_task *rc16_task = NULL;\n        struct scsi_task *rsop_task = NULL;\n        int full_size;\n        int xml_mode = 0;\n        static struct option long_opts[] = {\n                { \"help\", no_argument, 0, '?' },\n                { \"list\", no_argument, 0, 'l' },\n                { \"initiator-name\", required_argument, 0, 'i' },\n                { \"initiator-name-2\", required_argument, 0, 'I' },\n                { \"test\", required_argument, 0, 't' },\n                { \"dataloss\", no_argument, 0, 'd' },\n                { \"allow-sanitize\", no_argument, 0, 'S' },\n                { \"ignore\", no_argument, 0, 'g' },\n                { \"fail\", no_argument, 0, 'f' },\n                { \"abort\", no_argument, 0, 'A' },\n                { \"silent\", no_argument, 0, 's' },\n                { \"normal\", no_argument, 0, 'n' },\n                { \"verbose\", no_argument, 0, 'v' },\n                { \"xml\", no_argument, 0, 'x' },\n                { \"Verbose-scsi\", no_argument, 0, 'V' },\n                { NULL, 0, 0, 0 }\n        };\n        int i, c;\n        int opt_idx = 0;\n        unsigned int failures = 0;\n        int ret;\n\n        while ((c = getopt_long(argc, argv, \"?hli:I:t:sdgfAsSnvxV\", long_opts,\n                    &opt_idx)) > 0) {\n                switch (c) {\n                case 'h':\n                case '?':\n                        print_usage();\n                        return 0;\n                case 'l':\n                        list_all_tests();\n                        return 0;\n                case 'i':\n                        initiatorname1 = strdup(optarg);\n                        break;\n                case 'I':\n                        initiatorname2 = strdup(optarg);\n                        break;\n                case 't':\n                        testname_re = strdup(optarg);\n                        break;\n                case 'd':\n                        data_loss++;\n                        break;\n                case 'g':\n                        error_action = CUEA_IGNORE; /* default */\n                        break;\n                case 'f':\n                        error_action = CUEA_FAIL;\n                        break;\n                case 'A':\n                        error_action = CUEA_ABORT;\n                        break;\n                case 's':\n                        mode = CU_BRM_SILENT;\n                        break;\n                case 'S':\n                        allow_sanitize = 1;\n                        break;\n                case 'n':\n                        mode = CU_BRM_NORMAL;\n                        break;\n                case 'v':\n                        mode = CU_BRM_VERBOSE;        /* default */\n                        break;\n                case 'x':\n                        xml_mode = 1;\n                        break;\n                case 'V':\n                        loglevel = LOG_VERBOSE;\n                        break;\n                default:\n                        fprintf(stderr,\n                            \"error: unknown option return: %c (option %s)\\n\",\n                            c, argv[optind]);\n                        return 1;\n                }\n        }\n\n        /* parse all trailing arguments as device paths */\n        mp_num_sds = 0;\n        while (optind < argc) {\n                if (mp_num_sds >= MPATH_MAX_DEVS) {\n                        fprintf(stderr, \"Too many multipath device URLs\\n\");\n                        print_usage();\n                        free(testname_re);\n                        return 10;\n                }\n\n                mp_sds[mp_num_sds] = malloc(sizeof(struct scsi_device));\n                memset(mp_sds[mp_num_sds], '\\0', sizeof(struct scsi_device));\n                mp_sds[mp_num_sds]->sgio_fd = -1;\n\n                if (!strncmp(argv[optind], \"iscsi://\", 8)) {\n                        mp_sds[mp_num_sds]->iscsi_url = strdup(argv[optind++]);\n#ifdef HAVE_SG_IO\n                } else {\n                        mp_sds[mp_num_sds]->sgio_dev = strdup(argv[optind++]);\n#endif\n                }\n                mp_num_sds++;\n        }\n\n        /* So that we can override iscsi_queue_pdu in tests\n         * and replace or mutate the blob that we are about to write to the\n         * wire.\n         * This allows such tests to do their mutates and then call out\n         * to the real queueing function once they have modified the data.\n         */\n        real_iscsi_queue_pdu = dlsym(RTLD_NEXT, \"iscsi_queue_pdu\");\n\n        if ((mp_num_sds == 0) || (mp_sds[0]->iscsi_url == NULL\n                                        && mp_sds[0]->sgio_dev == NULL)) {\n#ifdef HAVE_SG_IO\n                fprintf(stderr, \"You must specify either an iSCSI URL or a device file\\n\");\n#else\n                fprintf(stderr, \"You must specify an iSCSI URL\\n\");\n#endif\n                print_usage();\n                if (testname_re)\n                        free(testname_re);\n                return 10;\n        }\n\n        /* sd remains an alias for the first device */\n        sd = mp_sds[0];\n\n        for (i = 0; i < mp_num_sds; i++) {\n                res = connect_scsi_device(mp_sds[i], initiatorname1);\n                if (res < 0) {\n                        fprintf(stderr,\n                                \"Failed to connect to SCSI device %d\\n\", i);\n                        goto err_sds_free;\n                }\n        }\n\n        if (mp_num_sds > 1) {\n                /* check that all multipath sds identify as the same LU */\n                res = mpath_check_matching_ids(mp_num_sds, mp_sds);\n                if (res < 0) {\n                        fprintf(stderr, \"multipath devices don't match\\n\");\n                        goto err_sds_free;\n                }\n        }\n\n        /*\n         * find the size of the LUN\n         * All devices support readcapacity10 but only some support\n         * readcapacity16\n         */\n        task = NULL;\n        readcapacity10(sd, &task, 0, 0, EXPECT_STATUS_GOOD);\n        if (task == NULL) {\n                printf(\"Failed to send READCAPACITY10 command: %s\\n\", sd->error_str);\n                goto err_sds_free;\n        }\n        if (task->status != SCSI_STATUS_GOOD) {\n                printf(\"READCAPACITY10 command: failed with sense. %s\\n\", sd->error_str);\n                scsi_free_scsi_task(task);\n                goto err_sds_free;\n        }\n        rc10 = scsi_datain_unmarshall(task);\n        if (rc10 == NULL) {\n                printf(\"failed to unmarshall READCAPACITY10 data.\\n\");\n                scsi_free_scsi_task(task);\n                goto err_sds_free;\n        }\n        block_size = rc10->block_size;\n        num_blocks = rc10->lba + 1;\n        scsi_free_scsi_task(task);\n\n        rc16_task = NULL;\n        readcapacity16(sd, &rc16_task, 96, EXPECT_STATUS_GOOD);\n        if (rc16_task == NULL) {\n                printf(\"Failed to send READCAPACITY16 command: %s\\n\", sd->error_str);\n                goto err_sds_free;\n        }\n        if (rc16_task->status == SCSI_STATUS_GOOD) {\n                rc16 = scsi_datain_unmarshall(rc16_task);\n                if (rc16 == NULL) {\n                        printf(\"failed to unmarshall READCAPACITY16 data. %s\\n\", sd->error_str);\n                        scsi_free_scsi_task(rc16_task);\n                        goto err_sds_free;\n                }\n                block_size = rc16->block_length;\n                num_blocks = rc16->returned_lba + 1;\n                lbppb = 1 << rc16->lbppbe;\n        }\n\n        /* create a really big buffer we can use in the tests */\n        scratch = malloc(65536 * block_size);\n        \n        inq_task = NULL;\n        inquiry(sd, &inq_task, 0, 0, 64, EXPECT_STATUS_GOOD);\n        if (inq_task == NULL || inq_task->status != SCSI_STATUS_GOOD) {\n                printf(\"Inquiry command failed : %s\\n\", sd->error_str);\n                goto err_sds_free;\n        }\n        full_size = scsi_datain_getfullsize(inq_task);\n        if (full_size > inq_task->datain.size) {\n                scsi_free_scsi_task(inq_task);\n\n                /* we need more data for the full list */\n                inq_task = NULL;\n                inquiry(sd, &inq_task, 0, 0, full_size, EXPECT_STATUS_GOOD);\n                if (inq_task == NULL) {\n                        printf(\"Inquiry command failed : %s\\n\", sd->error_str);\n                        goto err_sds_free;\n                }\n        }\n        inq = scsi_datain_unmarshall(inq_task);\n        if (inq == NULL) {\n                printf(\"failed to unmarshall inquiry datain blob\\n\");\n                scsi_free_scsi_task(inq_task);\n                goto err_sds_free;\n        }\n\n        sbc3_support = 0;\n        for (i = 0; i < 8; i++) {\n                if (inq->version_descriptor[i] == 0x04C0) {\n                        sbc3_support = 1;\n                }\n        }\n\n        /* try reading block limits vpd */\n        inq_bl_task = NULL;\n        inquiry(sd, &inq_bl_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS, 64, EXPECT_STATUS_GOOD);\n        if (inq_bl_task && inq_bl_task->status != SCSI_STATUS_GOOD) {\n                scsi_free_scsi_task(inq_bl_task);\n                inq_bl_task = NULL;\n        }\n        if (inq_bl_task) {\n                full_size = scsi_datain_getfullsize(inq_bl_task);\n                if (full_size > inq_bl_task->datain.size) {\n                        scsi_free_scsi_task(inq_bl_task);\n\n                        inq_bl_task = NULL;\n                        inquiry(sd, &inq_bl_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS, full_size,\n                                EXPECT_STATUS_GOOD);\n                        if (inq_bl_task == NULL) {\n                                printf(\"Inquiry command failed : %s\\n\", sd->error_str);\n                                goto err_sds_free;\n                        }\n                }\n\n                inq_bl = scsi_datain_unmarshall(inq_bl_task);\n                if (inq_bl == NULL) {\n                        printf(\"failed to unmarshall inquiry datain blob\\n\");\n                        goto err_sds_free;\n                }\n        }\n\n        /* try reading block device characteristics vpd */\n        inquiry(sd, &inq_bdc_task, 1, SCSI_INQUIRY_PAGECODE_BLOCK_DEVICE_CHARACTERISTICS, 255,\n                EXPECT_STATUS_GOOD);\n        if (inq_bdc_task == NULL || inq_bdc_task->status != SCSI_STATUS_GOOD) {\n                printf(\"Failed to read Block Device Characteristics page\\n\");\n        } else {\n                inq_bdc = scsi_datain_unmarshall(inq_bdc_task);\n                if (inq_bdc == NULL) {\n                        printf(\"failed to unmarshall inquiry datain blob\\n\");\n                        goto err_sds_free;\n                }\n        }\n\n        /* if thin provisioned we also need to read the VPD page for it */\n        if (rc16 && rc16->lbpme != 0){\n                inq_lbp_task = NULL;\n                inquiry(sd, &inq_lbp_task, 1, SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING, 64,\n                        EXPECT_STATUS_GOOD);\n                if (inq_lbp_task == NULL || inq_lbp_task->status != SCSI_STATUS_GOOD) {\n                        printf(\"Inquiry command failed : %s\\n\", sd->error_str);\n                        goto err_sds_free;\n                }\n                full_size = scsi_datain_getfullsize(inq_lbp_task);\n                if (full_size > inq_lbp_task->datain.size) {\n                        scsi_free_scsi_task(inq_lbp_task);\n\n                        /* we need more data for the full list */\n                        inq_lbp_task = NULL;\n                        inquiry(sd, &inq_lbp_task, 1, SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,\n                                full_size, EXPECT_STATUS_GOOD);\n                        if (inq_lbp_task == NULL) {\n                                printf(\"Inquiry command failed : %s\\n\", sd->error_str);\n                                goto err_sds_free;\n                        }\n                }\n\n                inq_lbp = scsi_datain_unmarshall(inq_lbp_task);\n                if (inq_lbp == NULL) {\n                        printf(\"failed to unmarshall inquiry datain blob\\n\");\n                        goto err_sds_free;\n                }\n        }\n\n        rsop_task = NULL;\n        report_supported_opcodes(sd, &rsop_task, 1, SCSI_REPORT_SUPPORTING_OPS_ALL, 0, 0, 65535,\n                                 EXPECT_STATUS_GOOD);\n        if (rsop_task == NULL) {\n                printf(\"Failed to send REPORT_SUPPORTED_OPCODES command: %s\\n\", sd->error_str);\n                goto err_sds_free;\n        }\n        if (rsop_task->status == SCSI_STATUS_GOOD) {\n                rsop = scsi_datain_unmarshall(rsop_task);\n                if (rsop == NULL) {\n                        printf(\"failed to unmarshall REPORT_SUPPORTED_OPCODES data.\\n\");\n                        scsi_free_scsi_task(rsop_task);\n                        rsop_task = NULL;\n                }\n        }\n\n        /* check if the device is write protected or not */\n        task = NULL;\n        modesense6(sd, &task, 0, SCSI_MODESENSE_PC_CURRENT, SCSI_MODEPAGE_RETURN_ALL_PAGES, 0, 255,\n                   EXPECT_STATUS_GOOD);\n        if (task == NULL) {\n                printf(\"Failed to send MODE_SENSE6 command: %s\\n\", sd->error_str);\n                goto err_sds_free;\n        }\n        if (task->status == SCSI_STATUS_GOOD) {\n                struct scsi_mode_sense *ms;\n\n                ms = scsi_datain_unmarshall(task);\n                if (ms == NULL) {\n                        printf(\"failed to unmarshall mode sense datain blob\\n\");\n                        scsi_free_scsi_task(task);\n                        goto err_sds_free;\n                }\n                readonly = !!(ms->device_specific_parameter & 0x80);\n        }\n        scsi_free_scsi_task(task);\n\n        if (clear_pr(sd) < 0) {\n                printf(\"One or more persistent reservations keys have been registered\\n\");\n                return -1;\n        }\n\n        /* BLKSECTGET for /dev/sg* is a shitshow under linux.\n         * Even 4.2 kernels return number of bytes instead of number\n         * of sectors here. Just force it to 120k and let us get on with\n         * our lives.\n         */\n        if (sd->sgio_dev && !strncmp(sd->sgio_dev, \"/dev/sg\", 7)) {\n                printf(\"Looks like a /dev/sg device. Force max iosize \"\n                       \"to 120k as BLKSECTGET is just broken and can \"\n                       \"not be used for discovery.\\n\");\n                maxsectors = 120 * 1024 / block_size;\n        }\n        if (maxsectors) {\n                maximum_transfer_length = maxsectors;\n                printf(\"Bus transfer size is limited to %d blocks. Clamping \"\n                       \"max transfers accordingly.\\n\", maxsectors);\n        }\n\n        if (CU_initialize_registry() != 0) {\n                fprintf(stderr, \"error: unable to initialize test registry\\n\");\n                goto err_sds_free;\n        }\n        if (CU_is_test_running()) {\n                fprintf(stderr, \"error: test suite(s) already running!?\\n\");\n                exit(1);\n        }\n\n        parse_and_add_tests(testname_re);\n        if (testname_re)\n                free(testname_re);\n\n        CU_basic_set_mode(mode);\n        CU_set_error_action(error_action);\n        printf(\"\\n\");\n\n        /*\n         * this actually runs the tests ...\n         */\n\n        if (xml_mode) {\n          CU_list_tests_to_file();\n          CU_automated_run_tests();\n        } else {\n          res = CU_basic_run_tests();\n          printf(\"Tests completed with return value: %d\\n\", res);\n        }\n\n        failures = CU_get_number_of_failures();\n        CU_cleanup_registry();\n\n        if (inq_task != NULL) {\n                scsi_free_scsi_task(inq_task);\n        }\n        if (inq_bl_task != NULL) {\n                scsi_free_scsi_task(inq_bl_task);\n        }\n        if (inq_lbp_task != NULL) {\n                scsi_free_scsi_task(inq_lbp_task);\n        }\n        if (inq_bdc_task != NULL) {\n                scsi_free_scsi_task(inq_bdc_task);\n        }\n        if (rc16_task != NULL) {\n                scsi_free_scsi_task(rc16_task);\n        }\n        if (rsop_task != NULL) {\n                scsi_free_scsi_task(rsop_task);\n        }\n        for (i = 0; i < mp_num_sds; i++) {\n                free_scsi_device(mp_sds[i]);\n        }\n        free(scratch);\n        if (failures > 0) {\n            ret = 1;\n        } else {\n            ret = 0;\n        }\n        return ret;\n\nerr_sds_free:\n        for (i = 0; i < mp_num_sds; i++) {\n                free_scsi_device(mp_sds[i]);\n        }\n        free(scratch);\n        return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libiscsi-1.18.0-owrt5aol3rvh4wopzgsfagjft6l7i3ns/spack-src/examples/ld_iscsi.c": "/*\n   Copyright (C) 2011, 2012 by Ronnie Sahlberg <ronniesahlberg@gmail.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation; either version 2.1 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with this program; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define _GNU_SOURCE\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <asm/fcntl.h>\n\n#include \"iscsi.h\"\n#include \"iscsi-private.h\"\n#include \"scsi-lowlevel.h\"\n\n#include <sys/syscall.h>\n#include <dlfcn.h>\n#include <inttypes.h>\n\nstatic const char *initiator = \"iqn.2007-10.com.github:sahlberg:libiscsi:ld-iscsi\";\n\n#define ISCSI_MAX_FD  255\n\nstatic int debug = 0;\n\n#define LD_ISCSI_DPRINTF(level,fmt,args...) do { if ((debug) >= level) {fprintf(stderr,\"ld_iscsi: \");fprintf(stderr, (fmt), ##args); fprintf(stderr,\"\\n\");} } while (0);\n\nstruct iscsi_fd_list {\n       int is_iscsi;\n       int dup2fd;\n       int in_flight;\n       struct iscsi_context *iscsi;\n       int lun;\n       uint32_t block_size;\n       uint64_t num_blocks;\n       off_t offset;\n       mode_t mode;\n       int get_lba_status;\n       struct scsi_lba_status_descriptor lbasd_cached;\n       int lbasd_cache_valid;\n};\n\nstatic struct iscsi_fd_list iscsi_fd_list[ISCSI_MAX_FD];\n\nint (*real_open)(__const char *path, int flags, mode_t mode);\n\nint open(const char *path, int flags, mode_t mode)\n{\n\tint fd;\n\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tstruct iscsi_context *iscsi;\n\t\tstruct iscsi_url *iscsi_url;\n\t\tstruct scsi_task *task;\n\t\tstruct scsi_readcapacity16 *rc16;\n\n\t\tif (mode & O_NONBLOCK) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Non-blocking I/O is currently not supported\");\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi = iscsi_create_context(initiator);\n\t\tif (iscsi == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Failed to create context\");\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_url = iscsi_parse_full_url(iscsi, path);\n\t\tif (iscsi_url == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Failed to parse URL: %s\\n\", iscsi_get_error(iscsi));\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL);\n\t\tiscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\t\tif (iscsi_full_connect_sync(iscsi, iscsi_url->portal, iscsi_url->lun) != 0) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Login Failed. %s\\n\", iscsi_get_error(iscsi));\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\ttask = iscsi_readcapacity16_sync(iscsi, iscsi_url->lun);\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send readcapacity command\");\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\trc16 = scsi_datain_unmarshall(task);\n\t\tif (rc16 == NULL) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to unmarshall readcapacity10 data\");\n\t\t\tscsi_free_scsi_task(task);\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n        LD_ISCSI_DPRINTF(4,\"readcapacity16_sync: block_size: %d, num_blocks: %\"PRIu64,rc16->block_length,rc16->returned_lba + 1);\n\n\t\tfd = iscsi_get_fd(iscsi);\n\t\tif (fd >= ISCSI_MAX_FD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"Too many files open\");\n\t\t\tiscsi_destroy_url(iscsi_url);\n\t\t\tiscsi_destroy_context(iscsi);\n\t\t\terrno = ENFILE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_fd_list[fd].is_iscsi   = 1;\n\t\tiscsi_fd_list[fd].dup2fd     = -1;\n\t\tiscsi_fd_list[fd].iscsi      = iscsi;\n\t\tiscsi_fd_list[fd].block_size = rc16->block_length;\n\t\tiscsi_fd_list[fd].num_blocks = rc16->returned_lba + 1;\n\t\tiscsi_fd_list[fd].offset     = 0;\n\t\tiscsi_fd_list[fd].lun        = iscsi_url->lun;\n\t\tiscsi_fd_list[fd].mode       = mode;\n\n\t\tif (getenv(\"LD_ISCSI_GET_LBA_STATUS\") != NULL) {\n\t\t\tiscsi_fd_list[fd].get_lba_status = atoi(getenv(\"LD_ISCSI_GET_LBA_STATUS\"));\n\t\t\tif (rc16->lbpme == 0){\n\t\t\t\tLD_ISCSI_DPRINTF(1,\"Logical unit is fully provisioned. Will skip get_lba_status tasks\");\n\t\t\t\tiscsi_fd_list[fd].get_lba_status = 0;\n\t\t\t}\n\t\t}\n\n\t\tscsi_free_scsi_task(task);\n\t\tiscsi_destroy_url(iscsi_url);\n\n\t\treturn fd;\n\t}\n\n\treturn real_open(path, flags, mode);\n}\n\nint open64(const char *path, int flags, mode_t mode)\n{\n\treturn open(path, flags | O_LARGEFILE, mode);\n}\n\nint (*real_close)(int fd);\n\nint close(int fd)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tint i;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\tiscsi_fd_list[fd].is_iscsi = 0;\n\t\t\tiscsi_fd_list[fd].dup2fd   = -1;\n\t\t\treal_close(fd);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* are there any FDs dup2ed onto this ? */\n\t\tfor(i = 0; i < ISCSI_MAX_FD; i++) {\n\t\t\tif (iscsi_fd_list[i].dup2fd == fd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < ISCSI_MAX_FD) {\n\t\t\tint j;\n\n\t\t\t/* yes there are DUPs onto fd, make i the new real device and repoint all other\n\t\t\t * duplicates\n\t\t\t */\n\t\t\tmemcpy(&iscsi_fd_list[i], &iscsi_fd_list[fd], sizeof(struct iscsi_fd_list));\n\t\t\tiscsi_fd_list[i].dup2fd = -1;\n\n\t\t\tmemset(&iscsi_fd_list[fd], 0, sizeof(struct iscsi_fd_list));\n\t\t\tiscsi_fd_list[fd].dup2fd = -1;\n\n\t\t\tiscsi_fd_list[i].iscsi->fd = i;\n\t\t\treal_close(fd);\n\n\t\t\tfor(j = 0; j < ISCSI_MAX_FD; j++) {\n\t\t\t\tif (j != i && iscsi_fd_list[j].dup2fd == fd) {\n\t\t\t\t\tiscsi_fd_list[j].dup2fd = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tiscsi_fd_list[fd].is_iscsi = 0;\n\t\tiscsi_fd_list[fd].dup2fd   = -1;\n\t\tiscsi_destroy_context(iscsi_fd_list[fd].iscsi);\n\t\tiscsi_fd_list[fd].iscsi    = NULL;\n\n\t\treturn 0;\n\t}\n\n        return real_close(fd);\n}\n\nint (*real_fxstat)(int ver, int fd, struct stat *buf);\n\nint __fxstat(int ver, int fd, struct stat *buf)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn __fxstat(ver, iscsi_fd_list[fd].dup2fd, buf);\n\t\t}\n\n\t\tmemset(buf, 0, sizeof(struct stat));\n\t\tbuf->st_mode = S_IRUSR | S_IRGRP | S_IROTH | S_IFREG;\n\t\tbuf->st_size = iscsi_fd_list[fd].num_blocks * iscsi_fd_list[fd].block_size;\n\n\t\treturn 0;\n\t}\n\n\treturn real_fxstat(ver, fd, buf);\n}\n\n\nint (*real_lxstat)(int ver, __const char *path, struct stat *buf);\n\nint __lxstat(int ver, const char *path, struct stat *buf)\n{\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tint fd, ret;\n\n\t\tfd = open(path, 0, 0);\n\t\tif (fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\n\t\tret = __fxstat(ver, fd, buf);\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\n\treturn real_lxstat(ver, path, buf);\n}\n\nint (*real_xstat)(int ver, __const char *path, struct stat *buf);\n\nint __xstat(int ver, const char *path, struct stat *buf)\n{\n\treturn __lxstat(ver, path, buf);\n}\n\noff_t (*real_lseek)(int fd, off_t offset, int whence);\n\noff_t lseek(int fd, off_t offset, int whence) {\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\toff_t new_offset;\n\t\toff_t size = iscsi_fd_list[fd].num_blocks*iscsi_fd_list[fd].block_size;\n\t\tswitch (whence) {\n\t\t\tcase SEEK_SET:\n\t\t\t\tnew_offset = offset;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_CUR:\n\t\t\t\tnew_offset = iscsi_fd_list[fd].offset+offset;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_END:\n\t\t\t\tnew_offset = size + offset;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (new_offset < 0 || new_offset > size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tiscsi_fd_list[fd].offset=new_offset;\n\t\treturn iscsi_fd_list[fd].offset;\n\t}\n\n\treturn real_lseek(fd, offset, whence);\n}\n\nssize_t (*real_read)(int fd, void *buf, size_t count);\n\nssize_t read(int fd, void *buf, size_t count)\n{\n\tif ((iscsi_fd_list[fd].is_iscsi == 1) && (iscsi_fd_list[fd].in_flight == 0)) {\n\t\tuint64_t offset;\n\t\tuint64_t num_blocks, lba;\n\t\tstruct scsi_task *task;\n\t\tstruct scsi_get_lba_status *lbas;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn read(iscsi_fd_list[fd].dup2fd, buf, count);\n\t\t}\n\t\toffset = iscsi_fd_list[fd].offset / iscsi_fd_list[fd].block_size * iscsi_fd_list[fd].block_size;\n\t\tnum_blocks = (iscsi_fd_list[fd].offset - offset + count + iscsi_fd_list[fd].block_size - 1) / iscsi_fd_list[fd].block_size;\n\t\tlba = offset / iscsi_fd_list[fd].block_size;\n\n\t\t/* Don't try to read beyond the last LBA */\n\t\tif (lba >= iscsi_fd_list[fd].num_blocks) {\n\t\t\treturn 0;\n\t\t}\n\t\t/* Trim num_blocks requested to last lba */\n\t\tif ((lba + num_blocks) > iscsi_fd_list[fd].num_blocks) {\n\t\t\tnum_blocks = iscsi_fd_list[fd].num_blocks - lba;\n\t\t\tcount = num_blocks * iscsi_fd_list[fd].block_size;\n\t\t}\n\n\t\tiscsi_fd_list[fd].in_flight = 1;\n        if (iscsi_fd_list[fd].get_lba_status != 0) {\n\t\t\tuint32_t i;\n\t\t\tuint32_t _num_allocated=0;\n\t\t\tuint32_t _num_blocks=0;\n\n\t\t\tif (iscsi_fd_list[fd].lbasd_cache_valid==1) {\n\t\t\t\tLD_ISCSI_DPRINTF(5,\"cached get_lba_status_descriptor is lba %\"PRIu64\", num_blocks %d, provisioning %d\",iscsi_fd_list[fd].lbasd_cached.lba,iscsi_fd_list[fd].lbasd_cached.num_blocks,iscsi_fd_list[fd].lbasd_cached.provisioning);\n\t\t\t    if (iscsi_fd_list[fd].lbasd_cached.provisioning != 0x00 && lba >= iscsi_fd_list[fd].lbasd_cached.lba && lba+num_blocks < iscsi_fd_list[fd].lbasd_cached.lba+iscsi_fd_list[fd].lbasd_cached.num_blocks)\n\t\t\t    {\n\t\t\t\t\tLD_ISCSI_DPRINTF(4,\"skipped read16_sync for non-allocated blocks: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\t\t\t\tmemset(buf, 0x00, count);\n\t\t\t\t\tiscsi_fd_list[fd].offset += count;\n\t\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLD_ISCSI_DPRINTF(4,\"get_lba_status_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64,iscsi_fd_list[fd].lun,lba,num_blocks);\n\t\t\ttask = iscsi_get_lba_status_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, 8+16);\n\t\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send get_lba_status command\");\n\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\terrno = EIO;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlbas = scsi_datain_unmarshall(task);\n\t\t\tif (lbas == NULL) {\n\t\t\t\tLD_ISCSI_DPRINTF(0,\"failed to unmarshall get_lba_status data\");\n\t\t\t\tscsi_free_scsi_task(task);\n\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\terrno = EIO;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tLD_ISCSI_DPRINTF(5,\"get_lba_status: num_descriptors: %d\",lbas->num_descriptors);\n\t\t\tfor (i=0;i<lbas->num_descriptors;i++) {\n\t\t\t\tstruct scsi_lba_status_descriptor *lbasd = &lbas->descriptors[i];\n\t\t\t\tLD_ISCSI_DPRINTF(5,\"get_lba_status_descriptor %d, lba %\"PRIu64\", num_blocks %d, provisioning %d\",i,lbasd->lba,lbasd->num_blocks,lbasd->provisioning);\n\t\t\t\tif (lbasd->lba != _num_blocks+lba) {\n\t\t\t\t\tLD_ISCSI_DPRINTF(0,\"get_lba_status response is non-continuous\");\n\t\t\t\t\tscsi_free_scsi_task(task);\n\t\t\t\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\t\t\t\terrno = EIO;\n\t\t\t\t\treturn -1;\n\t\t\t    }\n\t\t\t\t_num_allocated+=(lbasd->provisioning==0x00)?lbasd->num_blocks:0;\n\t\t\t\t_num_blocks+=lbasd->num_blocks;\n\t\t\t\tiscsi_fd_list[fd].lbasd_cached=lbas->descriptors[i];\n\t\t\t\tiscsi_fd_list[fd].lbasd_cache_valid=1;\n\t\t\t}\n\t\t\tscsi_free_scsi_task(task);\n            if (_num_allocated == 0 && _num_blocks >= num_blocks) {\n\t\t        LD_ISCSI_DPRINTF(4,\"skipped read16_sync for non-allocated blocks: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\t\t\tmemset(buf, 0x00, count);\n\t\t        iscsi_fd_list[fd].offset += count;\n\t\t        iscsi_fd_list[fd].in_flight = 0;\n\t\t        return count;\n\t\t\t}\n\t\t}\n\n\t\tLD_ISCSI_DPRINTF(4,\"read16_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\n\t\ttask = iscsi_read16_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, num_blocks * iscsi_fd_list[fd].block_size, iscsi_fd_list[fd].block_size, 0, 0, 0, 0, 0);\n\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send read16 command\");\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(buf, &task->datain.data[iscsi_fd_list[fd].offset - offset], count);\n\t\tiscsi_fd_list[fd].offset += count;\n\n\t\tscsi_free_scsi_task(task);\n\n\t\treturn count;\n\t}\n\n\treturn real_read(fd, buf, count);\n}\n\nssize_t (*real_pread)(int fd, void *buf, size_t count, off_t offset);\nssize_t pread(int fd, void *buf, size_t count, off_t offset) {\n\tif ((iscsi_fd_list[fd].is_iscsi == 1 && iscsi_fd_list[fd].in_flight == 0)) {\n\t\toff_t old_offset;\n\t\tif ((old_offset = lseek(fd, 0, SEEK_CUR)) < 0) {\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\t\tif (lseek(fd, offset, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(fd, buf, count) < 0) {\n\t\t\tlseek(fd, old_offset, SEEK_SET);\n\t\t\treturn -1;\n\t\t}\n\t\tlseek(fd, old_offset, SEEK_SET);\n\t\treturn count;\n\t}\n\treturn real_pread(fd, buf, count, offset);\n}\n\nssize_t (*real_write)(int fd, const void *buf, size_t count);\n\nssize_t write(int fd, const void *buf, size_t count)\n{\n\tif ((iscsi_fd_list[fd].is_iscsi == 1) && (iscsi_fd_list[fd].in_flight == 0)) {\n\t\tuint64_t offset;\n\t\tuint64_t num_blocks, lba;\n\t\tstruct scsi_task *task;\n\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn write(iscsi_fd_list[fd].dup2fd, buf, count);\n\t\t}\n\t\tif (iscsi_fd_list[fd].offset%iscsi_fd_list[fd].block_size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tif (count%iscsi_fd_list[fd].block_size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n                iscsi_fd_list[fd].lbasd_cache_valid = 0;\n\n\t\toffset = iscsi_fd_list[fd].offset;\n\t\tnum_blocks = count/iscsi_fd_list[fd].block_size;\n\t\tlba = offset / iscsi_fd_list[fd].block_size;\n\n\t\t/* Don't try to read beyond the last LBA */\n\t\tif (lba >= iscsi_fd_list[fd].num_blocks) {\n\t\t\treturn 0;\n\t\t}\n\t\t/* Trim num_blocks requested to last lba */\n\t\tif ((lba + num_blocks) > iscsi_fd_list[fd].num_blocks) {\n\t\t\tnum_blocks = iscsi_fd_list[fd].num_blocks - lba;\n\t\t\tcount = num_blocks * iscsi_fd_list[fd].block_size;\n\t\t}\n\n\t\tiscsi_fd_list[fd].in_flight = 1;\n\t\tLD_ISCSI_DPRINTF(4,\"write16_sync: lun %d, lba %\"PRIu64\", num_blocks: %\"PRIu64\", block_size: %d, offset: %\"PRIu64\" count: %lu\",iscsi_fd_list[fd].lun,lba,num_blocks,iscsi_fd_list[fd].block_size,offset,(unsigned long)count);\n\t\ttask = iscsi_write16_sync(iscsi_fd_list[fd].iscsi, iscsi_fd_list[fd].lun, lba, (unsigned char *) buf, count, iscsi_fd_list[fd].block_size, 0, 0, 0, 0, 0);\n\t\tiscsi_fd_list[fd].in_flight = 0;\n\t\tif (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\t\t\tLD_ISCSI_DPRINTF(0,\"failed to send write16 command\");\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\n\t\tiscsi_fd_list[fd].offset += count;\n\t\tscsi_free_scsi_task(task);\n\n\t\treturn count;\n\t}\n\n\treturn real_write(fd, buf, count);\n}\n\nssize_t (*real_pwrite)(int fd, const void *buf, size_t count, off_t offset);\nssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) {\n\tif ((iscsi_fd_list[fd].is_iscsi == 1 && iscsi_fd_list[fd].in_flight == 0)) {\n\t\toff_t old_offset;\n\t\tif ((old_offset = lseek(fd, 0, SEEK_CUR)) < 0) {\n\t\t\terrno = EIO;\n\t\t\treturn -1;\n\t\t}\n\t\tif (lseek(fd, offset, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (write(fd, buf, count) < 0) {\n\t\t\tlseek(fd, old_offset, SEEK_SET);\n\t\t\treturn -1;\n\t\t}\n\t\tlseek(fd, old_offset, SEEK_SET);\n\t\treturn count;\n\t}\n\treturn real_pwrite(fd, buf, count, offset);\n}\n\nint (*real_dup2)(int oldfd, int newfd);\n\nint dup2(int oldfd, int newfd)\n{\n\tif (iscsi_fd_list[newfd].is_iscsi) {\n\t\treturn real_dup2(oldfd, newfd);\n\t}\n\n\tclose(newfd);\n\n\tif (iscsi_fd_list[oldfd].is_iscsi == 1) {\n\t\tint ret;\n\t\tif (iscsi_fd_list[oldfd].dup2fd >= 0) {\n\t\t\treturn dup2(iscsi_fd_list[oldfd].dup2fd, newfd);\n\t\t}\n\n\t\tret = real_dup2(oldfd, newfd);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tiscsi_fd_list[newfd].is_iscsi = 1;\n\t\tiscsi_fd_list[newfd].dup2fd   = oldfd;\n\n\t\treturn newfd;\n\t}\n\n\treturn real_dup2(oldfd, newfd);\n}\n\n#if defined(_LARGEFILE64_SOURCE) && _FILE_OFFSET_BITS != 64\n\nint (*real_fxstat64)(int ver, int fd, struct stat64 *buf);\n\nint __fxstat64(int ver, int fd, struct stat64 *buf)\n{\n\tif (iscsi_fd_list[fd].is_iscsi == 1) {\n\t\tif (iscsi_fd_list[fd].dup2fd >= 0) {\n\t\t\treturn __fxstat64(ver, iscsi_fd_list[fd].dup2fd, buf);\n\t\t}\n\n\t\tmemset(buf, 0, sizeof(struct stat64));\n\t\tbuf->st_mode = S_IRUSR | S_IRGRP | S_IROTH | S_IFREG;\n\t\tbuf->st_size = iscsi_fd_list[fd].num_blocks * iscsi_fd_list[fd].block_size;\n\t\treturn 0;\n\t}\n\n\treturn real_fxstat64(ver, fd, buf);\n}\n\n\nint (*real_lxstat64)(int ver, __const char *path, struct stat64 *buf);\n\nint __lxstat64(int ver, const char *path, struct stat64 *buf)\n{\n\tif (!strncmp(path, \"iscsi:\", 6)) {\n\t\tint fd, ret;\n\n\t\tfd = open64(path, 0, 0);\n\t\tif (fd == -1) {\n\t\t\treturn fd;\n\t\t}\n\n\t\tret = __fxstat64(ver, fd, buf);\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\n\treturn real_lxstat64(ver, path, buf);\n}\n\n\nint (*real_xstat64)(int ver, __const char *path, struct stat64 *buf);\n\nint __xstat64(int ver, const char *path, struct stat64 *buf)\n{\n\treturn __lxstat64(ver, path, buf);\n}\n\n#endif\n\nstatic void __attribute__((constructor)) _init(void)\n{\n\tint i;\n\n\tfor(i = 0; i < ISCSI_MAX_FD; i++) {\n\t\tiscsi_fd_list[i].dup2fd = -1;\n\t}\n\n\tif (getenv(\"LD_ISCSI_DEBUG\") != NULL) {\n\t\tdebug = atoi(getenv(\"LD_ISCSI_DEBUG\"));\n\t}\n\n\treal_open = dlsym(RTLD_NEXT, \"open\");\n\tif (real_open == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(open)\");\n\t\texit(10);\n\t}\n\n\treal_close = dlsym(RTLD_NEXT, \"close\");\n\tif (real_close == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(close)\");\n\t\texit(10);\n\t}\n\n\treal_fxstat = dlsym(RTLD_NEXT, \"__fxstat\");\n\tif (real_fxstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__fxstat)\");\n\t\texit(10);\n\t}\n\n\treal_lxstat = dlsym(RTLD_NEXT, \"__lxstat\");\n\tif (real_lxstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__lxstat)\");\n\t\texit(10);\n\t}\n\treal_xstat = dlsym(RTLD_NEXT, \"__xstat\");\n\tif (real_xstat == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__xstat)\");\n\t\texit(10);\n\t}\n\n\treal_lseek = dlsym(RTLD_NEXT, \"lseek\");\n\tif (real_lseek == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(lseek)\");\n\t\texit(10);\n\t}\n\n\treal_read = dlsym(RTLD_NEXT, \"read\");\n\tif (real_read == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(read)\");\n\t\texit(10);\n\t}\n\n\treal_pread = dlsym(RTLD_NEXT, \"pread\");\n\tif (real_pread == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(pread)\");\n\t\texit(10);\n\t}\n\n\treal_write = dlsym(RTLD_NEXT, \"write\");\n\tif (real_write == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(write)\");\n\t\texit(10);\n\t}\n\n\treal_pwrite = dlsym(RTLD_NEXT, \"pwrite\");\n\tif (real_pwrite == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(pwrite)\");\n\t\texit(10);\n\t}\n\n\treal_dup2 = dlsym(RTLD_NEXT, \"dup2\");\n\tif (real_dup2 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(dup2)\");\n\t\texit(10);\n\t}\n\n#if defined(_LARGEFILE64_SOURCE) && _FILE_OFFSET_BITS != 64\n\treal_fxstat64 = dlsym(RTLD_NEXT, \"__fxstat64\");\n\tif (real_fxstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__fxstat64)\");\n\t}\n\n\treal_lxstat64 = dlsym(RTLD_NEXT, \"__lxstat64\");\n\tif (real_lxstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(_lxstat64)\");\n\t}\n\n\treal_xstat64 = dlsym(RTLD_NEXT, \"__xstat64\");\n\tif (real_xstat64 == NULL) {\n\t\tLD_ISCSI_DPRINTF(0,\"Failed to dlsym(__xstat64)\");\n\t}\n#endif\n}\n"
    },
    "skipped": [],
    "total_files": 307
}