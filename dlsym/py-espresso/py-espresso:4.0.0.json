{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/src/core/communication.cpp": "/*\n  Copyright (C) 2010-2018 The ESPResSo project\n  Copyright (C) 2002,2003,2004,2005,2006,2007,2008,2009,2010\n    Max-Planck-Institute for Polymer Research, Theory Group\n\n  This file is part of ESPResSo.\n\n  ESPResSo is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  ESPResSo is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <mpi.h>\n#ifdef OPEN_MPI\n#include <dlfcn.h>\n#endif\n#include <cassert>\n\n#include \"communication.hpp\"\n\n#include \"errorhandling.hpp\"\n\n#include \"EspressoSystemInterface.hpp\"\n#include \"buckingham.hpp\"\n#include \"cells.hpp\"\n#include \"collision.hpp\"\n#include \"cuda_interface.hpp\"\n#include \"debye_hueckel.hpp\"\n#include \"elc.hpp\"\n#include \"energy.hpp\"\n#include \"forces.hpp\"\n#include \"galilei.hpp\"\n#include \"gb.hpp\"\n#include \"global.hpp\"\n#include \"grid.hpp\"\n#include \"iccp3m.hpp\"\n#include \"initialize.hpp\"\n#include \"integrate.hpp\"\n#include \"interaction_data.hpp\"\n#include \"io/mpiio/mpiio.hpp\"\n#include \"lb.hpp\"\n#include \"lj.hpp\"\n#include \"ljcos.hpp\"\n#include \"ljcos2.hpp\"\n#include \"ljgen.hpp\"\n#include \"maggs.hpp\"\n#include \"mdlc_correction.hpp\"\n#include \"minimize_energy.hpp\"\n#include \"mmm1d.hpp\"\n#include \"mmm2d.hpp\"\n#include \"molforces.hpp\"\n#include \"morse.hpp\"\n#include \"npt.hpp\"\n#include \"p3m-dipolar.hpp\"\n#include \"p3m.hpp\"\n#include \"partCfg_global.hpp\"\n#include \"particle_data.hpp\"\n#include \"pressure.hpp\"\n#include \"reaction_field.hpp\"\n#include \"rotation.hpp\"\n#include \"scafacos.hpp\"\n#include \"statistics.hpp\"\n#include \"statistics_chain.hpp\"\n#include \"statistics_fluid.hpp\"\n#include \"swimmer_reaction.hpp\"\n#include \"tab.hpp\"\n#include \"topology.hpp\"\n#include \"virtual_sites.hpp\"\n\n#include \"utils.hpp\"\n#include \"utils/make_unique.hpp\"\n#include \"utils/serialization/IA_parameters.hpp\"\n#include \"utils/serialization/Particle.hpp\"\n\n#include <boost/mpi.hpp>\n#include <boost/serialization/array.hpp>\n#include <boost/serialization/string.hpp>\n\nusing namespace std;\n\nnamespace Communication {\nauto const &mpi_datatype_cache = boost::mpi::detail::mpi_datatype_cache();\nstd::unique_ptr<boost::mpi::environment> mpi_env;\n} // namespace Communication\n\nboost::mpi::communicator comm_cart;\n\nnamespace Communication {\nstd::unique_ptr<MpiCallbacks> m_callbacks;\n\n/* We use a singleton callback class for now. */\nMpiCallbacks &mpiCallbacks() {\n  assert(m_callbacks && \"Mpi not initialized!\");\n\n  return *m_callbacks;\n}\n} // namespace Communication\n\nusing Communication::mpiCallbacks;\n\nint this_node = -1;\nint n_nodes = -1;\n\nint graceful_exit = 0;\n/* whether there is already a termination going on. */\nstatic int terminated = 0;\n\n// if you want to add a callback, add it here, and here only\n#define CALLBACK_LIST                                                          \\\n  CB(mpi_bcast_parameter_slave)                                                \\\n  CB(mpi_who_has_slave)                                                        \\\n  CB(mpi_bcast_event_slave)                                                    \\\n  CB(mpi_place_particle_slave)                                                 \\\n  CB(mpi_send_v_slave)                                                         \\\n  CB(mpi_send_swimming_slave)                                                  \\\n  CB(mpi_send_f_slave)                                                         \\\n  CB(mpi_send_q_slave)                                                         \\\n  CB(mpi_send_type_slave)                                                      \\\n  CB(mpi_send_bond_slave)                                                      \\\n  CB(mpi_recv_part_slave)                                                      \\\n  CB(mpi_integrate_slave)                                                      \\\n  CB(mpi_bcast_ia_params_slave)                                                \\\n  CB(mpi_bcast_all_ia_params_slave)                                            \\\n  CB(mpi_bcast_max_seen_particle_type_slave)                                   \\\n  CB(mpi_gather_stats_slave)                                                   \\\n  CB(mpi_set_time_step_slave)                                                  \\\n  CB(mpi_bcast_coulomb_params_slave)                                           \\\n  CB(mpi_bcast_collision_params_slave)                                         \\\n  CB(mpi_send_ext_force_slave)                                                 \\\n  CB(mpi_send_ext_torque_slave)                                                \\\n  CB(mpi_place_new_particle_slave)                                             \\\n  CB(mpi_remove_particle_slave)                                                \\\n  CB(mpi_rescale_particles_slave)                                              \\\n  CB(mpi_bcast_cell_structure_slave)                                           \\\n  CB(mpi_send_quat_slave)                                                      \\\n  CB(mpi_send_omega_slave)                                                     \\\n  CB(mpi_send_torque_slave)                                                    \\\n  CB(mpi_send_mol_id_slave)                                                    \\\n  CB(mpi_bcast_nptiso_geom_slave)                                              \\\n  CB(mpi_update_mol_ids_slave)                                                 \\\n  CB(mpi_sync_topo_part_info_slave)                                            \\\n  CB(mpi_send_mass_slave)                                                      \\\n  CB(mpi_send_solvation_slave)                                                 \\\n  CB(mpi_send_exclusion_slave)                                                 \\\n  CB(mpi_bcast_lb_params_slave)                                                \\\n  CB(mpi_bcast_cuda_global_part_vars_slave)                                    \\\n  CB(mpi_send_dip_slave)                                                       \\\n  CB(mpi_send_dipm_slave)                                                      \\\n  CB(mpi_send_fluid_slave)                                                     \\\n  CB(mpi_recv_fluid_slave)                                                     \\\n  CB(mpi_local_stress_tensor_slave)                                            \\\n  CB(mpi_send_virtual_slave)                                                   \\\n  CB(mpi_iccp3m_iteration_slave)                                               \\\n  CB(mpi_iccp3m_init_slave)                                                    \\\n  CB(mpi_send_rotational_inertia_slave)                                        \\\n  CB(mpi_send_affinity_slave)                                                  \\\n  CB(mpi_rotate_particle_slave)                                                \\\n  CB(mpi_send_out_direction_slave)                                             \\\n  CB(mpi_send_mu_E_slave)                                                      \\\n  CB(mpi_bcast_max_mu_slave)                                                   \\\n  CB(mpi_send_vs_quat_slave)                                                   \\\n  CB(mpi_send_vs_relative_slave)                                               \\\n  CB(mpi_recv_fluid_populations_slave)                                         \\\n  CB(mpi_send_fluid_populations_slave)                                         \\\n  CB(mpi_recv_fluid_boundary_flag_slave)                                       \\\n  CB(mpi_set_particle_temperature_slave)                                       \\\n  CB(mpi_set_particle_gamma_slave)                                             \\\n  CB(mpi_set_particle_gamma_rot_slave)                                         \\\n  CB(mpi_kill_particle_motion_slave)                                           \\\n  CB(mpi_kill_particle_forces_slave)                                           \\\n  CB(mpi_system_CMS_slave)                                                     \\\n  CB(mpi_system_CMS_velocity_slave)                                            \\\n  CB(mpi_galilei_transform_slave)                                              \\\n  CB(mpi_setup_reaction_slave)                                                 \\\n  CB(mpi_send_rotation_slave)                                                  \\\n  CB(mpi_check_runtime_errors_slave)                                           \\\n  CB(mpi_minimize_energy_slave)                                                \\\n  CB(mpi_gather_cuda_devices_slave)                                            \\\n  CB(mpi_scafacos_set_parameters_slave)                                        \\\n  CB(mpi_scafacos_set_r_cut_and_tune_slave)                                    \\\n  CB(mpi_scafacos_free_slave)                                                  \\\n  CB(mpi_resort_particles_slave)                                               \\\n  CB(mpi_get_pairs_slave)                                                      \\\n  CB(mpi_get_particles_slave)                                                  \\\n  CB(mpi_rotate_system_slave)\n\n// create the forward declarations\n#define CB(name) void name(int node, int param);\nCALLBACK_LIST\n\nnamespace {\n\n// create the list of callbacks\n#undef CB\n#define CB(name) name,\nstd::vector<SlaveCallback *> slave_callbacks{CALLBACK_LIST};\n\n/** The callback name list is only used for\n    debugging.\n*/\n#ifdef COMM_DEBUG\n// create the list of names\n#undef CB\n#define CB(name) #name,\n\nstd::vector<std::string> names{CALLBACK_LIST};\n#endif\n} // namespace\n\n/** Forward declarations */\n\nint mpi_check_runtime_errors(void);\n\n/**********************************************\n * procedures\n **********************************************/\n\nvoid mpi_init() {\n#ifdef OPEN_MPI\n  void *handle = 0;\n  int mode = RTLD_NOW | RTLD_GLOBAL;\n#ifdef RTLD_NOLOAD\n  mode |= RTLD_NOLOAD;\n#endif\n  void *_openmpi_symbol = dlsym(RTLD_DEFAULT, \"MPI_Init\");\n  if (!_openmpi_symbol) {\n    fprintf(stderr, \"%d: Aborting because unable to find OpenMPI symbol.\\n\",\n            this_node);\n    errexit();\n  }\n  Dl_info _openmpi_info;\n  dladdr(_openmpi_symbol, &_openmpi_info);\n\n  if (!handle)\n    handle = dlopen(_openmpi_info.dli_fname, mode);\n\n  if (!handle) {\n    fprintf(stderr,\n            \"%d: Aborting because unable to load libmpi into the \"\n            \"global symbol space.\\n\",\n            this_node);\n    errexit();\n  }\n#endif\n\n#ifdef BOOST_MPI_HAS_NOARG_INITIALIZATION\n  Communication::mpi_env = Utils::make_unique<boost::mpi::environment>();\n#else\n  int argc{};\n  char **argv{};\n  Communication::mpi_env =\n      Utils::make_unique<boost::mpi::environment>(argc, argv);\n#endif\n\n  MPI_Comm_size(MPI_COMM_WORLD, &n_nodes);\n  MPI_Dims_create(n_nodes, 3, node_grid);\n\n  mpi_reshape_communicator({{node_grid[0], node_grid[1], node_grid[2]}},\n                           /* periodicity */ {{1, 1, 1}});\n  MPI_Cart_coords(comm_cart, this_node, 3, node_pos);\n\n  Communication::m_callbacks =\n      Utils::make_unique<Communication::MpiCallbacks>(comm_cart);\n\n  for (int i = 0; i < slave_callbacks.size(); ++i) {\n    mpiCallbacks().add(slave_callbacks[i]);\n  }\n\n  ErrorHandling::init_error_handling(mpiCallbacks());\n  partCfg(Utils::make_unique<PartCfg>(mpiCallbacks(), GetLocalParts()));\n\n  on_program_start();\n}\n\nvoid mpi_reshape_communicator(std::array<int, 3> const &node_grid,\n                              std::array<int, 3> const &periodicity) {\n  MPI_Comm temp_comm;\n  MPI_Cart_create(MPI_COMM_WORLD, 3, const_cast<int *>(node_grid.data()),\n                  const_cast<int *>(periodicity.data()), 0, &temp_comm);\n  comm_cart =\n      boost::mpi::communicator(temp_comm, boost::mpi::comm_take_ownership);\n\n  this_node = comm_cart.rank();\n}\n\nvoid mpi_call(SlaveCallback cb, int node, int param) {\n#ifdef COMM_DEBUG\n  auto it = std::find(slave_callbacks.begin(), slave_callbacks.end(), cb);\n\n  if (it != slave_callbacks.end()) {\n    auto const id = it - slave_callbacks.begin();\n    COMM_TRACE(fprintf(stderr, \"%d: issuing %s %d %d\\n\", this_node,\n                       names[id].c_str(), node, param));\n  }\n#endif /* COMM_DEBUG */\n  mpiCallbacks().call(cb, node, param);\n\n  COMM_TRACE(fprintf(stderr, \"%d: finished sending.\\n\", this_node));\n}\n\n/**************** REQ_CHTOPL ***********/\nvoid mpi_bcast_event(int event) {\n  mpi_call(mpi_bcast_event_slave, -1, event);\n  mpi_bcast_event_slave(-1, event);\n}\n\nvoid mpi_bcast_event_slave(int node, int event) {\n  switch (event) {\n#ifdef ELECTROSTATICS\n#ifdef P3M\n  case P3M_COUNT_CHARGES:\n    p3m_count_charged_particles();\n    break;\n#endif\n  case MAGGS_COUNT_CHARGES:\n    maggs_count_charged_particles();\n    break;\n#endif\n  case CHECK_PARTICLES:\n    check_particles();\n    break;\n\n#ifdef DP3M\n  case P3M_COUNT_DIPOLES:\n    dp3m_count_magnetic_particles();\n    break;\n#endif\n\n  default:;\n  }\n}\n\n/****************** REQ_PLACE/REQ_PLACE_NEW ************/\n\nvoid mpi_place_particle(int pnode, int part, double p[3]) {\n  mpi_call(mpi_place_particle_slave, pnode, part);\n\n  if (pnode == this_node)\n    local_place_particle(part, p, 0);\n  else\n    MPI_Send(p, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n\n  set_resort_particles(Cells::RESORT_GLOBAL);\n  on_particle_change();\n}\n\nvoid mpi_place_particle_slave(int pnode, int part) {\n\n  if (pnode == this_node) {\n    double p[3];\n    MPI_Recv(p, 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    local_place_particle(part, p, 0);\n  }\n\n  set_resort_particles(Cells::RESORT_GLOBAL);\n  on_particle_change();\n}\n\nvoid mpi_place_new_particle(int pnode, int part, double p[3]) {\n  mpi_call(mpi_place_new_particle_slave, pnode, part);\n  added_particle(part);\n\n  if (pnode == this_node)\n    local_place_particle(part, p, 1);\n  else\n    MPI_Send(p, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n\n  on_particle_change();\n}\n\nvoid mpi_place_new_particle_slave(int pnode, int part) {\n\n  added_particle(part);\n\n  if (pnode == this_node) {\n    double p[3];\n    MPI_Recv(p, 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    local_place_particle(part, p, 1);\n  }\n\n  on_particle_change();\n}\n\n/****************** REQ_SET_V ************/\nvoid mpi_send_v(int pnode, int part, double *v) {\n  mpi_call(mpi_send_v_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n\n    p->m.v = {v[0], v[1], v[2]};\n  } else\n    MPI_Send(v, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n\n  on_particle_change();\n}\n\nvoid mpi_send_v_slave(int pnode, int part) {\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->m.v.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n}\n\n/****************** REQ_SET_SWIMMING ************/\nvoid mpi_send_swimming(int pnode, int part, ParticleParametersSwimming swim) {\n#ifdef ENGINE\n  mpi_call(mpi_send_swimming_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->swim = swim;\n  } else {\n    MPI_Send(&swim, sizeof(ParticleParametersSwimming), MPI_BYTE, pnode,\n             SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_swimming_slave(int pnode, int part) {\n#ifdef ENGINE\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->swim, sizeof(ParticleParametersSwimming), MPI_BYTE, 0,\n             SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/****************** REQ_SET_F ************/\nvoid mpi_send_f(int pnode, int part, const Vector3d &F) {\n  mpi_call(mpi_send_f_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->f.f = F;\n  } else {\n    comm_cart.send(pnode, SOME_TAG, F);\n  }\n\n  on_particle_change();\n}\n\nvoid mpi_send_f_slave(int pnode, int part) {\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    Vector3d F;\n    comm_cart.recv(0, SOME_TAG, F);\n\n    p->f.f = F;\n  }\n\n  on_particle_change();\n}\n\n/********************* REQ_SET_Q ********/\nvoid mpi_send_q(int pnode, int part, double q) {\n#ifdef ELECTROSTATICS\n  mpi_call(mpi_send_q_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.q = q;\n  } else {\n    MPI_Send(&q, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_charge_change();\n#endif\n}\n\nvoid mpi_send_q_slave(int pnode, int part) {\n#ifdef ELECTROSTATICS\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.q, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n  }\n\n  on_particle_charge_change();\n#endif\n}\n\n/********************* REQ_SET_MU_E ********/\nvoid mpi_send_mu_E(int pnode, int part, double mu_E[3]) {\n#ifdef LB_ELECTROHYDRODYNAMICS\n  mpi_call(mpi_send_mu_E_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.mu_E[0] = mu_E[0];\n    p->p.mu_E[1] = mu_E[1];\n    p->p.mu_E[2] = mu_E[2];\n  } else {\n    MPI_Send(mu_E, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_mu_E_slave(int pnode, int part) {\n#ifdef LB_ELECTROHYDRODYNAMICS\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->p.mu_E.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_SOLV ********/\nvoid mpi_send_solvation(int pnode, int part, double *solvation) {\n#ifdef SHANCHEN\n  mpi_call(mpi_send_solvation_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    for (int ii = 0; ii < 2 * LB_COMPONENTS; ii++)\n      p->p.solvation[ii] = solvation[ii];\n  } else {\n    MPI_Send(&solvation, LB_COMPONENTS, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_solvation_slave(int pnode, int part) {\n#ifdef SHANCHEN\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.solvation, 2 * LB_COMPONENTS, MPI_DOUBLE, 0, SOME_TAG,\n             comm_cart, MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_M ********/\nvoid mpi_send_mass(int pnode, int part, double mass) {\n#ifdef MASS\n  mpi_call(mpi_send_mass_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.mass = mass;\n  } else {\n    MPI_Send(&mass, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_mass_slave(int pnode, int part) {\n#ifdef MASS\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.mass, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_RINERTIA ********/\n\nvoid mpi_send_rotational_inertia(int pnode, int part, double rinertia[3]) {\n#ifdef ROTATIONAL_INERTIA\n  mpi_call(mpi_send_rotational_inertia_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.rinertia[0] = rinertia[0];\n    p->p.rinertia[1] = rinertia[1];\n    p->p.rinertia[2] = rinertia[2];\n  } else {\n    MPI_Send(rinertia, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_rotational_inertia_slave(int pnode, int part) {\n#ifdef ROTATIONAL_INERTIA\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->p.rinertia.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_rotate_particle(int pnode, int part, double axis[3], double angle) {\n#ifdef ROTATION\n  mpi_call(mpi_rotate_particle_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    local_rotate_particle(p, axis, angle);\n  } else {\n    MPI_Send(axis, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n    MPI_Send(&angle, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_rotate_particle_slave(int pnode, int part) {\n#ifdef ROTATION\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    double axis[3], angle;\n    MPI_Recv(axis, 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    MPI_Recv(&angle, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    local_rotate_particle(p, axis, angle);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_BOND_SITE ********/\n\nvoid mpi_send_affinity_slave(int pnode, int part) {\n#ifdef AFFINITY\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->p.bond_site.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_affinity(int pnode, int part, double bond_site[3]) {\n#ifdef AFFINITY\n  mpi_call(mpi_send_affinity_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.bond_site[0] = bond_site[0];\n    p->p.bond_site[1] = bond_site[1];\n    p->p.bond_site[2] = bond_site[2];\n  } else {\n    MPI_Send(bond_site, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_OUT_DIRECTION ********/\n\nvoid mpi_send_out_direction(int pnode, int part, double out_direction[3]) {\n#ifdef MEMBRANE_COLLISION\n  mpi_call(mpi_send_out_direction_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.out_direction[0] = out_direction[0];\n    p->p.out_direction[1] = out_direction[1];\n    p->p.out_direction[2] = out_direction[2];\n  } else {\n    MPI_Send(out_direction, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_out_direction_slave(int pnode, int part) {\n#ifdef MEMBRANE_COLLISION\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->p.out_direction.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_TYPE ********/\nvoid mpi_send_type(int pnode, int part, int type) {\n  mpi_call(mpi_send_type_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.type = type;\n  } else\n    MPI_Send(&type, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n\n  on_particle_change();\n}\n\nvoid mpi_send_type_slave(int pnode, int part) {\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.type, 1, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n}\n\n/********************* REQ_SET_MOLID ********/\nvoid mpi_send_mol_id(int pnode, int part, int mid) {\n  mpi_call(mpi_send_mol_id_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.mol_id = mid;\n  } else\n    MPI_Send(&mid, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n\n  on_particle_change();\n}\n\nvoid mpi_send_mol_id_slave(int pnode, int part) {\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.mol_id, 1, MPI_INT, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n}\n\n/********************* REQ_SET_QUAT ********/\n\nvoid mpi_send_quat(int pnode, int part, double quat[4]) {\n#ifdef ROTATION\n  mpi_call(mpi_send_quat_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->r.quat[0] = quat[0];\n    p->r.quat[1] = quat[1];\n    p->r.quat[2] = quat[2];\n    p->r.quat[3] = quat[3];\n    convert_quat_to_quatu(p->r.quat, p->r.quatu);\n#ifdef DIPOLES\n    convert_quatu_to_dip(p->r.quatu, p->p.dipm, p->r.dip);\n#endif\n  } else {\n    MPI_Send(quat, 4, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_quat_slave(int pnode, int part) {\n#ifdef ROTATION\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->r.quat.data(), 4, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n    convert_quat_to_quatu(p->r.quat, p->r.quatu);\n#ifdef DIPOLES\n    convert_quatu_to_dip(p->r.quatu, p->p.dipm, p->r.dip);\n#endif\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_OMEGA ********/\n\nvoid mpi_send_omega(int pnode, int part, double omega[3]) {\n#ifdef ROTATION\n  mpi_call(mpi_send_omega_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /*  memmove(p->omega, omega, 3*sizeof(double));*/\n    p->m.omega[0] = omega[0];\n    p->m.omega[1] = omega[1];\n    p->m.omega[2] = omega[2];\n  } else {\n    MPI_Send(omega, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_omega_slave(int pnode, int part) {\n#ifdef ROTATION\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->m.omega.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_TORQUE ********/\n\nvoid mpi_send_torque(int pnode, int part, double torque[3]) {\n#ifdef ROTATION\n  mpi_call(mpi_send_torque_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->f.torque[0] = torque[0];\n    p->f.torque[1] = torque[1];\n    p->f.torque[2] = torque[2];\n  } else {\n    MPI_Send(torque, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_torque_slave(int pnode, int part) {\n#ifdef ROTATION\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->f.torque.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_DIP ********/\n\nvoid mpi_send_dip(int pnode, int part, double dip[3]) {\n#ifdef DIPOLES\n  mpi_call(mpi_send_dip_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->r.dip[0] = dip[0];\n    p->r.dip[1] = dip[1];\n    p->r.dip[2] = dip[2];\n#ifdef ROTATION\n    convert_dip_to_quat(p->r.dip, p->r.quat, &p->p.dipm);\n    convert_quat_to_quatu(p->r.quat, p->r.quatu);\n#else\n    p->p.dipm = sqrt(p->r.dip[0] * p->r.dip[0] + p->r.dip[1] * p->r.dip[1] +\n                     p->r.dip[2] * p->r.dip[2]);\n#endif\n  } else {\n    MPI_Send(dip, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_dip_slave(int pnode, int part) {\n#ifdef DIPOLES\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->r.dip.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n#ifdef ROTATION\n    convert_dip_to_quat(p->r.dip, p->r.quat, &p->p.dipm);\n    convert_quat_to_quatu(p->r.quat, p->r.quatu);\n#else\n    p->p.dipm = sqrt(p->r.dip[0] * p->r.dip[0] + p->r.dip[1] * p->r.dip[1] +\n                     p->r.dip[2] * p->r.dip[2]);\n#endif\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_DIPM ********/\n\nvoid mpi_send_dipm(int pnode, int part, double dipm) {\n#ifdef DIPOLES\n  mpi_call(mpi_send_dipm_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.dipm = dipm;\n#ifdef ROTATION\n    convert_quatu_to_dip(p->r.quatu, p->p.dipm, p->r.dip);\n#endif\n  } else {\n    MPI_Send(&dipm, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_dipm_slave(int pnode, int part) {\n#ifdef DIPOLES\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.dipm, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n#ifdef ROTATION\n    convert_quatu_to_dip(p->r.quatu, p->p.dipm, p->r.dip);\n#endif\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_ISVI ********/\n\nvoid mpi_send_virtual(int pnode, int part, int is_virtual) {\n#ifdef VIRTUAL_SITES\n  mpi_call(mpi_send_virtual_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.is_virtual = is_virtual;\n  } else {\n    MPI_Send(&is_virtual, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_virtual_slave(int pnode, int part) {\n#ifdef VIRTUAL_SITES\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&(p->p.is_virtual), 1, MPI_INT, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/********************* REQ_SET_BOND ********/\nvoid mpi_send_vs_quat(int pnode, int part, double *vs_quat) {\n#ifdef VIRTUAL_SITES_RELATIVE\n  mpi_call(mpi_send_vs_quat_slave, pnode, part);\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    for (int i = 0; i < 4; ++i) {\n      p->p.vs_quat[i] = vs_quat[i];\n    }\n  } else {\n    MPI_Send(vs_quat, 4, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\nvoid mpi_send_vs_quat_slave(int pnode, int part) {\n#ifdef VIRTUAL_SITES_RELATIVE\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(p->p.vs_quat, 4, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_vs_relative(int pnode, int part, int vs_relative_to,\n                          double vs_distance, double *rel_ori) {\n#ifdef VIRTUAL_SITES_RELATIVE\n  mpi_call(mpi_send_vs_relative_slave, pnode, part);\n\n  // If the particle is on the node on which this function was called\n  // set the values locally\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.vs_relative_to_particle_id = vs_relative_to;\n    p->p.vs_relative_distance = vs_distance;\n    for (int i = 0; i < 4; i++) {\n      p->p.vs_relative_rel_orientation[i] = rel_ori[i];\n    }\n  } else {\n    MPI_Send(&vs_relative_to, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n    MPI_Send(&vs_distance, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n    MPI_Send(rel_ori, 4, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_vs_relative_slave(int pnode, int part) {\n#ifdef VIRTUAL_SITES_RELATIVE\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Recv(&p->p.vs_relative_to_particle_id, 1, MPI_INT, 0, SOME_TAG,\n             comm_cart, MPI_STATUS_IGNORE);\n    MPI_Recv(&p->p.vs_relative_distance, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n    MPI_Recv(p->p.vs_relative_rel_orientation, 4, MPI_DOUBLE, 0, SOME_TAG,\n             comm_cart, MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n// ********************************\n\nvoid mpi_send_rotation(int pnode, int part, short int rot) {\n  mpi_call(mpi_send_rotation_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    p->p.rotation = rot;\n  } else {\n    MPI_Send(&rot, 1, MPI_SHORT, pnode, SOME_TAG, MPI_COMM_WORLD);\n  }\n\n  on_particle_change();\n}\n\nvoid mpi_send_rotation_slave(int pnode, int part) {\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Status status;\n    MPI_Recv(&p->p.rotation, 1, MPI_SHORT, 0, SOME_TAG, MPI_COMM_WORLD,\n             &status);\n  }\n\n  on_particle_change();\n}\n\n/********************* REQ_SET_BOND ********/\n\nint mpi_send_bond(int pnode, int part, int *bond, int _delete) {\n  int bond_size, stat = 0;\n\n  mpi_call(mpi_send_bond_slave, pnode, part);\n\n  bond_size = (bond) ? bonded_ia_params[bond[0]].num + 1 : 0;\n\n  if (pnode == this_node) {\n    stat = local_change_bond(part, bond, _delete);\n    on_particle_change();\n    return stat;\n  }\n  /* else */\n  MPI_Send(&bond_size, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n  if (bond_size)\n    MPI_Send(bond, bond_size, MPI_INT, pnode, SOME_TAG, comm_cart);\n  MPI_Send(&_delete, 1, MPI_INT, pnode, SOME_TAG, comm_cart);\n  MPI_Recv(&stat, 1, MPI_INT, pnode, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n  on_particle_change();\n  return stat;\n}\n\nvoid mpi_send_bond_slave(int pnode, int part) {\n  int bond_size = 0, _delete = 0, stat;\n\n  if (pnode == this_node) {\n    MPI_Recv(&bond_size, 1, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    int *bond;\n    if (bond_size) {\n      bond = (int *)Utils::malloc(bond_size * sizeof(int));\n      MPI_Recv(bond, bond_size, MPI_INT, 0, SOME_TAG, comm_cart,\n               MPI_STATUS_IGNORE);\n    } else\n      bond = nullptr;\n    MPI_Recv(&_delete, 1, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    stat = local_change_bond(part, bond, _delete);\n    if (bond)\n      free(bond);\n    MPI_Send(&stat, 1, MPI_INT, 0, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n}\n\n/****************** REQ_GET_PART ************/\nParticle mpi_recv_part(int pnode, int part) {\n  Particle ret;\n\n  mpi_call(mpi_recv_part_slave, pnode, part);\n  comm_cart.recv(pnode, SOME_TAG, ret);\n\n  return ret;\n}\n\nvoid mpi_recv_part_slave(int pnode, int part) {\n  if (pnode != this_node)\n    return;\n\n  assert(local_particles[part]);\n  comm_cart.send(0, SOME_TAG, *local_particles[part]);\n}\n\n/****************** REQ_REM_PART ************/\nvoid mpi_remove_particle(int pnode, int part) {\n  mpi_call(mpi_remove_particle_slave, pnode, part);\n  mpi_remove_particle_slave(pnode, part);\n}\n\nvoid mpi_remove_particle_slave(int pnode, int part) {\n  if (part != -1) {\n    n_part--;\n\n    if (pnode == this_node)\n      local_remove_particle(part);\n\n    remove_all_bonds_to(part);\n  } else\n    local_remove_all_particles();\n\n  on_particle_change();\n}\n\n/********************* REQ_MIN_ENERGY ********/\n\nint mpi_minimize_energy(void) {\n  mpi_call(mpi_minimize_energy_slave, 0, 0);\n  return minimize_energy();\n}\n\nvoid mpi_minimize_energy_slave(int a, int b) { minimize_energy(); }\n\n/********************* REQ_INTEGRATE ********/\nint mpi_integrate(int n_steps, int reuse_forces) {\n  mpi_call(mpi_integrate_slave, n_steps, reuse_forces);\n  integrate_vv(n_steps, reuse_forces);\n  COMM_TRACE(\n      fprintf(stderr, \"%d: integration task %d done.\\n\", this_node, n_steps));\n  return mpi_check_runtime_errors();\n}\n\nvoid mpi_integrate_slave(int n_steps, int reuse_forces) {\n  integrate_vv(n_steps, reuse_forces);\n  COMM_TRACE(fprintf(\n      stderr, \"%d: integration for %d n_steps with %d reuse_forces done.\\n\",\n      this_node, n_steps, reuse_forces));\n}\n\n/*************** REQ_BCAST_IA ************/\nvoid mpi_bcast_all_ia_params() {\n  mpi_call(mpi_bcast_all_ia_params_slave, -1, -1);\n  boost::mpi::broadcast(comm_cart, ia_params, 0);\n}\n\nvoid mpi_bcast_all_ia_params_slave(int a, int b) {\n  boost::mpi::broadcast(comm_cart, ia_params, 0);\n}\n\nvoid mpi_bcast_ia_params(int i, int j) {\n  mpi_call(mpi_bcast_ia_params_slave, i, j);\n\n  if (j >= 0) {\n    /* non-bonded interaction parameters */\n    boost::mpi::broadcast(comm_cart, *get_ia_param(i, j), 0);\n\n    *get_ia_param(j, i) = *get_ia_param(i, j);\n  } else {\n    /* bonded interaction parameters */\n    MPI_Bcast(&(bonded_ia_params[i]), sizeof(Bonded_ia_parameters), MPI_BYTE, 0,\n              comm_cart);\n#ifdef TABULATED\n    /* For tabulated potentials we have to send the tables extra */\n    if (bonded_ia_params[i].type == BONDED_IA_TABULATED) {\n      boost::mpi::broadcast(comm_cart, *bonded_ia_params[i].p.tab.pot, 0);\n    }\n#endif\n  }\n\n  on_short_range_ia_change();\n}\n\nvoid mpi_bcast_ia_params_slave(int i, int j) {\n  if (j >= 0) { /* non-bonded interaction parameters */\n\n    boost::mpi::broadcast(comm_cart, *get_ia_param(i, j), 0);\n\n    *get_ia_param(j, i) = *get_ia_param(i, j);\n\n  } else {                   /* bonded interaction parameters */\n    make_bond_type_exist(i); /* realloc bonded_ia_params on slave nodes! */\n    MPI_Bcast(&(bonded_ia_params[i]), sizeof(Bonded_ia_parameters), MPI_BYTE, 0,\n              comm_cart);\n#ifdef TABULATED\n    /* For tabulated potentials we have to send the tables extra */\n    if (bonded_ia_params[i].type == BONDED_IA_TABULATED) {\n      auto *tab_pot = new TabulatedPotential();\n      boost::mpi::broadcast(comm_cart, *tab_pot, 0);\n\n      bonded_ia_params[i].p.tab.pot = tab_pot;\n    }\n#endif\n  }\n\n  on_short_range_ia_change();\n}\n\n/*************** REQ_BCAST_IA_SIZE ************/\n\nvoid mpi_bcast_max_seen_particle_type(int ns) {\n  mpi_call(mpi_bcast_max_seen_particle_type_slave, -1, ns);\n  mpi_bcast_max_seen_particle_type_slave(-1, ns);\n}\n\nvoid mpi_bcast_max_seen_particle_type_slave(int pnode, int ns) {\n  realloc_ia_params(ns);\n}\n\n/*************** REQ_GATHER ************/\nvoid mpi_gather_stats(int job, void *result, void *result_t, void *result_nb,\n                      void *result_t_nb) {\n  switch (job) {\n  case 1:\n    mpi_call(mpi_gather_stats_slave, -1, 1);\n    energy_calc((double *)result);\n    break;\n  case 2:\n    /* calculate and reduce (sum up) virials for 'analyze pressure' or\n       'analyze stress_tensor' */\n    mpi_call(mpi_gather_stats_slave, -1, 2);\n    pressure_calc((double *)result, (double *)result_t, (double *)result_nb,\n                  (double *)result_t_nb, 0);\n    break;\n  case 3:\n    mpi_call(mpi_gather_stats_slave, -1, 3);\n    pressure_calc((double *)result, (double *)result_t, (double *)result_nb,\n                  (double *)result_t_nb, 1);\n    break;\n  case 4:\n    mpi_call(mpi_gather_stats_slave, -1, 4);\n    predict_momentum_particles((double *)result);\n    break;\n#ifdef LB\n  case 5:\n    mpi_call(mpi_gather_stats_slave, -1, 5);\n    lb_calc_fluid_mass((double *)result);\n    break;\n  case 6:\n    mpi_call(mpi_gather_stats_slave, -1, 6);\n    lb_calc_fluid_momentum((double *)result);\n    break;\n  case 7:\n    mpi_call(mpi_gather_stats_slave, -1, 7);\n    lb_calc_fluid_temp((double *)result);\n    break;\n#ifdef LB_BOUNDARIES\n  case 8:\n    mpi_call(mpi_gather_stats_slave, -1, 8);\n    lb_collect_boundary_forces((double *)result);\n    break;\n#endif\n#endif\n  default:\n    fprintf(\n        stderr,\n        \"%d: INTERNAL ERROR: illegal request %d for mpi_gather_stats_slave\\n\",\n        this_node, job);\n    errexit();\n  }\n}\n\nvoid mpi_gather_stats_slave(int ana_num, int job) {\n  switch (job) {\n  case 1:\n    /* calculate and reduce (sum up) energies */\n    energy_calc(nullptr);\n    break;\n  case 2:\n    /* calculate and reduce (sum up) virials for 'analyze pressure' or 'analyze\n     * stress_tensor'*/\n    pressure_calc(nullptr, nullptr, nullptr, nullptr, 0);\n    break;\n  case 3:\n    /* calculate and reduce (sum up) virials, revert velocities half a timestep\n     * for 'analyze p_inst' */\n    pressure_calc(nullptr, nullptr, nullptr, nullptr, 1);\n    break;\n  case 4:\n    predict_momentum_particles(nullptr);\n    break;\n#ifdef LB\n  case 5:\n    lb_calc_fluid_mass(nullptr);\n    break;\n  case 6:\n    lb_calc_fluid_momentum(nullptr);\n    break;\n  case 7:\n    lb_calc_fluid_temp(nullptr);\n    break;\n#ifdef LB_BOUNDARIES\n  case 8:\n    lb_collect_boundary_forces(nullptr);\n    break;\n#endif\n#endif\n  default:\n    fprintf(\n        stderr,\n        \"%d: INTERNAL ERROR: illegal request %d for mpi_gather_stats_slave\\n\",\n        this_node, job);\n    errexit();\n  }\n}\n\n/*************** REQ_GET_LOCAL_STRESS_TENSOR ************/\nvoid mpi_local_stress_tensor(DoubleList *TensorInBin, int bins[3],\n                             int periodic[3], double range_start[3],\n                             double range[3]) {\n\n  PTENSOR_TRACE(fprintf(stderr,\n                        \"%d: mpi_local_stress_tensor: Broadcasting \"\n                        \"local_stress_tensor parameters\\n\",\n                        this_node));\n\n  mpi_call(mpi_local_stress_tensor_slave, -1, 0);\n\n  MPI_Bcast(bins, 3, MPI_INT, 0, comm_cart);\n  MPI_Bcast(periodic, 3, MPI_INT, 0, comm_cart);\n  MPI_Bcast(range_start, 3, MPI_DOUBLE, 0, comm_cart);\n  MPI_Bcast(range, 3, MPI_DOUBLE, 0, comm_cart);\n\n  PTENSOR_TRACE(fprintf(\n      stderr, \"%d: mpi_local_stress_tensor: Call local_stress_tensor_calc\\n\",\n      this_node));\n  local_stress_tensor_calc(TensorInBin, bins, periodic, range_start, range);\n\n  PTENSOR_TRACE(fprintf(stderr,\n                        \"%d: mpi_local_stress_tensor: Reduce local \"\n                        \"stress tensors with MPI_Reduce\\n\",\n                        this_node));\n  for (int i = 0; i < bins[0] * bins[1] * bins[2]; i++) {\n    MPI_Reduce(MPI_IN_PLACE, TensorInBin[i].e, 9, MPI_DOUBLE, MPI_SUM, 0,\n               comm_cart);\n  }\n}\n\nvoid mpi_local_stress_tensor_slave(int ana_num, int job) {\n  int bins[3] = {0, 0, 0};\n  int periodic[3] = {0, 0, 0};\n  double range_start[3] = {0, 0, 0};\n  double range[3] = {0, 0, 0};\n  int i, j;\n\n  MPI_Bcast(bins, 3, MPI_INT, 0, comm_cart);\n  MPI_Bcast(periodic, 3, MPI_INT, 0, comm_cart);\n  MPI_Bcast(range_start, 3, MPI_DOUBLE, 0, comm_cart);\n  MPI_Bcast(range, 3, MPI_DOUBLE, 0, comm_cart);\n\n  auto TensorInBin =\n      std::vector<DoubleList>(bins[0] * bins[1] * bins[2], DoubleList(9, 0.0));\n\n  local_stress_tensor_calc(TensorInBin.data(), bins, periodic, range_start,\n                           range);\n\n  for (i = 0; i < bins[0] * bins[1] * bins[2]; i++) {\n    MPI_Reduce(TensorInBin[i].e, nullptr, 9, MPI_DOUBLE, MPI_SUM, 0, comm_cart);\n    PTENSOR_TRACE(fprintf(\n        stderr, \"%d: mpi_local_stress_tensor: Tensor sent in bin %d is {\",\n        this_node, i));\n    for (j = 0; j < 9; j++) {\n      PTENSOR_TRACE(fprintf(stderr, \"%f \", TensorInBin[i].e[j]));\n    }\n    PTENSOR_TRACE(fprintf(stderr, \"}\\n\"));\n  }\n}\n\n/*************** REQ_SET_TIME_STEP ************/\nvoid mpi_set_time_step(double time_s) {\n  double old_ts = time_step;\n\n  mpi_call(mpi_set_time_step_slave, -1, 0);\n\n  time_step = time_s;\n\n  time_step_squared = time_step * time_step;\n  time_step_squared_half = time_step_squared / 2.;\n  time_step_half = time_step / 2.;\n\n  MPI_Bcast(&time_step, 1, MPI_DOUBLE, 0, comm_cart);\n\n  rescale_velocities(time_step / old_ts);\n  on_parameter_change(FIELD_TIMESTEP);\n}\n\nvoid mpi_set_time_step_slave(int node, int i) {\n  double old_ts = time_step;\n\n  MPI_Bcast(&time_step, 1, MPI_DOUBLE, 0, comm_cart);\n  rescale_velocities(time_step / old_ts);\n  on_parameter_change(FIELD_TIMESTEP);\n  time_step_squared = time_step * time_step;\n  time_step_squared_half = time_step_squared / 2.;\n  time_step_half = time_step / 2.;\n}\n\nint mpi_check_runtime_errors(void) {\n  mpi_call(mpi_check_runtime_errors_slave, 0, 0);\n  return check_runtime_errors();\n}\n\nvoid mpi_check_runtime_errors_slave(int a, int b) { check_runtime_errors(); }\n\n/*************** REQ_BCAST_COULOMB ************/\nvoid mpi_bcast_coulomb_params() {\n#if defined(ELECTROSTATICS) || defined(DIPOLES)\n  mpi_call(mpi_bcast_coulomb_params_slave, 1, 0);\n  mpi_bcast_coulomb_params_slave(-1, 0);\n#endif\n}\n\nvoid mpi_bcast_coulomb_params_slave(int node, int parm) {\n\n#if defined(ELECTROSTATICS) || defined(DIPOLES)\n  MPI_Bcast(&coulomb, sizeof(Coulomb_parameters), MPI_BYTE, 0, comm_cart);\n\n#ifdef ELECTROSTATICS\n  switch (coulomb.method) {\n  case COULOMB_NONE:\n  // fall through, scafacos has internal parameter propagation\n  case COULOMB_SCAFACOS:\n    break;\n#ifdef P3M\n  case COULOMB_ELC_P3M:\n    MPI_Bcast(&elc_params, sizeof(ELC_struct), MPI_BYTE, 0, comm_cart);\n  // fall through\n  case COULOMB_P3M_GPU:\n  case COULOMB_P3M:\n    MPI_Bcast(&p3m.params, sizeof(p3m_parameter_struct), MPI_BYTE, 0,\n              comm_cart);\n    break;\n#endif\n  case COULOMB_DH:\n    MPI_Bcast(&dh_params, sizeof(Debye_hueckel_params), MPI_BYTE, 0, comm_cart);\n    break;\n  case COULOMB_MMM1D:\n  case COULOMB_MMM1D_GPU:\n    MPI_Bcast(&mmm1d_params, sizeof(MMM1D_struct), MPI_BYTE, 0, comm_cart);\n    break;\n  case COULOMB_MMM2D:\n    MPI_Bcast(&mmm2d_params, sizeof(MMM2D_struct), MPI_BYTE, 0, comm_cart);\n    break;\n  case COULOMB_MAGGS:\n    MPI_Bcast(&maggs, sizeof(MAGGS_struct), MPI_BYTE, 0, comm_cart);\n    break;\n  case COULOMB_RF:\n  case COULOMB_INTER_RF:\n    MPI_Bcast(&rf_params, sizeof(Reaction_field_params), MPI_BYTE, 0,\n              comm_cart);\n    break;\n  default:\n    fprintf(stderr,\n            \"%d: INTERNAL ERROR: cannot bcast coulomb params for \"\n            \"unknown method %d\\n\",\n            this_node, coulomb.method);\n    errexit();\n  }\n#endif\n\n#ifdef DIPOLES\n  set_dipolar_method_local(coulomb.Dmethod);\n\n  switch (coulomb.Dmethod) {\n  case DIPOLAR_NONE:\n    break;\n#ifdef DP3M\n  case DIPOLAR_MDLC_P3M:\n    MPI_Bcast(&dlc_params, sizeof(DLC_struct), MPI_BYTE, 0, comm_cart);\n  // fall through\n  case DIPOLAR_P3M:\n    MPI_Bcast(&dp3m.params, sizeof(p3m_parameter_struct), MPI_BYTE, 0,\n              comm_cart);\n    break;\n#endif\n  case DIPOLAR_ALL_WITH_ALL_AND_NO_REPLICA:\n    break;\n  case DIPOLAR_MDLC_DS:\n  // fall trough\n  case DIPOLAR_DS:\n    break;\n  case DIPOLAR_DS_GPU:\n    break;\n#ifdef DIPOLAR_BARNES_HUT\n  case DIPOLAR_BH_GPU:\n    break;\n#endif\n  case DIPOLAR_SCAFACOS:\n    break;\n  default:\n    fprintf(stderr,\n            \"%d: INTERNAL ERROR: cannot bcast dipolar params for \"\n            \"unknown method %d\\n\",\n            this_node, coulomb.Dmethod);\n    errexit();\n  }\n\n#endif\n\n  on_coulomb_change();\n#endif\n}\n\n/*************** REQ_BCAST_COULOMB ************/\nvoid mpi_bcast_collision_params() {\n#ifdef COLLISION_DETECTION\n  mpi_call(mpi_bcast_collision_params_slave, 1, 0);\n  mpi_bcast_collision_params_slave(-1, 0);\n#endif\n}\n\nvoid mpi_bcast_collision_params_slave(int node, int parm) {\n#ifdef COLLISION_DETECTION\n  MPI_Bcast(&collision_params, sizeof(Collision_parameters), MPI_BYTE, 0,\n            comm_cart);\n\n  recalc_forces = 1;\n#endif\n}\n\n/****************** REQ_SET_PERM ************/\n\nvoid mpi_send_permittivity_slave(int node, int index) {\n#ifdef ELECTROSTATICS\n  if (node == this_node) {\n    double data[3];\n    int indices[3];\n    MPI_Recv(data, 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    MPI_Recv(indices, 3, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    for (int d = 0; d < 3; d++) {\n      maggs_set_permittivity(indices[0], indices[1], indices[2], d, data[d]);\n    }\n  }\n#endif\n}\n\nvoid mpi_send_permittivity(int node, int index, int *indices,\n                           double *permittivity) {\n#ifdef ELECTROSTATICS\n  if (node == this_node) {\n    for (int d = 0; d < 3; d++) {\n      maggs_set_permittivity(indices[0], indices[1], indices[2], d,\n                             permittivity[d]);\n    }\n  } else {\n    mpi_call(mpi_send_permittivity_slave, node, index);\n    MPI_Send(permittivity, 3, MPI_DOUBLE, node, SOME_TAG, comm_cart);\n    MPI_Send(indices, 3, MPI_INT, node, SOME_TAG, comm_cart);\n  }\n#endif\n}\n\n/****************** REQ_SET_EXT ************/\n\nvoid mpi_send_ext_torque(int pnode, int part, int flag, int mask,\n                         double torque[3]) {\n#ifdef EXTERNAL_FORCES\n#ifdef ROTATION\n  mpi_call(mpi_send_ext_torque_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /* mask out old flags */\n    p->p.ext_flag &= ~mask;\n    /* set new values */\n    p->p.ext_flag |= flag;\n\n    if (mask & PARTICLE_EXT_TORQUE)\n      p->p.ext_torque = {torque[0], torque[1], torque[2]};\n  } else {\n    int s_buf[2];\n    s_buf[0] = flag;\n    s_buf[1] = mask;\n    MPI_Send(s_buf, 2, MPI_INT, pnode, SOME_TAG, comm_cart);\n    if (mask & PARTICLE_EXT_TORQUE)\n      MPI_Send(torque, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n#endif\n}\n\nvoid mpi_send_ext_torque_slave(int pnode, int part) {\n#ifdef EXTERNAL_FORCES\n#ifdef ROTATION\n  if (pnode == this_node) {\n    int s_buf[2] = {0, 0};\n    Particle *p = local_particles[part];\n    MPI_Recv(s_buf, 2, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    /* mask out old flags */\n    p->p.ext_flag &= ~s_buf[1];\n    /* set new values */\n    p->p.ext_flag |= s_buf[0];\n\n    if (s_buf[1] & PARTICLE_EXT_TORQUE)\n      MPI_Recv(p->p.ext_torque.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n               MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n#endif\n}\n\nvoid mpi_send_ext_force(int pnode, int part, int flag, int mask,\n                        double force[3]) {\n#ifdef EXTERNAL_FORCES\n  mpi_call(mpi_send_ext_force_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /* mask out old flags */\n    p->p.ext_flag &= ~mask;\n    /* set new values */\n    p->p.ext_flag |= flag;\n    if (mask & PARTICLE_EXT_FORCE)\n      p->p.ext_force = {force[0], force[1], force[2]};\n  } else {\n    int s_buf[2];\n    s_buf[0] = flag;\n    s_buf[1] = mask;\n    MPI_Send(s_buf, 2, MPI_INT, pnode, SOME_TAG, comm_cart);\n    if (mask & PARTICLE_EXT_FORCE)\n      MPI_Send(force, 3, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_ext_force_slave(int pnode, int part) {\n#ifdef EXTERNAL_FORCES\n  if (pnode == this_node) {\n    int s_buf[2] = {0, 0};\n    Particle *p = local_particles[part];\n    MPI_Recv(s_buf, 2, MPI_INT, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    /* mask out old flags */\n    p->p.ext_flag &= ~s_buf[1];\n    /* set new values */\n    p->p.ext_flag |= s_buf[0];\n\n    if (s_buf[1] & PARTICLE_EXT_FORCE)\n      MPI_Recv(p->p.ext_force.data(), 3, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n               MPI_STATUS_IGNORE);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/****************** REQ_RESCALE_PART ************/\n\nvoid mpi_rescale_particles(int dir, double scale) {\n  int pnode;\n\n  mpi_call(mpi_rescale_particles_slave, -1, dir);\n  for (pnode = 0; pnode < n_nodes; pnode++) {\n    if (pnode == this_node) {\n      local_rescale_particles(dir, scale);\n    } else {\n      MPI_Send(&scale, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n    }\n  }\n  on_particle_change();\n}\n\nvoid mpi_rescale_particles_slave(int pnode, int dir) {\n  double scale = 0.0;\n  MPI_Recv(&scale, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n  local_rescale_particles(dir, scale);\n  on_particle_change();\n}\n\n/*************** REQ_BCAST_CS *****************/\n\nvoid mpi_bcast_cell_structure(int cs) {\n  mpi_call(mpi_bcast_cell_structure_slave, -1, cs);\n  cells_re_init(cs);\n}\n\nvoid mpi_bcast_cell_structure_slave(int pnode, int cs) { cells_re_init(cs); }\n\n/*************** REQ_BCAST_NPTISO_GEOM *****************/\n\nvoid mpi_bcast_nptiso_geom() {\n  mpi_call(mpi_bcast_nptiso_geom_slave, -1, 0);\n  mpi_bcast_nptiso_geom_slave(-1, 0);\n}\n\nvoid mpi_bcast_nptiso_geom_slave(int node, int parm) {\n  MPI_Bcast(&nptiso.geometry, 1, MPI_INT, 0, comm_cart);\n  MPI_Bcast(&nptiso.dimension, 1, MPI_INT, 0, comm_cart);\n  MPI_Bcast(&nptiso.cubic_box, 1, MPI_INT, 0, comm_cart);\n  MPI_Bcast(&nptiso.non_const_dim, 1, MPI_INT, 0, comm_cart);\n}\n\n/***************REQ_UPDATE_MOL_IDS *********************/\n\nvoid mpi_update_mol_ids() {\n  mpi_call(mpi_update_mol_ids_slave, -1, 0);\n  mpi_update_mol_ids_slave(-1, 0);\n}\n\nvoid mpi_update_mol_ids_slave(int node, int parm) {\n  update_mol_ids_setchains();\n}\n\n/******************* REQ_SYNC_TOPO ********************/\nint mpi_sync_topo_part_info() {\n  int i;\n  int molsize = 0;\n  int moltype = 0;\n\n  mpi_call(mpi_sync_topo_part_info_slave, -1, 0);\n  int n_mols = topology.size();\n  MPI_Bcast(&n_mols, 1, MPI_INT, 0, comm_cart);\n\n  for (i = 0; i < n_mols; i++) {\n    molsize = topology[i].part.n;\n    moltype = topology[i].type;\n\n#ifdef MOLFORCES\n    MPI_Bcast(&(topology[i].trap_flag), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(topology[i].trap_center, 3, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].trap_spring_constant), 1, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].drag_constant), 1, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].noforce_flag), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&(topology[i].isrelative), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&(topology[i].favcounter), 1, MPI_INT, 0, comm_cart);\n    if (topology[i].favcounter == -1)\n      MPI_Bcast(topology[i].fav, 3, MPI_DOUBLE, 0, comm_cart);\n    /* check if any molecules are trapped */\n    if ((topology[i].trap_flag != 32) && (topology[i].noforce_flag != 32)) {\n      IsTrapped = 1;\n    }\n#endif\n\n    MPI_Bcast(&molsize, 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&moltype, 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(topology[i].part.e, topology[i].part.n, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&topology[i].type, 1, MPI_INT, 0, comm_cart);\n  }\n\n  sync_topo_part_info();\n\n  return 1;\n}\n\nvoid mpi_sync_topo_part_info_slave(int node, int parm) {\n  int i;\n  int molsize = 0;\n  int moltype = 0;\n  int n_mols = 0;\n\n  MPI_Bcast(&n_mols, 1, MPI_INT, 0, comm_cart);\n  realloc_topology(n_mols);\n  for (i = 0; i < n_mols; i++) {\n\n#ifdef MOLFORCES\n    MPI_Bcast(&(topology[i].trap_flag), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(topology[i].trap_center, 3, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].trap_spring_constant), 1, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].drag_constant), 1, MPI_DOUBLE, 0, comm_cart);\n    MPI_Bcast(&(topology[i].noforce_flag), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&(topology[i].isrelative), 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&(topology[i].favcounter), 1, MPI_INT, 0, comm_cart);\n    if (topology[i].favcounter == -1)\n      MPI_Bcast(topology[i].fav, 3, MPI_DOUBLE, 0, comm_cart);\n    /* check if any molecules are trapped */\n    if ((topology[i].trap_flag != 32) && (topology[i].noforce_flag != 32)) {\n      IsTrapped = 1;\n    }\n#endif\n\n    MPI_Bcast(&molsize, 1, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&moltype, 1, MPI_INT, 0, comm_cart);\n    topology[i].type = moltype;\n    topology[i].part.resize(molsize);\n\n    MPI_Bcast(topology[i].part.e, topology[i].part.n, MPI_INT, 0, comm_cart);\n    MPI_Bcast(&topology[i].type, 1, MPI_INT, 0, comm_cart);\n  }\n\n  sync_topo_part_info();\n}\n\n/******************* REQ_BCAST_LBPAR ********************/\n\nvoid mpi_bcast_lb_params(int field, int value) {\n#ifdef LB\n  mpi_call(mpi_bcast_lb_params_slave, field, value);\n  mpi_bcast_lb_params_slave(field, value);\n#endif\n}\n\nvoid mpi_bcast_lb_params_slave(int field, int value) {\n#ifdef LB\n  MPI_Bcast(&lbpar, sizeof(LB_Parameters), MPI_BYTE, 0, comm_cart);\n  on_lb_params_change(field);\n#endif\n}\n\n/******************* REQ_BCAST_CUDA_GLOBAL_PART_VARS ********************/\n\nvoid mpi_bcast_cuda_global_part_vars() {\n#ifdef CUDA\n  mpi_call(mpi_bcast_cuda_global_part_vars_slave, 1,\n           0); // third parameter is meaningless\n  mpi_bcast_cuda_global_part_vars_slave(-1, 0);\n#endif\n}\n\nvoid mpi_bcast_cuda_global_part_vars_slave(int node, int dummy) {\n#ifdef CUDA\n  MPI_Bcast(gpu_get_global_particle_vars_pointer_host(),\n            sizeof(CUDA_global_part_vars), MPI_BYTE, 0, comm_cart);\n  espressoSystemInterface.requestParticleStructGpu();\n#endif\n}\n\n/********************* REQ_SET_EXCL ********/\nvoid mpi_send_exclusion(int part1, int part2, int _delete) {\n#ifdef EXCLUSIONS\n  mpi_call(mpi_send_exclusion_slave, part1, part2);\n\n  MPI_Bcast(&_delete, 1, MPI_INT, 0, comm_cart);\n  local_change_exclusion(part1, part2, _delete);\n  on_particle_change();\n#endif\n}\n\nvoid mpi_send_exclusion_slave(int part1, int part2) {\n#ifdef EXCLUSIONS\n  int _delete = 0;\n  MPI_Bcast(&_delete, 1, MPI_INT, 0, comm_cart);\n  local_change_exclusion(part1, part2, _delete);\n  on_particle_change();\n#endif\n}\n\n/************** REQ_SET_FLUID **************/\nvoid mpi_send_fluid(int node, int index, double rho,\n                    const std::array<double, 3> &j,\n                    const std::array<double, 6> &pi) {\n#ifdef LB\n  if (node == this_node) {\n    lb_calc_n_from_rho_j_pi(index, rho, j, pi);\n  } else {\n    double data[10] = {rho,   j[0],  j[1],  j[2],  pi[0],\n                       pi[1], pi[2], pi[3], pi[4], pi[5]};\n    mpi_call(mpi_send_fluid_slave, node, index);\n    MPI_Send(data, 10, MPI_DOUBLE, node, SOME_TAG, comm_cart);\n  }\n#endif\n}\n\nvoid mpi_send_fluid_slave(int node, int index) {\n#ifdef LB\n  if (node == this_node) {\n    double data[10];\n    MPI_Recv(data, 10, MPI_DOUBLE, 0, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    std::array<double, 3> j = {{data[1], data[2], data[3]}};\n    std::array<double, 6> pi = {\n        {data[4], data[5], data[6], data[7], data[8], data[9]}};\n    lb_calc_n_from_rho_j_pi(index, data[0], j, pi);\n  }\n#endif\n}\n\n/************** REQ_GET_FLUID **************/\nvoid mpi_recv_fluid(int node, int index, double *rho, double *j, double *pi) {\n#ifdef LB\n  if (node == this_node) {\n    lb_calc_local_fields(index, rho, j, pi);\n  } else {\n    double data[10];\n    mpi_call(mpi_recv_fluid_slave, node, index);\n    MPI_Recv(data, 10, MPI_DOUBLE, node, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n    *rho = data[0];\n    j[0] = data[1];\n    j[1] = data[2];\n    j[2] = data[3];\n    pi[0] = data[4];\n    pi[1] = data[5];\n    pi[2] = data[6];\n    pi[3] = data[7];\n    pi[4] = data[8];\n    pi[5] = data[9];\n  }\n#endif\n}\n\nvoid mpi_recv_fluid_slave(int node, int index) {\n#ifdef LB\n  if (node == this_node) {\n    double data[10];\n    lb_calc_local_fields(index, &data[0], &data[1], &data[4]);\n    MPI_Send(data, 10, MPI_DOUBLE, 0, SOME_TAG, comm_cart);\n  }\n#endif\n}\n\n/************** REQ_LB_GET_BOUNDARY_FLAG **************/\nvoid mpi_recv_fluid_boundary_flag(int node, int index, int *boundary) {\n#ifdef LB_BOUNDARIES\n  if (node == this_node) {\n    lb_local_fields_get_boundary_flag(index, boundary);\n  } else {\n    int data = 0;\n    mpi_call(mpi_recv_fluid_boundary_flag_slave, node, index);\n    MPI_Recv(&data, 1, MPI_INT, node, SOME_TAG, comm_cart, MPI_STATUS_IGNORE);\n    *boundary = data;\n  }\n#endif\n}\n\nvoid mpi_recv_fluid_boundary_flag_slave(int node, int index) {\n#ifdef LB_BOUNDARIES\n  if (node == this_node) {\n    int data;\n    lb_local_fields_get_boundary_flag(index, &data);\n    MPI_Send(&data, 1, MPI_INT, 0, SOME_TAG, comm_cart);\n  }\n#endif\n}\n\n/********************* REQ_ICCP3M_ITERATION ********/\nint mpi_iccp3m_iteration(int dummy) {\n#ifdef ELECTROSTATICS\n  mpi_call(mpi_iccp3m_iteration_slave, -1, 0);\n\n  iccp3m_iteration();\n\n  COMM_TRACE(fprintf(stderr, \"%d: iccp3m iteration task %d done.\\n\", this_node,\n                     dummy));\n\n  return check_runtime_errors();\n#else\n  return 0;\n#endif\n}\n\nvoid mpi_iccp3m_iteration_slave(int dummy, int dummy2) {\n#ifdef ELECTROSTATICS\n  iccp3m_iteration();\n  COMM_TRACE(\n      fprintf(stderr, \"%d: iccp3m iteration task %d done.\\n\", dummy, dummy2));\n\n  check_runtime_errors();\n#endif\n}\n\n/********************* REQ_ICCP3M_INIT********/\nint mpi_iccp3m_init(int n_induced_charges) {\n#ifdef ELECTROSTATICS\n  /* nothing has to be done on the master node, this\n   * passes only the number of induced charges, in order for\n   * slaves to allocate memory */\n\n  mpi_call(mpi_iccp3m_init_slave, -1, n_induced_charges);\n\n  bcast_iccp3m_cfg();\n\n  COMM_TRACE(fprintf(stderr, \"%d: iccp3m init task %d done.\\n\", this_node,\n                     n_induced_charges));\n\n  return check_runtime_errors();\n#else\n  return 0;\n#endif\n}\n\nvoid mpi_iccp3m_init_slave(int node, int dummy) {\n#ifdef ELECTROSTATICS\n  COMM_TRACE(fprintf(stderr, \"%d: iccp3m iteration task %d done.\\n\", this_node,\n                     dummy));\n\n  if (iccp3m_initialized == 0) {\n    iccp3m_init();\n    iccp3m_initialized = 1;\n  }\n\n  bcast_iccp3m_cfg();\n\n  check_runtime_errors();\n#endif\n}\n\nvoid mpi_recv_fluid_populations(int node, int index, double *pop) {\n#ifdef LB\n  if (node == this_node) {\n    lb_get_populations(index, pop);\n  } else {\n    mpi_call(mpi_recv_fluid_populations_slave, node, index);\n    MPI_Recv(pop, 19 * LB_COMPONENTS, MPI_DOUBLE, node, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n  }\n  lbpar.resend_halo = 1;\n#endif\n}\n\nvoid mpi_recv_fluid_populations_slave(int node, int index) {\n#ifdef LB\n  if (node == this_node) {\n    double data[19 * LB_COMPONENTS];\n    lb_get_populations(index, data);\n    MPI_Send(data, 19 * LB_COMPONENTS, MPI_DOUBLE, 0, SOME_TAG, comm_cart);\n  }\n  lbpar.resend_halo = 1;\n#endif\n}\n\nvoid mpi_send_fluid_populations(int node, int index, double *pop) {\n#ifdef LB\n  if (node == this_node) {\n    lb_set_populations(index, pop);\n  } else {\n    mpi_call(mpi_send_fluid_populations_slave, node, index);\n    MPI_Send(pop, 19 * LB_COMPONENTS, MPI_DOUBLE, node, SOME_TAG, comm_cart);\n  }\n  lbpar.resend_halo = 1;\n#endif\n}\n\nvoid mpi_send_fluid_populations_slave(int node, int index) {\n#ifdef LB\n  if (node == this_node) {\n    double data[19 * LB_COMPONENTS];\n    MPI_Recv(data, 19 * LB_COMPONENTS, MPI_DOUBLE, 0, SOME_TAG, comm_cart,\n             MPI_STATUS_IGNORE);\n    lb_set_populations(index, data);\n  }\n  lbpar.resend_halo = 1;\n#endif\n}\n\n/****************************************************/\n\nvoid mpi_bcast_max_mu() {\n#ifdef DIPOLES\n  mpi_call(mpi_bcast_max_mu_slave, -1, 0);\n\n  calc_mu_max();\n\n#endif\n}\n\nvoid mpi_bcast_max_mu_slave(int node, int dummy) {\n#ifdef DIPOLES\n\n  calc_mu_max();\n\n#endif\n}\n\n#ifdef LANGEVIN_PER_PARTICLE\n\n/******************** REQ_SEND_PARTICLE_T ********************/\nvoid mpi_set_particle_temperature(int pnode, int part, double _T) {\n  mpi_call(mpi_set_particle_temperature_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /* here the setting actually happens, if the particle belongs to the local\n     * node */\n    p->p.T = _T;\n  } else {\n    MPI_Send(&_T, 1, MPI_DOUBLE, pnode, SOME_TAG, comm_cart);\n  }\n\n  on_particle_change();\n}\n#endif\n\nvoid mpi_set_particle_temperature_slave(int pnode, int part) {\n#ifdef LANGEVIN_PER_PARTICLE\n  double s_buf = 0.;\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    MPI_Status status;\n    MPI_Recv(&s_buf, 1, MPI_DOUBLE, 0, SOME_TAG, comm_cart, &status);\n    /* here the setting happens for nonlocal nodes */\n    p->p.T = s_buf;\n  }\n\n  on_particle_change();\n#endif\n}\n\n#ifdef LANGEVIN_PER_PARTICLE\n#ifndef PARTICLE_ANISOTROPY\nvoid mpi_set_particle_gamma(int pnode, int part, double gamma) {\n#else\nvoid mpi_set_particle_gamma(int pnode, int part, Vector3d gamma) {\n#endif\n  mpi_call(mpi_set_particle_gamma_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /* here the setting actually happens, if the particle belongs to the local\n     * node */\n    p->p.gamma = gamma;\n  } else {\n    comm_cart.send(pnode, SOME_TAG, gamma);\n  }\n\n  on_particle_change();\n}\n#endif\n\nvoid mpi_set_particle_gamma_slave(int pnode, int part) {\n#ifdef LANGEVIN_PER_PARTICLE\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    comm_cart.recv(0, SOME_TAG, p->p.gamma);\n  }\n\n  on_particle_change();\n#endif\n}\n\n#if defined(LANGEVIN_PER_PARTICLE) && defined(ROTATION)\n#ifndef PARTICLE_ANISOTROPY\nvoid mpi_set_particle_gamma_rot(int pnode, int part, double gamma_rot)\n#else\nvoid mpi_set_particle_gamma_rot(int pnode, int part, Vector3d gamma_rot)\n#endif\n{\n  mpi_call(mpi_set_particle_gamma_rot_slave, pnode, part);\n\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    /* here the setting actually happens, if the particle belongs to the local\n     * node */\n    p->p.gamma_rot = gamma_rot;\n  } else {\n    comm_cart.send(pnode, SOME_TAG, gamma_rot);\n  }\n\n  on_particle_change();\n}\n#endif\n\nvoid mpi_set_particle_gamma_rot_slave(int pnode, int part) {\n#if defined(LANGEVIN_PER_PARTICLE) && defined(ROTATION)\n  if (pnode == this_node) {\n    Particle *p = local_particles[part];\n    comm_cart.recv(0, SOME_TAG, p->p.gamma_rot);\n  }\n\n  on_particle_change();\n#endif\n}\n\n/***** GALILEI TRANSFORM AND ASSOCIATED FUNCTIONS ****/\n\nvoid mpi_kill_particle_motion(int rotation) {\n  mpi_call(mpi_kill_particle_motion_slave, -1, rotation);\n  local_kill_particle_motion(rotation);\n  on_particle_change();\n}\n\nvoid mpi_kill_particle_motion_slave(int pnode, int rotation) {\n  local_kill_particle_motion(rotation);\n  on_particle_change();\n}\n\nvoid mpi_kill_particle_forces(int torque) {\n  mpi_call(mpi_kill_particle_forces_slave, -1, torque);\n  local_kill_particle_forces(torque);\n  on_particle_change();\n}\n\nvoid mpi_kill_particle_forces_slave(int pnode, int torque) {\n  local_kill_particle_forces(torque);\n  on_particle_change();\n}\n\nvoid mpi_system_CMS() {\n  int pnode;\n  double data[4];\n  double rdata[4];\n  double *pdata = rdata;\n\n  data[0] = 0.0;\n  data[1] = 0.0;\n  data[2] = 0.0;\n  data[3] = 0.0;\n\n  mpi_call(mpi_system_CMS_slave, -1, 0);\n\n  for (pnode = 0; pnode < n_nodes; pnode++) {\n    if (pnode == this_node) {\n      local_system_CMS(pdata);\n      data[0] += rdata[0];\n      data[1] += rdata[1];\n      data[2] += rdata[2];\n      data[3] += rdata[3];\n    } else {\n      MPI_Recv(rdata, 4, MPI_DOUBLE, MPI_ANY_SOURCE, SOME_TAG, comm_cart,\n               MPI_STATUS_IGNORE);\n      data[0] += rdata[0];\n      data[1] += rdata[1];\n      data[2] += rdata[2];\n      data[3] += rdata[3];\n    }\n  }\n\n  gal.cms[0] = data[0] / data[3];\n  gal.cms[1] = data[1] / data[3];\n  gal.cms[2] = data[2] / data[3];\n}\n\nvoid mpi_system_CMS_slave(int node, int index) {\n  double rdata[4];\n  double *pdata = rdata;\n  local_system_CMS(pdata);\n  MPI_Send(rdata, 4, MPI_DOUBLE, 0, SOME_TAG, comm_cart);\n}\n\nvoid mpi_system_CMS_velocity() {\n  int pnode;\n  double data[4];\n  double rdata[4];\n  double *pdata = rdata;\n\n  data[0] = 0.0;\n  data[1] = 0.0;\n  data[2] = 0.0;\n  data[3] = 0.0;\n\n  mpi_call(mpi_system_CMS_velocity_slave, -1, 0);\n\n  for (pnode = 0; pnode < n_nodes; pnode++) {\n    if (pnode == this_node) {\n      local_system_CMS_velocity(pdata);\n      data[0] += rdata[0];\n      data[1] += rdata[1];\n      data[2] += rdata[2];\n      data[3] += rdata[3];\n    } else {\n      MPI_Recv(rdata, 4, MPI_DOUBLE, MPI_ANY_SOURCE, SOME_TAG, comm_cart,\n               MPI_STATUS_IGNORE);\n      data[0] += rdata[0];\n      data[1] += rdata[1];\n      data[2] += rdata[2];\n      data[3] += rdata[3];\n    }\n  }\n\n  gal.cms_vel[0] = data[0] / data[3];\n  gal.cms_vel[1] = data[1] / data[3];\n  gal.cms_vel[2] = data[2] / data[3];\n}\n\nvoid mpi_system_CMS_velocity_slave(int node, int index) {\n  double rdata[4];\n  double *pdata = rdata;\n  local_system_CMS_velocity(pdata);\n  MPI_Send(rdata, 4, MPI_DOUBLE, 0, SOME_TAG, comm_cart);\n}\n\nvoid mpi_galilei_transform() {\n  double cmsvel[3];\n\n  mpi_system_CMS_velocity();\n  memmove(cmsvel, gal.cms_vel, 3 * sizeof(double));\n\n  mpi_call(mpi_galilei_transform_slave, -1, 0);\n  MPI_Bcast(cmsvel, 3, MPI_DOUBLE, 0, comm_cart);\n\n  local_galilei_transform(cmsvel);\n\n  on_particle_change();\n}\n\nvoid mpi_galilei_transform_slave(int pnode, int i) {\n  double cmsvel[3];\n  MPI_Bcast(cmsvel, 3, MPI_DOUBLE, 0, comm_cart);\n\n  local_galilei_transform(cmsvel);\n  on_particle_change();\n}\n\n/******************** REQ_SWIMMER_REACTIONS ********************/\n\nvoid mpi_setup_reaction() {\n#ifdef SWIMMER_REACTIONS\n  mpi_call(mpi_setup_reaction_slave, -1, 0);\n  local_setup_reaction();\n#endif\n}\n\nvoid mpi_setup_reaction_slave(int pnode, int i) {\n#ifdef SWIMMER_REACTIONS\n  local_setup_reaction();\n#endif\n}\n\n/*********************** MAIN LOOP for slaves ****************/\n\nvoid mpi_loop() {\n  if (this_node != 0)\n    mpiCallbacks().loop();\n}\n\n/*********************** error abort ****************/\n\nvoid mpi_abort() {\n  if (terminated)\n    return;\n\n  terminated = 1;\n  MPI_Abort(comm_cart, -1);\n}\n\n/*********************** other stuff ****************/\n\n#ifdef CUDA\nstd::vector<EspressoGpuDevice> mpi_gather_cuda_devices() {\n  mpi_call(mpi_gather_cuda_devices_slave, 0, 0);\n  return cuda_gather_gpus();\n}\n#endif\n\nvoid mpi_gather_cuda_devices_slave(int dummy1, int dummy2) {\n#ifdef CUDA\n  cuda_gather_gpus();\n#endif\n}\n\nstd::vector<int> mpi_resort_particles(int global_flag) {\n  mpi_call(mpi_resort_particles_slave, global_flag, 0);\n  cells_resort_particles(global_flag);\n\n  std::vector<int> n_parts;\n  boost::mpi::gather(comm_cart, cells_get_n_particles(), n_parts, 0);\n\n  return n_parts;\n}\n\nvoid mpi_resort_particles_slave(int global_flag, int) {\n  cells_resort_particles(global_flag);\n\n  boost::mpi::gather(comm_cart, cells_get_n_particles(), 0);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/particles.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/bond_angle.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/dihedral_angle.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/ghost_cells.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/linked_cells.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/dihedral_angle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/elc_errordist.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/datastorage.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/directions.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/move_to_p_buf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/doxygen/figs/ghost_communication.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/salt.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/maggs-initial-scheme.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oif2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/constraint-force_only_positive.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifchannel.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/diamond.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/basepair.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/bending.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/constraint-force.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-spherocylinder.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-cylinder.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifcolored-triangles.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oif3.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oif.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-hollowcone.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-stomatocyte2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/dihedral-angle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/ccmake-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/arealocal.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-ellipsoid.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/hbond.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/elc-errordist.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/nacl-rdf.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-stomatocyte1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-maze.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/constraint-distance.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/stretching.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oif1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/correlator_scheme.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/slitpore.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/volume.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/maggs-rotation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifvectordata.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/correlator_scheme.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/inter_angle.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifrhomboid.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifcylinder.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-wall.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-simplepore.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-sphere.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/maggs-charge-assignment.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/oifstretched-sphere.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/shape-slitpore.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/fullerene.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/slitpore.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/sphinx/figures/analysis_cylindrical_average.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/08-visualization/08-visualization.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/05-raspberry_electrophoresis/figures/raspberry_snapshot.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/05-raspberry_electrophoresis/figures/raspberry_snapshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/02-charged_system/figures/salt.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/02-charged_system/figures/nacl_units_confined.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/02-charged_system/figures/nacl_units.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/02-charged_system/figures/nacl-rdf.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/10-reaction_ensemble.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/alpha_vs_C.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/alpha_vs_C.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/qdistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/titration.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/titration.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/10-reaction_ensemble/figures/qdistrib.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/06-active_matter.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/rectification.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/geometry.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/rectify.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/friction.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/enhanced.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/pusher-puller.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/06-active_matter/FIGURES/flow_field.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/07-electrokinetics/07-electrokinetics.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/07-electrokinetics/figures/profiles.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/07-electrokinetics/figures/latticeboltzmann-grid.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/07-electrokinetics/figures/schlitzpore_3d.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/01-lennard_jones/figures/lennard-jones-potential.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/04-lattice_boltzmann/figures/latticeboltzmann-momentumexchange.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/04-lattice_boltzmann/figures/latticeboltzmann-grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/04-lattice_boltzmann/figures/poiseuille.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/04-lattice_boltzmann/figures/msd.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/09-swimmer_reactions/09-swimmer_reactions.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/09-swimmer_reactions/FIGURES/msd.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/09-swimmer_reactions/FIGURES/avacf.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/09-swimmer_reactions/FIGURES/janus-particle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/tutorials/09-swimmer_reactions/FIGURES/number-conserving.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/wiki-background.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/wiki-header-background.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/header.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/wiki-header-background.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/background.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/background.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/header.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/wiki-background.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/homepage/wiki-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/covers/reynwar07a-cover.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/covers/kosovan10a-cover.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/misc/covers/mann11a-cover.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo_48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/cup.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo_500x500.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo-animated-200.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo_100x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo-small.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/cup-nosteam.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo-animated-500.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo_32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo-small_200x200.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/logo-animated-100.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/transparentbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/square.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/powered_by.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/whitebg.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/doc/logo/old/100px.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-espresso-4.0.0-hsz6dhsdzfkor4unskubysyd7rwvxnbg/spack-src/testsuite/data/coulomb_tuning_system.npz"
    ],
    "total_files": 1316
}