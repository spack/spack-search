{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/src/USER-MOLFILE/molfile_interface.cpp": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------------\n   Contributing author: Axel Kohlmeyer (Temple)\n------------------------------------------------------------------------- */\n\n#include \"molfile_interface.h\"\n\n#include <sys/types.h>\n#include <cstdio>\n#include <dirent.h>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\n#if defined(_WIN32)\n#include <windows.h>\n#else\n#include <dirent.h>\n#include <dlfcn.h>\n#endif\n\n#include \"molfile_plugin.h\"\n\n#if vmdplugin_ABIVERSION < 16\n#error \"unsupported VMD molfile plugin ABI version\"\n#endif\n\n#define DEBUG 0\n\nextern \"C\" {\n  typedef int (*initfunc)(void);\n  typedef int (*regfunc)(void *, vmdplugin_register_cb);\n  typedef int (*finifunc)(void);\n\n  typedef struct {\n    void *p;\n    const char *name;\n  } plugin_reginfo_t;\n\n  // callback function for plugin registration.\n  static int plugin_register_cb(void *v, vmdplugin_t *p)\n  {\n    plugin_reginfo_t *r = static_cast<plugin_reginfo_t *>(v);\n    // make sure we have the proper plugin type (native reader)\n    // for the desired file type (called \"name\" at this level)\n    if ((strcmp(MOLFILE_PLUGIN_TYPE,p->type) == 0)\n        && (strcmp(r->name, p->name) == 0) ) {\n      r->p = static_cast<void *>(p);\n    }\n    return 0;\n  }\n\n  /* periodic table of elements for translation of ordinal to atom type */\n  static const char *pte_label[] = {\n    \"X\",  \"H\",  \"He\", \"Li\", \"Be\", \"B\",  \"C\",  \"N\",  \"O\",  \"F\",  \"Ne\",\n    \"Na\", \"Mg\", \"Al\", \"Si\", \"P\" , \"S\",  \"Cl\", \"Ar\", \"K\",  \"Ca\", \"Sc\",\n    \"Ti\", \"V\",  \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\",\n    \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\",  \"Zr\", \"Nb\", \"Mo\", \"Tc\",\n    \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\",  \"Xe\",\n    \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\",\n    \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\",  \"Re\", \"Os\",\n    \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\",\n    \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\",  \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\",\n    \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\",\n    \"Ds\", \"Rg\"\n  };\n  static const int nr_pte_entries = sizeof(pte_label) / sizeof(char *);\n\n  /* corresponding table of masses. */\n  static const float pte_mass[] = {\n    /* X  */ 0.00000, 1.00794, 4.00260, 6.941, 9.012182, 10.811,\n    /* C  */ 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,\n    /* Na */ 22.989770, 24.3050, 26.981538, 28.0855, 30.973761,\n    /* S  */ 32.065, 35.453, 39.948, 39.0983, 40.078, 44.955910,\n    /* Ti */ 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.9332,\n    /* Ni */ 58.6934, 63.546, 65.409, 69.723, 72.64, 74.92160,\n    /* Se */ 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585,\n    /* Zr */ 91.224, 92.90638, 95.94, 98.0, 101.07, 102.90550,\n    /* Pd */ 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760,\n    /* Te */ 127.60, 126.90447, 131.293, 132.90545, 137.327,\n    /* La */ 138.9055, 140.116, 140.90765, 144.24, 145.0, 150.36,\n    /* Eu */ 151.964, 157.25, 158.92534, 162.500, 164.93032,\n    /* Er */ 167.259, 168.93421, 173.04, 174.967, 178.49, 180.9479,\n    /* W  */ 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655,\n    /* Hg */ 200.59, 204.3833, 207.2, 208.98038, 209.0, 210.0, 222.0,\n    /* Fr */ 223.0, 226.0, 227.0, 232.0381, 231.03588, 238.02891,\n    /* Np */ 237.0, 244.0, 243.0, 247.0, 247.0, 251.0, 252.0, 257.0,\n    /* Md */ 258.0, 259.0, 262.0, 261.0, 262.0, 266.0, 264.0, 269.0,\n    /* Mt */ 268.0, 271.0, 272.0\n  };\n\n  /*\n   * corresponding table of VDW radii.\n   * van der Waals radii are taken from A. Bondi,\n   * J. Phys. Chem., 68, 441 - 452, 1964,\n   * except the value for H, which is taken from R.S. Rowland & R. Taylor,\n   * J.Phys.Chem., 100, 7384 - 7391, 1996. Radii that are not available in\n   * either of these publications have RvdW = 2.00 \\AA.\n   * The radii for Ions (Na, K, Cl, Ca, Mg, and Cs are based on the CHARMM27\n   * Rmin/2 parameters for (SOD, POT, CLA, CAL, MG, CES) by default.\n   */\n  static const float pte_vdw_radius[] = {\n    /* X  */ 1.5, 1.2, 1.4, 1.82, 2.0, 2.0,\n    /* C  */ 1.7, 1.55, 1.52, 1.47, 1.54,\n    /* Na */ 1.36, 1.18, 2.0, 2.1, 1.8,\n    /* S  */ 1.8, 2.27, 1.88, 1.76, 1.37, 2.0,\n    /* Ti */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Ni */ 1.63, 1.4, 1.39, 1.07, 2.0, 1.85,\n    /* Se */ 1.9, 1.85, 2.02, 2.0, 2.0, 2.0,\n    /* Zr */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Pd */ 1.63, 1.72, 1.58, 1.93, 2.17, 2.0,\n    /* Te */ 2.06, 1.98, 2.16, 2.1, 2.0,\n    /* La */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Eu */ 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Er */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* W  */ 2.0, 2.0, 2.0, 2.0, 1.72, 1.66,\n    /* Hg */ 1.55, 1.96, 2.02, 2.0, 2.0, 2.0, 2.0,\n    /* Fr */ 2.0, 2.0, 2.0, 2.0, 2.0, 1.86,\n    /* Np */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Md */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Mt */ 2.0, 2.0, 2.0\n  };\n\n  /* lookup functions */\n\n  static const char *get_pte_label(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_label[0];\n\n    return pte_label[idx];\n  }\n\n  static float get_pte_mass(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_mass[0];\n\n    return pte_mass[idx];\n  }\n\n  static float get_pte_vdw_radius(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_vdw_radius[0];\n\n#if 1\n    /* Replace with Hydrogen radius with an \"all-atom\" radius */\n    if (idx == 1)\n      return 1.0;    /* H  */\n#else\n    /* Replace with old VMD atom radii values */\n    switch (idx) {\n    case  1: return 1.0;    /* H  */\n    case  6: return 1.5;    /* C  */\n    case  7: return 1.4;    /* N  */\n    case  8: return 1.3;    /* O  */\n    case  9: return 1.2;    /* F  */\n    case 15: return 1.5;    /* P  */\n    case 16: return 1.9;    /* S  */\n    }\n#endif\n\n    return pte_vdw_radius[idx];\n  }\n\n  static int get_pte_idx_from_string(const char *label) {\n    int i, ind;\n    char atom[3];\n\n    if (label != NULL) {\n      /* zap string */\n      atom[0] = atom[1] = atom[2] = '\\0';\n\n      for (ind=0,i=0; (ind<2) && (label[i]!='\\0'); i++) {\n        if (label[i] != ' ') {\n          atom[ind] = toupper(label[i]);\n          ind++;\n        }\n      }\n\n      if (ind < 1)\n        return 0; /* no non-whitespace characters */\n\n      for (i=0; i < nr_pte_entries; ++i) {\n        if ((toupper(pte_label[i][0]) == atom[0]) && (toupper(pte_label[i][1]) == atom[1]))\n          return i;\n      }\n    }\n\n    return 0;\n  }\n\n  // directory traversal helper functions\n\n#if defined(_WIN32)\n\n  // Win32 directory traversal handle\n  typedef struct {\n    HANDLE h;\n    WIN32_FIND_DATA fd;\n    char *name;\n    char *searchname;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == NULL)\n      return NULL;\n    d = new dirhandle_t;\n\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name, dirname);\n    strcat(d->name, \"\\\\\");\n    d->dlen = len;\n\n    len += 1;\n    d->searchname = new char[len];\n    strcpy(d->searchname, dirname);\n    strcat(d->searchname, \"\\\\*\");\n\n    d->h = FindFirstFile(d->searchname, &(d->fd));\n    if (d->h == ((HANDLE)(-1))) {\n      delete[] d->searchname;\n      delete[] d->name;\n      delete d;\n      return NULL;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    if (FindNextFile(d->h, &(d->fd))) {\n      return d->fd.cFileName;\n    }\n    return NULL;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->h != NULL) {\n      FindClose(d->h);\n    }\n    delete[] d->searchname;\n    delete[] d->name;\n    delete d;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return (void *)LoadLibrary(fname);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return (void *)GetProcAddress((HINSTANCE)h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    /* FreeLibrary returns nonzero on success */\n    return !FreeLibrary((HINSTANCE)h);\n  }\n\n#else\n\n  // Unix directory traversal handle\n  typedef struct {\n    DIR *d;\n    char *name;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == NULL) return NULL;\n\n    d = new dirhandle_t;\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name,dirname);\n    strcat(d->name,\"/\");\n    d->dlen = len;\n\n    d->d = opendir(d->name);\n    if (d->d == NULL) {\n      delete[] d->name;\n      delete d;\n      return NULL;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    struct dirent *p;\n\n    if ((p = readdir(d->d)) != NULL) {\n      return p->d_name;\n    }\n\n    return NULL;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->d != NULL) {\n      closedir(d->d);\n    }\n    delete[] d->name;\n    delete d;\n    return;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return dlopen(fname, RTLD_NOW);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return dlsym(h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    return dlclose(h);\n  }\n\n#endif\n\n} // end of extern \"C\" region\n\nusing namespace LAMMPS_NS;\n\n// constructor.\nMolfileInterface::MolfileInterface(const char *type, const int mode)\n  : _plugin(0), _dso(0), _ptr(0), _info(0), _natoms(0),\n    _mode(mode), _caps(M_NONE)\n{\n  _name = new char[5];\n  strcpy(_name,\"none\");\n  _type = new char[1+strlen(type)];\n  strcpy(_type,type);\n}\n\n// destructor.\nMolfileInterface::~MolfileInterface()\n{\n  forget_plugin();\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = NULL;\n  }\n  delete[] _name;\n  delete[] _type;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::find_plugin(const char *pluginpath)\n{\n  dirhandle_t *dir;\n  char *filename, *ext, *next, *path, *plugindir;\n  int retval = E_NONE;\n\n#if defined(_WIN32)\n#define MY_PATHSEP ';'\n#else\n#define MY_PATHSEP ':'\n#endif\n  if (pluginpath == NULL) return E_DIR;\n  plugindir = path = strdup(pluginpath);\n\n  while (plugindir) {\n    // check if this a single directory or path.\n    next = strchr(plugindir,MY_PATHSEP);\n    if (next) {\n      *next = '\\0';\n      ++next;\n    }\n\n    dir = my_opendir(plugindir);\n    if (!dir)\n      retval = (retval > E_DIR) ? retval : E_DIR;\n\n    // search for suitable file names and try to inspect them\n    while(dir) {\n      char *fullname;\n      int len;\n\n      filename = my_readdir(dir);\n      if (filename == NULL) break;\n\n      // only look at .so files\n      ext = strrchr(filename, '.');\n      if (ext == NULL) continue;\n      if (strcasecmp(ext,\".so\") != 0) continue;\n\n      // construct full pathname of potential DSO\n      len = dir->dlen;\n      len += strlen(filename);\n      fullname = new char[len];\n      strcpy(fullname,dir->name);\n      strcat(fullname,filename);\n\n      // try to register plugin at file name.\n      int rv = load_plugin(fullname);\n      if (rv > retval) retval = rv;\n\n      delete[] fullname;\n    }\n    if (dir)\n      my_closedir(dir);\n\n    plugindir = next;\n  }\n  free(path);\n  return retval;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::load_plugin(const char *filename)\n{\n  void *dso;\n  int len, retval = E_NONE;\n\n  // access shared object\n  dso = my_dlopen(filename);\n  if (dso == NULL)\n    return E_FILE;\n\n  // check for required plugin symbols\n  void *ifunc = my_dlsym(dso,\"vmdplugin_init\");\n  void *rfunc = my_dlsym(dso,\"vmdplugin_register\");\n  void *ffunc = my_dlsym(dso,\"vmdplugin_fini\");\n  if (ifunc == NULL || rfunc == NULL || ffunc == NULL) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // initialize plugin. skip plugin if it fails.\n  if (((initfunc)(ifunc))()) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // pre-register plugin.\n  // the callback will be called for each plugin in the DSO and\n  // check the file type. plugin->name will change if successful.\n  plugin_reginfo_t reginfo;\n  reginfo.p = NULL;\n  reginfo.name=_type;\n  ((regfunc)rfunc)(&reginfo, plugin_register_cb);\n\n  // make some checks to see if the plugin is suitable or not.\n  molfile_plugin_t *plugin = static_cast<molfile_plugin_t *>(reginfo.p);\n\n  // if the callback found a matching plugin and copied the struct,\n  // its name element will point to a different location now.\n  if (plugin == NULL) {\n    retval = E_TYPE;\n\n    // check if the ABI matches the one used to compile this code\n  } else if (plugin->abiversion != vmdplugin_ABIVERSION) {\n    retval = E_ABI;\n\n    // check if (basic) reading is supported\n  } else if ((_mode & M_READ) &&\n             ( (plugin->open_file_read == NULL) ||\n               (plugin->read_next_timestep  == NULL) ||\n               (plugin->close_file_read == NULL) )) {\n    retval = E_MODE;\n\n    // check if (basic) writing is supported\n  } else if ( (_mode & M_WRITE) &&\n              ( (plugin->open_file_write == NULL) ||\n                (plugin->write_timestep  == NULL) ||\n                (plugin->close_file_write == NULL) )) {\n    retval = E_MODE;\n\n    // make some additional check, if we\n    // already have a plugin registered.\n    // NOTE: this has to come last.\n  } else if (_dso && _plugin) {\n    molfile_plugin_t *p;\n    p = static_cast<molfile_plugin_t *>(_plugin);\n\n    // check if the new plugin is of a newer major version\n    if (p->majorv > plugin->majorv) {\n      retval = E_VERSION;\n\n    // check if the new plugin is of a newer minor version\n    } else if ( (p->majorv == plugin->majorv) &&\n                (p->minorv >= plugin->minorv) ) {\n      retval = E_VERSION;\n    }\n  }\n\n  // bingo! this one is a keeper.\n  if (retval == E_NONE) {\n\n    // make sure any existing plugin is wiped out\n    forget_plugin();\n\n    delete[] _name;\n    len = 16;\n    len += strlen(plugin->prettyname);\n    len += strlen(plugin->author);\n    _name = new char[len];\n    sprintf(_name,\"%s v%d.%d by %s\",plugin->prettyname,\n            plugin->majorv, plugin->minorv, plugin->author);\n\n    // determine plugin capabilities\n    _caps = M_NONE;\n    if (plugin->read_next_timestep)      _caps |= M_READ;\n    if (plugin->write_timestep)          _caps |= M_WRITE;\n#if vmdplugin_ABIVERSION > 10\n    // required to tell if velocities are present\n    if (plugin->read_timestep_metadata)  _caps |= M_RVELS;\n    // we can always offer velocities. we may not know if\n    // they will be written by the plugin though.\n    if (plugin->write_timestep)          _caps |= M_WVELS;\n#endif\n    if (plugin->read_structure)          _caps |= M_RSTRUCT;\n    if (plugin->write_structure)         _caps |= M_WSTRUCT;\n    if (plugin->read_bonds)              _caps |= M_RBONDS;\n    if (plugin->write_bonds)             _caps |= M_WBONDS;\n    if (plugin->read_angles)             _caps |= M_RANGLES;\n    if (plugin->write_angles)            _caps |= M_WANGLES;\n    if (plugin->read_volumetric_data)    _caps |= M_RVOL;\n    if (plugin->write_volumetric_data)   _caps |= M_WVOL;\n\n    if (_mode & M_WRITE) {\n      _mode |= (_caps & M_WSTRUCT);\n      _mode |= (_caps & M_WVELS);\n    } else if (_mode & M_READ) {\n      _mode |= (_caps & M_RSTRUCT);\n      _mode |= (_caps & M_RVELS);\n    }\n\n    _plugin = plugin;\n    _dso = dso;\n    return E_MATCH;\n  }\n\n  // better luck next time. clean up and return.\n  my_dlclose(dso);\n  return retval;\n}\n\n// deregister a plugin and close or reset all associated objects.\nvoid MolfileInterface::forget_plugin()\n{\n  if (_ptr)\n    close();\n\n  if (_plugin)\n    _plugin = NULL;\n\n  if (_dso) {\n    void *ffunc = my_dlsym(_dso,\"vmdplugin_fini\");\n    if (ffunc)\n      ((finifunc)ffunc)();\n    my_dlclose(_dso);\n  }\n  _dso = NULL;\n\n  delete[] _name;\n    _name = new char[5];\n  strcpy(_name,\"none\");\n\n  _caps = M_NONE;\n}\n\n// open file for reading or writing\nint MolfileInterface::open(const char *name, int *natoms)\n{\n  if (!_plugin || !_dso || !natoms)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE)\n    _ptr = p->open_file_write(name,_type,*natoms);\n  else if (_mode & M_READ)\n    _ptr = p->open_file_read(name,_type,natoms);\n\n  if (_ptr == NULL)\n    return E_FILE;\n\n  _natoms = *natoms;\n  // we need to deal with structure information,\n  // so we allocate and initialize storage for it.\n  if (_mode & (M_RSTRUCT|M_WSTRUCT)) {\n    molfile_atom_t *a = new molfile_atom_t[_natoms];\n    _info = a;\n    memset(_info,0,_natoms*sizeof(molfile_atom_t));\n    for (int i=0; i < _natoms; ++i) {\n      a[i].name[0] = 'X';\n      a[i].type[0] = a[i].resname[0] = a[i].segid[0] = 'U';\n      a[i].type[1] = a[i].resname[1] = a[i].segid[1] = 'N';\n      a[i].type[2] = a[i].resname[2] = a[i].segid[2] = 'K';\n      a[i].chain[0] = 'X';\n    }\n  }\n  return E_NONE;\n}\n\n// get of set atom structure information\nint MolfileInterface::structure()\n{\n  if (!_plugin || !_dso)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  int optflags = MOLFILE_NOOPTIONS;\n\n  if (_mode & M_WSTRUCT) {\n    optflags |= (_props & P_BFAC) ? MOLFILE_BFACTOR : 0;\n    optflags |= (_props & P_OCCP) ? MOLFILE_OCCUPANCY : 0;\n    optflags |= (_props & P_MASS) ? MOLFILE_MASS : 0;\n    optflags |= (_props & P_CHRG) ? MOLFILE_CHARGE : 0;\n    optflags |= (_props & P_RADS) ? MOLFILE_RADIUS : 0;\n    optflags |= (_props & P_ATMN) ? MOLFILE_ATOMICNUMBER : 0;\n\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->write_structure(_ptr,optflags,a);\n  } else if (_mode & M_RSTRUCT) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->read_structure(_ptr,&optflags,a);\n    // mandatory properties\n    _props = P_NAME|P_TYPE|P_RESN|P_RESI|P_SEGN|P_CHAI;\n    // optional properties\n    _props |= (optflags & MOLFILE_BFACTOR) ? P_BFAC : 0;\n    _props |= (optflags & MOLFILE_OCCUPANCY) ? P_OCCP : 0;\n    _props |= (optflags & MOLFILE_MASS) ? P_MASS : 0;\n    _props |= (optflags & MOLFILE_CHARGE) ? P_CHRG : 0;\n    _props |= (optflags & MOLFILE_RADIUS) ? P_RADS : 0;\n    _props |= (optflags & MOLFILE_ATOMICNUMBER) ? P_ATMN : 0;\n  }\n  return 0;\n}\n\n// safely close file\nint MolfileInterface::close()\n{\n  if (!_plugin || !_dso || !_ptr)\n    return E_FILE;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE) {\n    p->close_file_write(_ptr);\n  } else if (_mode & M_READ) {\n    p->close_file_read(_ptr);\n  }\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = NULL;\n  }\n  _ptr = NULL;\n  _natoms = 0;\n\n  return E_NONE;\n}\n\n\n// read or write timestep\nint MolfileInterface::timestep(float *coords, float *vels,\n                               float *cell, double *simtime)\n{\n  if (!_plugin || !_dso || !_ptr)\n    return 1;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n  molfile_timestep_t *t = new molfile_timestep_t;\n  int rv;\n\n  if (_mode & M_WRITE) {\n    t->coords = coords;\n    t->velocities = vels;\n    if (cell != NULL) {\n      t->A = cell[0];\n      t->B = cell[1];\n      t->C = cell[2];\n      t->alpha = cell[3];\n      t->beta = cell[4];\n      t->gamma = cell[5];\n    } else {\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n    }\n\n    if (simtime)\n      t->physical_time = *simtime;\n    else\n      t->physical_time = 0.0;\n\n    rv = p->write_timestep(_ptr,t);\n\n  } else {\n    // no coordinate storage => skip step\n    if (coords == NULL) {\n      rv = p->read_next_timestep(_ptr, _natoms, NULL);\n    } else {\n      t->coords = coords;\n      t->velocities = vels;\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n      t->physical_time = 0.0;\n      rv = p->read_next_timestep(_ptr, _natoms, t);\n      if (cell != NULL) {\n        cell[0] = t->A;\n        cell[1] = t->B;\n        cell[2] = t->C;\n        cell[3] = t->alpha;\n        cell[4] = t->beta;\n        cell[5] = t->gamma;\n      }\n      if (simtime)\n        *simtime = t->physical_time;\n    }\n\n    if (rv == MOLFILE_EOF) {\n      delete t;\n      return 1;\n    }\n  }\n\n  delete t;\n  return 0;\n}\n\n// functions to read properties from molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { VAL = a.ENTRY; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { strcpy(VAL,a.ENTRY); }\n\n// single precision floating point props\nstatic float read_float_property(molfile_atom_t &a, const int propid)\n{\n  float prop = 0.0f;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_RADS),\n             atomicnumber,iprop);\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & MolfileInterface::P_MASS)\n      prop = get_pte_mass(iprop);\n    if (propid & MolfileInterface::P_RADS)\n      prop = get_pte_vdw_radius(iprop);\n  }\n\n  return prop;\n}\n\n// integer and derived props\nstatic int read_int_property(molfile_atom_t &a, const int propid)\n{\n  int prop = 0;\n  const char * sprop;\n\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,sprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,sprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_idx_from_string(sprop);\n  }\n\n  return prop;\n}\n\n// string and derived props\nstatic const char *read_string_property(molfile_atom_t &a,\n                                        const int propid)\n{\n  const char *prop = NULL;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_NAME,name,prop);\n  PROPUPDATE(MolfileInterface::P_TYPE,type,prop);\n  PROPUPDATE(MolfileInterface::P_RESN,resname,prop);\n  PROPUPDATE(MolfileInterface::P_SEGN,segid,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             atomicnumber,iprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_label(iprop);\n  }\n\n  return prop;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// functions to store properties into molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)                                  \\\n  if ((propid & PROP) == PROP) { a.ENTRY = VAL; plist |= PROP; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)                                      \\\n  if ((propid & PROP) == PROP) { strcpy(a.ENTRY,VAL); plist |= PROP; }\n\n// floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const float prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n  return plist;\n}\n\n// double precision floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const double prop)\n{\n  return write_atom_property(a,propid,static_cast<float>(prop));\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const int prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             mass,get_pte_mass(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,get_pte_label(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,get_pte_label(prop));\n  return plist;\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const char *prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPSTRCPY(MolfileInterface::P_NAME,name,prop);\n  PROPSTRCPY(MolfileInterface::P_TYPE,type,prop);\n  PROPSTRCPY(MolfileInterface::P_RESN,resname,prop);\n  PROPSTRCPY(MolfileInterface::P_SEGN,segid,prop);\n  return plist;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, float *prop)\n{\n  if ((_info == NULL) || (prop == NULL) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_float_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, float *prop)\n{\n  if ((_info == NULL) || (types == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading.\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, float *prop)\n{\n  if ((_info == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_float_property(a[i], propid);\n  }\n\n  return _props;\n}\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, double *prop)\n{\n  if ((_info == NULL) || (prop == NULL) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    return write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = static_cast<double>(read_float_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, double *prop)\n{\n  if ((_info == NULL) || (types == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, double *prop)\n{\n  if ((_info == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = static_cast<double>(read_float_property(a[i], propid));\n  }\n\n  return _props;\n}\n\n#define INT_TO_STRING_BODY(IDX)                         \\\n  buf[15] = 0;                                          \\\n  if (propid & P_NAME)                                  \\\n    _props |= write_atom_property(a[IDX],P_NAME,buf);   \\\n  if (propid & P_TYPE)                                  \\\n    _props |= write_atom_property(a[IDX],P_TYPE,buf);   \\\n  buf[7] = 0;                                           \\\n  if (propid & P_RESN)                                  \\\n    _props |= write_atom_property(a[IDX],P_RESN,buf);   \\\n  if (propid & P_SEGN)                                  \\\n    _props |= write_atom_property(a[IDX],P_SEGN,buf);   \\\n  buf[1] = 0;                                           \\\n  if (propid & P_CHAI)                                  \\\n    _props |= write_atom_property(a[IDX],P_CHAI,buf)\n\n// set/get atom integer property\nint MolfileInterface::property(int propid, int idx, int *prop)\n{\n  if ((_info == NULL) || (prop == NULL) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      sprintf(buf,\"%d\",*prop);\n      INT_TO_STRING_BODY(idx);\n    }\n  }\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_int_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type integer property\nint MolfileInterface::property(int propid, int *types, int *prop)\n{\n  if ((_info == NULL) || (types == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[types[i]]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom integer property\nint MolfileInterface::property(int propid, int *prop)\n{\n  if ((_info == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i],propid,prop[i]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[i]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_int_property(a[i], propid);\n  }\n\n  return _props;\n}\n#undef INT_TO_STRING_BODY\n\n// set/get atom string property\nint MolfileInterface::property(int propid, int idx, char *prop)\n{\n  if ((_info == NULL) || (prop == NULL) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    _props |= write_atom_property(a[idx], propid, prop);\n  }\n\n  if (_mode & M_RSTRUCT)\n    strcpy(prop,read_string_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type string property\nint MolfileInterface::property(int propid, int *types, char **prop)\n{\n  if ((_info == NULL) || (types == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom string property\nint MolfileInterface::property(int propid, char **prop)\n{\n  if ((_info == NULL) || (prop == NULL))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[i]);\n    }\n  }\n\n  // not supported right now. XXX: should we use strdup() here?\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/lib/kokkos/core/src/impl/Kokkos_Profiling_Interface.cpp": "/*\n //@HEADER\n // ************************************************************************\n //\n //                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n //\n // Under the terms of Contract DE-NA0003525 with NTESS,\n // the U.S. Government retains certain rights in this software.\n //\n // Redistribution and use in source and binary forms, with or without\n // modification, are permitted provided that the following conditions are\n // met:\n //\n // 1. Redistributions of source code must retain the above copyright\n // notice, this list of conditions and the following disclaimer.\n //\n // 2. Redistributions in binary form must reproduce the above copyright\n // notice, this list of conditions and the following disclaimer in the\n // documentation and/or other materials provided with the distribution.\n //\n // 3. Neither the name of the Corporation nor the names of the\n // contributors may be used to endorse or promote products derived from\n // this software without specific prior written permission.\n //\n // THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n //\n // Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n //\n // ************************************************************************\n //@HEADER\n */\n\n#include <Kokkos_Macros.hpp>\n\n#if defined(KOKKOS_ENABLE_PROFILING)\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n#include <cstring>\n\nnamespace Kokkos {\nnamespace Profiling {\n\nstatic initFunction initProfileLibrary         = nullptr;\nstatic finalizeFunction finalizeProfileLibrary = nullptr;\n\nstatic beginFunction beginForCallee    = nullptr;\nstatic beginFunction beginScanCallee   = nullptr;\nstatic beginFunction beginReduceCallee = nullptr;\nstatic endFunction endForCallee        = nullptr;\nstatic endFunction endScanCallee       = nullptr;\nstatic endFunction endReduceCallee     = nullptr;\n\nstatic pushFunction pushRegionCallee = nullptr;\nstatic popFunction popRegionCallee   = nullptr;\n\nstatic allocateDataFunction allocateDataCallee     = nullptr;\nstatic deallocateDataFunction deallocateDataCallee = nullptr;\n\nstatic beginDeepCopyFunction beginDeepCopyCallee = nullptr;\nstatic endDeepCopyFunction endDeepCopyCallee     = nullptr;\n\nstatic createProfileSectionFunction createSectionCallee   = nullptr;\nstatic startProfileSectionFunction startSectionCallee     = nullptr;\nstatic stopProfileSectionFunction stopSectionCallee       = nullptr;\nstatic destroyProfileSectionFunction destroySectionCallee = nullptr;\n\nstatic profileEventFunction profileEventCallee = nullptr;\n\nSpaceHandle::SpaceHandle(const char* space_name) {\n  strncpy(name, space_name, 64);\n}\n\nbool profileLibraryLoaded() { return (nullptr != initProfileLibrary); }\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  if (nullptr != beginForCallee) {\n    Kokkos::fence();\n    (*beginForCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if (nullptr != endForCallee) {\n    Kokkos::fence();\n    (*endForCallee)(kernelID);\n  }\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  if (nullptr != beginScanCallee) {\n    Kokkos::fence();\n    (*beginScanCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if (nullptr != endScanCallee) {\n    Kokkos::fence();\n    (*endScanCallee)(kernelID);\n  }\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  if (nullptr != beginReduceCallee) {\n    Kokkos::fence();\n    (*beginReduceCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if (nullptr != endReduceCallee) {\n    Kokkos::fence();\n    (*endReduceCallee)(kernelID);\n  }\n}\n\nvoid pushRegion(const std::string& kName) {\n  if (nullptr != pushRegionCallee) {\n    Kokkos::fence();\n    (*pushRegionCallee)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if (nullptr != popRegionCallee) {\n    Kokkos::fence();\n    (*popRegionCallee)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label,\n                  const void* ptr, const uint64_t size) {\n  if (nullptr != allocateDataCallee) {\n    (*allocateDataCallee)(space, label.c_str(), ptr, size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  if (nullptr != deallocateDataCallee) {\n    (*deallocateDataCallee)(space, label.c_str(), ptr, size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  if (nullptr != beginDeepCopyCallee) {\n    (*beginDeepCopyCallee)(dst_space, dst_label.c_str(), dst_ptr, src_space,\n                           src_label.c_str(), src_ptr, size);\n  }\n}\n\nvoid endDeepCopy() {\n  if (nullptr != endDeepCopyCallee) {\n    (*endDeepCopyCallee)();\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  if (nullptr != createSectionCallee) {\n    (*createSectionCallee)(sectionName.c_str(), secID);\n  }\n}\n\nvoid startSection(const uint32_t secID) {\n  if (nullptr != startSectionCallee) {\n    (*startSectionCallee)(secID);\n  }\n}\n\nvoid stopSection(const uint32_t secID) {\n  if (nullptr != stopSectionCallee) {\n    (*stopSectionCallee)(secID);\n  }\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n  if (nullptr != destroySectionCallee) {\n    (*destroySectionCallee)(secID);\n  }\n}\n\nvoid markEvent(const std::string& eventName) {\n  if (nullptr != profileEventCallee) {\n    (*profileEventCallee)(eventName.c_str());\n  }\n}\n\nvoid initialize() {\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if (is_initialized) return;\n  is_initialized = 1;\n\n  void* firstProfileLibrary;\n\n  char* envProfileLibrary = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if (nullptr == envProfileLibrary) {\n    return;\n  }\n\n  char* envProfileCopy =\n      (char*)malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if ((nullptr != profileLibraryName) &&\n      (strcmp(profileLibraryName, \"\") != 0)) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if (nullptr == firstProfileLibrary) {\n      std::cerr << \"Error: Unable to load KokkosP library: \"\n                << profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName\n                << \", RTLD_NOW | RTLD_GLOBAL) failed with \" << dlerror()\n                << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName\n                << std::endl;\n#endif\n\n      // dlsym returns a pointer to an object, while we want to assign to\n      // pointer to function A direct cast will give warnings hence, we have to\n      // workaround the issue by casting pointer to pointers.\n      auto p1        = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      beginForCallee = *((beginFunction*)&p1);\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      beginScanCallee = *((beginFunction*)&p2);\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      beginReduceCallee = *((beginFunction*)&p3);\n\n      auto p4       = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      endScanCallee = *((endFunction*)&p4);\n      auto p5       = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      endForCallee  = *((endFunction*)&p5);\n      auto p6       = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      endReduceCallee = *((endFunction*)&p6);\n\n      auto p7            = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      initProfileLibrary = *((initFunction*)&p7);\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      finalizeProfileLibrary = *((finalizeFunction*)&p8);\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      pushRegionCallee = *((pushFunction*)&p9);\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      popRegionCallee = *((popFunction*)&p10);\n\n      auto p11           = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      allocateDataCallee = *((allocateDataFunction*)&p11);\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      deallocateDataCallee = *((deallocateDataFunction*)&p12);\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      beginDeepCopyCallee = *((beginDeepCopyFunction*)&p13);\n      auto p14            = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      endDeepCopyCallee   = *((endDeepCopyFunction*)&p14);\n\n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      createSectionCallee = *((createProfileSectionFunction*)&p15);\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      startSectionCallee = *((startProfileSectionFunction*)&p16);\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      stopSectionCallee = *((stopProfileSectionFunction*)&p17);\n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      destroySectionCallee = *((destroyProfileSectionFunction*)&p18);\n\n      auto p19           = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      profileEventCallee = *((profileEventFunction*)&p19);\n    }\n  }\n\n  if (nullptr != initProfileLibrary) {\n    (*initProfileLibrary)(0, (uint64_t)KOKKOSP_INTERFACE_VERSION, (uint32_t)0,\n                          nullptr);\n  }\n\n  free(envProfileCopy);\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if (is_finalized) return;\n  is_finalized = 1;\n\n  if (nullptr != finalizeProfileLibrary) {\n    (*finalizeProfileLibrary)();\n\n    // Set all profile hooks to nullptr to prevent\n    // any additional calls. Once we are told to\n    // finalize, we mean it\n    initProfileLibrary     = nullptr;\n    finalizeProfileLibrary = nullptr;\n\n    beginForCallee    = nullptr;\n    beginScanCallee   = nullptr;\n    beginReduceCallee = nullptr;\n    endScanCallee     = nullptr;\n    endForCallee      = nullptr;\n    endReduceCallee   = nullptr;\n\n    pushRegionCallee = nullptr;\n    popRegionCallee  = nullptr;\n\n    allocateDataCallee   = nullptr;\n    deallocateDataCallee = nullptr;\n\n    beginDeepCopyCallee = nullptr;\n    endDeepCopyCallee   = nullptr;\n\n    createSectionCallee  = nullptr;\n    startSectionCallee   = nullptr;\n    stopSectionCallee    = nullptr;\n    destroySectionCallee = nullptr;\n\n    profileEventCallee = nullptr;\n  }\n}\n}  // namespace Profiling\n}  // namespace Kokkos\n\n#else\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n#include <cstring>\n\nnamespace Kokkos {\nnamespace Profiling {\n\nbool profileLibraryLoaded() { return false; }\n\nvoid beginParallelFor(const std::string&, const uint32_t, uint64_t*) {}\nvoid endParallelFor(const uint64_t) {}\nvoid beginParallelScan(const std::string&, const uint32_t, uint64_t*) {}\nvoid endParallelScan(const uint64_t) {}\nvoid beginParallelReduce(const std::string&, const uint32_t, uint64_t*) {}\nvoid endParallelReduce(const uint64_t) {}\n\nvoid pushRegion(const std::string&) {}\nvoid popRegion() {}\nvoid createProfileSection(const std::string&, uint32_t*) {}\nvoid startSection(const uint32_t) {}\nvoid stopSection(const uint32_t) {}\nvoid destroyProfileSection(const uint32_t) {}\n\nvoid markEvent(const std::string&) {}\n\nvoid allocateData(const SpaceHandle, const std::string, const void*,\n                  const uint64_t) {}\nvoid deallocateData(const SpaceHandle, const std::string, const void*,\n                    const uint64_t) {}\n\nvoid beginDeepCopy(const SpaceHandle, const std::string, const void*,\n                   const SpaceHandle, const std::string, const void*,\n                   const uint64_t) {}\nvoid endDeepCopy() {}\n\nvoid initialize() {}\nvoid finalize() {}\n\n}  // namespace Profiling\n}  // namespace Kokkos\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/lib/molfile/Makefile.lammps": "# This file contains the hooks to build and link LAMMPS with the VMD\n# molfile plugins described here:\n# \n# http://www.ks.uiuc.edu/Research/vmd/plugins/molfile\n# \n# When you build LAMMPS with the USER-MOLFILE package installed, it will\n# use the 3 settings in this file.  They should be set as follows.\n# \n# The molfile_SYSINC setting is to point to the folder with the VMD\n# plugin headers. By default it points to bundled headers in this folder\n# \n# The molfile_SYSLIB setting is for a system dynamic loading library\n# that will be used to load the molfile plugins.  It contains functions\n# like dlopen(), dlsym() and so on for dynamic linking of executable\n# code into an executable.  For Linux and most current Unix-like\n# operating systems, the setting of \"-ldl\" will work.  On some platforms\n# you may need \"-ldld\".  For compilation on Windows, a different\n# mechanism is used that is part of the Windows programming environment\n# and thus molfile_SYSLIB can be left blank.\n# \n# The molfile_SYSINC and molfile_SYSPATH variables do not typically need\n# to be set.  If the dl library is not in a place the linker can find\n# it, specify its directory via the molfile_SYSPATH variable, e.g.\n# -Ldir.\n\n# -----------------------------------------------------------\n\n# Settings that the LAMMPS build will import when this package is installed\n\n# change this to -I/path/to/your/lib/vmd/plugins/include if the bundled\n# header files are incompatible with your VMD plugsins\nmolfile_SYSINC =-I../../lib/molfile\n#\nifneq ($(LIBOBJDIR),/Obj_mingw32)\nifneq ($(LIBOBJDIR),/Obj_mingw64)\nifneq ($(LIBOBJDIR),/Obj_mingw32-mpi)\nifneq ($(LIBOBJDIR),/Obj_mingw64-mpi)\nmolfile_SYSLIB = -ldl\nendif\nendif\nendif\nendif\nmolfile_SYSPATH =\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/COUPLE/plugin/liblammpsplugin.c": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/*\n   Variant of the C style library interface to LAMMPS\n   that uses a shared library and dynamically opens it,\n   so this can be used as a prototype code to integrate\n   a LAMMPS plugin to some other software.\n*/\n\n#include \"library.h\"\n#include \"liblammpsplugin.h\"\n#include <stdlib.h>\n#include <dlfcn.h>\n\nliblammpsplugin_t *liblammpsplugin_load(const char *lib)\n{\n  liblammpsplugin_t *lmp;\n  void *handle;\n\n  if (lib == NULL) return NULL;\n  handle = dlopen(lib,RTLD_NOW|RTLD_GLOBAL);\n  if (handle == NULL) return NULL;\n  \n  lmp = (liblammpsplugin_t *) malloc(sizeof(liblammpsplugin_t));\n  lmp->handle = handle;\n\n#define ADDSYM(symbol) lmp->symbol = dlsym(handle,\"lammps_\" #symbol)\n  ADDSYM(open);\n  ADDSYM(open_no_mpi);\n  ADDSYM(close);\n  ADDSYM(version);\n  ADDSYM(file);\n  ADDSYM(command);\n  ADDSYM(commands_list);\n  ADDSYM(commands_string);\n  ADDSYM(free);\n  ADDSYM(extract_setting);\n  ADDSYM(extract_global);\n  ADDSYM(extract_box);\n  ADDSYM(extract_atom);\n  ADDSYM(extract_compute);\n  ADDSYM(extract_fix);\n  ADDSYM(extract_variable);\n\n  ADDSYM(get_thermo);\n  ADDSYM(get_natoms);\n\n  ADDSYM(set_variable);\n  ADDSYM(reset_box);\n\n  ADDSYM(gather_atoms);\n  ADDSYM(gather_atoms_concat);\n  ADDSYM(gather_atoms_subset);\n  ADDSYM(scatter_atoms);\n  ADDSYM(scatter_atoms_subset);\n\n  ADDSYM(set_fix_external_callback);\n\n  ADDSYM(config_has_package);\n  ADDSYM(config_package_count);\n  ADDSYM(config_package_name);\n  ADDSYM(config_has_gzip_support);\n  ADDSYM(config_has_png_support);\n  ADDSYM(config_has_jpeg_support);\n  ADDSYM(config_has_ffmpeg_support);\n  ADDSYM(config_has_exceptions);\n  ADDSYM(create_atoms);\n#ifdef LAMMPS_EXCEPTIONS\n  lmp->has_exceptions = 1;\n  ADDSYM(has_error);\n  ADDSYM(get_last_error_message);\n#else\n  lmp->has_exceptions = 0;\n  lmp->has_error = NULL;\n  lmp->get_last_error_message = NULL;\n#endif\n  return lmp;\n}\n\nint liblammpsplugin_release(liblammpsplugin_t *lmp)\n{\n  if (lmp == NULL) return 1;\n  if (lmp->handle == NULL) return 2;\n\n  dlclose(lmp->handle);\n  free((void *)lmp);\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/lib/awpmd/ivutils/include/cvector_3.h",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/lib/awpmd/ivutils/include/pairhash.h",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/lib/awpmd/ivutils/include/vector_3.h",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/SPIN/read_restart/restart_hcp_cobalt.equil",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/local.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/local.001300.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/global.089000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/local.000400.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/global.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/global.041000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/global.048000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/hyper/global.045000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/mscg/output_9Jan17/x.out",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/cgsdk/sds-monolayer/data.sds.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/cgsdk/peg-verlet/data.pegc12e8.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/phonon/3-3D-FCC-Cu-EAM/CuPhonon.bin.6500000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/phonon/4-Graphene/Graphene.bin.6000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/phonon/1-1D-mono/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/phonon/2-1D-diatomic/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/diffraction/Output/bulkNi_001.saed.0_VisIt_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/reaction/nylon,6-6_melt/large_nylon_melt.data.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/manifold/diffusion/msd_plot2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/manifold/diffusion/msd.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/manifold/energy/energy_conservation.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/examples/USER/manifold/energy/energy_conservation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/createatoms/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/xmgrace/lammpsplot.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/emacs/lammps-mode.el",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/i-pi/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/polybond/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/matlab/README.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/tools/pymol_asphere/doc/asphere_vis.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/colvars-refman-lammps.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/pair_resquared_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/PDLammps_overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/USER-CGDNA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/SMD_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/PDLammps_EPS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/pair_gayberne_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/PDLammps_VES.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/kspace.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/PDF/SPH_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dump1_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/saed_mesh_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_pull_request_feature_branch1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/gran_funnel_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_uniform_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/ccmake-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/hop1_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/user_intel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_uniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_pymol.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/zeeman_langevin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/examples_edpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/hop2_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/atc_nanotube.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_merged.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_06.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_additional_changes.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/qbmsst_shock.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/examples_mdpd_first.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dreiding_hbond.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_02_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/qbmsst_init.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/cmake-gui-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pylammps_mc_energies_plot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_edits_maintainers.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_atomeye_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_08.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/examples_mdpd_last.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/improper_distance.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/umbrella.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/lj_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_gl.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/ccmake-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_09.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_vmd_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_automated_checks_passed.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_03_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_04.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_new_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/cmake-codeblocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/fix_wall_ees_image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/saed_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/rhodo_staggered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dynamical_matrix_phonons.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pimd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_01_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/offload_knc.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_rcb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/ccmake-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request7.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/coul_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pylammps_mc_minimum.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dihedral_sign.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pylammps_mc_disordered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/gran_mixer_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/saed_ewald_intersect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_04_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/examples_mdpd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_https_block.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/sinusoid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/xrd_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/lammps-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_create_new_pull_request1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/uef_frames.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/sinusoid_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_nonuniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_changes_others.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pair_body_rounded.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_05.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/examples_tdpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_vmd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/gran_mixer.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_create_new_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_gl_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dump2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/hop2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dump2_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/saed_ewald_intersect_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/cmake-gui-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_07.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/third_order_force_constant.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_pymol_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/fix_integration_spin_stdecomposition.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_nonuniform_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dump1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/gran_funnel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request5.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/balance_rcb_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bow_tutorial_03.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/hop1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pair_atm_dia.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request6.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_branch.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/cmake-gui-popup.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pylammps_dihedral.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/bondswap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_reverse_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/xrd_mesh_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_automated_checks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/tutorial_steve_assignee.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/screenshot_atomeye.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/dihedral_spherical_angles.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/JPG/pair_cosine_squared_graphs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/src/Developer/classes.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/lammps-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/FontAwesome.otf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-20200505-ekdddm7zljxonznm76zmd67updjxow2i/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.woff"
    ],
    "total_files": 10727
}