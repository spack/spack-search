{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/src/USER-MOLFILE/molfile_interface.cpp": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   https://lammps.sandia.gov/, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------------\n   Contributing author: Axel Kohlmeyer (Temple)\n------------------------------------------------------------------------- */\n\n#include \"molfile_interface.h\"\n#include \"molfile_plugin.h\"\n\n#include <sys/types.h>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\n#if defined(_WIN32)\n#include <windows.h>\n#else\n#include <dirent.h>\n#include <dlfcn.h>\n#endif\n\n#if vmdplugin_ABIVERSION < 16\n#error \"unsupported VMD molfile plugin ABI version\"\n#endif\n\n#define DEBUG 0\n\nextern \"C\" {\n  typedef int (*initfunc)(void);\n  typedef int (*regfunc)(void *, vmdplugin_register_cb);\n  typedef int (*finifunc)(void);\n\n  typedef struct {\n    void *p;\n    const char *name;\n  } plugin_reginfo_t;\n\n  // callback function for plugin registration.\n  static int plugin_register_cb(void *v, vmdplugin_t *p)\n  {\n    plugin_reginfo_t *r = static_cast<plugin_reginfo_t *>(v);\n    // make sure we have the proper plugin type (native reader)\n    // for the desired file type (called \"name\" at this level)\n    if ((strcmp(MOLFILE_PLUGIN_TYPE,p->type) == 0)\n        && (strcmp(r->name, p->name) == 0)) {\n      r->p = static_cast<void *>(p);\n    }\n    return 0;\n  }\n\n  /* periodic table of elements for translation of ordinal to atom type */\n  static const char *pte_label[] = {\n    \"X\",  \"H\",  \"He\", \"Li\", \"Be\", \"B\",  \"C\",  \"N\",  \"O\",  \"F\",  \"Ne\",\n    \"Na\", \"Mg\", \"Al\", \"Si\", \"P\" , \"S\",  \"Cl\", \"Ar\", \"K\",  \"Ca\", \"Sc\",\n    \"Ti\", \"V\",  \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\",\n    \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\",  \"Zr\", \"Nb\", \"Mo\", \"Tc\",\n    \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\",  \"Xe\",\n    \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\",\n    \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\",  \"Re\", \"Os\",\n    \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\",\n    \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\",  \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\",\n    \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\",\n    \"Ds\", \"Rg\"\n  };\n  static const int nr_pte_entries = sizeof(pte_label) / sizeof(char *);\n\n  /* corresponding table of masses. */\n  static const float pte_mass[] = {\n    /* X  */ 0.00000, 1.00794, 4.00260, 6.941, 9.012182, 10.811,\n    /* C  */ 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,\n    /* Na */ 22.989770, 24.3050, 26.981538, 28.0855, 30.973761,\n    /* S  */ 32.065, 35.453, 39.948, 39.0983, 40.078, 44.955910,\n    /* Ti */ 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.9332,\n    /* Ni */ 58.6934, 63.546, 65.409, 69.723, 72.64, 74.92160,\n    /* Se */ 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585,\n    /* Zr */ 91.224, 92.90638, 95.94, 98.0, 101.07, 102.90550,\n    /* Pd */ 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760,\n    /* Te */ 127.60, 126.90447, 131.293, 132.90545, 137.327,\n    /* La */ 138.9055, 140.116, 140.90765, 144.24, 145.0, 150.36,\n    /* Eu */ 151.964, 157.25, 158.92534, 162.500, 164.93032,\n    /* Er */ 167.259, 168.93421, 173.04, 174.967, 178.49, 180.9479,\n    /* W  */ 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655,\n    /* Hg */ 200.59, 204.3833, 207.2, 208.98038, 209.0, 210.0, 222.0,\n    /* Fr */ 223.0, 226.0, 227.0, 232.0381, 231.03588, 238.02891,\n    /* Np */ 237.0, 244.0, 243.0, 247.0, 247.0, 251.0, 252.0, 257.0,\n    /* Md */ 258.0, 259.0, 262.0, 261.0, 262.0, 266.0, 264.0, 269.0,\n    /* Mt */ 268.0, 271.0, 272.0\n  };\n\n  /*\n   * corresponding table of VDW radii.\n   * van der Waals radii are taken from A. Bondi,\n   * J. Phys. Chem., 68, 441 - 452, 1964,\n   * except the value for H, which is taken from R.S. Rowland & R. Taylor,\n   * J.Phys.Chem., 100, 7384 - 7391, 1996. Radii that are not available in\n   * either of these publications have RvdW = 2.00 \\AA.\n   * The radii for Ions (Na, K, Cl, Ca, Mg, and Cs are based on the CHARMM27\n   * Rmin/2 parameters for (SOD, POT, CLA, CAL, MG, CES) by default.\n   */\n  static const float pte_vdw_radius[] = {\n    /* X  */ 1.5, 1.2, 1.4, 1.82, 2.0, 2.0,\n    /* C  */ 1.7, 1.55, 1.52, 1.47, 1.54,\n    /* Na */ 1.36, 1.18, 2.0, 2.1, 1.8,\n    /* S  */ 1.8, 2.27, 1.88, 1.76, 1.37, 2.0,\n    /* Ti */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Ni */ 1.63, 1.4, 1.39, 1.07, 2.0, 1.85,\n    /* Se */ 1.9, 1.85, 2.02, 2.0, 2.0, 2.0,\n    /* Zr */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Pd */ 1.63, 1.72, 1.58, 1.93, 2.17, 2.0,\n    /* Te */ 2.06, 1.98, 2.16, 2.1, 2.0,\n    /* La */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Eu */ 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Er */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* W  */ 2.0, 2.0, 2.0, 2.0, 1.72, 1.66,\n    /* Hg */ 1.55, 1.96, 2.02, 2.0, 2.0, 2.0, 2.0,\n    /* Fr */ 2.0, 2.0, 2.0, 2.0, 2.0, 1.86,\n    /* Np */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Md */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Mt */ 2.0, 2.0, 2.0\n  };\n\n  /* lookup functions */\n\n  static const char *get_pte_label(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_label[0];\n\n    return pte_label[idx];\n  }\n\n  static float get_pte_mass(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_mass[0];\n\n    return pte_mass[idx];\n  }\n\n  static float get_pte_vdw_radius(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_vdw_radius[0];\n\n#if 1\n    /* Replace with Hydrogen radius with an \"all-atom\" radius */\n    if (idx == 1)\n      return 1.0;    /* H  */\n#else\n    /* Replace with old VMD atom radii values */\n    switch (idx) {\n    case  1: return 1.0;    /* H  */\n    case  6: return 1.5;    /* C  */\n    case  7: return 1.4;    /* N  */\n    case  8: return 1.3;    /* O  */\n    case  9: return 1.2;    /* F  */\n    case 15: return 1.5;    /* P  */\n    case 16: return 1.9;    /* S  */\n    }\n#endif\n\n    return pte_vdw_radius[idx];\n  }\n\n  static int get_pte_idx_from_string(const char *label) {\n    int i, ind;\n    char atom[3];\n\n    if (label != nullptr) {\n      /* zap string */\n      atom[0] = atom[1] = atom[2] = '\\0';\n\n      for (ind=0,i=0; (ind<2) && (label[i]!='\\0'); i++) {\n        if (label[i] != ' ') {\n          atom[ind] = toupper(label[i]);\n          ind++;\n        }\n      }\n\n      if (ind < 1)\n        return 0; /* no non-whitespace characters */\n\n      for (i=0; i < nr_pte_entries; ++i) {\n        if ((toupper(pte_label[i][0]) == atom[0]) && (toupper(pte_label[i][1]) == atom[1]))\n          return i;\n      }\n    }\n\n    return 0;\n  }\n\n  // directory traversal helper functions\n\n#if defined(_WIN32)\n\n  // Win32 directory traversal handle\n  typedef struct {\n    HANDLE h;\n    WIN32_FIND_DATA fd;\n    char *name;\n    char *searchname;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == nullptr)\n      return nullptr;\n    d = new dirhandle_t;\n\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name, dirname);\n    strcat(d->name, \"\\\\\");\n    d->dlen = len;\n\n    len += 1;\n    d->searchname = new char[len];\n    strcpy(d->searchname, dirname);\n    strcat(d->searchname, \"\\\\*\");\n\n    d->h = FindFirstFile(d->searchname, &(d->fd));\n    if (d->h == ((HANDLE)(-1))) {\n      delete[] d->searchname;\n      delete[] d->name;\n      delete d;\n      return nullptr;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    if (FindNextFile(d->h, &(d->fd))) {\n      return d->fd.cFileName;\n    }\n    return nullptr;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->h != nullptr) {\n      FindClose(d->h);\n    }\n    delete[] d->searchname;\n    delete[] d->name;\n    delete d;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return (void *)LoadLibrary(fname);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return (void *)GetProcAddress((HINSTANCE)h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    /* FreeLibrary returns nonzero on success */\n    return !FreeLibrary((HINSTANCE)h);\n  }\n\n#else\n\n  // Unix directory traversal handle\n  typedef struct {\n    DIR *d;\n    char *name;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == nullptr) return nullptr;\n\n    d = new dirhandle_t;\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name,dirname);\n    strcat(d->name,\"/\");\n    d->dlen = len;\n\n    d->d = opendir(d->name);\n    if (d->d == nullptr) {\n      delete[] d->name;\n      delete d;\n      return nullptr;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    struct dirent *p;\n\n    if ((p = readdir(d->d)) != nullptr) {\n      return p->d_name;\n    }\n\n    return nullptr;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->d != nullptr) {\n      closedir(d->d);\n    }\n    delete[] d->name;\n    delete d;\n    return;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return dlopen(fname, RTLD_NOW);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return dlsym(h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    return dlclose(h);\n  }\n\n#endif\n\n} // end of extern \"C\" region\n\nusing namespace LAMMPS_NS;\n\n// constructor.\nMolfileInterface::MolfileInterface(const char *type, const int mode)\n  : _plugin(0), _dso(0), _ptr(0), _info(0), _natoms(0),\n    _mode(mode), _caps(M_NONE)\n{\n  _name = new char[5];\n  strcpy(_name,\"none\");\n  _type = new char[1+strlen(type)];\n  strcpy(_type,type);\n}\n\n// destructor.\nMolfileInterface::~MolfileInterface()\n{\n  forget_plugin();\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = nullptr;\n  }\n  delete[] _name;\n  delete[] _type;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::find_plugin(const char *pluginpath)\n{\n  dirhandle_t *dir;\n  char *filename, *ext, *next, *path, *plugindir;\n  int retval = E_NONE;\n\n#if defined(_WIN32)\n#define MY_PATHSEP ';'\n#else\n#define MY_PATHSEP ':'\n#endif\n  if (pluginpath == nullptr) return E_DIR;\n  plugindir = path = strdup(pluginpath);\n\n  while (plugindir) {\n    // check if this a single directory or path.\n    next = strchr(plugindir,MY_PATHSEP);\n    if (next) {\n      *next = '\\0';\n      ++next;\n    }\n\n    dir = my_opendir(plugindir);\n    if (!dir)\n      retval = (retval > E_DIR) ? retval : E_DIR;\n\n    // search for suitable file names and try to inspect them\n    while (dir) {\n      char *fullname;\n      int len;\n\n      filename = my_readdir(dir);\n      if (filename == nullptr) break;\n\n      // only look at .so files\n      ext = strrchr(filename, '.');\n      if (ext == nullptr) continue;\n      if (strcasecmp(ext,\".so\") != 0) continue;\n\n      // construct full pathname of potential DSO\n      len = dir->dlen;\n      len += strlen(filename);\n      fullname = new char[len];\n      strcpy(fullname,dir->name);\n      strcat(fullname,filename);\n\n      // try to register plugin at file name.\n      int rv = load_plugin(fullname);\n      if (rv > retval) retval = rv;\n\n      delete[] fullname;\n    }\n    if (dir)\n      my_closedir(dir);\n\n    plugindir = next;\n  }\n  free(path);\n  return retval;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::load_plugin(const char *filename)\n{\n  void *dso;\n  int len, retval = E_NONE;\n\n  // access shared object\n  dso = my_dlopen(filename);\n  if (dso == nullptr)\n    return E_FILE;\n\n  // check for required plugin symbols\n  void *ifunc = my_dlsym(dso,\"vmdplugin_init\");\n  void *rfunc = my_dlsym(dso,\"vmdplugin_register\");\n  void *ffunc = my_dlsym(dso,\"vmdplugin_fini\");\n  if (ifunc == nullptr || rfunc == nullptr || ffunc == nullptr) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // initialize plugin. skip plugin if it fails.\n  if (((initfunc)(ifunc))()) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // pre-register plugin.\n  // the callback will be called for each plugin in the DSO and\n  // check the file type. plugin->name will change if successful.\n  plugin_reginfo_t reginfo;\n  reginfo.p = nullptr;\n  reginfo.name=_type;\n  ((regfunc)rfunc)(&reginfo, plugin_register_cb);\n\n  // make some checks to see if the plugin is suitable or not.\n  molfile_plugin_t *plugin = static_cast<molfile_plugin_t *>(reginfo.p);\n\n  // if the callback found a matching plugin and copied the struct,\n  // its name element will point to a different location now.\n  if (plugin == nullptr) {\n    retval = E_TYPE;\n\n    // check if the ABI matches the one used to compile this code\n  } else if (plugin->abiversion != vmdplugin_ABIVERSION) {\n    retval = E_ABI;\n\n    // check if (basic) reading is supported\n  } else if ((_mode & M_READ) &&\n             ( (plugin->open_file_read == nullptr) ||\n               (plugin->read_next_timestep  == nullptr) ||\n               (plugin->close_file_read == nullptr) )) {\n    retval = E_MODE;\n\n    // check if (basic) writing is supported\n  } else if ( (_mode & M_WRITE) &&\n              ( (plugin->open_file_write == nullptr) ||\n                (plugin->write_timestep  == nullptr) ||\n                (plugin->close_file_write == nullptr) )) {\n    retval = E_MODE;\n\n    // make some additional check, if we\n    // already have a plugin registered.\n    // NOTE: this has to come last.\n  } else if (_dso && _plugin) {\n    molfile_plugin_t *p;\n    p = static_cast<molfile_plugin_t *>(_plugin);\n\n    // check if the new plugin is of a newer major version\n    if (p->majorv > plugin->majorv) {\n      retval = E_VERSION;\n\n    // check if the new plugin is of a newer minor version\n    } else if ( (p->majorv == plugin->majorv) &&\n                (p->minorv >= plugin->minorv)) {\n      retval = E_VERSION;\n    }\n  }\n\n  // bingo! this one is a keeper.\n  if (retval == E_NONE) {\n\n    // make sure any existing plugin is wiped out\n    forget_plugin();\n\n    delete[] _name;\n    len = 16;\n    len += strlen(plugin->prettyname);\n    len += strlen(plugin->author);\n    _name = new char[len];\n    sprintf(_name,\"%s v%d.%d by %s\",plugin->prettyname,\n            plugin->majorv, plugin->minorv, plugin->author);\n\n    // determine plugin capabilities\n    _caps = M_NONE;\n    if (plugin->read_next_timestep)      _caps |= M_READ;\n    if (plugin->write_timestep)          _caps |= M_WRITE;\n#if vmdplugin_ABIVERSION > 10\n    // required to tell if velocities are present\n    if (plugin->read_timestep_metadata)  _caps |= M_RVELS;\n    // we can always offer velocities. we may not know if\n    // they will be written by the plugin though.\n    if (plugin->write_timestep)          _caps |= M_WVELS;\n#endif\n    if (plugin->read_structure)          _caps |= M_RSTRUCT;\n    if (plugin->write_structure)         _caps |= M_WSTRUCT;\n    if (plugin->read_bonds)              _caps |= M_RBONDS;\n    if (plugin->write_bonds)             _caps |= M_WBONDS;\n    if (plugin->read_angles)             _caps |= M_RANGLES;\n    if (plugin->write_angles)            _caps |= M_WANGLES;\n    if (plugin->read_volumetric_data)    _caps |= M_RVOL;\n    if (plugin->write_volumetric_data)   _caps |= M_WVOL;\n\n    if (_mode & M_WRITE) {\n      _mode |= (_caps & M_WSTRUCT);\n      _mode |= (_caps & M_WVELS);\n    } else if (_mode & M_READ) {\n      _mode |= (_caps & M_RSTRUCT);\n      _mode |= (_caps & M_RVELS);\n    }\n\n    _plugin = plugin;\n    _dso = dso;\n    return E_MATCH;\n  }\n\n  // better luck next time. clean up and return.\n  my_dlclose(dso);\n  return retval;\n}\n\n// deregister a plugin and close or reset all associated objects.\nvoid MolfileInterface::forget_plugin()\n{\n  if (_ptr)\n    close();\n\n  if (_plugin)\n    _plugin = nullptr;\n\n  if (_dso) {\n    void *ffunc = my_dlsym(_dso,\"vmdplugin_fini\");\n    if (ffunc)\n      ((finifunc)ffunc)();\n    my_dlclose(_dso);\n  }\n  _dso = nullptr;\n\n  delete[] _name;\n    _name = new char[5];\n  strcpy(_name,\"none\");\n\n  _caps = M_NONE;\n}\n\n// open file for reading or writing\nint MolfileInterface::open(const char *name, int *natoms)\n{\n  if (!_plugin || !_dso || !natoms)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE)\n    _ptr = p->open_file_write(name,_type,*natoms);\n  else if (_mode & M_READ)\n    _ptr = p->open_file_read(name,_type,natoms);\n\n  if (_ptr == nullptr)\n    return E_FILE;\n\n  _natoms = *natoms;\n  // we need to deal with structure information,\n  // so we allocate and initialize storage for it.\n  if (_mode & (M_RSTRUCT|M_WSTRUCT)) {\n    molfile_atom_t *a = new molfile_atom_t[_natoms];\n    _info = a;\n    memset(_info,0,_natoms*sizeof(molfile_atom_t));\n    for (int i=0; i < _natoms; ++i) {\n      a[i].name[0] = 'X';\n      a[i].type[0] = a[i].resname[0] = a[i].segid[0] = 'U';\n      a[i].type[1] = a[i].resname[1] = a[i].segid[1] = 'N';\n      a[i].type[2] = a[i].resname[2] = a[i].segid[2] = 'K';\n      a[i].chain[0] = 'X';\n    }\n  }\n  return E_NONE;\n}\n\n// get of set atom structure information\nint MolfileInterface::structure()\n{\n  if (!_plugin || !_dso)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  int optflags = MOLFILE_NOOPTIONS;\n\n  if (_mode & M_WSTRUCT) {\n    optflags |= (_props & P_BFAC) ? MOLFILE_BFACTOR : 0;\n    optflags |= (_props & P_OCCP) ? MOLFILE_OCCUPANCY : 0;\n    optflags |= (_props & P_MASS) ? MOLFILE_MASS : 0;\n    optflags |= (_props & P_CHRG) ? MOLFILE_CHARGE : 0;\n    optflags |= (_props & P_RADS) ? MOLFILE_RADIUS : 0;\n    optflags |= (_props & P_ATMN) ? MOLFILE_ATOMICNUMBER : 0;\n\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->write_structure(_ptr,optflags,a);\n  } else if (_mode & M_RSTRUCT) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->read_structure(_ptr,&optflags,a);\n    // mandatory properties\n    _props = P_NAME|P_TYPE|P_RESN|P_RESI|P_SEGN|P_CHAI;\n    // optional properties\n    _props |= (optflags & MOLFILE_BFACTOR) ? P_BFAC : 0;\n    _props |= (optflags & MOLFILE_OCCUPANCY) ? P_OCCP : 0;\n    _props |= (optflags & MOLFILE_MASS) ? P_MASS : 0;\n    _props |= (optflags & MOLFILE_CHARGE) ? P_CHRG : 0;\n    _props |= (optflags & MOLFILE_RADIUS) ? P_RADS : 0;\n    _props |= (optflags & MOLFILE_ATOMICNUMBER) ? P_ATMN : 0;\n  }\n  return 0;\n}\n\n// safely close file\nint MolfileInterface::close()\n{\n  if (!_plugin || !_dso || !_ptr)\n    return E_FILE;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE) {\n    p->close_file_write(_ptr);\n  } else if (_mode & M_READ) {\n    p->close_file_read(_ptr);\n  }\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = nullptr;\n  }\n  _ptr = nullptr;\n  _natoms = 0;\n\n  return E_NONE;\n}\n\n\n// read or write timestep\nint MolfileInterface::timestep(float *coords, float *vels,\n                               float *cell, double *simtime)\n{\n  if (!_plugin || !_dso || !_ptr)\n    return 1;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n  molfile_timestep_t *t = new molfile_timestep_t;\n  int rv;\n\n  if (_mode & M_WRITE) {\n    t->coords = coords;\n    t->velocities = vels;\n    if (cell != nullptr) {\n      t->A = cell[0];\n      t->B = cell[1];\n      t->C = cell[2];\n      t->alpha = cell[3];\n      t->beta = cell[4];\n      t->gamma = cell[5];\n    } else {\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n    }\n\n    if (simtime)\n      t->physical_time = *simtime;\n    else\n      t->physical_time = 0.0;\n\n    rv = p->write_timestep(_ptr,t);\n\n  } else {\n    // no coordinate storage => skip step\n    if (coords == nullptr) {\n      rv = p->read_next_timestep(_ptr, _natoms, nullptr);\n    } else {\n      t->coords = coords;\n      t->velocities = vels;\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n      t->physical_time = 0.0;\n      rv = p->read_next_timestep(_ptr, _natoms, t);\n      if (cell != nullptr) {\n        cell[0] = t->A;\n        cell[1] = t->B;\n        cell[2] = t->C;\n        cell[3] = t->alpha;\n        cell[4] = t->beta;\n        cell[5] = t->gamma;\n      }\n      if (simtime)\n        *simtime = t->physical_time;\n    }\n\n    if (rv == MOLFILE_EOF) {\n      delete t;\n      return 1;\n    }\n  }\n\n  delete t;\n  return 0;\n}\n\n// functions to read properties from molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { VAL = a.ENTRY; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { strcpy(VAL,a.ENTRY); }\n\n// single precision floating point props\nstatic float read_float_property(molfile_atom_t &a, const int propid)\n{\n  float prop = 0.0f;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_RADS),\n             atomicnumber,iprop);\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & MolfileInterface::P_MASS)\n      prop = get_pte_mass(iprop);\n    if (propid & MolfileInterface::P_RADS)\n      prop = get_pte_vdw_radius(iprop);\n  }\n\n  return prop;\n}\n\n// integer and derived props\nstatic int read_int_property(molfile_atom_t &a, const int propid)\n{\n  int prop = 0;\n  const char * sprop;\n\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,sprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,sprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_idx_from_string(sprop);\n  }\n\n  return prop;\n}\n\n// string and derived props\nstatic const char *read_string_property(molfile_atom_t &a,\n                                        const int propid)\n{\n  const char *prop = nullptr;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_NAME,name,prop);\n  PROPUPDATE(MolfileInterface::P_TYPE,type,prop);\n  PROPUPDATE(MolfileInterface::P_RESN,resname,prop);\n  PROPUPDATE(MolfileInterface::P_SEGN,segid,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             atomicnumber,iprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_label(iprop);\n  }\n\n  return prop;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// functions to store properties into molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)                                  \\\n  if ((propid & PROP) == PROP) { a.ENTRY = VAL; plist |= PROP; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)                                      \\\n  if ((propid & PROP) == PROP) { strcpy(a.ENTRY,VAL); plist |= PROP; }\n\n// floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const float prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n  return plist;\n}\n\n// double precision floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const double prop)\n{\n  return write_atom_property(a,propid,static_cast<float>(prop));\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const int prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             mass,get_pte_mass(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,get_pte_label(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,get_pte_label(prop));\n  return plist;\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const char *prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPSTRCPY(MolfileInterface::P_NAME,name,prop);\n  PROPSTRCPY(MolfileInterface::P_TYPE,type,prop);\n  PROPSTRCPY(MolfileInterface::P_RESN,resname,prop);\n  PROPSTRCPY(MolfileInterface::P_SEGN,segid,prop);\n  return plist;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, float *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_float_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, float *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading.\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, float *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_float_property(a[i], propid);\n  }\n\n  return _props;\n}\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, double *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    return write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = static_cast<double>(read_float_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, double *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, double *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = static_cast<double>(read_float_property(a[i], propid));\n  }\n\n  return _props;\n}\n\n#define INT_TO_STRING_BODY(IDX)                         \\\n  buf[15] = 0;                                          \\\n  if (propid & P_NAME)                                  \\\n    _props |= write_atom_property(a[IDX],P_NAME,buf);   \\\n  if (propid & P_TYPE)                                  \\\n    _props |= write_atom_property(a[IDX],P_TYPE,buf);   \\\n  buf[7] = 0;                                           \\\n  if (propid & P_RESN)                                  \\\n    _props |= write_atom_property(a[IDX],P_RESN,buf);   \\\n  if (propid & P_SEGN)                                  \\\n    _props |= write_atom_property(a[IDX],P_SEGN,buf);   \\\n  buf[1] = 0;                                           \\\n  if (propid & P_CHAI)                                  \\\n    _props |= write_atom_property(a[IDX],P_CHAI,buf)\n\n// set/get atom integer property\nint MolfileInterface::property(int propid, int idx, int *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      sprintf(buf,\"%d\",*prop);\n      INT_TO_STRING_BODY(idx);\n    }\n  }\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_int_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type integer property\nint MolfileInterface::property(int propid, int *types, int *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[types[i]]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom integer property\nint MolfileInterface::property(int propid, int *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i],propid,prop[i]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[i]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_int_property(a[i], propid);\n  }\n\n  return _props;\n}\n#undef INT_TO_STRING_BODY\n\n// set/get atom string property\nint MolfileInterface::property(int propid, int idx, char *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    _props |= write_atom_property(a[idx], propid, prop);\n  }\n\n  if (_mode & M_RSTRUCT)\n    strcpy(prop,read_string_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type string property\nint MolfileInterface::property(int propid, int *types, char **prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom string property\nint MolfileInterface::property(int propid, char **prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[i]);\n    }\n  }\n\n  // not supported right now. XXX: should we use strdup() here?\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/lib/kokkos/core/src/impl/Kokkos_Profiling.cpp": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n#include <Kokkos_Macros.hpp>\n#include <Kokkos_Tuners.hpp>\n#include <impl/Kokkos_Profiling.hpp>\n#if defined(KOKKOS_ENABLE_LIBDL)\n#include <dlfcn.h>\n#endif\n\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <stack>\n#include <iostream>\nnamespace Kokkos {\n\nnamespace Tools {\n\nnamespace Experimental {\n#ifdef KOKKOS_ENABLE_TUNING\nstatic size_t kernel_name_context_variable_id;\nstatic size_t kernel_type_context_variable_id;\nstatic std::unordered_map<size_t, std::unordered_set<size_t>>\n    features_per_context;\nstatic std::unordered_set<size_t> active_features;\nstatic std::unordered_map<size_t, VariableValue> feature_values;\nstatic std::unordered_map<size_t, VariableInfo> variable_metadata;\n#endif\nstatic EventSet current_callbacks;\nstatic EventSet backup_callbacks;\nstatic EventSet no_profiling;\n\nbool eventSetsEqual(const EventSet& l, const EventSet& r) {\n  return l.init == r.init && l.finalize == r.finalize &&\n         l.begin_parallel_for == r.begin_parallel_for &&\n         l.end_parallel_for == r.end_parallel_for &&\n         l.begin_parallel_reduce == r.begin_parallel_reduce &&\n         l.end_parallel_reduce == r.end_parallel_reduce &&\n         l.begin_parallel_scan == r.begin_parallel_scan &&\n         l.end_parallel_scan == r.end_parallel_scan &&\n         l.push_region == r.push_region && l.pop_region == r.pop_region &&\n         l.allocate_data == r.allocate_data &&\n         l.deallocate_data == r.deallocate_data &&\n         l.create_profile_section == r.create_profile_section &&\n         l.start_profile_section == r.start_profile_section &&\n         l.stop_profile_section == r.stop_profile_section &&\n         l.destroy_profile_section == r.destroy_profile_section &&\n         l.profile_event == r.profile_event &&\n         l.begin_deep_copy == r.begin_deep_copy &&\n         l.end_deep_copy == r.end_deep_copy && l.begin_fence == r.begin_fence &&\n         l.end_fence == r.end_fence && l.sync_dual_view == r.sync_dual_view &&\n         l.modify_dual_view == r.modify_dual_view &&\n         l.declare_input_type == r.declare_input_type &&\n         l.declare_output_type == r.declare_output_type &&\n         l.end_tuning_context == r.end_tuning_context &&\n         l.begin_tuning_context == r.begin_tuning_context &&\n         l.request_output_values == r.request_output_values &&\n         l.declare_optimization_goal == r.declare_optimization_goal;\n}\n}  // namespace Experimental\nbool profileLibraryLoaded() {\n  return !Experimental::eventSetsEqual(Experimental::current_callbacks,\n                                       Experimental::no_profiling);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_for)(kernelPrefix.c_str(),\n                                                          devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_for)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_scan)(kernelPrefix.c_str(),\n                                                           devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_scan)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_reduce)(\n        kernelPrefix.c_str(), devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_reduce)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid pushRegion(const std::string& kName) {\n  if (Experimental::current_callbacks.push_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.push_region)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if (Experimental::current_callbacks.pop_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.pop_region)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label,\n                  const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.allocate_data != nullptr) {\n    (*Experimental::current_callbacks.allocate_data)(space, label.c_str(), ptr,\n                                                     size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.deallocate_data != nullptr) {\n    (*Experimental::current_callbacks.deallocate_data)(space, label.c_str(),\n                                                       ptr, size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  if (Experimental::current_callbacks.begin_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.begin_deep_copy)(\n        dst_space, dst_label.c_str(), dst_ptr, src_space, src_label.c_str(),\n        src_ptr, size);\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      auto context_id = Experimental::get_new_context_id();\n      Experimental::begin_context(context_id);\n      Experimental::VariableValue contextValues[] = {\n          Experimental::make_variable_value(\n              Experimental::kernel_name_context_variable_id,\n              \"deep_copy_kernel\"),\n          Experimental::make_variable_value(\n              Experimental::kernel_type_context_variable_id, \"deep_copy\")};\n      Experimental::set_input_values(context_id, 2, contextValues);\n    }\n#endif\n  }\n}\n\nvoid endDeepCopy() {\n  if (Experimental::current_callbacks.end_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.end_deep_copy)();\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      Experimental::end_context(Experimental::get_current_context_id());\n    }\n#endif\n  }\n}\n\nvoid beginFence(const std::string name, const uint32_t deviceId,\n                uint64_t* handle) {\n  if (Experimental::current_callbacks.begin_fence != nullptr) {\n    (*Experimental::current_callbacks.begin_fence)(name.c_str(), deviceId,\n                                                   handle);\n  }\n}\n\nvoid endFence(const uint64_t handle) {\n  if (Experimental::current_callbacks.end_fence != nullptr) {\n    (*Experimental::current_callbacks.end_fence)(handle);\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  if (Experimental::current_callbacks.create_profile_section != nullptr) {\n    (*Experimental::current_callbacks.create_profile_section)(\n        sectionName.c_str(), secID);\n  }\n}\n\nvoid startSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.start_profile_section != nullptr) {\n    (*Experimental::current_callbacks.start_profile_section)(secID);\n  }\n}\n\nvoid stopSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.stop_profile_section != nullptr) {\n    (*Experimental::current_callbacks.stop_profile_section)(secID);\n  }\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.destroy_profile_section != nullptr) {\n    (*Experimental::current_callbacks.destroy_profile_section)(secID);\n  }\n}\n\nvoid markEvent(const std::string& eventName) {\n  if (Experimental::current_callbacks.profile_event != nullptr) {\n    (*Experimental::current_callbacks.profile_event)(eventName.c_str());\n  }\n}\n\nSpaceHandle make_space_handle(const char* space_name) {\n  SpaceHandle handle;\n  strncpy(handle.name, space_name, 63);\n  return handle;\n}\n\nvoid initialize() {\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if (is_initialized) return;\n  is_initialized = 1;\n\n#ifdef KOKKOS_ENABLE_LIBDL\n  void* firstProfileLibrary = nullptr;\n\n  char* envProfileLibrary = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if (envProfileLibrary == nullptr) {\n    return;\n  }\n\n  char* envProfileCopy =\n      (char*)malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if ((profileLibraryName != nullptr) &&\n      (strcmp(profileLibraryName, \"\") != 0)) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if (firstProfileLibrary == nullptr) {\n      std::cerr << \"Error: Unable to load KokkosP library: \"\n                << profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName\n                << \", RTLD_NOW | RTLD_GLOBAL) failed with \" << dlerror()\n                << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName\n                << std::endl;\n#endif\n      // dlsym returns a pointer to an object, while we want to assign to\n      // pointer to function A direct cast will give warnings hence, we have to\n      // workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      Experimental::set_begin_parallel_for_callback(\n          *reinterpret_cast<beginFunction*>(&p1));\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      Experimental::set_begin_parallel_scan_callback(\n          *reinterpret_cast<beginFunction*>(&p2));\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      Experimental::set_begin_parallel_reduce_callback(\n          *reinterpret_cast<beginFunction*>(&p3));\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      Experimental::set_end_parallel_scan_callback(\n          *reinterpret_cast<endFunction*>(&p4));\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      Experimental::set_end_parallel_for_callback(\n          *reinterpret_cast<endFunction*>(&p5));\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      Experimental::set_end_parallel_reduce_callback(\n          *reinterpret_cast<endFunction*>(&p6));\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      Experimental::set_init_callback(*reinterpret_cast<initFunction*>(&p7));\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      Experimental::set_finalize_callback(\n          *reinterpret_cast<finalizeFunction*>(&p8));\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      Experimental::set_push_region_callback(\n          *reinterpret_cast<pushFunction*>(&p9));\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      Experimental::set_pop_region_callback(\n          *reinterpret_cast<popFunction*>(&p10));\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      Experimental::set_allocate_data_callback(\n          *reinterpret_cast<allocateDataFunction*>(&p11));\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      Experimental::set_deallocate_data_callback(\n          *reinterpret_cast<deallocateDataFunction*>(&p12));\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      Experimental::set_begin_deep_copy_callback(\n          *reinterpret_cast<beginDeepCopyFunction*>(&p13));\n      auto p14 = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      Experimental::set_end_deep_copy_callback(\n          *reinterpret_cast<endDeepCopyFunction*>(&p14));\n\n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_begin_fence\");\n      Experimental::set_begin_fence_callback(\n          *reinterpret_cast<beginFenceFunction*>(&p15));\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_end_fence\");\n      Experimental::set_end_fence_callback(\n          *reinterpret_cast<endFenceFunction*>(&p16));\n\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_sync\");\n      Experimental::set_dual_view_sync_callback(\n          *reinterpret_cast<dualViewSyncFunction*>(&p17));\n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_modify\");\n      Experimental::set_dual_view_modify_callback(\n          *reinterpret_cast<dualViewModifyFunction*>(&p18));\n\n      auto p19 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      Experimental::set_create_profile_section_callback(\n          *(reinterpret_cast<createProfileSectionFunction*>(&p19)));\n      auto p20 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      Experimental::set_start_profile_section_callback(\n          *reinterpret_cast<startProfileSectionFunction*>(&p20));\n      auto p21 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      Experimental::set_stop_profile_section_callback(\n          *reinterpret_cast<stopProfileSectionFunction*>(&p21));\n      auto p22 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      Experimental::set_destroy_profile_section_callback(\n          *(reinterpret_cast<destroyProfileSectionFunction*>(&p22)));\n\n      auto p23 = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      Experimental::set_profile_event_callback(\n          *reinterpret_cast<profileEventFunction*>(&p23));\n\n#ifdef KOKKOS_ENABLE_TUNING\n      auto p24 = dlsym(firstProfileLibrary, \"kokkosp_declare_output_type\");\n      Experimental::set_declare_output_type_callback(\n          *reinterpret_cast<Experimental::outputTypeDeclarationFunction*>(\n              &p24));\n\n      auto p25 = dlsym(firstProfileLibrary, \"kokkosp_declare_input_type\");\n      Experimental::set_declare_input_type_callback(\n          *reinterpret_cast<Experimental::inputTypeDeclarationFunction*>(&p25));\n      auto p26 = dlsym(firstProfileLibrary, \"kokkosp_request_values\");\n      Experimental::set_request_output_values_callback(\n          *reinterpret_cast<Experimental::requestValueFunction*>(&p26));\n      auto p27 = dlsym(firstProfileLibrary, \"kokkosp_end_context\");\n      Experimental::set_end_context_callback(\n          *reinterpret_cast<Experimental::contextEndFunction*>(&p27));\n      auto p28 = dlsym(firstProfileLibrary, \"kokkosp_begin_context\");\n      Experimental::set_begin_context_callback(\n          *reinterpret_cast<Experimental::contextBeginFunction*>(&p28));\n      auto p29 =\n          dlsym(firstProfileLibrary, \"kokkosp_declare_optimization_goal\");\n      Experimental::set_declare_optimization_goal_callback(\n          *reinterpret_cast<Experimental::optimizationGoalDeclarationFunction*>(\n              &p29));\n#endif  // KOKKOS_ENABLE_TUNING\n    }\n  }\n#endif  // KOKKOS_ENABLE_LIBDL\n  if (Experimental::current_callbacks.init != nullptr) {\n    (*Experimental::current_callbacks.init)(\n        0, (uint64_t)KOKKOSP_INTERFACE_VERSION, (uint32_t)0, nullptr);\n  }\n\n#ifdef KOKKOS_ENABLE_TUNING\n  Experimental::VariableInfo kernel_name;\n  kernel_name.type = Experimental::ValueType::kokkos_value_string;\n  kernel_name.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_name.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_unbounded;\n\n  std::array<std::string, 4> candidate_values = {\n      \"parallel_for\",\n      \"parallel_reduce\",\n      \"parallel_scan\",\n      \"parallel_copy\",\n  };\n\n  Experimental::SetOrRange kernel_type_variable_candidates =\n      Experimental::make_candidate_set(4, candidate_values.data());\n\n  Experimental::kernel_name_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_name\", kernel_name);\n\n  Experimental::VariableInfo kernel_type;\n  kernel_type.type = Experimental::ValueType::kokkos_value_string;\n  kernel_type.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_type.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_set;\n  kernel_type.candidates = kernel_type_variable_candidates;\n  Experimental::kernel_type_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_type\", kernel_type);\n\n#endif\n\n  Experimental::no_profiling.init     = nullptr;\n  Experimental::no_profiling.finalize = nullptr;\n\n  Experimental::no_profiling.begin_parallel_for    = nullptr;\n  Experimental::no_profiling.begin_parallel_scan   = nullptr;\n  Experimental::no_profiling.begin_parallel_reduce = nullptr;\n  Experimental::no_profiling.end_parallel_scan     = nullptr;\n  Experimental::no_profiling.end_parallel_for      = nullptr;\n  Experimental::no_profiling.end_parallel_reduce   = nullptr;\n\n  Experimental::no_profiling.push_region     = nullptr;\n  Experimental::no_profiling.pop_region      = nullptr;\n  Experimental::no_profiling.allocate_data   = nullptr;\n  Experimental::no_profiling.deallocate_data = nullptr;\n\n  Experimental::no_profiling.begin_deep_copy = nullptr;\n  Experimental::no_profiling.end_deep_copy   = nullptr;\n\n  Experimental::no_profiling.create_profile_section  = nullptr;\n  Experimental::no_profiling.start_profile_section   = nullptr;\n  Experimental::no_profiling.stop_profile_section    = nullptr;\n  Experimental::no_profiling.destroy_profile_section = nullptr;\n\n  Experimental::no_profiling.profile_event = nullptr;\n\n  Experimental::no_profiling.declare_input_type    = nullptr;\n  Experimental::no_profiling.declare_output_type   = nullptr;\n  Experimental::no_profiling.request_output_values = nullptr;\n  Experimental::no_profiling.end_tuning_context    = nullptr;\n#ifdef KOKKOS_ENABLE_LIBDL\n  free(envProfileCopy);\n#endif\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if (is_finalized) return;\n  is_finalized = 1;\n\n  if (Experimental::current_callbacks.finalize != nullptr) {\n    (*Experimental::current_callbacks.finalize)();\n\n    Experimental::pause_tools();\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  // clean up string candidate set\n  for (auto& metadata_pair : Experimental::variable_metadata) {\n    auto metadata = metadata_pair.second;\n    if ((metadata.type == Experimental::ValueType::kokkos_value_string) &&\n        (metadata.valueQuantity ==\n         Experimental::CandidateValueType::kokkos_value_set)) {\n      auto candidate_set = metadata.candidates.set;\n      delete[] candidate_set.values.string_value;\n    }\n  }\n#endif\n}\n\nvoid syncDualView(const std::string& label, const void* const ptr,\n                  bool to_device) {\n  if (Experimental::current_callbacks.sync_dual_view != nullptr) {\n    (*Experimental::current_callbacks.sync_dual_view)(label.c_str(), ptr,\n                                                      to_device);\n  }\n}\nvoid modifyDualView(const std::string& label, const void* const ptr,\n                    bool on_device) {\n  if (Experimental::current_callbacks.modify_dual_view != nullptr) {\n    (*Experimental::current_callbacks.modify_dual_view)(label.c_str(), ptr,\n                                                        on_device);\n  }\n}\n\n}  // namespace Tools\n\nnamespace Tools {\nnamespace Experimental {\nvoid set_init_callback(initFunction callback) {\n  current_callbacks.init = callback;\n}\nvoid set_finalize_callback(finalizeFunction callback) {\n  current_callbacks.finalize = callback;\n}\nvoid set_begin_parallel_for_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_for = callback;\n}\nvoid set_end_parallel_for_callback(endFunction callback) {\n  current_callbacks.end_parallel_for = callback;\n}\nvoid set_begin_parallel_reduce_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_reduce = callback;\n}\nvoid set_end_parallel_reduce_callback(endFunction callback) {\n  current_callbacks.end_parallel_reduce = callback;\n}\nvoid set_begin_parallel_scan_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_scan = callback;\n}\nvoid set_end_parallel_scan_callback(endFunction callback) {\n  current_callbacks.end_parallel_scan = callback;\n}\nvoid set_push_region_callback(pushFunction callback) {\n  current_callbacks.push_region = callback;\n}\nvoid set_pop_region_callback(popFunction callback) {\n  current_callbacks.pop_region = callback;\n}\nvoid set_allocate_data_callback(allocateDataFunction callback) {\n  current_callbacks.allocate_data = callback;\n}\nvoid set_deallocate_data_callback(deallocateDataFunction callback) {\n  current_callbacks.deallocate_data = callback;\n}\nvoid set_create_profile_section_callback(\n    createProfileSectionFunction callback) {\n  current_callbacks.create_profile_section = callback;\n}\nvoid set_start_profile_section_callback(startProfileSectionFunction callback) {\n  current_callbacks.start_profile_section = callback;\n}\nvoid set_stop_profile_section_callback(stopProfileSectionFunction callback) {\n  current_callbacks.stop_profile_section = callback;\n}\nvoid set_destroy_profile_section_callback(\n    destroyProfileSectionFunction callback) {\n  current_callbacks.destroy_profile_section = callback;\n}\nvoid set_profile_event_callback(profileEventFunction callback) {\n  current_callbacks.profile_event = callback;\n}\nvoid set_begin_deep_copy_callback(beginDeepCopyFunction callback) {\n  current_callbacks.begin_deep_copy = callback;\n}\nvoid set_end_deep_copy_callback(endDeepCopyFunction callback) {\n  current_callbacks.end_deep_copy = callback;\n}\nvoid set_begin_fence_callback(beginFenceFunction callback) {\n  current_callbacks.begin_fence = callback;\n}\nvoid set_end_fence_callback(endFenceFunction callback) {\n  current_callbacks.end_fence = callback;\n}\n\nvoid set_dual_view_sync_callback(dualViewSyncFunction callback) {\n  current_callbacks.sync_dual_view = callback;\n}\nvoid set_dual_view_modify_callback(dualViewModifyFunction callback) {\n  current_callbacks.modify_dual_view = callback;\n}\n\nvoid set_declare_output_type_callback(outputTypeDeclarationFunction callback) {\n  current_callbacks.declare_output_type = callback;\n}\nvoid set_declare_input_type_callback(inputTypeDeclarationFunction callback) {\n  current_callbacks.declare_input_type = callback;\n}\nvoid set_request_output_values_callback(requestValueFunction callback) {\n  current_callbacks.request_output_values = callback;\n}\nvoid set_end_context_callback(contextEndFunction callback) {\n  current_callbacks.end_tuning_context = callback;\n}\nvoid set_begin_context_callback(contextBeginFunction callback) {\n  current_callbacks.begin_tuning_context = callback;\n}\nvoid set_declare_optimization_goal_callback(\n    optimizationGoalDeclarationFunction callback) {\n  current_callbacks.declare_optimization_goal = callback;\n}\n\nvoid pause_tools() {\n  backup_callbacks  = current_callbacks;\n  current_callbacks = no_profiling;\n}\n\nvoid resume_tools() { current_callbacks = backup_callbacks; }\n\nEventSet get_callbacks() { return current_callbacks; }\nvoid set_callbacks(EventSet new_events) { current_callbacks = new_events; }\n}  // namespace Experimental\n}  // namespace Tools\n\nnamespace Profiling {\nbool profileLibraryLoaded() { return Kokkos::Tools::profileLibraryLoaded(); }\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelFor(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelReduce(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelScan(kernelPrefix, devID, kernelID);\n}\nvoid endParallelFor(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelFor(kernelID);\n}\nvoid endParallelReduce(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelReduce(kernelID);\n}\nvoid endParallelScan(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelScan(kernelID);\n}\n\nvoid pushRegion(const std::string& kName) { Kokkos::Tools::pushRegion(kName); }\nvoid popRegion() { Kokkos::Tools::popRegion(); }\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  Kokkos::Tools::createProfileSection(sectionName, secID);\n}\nvoid destroyProfileSection(const uint32_t secID) {\n  Kokkos::Tools::destroyProfileSection(secID);\n}\n\nvoid startSection(const uint32_t secID) { Kokkos::Tools::startSection(secID); }\n\nvoid stopSection(const uint32_t secID) { Kokkos::Tools::stopSection(secID); }\n\nvoid markEvent(const std::string& eventName) {\n  Kokkos::Tools::markEvent(eventName);\n}\nvoid allocateData(const SpaceHandle handle, const std::string name,\n                  const void* data, const uint64_t size) {\n  Kokkos::Tools::allocateData(handle, name, data, size);\n}\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  Kokkos::Tools::deallocateData(space, label, ptr, size);\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  Kokkos::Tools::beginDeepCopy(dst_space, dst_label, dst_ptr, src_space,\n                               src_label, src_ptr, size);\n}\nvoid endDeepCopy() { Kokkos::Tools::endDeepCopy(); }\n\nvoid finalize() { Kokkos::Tools::finalize(); }\nvoid initialize() { Kokkos::Tools::initialize(); }\n\nSpaceHandle make_space_handle(const char* space_name) {\n  return Kokkos::Tools::make_space_handle(space_name);\n}\n}  // namespace Profiling\n\n}  // namespace Kokkos\n\n// Tuning\n\nnamespace Kokkos {\nnamespace Tools {\nnamespace Experimental {\nstatic size_t& get_context_counter() {\n  static size_t x;\n  return x;\n}\nstatic size_t& get_variable_counter() {\n  static size_t x;\n  return ++x;\n}\n\nsize_t get_new_context_id() { return ++get_context_counter(); }\nsize_t get_current_context_id() { return get_context_counter(); }\nvoid decrement_current_context_id() { --get_context_counter(); }\nsize_t get_new_variable_id() { return get_variable_counter(); }\n\nsize_t declare_output_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_output_type != nullptr) {\n    (*Experimental::current_callbacks.declare_output_type)(variableName.c_str(),\n                                                           variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nsize_t declare_input_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_input_type != nullptr) {\n    (*Experimental::current_callbacks.declare_input_type)(variableName.c_str(),\n                                                          variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nvoid set_input_values(size_t contextId, size_t count, VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (features_per_context.find(contextId) == features_per_context.end()) {\n    features_per_context[contextId] = std::unordered_set<size_t>();\n  }\n  for (size_t x = 0; x < count; ++x) {\n    values[x].metadata = &variable_metadata[values[x].type_id];\n    features_per_context[contextId].insert(values[x].type_id);\n    active_features.insert(values[x].type_id);\n    feature_values[values[x].type_id] = values[x];\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n#include <iostream>\nvoid request_output_values(size_t contextId, size_t count,\n                           VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  std::vector<size_t> context_ids;\n  std::vector<VariableValue> context_values;\n  for (auto id : active_features) {\n    context_values.push_back(feature_values[id]);\n  }\n  if (Experimental::current_callbacks.request_output_values != nullptr) {\n    for (size_t x = 0; x < count; ++x) {\n      values[x].metadata = &variable_metadata[values[x].type_id];\n    }\n    (*Experimental::current_callbacks.request_output_values)(\n        contextId, context_values.size(), context_values.data(), count, values);\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n\n#ifdef KOKKOS_ENABLE_TUNING\nstatic std::unordered_map<size_t, size_t> optimization_goals;\n#endif\n\nvoid begin_context(size_t contextId) {\n  if (Experimental::current_callbacks.begin_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.begin_tuning_context)(contextId);\n  }\n}\nvoid end_context(size_t contextId) {\n#ifdef KOKKOS_ENABLE_TUNING\n  for (auto id : features_per_context[contextId]) {\n    active_features.erase(id);\n  }\n  if (Experimental::current_callbacks.end_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.end_tuning_context)(\n        contextId, feature_values[optimization_goals[contextId]]);\n  }\n  optimization_goals.erase(contextId);\n  decrement_current_context_id();\n#else\n  (void)contextId;\n#endif\n}\n\nbool have_tuning_tool() {\n#ifdef KOKKOS_ENABLE_TUNING\n  return (Experimental::current_callbacks.request_output_values != nullptr);\n#else\n  return false;\n#endif\n}\n\nVariableValue make_variable_value(size_t id, int64_t val) {\n  VariableValue variable_value;\n  variable_value.type_id         = id;\n  variable_value.value.int_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, double val) {\n  VariableValue variable_value;\n  variable_value.type_id            = id;\n  variable_value.value.double_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, const std::string& val) {\n  VariableValue variable_value;\n  variable_value.type_id = id;\n  strncpy(variable_value.value.string_value, val.c_str(),\n          KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  return variable_value;\n}\nSetOrRange make_candidate_set(size_t size, std::string* data) {\n  SetOrRange value_set;\n  value_set.set.values.string_value = new TuningString[size];\n  for (size_t x = 0; x < size; ++x) {\n    strncpy(value_set.set.values.string_value[x], data[x].c_str(),\n            KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  }\n  value_set.set.size = size;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, int64_t* data) {\n  SetOrRange value_set;\n  value_set.set.size             = size;\n  value_set.set.values.int_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, double* data) {\n  SetOrRange value_set;\n  value_set.set.size                = size;\n  value_set.set.values.double_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_range(double lower, double upper, double step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.double_value = lower;\n  value_range.range.upper.double_value = upper;\n  value_range.range.step.double_value  = step;\n  value_range.range.openLower          = openLower;\n  value_range.range.openUpper          = openUpper;\n  return value_range;\n}\n\nSetOrRange make_candidate_range(int64_t lower, int64_t upper, int64_t step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.int_value = lower;\n  value_range.range.upper.int_value = upper;\n  value_range.range.step.int_value  = step;\n  value_range.range.openLower       = openLower;\n  value_range.range.openUpper       = openUpper;\n  return value_range;\n}\n\nsize_t get_new_context_id();\nsize_t get_current_context_id();\nvoid decrement_current_context_id();\nsize_t get_new_variable_id();\nvoid declare_optimization_goal(const size_t context,\n                               const OptimizationGoal& goal) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_optimization_goal != nullptr) {\n    (*Experimental::current_callbacks.declare_optimization_goal)(context, goal);\n  }\n  optimization_goals[context] = goal.type_id;\n#else\n  (void)context;\n  (void)goal;\n#endif\n}\n}  // end namespace Experimental\n}  // end namespace Tools\n\n}  // end namespace Kokkos\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/lib/kokkos/core/unit_test/tools/TestAllCalls.cpp": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n// This file calls most of the basic Kokkos primitives. When combined with a\n// testing library this tests that our shared-library loading based profiling\n// mechanisms work\n\n#include <iostream>\n#include <Kokkos_Core.hpp>\n\nint main() {\n  Kokkos::initialize();\n  {\n    // This test only uses host kernel launch mechanisms. This is to allow for\n    // the test to run on platforms where CUDA lambda launch isn't supported.\n    // This is safe because this test only seeks to test that the dlsym-based\n    // tool loading mechanisms work, all of which happens completely\n    // independently of the enabled backends\n    using execution_space = Kokkos::DefaultHostExecutionSpace;\n    using memory_space    = typename execution_space::memory_space;\n    Kokkos::View<int*, memory_space> src_view(\"source\", 10);\n    Kokkos::View<int*, memory_space> dst_view(\"destination\", 10);\n    Kokkos::deep_copy(dst_view, src_view);\n    Kokkos::parallel_for(\"parallel_for\",\n                         Kokkos::RangePolicy<execution_space>(0, 1),\n                         [=](int i) { (void)i; });\n    int result;\n    Kokkos::parallel_reduce(\n        \"parallel_reduce\", Kokkos::RangePolicy<execution_space>(0, 1),\n        [=](int i, int& hold_result) { hold_result += i; }, result);\n    Kokkos::parallel_scan(\"parallel_scan\",\n                          Kokkos::RangePolicy<execution_space>(0, 1),\n                          [=](const int i, int& hold_result, const bool final) {\n                            if (final) {\n                              hold_result += i;\n                            }\n                          });\n    Kokkos::Profiling::pushRegion(\"push_region\");\n    Kokkos::Profiling::popRegion();\n    uint32_t sectionId;\n    Kokkos::Profiling::createProfileSection(\"created_section\", &sectionId);\n    Kokkos::Profiling::startSection(sectionId);\n    Kokkos::Profiling::stopSection(sectionId);\n    Kokkos::Profiling::destroyProfileSection(sectionId);\n    Kokkos::Profiling::markEvent(\"profiling_event\");\n  }\n  Kokkos::finalize();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/lib/molfile/Makefile.lammps": "# This file contains the hooks to build and link LAMMPS with the VMD\n# molfile plugins described here:\n# \n# http://www.ks.uiuc.edu/Research/vmd/plugins/molfile\n# \n# When you build LAMMPS with the USER-MOLFILE package installed, it will\n# use the 3 settings in this file.  They should be set as follows.\n# \n# The molfile_SYSINC setting is to point to the folder with the VMD\n# plugin headers. By default it points to bundled headers in this folder\n# \n# The molfile_SYSLIB setting is for a system dynamic loading library\n# that will be used to load the molfile plugins.  It contains functions\n# like dlopen(), dlsym() and so on for dynamic linking of executable\n# code into an executable.  For Linux and most current Unix-like\n# operating systems, the setting of \"-ldl\" will work.  On some platforms\n# you may need \"-ldld\".  For compilation on Windows, a different\n# mechanism is used that is part of the Windows programming environment\n# and thus molfile_SYSLIB can be left blank.\n# \n# The molfile_SYSINC and molfile_SYSPATH variables do not typically need\n# to be set.  If the dl library is not in a place the linker can find\n# it, specify its directory via the molfile_SYSPATH variable, e.g.\n# -Ldir.\n\n# -----------------------------------------------------------\n\n# Settings that the LAMMPS build will import when this package is installed\n\n# change this to -I/path/to/your/lib/vmd/plugins/include if the bundled\n# header files are incompatible with your VMD plugsins\nmolfile_SYSINC =-I../../lib/molfile\n#\nifneq ($(LIBOBJDIR),/Obj_mingw32)\nifneq ($(LIBOBJDIR),/Obj_mingw64)\nifneq ($(LIBOBJDIR),/Obj_mingw32-mpi)\nifneq ($(LIBOBJDIR),/Obj_mingw64-mpi)\nmolfile_SYSLIB = -ldl\nendif\nendif\nendif\nendif\nmolfile_SYSPATH =\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/COUPLE/plugin/liblammpsplugin.c": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/*\n   Variant of the C style library interface to LAMMPS\n   that uses a shared library and dynamically opens it,\n   so this can be used as a prototype code to integrate\n   a LAMMPS plugin to some other software.\n*/\n\n#include \"library.h\"\n#include \"liblammpsplugin.h\"\n#include <stdlib.h>\n#include <dlfcn.h>\n\nliblammpsplugin_t *liblammpsplugin_load(const char *lib)\n{\n  liblammpsplugin_t *lmp;\n  void *handle;\n\n  if (lib == NULL) return NULL;\n  handle = dlopen(lib,RTLD_NOW|RTLD_GLOBAL);\n  if (handle == NULL) return NULL;\n  \n  lmp = (liblammpsplugin_t *) malloc(sizeof(liblammpsplugin_t));\n  lmp->handle = handle;\n\n#define ADDSYM(symbol) lmp->symbol = dlsym(handle,\"lammps_\" #symbol)\n  ADDSYM(open);\n  ADDSYM(open_no_mpi);\n  ADDSYM(close);\n  ADDSYM(version);\n  ADDSYM(file);\n  ADDSYM(command);\n  ADDSYM(commands_list);\n  ADDSYM(commands_string);\n  ADDSYM(free);\n  ADDSYM(extract_setting);\n  ADDSYM(extract_global);\n  ADDSYM(extract_box);\n  ADDSYM(extract_atom);\n  ADDSYM(extract_compute);\n  ADDSYM(extract_fix);\n  ADDSYM(extract_variable);\n\n  ADDSYM(get_thermo);\n  ADDSYM(get_natoms);\n\n  ADDSYM(set_variable);\n  ADDSYM(reset_box);\n\n  ADDSYM(gather_atoms);\n  ADDSYM(gather_atoms_concat);\n  ADDSYM(gather_atoms_subset);\n  ADDSYM(scatter_atoms);\n  ADDSYM(scatter_atoms_subset);\n\n  ADDSYM(set_fix_external_callback);\n\n  ADDSYM(config_has_package);\n  ADDSYM(config_package_count);\n  ADDSYM(config_package_name);\n  ADDSYM(config_has_gzip_support);\n  ADDSYM(config_has_png_support);\n  ADDSYM(config_has_jpeg_support);\n  ADDSYM(config_has_ffmpeg_support);\n  ADDSYM(config_has_exceptions);\n  ADDSYM(create_atoms);\n#ifdef LAMMPS_EXCEPTIONS\n  lmp->has_exceptions = 1;\n  ADDSYM(has_error);\n  ADDSYM(get_last_error_message);\n#else\n  lmp->has_exceptions = 0;\n  lmp->has_error = NULL;\n  lmp->get_last_error_message = NULL;\n#endif\n  return lmp;\n}\n\nint liblammpsplugin_release(liblammpsplugin_t *lmp)\n{\n  if (lmp == NULL) return 1;\n  if (lmp->handle == NULL) return 2;\n\n  dlclose(lmp->handle);\n  free((void *)lmp);\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/.git/objects/pack/pack-e99a45b5aed95b253bdeab8f45277f0631f7e7af.pack",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/.git/objects/pack/pack-e99a45b5aed95b253bdeab8f45277f0631f7e7af.idx",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/SPIN/read_restart/restart_hcp_cobalt.equil",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/local.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/local.001300.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/global.089000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/local.000400.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/global.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/global.041000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/global.048000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/hyper/global.045000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/mliap/relu1hidden.mliap.pytorch.model.pt",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/mscg/output_9Jan17/x.out",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/cgsdk/sds-monolayer/data.sds.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/cgsdk/peg-verlet/data.pegc12e8.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/phonon/3-3D-FCC-Cu-EAM/CuPhonon.bin.6500000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/phonon/4-Graphene/Graphene.bin.6000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/phonon/1-1D-mono/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/phonon/2-1D-diatomic/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/diffraction/Output/bulkNi_001.saed.0_VisIt_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/reaction/nylon,6-6_melt/large_nylon_melt.data.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/manifold/diffusion/msd_plot2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/manifold/diffusion/msd.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/manifold/energy/energy_conservation.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/manifold/energy/energy_conservation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/mesont/C_10_10.mesocnt",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/examples/USER/mesont/TABTP_10_10.mesont",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/lammps.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/lmpfile.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/64x64/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/22x22/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/48x48/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/16x16/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/32x32/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/lammps-shell/icons/hicolor/128x128/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/createatoms/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/xmgrace/lammpsplot.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/emacs/lammps-mode.el",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/i-pi/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/polybond/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/matlab/README.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/tools/pymol_asphere/doc/asphere_vis.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/balance_uniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/screenshot_pymol.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/screenshot_gl.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/saed_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/balance_rcb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/saed_ewald_intersect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/sinusoid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/xrd_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/balance_nonuniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/screenshot_vmd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/gran_mixer.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/dump2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/hop2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/dump1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/gran_funnel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/hop1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/screenshot_atomeye.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/osinfo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/wsl_install2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/powershell.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/wsl_integration.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/first_login.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/windows_update.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/wsl_install3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/updates.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/wsl_install1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/windows_firewall.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/ubuntu_in_store.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/img/wsl_tutorial/compilation_result.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/colvars-refman-lammps.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/pair_resquared_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/PDLammps_overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/USER-CGDNA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/SMD_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/PDLammps_EPS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/pair_gayberne_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/PDLammps_VES.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/kspace.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/PDF/SPH_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_pull_request_feature_branch1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/ccmake-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/user_intel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/zeeman_langevin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/examples_edpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/atc_nanotube.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_merged.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_additional_changes.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/qbmsst_shock.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/examples_mdpd_first.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/dreiding_hbond.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/qbmsst_init.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/cmake-gui-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pylammps_mc_energies_plot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/coverage-overview-manybody.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_edits_maintainers.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/coverage-file-branches.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/examples_mdpd_last.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/improper_distance.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/umbrella.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/lj_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/ccmake-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_automated_checks_passed.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_new_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/cmake-codeblocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/fix_wall_ees_image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/rhodo_staggered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/dynamical_matrix_phonons.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pimd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/offload_knc.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/ccmake-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request7.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/coul_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pylammps_mc_minimum.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/dihedral_sign.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pylammps_mc_disordered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/lammps-classes.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/examples_mdpd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_https_block.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_create_new_pull_request1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/uef_frames.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_changes_others.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/coverage-overview-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pair_body_rounded.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/examples_tdpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/coverage-file-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_create_new_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/python-invoke-lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/cmake-gui-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/third_order_force_constant.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/fix_integration_spin_stdecomposition.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/lammps-invoke-python.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request5.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pair_atm_dia.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request6.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_branch.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/cmake-gui-popup.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pylammps_dihedral.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/bondswap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_reverse_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/WF_LJ.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_automated_checks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pylammps-invoke-lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/tutorial_steve_assignee.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/dihedral_spherical_angles.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/src/JPG/pair_cosine_squared_graphs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_static/lammps-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_static/lammps.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/FontAwesome.otf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/nl/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/es/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/pt_BR/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/ru/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/et/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/tr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/fr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/de/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/en/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/zh_CN/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/sv/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-z5frtag7y27lqs4wtq43p4k7pxiusske/spack-src/doc/doxygen/lammps-logo.png"
    ],
    "total_files": 10155
}