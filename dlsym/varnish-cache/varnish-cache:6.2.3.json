{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.2.3-ymlgb5n3vpyjftra6mshxv2pw3hrlozu/spack-src/bin/varnishd/storage/storage_umem.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2011 Varnish Software AS\n * Copyright 2017 UPLEX - Nils Goroll Systemoptimierung\n * All rights reserved.\n *\n * Authors: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\t    Nils Goroll <nils.goroll@uplex.de>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Storage method based on libumem\n */\n\n#include \"config.h\"\n\n#if defined(HAVE_UMEM_H)\n\n#include \"cache/cache_varnishd.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <umem.h>\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n\n#include \"storage/storage.h\"\n#include \"storage/storage_simple.h\"\n\n#include \"vnum.h\"\n#include \"common/heritage.h\"\n\n#include \"VSC_smu.h\"\n\nstruct smu_sc {\n\tunsigned\t\tmagic;\n#define SMU_SC_MAGIC\t\t0x7695f68e\n\tstruct lock\t\tsmu_mtx;\n\tsize_t\t\t\tsmu_max;\n\tsize_t\t\t\tsmu_alloc;\n\tstruct VSC_smu\t\t*stats;\n\tumem_cache_t\t\t*smu_cache;\n};\n\nstruct smu {\n\tunsigned\t\tmagic;\n#define SMU_MAGIC\t\t0x3773300c\n\tstruct storage\t\ts;\n\tsize_t\t\t\tsz;\n\tstruct smu_sc\t\t*sc;\n};\n\n/*\n * We only want the umem slab allocator for cache storage, not also as a\n * substitute for malloc and friends. So we don't link with libumem, but\n * use dlopen/dlsym to get the slab allocator interface into function\n * pointers.\n */\ntypedef void * (*umem_alloc_f)(size_t size, int flags);\ntypedef void (*umem_free_f)(void *buf, size_t size);\ntypedef umem_cache_t * (*umem_cache_create_f)(char *debug_name, size_t bufsize,\n    size_t align, umem_constructor_t *constructor,\n    umem_destructor_t *destructor, umem_reclaim_t *reclaim,\n    void *callback_data, vmem_t *source, int cflags);\ntypedef void (*umem_cache_destroy_f)(umem_cache_t *cache);\ntypedef void * (*umem_cache_alloc_f)(umem_cache_t *cache, int flags);\ntypedef void (*umem_cache_free_f)(umem_cache_t *cache, void *buffer);\n\nstatic void *libumem_hndl = NULL;\nstatic umem_alloc_f umem_allocf = NULL;\nstatic umem_free_f umem_freef = NULL;\nstatic umem_cache_create_f umem_cache_createf = NULL;\nstatic umem_cache_destroy_f umem_cache_destroyf = NULL;\nstatic umem_cache_alloc_f umem_cache_allocf = NULL;\nstatic umem_cache_free_f umem_cache_freef = NULL;\n\nstatic const char * const def_umem_options = \"perthread_cache=0,backend=mmap\";\nstatic const char * const env_umem_options = \"UMEM_OPTIONS\";\n\n/* init required per cache get:\n   smu->sz = size\n   smu->s.ptr;\n   smu->s.space = size\n*/\n\nstatic inline void\nsmu_smu_init(struct smu *smu, struct smu_sc *sc)\n{\n\tINIT_OBJ(smu, SMU_MAGIC);\n\tsmu->s.magic = STORAGE_MAGIC;\n\tsmu->s.priv = smu;\n\tsmu->sc = sc;\n}\n\nstatic int v_matchproto_(umem_constructor_t)\nsmu_smu_constructor(void *buffer, void *callback_data, int flags)\n{\n\tstruct smu *smu = buffer;\n\tstruct smu_sc *sc;\n\n\t(void) flags;\n\tCAST_OBJ_NOTNULL(sc, callback_data, SMU_SC_MAGIC);\n\tsmu_smu_init(smu, sc);\n\treturn (0);\n}\n\nstatic void v_matchproto_(umem_destructor_t)\n\tsmu_smu_destructor(void *buffer, void *callback_data)\n{\n\tstruct smu *smu;\n\tstruct smu_sc *sc;\n\n\tCAST_OBJ_NOTNULL(smu, buffer, SMU_MAGIC);\n\tCAST_OBJ_NOTNULL(sc, callback_data, SMU_SC_MAGIC);\n\tCHECK_OBJ_NOTNULL(&(smu->s), STORAGE_MAGIC);\n\tassert(smu->s.priv == smu);\n\tassert(smu->sc == sc);\n}\n\nstatic struct VSC_lck *lck_smu;\n\nstatic struct storage * v_matchproto_(sml_alloc_f)\nsmu_alloc(const struct stevedore *st, size_t size)\n{\n\tstruct smu_sc *smu_sc;\n\tstruct smu *smu = NULL;\n\tvoid *p;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tLck_Lock(&smu_sc->smu_mtx);\n\tsmu_sc->stats->c_req++;\n\tif (smu_sc->smu_alloc + size > smu_sc->smu_max) {\n\t\tsmu_sc->stats->c_fail++;\n\t\tsize = 0;\n\t} else {\n\t\tsmu_sc->smu_alloc += size;\n\t\tsmu_sc->stats->c_bytes += size;\n\t\tsmu_sc->stats->g_alloc++;\n\t\tsmu_sc->stats->g_bytes += size;\n\t\tif (smu_sc->smu_max != SIZE_MAX)\n\t\t\tsmu_sc->stats->g_space -= size;\n\t}\n\tLck_Unlock(&smu_sc->smu_mtx);\n\n\tif (size == 0)\n\t\treturn (NULL);\n\n\t/*\n\t * Do not collaps the smu allocation with smu->s.ptr: it is not\n\t * a good idea.  Not only would it make ->trim impossible,\n\t * performance-wise it would be a catastropy with chunksized\n\t * allocations growing another full page, just to accommodate the smu.\n\t */\n\n\tp = umem_allocf(size, UMEM_DEFAULT);\n\tif (p != NULL) {\n\t\tAN(smu_sc->smu_cache);\n\t\tsmu = umem_cache_allocf(smu_sc->smu_cache, UMEM_DEFAULT);\n\t\tif (smu != NULL)\n\t\t\tsmu->s.ptr = p;\n\t\telse\n\t\t\tumem_freef(p, size);\n\t}\n\tif (smu == NULL) {\n\t\tLck_Lock(&smu_sc->smu_mtx);\n\t\t/*\n\t\t * XXX: Not nice to have counters go backwards, but we do\n\t\t * XXX: Not want to pick up the lock twice just for stats.\n\t\t */\n\t\tsmu_sc->stats->c_fail++;\n\t\tsmu_sc->smu_alloc -= size;\n\t\tsmu_sc->stats->c_bytes -= size;\n\t\tsmu_sc->stats->g_alloc--;\n\t\tsmu_sc->stats->g_bytes -= size;\n\t\tif (smu_sc->smu_max != SIZE_MAX)\n\t\t\tsmu_sc->stats->g_space += size;\n\t\tLck_Unlock(&smu_sc->smu_mtx);\n\t\treturn (NULL);\n\t}\n\tsmu->sz = size;\n\tsmu->s.space = size;\n\treturn (&smu->s);\n}\n\nstatic void v_matchproto_(sml_free_f)\nsmu_free(struct storage *s)\n{\n\tstruct smu *smu;\n\tstruct smu_sc *sc;\n\n\tCHECK_OBJ_NOTNULL(s, STORAGE_MAGIC);\n\tCAST_OBJ_NOTNULL(smu, s->priv, SMU_MAGIC);\n\tCAST_OBJ_NOTNULL(sc, smu->sc, SMU_SC_MAGIC);\n\n\tLck_Lock(&sc->smu_mtx);\n\tsc->smu_alloc -= smu->sz;\n\tsc->stats->g_alloc--;\n\tsc->stats->g_bytes -= smu->sz;\n\tsc->stats->c_freed += smu->sz;\n\tif (sc->smu_max != SIZE_MAX)\n\t\tsc->stats->g_space += smu->sz;\n\tLck_Unlock(&sc->smu_mtx);\n\n\tumem_freef(smu->s.ptr, smu->sz);\n\tsmu_smu_init(smu, sc);\n\tumem_cache_freef(sc->smu_cache, smu);\n}\n\nstatic VCL_BYTES v_matchproto_(stv_var_used_space)\nsmu_used_space(const struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\treturn (smu_sc->smu_alloc);\n}\n\nstatic VCL_BYTES v_matchproto_(stv_var_free_space)\nsmu_free_space(const struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\treturn (smu_sc->smu_max - smu_sc->smu_alloc);\n}\n\nstatic void\nsmu_umem_loaded_warn(void)\n{\n\tconst char *e;\n\tstatic int warned = 0;\n\n\tif (warned++)\n\t\treturn;\n\n\tfprintf(stderr, \"notice:\\tlibumem was already found to be loaded\\n\"\n\t\t\"\\tand will likely be used for all allocations\\n\");\n\n\te = getenv(env_umem_options);\n\tif (e == NULL || ! strstr(e, def_umem_options))\n\t\tfprintf(stderr, \"\\tit is recommended to set %s=%s \"\n\t\t\t\"before starting varnish\\n\",\n\t\t\tenv_umem_options, def_umem_options);\n}\n\nstatic int\nsmu_umem_loaded(void)\n{\n\tvoid *h = NULL;\n\n\th = dlopen(\"libumem.so\", RTLD_NOLOAD);\n\tif (h) {\n\t\tAZ(dlclose(h));\n\t\treturn (1);\n\t}\n\n\th = dlsym(RTLD_DEFAULT, \"umem_alloc\");\n\tif (h)\n\t\treturn (1);\n\n\treturn (0);\n}\n\nstatic void\nsmu_init(struct stevedore *parent, int ac, char * const *av)\n{\n\tstatic int inited = 0;\n\tconst char *e;\n\tuintmax_t u;\n\tstruct smu_sc *sc;\n\n\tASSERT_MGT();\n\tALLOC_OBJ(sc, SMU_SC_MAGIC);\n\tAN(sc);\n\tsc->smu_max = SIZE_MAX;\n\tassert(sc->smu_max == SIZE_MAX);\n\tparent->priv = sc;\n\n\tAZ(av[ac]);\n\tif (ac > 1)\n\t\tARGV_ERR(\"(-sumem) too many arguments\\n\");\n\n\tif (ac == 1 && *av[0] != '\\0') {\n\t\te = VNUM_2bytes(av[0], &u, 0);\n\t\tif (e != NULL)\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": %s\\n\", av[0], e);\n\t\tif ((u != (uintmax_t)(size_t)u))\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": too big\\n\", av[0]);\n\t\tif (u < 1024*1024)\n\t\t\tARGV_ERR(\"(-sumem) size \\\"%s\\\": too small, \"\n\t\t\t\t \"did you forget to specify M or G?\\n\", av[0]);\n\t\tsc->smu_max = u;\n\t}\n\n\tif (inited++)\n\t\treturn;\n\n\tif (smu_umem_loaded())\n\t\tsmu_umem_loaded_warn();\n\telse\n\t\tAZ(setenv(env_umem_options, def_umem_options, 0));\n\n\t/* Check if these load in the management process. */\n\t(void) dlerror();\n\tlibumem_hndl = dlmopen(LM_ID_NEWLM, \"libumem.so\", RTLD_LAZY);\n\tif (libumem_hndl == NULL)\n\t\tARGV_ERR(\"(-sumem) cannot open libumem.so: %s\", dlerror());\n\n#define DLSYM_UMEM(fptr,sym)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(void) dlerror();\t\t\t\t\t\\\n\t\tif (dlsym(libumem_hndl, #sym) == NULL)\t\t\t\\\n\t\t\tARGV_ERR(\"(-sumem) cannot find symbol \"\t\t\\\n\t\t\t\t #sym \": %s\",\t\t\t\t\\\n\t\t\t\t dlerror());\t\t\t\t\\\n\t\tfptr = NULL;\t\t\t\t\t\t\\\n\t} while(0)\n\n\tDLSYM_UMEM(umem_allocf, umem_alloc);\n\tDLSYM_UMEM(umem_freef, umem_free);\n\tDLSYM_UMEM(umem_cache_createf, umem_cache_create);\n\tDLSYM_UMEM(umem_cache_destroyf, umem_cache_destroy);\n\tDLSYM_UMEM(umem_cache_allocf, umem_cache_alloc);\n\tDLSYM_UMEM(umem_cache_freef, umem_cache_free);\n\n#undef DLSYM_UMEM\n\n\tAZ(dlclose(libumem_hndl));\n\tlibumem_hndl = NULL;\n}\n\n/*\n * Load the symbols for use in the child process, assert if they fail to load.\n */\nstatic void\nsmu_open_init(void)\n{\n\tstatic int inited = 0;\n\n\tif (inited++) {\n\t\tAN(libumem_hndl);\n\t\tAN(umem_allocf);\n\t\treturn;\n\t}\n\n\tif (smu_umem_loaded())\n\t\tsmu_umem_loaded_warn();\n\telse\n\t\tAN(getenv(env_umem_options));\n\n\tAZ(libumem_hndl);\n\tlibumem_hndl = dlopen(\"libumem.so\", RTLD_LAZY);\n\tAN(libumem_hndl);\n\n#define DLSYM_UMEM(fptr,sym)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tfptr = (sym ## _f) dlsym(libumem_hndl, #sym);\t\\\n\t\tAN(fptr);\t\t\t\t\t\\\n\t} while(0)\n\n\tDLSYM_UMEM(umem_allocf, umem_alloc);\n\tDLSYM_UMEM(umem_freef, umem_free);\n\tDLSYM_UMEM(umem_cache_createf, umem_cache_create);\n\tDLSYM_UMEM(umem_cache_destroyf, umem_cache_destroy);\n\tDLSYM_UMEM(umem_cache_allocf, umem_cache_alloc);\n\tDLSYM_UMEM(umem_cache_freef, umem_cache_free);\n\n#undef DLSYM_UMEM\n}\n\nstatic void v_matchproto_(storage_open_f)\nsmu_open(struct stevedore *st)\n{\n\tstruct smu_sc *smu_sc;\n\tchar ident[strlen(st->ident) + 1];\n\n\tASSERT_CLI();\n\tst->lru = LRU_Alloc();\n\tif (lck_smu == NULL)\n\t\tlck_smu = Lck_CreateClass(NULL, \"smu\");\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tLck_New(&smu_sc->smu_mtx, lck_smu);\n\tsmu_sc->stats = VSC_smu_New(NULL, NULL, st->ident);\n\tif (smu_sc->smu_max != SIZE_MAX)\n\t\tsmu_sc->stats->g_space = smu_sc->smu_max;\n\n\tsmu_open_init();\n\n\tAN(strcpy(ident, st->ident));\n\tsmu_sc->smu_cache = umem_cache_createf(ident,\n\t\t\t\t\t  sizeof(struct smu),\n\t\t\t\t\t  0,\t\t// align\n\t\t\t\t\t  smu_smu_constructor,\n\t\t\t\t\t  smu_smu_destructor,\n\t\t\t\t\t  NULL,\t\t// reclaim\n\t\t\t\t\t  smu_sc,\t// callback_data\n\t\t\t\t\t  NULL,\t\t// source\n\t\t\t\t\t  0\t\t// cflags\n\t\t);\n\tAN(smu_sc->smu_cache);\n}\n\nstatic void v_matchproto_(storage_close_f)\nsmu_close(const struct stevedore *st, int warn)\n{\n\tstruct smu_sc *smu_sc;\n\n\tASSERT_CLI();\n\n\tCAST_OBJ_NOTNULL(smu_sc, st->priv, SMU_SC_MAGIC);\n\tif (warn)\n\t\treturn;\n\tumem_cache_destroyf(smu_sc->smu_cache);\n\tsmu_sc->smu_cache = NULL;\n\n\t/*\n\t   XXX TODO?\n\t   - LRU_Free\n\t   - Lck Destroy\n\t*/\n}\n\nconst struct stevedore smu_stevedore = {\n\t.magic\t\t=\tSTEVEDORE_MAGIC,\n\t.name\t\t=\t\"umem\",\n\t.init\t\t=\tsmu_init,\n\t.open\t\t=\tsmu_open,\n\t.close\t\t=\tsmu_close,\n\t.sml_alloc\t=\tsmu_alloc,\n\t.sml_free\t=\tsmu_free,\n\t.allocobj\t=\tSML_allocobj,\n\t.panic\t\t=\tSML_panic,\n\t.methods\t=\t&SML_methods,\n\t.var_free_space =\tsmu_free_space,\n\t.var_used_space =\tsmu_used_space,\n};\n\n#endif /* HAVE_UMEM_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.2.3-ymlgb5n3vpyjftra6mshxv2pw3hrlozu/spack-src/bin/varnishd/cache/cache_vcl.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2016 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"config.h\"\n\n#include <dlfcn.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cache_varnishd.h\"\n#include \"common/heritage.h\"\n\n#include \"vcl.h\"\n\n#include \"cache_director.h\"\n#include \"cache_vcl.h\"\n#include \"vcli_serve.h\"\n#include \"vtim.h\"\n\nconst char * const VCL_TEMP_INIT = \"init\";\nconst char * const VCL_TEMP_COLD = \"cold\";\nconst char * const VCL_TEMP_WARM = \"warm\";\nconst char * const VCL_TEMP_BUSY = \"busy\";\nconst char * const VCL_TEMP_COOLING = \"cooling\";\n\n// not really a state\nstatic const char * const VCL_TEMP_LABEL = \"label\";\n\n/*\n * XXX: Presently all modifications to this list happen from the\n * CLI event-engine, so no locking is necessary\n */\nstatic VTAILQ_HEAD(, vcl)\tvcl_head =\n    VTAILQ_HEAD_INITIALIZER(vcl_head);\n\nstruct lock\t\tvcl_mtx;\nstruct vcl\t\t*vcl_active; /* protected by vcl_mtx */\n\nstatic struct vrt_ctx ctx_cli;\nstatic unsigned handling_cli;\nstatic struct ws ws_cli;\nstatic uintptr_t ws_snapshot_cli;\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Bo2Ctx(struct vrt_ctx *ctx, struct busyobj *bo)\n{\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tctx->vcl = bo->vcl;\n\tctx->vsl = bo->vsl;\n\tctx->http_bereq = bo->bereq;\n\tctx->http_beresp = bo->beresp;\n\tctx->bo = bo;\n\tctx->sp = bo->sp;\n\tctx->now = bo->t_prev;\n\tctx->ws = bo->ws;\n}\n\nvoid\nVCL_Req2Ctx(struct vrt_ctx *ctx, struct req *req)\n{\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\tCHECK_OBJ_ORNULL(req->topreq, REQ_MAGIC);\n\n\tctx->vcl = req->vcl;\n\tctx->vsl = req->vsl;\n\tctx->http_req = req->http;\n\tctx->http_req_top = req->topreq->http;\n\tctx->http_resp = req->resp;\n\tctx->req = req;\n\tctx->sp = req->sp;\n\tctx->now = req->t_prev;\n\tctx->ws = req->ws;\n}\n\n/*--------------------------------------------------------------------*/\n\nstruct vrt_ctx *\nVCL_Get_CliCtx(int msg)\n{\n\n\tASSERT_CLI();\n\tAZ(ctx_cli.handling);\n\tINIT_OBJ(&ctx_cli, VRT_CTX_MAGIC);\n\thandling_cli = 0;\n\tctx_cli.handling = &handling_cli;\n\tctx_cli.now = VTIM_real();\n\tif (msg) {\n\t\tctx_cli.msg = VSB_new_auto();\n\t\tAN(ctx_cli.msg);\n\t}\n\tctx_cli.ws = &ws_cli;\n\tWS_Assert(ctx_cli.ws);\n\treturn (&ctx_cli);\n}\n\nvoid\nVCL_Rel_CliCtx(struct vrt_ctx **ctx)\n{\n\n\tASSERT_CLI();\n\tassert(*ctx == &ctx_cli);\n\tAN((*ctx)->handling);\n\tif (ctx_cli.msg)\n\t\tVSB_destroy(&ctx_cli.msg);\n\tWS_Assert(ctx_cli.ws);\n\tWS_Reset(&ws_cli, ws_snapshot_cli);\n\tINIT_OBJ(*ctx, VRT_CTX_MAGIC);\n\t*ctx = NULL;\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic int\nvcl_send_event(VRT_CTX, enum vcl_event_e ev)\n{\n\tint r;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(ctx->vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(ctx->vcl->conf, VCL_CONF_MAGIC);\n\tassert(ev == VCL_EVENT_LOAD ||\n\t       ev == VCL_EVENT_WARM ||\n\t       ev == VCL_EVENT_COLD ||\n\t       ev == VCL_EVENT_DISCARD);\n\tassert(ev != VCL_EVENT_LOAD || ctx->method == VCL_MET_INIT);\n\tassert(ev != VCL_EVENT_DISCARD || ctx->method == VCL_MET_FINI);\n\tAN(ctx->handling);\n\t*ctx->handling = 0;\n\tAN(ctx->ws);\n\n\tif (ev == VCL_EVENT_LOAD || ev == VCL_EVENT_WARM)\n\t\tAN(ctx->msg);\n\n\tVCL_TaskEnter(ctx->vcl, cli_task_privs);\n\tr = ctx->vcl->conf->event_vcl(ctx, ev);\n\tVCL_TaskLeave(ctx->vcl, cli_task_privs);\n\n\tif (r && (ev == VCL_EVENT_COLD || ev == VCL_EVENT_DISCARD))\n\t\tWRONG(\"A VMOD cannot fail COLD or DISCARD events\");\n\n\treturn (r);\n}\n\n/*--------------------------------------------------------------------*/\n\nstruct vcl *\nvcl_find(const char *name)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tif (vcl->discard)\n\t\t\tcontinue;\n\t\tif (!strcmp(vcl->loaded_name, name))\n\t\t\treturn (vcl);\n\t}\n\treturn (NULL);\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Panic(struct vsb *vsb, const char *nm, const struct vcl *vcl)\n{\n\tint i;\n\n\tAN(vsb);\n\tif (vcl == NULL)\n\t\treturn;\n\tVSB_printf(vsb, \"%s = {\\n\", nm);\n\tVSB_indent(vsb, 2);\n\tPAN_CheckMagic(vsb, vcl, VCL_MAGIC);\n\tVSB_printf(vsb, \"name = \\\"%s\\\",\\n\", vcl->loaded_name);\n\tVSB_printf(vsb, \"busy = %u,\\n\", vcl->busy);\n\tVSB_printf(vsb, \"discard = %u,\\n\", vcl->discard);\n\tVSB_printf(vsb, \"state = %s,\\n\", vcl->state);\n\tVSB_printf(vsb, \"temp = %s,\\n\", (const volatile char *)vcl->temp);\n\tVSB_printf(vsb, \"conf = {\\n\");\n\tVSB_indent(vsb, 2);\n\tif (vcl->conf == NULL) {\n\t\tVSB_printf(vsb, \"conf = NULL\\n\");\n\t} else {\n\t\tPAN_CheckMagic(vsb, vcl->conf, VCL_CONF_MAGIC);\n\t\tVSB_printf(vsb, \"syntax = \\\"%u\\\",\\n\", vcl->conf->syntax);\n\t\tVSB_printf(vsb, \"srcname = {\\n\");\n\t\tVSB_indent(vsb, 2);\n\t\tfor (i = 0; i < vcl->conf->nsrc; ++i)\n\t\t\tVSB_printf(vsb, \"\\\"%s\\\",\\n\", vcl->conf->srcname[i]);\n\t\tVSB_indent(vsb, -2);\n\t\tVSB_printf(vsb, \"},\\n\");\n\t}\n\tVSB_indent(vsb, -2);\n\tVSB_printf(vsb, \"},\\n\");\n\tVSB_indent(vsb, -2);\n\tVSB_printf(vsb, \"},\\n\");\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nvcl_get(struct vcl **vcc, struct vcl *vcl)\n{\n\tAN(vcc);\n\n\tLck_Lock(&vcl_mtx);\n\tif (vcl == NULL)\n\t\tvcl = vcl_active; /* Sample vcl_active under lock to avoid\n\t\t\t\t   * race */\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tif (vcl->label == NULL) {\n\t\tAN(strcmp(vcl->state, VCL_TEMP_LABEL));\n\t\t*vcc = vcl;\n\t} else {\n\t\tAZ(strcmp(vcl->state, VCL_TEMP_LABEL));\n\t\t*vcc = vcl->label;\n\t}\n\tCHECK_OBJ_NOTNULL(*vcc, VCL_MAGIC);\n\tAZ((*vcc)->discard);\n\t(*vcc)->busy++;\n\tLck_Unlock(&vcl_mtx);\n\tAZ(errno=pthread_rwlock_rdlock(&(*vcc)->temp_rwl));\n\tassert(VCL_WARM(*vcc));\n\tAZ(errno=pthread_rwlock_unlock(&(*vcc)->temp_rwl));\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic int\nvcl_iterdir(struct cli *cli, const char *pat, const struct vcl *vcl,\n    vcl_be_func *func, void *priv)\n{\n\tint i, found = 0;\n\tstruct vcldir *vdir;\n\n\tVTAILQ_FOREACH(vdir, &vcl->director_list, list) {\n\t\tif (fnmatch(pat, vdir->cli_name, 0))\n\t\t\tcontinue;\n\t\tfound++;\n\t\ti = func(cli, vdir->dir, priv);\n\t\tif (i < 0)\n\t\t\treturn (i);\n\t\tfound += i;\n\t}\n\treturn (found);\n}\n\nint\nVCL_IterDirector(struct cli *cli, const char *pat,\n    vcl_be_func *func, void *priv)\n{\n\tint i, found = 0;\n\tstruct vsb *vsb;\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tif (pat == NULL || *pat == '\\0' || !strcmp(pat, \"*\")) {\n\t\t// all backends in active VCL\n\t\tVSB_printf(vsb, \"%s.*\", VCL_Name(vcl_active));\n\t\tvcl = vcl_active;\n\t} else if (strchr(pat, '.') == NULL) {\n\t\t// pattern applies to active vcl\n\t\tVSB_printf(vsb, \"%s.%s\", VCL_Name(vcl_active), pat);\n\t\tvcl = vcl_active;\n\t} else {\n\t\t// use pattern as is\n\t\tVSB_cat(vsb, pat);\n\t\tvcl = NULL;\n\t}\n\tAZ(VSB_finish(vsb));\n\tLck_Lock(&vcl_mtx);\n\tif (vcl != NULL) {\n\t\tfound = vcl_iterdir(cli, VSB_data(vsb), vcl, func, priv);\n\t} else {\n\t\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\t\ti = vcl_iterdir(cli, VSB_data(vsb), vcl, func, priv);\n\t\t\tif (i < 0) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfound += i;\n\t\t\t}\n\t\t}\n\t}\n\tLck_Unlock(&vcl_mtx);\n\tVSB_destroy(&vsb);\n\treturn (found);\n}\n\nstatic void\nvcl_BackendEvent(const struct vcl *vcl, enum vcl_event_e e)\n{\n\tstruct vcldir *vdir;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tAZ(vcl->busy);\n\n\tVTAILQ_FOREACH(vdir, &vcl->director_list, list)\n\t\tVDI_Event(vdir->dir, e);\n}\n\nstatic void\nvcl_KillBackends(struct vcl *vcl)\n{\n\tstruct vcldir *vdir;\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tAZ(vcl->busy);\n\tassert(VTAILQ_EMPTY(&vcl->ref_list));\n\twhile (1) {\n\t\tvdir = VTAILQ_FIRST(&vcl->director_list);\n\t\tif (vdir == NULL)\n\t\t\tbreak;\n\t\tVTAILQ_REMOVE(&vcl->director_list, vdir, list);\n\t\tREPLACE(vdir->cli_name, NULL);\n\t\tAN(vdir->methods->destroy);\n\t\tvdir->methods->destroy(vdir->dir);\n\t\tFREE_OBJ(vdir->dir);\n\t\tFREE_OBJ(vdir);\n\t}\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic struct vcl *\nVCL_Open(const char *fn, struct vsb *msg)\n{\n\tstruct vcl *vcl;\n\tvoid *dlh;\n\tstruct VCL_conf const *cnf;\n\n\tAN(fn);\n\tAN(msg);\n\n#ifdef RTLD_NOLOAD\n\t/* Detect bogus caching by dlopen(3) */\n\tdlh = dlopen(fn, RTLD_NOW | RTLD_NOLOAD);\n\tAZ(dlh);\n#endif\n\tdlh = dlopen(fn, RTLD_NOW | RTLD_LOCAL);\n\tif (dlh == NULL) {\n\t\tVSB_printf(msg, \"Could not load compiled VCL.\\n\");\n\t\tVSB_printf(msg, \"\\tdlopen() = %s\\n\", dlerror());\n\t\treturn (NULL);\n\t}\n\tcnf = dlsym(dlh, \"VCL_conf\");\n\tif (cnf == NULL) {\n\t\tVSB_printf(msg, \"Compiled VCL lacks metadata.\\n\");\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tif (cnf->magic != VCL_CONF_MAGIC) {\n\t\tVSB_printf(msg, \"Compiled VCL has mangled metadata.\\n\");\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tif (cnf->syntax < heritage.min_vcl || cnf->syntax > heritage.max_vcl) {\n\t\tVSB_printf(msg, \"Compiled VCL version (%.1f) not supported.\\n\",\n\t\t    .1 * cnf->syntax);\n\t\t(void)dlclose(dlh);\n\t\treturn (NULL);\n\t}\n\tALLOC_OBJ(vcl, VCL_MAGIC);\n\tAN(vcl);\n\tAZ(errno=pthread_rwlock_init(&vcl->temp_rwl, NULL));\n\tvcl->dlh = dlh;\n\tvcl->conf = cnf;\n\treturn (vcl);\n}\n\nstatic void\nVCL_Close(struct vcl **vclp)\n{\n\tstruct vcl *vcl;\n\n\tCHECK_OBJ_NOTNULL(*vclp, VCL_MAGIC);\n\tvcl = *vclp;\n\t*vclp = NULL;\n\tassert(VTAILQ_EMPTY(&vcl->vfps));\n\tassert(VTAILQ_EMPTY(&vcl->vdps));\n\tAZ(dlclose(vcl->dlh));\n\tAZ(errno=pthread_rwlock_destroy(&vcl->temp_rwl));\n\tFREE_OBJ(vcl);\n}\n\n/*--------------------------------------------------------------------\n * NB: This function is called from the test-load subprocess.\n */\n\nint\nVCL_TestLoad(const char *fn)\n{\n\tstruct vsb *vsb;\n\tstruct vcl *vcl;\n\tint retval = 0;\n\n\tAN(fn);\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tvcl = VCL_Open(fn, vsb);\n\tif (vcl == NULL) {\n\t\tAZ(VSB_finish(vsb));\n\t\tfprintf(stderr, \"%s\", VSB_data(vsb));\n\t\tretval = -1;\n\t} else\n\t\tVCL_Close(&vcl);\n\tVSB_destroy(&vsb);\n\treturn (retval);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nvcl_print_refs(VRT_CTX)\n{\n\tstruct vcl *vcl;\n\tstruct vclref *ref;\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(ctx->vcl, VCL_MAGIC);\n\tAN(ctx->msg);\n\tvcl = ctx->vcl;\n\tVSB_printf(ctx->msg, \"VCL %s is waiting for:\", vcl->loaded_name);\n\tLck_Lock(&vcl_mtx);\n\tVTAILQ_FOREACH(ref, &ctx->vcl->ref_list, list)\n\t\tVSB_printf(ctx->msg, \"\\n\\t- %s\", ref->desc);\n\tLck_Unlock(&vcl_mtx);\n}\n\nstatic int\nvcl_set_state(VRT_CTX, const char *state)\n{\n\tstruct vcl *vcl;\n\tint i = 0;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(ctx->vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(ctx->vcl->conf, VCL_CONF_MAGIC);\n\tAN(ctx->handling);\n\tAN(ctx->vcl);\n\tAN(state);\n\tassert(ctx->msg != NULL || *state == '0');\n\n\tvcl = ctx->vcl;\n\tAZ(errno=pthread_rwlock_wrlock(&vcl->temp_rwl));\n\tAN(vcl->temp);\n\n\tswitch (state[0]) {\n\tcase '0':\n\t\tif (vcl->temp == VCL_TEMP_COLD)\n\t\t\tbreak;\n\t\tif (vcl->busy == 0 && VCL_WARM(vcl)) {\n\t\t\tvcl->temp = VTAILQ_EMPTY(&vcl->ref_list) ?\n\t\t\t    VCL_TEMP_COLD : VCL_TEMP_COOLING;\n\t\t\tAZ(vcl_send_event(ctx, VCL_EVENT_COLD));\n\t\t\tvcl_BackendEvent(vcl, VCL_EVENT_COLD);\n\t\t}\n\t\telse if (vcl->busy)\n\t\t\tvcl->temp = VCL_TEMP_BUSY;\n\t\telse if (VTAILQ_EMPTY(&vcl->ref_list))\n\t\t\tvcl->temp = VCL_TEMP_COLD;\n\t\telse\n\t\t\tvcl->temp = VCL_TEMP_COOLING;\n\t\tbreak;\n\tcase '1':\n\t\tif (vcl->temp == VCL_TEMP_WARM)\n\t\t\tbreak;\n\t\t/* The warm VCL hasn't seen a cold event yet */\n\t\tif (vcl->temp == VCL_TEMP_BUSY)\n\t\t\tvcl->temp = VCL_TEMP_WARM;\n\t\t/* The VCL must first reach a stable cold state */\n\t\telse if (vcl->temp == VCL_TEMP_COOLING) {\n\t\t\tvcl_print_refs(ctx);\n\t\t\ti = -1;\n\t\t}\n\t\telse {\n\t\t\tvcl->temp = VCL_TEMP_WARM;\n\t\t\ti = vcl_send_event(ctx, VCL_EVENT_WARM);\n\t\t\tif (i == 0) {\n\t\t\t\tvcl_BackendEvent(vcl, VCL_EVENT_WARM);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAZ(vcl->conf->event_vcl(ctx, VCL_EVENT_COLD));\n\t\t\tvcl->temp = VCL_TEMP_COLD;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWRONG(\"Wrong enum state\");\n\t}\n\tif (i == 0 && state[1])\n\t\tbprintf(vcl->state, \"%s\", state + 1);\n\tAZ(errno=pthread_rwlock_unlock(&vcl->temp_rwl));\n\n\treturn (i);\n}\n\nstatic void\nvcl_cancel_load(struct vrt_ctx *ctx, struct cli *cli,\n    const char *name, const char *step)\n{\n\tstruct vcl *vcl = ctx->vcl;\n\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(vcl->conf, VCL_CONF_MAGIC);\n\n\tAZ(VSB_finish(ctx->msg));\n\tVCLI_SetResult(cli, CLIS_CANT);\n\tVCLI_Out(cli, \"VCL \\\"%s\\\" Failed %s\", name, step);\n\tif (VSB_len(ctx->msg))\n\t\tVCLI_Out(cli, \"\\nMessage:\\n\\t%s\", VSB_data(ctx->msg));\n\tctx->method = VCL_MET_FINI;\n\tAZ(vcl_send_event(ctx, VCL_EVENT_DISCARD));\n\tctx->method = 0;\n\tvcl_KillBackends(vcl);\n\tfree(vcl->loaded_name);\n\tVCL_Close(&vcl);\n}\n\nstatic void\nvcl_load(struct cli *cli, struct vrt_ctx *ctx,\n    const char *name, const char *fn, const char *state)\n{\n\tstruct vcl *vcl;\n\tint i;\n\n\tASSERT_CLI();\n\n\tvcl = vcl_find(name);\n\tAZ(vcl);\n\n\tvcl = VCL_Open(fn, ctx->msg);\n\tif (vcl == NULL) {\n\t\tAZ(VSB_finish(ctx->msg));\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\tVCLI_Out(cli, \"%s\", VSB_data(ctx->msg));\n\t\treturn;\n\t}\n\n\tvcl->loaded_name = strdup(name);\n\tXXXAN(vcl->loaded_name);\n\tVTAILQ_INIT(&vcl->director_list);\n\tVTAILQ_INIT(&vcl->ref_list);\n\tVTAILQ_INIT(&vcl->vfps);\n\tVTAILQ_INIT(&vcl->vdps);\n\n\tvcl->temp = VCL_TEMP_INIT;\n\n\tctx->vcl = vcl;\n\n\tVSB_clear(ctx->msg);\n\tctx->method = VCL_MET_INIT;\n\ti = vcl_send_event(ctx, VCL_EVENT_LOAD);\n\tctx->method = 0;\n\tif (i || *ctx->handling != VCL_RET_OK) {\n\t\tvcl_cancel_load(ctx, cli, name, \"initialization\");\n\t\treturn;\n\t}\n\tassert(*ctx->handling == VCL_RET_OK);\n\tVSB_clear(ctx->msg);\n\ti = vcl_set_state(ctx, state);\n\tif (i) {\n\t\tassert(*state == '1');\n\t\tvcl_cancel_load(ctx, cli, name, \"warmup\");\n\t\treturn;\n\t}\n\tVCLI_Out(cli, \"Loaded \\\"%s\\\" as \\\"%s\\\"\", fn , name);\n\tVTAILQ_INSERT_TAIL(&vcl_head, vcl, list);\n\tLck_Lock(&vcl_mtx);\n\tif (vcl_active == NULL)\n\t\tvcl_active = vcl;\n\tLck_Unlock(&vcl_mtx);\n\tVSC_C_main->n_vcl++;\n\tVSC_C_main->n_vcl_avail++;\n}\n\n/*--------------------------------------------------------------------*/\n\nvoid\nVCL_Poll(void)\n{\n\tstruct vrt_ctx *ctx;\n\tstruct vcl *vcl, *vcl2;\n\n\tASSERT_CLI();\n\tctx = VCL_Get_CliCtx(0);\n\tVTAILQ_FOREACH_SAFE(vcl, &vcl_head, list, vcl2) {\n\t\tif (vcl->temp == VCL_TEMP_BUSY ||\n\t\t    vcl->temp == VCL_TEMP_COOLING) {\n\t\t\tctx->vcl = vcl;\n\t\t\tctx->syntax = ctx->vcl->conf->syntax;\n\t\t\tctx->method = 0;\n\t\t\t(void)vcl_set_state(ctx, \"0\");\n\t\t}\n\t\tif (vcl->discard && vcl->temp == VCL_TEMP_COLD) {\n\t\t\tAZ(vcl->busy);\n\t\t\tassert(vcl != vcl_active);\n\t\t\tassert(VTAILQ_EMPTY(&vcl->ref_list));\n\t\t\tVTAILQ_REMOVE(&vcl_head, vcl, list);\n\t\t\tctx->vcl = vcl;\n\t\t\tctx->syntax = ctx->vcl->conf->syntax;\n\t\t\tctx->method = VCL_MET_FINI;\n\t\t\tAZ(vcl_send_event(ctx, VCL_EVENT_DISCARD));\n\t\t\tctx->method = 0;\n\t\t\tvcl_KillBackends(vcl);\n\t\t\tfree(vcl->loaded_name);\n\t\t\tVCL_Close(&vcl);\n\t\t\tVSC_C_main->n_vcl--;\n\t\t\tVSC_C_main->n_vcl_discard--;\n\t\t}\n\t}\n\tVCL_Rel_CliCtx(&ctx);\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_list(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\tconst char *flg;\n\tstruct vsb *vsb;\n\n\t/* NB: Shall generate same output as mcf_vcl_list() */\n\n\t(void)av;\n\t(void)priv;\n\tASSERT_CLI();\n\tvsb = VSB_new_auto();\n\tAN(vsb);\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tif (vcl == vcl_active) {\n\t\t\tflg = \"active\";\n\t\t} else if (vcl->discard) {\n\t\t\tflg = \"discarded\";\n\t\t} else\n\t\t\tflg = \"available\";\n\t\tVSB_printf(vsb, \"%s\\t%s\\t%s\\t%6u\\t%s\",\n\t\t    flg, vcl->state, vcl->temp, vcl->busy, vcl->loaded_name);\n\t\tif (vcl->label != NULL) {\n\t\t\tVSB_printf(vsb, \"\\t->\\t%s\", vcl->label->loaded_name);\n\t\t\tif (vcl->nrefs)\n\t\t\t\tVSB_printf(vsb, \" (%d return(vcl)%s)\",\n\t\t\t\t    vcl->nrefs, vcl->nrefs > 1 ? \"'s\" : \"\");\n\t\t} else if (vcl->nlabels > 0) {\n\t\t\tVSB_printf(vsb, \"\\t<-\\t(%d label%s)\",\n\t\t\t    vcl->nlabels, vcl->nlabels > 1 ? \"s\" : \"\");\n\t\t}\n\t\tVSB_printf(vsb, \"\\n\");\n\t}\n\tVCLI_VTE(cli, &vsb, 80);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_list_json(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\t(void)priv;\n\tASSERT_CLI();\n\tVCLI_JSON_begin(cli, 2, av);\n\tVCLI_Out(cli, \",\\n\");\n\tVTAILQ_FOREACH(vcl, &vcl_head, list) {\n\t\tVCLI_Out(cli, \"{\\n\");\n\t\tVSB_indent(cli->sb, 2);\n\t\tVCLI_Out(cli, \"\\\"status\\\": \");\n\t\tif (vcl == vcl_active) {\n\t\t\tVCLI_Out(cli, \"\\\"active\\\",\\n\");\n\t\t} else if (vcl->discard) {\n\t\t\tVCLI_Out(cli, \"\\\"discarded\\\",\\n\");\n\t\t} else\n\t\t\tVCLI_Out(cli, \"\\\"available\\\",\\n\");\n\t\tVCLI_Out(cli, \"\\\"state\\\": \\\"%s\\\",\\n\", vcl->state);\n\t\tVCLI_Out(cli, \"\\\"temperature\\\": \\\"%s\\\",\\n\", vcl->temp);\n\t\tVCLI_Out(cli, \"\\\"busy\\\": %u,\\n\", vcl->busy);\n\t\tVCLI_Out(cli, \"\\\"name\\\": \\\"%s\\\"\", vcl->loaded_name);\n\t\tif (vcl->label != NULL) {\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t\t\tVCLI_Out(cli, \"\\\"label\\\": {\\n\");\n\t\t\tVSB_indent(cli->sb, 2);\n\t\t\t\tVCLI_Out(cli, \"\\\"name\\\": \\\"%s\\\"\",\n\t\t\t\t\t vcl->label->loaded_name);\n\t\t\tif (vcl->nrefs)\n\t\t\t\tVCLI_Out(cli, \",\\n\\\"refs\\\": %d\", vcl->nrefs);\n\t\t\tVCLI_Out(cli, \"\\n\");\n\t\t\tVCLI_Out(cli, \"}\");\n\t\t\tVSB_indent(cli->sb, -2);\n\t\t} else if (vcl->nlabels > 0) {\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t\t\tVCLI_Out(cli, \"\\\"labels\\\": %d\", vcl->nlabels);\n\t\t}\n\t\tVSB_indent(cli->sb, -2);\n\t\tVCLI_Out(cli, \"\\n}\");\n\t\tif (VTAILQ_NEXT(vcl, list) != NULL)\n\t\t\tVCLI_Out(cli, \",\\n\");\n\t}\n\tVCLI_JSON_end(cli);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_load(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vrt_ctx *ctx;\n\n\tAZ(priv);\n\tASSERT_CLI();\n\tctx = VCL_Get_CliCtx(1);\n\tvcl_load(cli, ctx, av[2], av[3], av[4]);\n\tVCL_Rel_CliCtx(&ctx);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_state(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vrt_ctx *ctx;\n\n\tAZ(priv);\n\tASSERT_CLI();\n\tAN(av[2]);\n\tAN(av[3]);\n\tctx = VCL_Get_CliCtx(1);\n\tctx->vcl = vcl_find(av[2]);\n\tAN(ctx->vcl);\t\t\t// MGT ensures this\n\tif (vcl_set_state(ctx, av[3])) {\n\t\tAZ(VSB_finish(ctx->msg));\n\t\tVCLI_SetResult(cli, CLIS_CANT);\n\t\tVCLI_Out(cli, \"Failed <vcl.state %s %s>\", ctx->vcl->loaded_name,\n\t\t    av[3] + 1);\n\t\tif (VSB_len(ctx->msg))\n\t\t\tVCLI_Out(cli, \"\\nMessage:\\n\\t%s\", VSB_data(ctx->msg));\n\t}\n\tVCL_Rel_CliCtx(&ctx);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_discard(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\t(void)cli;\n\tAZ(priv);\n\tvcl = vcl_find(av[2]);\n\tAN(vcl);\t\t\t// MGT ensures this\n\tLck_Lock(&vcl_mtx);\n\tassert (vcl != vcl_active);\t// MGT ensures this\n\tAZ(vcl->nlabels);\t\t// MGT ensures this\n\tVSC_C_main->n_vcl_discard++;\n\tVSC_C_main->n_vcl_avail--;\n\tvcl->discard = 1;\n\tif (vcl->label != NULL) {\n\t\tAZ(strcmp(vcl->state, VCL_TEMP_LABEL));\n\t\tvcl->label->nlabels--;\n\t\tvcl->label= NULL;\n\t}\n\tLck_Unlock(&vcl_mtx);\n\n\tif (!strcmp(vcl->state, VCL_TEMP_LABEL)) {\n\t\tVTAILQ_REMOVE(&vcl_head, vcl, list);\n\t\tfree(vcl->loaded_name);\n\t\tAZ(errno=pthread_rwlock_destroy(&vcl->temp_rwl));\n\t\tFREE_OBJ(vcl);\n\t} else if (vcl->temp == VCL_TEMP_COLD) {\n\t\tVCL_Poll();\n\t}\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_label(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *lbl;\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\t(void)cli;\n\t(void)priv;\n\tvcl = vcl_find(av[3]);\n\tAN(vcl);\t\t\t\t// MGT ensures this\n\tlbl = vcl_find(av[2]);\n\tif (lbl == NULL) {\n\t\tALLOC_OBJ(lbl, VCL_MAGIC);\n\t\tAN(lbl);\n\t\tbprintf(lbl->state, \"%s\", VCL_TEMP_LABEL);\n\t\tlbl->temp = VCL_TEMP_WARM;\n\t\tREPLACE(lbl->loaded_name, av[2]);\n\t\tAZ(errno=pthread_rwlock_init(&lbl->temp_rwl, NULL));\n\t\tVTAILQ_INSERT_TAIL(&vcl_head, lbl, list);\n\t}\n\tif (lbl->label != NULL)\n\t\tlbl->label->nlabels--;\n\tlbl->label = vcl;\n\tvcl->nlabels++;\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_use(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\n\tASSERT_CLI();\n\tAN(cli);\n\tAZ(priv);\n\tvcl = vcl_find(av[2]);\n\tAN(vcl);\t\t\t\t// MGT ensures this\n\tassert(vcl->temp == VCL_TEMP_WARM);\t// MGT ensures this\n\tLck_Lock(&vcl_mtx);\n\tvcl_active = vcl;\n\tLck_Unlock(&vcl_mtx);\n}\n\nstatic void v_matchproto_(cli_func_t)\nvcl_cli_show(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vcl *vcl;\n\tint verbose = 0;\n\tint i;\n\n\tASSERT_CLI();\n\tAZ(priv);\n\tif (!strcmp(av[2], \"-v\") && av[3] == NULL) {\n\t\tVCLI_Out(cli, \"Too few parameters\");\n\t\tVCLI_SetResult(cli, CLIS_TOOFEW);\n\t\treturn;\n\t} else if (strcmp(av[2], \"-v\") && av[3] != NULL) {\n\t\tVCLI_Out(cli, \"Unknown options '%s'\", av[2]);\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\treturn;\n\t} else if (av[3] != NULL) {\n\t\tverbose = 1;\n\t\tvcl = vcl_find(av[3]);\n\t} else\n\t\tvcl = vcl_find(av[2]);\n\n\tif (vcl == NULL) {\n\t\tVCLI_Out(cli, \"No VCL named '%s'\",\n\t\t    av[3] == NULL ? av[2] : av[3]);\n\t\tVCLI_SetResult(cli, CLIS_PARAM);\n\t\treturn;\n\t}\n\tCHECK_OBJ_NOTNULL(vcl, VCL_MAGIC);\n\tCHECK_OBJ_NOTNULL(vcl->conf, VCL_CONF_MAGIC);\n\tif (verbose) {\n\t\tfor (i = 0; i < vcl->conf->nsrc; i++)\n\t\t\tVCLI_Out(cli, \"// VCL.SHOW %d %zd %s\\n%s\\n\",\n\t\t\t    i, strlen(vcl->conf->srcbody[i]),\n\t\t\t    vcl->conf->srcname[i],\n\t\t\t    vcl->conf->srcbody[i]);\n\t} else {\n\t\tVCLI_Out(cli, \"%s\", vcl->conf->srcbody[0]);\n\t}\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic struct cli_proto vcl_cmds[] = {\n\t{ CLICMD_VCL_LOAD,\t\t\"\", vcl_cli_load },\n\t{ CLICMD_VCL_LIST,\t\t\"\", vcl_cli_list, vcl_cli_list_json },\n\t{ CLICMD_VCL_STATE,\t\t\"\", vcl_cli_state },\n\t{ CLICMD_VCL_DISCARD,\t\t\"\", vcl_cli_discard },\n\t{ CLICMD_VCL_USE,\t\t\"\", vcl_cli_use },\n\t{ CLICMD_VCL_SHOW,\t\t\"\", vcl_cli_show },\n\t{ CLICMD_VCL_LABEL,\t\t\"\", vcl_cli_label },\n\t{ NULL }\n};\n\nvoid\nVCL_Init(void)\n{\n\n\tassert(cache_param->workspace_client > 0);\n\tWS_Init(&ws_cli, \"cli\", malloc(cache_param->workspace_client),\n\t    cache_param->workspace_client);\n\tws_snapshot_cli = WS_Snapshot(&ws_cli);\n\tCLI_AddFuncs(vcl_cmds);\n\tLck_New(&vcl_mtx, lck_vcl);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.2.3-ymlgb5n3vpyjftra6mshxv2pw3hrlozu/spack-src/bin/varnishd/cache/cache_vrt_vmod.c": "/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Runtime support for compiled VCL programs\n */\n\n#include \"config.h\"\n\n#include \"cache_varnishd.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"vcli_serve.h\"\n#include \"vmod_abi.h\"\n\n/*--------------------------------------------------------------------\n * Modules stuff\n */\n\nstruct vmod {\n\tunsigned\t\tmagic;\n#define VMOD_MAGIC\t\t0xb750219c\n\n\tVTAILQ_ENTRY(vmod)\tlist;\n\n\tint\t\t\tref;\n\n\tchar\t\t\t*nm;\n\tunsigned\t\tnbr;\n\tchar\t\t\t*path;\n\tchar\t\t\t*backup;\n\tvoid\t\t\t*hdl;\n\tconst void\t\t*funcs;\n\tint\t\t\tfunclen;\n\tconst char\t\t*abi;\n\tunsigned\t\tvrt_major;\n\tunsigned\t\tvrt_minor;\n};\n\nstatic VTAILQ_HEAD(,vmod)\tvmods = VTAILQ_HEAD_INITIALIZER(vmods);\n\nstatic unsigned\nvmod_abi_mismatch(const struct vmod_data *d)\n{\n\n\tif (d->vrt_major == 0 && d->vrt_minor == 0)\n\t\treturn (d->abi == NULL || strcmp(d->abi, VMOD_ABI_Version));\n\n\treturn (d->vrt_major != VRT_MAJOR_VERSION ||\n\t    d->vrt_minor > VRT_MINOR_VERSION);\n}\n\nint\nVRT_Vmod_Init(VRT_CTX, struct vmod **hdl, unsigned nbr, void *ptr, int len,\n    const char *nm, const char *path, const char *file_id, const char *backup)\n{\n\tstruct vmod *v;\n\tconst struct vmod_data *d;\n\tchar buf[256];\n\tvoid *dlhdl;\n\n\tASSERT_CLI();\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tAN(ctx->msg);\n\tAN(hdl);\n\tAZ(*hdl);\n\n\tdlhdl = dlopen(backup, RTLD_NOW | RTLD_LOCAL);\n\tif (dlhdl == NULL) {\n\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t    nm, backup, path);\n\t\tVSB_printf(ctx->msg, \"dlopen() failed: %s\\n\", dlerror());\n\t\treturn (1);\n\t}\n\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tif (v->hdl == dlhdl)\n\t\t\tbreak;\n\tif (v == NULL) {\n\t\tALLOC_OBJ(v, VMOD_MAGIC);\n\t\tAN(v);\n\t\tREPLACE(v->backup, backup);\n\n\t\tv->hdl = dlhdl;\n\n\t\tbprintf(buf, \"Vmod_%s_Data\", nm);\n\t\td = dlsym(v->hdl, buf);\n\t\tif (d == NULL ||\n\t\t    d->file_id == NULL ||\n\t\t    strcmp(d->file_id, file_id)) {\n\t\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t\t    nm, backup, path);\n\t\t\tVSB_printf(ctx->msg,\n\t\t\t    \"This is no longer the same file seen by\"\n\t\t\t    \" the VCL-compiler.\\n\");\n\t\t\t(void)dlclose(v->hdl);\n\t\t\tFREE_OBJ(v);\n\t\t\treturn (1);\n\t\t}\n\t\tif (vmod_abi_mismatch(d) ||\n\t\t    d->name == NULL ||\n\t\t    strcmp(d->name, nm) ||\n\t\t    d->func == NULL ||\n\t\t    d->func_len <= 0 ||\n\t\t    d->proto == NULL ||\n\t\t    d->json == NULL) {\n\t\t\tVSB_printf(ctx->msg, \"Loading vmod %s from %s (%s):\\n\",\n\t\t\t    nm, backup, path);\n\t\t\tVSB_printf(ctx->msg, \"VMOD data is mangled.\\n\");\n\t\t\t(void)dlclose(v->hdl);\n\t\t\tFREE_OBJ(v);\n\t\t\treturn (1);\n\t\t}\n\n\t\tv->nbr = nbr;\n\t\tv->funclen = d->func_len;\n\t\tv->funcs = d->func;\n\t\tv->abi = d->abi;\n\t\tv->vrt_major = d->vrt_major;\n\t\tv->vrt_minor = d->vrt_minor;\n\n\t\tREPLACE(v->nm, nm);\n\t\tREPLACE(v->path, path);\n\n\t\tVSC_C_main->vmods++;\n\t\tVTAILQ_INSERT_TAIL(&vmods, v, list);\n\t}\n\n\tassert(len == v->funclen);\n\tmemcpy(ptr, v->funcs, v->funclen);\n\tv->ref++;\n\n\t*hdl = v;\n\treturn (0);\n}\n\nvoid\nVRT_Vmod_Unload(VRT_CTX, struct vmod **hdl)\n{\n\tstruct vmod *v;\n\n\tASSERT_CLI();\n\n\tTAKE_OBJ_NOTNULL(v, hdl, VMOD_MAGIC);\n\n\tVCL_TaskLeave(ctx->vcl, cli_task_privs);\n\tVCL_TaskEnter(ctx->vcl, cli_task_privs);\n\n#ifndef DONT_DLCLOSE_VMODS\n\t/*\n\t * atexit(3) handlers are not called during dlclose(3).  We don't\n\t * normally use them, but we do when running GCOV.  This option\n\t * enables us to do that.\n\t */\n\tAZ(dlclose(v->hdl));\n#endif\n\tif (--v->ref != 0)\n\t\treturn;\n\tfree(v->nm);\n\tfree(v->path);\n\tfree(v->backup);\n\tVTAILQ_REMOVE(&vmods, v, list);\n\tVSC_C_main->vmods--;\n\tFREE_OBJ(v);\n}\n\nvoid\nVMOD_Panic(struct vsb *vsb)\n{\n\tstruct vmod *v;\n\n\tVSB_printf(vsb, \"vmods = {\\n\");\n\tVSB_indent(vsb, 2);\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tVSB_printf(vsb, \"%s = {%s, %u.%u},\\n\",\n\t\t    v->nm, v->abi, v->vrt_major, v->vrt_minor);\n\tVSB_indent(vsb, -2);\n\tVSB_printf(vsb, \"},\\n\");\n}\n\n/*---------------------------------------------------------------------*/\n\nstatic void v_matchproto_(cli_func_t)\nccf_debug_vmod(struct cli *cli, const char * const *av, void *priv)\n{\n\tstruct vmod *v;\n\n\t(void)av;\n\t(void)priv;\n\tASSERT_CLI();\n\tVTAILQ_FOREACH(v, &vmods, list)\n\t\tVCLI_Out(cli, \"%5d %s (%s)\\n\", v->ref, v->nm, v->path);\n}\n\nstatic struct cli_proto vcl_cmds[] = {\n\t{ CLICMD_DEBUG_VMOD,\t\t\t\"d\", ccf_debug_vmod },\n\t{ NULL }\n};\n\nvoid\nVMOD_Init(void)\n{\n\n\tCLI_AddFuncs(vcl_cmds);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.2.3-ymlgb5n3vpyjftra6mshxv2pw3hrlozu/spack-src/lib/libvcc/vcc_vmod.c": "/*-\n * Copyright (c) 2010-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"vcc_compile.h\"\n\n#include \"libvcc.h\"\n#include \"vfil.h\"\n#include \"vjsn.h\"\n#include \"vmod_abi.h\"\n#include \"vsb.h\"\n\nstatic int\nvcc_path_dlopen(void *priv, const char *fn)\n{\n\tvoid *hdl, **pp;\n\n\tAN(priv);\n\tAN(fn);\n\n\thdl = dlopen(fn, RTLD_NOW | RTLD_LOCAL);\n\tif (hdl == NULL)\n\t\treturn (-1);\n\tpp = priv;\n\t*pp = hdl;\n\treturn (0);\n}\n\nstatic void\nfunc_sym(struct symbol *sym, const char *vmod, const struct vjsn_val *v)\n{\n\n\tassert(v->type == VJSN_ARRAY);\n\tsym->action = vcc_Act_Call;\n\tsym->vmod = vmod;\n\tsym->eval = vcc_Eval_SymFunc;\n\tsym->eval_priv = v;\n\tv = VTAILQ_FIRST(&v->children);\n\tassert(v->type == VJSN_ARRAY);\n\tv = VTAILQ_FIRST(&v->children);\n\tassert(v->type == VJSN_STRING);\n\tsym->type = VCC_Type(v->value);\n\tAN(sym->type);\n}\n\nstatic void\nvcc_json_always(struct vcc *tl, const struct symbol *msym)\n{\n\tstruct inifin *ifp;\n\tconst struct vjsn *vj;\n\tconst struct vjsn_val *vv, *vv2;\n\tdouble vmod_syntax = 0.0;\n\n\tifp = NULL;\n\n\tCAST_OBJ_NOTNULL(vj, msym->eval_priv, VJSN_MAGIC);\n\n\tVTAILQ_FOREACH(vv, &vj->value->children, list) {\n\t\tassert(vv->type == VJSN_ARRAY);\n\t\tvv2 = VTAILQ_FIRST(&vv->children);\n\t\tassert(vv2->type == VJSN_STRING);\n\t\tif (!strcmp(vv2->value, \"$VMOD\")) {\n\t\t\tvmod_syntax =\n\t\t\t    strtod(VTAILQ_NEXT(vv2, list)->value, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tassert (vmod_syntax == 1.0);\n\t\tif (!strcmp(vv2->value, \"$EVENT\")) {\n\t\t\t/* XXX: What about the rest of the events ? */\n\t\t\tif (ifp == NULL)\n\t\t\t\tifp = New_IniFin(tl);\n\t\t\tvv2 = VTAILQ_NEXT(vv2, list);\n\t\t\tVSB_printf(ifp->ini,\n\t\t\t    \"\\tif (%s(ctx, &vmod_priv_%s, VCL_EVENT_LOAD))\\n\"\n\t\t\t    \"\\t\\treturn(1);\",\n\t\t\t    vv2->value, msym->name);\n\t\t\tVSB_printf(ifp->fin,\n\t\t\t    \"\\t\\t(void)%s(ctx, &vmod_priv_%s,\\n\"\n\t\t\t    \"\\t\\t\\t    VCL_EVENT_DISCARD);\",\n\t\t\t    vv2->value, msym->name);\n\t\t\tVSB_printf(ifp->event, \"%s(ctx, &vmod_priv_%s, ev)\",\n\t\t\t    vv2->value, msym->name);\n\t\t} else if (!strcmp(vv2->value, \"$FUNC\")) {\n\t\t} else if (!strcmp(vv2->value, \"$OBJ\")) {\n\t\t} else {\n\t\t\tVTAILQ_FOREACH(vv2, &vv->children, list)\n\t\t\t\tfprintf(stderr, \"\\tt %s n %s v %s\\n\",\n\t\t\t\t    vv2->type, vv2->name, vv2->value);\n\t\t\tWRONG(\"Vmod JSON syntax error\");\n\t\t}\n\t}\n}\n\nstatic void v_matchproto_(sym_wildcard_t)\nvcc_json_wildcard(struct vcc *tl, struct symbol *msym, struct symbol *tsym)\n{\n\tconst struct vjsn *vj;\n\tconst struct vjsn_val *vv, *vv1, *vv2;\n\n\tassert(msym->kind == SYM_VMOD);\n\tCAST_OBJ_NOTNULL(vj, msym->eval_priv, VJSN_MAGIC);\n\tVTAILQ_FOREACH(vv, &vj->value->children, list) {\n\t\tassert(vv->type == VJSN_ARRAY);\n\t\tvv1 = VTAILQ_FIRST(&vv->children);\n\t\tassert(vv1->type == VJSN_STRING);\n\t\tvv2 = VTAILQ_NEXT(vv1, list);\n\t\tassert(vv2->type == VJSN_STRING);\n\t\tif (!strcmp(vv1->value, \"$FUNC\") &&\n\t\t    !strcmp(vv2->value, tsym->name)) {\n\t\t\ttsym->kind = SYM_FUNC;\n\t\t\ttsym->noref = 1;\n\t\t\tfunc_sym(tsym, msym->name, VTAILQ_NEXT(vv2, list));\n\t\t\treturn;\n\t\t} else if (!strcmp(vv1->value, \"$OBJ\") &&\n\t\t\t   !strcmp(vv2->value, tsym->name)) {\n\t\t\ttsym->kind = SYM_OBJECT;\n\t\t\ttsym->eval_priv = vv2;\n\t\t\ttsym->vmod = msym->name;\n\t\t\treturn;\n\t\t}\n\t}\n\ttl->err = 1;\n}\n\nvoid\nvcc_ParseImport(struct vcc *tl)\n{\n\tvoid *hdl;\n\tchar fn[1024], *fnp, *fnpx;\n\tchar buf[256];\n\tconst char *p;\n\tstruct token *mod, *t1;\n\tstruct inifin *ifp;\n\tstruct symbol *msym;\n\tconst struct vmod_data *vmd;\n\tstruct vjsn *vj;\n\tint again = 0;\n\n\tt1 = tl->t;\n\tSkipToken(tl, ID);\t\t/* \"import\" */\n\n\n\tExpectErr(tl, ID);\n\tmod = tl->t;\n\tmsym = VCC_SymbolGet(tl, SYM_NONE, SYMTAB_NOERR, XREF_NONE);\n\n\tif (msym != NULL && msym->kind != SYM_VMOD) {\n\t\t/*\n\t\t * We need to make sure the entire std.* namespace is empty\n\t\t */\n\t\tVSB_printf(tl->sb, \"Module %.*s conflicts with other symbol.\\n\",\n\t\t    PF(mod));\n\t\tvcc_ErrWhere2(tl, t1, tl->t);\n\t\treturn;\n\t}\n\tif (msym != NULL) {\n\t\tagain = 1;\n\t} else {\n\n\t\tmsym = VCC_SymbolGet(tl, SYM_VMOD, SYMTAB_CREATE, XREF_NONE);\n\t\tERRCHK(tl);\n\t\tAN(msym);\n\t\tmsym->def_b = t1;\n\t\tmsym->def_e = tl->t;\n\t}\n\n\tif (tl->t->tok == ID) {\n\t\tif (!vcc_IdIs(tl->t, \"from\")) {\n\t\t\tVSB_printf(tl->sb, \"Expected 'from path ...'\\n\");\n\t\t\tvcc_ErrWhere(tl, tl->t);\n\t\t\treturn;\n\t\t}\n\t\tvcc_NextToken(tl);\n\t\tif (!tl->unsafe_path && strchr(tl->t->dec, '/')) {\n\t\t\tVSB_printf(tl->sb,\n\t\t\t    \"'import ... from path ...' is unsafe.\\nAt:\");\n\t\t\tvcc_ErrToken(tl, tl->t);\n\t\t\tvcc_ErrWhere(tl, tl->t);\n\t\t\treturn;\n\t\t}\n\t\tExpectErr(tl, CSTR);\n\t\tp = strrchr(tl->t->dec, '/');\n\t\tif (p != NULL && p[1] == '\\0')\n\t\t\tbprintf(fn, \"%slibvmod_%.*s.so\", tl->t->dec, PF(mod));\n\t\telse\n\t\t\tbprintf(fn, \"%s\", tl->t->dec);\n\t\tvcc_NextToken(tl);\n\t} else {\n\t\tbprintf(fn, \"libvmod_%.*s.so\", PF(mod));\n\t}\n\n\tSkipToken(tl, ';');\n\n\tif (!again)\n\t\tmsym->def_e = tl->t;\n\n\n\tif (VFIL_searchpath(tl->vmod_path, vcc_path_dlopen, &hdl, fn, &fnpx)) {\n\t\tVSB_printf(tl->sb, \"Could not load VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\",\n\t\t    fnpx != NULL ? fnpx : fn);\n\t\tVSB_printf(tl->sb, \"\\tdlerror: %s\\n\", dlerror());\n\t\tvcc_ErrWhere(tl, mod);\n\t\tfree(fnpx);\n\t\treturn;\n\t}\n\n\tAN(fnpx);\n\tfnp = TlDup(tl, fnpx);\n\tfree(fnpx);\n\n\tbprintf(buf, \"Vmod_%.*s_Data\", PF(mod));\n\tvmd = dlsym(hdl, buf);\n\tif (vmd == NULL) {\n\t\tVSB_printf(tl->sb, \"Malformed VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\t(no Vmod_Data symbol)\\n\");\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn;\n\t}\n\tif (vmd->vrt_major == 0 && vmd->vrt_minor == 0 &&\n\t    strcmp(vmd->abi, VMOD_ABI_Version) != 0) {\n\t\tVSB_printf(tl->sb, \"Incompatible VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tABI mismatch, expected <%s>, got <%s>\\n\",\n\t\t\t   VMOD_ABI_Version, vmd->abi);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn;\n\t}\n\tif (vmd->vrt_major != 0 && (vmd->vrt_major != VRT_MAJOR_VERSION ||\n\t    vmd->vrt_minor > VRT_MINOR_VERSION)) {\n\t\tVSB_printf(tl->sb, \"Incompatible VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tVMOD wants ABI version %u.%u\\n\",\n\t\t    vmd->vrt_major, vmd->vrt_minor);\n\t\tVSB_printf(tl->sb, \"\\tvarnishd provides ABI version %u.%u\\n\",\n\t\t    VRT_MAJOR_VERSION, VRT_MINOR_VERSION);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn;\n\t}\n\tif (vmd->name == NULL ||\n\t    vmd->func == NULL ||\n\t    vmd->func_len <= 0 ||\n\t    vmd->proto == NULL ||\n\t    vmd->abi == NULL) {\n\t\tVSB_printf(tl->sb, \"Mangled VMOD %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tInconsistent metadata\\n\");\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn;\n\t}\n\n\tif (!vcc_IdIs(mod, vmd->name)) {\n\t\tVSB_printf(tl->sb, \"Wrong VMOD file %.*s\\n\", PF(mod));\n\t\tVSB_printf(tl->sb, \"\\tFile name: %s\\n\", fnp);\n\t\tVSB_printf(tl->sb, \"\\tContains vmod \\\"%s\\\"\\n\", vmd->name);\n\t\tvcc_ErrWhere(tl, mod);\n\t\treturn;\n\t}\n\n\tif (again && strcmp(vmd->file_id, msym->extra)) {\n\t\tVSB_printf(tl->sb,\n\t\t    \"Different version of module %.*s already imported.\\n\",\n\t\t    PF(mod));\n\t\tvcc_ErrWhere2(tl, t1, tl->t);\n\t\tVSB_printf(tl->sb, \"Previous import was here:\\n\");\n\t\tvcc_ErrWhere2(tl, msym->def_b, msym->def_e);\n\t}\n\tif (again) {\n\t\tAZ(dlclose(hdl));\n\t\treturn;\n\t}\n\n\tifp = New_IniFin(tl);\n\n\tVSB_printf(ifp->ini, \"\\tif (VRT_Vmod_Init(ctx,\\n\");\n\tVSB_printf(ifp->ini, \"\\t    &VGC_vmod_%.*s,\\n\", PF(mod));\n\tVSB_printf(ifp->ini, \"\\t    %u,\\n\", tl->vmod_count++);\n\tVSB_printf(ifp->ini, \"\\t    &%s,\\n\", vmd->func_name);\n\tVSB_printf(ifp->ini, \"\\t    sizeof(%s),\\n\", vmd->func_name);\n\tVSB_printf(ifp->ini, \"\\t    \\\"%.*s\\\",\\n\", PF(mod));\n\tVSB_printf(ifp->ini, \"\\t    \");\n\tVSB_quote(ifp->ini, fnp, -1, VSB_QUOTE_CSTR);\n\tVSB_printf(ifp->ini, \",\\n\");\n\tAN(vmd);\n\tAN(vmd->file_id);\n\tVSB_printf(ifp->ini, \"\\t    \\\"%s\\\",\\n\", vmd->file_id);\n\tVSB_printf(ifp->ini, \"\\t    \\\"./vmod_cache/_vmod_%.*s.%s\\\"\\n\",\n\t    PF(mod), vmd->file_id);\n\tVSB_printf(ifp->ini, \"\\t    ))\\n\");\n\tVSB_printf(ifp->ini, \"\\t\\treturn(1);\");\n\n\tVSB_printf(tl->fi, \"%s VMOD %s ./vmod_cache/_vmod_%.*s.%s */\\n\",\n\t    VCC_INFO_PREFIX, fnp, PF(mod), vmd->file_id);\n\n\t/* XXX: zero the function pointer structure ?*/\n\tVSB_printf(ifp->fin, \"\\t\\tVRT_priv_fini(&vmod_priv_%.*s);\", PF(mod));\n\tVSB_printf(ifp->final,\n\t    \"\\t\\tVRT_Vmod_Unload(ctx, &VGC_vmod_%.*s);\", PF(mod));\n\n\tvj = vjsn_parse(vmd->json, &p);\n\tXXXAZ(p);\n\tAN(vj);\n\tmsym->eval_priv = vj;\n\tmsym->wildcard = vcc_json_wildcard;\n\tmsym->extra = TlDup(tl, vmd->file_id);\n\n\tvcc_json_always(tl, msym);\n\n\tFh(tl, 0, \"\\n/* --- BEGIN VMOD %.*s --- */\\n\\n\", PF(mod));\n\tFh(tl, 0, \"static struct vmod *VGC_vmod_%.*s;\\n\", PF(mod));\n\tFh(tl, 0, \"static struct vmod_priv vmod_priv_%.*s;\\n\", PF(mod));\n\tFh(tl, 0, \"\\n%s\\n\", vmd->proto);\n\tFh(tl, 0, \"\\n/* --- END VMOD %.*s --- */\\n\\n\", PF(mod));\n}\n\nvoid v_matchproto_(sym_act_f)\nvcc_Act_New(struct vcc *tl, struct token *t, struct symbol *sym)\n{\n\tstruct symbol *sy1, *sy2, *sy3;\n\tstruct inifin *ifp;\n\tstruct vsb *buf;\n\tconst struct vjsn_val *vv, *vf;\n\tconst char *p;\n\tint null_ok = 0;\n\n\t(void)sym;\n\tExpectErr(tl, ID);\n\tvcc_ExpectVid(tl, \"VCL object\");\n\tERRCHK(tl);\n\tsy1 = VCC_HandleSymbol(tl, INSTANCE, \"vo\");\n\tERRCHK(tl);\n\tAN(sy1);\n\tsy1->noref = 1;\n\n\tExpectErr(tl, '=');\n\tvcc_NextToken(tl);\n\n\tExpectErr(tl, ID);\n\tt = tl->t;\n\tsy2 = VCC_SymbolGet(tl, SYM_OBJECT, \"Symbol not found\", XREF_NONE);\n\tERRCHK(tl);\n\tAN(sy2);\n\tif (sy2->eval_priv == NULL) {\n\t\tVSB_printf(tl->sb, \"Constructor not found: \");\n\t\tvcc_ErrToken(tl, t);\n\t\tVSB_printf(tl->sb, \" at \");\n\t\tvcc_ErrWhere(tl, t);\n\t\treturn;\n\t}\n\n\tCAST_OBJ_NOTNULL(vv, sy2->eval_priv, VJSN_VAL_MAGIC);\n\t// vv = object name\n\n\tvv = VTAILQ_NEXT(vv, list);\n\t// vv = flags\n\tassert(vv->type == VJSN_OBJECT);\n\tVTAILQ_FOREACH(vf, &vv->children, list)\n\t\tif (!strcmp(vf->name, \"NULL_OK\") && vf->type == VJSN_TRUE)\n\t\t\tnull_ok = 1;\n\tif (!null_ok)\n\t\tVTAILQ_INSERT_TAIL(&tl->sym_objects, sy1, sideways);\n\n\tvv = VTAILQ_NEXT(vv, list);\n\t// vv = struct name\n\n\tFh(tl, 0, \"static %s *%s;\\n\\n\", vv->value, sy1->rname);\n\tvv = VTAILQ_NEXT(vv, list);\n\n\tvf = VTAILQ_FIRST(&vv->children);\n\tvv = VTAILQ_NEXT(vv, list);\n\tassert(vf->type == VJSN_STRING);\n\tassert(!strcmp(vf->value, \"$INIT\"));\n\n\tvf = VTAILQ_NEXT(vf, list);\n\n\tbuf = VSB_new_auto();\n\tAN(buf);\n\tVSB_printf(buf, \", &%s, \\\"%s\\\"\", sy1->rname, sy1->name);\n\tAZ(VSB_finish(buf));\n\tvcc_Eval_Func(tl, vf, VSB_data(buf), sy2);\n\tVSB_destroy(&buf);\n\tERRCHK(tl);\n\tSkipToken(tl, ';');\n\tsy1->def_e = tl->t;\n\n\tvf = VTAILQ_FIRST(&vv->children);\n\tvv = VTAILQ_NEXT(vv, list);\n\tassert(vf->type == VJSN_STRING);\n\tassert(!strcmp(vf->value, \"$FINI\"));\n\n\tvf = VTAILQ_NEXT(vf, list);\n\tvf = VTAILQ_FIRST(&vf->children);\n\tvf = VTAILQ_NEXT(vf, list);\n\tifp = New_IniFin(tl);\n\tVSB_printf(ifp->fin, \"\\t\\tif (%s)\\n\", sy1->rname);\n\tVSB_printf(ifp->fin, \"\\t\\t\\t\\t%s(&%s);\", vf->value, sy1->rname);\n\n\t/* Instantiate symbols for the methods */\n\tbuf = VSB_new_auto();\n\tAN(buf);\n\tVSB_printf(buf, \", %s\", sy1->rname);\n\tAZ(VSB_finish(buf));\n\tp = TlDup(tl, VSB_data(buf));\n\twhile (vv != NULL) {\n\t\tvf = VTAILQ_FIRST(&vv->children);\n\t\tassert(vf->type == VJSN_STRING);\n\t\tassert(!strcmp(vf->value, \"$METHOD\"));\n\t\tvf = VTAILQ_NEXT(vf, list);\n\t\tassert(vf->type == VJSN_STRING);\n\n\t\tVSB_clear(buf);\n\t\tVSB_printf(buf, \"%s.%s\", sy1->name, vf->value);\n\t\tAZ(VSB_finish(buf));\n\t\tsy3 = VCC_MkSym(tl, VSB_data(buf), SYM_FUNC, VCL_LOW, VCL_HIGH);\n\t\tAN(sy3);\n\t\tfunc_sym(sy3, sy2->vmod, VTAILQ_NEXT(vf, list));\n\t\tsy3->extra = p;\n\t\tvv = VTAILQ_NEXT(vv, list);\n\t}\n\tVSB_destroy(&buf);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-varnish-cache-6.2.3-ymlgb5n3vpyjftra6mshxv2pw3hrlozu/spack-src/doc/sphinx/phk/bjarne.jpeg"
    ],
    "total_files": 1426
}