{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/byterun/unix.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 2001 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#define CAML_INTERNALS\n\n/* Unix-specific stuff */\n\n#define _GNU_SOURCE\n           /* Helps finding RTLD_DEFAULT in glibc */\n           /* also secure_getenv */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include \"caml/config.h\"\n#ifdef SUPPORT_DYNAMIC_LINKING\n#ifdef __CYGWIN__\n#include \"flexdll.h\"\n#else\n#include <dlfcn.h>\n#endif\n#endif\n#ifdef HAS_UNISTD\n#include <unistd.h>\n#endif\n#ifdef HAS_DIRENT\n#include <dirent.h>\n#else\n#include <sys/dir.h>\n#endif\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#endif\n#include \"caml/fail.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/signals.h\"\n#include \"caml/sys.h\"\n#include \"caml/io.h\"\n#include \"caml/alloc.h\"\n\n#ifndef S_ISREG\n#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)\n#endif\n\n#ifndef EINTR\n#define EINTR (-1)\n#endif\n#ifndef EAGAIN\n#define EAGAIN (-1)\n#endif\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK (-1)\n#endif\n\nint caml_read_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  do {\n    caml_enter_blocking_section();\n    retcode = read(fd, buf, n);\n    caml_leave_blocking_section();\n  } while (retcode == -1 && errno == EINTR);\n  if (retcode == -1) caml_sys_io_error(NO_ARG);\n  return retcode;\n}\n\nint caml_write_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n again:\n#if defined(NATIVE_CODE) && defined(WITH_SPACETIME)\n  if (flags & CHANNEL_FLAG_BLOCKING_WRITE) {\n    retcode = write(fd, buf, n);\n  } else {\n#endif\n  caml_enter_blocking_section();\n  retcode = write(fd, buf, n);\n  caml_leave_blocking_section();\n#if defined(NATIVE_CODE) && defined(WITH_SPACETIME)\n  }\n#endif\n  if (retcode == -1) {\n    if (errno == EINTR) goto again;\n    if ((errno == EAGAIN || errno == EWOULDBLOCK) && n > 1) {\n      /* We couldn't do a partial write here, probably because\n         n <= PIPE_BUF and POSIX says that writes of less than\n         PIPE_BUF characters must be atomic.\n         We first try again with a partial write of 1 character.\n         If that fails too, we'll return an error code. */\n      n = 1; goto again;\n    }\n  }\n  if (retcode == -1) caml_sys_io_error(NO_ARG);\n  CAMLassert (retcode > 0);\n  return retcode;\n}\n\ncaml_stat_string caml_decompose_path(struct ext_table * tbl, char * path)\n{\n  char * p, * q;\n  size_t n;\n\n  if (path == NULL) return NULL;\n  p = caml_stat_strdup(path);\n  q = p;\n  while (1) {\n    for (n = 0; q[n] != 0 && q[n] != ':'; n++) /*nothing*/;\n    caml_ext_table_add(tbl, q);\n    q = q + n;\n    if (*q == 0) break;\n    *q = 0;\n    q += 1;\n  }\n  return p;\n}\n\ncaml_stat_string caml_search_in_path(struct ext_table * path, const char * name)\n{\n  const char * p;\n  char * dir, * fullname;\n  int i;\n  struct stat st;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) dir = \".\";  /* empty path component = current dir */\n    fullname = caml_stat_strconcat(3, dir, \"/\", name);\n    if (stat(fullname, &st) == 0 && S_ISREG(st.st_mode))\n      return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  return caml_stat_strdup(name);\n}\n\n#ifdef __CYGWIN__\n\n/* Cygwin needs special treatment because of the implicit \".exe\" at the\n   end of executable file names */\n\nstatic int cygwin_file_exists(const char * name)\n{\n  int fd, ret;\n  struct stat st;\n  /* Cannot use stat() here because it adds \".exe\" implicitly */\n  fd = open(name, O_RDONLY);\n  if (fd == -1) return 0;\n  ret = fstat(fd, &st);\n  close(fd);\n  return ret == 0 && S_ISREG(st.st_mode);\n}\n\nstatic caml_stat_string cygwin_search_exe_in_path(struct ext_table * path, const char * name)\n{\n  const char * p;\n  char * dir, * fullname;\n  int i;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/' || *p == '\\\\') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) dir = \".\";  /* empty path component = current dir */\n    fullname = caml_stat_strconcat(3, dir, \"/\", name);\n    if (cygwin_file_exists(fullname)) return fullname;\n    caml_stat_free(fullname);\n    fullname = caml_stat_strconcat(4, dir, \"/\", name, \".exe\");\n    if (cygwin_file_exists(fullname)) return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  if (cygwin_file_exists(name)) return caml_stat_strdup(name);\n  fullname = caml_stat_strconcat(2, name, \".exe\");\n  if (cygwin_file_exists(fullname)) return fullname;\n  caml_stat_free(fullname);\n  return caml_stat_strdup(name);\n}\n\n#endif\n\ncaml_stat_string caml_search_exe_in_path(const char * name)\n{\n  struct ext_table path;\n  char * tofree;\n  caml_stat_string res;\n\n  caml_ext_table_init(&path, 8);\n  tofree = caml_decompose_path(&path, getenv(\"PATH\"));\n#ifndef __CYGWIN__\n  res = caml_search_in_path(&path, name);\n#else\n  res = cygwin_search_exe_in_path(&path, name);\n#endif\n  caml_stat_free(tofree);\n  caml_ext_table_free(&path, 0);\n  return res;\n}\n\ncaml_stat_string caml_search_dll_in_path(struct ext_table * path, const char * name)\n{\n  caml_stat_string dllname;\n  caml_stat_string res;\n\n  dllname = caml_stat_strconcat(2, name, \".so\");\n  res = caml_search_in_path(path, dllname);\n  caml_stat_free(dllname);\n  return res;\n}\n\n#ifdef SUPPORT_DYNAMIC_LINKING\n#ifdef __CYGWIN__\n/* Use flexdll */\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  int flags = (global ? FLEXDLL_RTLD_GLOBAL : 0);\n  if (!for_execution) flags |= FLEXDLL_RTLD_NOEXEC;\n  return flexdll_dlopen(libname, flags);\n}\n\nvoid caml_dlclose(void * handle)\n{\n  flexdll_dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, const char * name)\n{\n  return flexdll_dlsym(handle, name);\n}\n\nvoid * caml_globalsym(const char * name)\n{\n  return flexdll_dlsym(flexdll_dlopen(NULL,0), name);\n}\n\nchar * caml_dlerror(void)\n{\n  return flexdll_dlerror();\n}\n\n#else\n/* Use normal dlopen */\n\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  return dlopen(libname, RTLD_NOW | (global ? RTLD_GLOBAL : RTLD_LOCAL));\n  /* Could use RTLD_LAZY if for_execution == 0, but needs testing */\n}\n\nvoid caml_dlclose(void * handle)\n{\n  dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, const char * name)\n{\n#ifdef DL_NEEDS_UNDERSCORE\n  char _name[1000] = \"_\";\n  strncat (_name, name, 998);\n  name = _name;\n#endif\n  return dlsym(handle, name);\n}\n\nvoid * caml_globalsym(const char * name)\n{\n#ifdef RTLD_DEFAULT\n  return caml_dlsym(RTLD_DEFAULT, name);\n#else\n  return NULL;\n#endif\n}\n\nchar * caml_dlerror(void)\n{\n  return (char*) dlerror();\n}\n\n#endif\n#else\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  return NULL;\n}\n\nvoid caml_dlclose(void * handle)\n{\n}\n\nvoid * caml_dlsym(void * handle, const char * name)\n{\n  return NULL;\n}\n\nvoid * caml_globalsym(const char * name)\n{\n  return NULL;\n}\n\nchar * caml_dlerror(void)\n{\n  return \"dynamic loading not supported on this platform\";\n}\n\n#endif\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\n\nCAMLexport int caml_read_directory(char * dirname, struct ext_table * contents)\n{\n  DIR * d;\n#ifdef HAS_DIRENT\n  struct dirent * e;\n#else\n  struct direct * e;\n#endif\n\n  d = opendir(dirname);\n  if (d == NULL) return -1;\n  while (1) {\n    e = readdir(d);\n    if (e == NULL) break;\n    if (strcmp(e->d_name, \".\") == 0 || strcmp(e->d_name, \"..\") == 0) continue;\n    caml_ext_table_add(contents, caml_stat_strdup(e->d_name));\n  }\n  closedir(d);\n  return 0;\n}\n\n/* Recover executable name from /proc/self/exe if possible */\n\nchar * caml_executable_name(void)\n{\n#if defined(__linux__)\n  int namelen, retcode;\n  char * name;\n  struct stat st;\n\n  /* lstat(\"/proc/self/exe\") returns st_size == 0 so we cannot use it\n     to determine the size of the buffer.  Instead, we guess and adjust. */\n  namelen = 256;\n  while (1) {\n    name = caml_stat_alloc(namelen);\n    retcode = readlink(\"/proc/self/exe\", name, namelen);\n    if (retcode == -1) { caml_stat_free(name); return NULL; }\n    if (retcode < namelen) break;\n    caml_stat_free(name);\n    if (namelen >= 1024*1024) return NULL; /* avoid runaway and overflow */\n    namelen *= 2;\n  }\n  /* readlink() does not zero-terminate its result.\n     There is room for a final zero since retcode < namelen. */\n  name[retcode] = 0;\n  /* Make sure that the contents of /proc/self/exe is a regular file.\n     (Old Linux kernels return an inode number instead.) */\n  if (stat(name, &st) == -1 || ! S_ISREG(st.st_mode)) {\n    caml_stat_free(name); return NULL;\n  }\n  return name;\n\n#elif defined(__APPLE__)\n  unsigned int namelen;\n  char * name;\n\n  namelen = 256;\n  name = caml_stat_alloc(namelen);\n  if (_NSGetExecutablePath(name, &namelen) == 0) return name;\n  caml_stat_free(name);\n  /* Buffer is too small, but namelen now contains the size needed */\n  name = caml_stat_alloc(namelen);\n  if (_NSGetExecutablePath(name, &namelen) == 0) return name;\n  caml_stat_free(name);\n  return NULL;\n\n#else\n  return NULL;\n\n#endif\n}\n\nchar *caml_secure_getenv (char const *var)\n{\n#ifdef HAS_SECURE_GETENV\n  return secure_getenv (var);\n#elif defined (HAS___SECURE_GETENV)\n  return __secure_getenv (var);\n#elif defined(HAS_ISSETUGID)\n  if (!issetugid ())\n    return CAML_SYS_GETENV (var);\n  else\n    return NULL;\n#else\n  if (geteuid () == getuid () && getegid () == getgid ())\n    return CAML_SYS_GETENV (var);\n  else\n    return NULL;\n#endif\n}\n\nint caml_num_rows_fd(int fd)\n{\n#ifdef TIOCGWINSZ\n  struct winsize w;\n  w.ws_row = -1;\n  if (ioctl(fd, TIOCGWINSZ, &w) == 0)\n    return w.ws_row;\n  else\n    return -1;\n#else\n  return -1;\n#endif\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/byterun/sys.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           */\n/*                                                                        */\n/*   Copyright 1996 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#define CAML_INTERNALS\n\n/* Basic system calls */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifdef _WIN32\n#include <direct.h> /* for _wchdir and _wgetcwd */\n#else\n#include <sys/wait.h>\n#endif\n#include \"caml/config.h\"\n#ifdef HAS_UNISTD\n#include <unistd.h>\n#endif\n#ifdef HAS_TIMES\n#include <sys/times.h>\n#endif\n#ifdef HAS_GETRUSAGE\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n#ifdef HAS_GETTIMEOFDAY\n#include <sys/time.h>\n#endif\n#include \"caml/alloc.h\"\n#include \"caml/debugger.h\"\n#include \"caml/fail.h\"\n#include \"caml/gc_ctrl.h\"\n#include \"caml/io.h\"\n#include \"caml/misc.h\"\n#include \"caml/mlvalues.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/signals.h\"\n#include \"caml/stacks.h\"\n#include \"caml/sys.h\"\n#include \"caml/version.h\"\n#include \"caml/callback.h\"\n#include \"caml/startup_aux.h\"\n\nstatic char * error_message(void)\n{\n  return strerror(errno);\n}\n\n#ifndef EAGAIN\n#define EAGAIN (-1)\n#endif\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK (-1)\n#endif\n\nCAMLexport void caml_sys_error(value arg)\n{\n  CAMLparam1 (arg);\n  char * err;\n  CAMLlocal1 (str);\n\n  err = error_message();\n  if (arg == NO_ARG) {\n    str = caml_copy_string(err);\n  } else {\n    int err_len = strlen(err);\n    int arg_len = caml_string_length(arg);\n    str = caml_alloc_string(arg_len + 2 + err_len);\n    memmove(&Byte(str, 0), String_val(arg), arg_len);\n    memmove(&Byte(str, arg_len), \": \", 2);\n    memmove(&Byte(str, arg_len + 2), err, err_len);\n  }\n  caml_raise_sys_error(str);\n  CAMLnoreturn;\n}\n\nCAMLexport void caml_sys_io_error(value arg)\n{\n  if (errno == EAGAIN || errno == EWOULDBLOCK) {\n    caml_raise_sys_blocked_io();\n  } else {\n    caml_sys_error(arg);\n  }\n}\n\n/* Check that [name] can safely be used as a file path */\n\nstatic void caml_sys_check_path(value name)\n{\n  if (! caml_string_is_c_safe(name)) {\n    errno = ENOENT;\n    caml_sys_error(name);\n  }\n}\n\nCAMLprim value caml_sys_exit(value retcode_v)\n{\n  int retcode = Int_val(retcode_v);\n\n  if ((caml_verb_gc & 0x400) != 0) {\n    /* cf caml_gc_counters */\n    double minwords = caml_stat_minor_words\n      + (double) (caml_young_end - caml_young_ptr);\n    double prowords = caml_stat_promoted_words;\n    double majwords = caml_stat_major_words + (double) caml_allocated_words;\n    double allocated_words = minwords + majwords - prowords;\n    intnat mincoll = caml_stat_minor_collections;\n    intnat majcoll = caml_stat_major_collections;\n    intnat heap_words = caml_stat_heap_wsz;\n    intnat heap_chunks = caml_stat_heap_chunks;\n    intnat top_heap_words = caml_stat_top_heap_wsz;\n    intnat cpct = caml_stat_compactions;\n    caml_gc_message(0x400, \"allocated_words: %.0f\\n\", allocated_words);\n    caml_gc_message(0x400, \"minor_words: %.0f\\n\", minwords);\n    caml_gc_message(0x400, \"promoted_words: %.0f\\n\", prowords);\n    caml_gc_message(0x400, \"major_words: %.0f\\n\", majwords);\n    caml_gc_message(0x400, \"minor_collections: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    mincoll);\n    caml_gc_message(0x400, \"major_collections: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    majcoll);\n    caml_gc_message(0x400, \"heap_words: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    heap_words);\n    caml_gc_message(0x400, \"heap_chunks: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    heap_chunks);\n    caml_gc_message(0x400, \"top_heap_words: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    top_heap_words);\n    caml_gc_message(0x400, \"compactions: %\"ARCH_INTNAT_PRINTF_FORMAT\"d\\n\",\n                    cpct);\n  }\n\n#ifndef NATIVE_CODE\n  caml_debugger(PROGRAM_EXIT);\n#endif\n  CAML_INSTR_ATEXIT ();\n  if (caml_cleanup_on_exit)\n    caml_shutdown();\n#ifdef _WIN32\n  caml_restore_win32_terminal();\n#endif\n  CAML_SYS_EXIT(retcode);\n  return Val_unit;\n}\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#ifndef O_TEXT\n#define O_TEXT 0\n#endif\n#ifndef O_NONBLOCK\n#ifdef O_NDELAY\n#define O_NONBLOCK O_NDELAY\n#else\n#define O_NONBLOCK 0\n#endif\n#endif\n\nstatic int sys_open_flags[] = {\n  O_RDONLY, O_WRONLY, O_APPEND | O_WRONLY, O_CREAT, O_TRUNC, O_EXCL,\n  O_BINARY, O_TEXT, O_NONBLOCK\n};\n\nCAMLprim value caml_sys_open(value path, value vflags, value vperm)\n{\n  CAMLparam3(path, vflags, vperm);\n  int fd, flags, perm;\n  char_os * p;\n\n#if defined(O_CLOEXEC)\n  flags = O_CLOEXEC;\n#elif defined(_WIN32)\n  flags = _O_NOINHERIT;\n#else\n  flags = 0;\n#endif\n\n  caml_sys_check_path(path);\n  p = caml_stat_strdup_to_os(String_val(path));\n  flags |= caml_convert_flag_list(vflags, sys_open_flags);\n  perm = Int_val(vperm);\n  /* open on a named FIFO can block (PR#1533) */\n  caml_enter_blocking_section();\n  fd = CAML_SYS_OPEN(p, flags, perm);\n  /* fcntl on a fd can block (PR#5069)*/\n#if defined(F_SETFD) && defined(FD_CLOEXEC) && !defined(_WIN32) \\\n  && !defined(O_CLOEXEC)\n  if (fd != -1)\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n#endif\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (fd == -1) caml_sys_error(path);\n  CAMLreturn(Val_long(fd));\n}\n\nCAMLprim value caml_sys_close(value fd_v)\n{\n  int fd = Int_val(fd_v);\n  caml_enter_blocking_section();\n  CAML_SYS_CLOSE(fd);\n  caml_leave_blocking_section();\n  return Val_unit;\n}\n\nCAMLprim value caml_sys_file_exists(value name)\n{\n#ifdef _WIN32\n  struct _stati64 st;\n#else\n  struct stat st;\n#endif\n  char_os * p;\n  int ret;\n\n  if (! caml_string_is_c_safe(name)) return Val_false;\n  p = caml_stat_strdup_to_os(String_val(name));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_STAT(p, &st);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  return Val_bool(ret == 0);\n}\n\nCAMLprim value caml_sys_is_directory(value name)\n{\n  CAMLparam1(name);\n#ifdef _WIN32\n  struct _stati64 st;\n#else\n  struct stat st;\n#endif\n  char_os * p;\n  int ret;\n\n  caml_sys_check_path(name);\n  p = caml_stat_strdup_to_os(String_val(name));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_STAT(p, &st);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  if (ret == -1) caml_sys_error(name);\n#ifdef S_ISDIR\n  CAMLreturn(Val_bool(S_ISDIR(st.st_mode)));\n#else\n  CAMLreturn(Val_bool(st.st_mode & S_IFDIR));\n#endif\n}\n\nCAMLprim value caml_sys_remove(value name)\n{\n  CAMLparam1(name);\n  char_os * p;\n  int ret;\n  caml_sys_check_path(name);\n  p = caml_stat_strdup_to_os(String_val(name));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_UNLINK(p);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (ret != 0) caml_sys_error(name);\n  CAMLreturn(Val_unit);\n}\n\nCAMLprim value caml_sys_rename(value oldname, value newname)\n{\n  char_os * p_old;\n  char_os * p_new;\n  int ret;\n  caml_sys_check_path(oldname);\n  caml_sys_check_path(newname);\n  p_old = caml_stat_strdup_to_os(String_val(oldname));\n  p_new = caml_stat_strdup_to_os(String_val(newname));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_RENAME(p_old, p_new);\n  caml_leave_blocking_section();\n  caml_stat_free(p_new);\n  caml_stat_free(p_old);\n  if (ret != 0)\n    caml_sys_error(NO_ARG);\n  return Val_unit;\n}\n\nCAMLprim value caml_sys_chdir(value dirname)\n{\n  CAMLparam1(dirname);\n  char_os * p;\n  int ret;\n  caml_sys_check_path(dirname);\n  p = caml_stat_strdup_to_os(String_val(dirname));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_CHDIR(p);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (ret != 0) caml_sys_error(dirname);\n  CAMLreturn(Val_unit);\n}\n\nCAMLprim value caml_sys_getcwd(value unit)\n{\n  char_os buff[4096];\n  char_os * ret;\n#ifdef HAS_GETCWD\n  ret = getcwd_os(buff, sizeof(buff)/sizeof(*buff));\n#else\n  caml_invalid_argument(\"Sys.getcwd not implemented\");\n#endif /* HAS_GETCWD */\n  if (ret == 0) caml_sys_error(NO_ARG);\n  return caml_copy_string_of_os(buff);\n}\n\nCAMLprim value caml_sys_unsafe_getenv(value var)\n{\n  char_os * res, * p;\n  value val;\n\n  if (! caml_string_is_c_safe(var)) caml_raise_not_found();\n  p = caml_stat_strdup_to_os(String_val(var));\n#ifdef _WIN32\n  res = caml_win32_getenv(p);\n#else\n  res = CAML_SYS_GETENV(p);\n#endif\n  caml_stat_free(p);\n  if (res == 0) caml_raise_not_found();\n  val = caml_copy_string_of_os(res);\n#ifdef _WIN32\n  caml_stat_free(res);\n#endif\n  return val;\n}\n\nCAMLprim value caml_sys_getenv(value var)\n{\n  char_os * res, * p;\n  value val;\n\n  if (! caml_string_is_c_safe(var)) caml_raise_not_found();\n  p = caml_stat_strdup_to_os(String_val(var));\n#ifdef _WIN32\n  res = caml_win32_getenv(p);\n#else\n  res = caml_secure_getenv(p);\n#endif\n  caml_stat_free(p);\n  if (res == 0) caml_raise_not_found();\n  val = caml_copy_string_of_os(res);\n#ifdef _WIN32\n  caml_stat_free(res);\n#endif\n  return val;\n}\n\nchar_os * caml_exe_name;\nchar_os ** caml_main_argv;\n\nCAMLprim value caml_sys_get_argv(value unit)\n{\n  CAMLparam0 ();   /* unit is unused */\n  CAMLlocal3 (exe_name, argv, res);\n  exe_name = caml_copy_string_of_os(caml_exe_name);\n  argv = caml_alloc_array((void *)caml_copy_string_of_os, (char const **) caml_main_argv);\n  res = caml_alloc_small(2, 0);\n  Field(res, 0) = exe_name;\n  Field(res, 1) = argv;\n  CAMLreturn(res);\n}\n\nvoid caml_sys_init(char_os * exe_name, char_os **argv)\n{\n#ifdef _WIN32\n  /* Initialises the caml_win32_* globals on Windows with the version of\n     Windows which is running */\n  caml_probe_win32_version();\n#if WINDOWS_UNICODE\n  caml_setup_win32_terminal();\n#endif\n#endif\n#ifdef CAML_WITH_CPLUGINS\n  caml_cplugins_init(exe_name, argv);\n#endif\n  caml_exe_name = exe_name;\n  caml_main_argv = argv;\n}\n\n#ifdef _WIN32\n#define WIFEXITED(status) 1\n#define WEXITSTATUS(status) (status)\n#else\n#if !(defined(WIFEXITED) && defined(WEXITSTATUS))\n/* Assume old-style V7 status word */\n#define WIFEXITED(status) (((status) & 0xFF) == 0)\n#define WEXITSTATUS(status) (((status) >> 8) & 0xFF)\n#endif\n#endif\n\nCAMLprim value caml_sys_system_command(value command)\n{\n  CAMLparam1 (command);\n  int status, retcode;\n  char_os *buf;\n\n  if (! caml_string_is_c_safe (command)) {\n    errno = EINVAL;\n    caml_sys_error(command);\n  }\n  buf = caml_stat_strdup_to_os(String_val(command));\n  caml_enter_blocking_section ();\n  status = CAML_SYS_SYSTEM(buf);\n  caml_leave_blocking_section ();\n  caml_stat_free(buf);\n  if (status == -1) caml_sys_error(command);\n  if (WIFEXITED(status))\n    retcode = WEXITSTATUS(status);\n  else\n    retcode = 255;\n  CAMLreturn (Val_int(retcode));\n}\n\ndouble caml_sys_time_include_children_unboxed(value include_children)\n{\n#ifdef HAS_GETRUSAGE\n  struct rusage ru;\n  double acc = 0.;\n\n  getrusage (RUSAGE_SELF, &ru);\n  acc += ru.ru_utime.tv_sec + ru.ru_utime.tv_usec / 1e6\n    + ru.ru_stime.tv_sec + ru.ru_stime.tv_usec / 1e6;\n\n  if (Bool_val(include_children)) {\n    getrusage (RUSAGE_CHILDREN, &ru);\n    acc += ru.ru_utime.tv_sec + ru.ru_utime.tv_usec / 1e6\n      + ru.ru_stime.tv_sec + ru.ru_stime.tv_usec / 1e6;\n  }\n\n  return acc;\n#else\n  #ifdef HAS_TIMES\n    #ifndef CLK_TCK\n      #ifdef HZ\n        #define CLK_TCK HZ\n      #else\n        #define CLK_TCK 60\n      #endif\n    #endif\n    struct tms t;\n    clock_t acc = 0;\n    times(&t);\n    acc += t.tms_utime + t.tms_stime;\n    if (Bool_val(include_children)) {\n      acc += t.tms_cutime + t.tms_cstime;\n    }\n    return (double)acc / CLK_TCK;\n  #else\n    /* clock() is standard ANSI C. We have no way of getting\n       subprocess times in this branch. */\n    return (double)clock() / CLOCKS_PER_SEC;\n  #endif\n#endif\n}\n\nCAMLprim value caml_sys_time_include_children(value include_children)\n{\n  return caml_copy_double(caml_sys_time_include_children_unboxed(include_children));\n}\n\ndouble caml_sys_time_unboxed(value unit) {\n  return caml_sys_time_include_children_unboxed(Val_false);\n}\n\nCAMLprim value caml_sys_time(value unit)\n{\n  return caml_copy_double(caml_sys_time_unboxed(unit));\n}\n\n#ifdef _WIN32\nextern int caml_win32_random_seed (intnat data[16]);\n#endif\n\nCAMLprim value caml_sys_random_seed (value unit)\n{\n  intnat data[16];\n  int n, i;\n  value res;\n#ifdef _WIN32\n  n = caml_win32_random_seed(data);\n#else\n  int fd;\n  n = 0;\n  /* Try /dev/urandom first */\n  fd = open(\"/dev/urandom\", O_RDONLY, 0);\n  if (fd != -1) {\n    unsigned char buffer[12];\n    int nread = read(fd, buffer, 12);\n    close(fd);\n    while (nread > 0) data[n++] = buffer[--nread];\n  }\n  /* If the read from /dev/urandom fully succeeded, we now have 96 bits\n     of good random data and can stop here.  Otherwise, complement\n     whatever we got (probably nothing) with some not-very-random data. */\n  if (n < 12) {\n#ifdef HAS_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    data[n++] = tv.tv_usec;\n    data[n++] = tv.tv_sec;\n#else\n    data[n++] = time(NULL);\n#endif\n#ifdef HAS_UNISTD\n    data[n++] = getpid();\n    data[n++] = getppid();\n#endif\n  }\n#endif\n  /* Convert to an OCaml array of ints */\n  res = caml_alloc_small(n, 0);\n  for (i = 0; i < n; i++) Field(res, i) = Val_long(data[i]);\n  return res;\n}\n\nCAMLprim value caml_sys_const_big_endian(value unit)\n{\n#ifdef ARCH_BIG_ENDIAN\n  return Val_true;\n#else\n  return Val_false;\n#endif\n}\n\n/* returns a value that represents a number of bits */\nCAMLprim value caml_sys_const_word_size(value unit)\n{\n  return Val_long(8 * sizeof(value));\n}\n\n/* returns a value that represents a number of bits */\nCAMLprim value caml_sys_const_int_size(value unit)\n{\n  return Val_long(8 * sizeof(value) - 1) ;\n}\n\n/* returns a value that represents a number of words */\nCAMLprim value caml_sys_const_max_wosize(value unit)\n{\n  return Val_long(Max_wosize) ;\n}\n\nCAMLprim value caml_sys_const_ostype_unix(value unit)\n{\n  return Val_bool(0 == strcmp(OCAML_OS_TYPE,\"Unix\"));\n}\n\nCAMLprim value caml_sys_const_ostype_win32(value unit)\n{\n  return Val_bool(0 == strcmp(OCAML_OS_TYPE,\"Win32\"));\n}\n\nCAMLprim value caml_sys_const_ostype_cygwin(value unit)\n{\n  return Val_bool(0 == strcmp(OCAML_OS_TYPE,\"Cygwin\"));\n}\n\nCAMLprim value caml_sys_const_backend_type(value unit)\n{\n  return Val_int(1); /* Bytecode backed */\n}\nCAMLprim value caml_sys_get_config(value unit)\n{\n  CAMLparam0 ();   /* unit is unused */\n  CAMLlocal2 (result, ostype);\n\n  ostype = caml_copy_string(OCAML_OS_TYPE);\n  result = caml_alloc_small (3, 0);\n  Field(result, 0) = ostype;\n  Field(result, 1) = Val_long (8 * sizeof(value));\n#ifdef ARCH_BIG_ENDIAN\n  Field(result, 2) = Val_true;\n#else\n  Field(result, 2) = Val_false;\n#endif\n  CAMLreturn (result);\n}\n\nCAMLprim value caml_sys_read_directory(value path)\n{\n  CAMLparam1(path);\n  CAMLlocal1(result);\n  struct ext_table tbl;\n  char_os * p;\n  int ret;\n\n  caml_sys_check_path(path);\n  caml_ext_table_init(&tbl, 50);\n  p = caml_stat_strdup_to_os(String_val(path));\n  caml_enter_blocking_section();\n  ret = CAML_SYS_READ_DIRECTORY(p, &tbl);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (ret == -1){\n    caml_ext_table_free(&tbl, 1);\n    caml_sys_error(path);\n  }\n  caml_ext_table_add(&tbl, NULL);\n  result = caml_copy_string_array((char const **) tbl.contents);\n  caml_ext_table_free(&tbl, 1);\n  CAMLreturn(result);\n}\n\n/* Return true if the value is a filedescriptor (int) that is\n * (presumably) open on an interactive terminal */\nCAMLprim value caml_sys_isatty(value chan)\n{\n  int fd;\n  value ret;\n\n  fd = (Channel(chan))->fd;\n#ifdef _WIN32\n  ret = Val_bool(caml_win32_isatty(fd));\n#else\n  ret = Val_bool(isatty(fd));\n#endif\n\n  return ret;\n}\n\n/* Load dynamic plugins indicated in the CAML_CPLUGINS environment\n   variable. These plugins can be used to set currently existing\n   hooks, such as GC hooks and system calls tracing (see misc.h).\n */\n\n#ifdef CAML_WITH_CPLUGINS\n\nvalue (*caml_cplugins_prim)(int,value,value,value) = NULL;\n\n#define DLL_EXECUTABLE 1\n#define DLL_NOT_GLOBAL 0\n\nstatic struct cplugin_context cplugin_context;\n\nvoid caml_load_plugin(char_os *plugin)\n{\n  void* dll_handle = NULL;\n  char* u8;\n\n  dll_handle = caml_dlopen(plugin, DLL_EXECUTABLE, DLL_NOT_GLOBAL);\n  if( dll_handle != NULL ){\n   void (* dll_init)(struct cplugin_context*) =\n     caml_dlsym(dll_handle, \"caml_cplugin_init\");\n   if( dll_init != NULL ){\n     cplugin_context.plugin=plugin;\n     dll_init(&cplugin_context);\n   } else {\n     caml_dlclose(dll_handle);\n   }\n  } else {\n   u8 = caml_stat_strdup_of_os(plugin);\n   fprintf(stderr, \"Cannot load C plugin %s\\nReason: %s\\n\",\n           u8, caml_dlerror());\n   caml_stat_free(u8);\n  }\n}\n\nvoid caml_cplugins_load(char_os *env_variable)\n{\n  char_os *plugins = caml_secure_getenv(env_variable);\n  if(plugins != NULL){\n    char_os* curs = plugins;\n    while(*curs != 0){\n      if(*curs == _T(',')){\n          if(curs > plugins){\n            *curs = 0;\n            caml_load_plugin(plugins);\n          }\n          plugins = curs+1;\n        }\n        curs++;\n    }\n    if(curs > plugins) caml_load_plugin(plugins);\n  }\n}\n\nvoid caml_cplugins_init(char_os * exe_name, char_os **argv)\n{\n  cplugin_context.api_version = CAML_CPLUGIN_CONTEXT_API;\n  cplugin_context.prims_bitmap = CAML_CPLUGINS_PRIMS_BITMAP;\n  cplugin_context.exe_name = exe_name;\n  cplugin_context.argv = argv;\n  cplugin_context.ocaml_version = OCAML_VERSION_STRING;\n  caml_cplugins_load(_T(\"CAML_CPLUGINS\"));\n#ifdef NATIVE_CODE\n  caml_cplugins_load(_T(\"CAML_NATIVE_CPLUGINS\"));\n#else\n  caml_cplugins_load(_T(\"CAML_BYTE_CPLUGINS\"));\n#endif\n}\n\n#endif /* CAML_WITH_CPLUGINS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/byterun/win32.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 1996 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#define CAML_INTERNALS\n\n/* Win32-specific stuff */\n\n/* FILE_INFO_BY_HANDLE_CLASS and FILE_NAME_INFO are only available from Windows\n   Vista onwards */\n#undef _WIN32_WINNT\n#define _WIN32_WINNT 0x0600\n\n#define WIN32_LEAN_AND_MEAN\n#include <wtypes.h>\n#include <winbase.h>\n#include <winsock2.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <io.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include \"caml/alloc.h\"\n#include \"caml/address_class.h\"\n#include \"caml/fail.h\"\n#include \"caml/io.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/signals.h\"\n#include \"caml/sys.h\"\n\n#include \"caml/config.h\"\n#ifdef SUPPORT_DYNAMIC_LINKING\n#include <flexdll.h>\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)\n#endif\n\nunsigned short caml_win32_major = 0;\nunsigned short caml_win32_minor = 0;\nunsigned short caml_win32_build = 0;\nunsigned short caml_win32_revision = 0;\n\nCAMLnoreturn_start\nstatic void caml_win32_sys_error (int errnum)\nCAMLnoreturn_end;\n\nstatic void caml_win32_sys_error(int errnum)\n{\n  wchar_t buffer[512];\n  value msg;\n  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                    NULL,\n                    errnum,\n                    0,\n                    buffer,\n                    sizeof(buffer)/sizeof(wchar_t),\n                    NULL)) {\n    msg = caml_copy_string_of_utf16(buffer);\n  } else {\n    msg = caml_alloc_sprintf(\"unknown error #%d\", errnum);\n  }\n  caml_raise_sys_error(msg);\n}\n\nint caml_read_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  if ((flags & CHANNEL_FLAG_FROM_SOCKET) == 0) {\n    caml_enter_blocking_section();\n    retcode = read(fd, buf, n);\n    /* Large reads from console can fail with ENOMEM.  Reduce requested size\n       and try again. */\n    if (retcode == -1 && errno == ENOMEM && n > 16384) {\n      retcode = read(fd, buf, 16384);\n    }\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_sys_io_error(NO_ARG);\n  } else {\n    caml_enter_blocking_section();\n    retcode = recv((SOCKET) _get_osfhandle(fd), buf, n, 0);\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_win32_sys_error(WSAGetLastError());\n  }\n  return retcode;\n}\n\nint caml_write_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  if ((flags & CHANNEL_FLAG_FROM_SOCKET) == 0) {\n#if defined(NATIVE_CODE) && defined(WITH_SPACETIME)\n  if (flags & CHANNEL_FLAG_BLOCKING_WRITE) {\n    retcode = write(fd, buf, n);\n  } else {\n#endif\n    caml_enter_blocking_section();\n    retcode = write(fd, buf, n);\n    caml_leave_blocking_section();\n#if defined(NATIVE_CODE) && defined(WITH_SPACETIME)\n  }\n#endif\n    if (retcode == -1) caml_sys_io_error(NO_ARG);\n  } else {\n    caml_enter_blocking_section();\n    retcode = send((SOCKET) _get_osfhandle(fd), buf, n, 0);\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_win32_sys_error(WSAGetLastError());\n  }\n  CAMLassert (retcode > 0);\n  return retcode;\n}\n\nwchar_t * caml_decompose_path(struct ext_table * tbl, wchar_t * path)\n{\n  wchar_t * p, * q;\n  int n;\n\n  if (path == NULL) return NULL;\n  p = caml_stat_wcsdup(path);\n  q = p;\n  while (1) {\n    for (n = 0; q[n] != 0 && q[n] != L';'; n++) /*nothing*/;\n    caml_ext_table_add(tbl, q);\n    q = q + n;\n    if (*q == 0) break;\n    *q = 0;\n    q += 1;\n  }\n  return p;\n}\n\nwchar_t * caml_search_in_path(struct ext_table * path, const wchar_t * name)\n{\n  wchar_t * dir, * fullname;\n  char * u8;\n  const wchar_t * p;\n  int i;\n  struct _stati64 st;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/' || *p == '\\\\') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) continue;\n         /* not sure what empty path components mean under Windows */\n    fullname = caml_stat_wcsconcat(3, dir, L\"\\\\\", name);\n    u8 = caml_stat_strdup_of_utf16(fullname);\n    caml_gc_message(0x100, \"Searching %s\\n\", u8);\n    caml_stat_free(u8);\n    if (_wstati64(fullname, &st) == 0 && S_ISREG(st.st_mode))\n      return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  u8 = caml_stat_strdup_of_utf16(name);\n  caml_gc_message(0x100, \"%s not found in search path\\n\", u8);\n  caml_stat_free(u8);\n  return caml_stat_wcsdup(name);\n}\n\nCAMLexport wchar_t * caml_search_exe_in_path(const wchar_t * name)\n{\n  wchar_t * fullname, * filepart;\n  char * u8;\n  size_t fullnamelen;\n  DWORD retcode;\n\n  fullnamelen = wcslen(name) + 1;\n  if (fullnamelen < 256) fullnamelen = 256;\n  while (1) {\n    fullname = caml_stat_alloc(fullnamelen*sizeof(wchar_t));\n    retcode = SearchPath(NULL,              /* use system search path */\n                         name,\n                         L\".exe\",            /* add .exe extension if needed */\n                         fullnamelen,\n                         fullname,\n                         &filepart);\n    if (retcode == 0) {\n      u8 = caml_stat_strdup_of_utf16(name);\n      caml_gc_message(0x100, \"%s not found in search path\\n\", u8);\n      caml_stat_free(u8);\n      caml_stat_free(fullname);\n      return caml_stat_strdup_os(name);\n    }\n    if (retcode < fullnamelen)\n      return fullname;\n    caml_stat_free(fullname);\n    fullnamelen = retcode + 1;\n  }\n}\n\nwchar_t * caml_search_dll_in_path(struct ext_table * path, const wchar_t * name)\n{\n  wchar_t * dllname;\n  wchar_t * res;\n\n  dllname = caml_stat_wcsconcat(2, name, L\".dll\");\n  res = caml_search_in_path(path, dllname);\n  caml_stat_free(dllname);\n  return res;\n}\n\n#ifdef SUPPORT_DYNAMIC_LINKING\n\nvoid * caml_dlopen(wchar_t * libname, int for_execution, int global)\n{\n  void *handle;\n  int flags = (global ? FLEXDLL_RTLD_GLOBAL : 0);\n  if (!for_execution) flags |= FLEXDLL_RTLD_NOEXEC;\n  handle = flexdll_wdlopen(libname, flags);\n  if ((handle != NULL) && ((caml_verb_gc & 0x100) != 0)) {\n    flexdll_dump_exports(handle);\n    fflush(stdout);\n  }\n  return handle;\n}\n\nvoid caml_dlclose(void * handle)\n{\n  flexdll_dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, const char * name)\n{\n  return flexdll_dlsym(handle, name);\n}\n\nvoid * caml_globalsym(const char * name)\n{\n  return flexdll_dlsym(flexdll_dlopen(NULL,0), name);\n}\n\nchar * caml_dlerror(void)\n{\n  return flexdll_dlerror();\n}\n\n#else\n\nvoid * caml_dlopen(wchar_t * libname, int for_execution, int global)\n{\n  return NULL;\n}\n\nvoid caml_dlclose(void * handle)\n{\n}\n\nvoid * caml_dlsym(void * handle, const char * name)\n{\n  return NULL;\n}\n\nvoid * caml_globalsym(const char * name)\n{\n  return NULL;\n}\n\nchar * caml_dlerror(void)\n{\n  return \"dynamic loading not supported on this platform\";\n}\n\n#endif\n\n/* Proper emulation of signal(), including ctrl-C and ctrl-break */\n\ntypedef void (*sighandler)(int sig);\nstatic int ctrl_handler_installed = 0;\nstatic volatile sighandler ctrl_handler_action = SIG_DFL;\n\nstatic BOOL WINAPI ctrl_handler(DWORD event)\n{\n  /* Only ctrl-C and ctrl-Break are handled */\n  if (event != CTRL_C_EVENT && event != CTRL_BREAK_EVENT) return FALSE;\n  /* Default behavior is to exit, which we get by not handling the event */\n  if (ctrl_handler_action == SIG_DFL) return FALSE;\n  /* Ignore behavior is to do nothing, which we get by claiming that we\n     have handled the event */\n  if (ctrl_handler_action == SIG_IGN) return TRUE;\n  /* Win32 doesn't like it when we do a longjmp() at this point\n     (it looks like we're running in a different thread than\n     the main program!).  So, just record the signal. */\n  caml_record_signal(SIGINT);\n  /* We have handled the event */\n  return TRUE;\n}\n\nsighandler caml_win32_signal(int sig, sighandler action)\n{\n  sighandler oldaction;\n\n  if (sig != SIGINT) return signal(sig, action);\n  if (! ctrl_handler_installed) {\n    SetConsoleCtrlHandler(ctrl_handler, TRUE);\n    ctrl_handler_installed = 1;\n  }\n  oldaction = ctrl_handler_action;\n  ctrl_handler_action = action;\n  return oldaction;\n}\n\n/* Expansion of @responsefile and *? file patterns in the command line */\n\nstatic int argc;\nstatic wchar_t ** argv;\nstatic int argvsize;\n\nstatic void store_argument(wchar_t * arg);\nstatic void expand_argument(wchar_t * arg);\nstatic void expand_pattern(wchar_t * arg);\n\nstatic void out_of_memory(void)\n{\n  fprintf(stderr, \"Out of memory while expanding command line\\n\");\n  exit(2);\n}\n\nstatic void store_argument(wchar_t * arg)\n{\n  if (argc + 1 >= argvsize) {\n    argvsize *= 2;\n    argv = (wchar_t **) caml_stat_resize_noexc(argv, argvsize * sizeof(wchar_t *));\n    if (argv == NULL) out_of_memory();\n  }\n  argv[argc++] = arg;\n}\n\nstatic void expand_argument(wchar_t * arg)\n{\n  wchar_t * p;\n\n  for (p = arg; *p != 0; p++) {\n    if (*p == L'*' || *p == L'?') {\n      expand_pattern(arg);\n      return;\n    }\n  }\n  store_argument(arg);\n}\n\nstatic void expand_pattern(wchar_t * pat)\n{\n  wchar_t * prefix, * p, * name;\n  intptr_t handle;\n  struct _wfinddata_t ffblk;\n  size_t i;\n\n  handle = _wfindfirst(pat, &ffblk);\n  if (handle == -1) {\n    store_argument(pat); /* a la Bourne shell */\n    return;\n  }\n  prefix = caml_stat_wcsdup(pat);\n  /* We need to stop at the first directory or drive boundary, because the\n   * _findata_t structure contains the filename, not the leading directory. */\n  for (i = wcslen(prefix); i > 0; i--) {\n    wchar_t c = prefix[i - 1];\n    if (c == L'\\\\' || c == L'/' || c == L':') { prefix[i] = 0; break; }\n  }\n  /* No separator was found, it's a filename pattern without a leading directory. */\n  if (i == 0)\n    prefix[0] = 0;\n  do {\n    name = caml_stat_wcsconcat(2, prefix, ffblk.name);\n    store_argument(name);\n  } while (_wfindnext(handle, &ffblk) != -1);\n  _findclose(handle);\n  caml_stat_free(prefix);\n}\n\n\nCAMLexport void caml_expand_command_line(int * argcp, wchar_t *** argvp)\n{\n  int i;\n  argc = 0;\n  argvsize = 16;\n  argv = (wchar_t **) caml_stat_alloc_noexc(argvsize * sizeof(wchar_t *));\n  if (argv == NULL) out_of_memory();\n  for (i = 0; i < *argcp; i++) expand_argument((*argvp)[i]);\n  argv[argc] = NULL;\n  *argcp = argc;\n  *argvp = argv;\n}\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\n\nint caml_read_directory(wchar_t * dirname, struct ext_table * contents)\n{\n  size_t dirnamelen;\n  wchar_t * template;\n  intptr_t h;\n  struct _wfinddata_t fileinfo;\n\n  dirnamelen = wcslen(dirname);\n  if (dirnamelen > 0 &&\n      (dirname[dirnamelen - 1] == L'/'\n       || dirname[dirnamelen - 1] == L'\\\\'\n       || dirname[dirnamelen - 1] == L':'))\n    template = caml_stat_wcsconcat(2, dirname, L\"*.*\");\n  else\n    template = caml_stat_wcsconcat(2, dirname, L\"\\\\*.*\");\n  h = _wfindfirst(template, &fileinfo);\n  if (h == -1) {\n    caml_stat_free(template);\n    return errno == ENOENT ? 0 : -1;\n  }\n  do {\n    if (wcscmp(fileinfo.name, L\".\") != 0 && wcscmp(fileinfo.name, L\"..\") != 0) {\n      caml_ext_table_add(contents, caml_stat_strdup_of_utf16(fileinfo.name));\n    }\n  } while (_wfindnext(h, &fileinfo) == 0);\n  _findclose(h);\n  caml_stat_free(template);\n  return 0;\n}\n\n#ifndef NATIVE_CODE\n\n/* Set up a new thread for control-C emulation and termination */\n\nvoid caml_signal_thread(void * lpParam)\n{\n  wchar_t *endptr;\n  HANDLE h;\n  /* Get an hexa-code raw handle through the environment */\n  h = (HANDLE) (uintptr_t)\n    wcstol(caml_secure_getenv(_T(\"CAMLSIGPIPE\")), &endptr, 16);\n  while (1) {\n    DWORD numread;\n    BOOL ret;\n    char iobuf[2];\n    /* This shall always return a single character */\n    ret = ReadFile(h, iobuf, 1, &numread, NULL);\n    if (!ret || numread != 1) caml_sys_exit(Val_int(2));\n    switch (iobuf[0]) {\n    case 'C':\n      caml_record_signal(SIGINT);\n      break;\n    case 'T':\n      raise(SIGTERM);\n      return;\n    }\n  }\n}\n\n#endif /* NATIVE_CODE */\n\n#if defined(NATIVE_CODE)\n\n/* Handling of system stack overflow.\n * Based on code provided by Olivier Andrieu.\n\n * An EXCEPTION_STACK_OVERFLOW is signaled when the guard page at the\n * end of the stack has been accessed. Windows clears the PAGE_GUARD\n * protection (making it a regular PAGE_READWRITE) and then calls our\n * exception handler. This means that although we're handling an \"out\n * of stack\" condition, there is a bit of stack available to call\n * functions and allocate temporaries.\n *\n * PAGE_GUARD is a one-shot access protection mechanism: we need to\n * restore the PAGE_GUARD protection on this page otherwise the next\n * stack overflow won't be detected and the program will abruptly exit\n * with STATUS_ACCESS_VIOLATION.\n *\n * Visual Studio 2003 and later (_MSC_VER >= 1300) have a\n * _resetstkoflw() function that resets this protection.\n * Unfortunately, it cannot work when called directly from the\n * exception handler because at this point we are using the page that\n * is to be protected.\n *\n * A solution is to use an alternate stack when restoring the\n * protection. However it's not possible to use _resetstkoflw() then\n * since it determines the stack pointer by calling alloca(): it would\n * try to protect the alternate stack.\n *\n * Finally, we call caml_raise_stack_overflow; it will either call\n * caml_raise_exception which switches back to the normal stack, or\n * call caml_fatal_uncaught_exception which terminates the program\n * quickly.\n */\n\nstatic uintnat win32_alt_stack[0x100];\n\nstatic void caml_reset_stack (void *faulting_address)\n{\n  SYSTEM_INFO si;\n  DWORD page_size;\n  MEMORY_BASIC_INFORMATION mbi;\n  DWORD oldprot;\n\n  /* get the system's page size. */\n  GetSystemInfo (&si);\n  page_size = si.dwPageSize;\n\n  /* get some information on the page the fault occurred */\n  if (! VirtualQuery (faulting_address, &mbi, sizeof mbi))\n    goto failed;\n\n  VirtualProtect (mbi.BaseAddress, page_size,\n                  mbi.Protect | PAGE_GUARD, &oldprot);\n\n failed:\n  caml_raise_stack_overflow();\n}\n\n\n#ifndef _WIN64\nstatic LONG CALLBACK\n    caml_stack_overflow_VEH (EXCEPTION_POINTERS* exn_info)\n{\n  DWORD code   = exn_info->ExceptionRecord->ExceptionCode;\n  CONTEXT *ctx = exn_info->ContextRecord;\n  DWORD *ctx_ip = &(ctx->Eip);\n  DWORD *ctx_sp = &(ctx->Esp);\n\n  if (code == EXCEPTION_STACK_OVERFLOW && Is_in_code_area (*ctx_ip))\n    {\n      uintnat faulting_address;\n      uintnat * alt_esp;\n\n      /* grab the address that caused the fault */\n      faulting_address = exn_info->ExceptionRecord->ExceptionInformation[1];\n\n      /* call caml_reset_stack(faulting_address) using the alternate stack */\n      alt_esp  = win32_alt_stack + sizeof(win32_alt_stack) / sizeof(uintnat);\n      *--alt_esp = faulting_address;\n      *ctx_sp = (uintnat) (alt_esp - 1);\n      *ctx_ip = (uintnat) &caml_reset_stack;\n\n      return EXCEPTION_CONTINUE_EXECUTION;\n    }\n\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n#else\nextern char *caml_exception_pointer;\nextern value *caml_young_ptr;\n\n/* Do not use the macro from address_class.h here. */\n#undef Is_in_code_area\n#define Is_in_code_area(pc) \\\n ( ((char *)(pc) >= caml_code_area_start && \\\n    (char *)(pc) <= caml_code_area_end)     \\\n|| ((char *)(pc) >= &caml_system__code_begin && \\\n    (char *)(pc) <= &caml_system__code_end)     \\\n|| (Classify_addr(pc) & In_code_area) )\nextern char caml_system__code_begin, caml_system__code_end;\n\n\nstatic LONG CALLBACK\n    caml_stack_overflow_VEH (EXCEPTION_POINTERS* exn_info)\n{\n  DWORD code   = exn_info->ExceptionRecord->ExceptionCode;\n  CONTEXT *ctx = exn_info->ContextRecord;\n\n  if (code == EXCEPTION_STACK_OVERFLOW && Is_in_code_area (ctx->Rip))\n    {\n      uintnat faulting_address;\n      uintnat * alt_rsp;\n\n      /* grab the address that caused the fault */\n      faulting_address = exn_info->ExceptionRecord->ExceptionInformation[1];\n\n      /* refresh runtime parameters from registers */\n      caml_exception_pointer =  (char *) ctx->R14;\n      caml_young_ptr         = (value *) ctx->R15;\n\n      /* call caml_reset_stack(faulting_address) using the alternate stack */\n      alt_rsp  = win32_alt_stack + sizeof(win32_alt_stack) / sizeof(uintnat);\n      ctx->Rcx = faulting_address;\n      ctx->Rsp = (uintnat) (alt_rsp - 4 - 1);\n      ctx->Rip = (uintnat) &caml_reset_stack;\n\n      return EXCEPTION_CONTINUE_EXECUTION;\n    }\n\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n#endif /* _WIN64 */\n\nvoid caml_win32_overflow_detection(void)\n{\n  AddVectoredExceptionHandler(1, caml_stack_overflow_VEH);\n}\n\n#endif /* NATIVE_CODE */\n\n/* Seeding of pseudo-random number generators */\n\nint caml_win32_random_seed (intnat data[16])\n{\n  /* For better randomness, consider:\n     http://msdn.microsoft.com/library/en-us/seccrypto/security/rtlgenrandom.asp\n     http://blogs.msdn.com/b/michael_howard/archive/2005/01/14/353379.aspx\n  */\n  FILETIME t;\n  LARGE_INTEGER pc;\n  GetSystemTimeAsFileTime(&t);\n  QueryPerformanceCounter(&pc);  /* PR#6032 */\n  data[0] = t.dwLowDateTime;\n  data[1] = t.dwHighDateTime;\n  data[2] = GetCurrentProcessId();\n  data[3] = pc.LowPart;\n  data[4] = pc.HighPart;\n  return 5;\n}\n\n\n#if defined(_MSC_VER) && __STDC_SECURE_LIB__ >= 200411L\n\nstatic void invalid_parameter_handler(const wchar_t* expression,\n   const wchar_t* function,\n   const wchar_t* file,\n   unsigned int line,\n   uintptr_t pReserved)\n{\n  /* no crash box */\n}\n\n\nvoid caml_install_invalid_parameter_handler()\n{\n  _set_invalid_parameter_handler(invalid_parameter_handler);\n}\n\n#endif\n\n\n/* Recover executable name  */\n\nwchar_t * caml_executable_name(void)\n{\n  wchar_t * name;\n  DWORD namelen, ret;\n\n  namelen = 256;\n  while (1) {\n    name = caml_stat_alloc(namelen*sizeof(wchar_t));\n    ret = GetModuleFileName(NULL, name, namelen);\n    if (ret == 0) { caml_stat_free(name); return NULL; }\n    if (ret < namelen) break;\n    caml_stat_free(name);\n    if (namelen >= 1024*1024) return NULL; /* avoid runaway and overflow */\n    namelen *= 2;\n  }\n  return name;\n}\n\n/* snprintf emulation */\n\n#ifdef LACKS_VSCPRINTF\n/* No _vscprintf until Visual Studio .NET 2002 and sadly no version number\n   in the CRT headers until Visual Studio 2005 so forced to predicate this\n   on the compiler version instead */\nint _vscprintf(const char * format, va_list args)\n{\n  int n;\n  int sz = 5;\n  char* buf = (char*)malloc(sz);\n  n = _vsnprintf(buf, sz, format, args);\n  while (n < 0 || n > sz) {\n    sz += 512;\n    buf = (char*)realloc(buf, sz);\n    n = _vsnprintf(buf, sz, format, args);\n  }\n  free(buf);\n  return n;\n}\n#endif\n\n#if defined(_WIN32) && !defined(_UCRT)\nint caml_snprintf(char * buf, size_t size, const char * format, ...)\n{\n  int len;\n  va_list args;\n\n  if (size > 0) {\n    va_start(args, format);\n    len = _vsnprintf(buf, size, format, args);\n    va_end(args);\n    if (len >= 0 && len < size) {\n      /* [len] characters were stored in [buf],\n         a null-terminator was appended. */\n      return len;\n    }\n    /* [size] characters were stored in [buf], without null termination.\n       Put a null terminator, truncating the output. */\n    buf[size - 1] = 0;\n  }\n  /* Compute the actual length of output, excluding null terminator */\n  va_start(args, format);\n  len = _vscprintf(format, args);\n  va_end(args);\n  return len;\n}\n#endif\n\nwchar_t *caml_secure_getenv (wchar_t const *var)\n{\n  /* Win32 doesn't have a notion of setuid bit, so getenv is safe. */\n  return _wgetenv(var);\n}\n\n/* caml_win32_getenv is used to implement Sys.getenv and Unix.getenv in such a\n   way that they get direct access to the Win32 environment rather than to the\n   copy that is cached by the C runtime system. The result of caml_win32_getenv\n   is dynamically allocated and must be explicitly deallocated.\n\n   In contrast, the OCaml runtime system still calls _wgetenv from the C runtime\n   system, via caml_secure_getenv. The result is statically allocated and needs\n   no deallocation. */\nCAMLexport wchar_t *caml_win32_getenv(wchar_t const *lpName)\n{\n  wchar_t * lpBuffer;\n  DWORD nSize = 256, res;\n\n  lpBuffer = caml_stat_alloc_noexc(nSize * sizeof(wchar_t));\n\n  if (lpBuffer == NULL)\n    return NULL;\n\n  res = GetEnvironmentVariable(lpName, lpBuffer, nSize);\n\n  if (res == 0) {\n    caml_stat_free(lpBuffer);\n    return NULL;\n  }\n\n  if (res < nSize)\n    return lpBuffer;\n\n  nSize = res;\n  lpBuffer = caml_stat_resize_noexc(lpBuffer, nSize * sizeof(wchar_t));\n\n  if (lpBuffer == NULL)\n    return NULL;\n\n  res = GetEnvironmentVariable(lpName, lpBuffer, nSize);\n\n  if (res == 0 || res >= nSize) {\n    caml_stat_free(lpBuffer);\n    return NULL;\n  }\n\n  return lpBuffer;\n}\n\n/* The rename() implementation in MSVC's CRT is based on MoveFile()\n   and therefore fails if the new name exists.  This is inconsistent\n   with POSIX and a problem in practice.  Here we reimplement\n   rename() using MoveFileEx() to make it more POSIX-like.\n   There are no official guarantee that the rename operation is atomic,\n   but it is widely believed to be atomic on NTFS. */\n\nint caml_win32_rename(const wchar_t * oldpath, const wchar_t * newpath)\n{\n  /* MOVEFILE_REPLACE_EXISTING: to be closer to POSIX\n     MOVEFILE_COPY_ALLOWED: MoveFile performs a copy if old and new\n       paths are on different devices, so we do the same here for\n       compatibility with the old rename()-based implementation.\n     MOVEFILE_WRITE_THROUGH: not sure it's useful; affects only\n       the case where a copy is done. */\n  if (MoveFileEx(oldpath, newpath,\n                 MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH |\n                 MOVEFILE_COPY_ALLOWED)) {\n    return 0;\n  }\n  /* Modest attempt at mapping Win32 error codes to POSIX error codes.\n     The __dosmaperr() function from the CRT does a better job but is\n     generally not accessible. */\n  switch (GetLastError()) {\n  case ERROR_FILE_NOT_FOUND: case ERROR_PATH_NOT_FOUND:\n    errno = ENOENT; break;\n  case ERROR_ACCESS_DENIED: case ERROR_WRITE_PROTECT: case ERROR_CANNOT_MAKE:\n    errno = EACCES; break;\n  case ERROR_CURRENT_DIRECTORY: case ERROR_BUSY:\n    errno = EBUSY; break;\n  case ERROR_NOT_SAME_DEVICE:\n    errno = EXDEV; break;\n  case ERROR_ALREADY_EXISTS:\n    errno = EEXIST; break;\n  default:\n    errno = EINVAL;\n  }\n  return -1;\n}\n\n/* Windows Unicode support */\nstatic uintnat windows_unicode_enabled = WINDOWS_UNICODE;\n\n/* If [windows_unicode_strict] is non-zero, then illegal UTF-8 characters (on\n   the OCaml side) or illegal UTF-16 characters (on the Windows side) cause an\n   error to be signaled.  What happens then depends on the variable\n   [windows_unicode_fallback].\n\n   If [windows_unicode_strict] is zero, then illegal characters are silently\n   dropped. */\nstatic uintnat windows_unicode_strict = 1;\n\n/* If [windows_unicode_fallback] is non-zero, then if an error is signaled when\n   translating to UTF-16, the translation is re-done under the assumption that\n   the argument string is encoded in the local codepage. */\nstatic uintnat windows_unicode_fallback = 1;\n\nCAMLexport int win_multi_byte_to_wide_char(const char *s, int slen, wchar_t *out, int outlen)\n{\n  int retcode;\n\n  CAMLassert (s != NULL);\n\n  if (slen == 0)\n    return 0;\n\n  if (windows_unicode_enabled != 0) {\n    retcode = MultiByteToWideChar(CP_UTF8, windows_unicode_strict ? MB_ERR_INVALID_CHARS : 0, s, slen, out, outlen);\n    if (retcode == 0 && windows_unicode_fallback != 0)\n      retcode = MultiByteToWideChar(CP_THREAD_ACP, 0, s, slen, out, outlen);\n  } else {\n    retcode = MultiByteToWideChar(CP_THREAD_ACP, 0, s, slen, out, outlen);\n  }\n\n  if (retcode == 0)\n    caml_win32_sys_error(GetLastError());\n\n  return retcode;\n}\n\n#ifndef WC_ERR_INVALID_CHARS /* For old versions of Windows we simply ignore the flag */\n#define WC_ERR_INVALID_CHARS 0\n#endif\n\nCAMLexport int win_wide_char_to_multi_byte(const wchar_t *s, int slen, char *out, int outlen)\n{\n  int retcode;\n\n  CAMLassert(s != NULL);\n\n  if (slen == 0)\n    return 0;\n\n  if (windows_unicode_enabled != 0)\n    retcode = WideCharToMultiByte(CP_UTF8, windows_unicode_strict ? WC_ERR_INVALID_CHARS : 0, s, slen, out, outlen, NULL, NULL);\n  else\n    retcode = WideCharToMultiByte(CP_THREAD_ACP, 0, s, slen, out, outlen, NULL, NULL);\n\n  if (retcode == 0)\n    caml_win32_sys_error(GetLastError());\n\n  return retcode;\n}\n\nCAMLexport value caml_copy_string_of_utf16(const wchar_t *s)\n{\n  int retcode, slen;\n  value v;\n\n  slen = wcslen(s);\n  retcode = win_wide_char_to_multi_byte(s, slen, NULL, 0); /* Do not include final NULL */\n  v = caml_alloc_string(retcode);\n  win_wide_char_to_multi_byte(s, slen, String_val(v), retcode);\n\n  return v;\n}\n\nCAMLexport inline wchar_t* caml_stat_strdup_to_utf16(const char *s)\n{\n  wchar_t * ws;\n  int retcode;\n\n  retcode = win_multi_byte_to_wide_char(s, -1, NULL, 0);\n  ws = malloc(retcode * sizeof(*ws));\n  win_multi_byte_to_wide_char(s, -1, ws, retcode);\n\n  return ws;\n}\n\nCAMLexport caml_stat_string caml_stat_strdup_of_utf16(const wchar_t *s)\n{\n  caml_stat_string out;\n  int retcode;\n\n  retcode = win_wide_char_to_multi_byte(s, -1, NULL, 0);\n  out = caml_stat_alloc(retcode);\n  win_wide_char_to_multi_byte(s, -1, out, retcode);\n\n  return out;\n}\n\nvoid caml_probe_win32_version(void)\n{\n  /* Determine the version of Windows we're running, and cache it */\n  WCHAR fileName[MAX_PATH];\n  DWORD size =\n    GetModuleFileName(GetModuleHandle(L\"kernel32\"), fileName, MAX_PATH);\n  DWORD dwHandle = 0;\n  BYTE* versionInfo;\n  fileName[size] = 0;\n  size = GetFileVersionInfoSize(fileName, &dwHandle);\n  versionInfo = (BYTE*)malloc(size * sizeof(BYTE));\n  if (GetFileVersionInfo(fileName, 0, size, versionInfo)) {\n    UINT len = 0;\n    VS_FIXEDFILEINFO* vsfi = NULL;\n    VerQueryValue(versionInfo, L\"\\\\\", (void**)&vsfi, &len);\n    caml_win32_major = HIWORD(vsfi->dwProductVersionMS);\n    caml_win32_minor = LOWORD(vsfi->dwProductVersionMS);\n    caml_win32_build = HIWORD(vsfi->dwProductVersionLS);\n    caml_win32_revision = LOWORD(vsfi->dwProductVersionLS);\n  }\n  free(versionInfo);\n}\n\nstatic UINT startup_codepage = 0;\n\nvoid caml_setup_win32_terminal(void)\n{\n  if (caml_win32_major >= 10) {\n    startup_codepage = GetConsoleOutputCP();\n    if (startup_codepage != CP_UTF8)\n      SetConsoleOutputCP(CP_UTF8);\n  }\n}\n\nvoid caml_restore_win32_terminal(void)\n{\n  if (startup_codepage != 0)\n    SetConsoleOutputCP(startup_codepage);\n}\n\n/* Detect if a named pipe corresponds to a Cygwin/MSYS pty: see\n   https://github.com/mirror/newlib-cygwin/blob/00e9bf2/winsup/cygwin/dtable.cc#L932\n*/\ntypedef\nBOOL (WINAPI *tGetFileInformationByHandleEx)(HANDLE, FILE_INFO_BY_HANDLE_CLASS,\n                                             LPVOID, DWORD);\n\nstatic int caml_win32_is_cygwin_pty(HANDLE hFile)\n{\n  char buffer[1024];\n  FILE_NAME_INFO * nameinfo = (FILE_NAME_INFO *) buffer;\n  static tGetFileInformationByHandleEx pGetFileInformationByHandleEx = INVALID_HANDLE_VALUE;\n\n  if (pGetFileInformationByHandleEx == INVALID_HANDLE_VALUE)\n    pGetFileInformationByHandleEx =\n      (tGetFileInformationByHandleEx)GetProcAddress(GetModuleHandle(L\"KERNEL32.DLL\"),\n                                                    \"GetFileInformationByHandleEx\");\n\n  if (pGetFileInformationByHandleEx == NULL)\n    return 0;\n\n  /* Get pipe name. GetFileInformationByHandleEx does not NULL-terminate the string, so reduce\n     the buffer size to allow for adding one. */\n  if (! pGetFileInformationByHandleEx(hFile, FileNameInfo, buffer, sizeof(buffer) - sizeof(WCHAR)))\n    return 0;\n\n  nameinfo->FileName[nameinfo->FileNameLength / sizeof(WCHAR)] = L'\\0';\n\n  /* check if this could be a msys pty pipe ('msys-XXXX-ptyN-XX')\n     or a cygwin pty pipe ('cygwin-XXXX-ptyN-XX') */\n  if ((wcsstr(nameinfo->FileName, L\"msys-\") ||\n       wcsstr(nameinfo->FileName, L\"cygwin-\")) && wcsstr(nameinfo->FileName, L\"-pty\"))\n    return 1;\n\n  return 0;\n}\n\nCAMLexport int caml_win32_isatty(int fd)\n{\n  DWORD lpMode;\n  HANDLE hFile = (HANDLE)_get_osfhandle(fd);\n\n  if (hFile == INVALID_HANDLE_VALUE)\n    return 0;\n\n  switch (GetFileType(hFile)) {\n    case FILE_TYPE_CHAR:\n      /* Both console handles and the NUL device are FILE_TYPE_CHAR.  The NUL\n         device returns FALSE for a GetConsoleMode call. _isatty incorrectly\n         only uses GetFileType (see GPR#1321). */\n      return GetConsoleMode(hFile, &lpMode);\n    case FILE_TYPE_PIPE:\n      /* Cygwin PTYs are implemented using named pipes */\n      return caml_win32_is_cygwin_pty(hFile);\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nint caml_num_rows_fd(int fd)\n{\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/byterun/dynlink.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           */\n/*                                                                        */\n/*   Copyright 2000 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#define CAML_INTERNALS\n\n/* Dynamic loading of C primitives. */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"caml/config.h\"\n#ifdef HAS_UNISTD\n#include <unistd.h>\n#endif\n#include \"caml/alloc.h\"\n#include \"caml/dynlink.h\"\n#include \"caml/fail.h\"\n#include \"caml/mlvalues.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/prims.h\"\n#include \"caml/signals.h\"\n\n#ifndef NATIVE_CODE\n\n/* The table of primitives */\nstruct ext_table caml_prim_table;\n\n#ifdef DEBUG\n/* The names of primitives (for instrtrace.c) */\nstruct ext_table caml_prim_name_table;\n#endif\n\n/* The table of shared libraries currently opened */\nstatic struct ext_table shared_libs;\n\n/* The search path for shared libraries */\nstruct ext_table caml_shared_libs_path;\n\n/* Look up the given primitive name in the built-in primitive table,\n   then in the opened shared libraries (shared_libs) */\nstatic c_primitive lookup_primitive(char * name)\n{\n  int i;\n  void * res;\n\n  for (i = 0; caml_names_of_builtin_cprim[i] != NULL; i++) {\n    if (strcmp(name, caml_names_of_builtin_cprim[i]) == 0)\n      return caml_builtin_cprim[i];\n  }\n  for (i = 0; i < shared_libs.size; i++) {\n    res = caml_dlsym(shared_libs.contents[i], name);\n    if (res != NULL) return (c_primitive) res;\n  }\n  return NULL;\n}\n\n/* Parse the OCAML_STDLIB_DIR/ld.conf file and add the directories\n   listed there to the search path */\n\n#define LD_CONF_NAME _T(\"ld.conf\")\n\nstatic char_os * parse_ld_conf(void)\n{\n  char_os * stdlib, * ldconfname, * wconfig, * p, * q;\n  char * config;\n#ifdef _WIN32\n  struct _stati64 st;\n#else\n  struct stat st;\n#endif\n  int ldconf, nread;\n\n  stdlib = caml_secure_getenv(_T(\"OCAMLLIB\"));\n  if (stdlib == NULL) stdlib = caml_secure_getenv(_T(\"CAMLLIB\"));\n  if (stdlib == NULL) stdlib = OCAML_STDLIB_DIR;\n  ldconfname = caml_stat_strconcat_os(3, stdlib, _T(\"/\"), LD_CONF_NAME);\n  if (stat_os(ldconfname, &st) == -1) {\n    caml_stat_free(ldconfname);\n    return NULL;\n  }\n  ldconf = open_os(ldconfname, O_RDONLY, 0);\n  if (ldconf == -1)\n    caml_fatal_error_arg(\"Fatal error: cannot read loader config file %s\\n\",\n                         caml_stat_strdup_of_os(ldconfname));\n  config = caml_stat_alloc(st.st_size + 1);\n  nread = read(ldconf, config, st.st_size);\n  if (nread == -1)\n    caml_fatal_error_arg\n      (\"Fatal error: error while reading loader config file %s\\n\",\n       caml_stat_strdup_of_os(ldconfname));\n  config[nread] = 0;\n  wconfig = caml_stat_strdup_to_os(config);\n  caml_stat_free(config);\n  q = wconfig;\n  for (p = wconfig; *p != 0; p++) {\n    if (*p == _T('\\n')) {\n      *p = 0;\n      caml_ext_table_add(&caml_shared_libs_path, q);\n      q = p + 1;\n    }\n  }\n  if (q < p) caml_ext_table_add(&caml_shared_libs_path, q);\n  close(ldconf);\n  caml_stat_free(ldconfname);\n  return wconfig;\n}\n\n/* Open the given shared library and add it to shared_libs.\n   Abort on error. */\nstatic void open_shared_lib(char_os * name)\n{\n  char_os * realname;\n  char * u8;\n  void * handle;\n\n  realname = caml_search_dll_in_path(&caml_shared_libs_path, name);\n  u8 = caml_stat_strdup_of_os(realname);\n  caml_gc_message(0x100, \"Loading shared library %s\\n\", u8);\n  caml_stat_free(u8);\n  caml_enter_blocking_section();\n  handle = caml_dlopen(realname, 1, 1);\n  caml_leave_blocking_section();\n  if (handle == NULL)\n    caml_fatal_error_arg2(\"Fatal error: cannot load shared library %s\\n\",\n                          caml_stat_strdup_of_os(name),\n                          \"Reason: %s\\n\", caml_dlerror());\n  caml_ext_table_add(&shared_libs, handle);\n  caml_stat_free(realname);\n}\n\n/* Build the table of primitives, given a search path and a list\n   of shared libraries (both 0-separated in a char array).\n   Abort the runtime system on error. */\nvoid caml_build_primitive_table(char_os * lib_path,\n                                char_os * libs,\n                                char * req_prims)\n{\n  char_os * tofree1, * tofree2;\n  char_os * p;\n  char * q;\n\n  /* Initialize the search path for dynamic libraries:\n     - directories specified on the command line with the -I option\n     - directories specified in the CAML_LD_LIBRARY_PATH\n     - directories specified in the executable\n     - directories specified in the file <stdlib>/ld.conf */\n  tofree1 = caml_decompose_path(&caml_shared_libs_path,\n                                caml_secure_getenv(_T(\"CAML_LD_LIBRARY_PATH\")));\n  if (lib_path != NULL)\n    for (p = lib_path; *p != 0; p += strlen_os(p) + 1)\n      caml_ext_table_add(&caml_shared_libs_path, p);\n  tofree2 = parse_ld_conf();\n  /* Open the shared libraries */\n  caml_ext_table_init(&shared_libs, 8);\n  if (libs != NULL)\n    for (p = libs; *p != 0; p += strlen_os(p) + 1)\n      open_shared_lib(p);\n  /* Build the primitive table */\n  caml_ext_table_init(&caml_prim_table, 0x180);\n#ifdef DEBUG\n  caml_ext_table_init(&caml_prim_name_table, 0x180);\n#endif\n  for (q = req_prims; *q != 0; q += strlen(q) + 1) {\n    c_primitive prim = lookup_primitive(q);\n    if (prim == NULL)\n          caml_fatal_error_arg(\"Fatal error: unknown C primitive `%s'\\n\", q);\n    caml_ext_table_add(&caml_prim_table, (void *) prim);\n#ifdef DEBUG\n    caml_ext_table_add(&caml_prim_name_table, caml_stat_strdup(q));\n#endif\n  }\n  /* Clean up */\n  caml_stat_free(tofree1);\n  caml_stat_free(tofree2);\n  caml_ext_table_free(&caml_shared_libs_path, 0);\n}\n\n/* Build the table of primitives as a copy of the builtin primitive table.\n   Used for executables generated by ocamlc -output-obj. */\n\nvoid caml_build_primitive_table_builtin(void)\n{\n  int i;\n  caml_ext_table_init(&caml_prim_table, 0x180);\n#ifdef DEBUG\n  caml_ext_table_init(&caml_prim_name_table, 0x180);\n#endif\n  for (i = 0; caml_builtin_cprim[i] != 0; i++) {\n    caml_ext_table_add(&caml_prim_table, (void *) caml_builtin_cprim[i]);\n#ifdef DEBUG\n    caml_ext_table_add(&caml_prim_name_table,\n                       caml_stat_strdup(caml_names_of_builtin_cprim[i]));\n#endif\n  }\n}\n\nvoid caml_free_shared_libs(void)\n{\n  while (shared_libs.size > 0)\n    caml_dlclose(shared_libs.contents[--shared_libs.size]);\n}\n\n#endif /* NATIVE_CODE */\n\n/** dlopen interface for the bytecode linker **/\n\n#define Handle_val(v) (*((void **) (v)))\n\nCAMLprim value caml_dynlink_open_lib(value mode, value filename)\n{\n  void * handle;\n  value result;\n  char_os * p;\n\n  caml_gc_message(0x100, \"Opening shared library %s\\n\",\n                  String_val(filename));\n  p = caml_stat_strdup_to_os(String_val(filename));\n  caml_enter_blocking_section();\n  handle = caml_dlopen(p, Int_val(mode), 1);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (handle == NULL) caml_failwith(caml_dlerror());\n  result = caml_alloc_small(1, Abstract_tag);\n  Handle_val(result) = handle;\n  return result;\n}\n\nCAMLprim value caml_dynlink_close_lib(value handle)\n{\n  caml_dlclose(Handle_val(handle));\n  return Val_unit;\n}\n\n/*#include <stdio.h>*/\nCAMLprim value caml_dynlink_lookup_symbol(value handle, value symbolname)\n{\n  void * symb;\n  value result;\n  symb = caml_dlsym(Handle_val(handle), String_val(symbolname));\n  /* printf(\"%s = 0x%lx\\n\", String_val(symbolname), symb);\n     fflush(stdout); */\n  if (symb == NULL) return Val_unit /*caml_failwith(caml_dlerror())*/;\n  result = caml_alloc_small(1, Abstract_tag);\n  Handle_val(result) = symb;\n  return result;\n}\n\n#ifndef NATIVE_CODE\n\nCAMLprim value caml_dynlink_add_primitive(value handle)\n{\n  return Val_int(caml_ext_table_add(&caml_prim_table, Handle_val(handle)));\n}\n\nCAMLprim value caml_dynlink_get_current_libs(value unit)\n{\n  CAMLparam0();\n  CAMLlocal1(res);\n  int i;\n\n  res = caml_alloc_tuple(shared_libs.size);\n  for (i = 0; i < shared_libs.size; i++) {\n    value v = caml_alloc_small(1, Abstract_tag);\n    Handle_val(v) = shared_libs.contents[i];\n    Store_field(res, i, v);\n  }\n  CAMLreturn(res);\n}\n\n#else\n\nvalue caml_dynlink_add_primitive(value handle)\n{\n  caml_invalid_argument(\"dynlink_add_primitive\");\n  return Val_unit; /* not reached */\n}\n\nvalue caml_dynlink_get_current_libs(value unit)\n{\n  caml_invalid_argument(\"dynlink_get_current_libs\");\n  return Val_unit; /* not reached */\n}\n\n#endif /* NATIVE_CODE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/byterun/caml/osdeps.h": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 2001 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n/* Operating system - specific stuff */\n\n#ifndef CAML_OSDEPS_H\n#define CAML_OSDEPS_H\n\n#ifdef _WIN32\nextern unsigned short caml_win32_major;\nextern unsigned short caml_win32_minor;\nextern unsigned short caml_win32_build;\nextern unsigned short caml_win32_revision;\n#endif\n\n#ifdef CAML_INTERNALS\n\n#include \"misc.h\"\n#include \"memory.h\"\n\n/* Read at most [n] bytes from file descriptor [fd] into buffer [buf].\n   [flags] indicates whether [fd] is a socket\n   (bit [CHANNEL_FLAG_FROM_SOCKET] is set in this case, see [io.h]).\n   (This distinction matters for Win32, but not for Unix.)\n   Return number of bytes read.\n   In case of error, raises [Sys_error] or [Sys_blocked_io]. */\nextern int caml_read_fd(int fd, int flags, void * buf, int n);\n\n/* Write at most [n] bytes from buffer [buf] onto file descriptor [fd].\n   [flags] indicates whether [fd] is a socket\n   (bit [CHANNEL_FLAG_FROM_SOCKET] is set in this case, see [io.h]).\n   (This distinction matters for Win32, but not for Unix.)\n   Return number of bytes written.\n   In case of error, raises [Sys_error] or [Sys_blocked_io]. */\nextern int caml_write_fd(int fd, int flags, void * buf, int n);\n\n/* Decompose the given path into a list of directories, and add them\n   to the given table. */\nextern char_os * caml_decompose_path(struct ext_table * tbl, char_os * path);\n\n/* Search the given file in the given list of directories.\n   If not found, return a copy of [name]. */\nextern char_os * caml_search_in_path(struct ext_table * path, const char_os * name);\n\n/* Same, but search an executable name in the system path for executables. */\nCAMLextern char_os * caml_search_exe_in_path(const char_os * name);\n\n/* Same, but search a shared library in the given path. */\nextern char_os * caml_search_dll_in_path(struct ext_table * path, const char_os * name);\n\n/* Open a shared library and return a handle on it.\n   If [for_execution] is true, perform full symbol resolution and\n   execute initialization code so that functions from the shared library\n   can be called.  If [for_execution] is false, functions from this\n   shared library will not be called, but just checked for presence,\n   so symbol resolution can be skipped.\n   If [global] is true, symbols from the shared library can be used\n   to resolve for other libraries to be opened later on.\n   Return [NULL] on error. */\nextern void * caml_dlopen(char_os * libname, int for_execution, int global);\n\n/* Close a shared library handle */\nextern void caml_dlclose(void * handle);\n\n/* Look up the given symbol in the given shared library.\n   Return [NULL] if not found, or symbol value if found. */\nextern void * caml_dlsym(void * handle, const char * name);\n\nextern void * caml_globalsym(const char * name);\n\n/* Return an error message describing the most recent dynlink failure. */\nextern char * caml_dlerror(void);\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\nextern int caml_read_directory(char_os * dirname, struct ext_table * contents);\n\n/* Recover executable name if possible (/proc/sef/exe under Linux,\n   GetModuleFileName under Windows).  Return NULL on error,\n   string allocated with [caml_stat_alloc] on success. */\nextern char_os * caml_executable_name(void);\n\n/* Secure version of [getenv]: returns NULL if the process has special\n   privileges (setuid bit, setgid bit, capabilities).\n*/\nextern char_os *caml_secure_getenv(char_os const *var);\n\n/* If [fd] refers to a terminal or console, return the number of rows\n   (lines) that it displays.  Otherwise, or if the number of rows\n   cannot be determined, return -1. */\nextern int caml_num_rows_fd(int fd);\n\n#ifdef _WIN32\n\nextern int caml_win32_rename(const wchar_t *, const wchar_t *);\n\nextern void caml_probe_win32_version(void);\nextern void caml_setup_win32_terminal(void);\nextern void caml_restore_win32_terminal(void);\n\nextern wchar_t *caml_win32_getenv(wchar_t const *);\n\n/* Windows Unicode support */\n\nextern int win_multi_byte_to_wide_char(const char* s, int slen, wchar_t *out, int outlen);\nextern int win_wide_char_to_multi_byte(const wchar_t* s, int slen, char *out, int outlen);\n\n/* [caml_stat_strdup_to_utf16(s)] returns a NULL-terminated copy of [s],\n   re-encoded in UTF-16.  The encoding of [s] is assumed to be UTF-8 if\n   [caml_windows_unicode_runtime_enabled] is non-zero **and** [s] is valid\n   UTF-8, or the current Windows code page otherwise.\n\n   The returned string is allocated with [caml_stat_alloc], so it should be free\n   using [caml_stat_free].\n*/\nextern wchar_t* caml_stat_strdup_to_utf16(const char *s);\n\n/* [caml_stat_strdup_of_utf16(s)] returns a NULL-terminated copy of [s],\n   re-encoded in UTF-8 if [caml_windows_unicode_runtime_enabled] is non-zero or\n   the current Windows code page otherwise.\n\n   The returned string is allocated with [caml_stat_alloc], so it should be free\n   using [caml_stat_free].\n*/\nextern char* caml_stat_strdup_of_utf16(const wchar_t *s);\n\n/* [caml_copy_string_of_utf16(s)] returns an OCaml string containing a copy of\n   [s] re-encoded in UTF-8 if [caml_windows_unicode_runtime_enabled] is non-zero\n   or in the current code page otherwise.\n*/\nextern value caml_copy_string_of_utf16(const wchar_t *s);\n\nextern int caml_win32_isatty(int fd);\n\n#endif /* _WIN32 */\n\n#endif /* CAML_INTERNALS */\n\n#endif /* CAML_OSDEPS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/asmrun/natdynlink.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*             Alain Frisch, projet Gallium, INRIA Rocquencourt           */\n/*                                                                        */\n/*   Copyright 2007 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#define CAML_INTERNALS\n\n#include \"caml/misc.h\"\n#include \"caml/mlvalues.h\"\n#include \"caml/memory.h\"\n#include \"caml/stack.h\"\n#include \"caml/callback.h\"\n#include \"caml/alloc.h\"\n#include \"caml/intext.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/fail.h\"\n#include \"caml/signals.h\"\n#ifdef WITH_SPACETIME\n#include \"caml/spacetime.h\"\n#endif\n\n#include \"caml/hooks.h\"\n\nCAMLexport void (*caml_natdynlink_hook)(void* handle, const char* unit) = NULL;\n\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define Handle_val(v) (*((void **) Data_abstract_val(v)))\nstatic value Val_handle(void* handle) {\n  value res = caml_alloc_small(1, Abstract_tag);\n  Handle_val(res) = handle;\n  return res;\n}\n\nstatic void *getsym(void *handle, const char *module, const char *name){\n  char *fullname = caml_stat_strconcat(3, \"caml\", module, name);\n  void *sym;\n  sym = caml_dlsym (handle, fullname);\n  /*  printf(\"%s => %lx\\n\", fullname, (uintnat) sym); */\n  caml_stat_free(fullname);\n  return sym;\n}\n\nCAMLprim value caml_natdynlink_getmap(value unit)\n{\n  return caml_input_value_from_block(caml_globals_map, INT_MAX);\n}\n\nCAMLprim value caml_natdynlink_globals_inited(value unit)\n{\n  return Val_int(caml_globals_inited);\n}\n\nCAMLprim value caml_natdynlink_open(value filename, value global)\n{\n  CAMLparam2 (filename, global);\n  CAMLlocal3 (res, handle, header);\n  void *sym;\n  void *dlhandle;\n  char_os *p;\n\n  /* TODO: dlclose in case of error... */\n\n  p = caml_stat_strdup_to_os(String_val(filename));\n  caml_enter_blocking_section();\n  dlhandle = caml_dlopen(p, 1, Int_val(global));\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  if (NULL == dlhandle)\n    caml_failwith(caml_dlerror());\n\n  sym = caml_dlsym(dlhandle, \"caml_plugin_header\");\n  if (NULL == sym)\n    caml_failwith(\"not an OCaml plugin\");\n\n  handle = Val_handle(dlhandle);\n  header = caml_input_value_from_block(sym, INT_MAX);\n\n  res = caml_alloc_tuple(2);\n  Field(res, 0) = handle;\n  Field(res, 1) = header;\n  CAMLreturn(res);\n}\n\nCAMLprim value caml_natdynlink_run(value handle_v, value symbol) {\n  CAMLparam2 (handle_v, symbol);\n  CAMLlocal1 (result);\n  void *sym,*sym2;\n  void* handle = Handle_val(handle_v);\n  struct code_fragment * cf;\n\n#define optsym(n) getsym(handle,unit,n)\n  const char *unit;\n  void (*entrypoint)(void);\n\n  unit = String_val(symbol);\n\n  sym = optsym(\"__frametable\");\n  if (NULL != sym) caml_register_frametable(sym);\n\n#ifdef WITH_SPACETIME\n  sym = optsym(\"__spacetime_shapes\");\n  if (NULL != sym) caml_spacetime_register_shapes(sym);\n#endif\n\n  sym = optsym(\"__gc_roots\");\n  if (NULL != sym) caml_register_dyn_global(sym);\n\n  sym = optsym(\"__data_begin\");\n  sym2 = optsym(\"__data_end\");\n  if (NULL != sym && NULL != sym2)\n    caml_page_table_add(In_static_data, sym, sym2);\n\n  sym = optsym(\"__code_begin\");\n  sym2 = optsym(\"__code_end\");\n  if (NULL != sym && NULL != sym2) {\n    caml_page_table_add(In_code_area, sym, sym2);\n    cf = caml_stat_alloc(sizeof(struct code_fragment));\n    cf->code_start = (char *) sym;\n    cf->code_end = (char *) sym2;\n    cf->digest_computed = 0;\n    caml_ext_table_add(&caml_code_fragments_table, cf);\n  }\n\n  if( caml_natdynlink_hook != NULL ) caml_natdynlink_hook(handle,unit);\n\n  entrypoint = optsym(\"__entry\");\n  if (NULL != entrypoint) result = caml_callback((value)(&entrypoint), 0);\n  else result = Val_unit;\n\n#undef optsym\n\n  CAMLreturn (result);\n}\n\nCAMLprim value caml_natdynlink_run_toplevel(value filename, value symbol)\n{\n  CAMLparam2 (filename, symbol);\n  CAMLlocal3 (res, v, handle_v);\n  void *handle;\n  char_os *p;\n\n  /* TODO: dlclose in case of error... */\n\n  p = caml_stat_strdup_to_os(String_val(filename));\n  caml_enter_blocking_section();\n  handle = caml_dlopen(p, 1, 1);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  if (NULL == handle) {\n    res = caml_alloc(1,1);\n    v = caml_copy_string(caml_dlerror());\n    Store_field(res, 0, v);\n  } else {\n    handle_v = Val_handle(handle);\n    res = caml_alloc(1,0);\n    v = caml_natdynlink_run(handle_v, symbol);\n    Store_field(res, 0, v);\n  }\n  CAMLreturn(res);\n}\n\nCAMLprim value caml_natdynlink_loadsym(value symbol)\n{\n  CAMLparam1 (symbol);\n  CAMLlocal1 (sym);\n\n  sym = (value) caml_globalsym(String_val(symbol));\n  if (!sym) caml_failwith(String_val(symbol));\n  CAMLreturn(sym);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/manual.inf",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/biblio.etex",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/allfiles.etex",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/macros.hva",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/library/libgraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/previous_motif.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/contents_motif.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/libgraph.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/next_motif.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/fonts/fira-sans-v8-latin-regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/fonts/fira-sans-v8-latin-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/fonts/fira-sans-v8-latin-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/htmlman/fonts/fira-sans-v8-latin-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/manual/tutorials/advexamples.etex",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/doctt.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/docit.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/doc.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/docbf.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/isolatin.sty",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/docrm.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/manual/styles/docmi.tfm",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.07.0-esz6pp3xjhzfo3ebvphhennf2kbcps6d/spack-src/testsuite/tests/lib-str/t01.reference"
    ],
    "total_files": 2884
}