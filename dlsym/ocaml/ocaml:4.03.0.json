{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/byterun/unix.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 2001 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n/* Unix-specific stuff */\n\n#define _GNU_SOURCE\n           /* Helps finding RTLD_DEFAULT in glibc */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include \"caml/config.h\"\n#ifdef SUPPORT_DYNAMIC_LINKING\n#ifdef __CYGWIN__\n#include \"flexdll.h\"\n#else\n#include <dlfcn.h>\n#endif\n#endif\n#ifdef HAS_UNISTD\n#include <unistd.h>\n#endif\n#ifdef HAS_DIRENT\n#include <dirent.h>\n#else\n#include <sys/dir.h>\n#endif\n#include \"caml/fail.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/signals.h\"\n#include \"caml/sys.h\"\n\n#ifndef S_ISREG\n#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)\n#endif\n\n#ifndef EINTR\n#define EINTR (-1)\n#endif\n#ifndef EAGAIN\n#define EAGAIN (-1)\n#endif\n#ifndef EWOULDBLOCK\n#define EWOULDBLOCK (-1)\n#endif\n\nint caml_read_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  do {\n    caml_enter_blocking_section();\n    retcode = read(fd, buf, n);\n    caml_leave_blocking_section();\n  } while (retcode == -1 && errno == EINTR);\n  if (retcode == -1) caml_sys_io_error(NO_ARG);\n  return retcode;\n}\n\nint caml_write_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n again:\n  caml_enter_blocking_section();\n  retcode = write(fd, buf, n);\n  caml_leave_blocking_section();\n  if (retcode == -1) {\n    if (errno == EINTR) goto again;\n    if ((errno == EAGAIN || errno == EWOULDBLOCK) && n > 1) {\n      /* We couldn't do a partial write here, probably because\n         n <= PIPE_BUF and POSIX says that writes of less than\n         PIPE_BUF characters must be atomic.\n         We first try again with a partial write of 1 character.\n         If that fails too, we'll return an error code. */\n      n = 1; goto again;\n    }\n  }\n  if (retcode == -1) caml_sys_io_error(NO_ARG);\n  CAMLassert (retcode > 0);\n  return retcode;\n}\n\nchar * caml_decompose_path(struct ext_table * tbl, char * path)\n{\n  char * p, * q;\n  size_t n;\n\n  if (path == NULL) return NULL;\n  p = caml_strdup(path);\n  q = p;\n  while (1) {\n    for (n = 0; q[n] != 0 && q[n] != ':'; n++) /*nothing*/;\n    caml_ext_table_add(tbl, q);\n    q = q + n;\n    if (*q == 0) break;\n    *q = 0;\n    q += 1;\n  }\n  return p;\n}\n\nchar * caml_search_in_path(struct ext_table * path, char * name)\n{\n  char * p, * dir, * fullname;\n  int i;\n  struct stat st;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) dir = \".\";  /* empty path component = current dir */\n    fullname = caml_strconcat(3, dir, \"/\", name);\n    if (stat(fullname, &st) == 0 && S_ISREG(st.st_mode))\n      return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  return caml_strdup(name);\n}\n\n#ifdef __CYGWIN__\n\n/* Cygwin needs special treatment because of the implicit \".exe\" at the\n   end of executable file names */\n\nstatic int cygwin_file_exists(char * name)\n{\n  int fd;\n  /* Cannot use stat() here because it adds \".exe\" implicitly */\n  fd = open(name, O_RDONLY);\n  if (fd == -1) return 0;\n  close(fd);\n  return 1;\n}\n\nstatic char * cygwin_search_exe_in_path(struct ext_table * path, char * name)\n{\n  char * p, * dir, * fullname;\n  int i;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/' || *p == '\\\\') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) dir = \".\";  /* empty path component = current dir */\n    fullname = caml_strconcat(3, dir, \"/\", name);\n    if (cygwin_file_exists(fullname)) return fullname;\n    caml_stat_free(fullname);\n    fullname = caml_strconcat(4, dir, \"/\", name, \".exe\");\n    if (cygwin_file_exists(fullname)) return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  if (cygwin_file_exists(name)) return caml_strdup(name);\n  fullname = caml_strconcat(2, name, \".exe\");\n  if (cygwin_file_exists(fullname)) return fullname;\n  caml_stat_free(fullname);\n  return caml_strdup(name);\n}\n\n#endif\n\nchar * caml_search_exe_in_path(char * name)\n{\n  struct ext_table path;\n  char * tofree;\n  char * res;\n\n  caml_ext_table_init(&path, 8);\n  tofree = caml_decompose_path(&path, getenv(\"PATH\"));\n#ifndef __CYGWIN__\n  res = caml_search_in_path(&path, name);\n#else\n  res = cygwin_search_exe_in_path(&path, name);\n#endif\n  caml_stat_free(tofree);\n  caml_ext_table_free(&path, 0);\n  return res;\n}\n\nchar * caml_search_dll_in_path(struct ext_table * path, char * name)\n{\n  char * dllname;\n  char * res;\n\n  dllname = caml_strconcat(2, name, \".so\");\n  res = caml_search_in_path(path, dllname);\n  caml_stat_free(dllname);\n  return res;\n}\n\n#ifdef SUPPORT_DYNAMIC_LINKING\n#ifdef __CYGWIN__\n/* Use flexdll */\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  int flags = (global ? FLEXDLL_RTLD_GLOBAL : 0);\n  if (!for_execution) flags |= FLEXDLL_RTLD_NOEXEC;\n  return flexdll_dlopen(libname, flags);\n}\n\nvoid caml_dlclose(void * handle)\n{\n  flexdll_dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, char * name)\n{\n  return flexdll_dlsym(handle, name);\n}\n\nvoid * caml_globalsym(char * name)\n{\n  return flexdll_dlsym(flexdll_dlopen(NULL,0), name);\n}\n\nchar * caml_dlerror(void)\n{\n  return flexdll_dlerror();\n}\n\n#else\n/* Use normal dlopen */\n\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n#ifndef RTLD_NODELETE\n#define RTLD_NODELETE 0\n#endif\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  return dlopen(libname, RTLD_NOW | (global ? RTLD_GLOBAL : RTLD_LOCAL)\n                         | RTLD_NODELETE);\n  /* Could use RTLD_LAZY if for_execution == 0, but needs testing */\n}\n\nvoid caml_dlclose(void * handle)\n{\n  dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, char * name)\n{\n#ifdef DL_NEEDS_UNDERSCORE\n  char _name[1000] = \"_\";\n  strncat (_name, name, 998);\n  name = _name;\n#endif\n  return dlsym(handle, name);\n}\n\nvoid * caml_globalsym(char * name)\n{\n#ifdef RTLD_DEFAULT\n  return caml_dlsym(RTLD_DEFAULT, name);\n#else\n  return NULL;\n#endif\n}\n\nchar * caml_dlerror(void)\n{\n  return (char*) dlerror();\n}\n\n#endif\n#else\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  return NULL;\n}\n\nvoid caml_dlclose(void * handle)\n{\n}\n\nvoid * caml_dlsym(void * handle, char * name)\n{\n  return NULL;\n}\n\nvoid * caml_globalsym(char * name)\n{\n  return NULL;\n}\n\nchar * caml_dlerror(void)\n{\n  return \"dynamic loading not supported on this platform\";\n}\n\n#endif\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\n\nint caml_read_directory(char * dirname, struct ext_table * contents)\n{\n  DIR * d;\n#ifdef HAS_DIRENT\n  struct dirent * e;\n#else\n  struct direct * e;\n#endif\n\n  d = opendir(dirname);\n  if (d == NULL) return -1;\n  while (1) {\n    e = readdir(d);\n    if (e == NULL) break;\n    if (strcmp(e->d_name, \".\") == 0 || strcmp(e->d_name, \"..\") == 0) continue;\n    caml_ext_table_add(contents, caml_strdup(e->d_name));\n  }\n  closedir(d);\n  return 0;\n}\n\n/* Recover executable name from /proc/self/exe if possible */\n\n#ifdef __linux__\n\nint caml_executable_name(char * name, int name_len)\n{\n  int retcode;\n  struct stat st;\n\n  retcode = readlink(\"/proc/self/exe\", name, name_len);\n  if (retcode == -1 || retcode >= name_len) return -1;\n  name[retcode] = 0;\n  /* Make sure that the contents of /proc/self/exe is a regular file.\n     (Old Linux kernels return an inode number instead.) */\n  if (stat(name, &st) != 0) return -1;\n  if (! S_ISREG(st.st_mode)) return -1;\n  return 0;\n}\n\n#else\n\nint caml_executable_name(char * name, int name_len)\n{\n  return -1;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/byterun/win32.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 1996 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n/* Win32-specific stuff */\n\n#define WIN32_LEAN_AND_MEAN\n#include <wtypes.h>\n#include <winbase.h>\n#include <winsock2.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <io.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include \"caml/alloc.h\"\n#include \"caml/address_class.h\"\n#include \"caml/fail.h\"\n#include \"caml/io.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/signals.h\"\n#include \"caml/sys.h\"\n\n#include \"caml/config.h\"\n#ifdef SUPPORT_DYNAMIC_LINKING\n#include <flexdll.h>\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)\n#endif\n\nCAMLnoreturn_start\nstatic void caml_win32_sys_error (int errnum)\nCAMLnoreturn_end;\n\nstatic void caml_win32_sys_error(int errnum)\n{\n  char buffer[512];\n  value msg;\n  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                    NULL,\n                    errnum,\n                    0,\n                    buffer,\n                    sizeof(buffer),\n                    NULL)) {\n    msg = caml_copy_string(buffer);\n  } else {\n    msg = caml_alloc_sprintf(\"unknown error #%d\", errnum);\n  }\n  caml_raise_sys_error(msg);\n}\n\nint caml_read_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  if ((flags & CHANNEL_FLAG_FROM_SOCKET) == 0) {\n    caml_enter_blocking_section();\n    retcode = read(fd, buf, n);\n    /* Large reads from console can fail with ENOMEM.  Reduce requested size\n       and try again. */\n    if (retcode == -1 && errno == ENOMEM && n > 16384) {\n      retcode = read(fd, buf, 16384);\n    }\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_sys_io_error(NO_ARG);\n  } else {\n    caml_enter_blocking_section();\n    retcode = recv((SOCKET) _get_osfhandle(fd), buf, n, 0);\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_win32_sys_error(WSAGetLastError());\n  }\n  return retcode;\n}\n\nint caml_write_fd(int fd, int flags, void * buf, int n)\n{\n  int retcode;\n  if ((flags & CHANNEL_FLAG_FROM_SOCKET) == 0) {\n    caml_enter_blocking_section();\n    retcode = write(fd, buf, n);\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_sys_io_error(NO_ARG);\n  } else {\n    caml_enter_blocking_section();\n    retcode = send((SOCKET) _get_osfhandle(fd), buf, n, 0);\n    caml_leave_blocking_section();\n    if (retcode == -1) caml_win32_sys_error(WSAGetLastError());\n  }\n  CAMLassert (retcode > 0);\n  return retcode;\n}\n\nchar * caml_decompose_path(struct ext_table * tbl, char * path)\n{\n  char * p, * q;\n  int n;\n\n  if (path == NULL) return NULL;\n  p = caml_strdup(path);\n  q = p;\n  while (1) {\n    for (n = 0; q[n] != 0 && q[n] != ';'; n++) /*nothing*/;\n    caml_ext_table_add(tbl, q);\n    q = q + n;\n    if (*q == 0) break;\n    *q = 0;\n    q += 1;\n  }\n  return p;\n}\n\nchar * caml_search_in_path(struct ext_table * path, char * name)\n{\n  char * p, * dir, * fullname;\n  int i;\n  struct stat st;\n\n  for (p = name; *p != 0; p++) {\n    if (*p == '/' || *p == '\\\\') goto not_found;\n  }\n  for (i = 0; i < path->size; i++) {\n    dir = path->contents[i];\n    if (dir[0] == 0) continue;\n         /* not sure what empty path components mean under Windows */\n    fullname = caml_strconcat(3, dir, \"\\\\\", name);\n    caml_gc_message(0x100, \"Searching %s\\n\", (uintnat) fullname);\n    if (stat(fullname, &st) == 0 && S_ISREG(st.st_mode))\n      return fullname;\n    caml_stat_free(fullname);\n  }\n not_found:\n  caml_gc_message(0x100, \"%s not found in search path\\n\", (uintnat) name);\n  return caml_strdup(name);\n}\n\nCAMLexport char * caml_search_exe_in_path(char * name)\n{\n  char * fullname, * filepart;\n  size_t fullnamelen;\n  DWORD retcode;\n\n  fullnamelen = strlen(name) + 1;\n  if (fullnamelen < 256) fullnamelen = 256;\n  while (1) {\n    fullname = caml_stat_alloc(fullnamelen);\n    retcode = SearchPath(NULL,              /* use system search path */\n                         name,\n                         \".exe\",            /* add .exe extension if needed */\n                         fullnamelen,\n                         fullname,\n                         &filepart);\n    if (retcode == 0) {\n      caml_gc_message(0x100, \"%s not found in search path\\n\",\n                      (uintnat) name);\n      caml_stat_free(fullname);\n      return caml_strdup(name);\n    }\n    if (retcode < fullnamelen)\n      return fullname;\n    caml_stat_free(fullname);\n    fullnamelen = retcode + 1;\n  }\n}\n\nchar * caml_search_dll_in_path(struct ext_table * path, char * name)\n{\n  char * dllname;\n  char * res;\n\n  dllname = caml_strconcat(2, name, \".dll\");\n  res = caml_search_in_path(path, dllname);\n  caml_stat_free(dllname);\n  return res;\n}\n\n#ifdef SUPPORT_DYNAMIC_LINKING\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  void *handle;\n  int flags = (global ? FLEXDLL_RTLD_GLOBAL : 0);\n  if (!for_execution) flags |= FLEXDLL_RTLD_NOEXEC;\n  handle = flexdll_dlopen(libname, flags);\n  if ((handle != NULL) && ((caml_verb_gc & 0x100) != 0)) {\n    flexdll_dump_exports(handle);\n    fflush(stdout);\n  }\n  return handle;\n}\n\nvoid caml_dlclose(void * handle)\n{\n  flexdll_dlclose(handle);\n}\n\nvoid * caml_dlsym(void * handle, char * name)\n{\n  return flexdll_dlsym(handle, name);\n}\n\nvoid * caml_globalsym(char * name)\n{\n  return flexdll_dlsym(flexdll_dlopen(NULL,0), name);\n}\n\nchar * caml_dlerror(void)\n{\n  return flexdll_dlerror();\n}\n\n#else\n\nvoid * caml_dlopen(char * libname, int for_execution, int global)\n{\n  return NULL;\n}\n\nvoid caml_dlclose(void * handle)\n{\n}\n\nvoid * caml_dlsym(void * handle, char * name)\n{\n  return NULL;\n}\n\nvoid * caml_globalsym(char * name)\n{\n  return NULL;\n}\n\nchar * caml_dlerror(void)\n{\n  return \"dynamic loading not supported on this platform\";\n}\n\n#endif\n\n/* Proper emulation of signal(), including ctrl-C and ctrl-break */\n\ntypedef void (*sighandler)(int sig);\nstatic int ctrl_handler_installed = 0;\nstatic volatile sighandler ctrl_handler_action = SIG_DFL;\n\nstatic BOOL WINAPI ctrl_handler(DWORD event)\n{\n  int saved_mode;\n\n  /* Only ctrl-C and ctrl-Break are handled */\n  if (event != CTRL_C_EVENT && event != CTRL_BREAK_EVENT) return FALSE;\n  /* Default behavior is to exit, which we get by not handling the event */\n  if (ctrl_handler_action == SIG_DFL) return FALSE;\n  /* Ignore behavior is to do nothing, which we get by claiming that we\n     have handled the event */\n  if (ctrl_handler_action == SIG_IGN) return TRUE;\n  /* Win32 doesn't like it when we do a longjmp() at this point\n     (it looks like we're running in a different thread than\n     the main program!).  So, just record the signal. */\n  caml_record_signal(SIGINT);\n  /* We have handled the event */\n  return TRUE;\n}\n\nsighandler caml_win32_signal(int sig, sighandler action)\n{\n  sighandler oldaction;\n\n  if (sig != SIGINT) return signal(sig, action);\n  if (! ctrl_handler_installed) {\n    SetConsoleCtrlHandler(ctrl_handler, TRUE);\n    ctrl_handler_installed = 1;\n  }\n  oldaction = ctrl_handler_action;\n  ctrl_handler_action = action;\n  return oldaction;\n}\n\n/* Expansion of @responsefile and *? file patterns in the command line */\n\nstatic int argc;\nstatic char ** argv;\nstatic int argvsize;\n\nstatic void store_argument(char * arg);\nstatic void expand_argument(char * arg);\nstatic void expand_pattern(char * arg);\n\nstatic void out_of_memory(void)\n{\n  fprintf(stderr, \"Out of memory while expanding command line\\n\");\n  exit(2);\n}\n\nstatic void store_argument(char * arg)\n{\n  if (argc + 1 >= argvsize) {\n    argvsize *= 2;\n    argv = (char **) realloc(argv, argvsize * sizeof(char *));\n    if (argv == NULL) out_of_memory();\n  }\n  argv[argc++] = arg;\n}\n\nstatic void expand_argument(char * arg)\n{\n  char * p;\n\n  for (p = arg; *p != 0; p++) {\n    if (*p == '*' || *p == '?') {\n      expand_pattern(arg);\n      return;\n    }\n  }\n  store_argument(arg);\n}\n\nstatic void expand_pattern(char * pat)\n{\n  char * prefix, * p, * name;\n  int handle;\n  struct _finddata_t ffblk;\n  size_t i;\n\n  handle = _findfirst(pat, &ffblk);\n  if (handle == -1) {\n    store_argument(pat); /* a la Bourne shell */\n    return;\n  }\n  prefix = caml_strdup(pat);\n  for (i = strlen(prefix); i > 0; i--) {\n    char c = prefix[i - 1];\n    if (c == '\\\\' || c == '/' || c == ':') { prefix[i] = 0; break; }\n  }\n  do {\n    name = caml_strconcat(2, prefix, ffblk.name);\n    store_argument(name);\n  } while (_findnext(handle, &ffblk) != -1);\n  _findclose(handle);\n  caml_stat_free(prefix);\n}\n\n\nCAMLexport void caml_expand_command_line(int * argcp, char *** argvp)\n{\n  int i;\n  argc = 0;\n  argvsize = 16;\n  argv = (char **) malloc(argvsize * sizeof(char *));\n  if (argv == NULL) out_of_memory();\n  for (i = 0; i < *argcp; i++) expand_argument((*argvp)[i]);\n  argv[argc] = NULL;\n  *argcp = argc;\n  *argvp = argv;\n}\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\n\nint caml_read_directory(char * dirname, struct ext_table * contents)\n{\n  size_t dirnamelen;\n  char * template;\n#if _MSC_VER <= 1200\n  int h;\n#else\n  intptr_t h;\n#endif\n  struct _finddata_t fileinfo;\n\n  dirnamelen = strlen(dirname);\n  if (dirnamelen > 0 &&\n      (dirname[dirnamelen - 1] == '/'\n       || dirname[dirnamelen - 1] == '\\\\'\n       || dirname[dirnamelen - 1] == ':'))\n    template = caml_strconcat(2, dirname, \"*.*\");\n  else\n    template = caml_strconcat(2, dirname, \"\\\\*.*\");\n  h = _findfirst(template, &fileinfo);\n  if (h == -1) {\n    caml_stat_free(template);\n    return errno == ENOENT ? 0 : -1;\n  }\n  do {\n    if (strcmp(fileinfo.name, \".\") != 0 && strcmp(fileinfo.name, \"..\") != 0) {\n      caml_ext_table_add(contents, caml_strdup(fileinfo.name));\n    }\n  } while (_findnext(h, &fileinfo) == 0);\n  _findclose(h);\n  caml_stat_free(template);\n  return 0;\n}\n\n#ifndef NATIVE_CODE\n\n/* Set up a new thread for control-C emulation and termination */\n\nvoid caml_signal_thread(void * lpParam)\n{\n  char *endptr;\n  HANDLE h;\n  /* Get an hexa-code raw handle through the environment */\n  h = (HANDLE) (uintptr_t) strtol(getenv(\"CAMLSIGPIPE\"), &endptr, 16);\n  while (1) {\n    DWORD numread;\n    BOOL ret;\n    char iobuf[2];\n    /* This shall always return a single character */\n    ret = ReadFile(h, iobuf, 1, &numread, NULL);\n    if (!ret || numread != 1) caml_sys_exit(Val_int(2));\n    switch (iobuf[0]) {\n    case 'C':\n      caml_record_signal(SIGINT);\n      break;\n    case 'T':\n      raise(SIGTERM);\n      return;\n    }\n  }\n}\n\n#endif /* NATIVE_CODE */\n\n#if defined(NATIVE_CODE) && !defined(_WIN64)\n\n/* Handling of system stack overflow.\n * Based on code provided by Olivier Andrieu.\n\n * An EXCEPTION_STACK_OVERFLOW is signaled when the guard page at the\n * end of the stack has been accessed. Windows clears the PAGE_GUARD\n * protection (making it a regular PAGE_READWRITE) and then calls our\n * exception handler. This means that although we're handling an \"out\n * of stack\" condition, there is a bit of stack available to call\n * functions and allocate temporaries.\n *\n * PAGE_GUARD is a one-shot access protection mechanism: we need to\n * restore the PAGE_GUARD protection on this page otherwise the next\n * stack overflow won't be detected and the program will abruptly exit\n * with STATUS_ACCESS_VIOLATION.\n *\n * Visual Studio 2003 and later (_MSC_VER >= 1300) have a\n * _resetstkoflw() function that resets this protection.\n * Unfortunately, it cannot work when called directly from the\n * exception handler because at this point we are using the page that\n * is to be protected.\n *\n * A solution is to used an alternate stack when restoring the\n * protection. However it's not possible to use _resetstkoflw() then\n * since it determines the stack pointer by calling alloca(): it would\n * try to protect the alternate stack.\n *\n * Finally, we call caml_raise_stack_overflow; it will either call\n * caml_raise_exception which switches back to the normal stack, or\n * call caml_fatal_uncaught_exception which terminates the program\n * quickly.\n *\n * NB: The PAGE_GUARD protection is only available on WinNT, not\n * Win9x. There is an equivalent mechanism on Win9x with\n * PAGE_NOACCESS.\n *\n * Currently, does not work under Win64.\n */\n\nstatic uintnat win32_alt_stack[0x80];\n\nstatic void caml_reset_stack (void *faulting_address)\n{\n  OSVERSIONINFO osi;\n  SYSTEM_INFO si;\n  DWORD page_size;\n  MEMORY_BASIC_INFORMATION mbi;\n  DWORD oldprot;\n\n  /* get the os version (Win9x or WinNT ?) */\n  osi.dwOSVersionInfoSize = sizeof osi;\n  if (! GetVersionEx (&osi))\n    goto failed;\n\n  /* get the system's page size. */\n  GetSystemInfo (&si);\n  page_size = si.dwPageSize;\n\n  /* get some information on the page the fault occurred */\n  if (! VirtualQuery (faulting_address, &mbi, sizeof mbi))\n    goto failed;\n\n  /* restore the PAGE_GUARD protection on this page */\n  switch (osi.dwPlatformId) {\n  case VER_PLATFORM_WIN32_NT:\n    VirtualProtect (mbi.BaseAddress, page_size,\n                    mbi.Protect | PAGE_GUARD, &oldprot);\n    break;\n  case VER_PLATFORM_WIN32_WINDOWS:\n    VirtualProtect (mbi.BaseAddress, page_size,\n                    PAGE_NOACCESS, &oldprot);\n    break;\n  }\n\n failed:\n  caml_raise_stack_overflow();\n}\n\nCAMLextern int caml_is_in_code(void *);\n\nstatic LONG CALLBACK\n    caml_UnhandledExceptionFilter (EXCEPTION_POINTERS* exn_info)\n{\n  DWORD code   = exn_info->ExceptionRecord->ExceptionCode;\n  CONTEXT *ctx = exn_info->ContextRecord;\n  DWORD *ctx_ip = &(ctx->Eip);\n  DWORD *ctx_sp = &(ctx->Esp);\n\n  if (code == EXCEPTION_STACK_OVERFLOW && Is_in_code_area (*ctx_ip))\n    {\n      uintnat faulting_address;\n      uintnat * alt_esp;\n\n      /* grab the address that caused the fault */\n      faulting_address = exn_info->ExceptionRecord->ExceptionInformation[1];\n\n      /* call caml_reset_stack(faulting_address) using the alternate stack */\n      alt_esp  = win32_alt_stack + sizeof(win32_alt_stack) / sizeof(uintnat);\n      *--alt_esp = faulting_address;\n      *ctx_sp = (uintnat) (alt_esp - 1);\n      *ctx_ip = (uintnat) &caml_reset_stack;\n\n      return EXCEPTION_CONTINUE_EXECUTION;\n    }\n\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\nvoid caml_win32_overflow_detection()\n{\n  SetUnhandledExceptionFilter (caml_UnhandledExceptionFilter);\n}\n\n#endif\n\n/* Seeding of pseudo-random number generators */\n\nint caml_win32_random_seed (intnat data[16])\n{\n  /* For better randomness, consider:\n     http://msdn.microsoft.com/library/en-us/seccrypto/security/rtlgenrandom.asp\n     http://blogs.msdn.com/b/michael_howard/archive/2005/01/14/353379.aspx\n  */\n  FILETIME t;\n  LARGE_INTEGER pc;\n  GetSystemTimeAsFileTime(&t);\n  QueryPerformanceCounter(&pc);  /* PR#6032 */\n  data[0] = t.dwLowDateTime;\n  data[1] = t.dwHighDateTime;\n  data[2] = GetCurrentProcessId();\n  data[3] = pc.LowPart;\n  data[4] = pc.HighPart;\n  return 5;\n}\n\n\n#ifdef _MSC_VER\n\nstatic void invalid_parameter_handler(const wchar_t* expression,\n   const wchar_t* function,\n   const wchar_t* file,\n   unsigned int line,\n   uintptr_t pReserved)\n{\n  /* no crash box */\n}\n\n\nvoid caml_install_invalid_parameter_handler()\n{\n  _set_invalid_parameter_handler(invalid_parameter_handler);\n}\n\n#endif\n\n\n/* Recover executable name  */\n\nint caml_executable_name(char * name, int name_len)\n{\n  int retcode;\n\n  int ret = GetModuleFileName(NULL, name, name_len);\n  if (0 == ret || ret >= name_len) return -1;\n  return 0;\n}\n\n/* snprintf emulation */\n\n#if defined(_WIN32) && !defined(_UCRT)\nint caml_snprintf(char * buf, size_t size, const char * format, ...)\n{\n  int len;\n  va_list args;\n\n  if (size > 0) {\n    va_start(args, format);\n    len = _vsnprintf(buf, size, format, args);\n    va_end(args);\n    if (len >= 0 && len < size) {\n      /* [len] characters were stored in [buf],\n         a null-terminator was appended. */\n      return len;\n    }\n    /* [size] characters were stored in [buf], without null termination.\n       Put a null terminator, truncating the output. */\n    buf[size - 1] = 0;\n  }\n  /* Compute the actual length of output, excluding null terminator */\n  va_start(args, format);\n  len = _vscprintf(format, args);\n  va_end(args);\n  return len;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/byterun/dynlink.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           */\n/*                                                                        */\n/*   Copyright 2000 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n/* Dynamic loading of C primitives. */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"caml/config.h\"\n#ifdef HAS_UNISTD\n#include <unistd.h>\n#endif\n#include \"caml/alloc.h\"\n#include \"caml/dynlink.h\"\n#include \"caml/fail.h\"\n#include \"caml/mlvalues.h\"\n#include \"caml/memory.h\"\n#include \"caml/misc.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/prims.h\"\n#include \"caml/signals.h\"\n\n#ifndef NATIVE_CODE\n\n/* The table of primitives */\nstruct ext_table caml_prim_table;\n\n#ifdef DEBUG\n/* The names of primitives (for instrtrace.c) */\nstruct ext_table caml_prim_name_table;\n#endif\n\n/* The table of shared libraries currently opened */\nstatic struct ext_table shared_libs;\n\n/* The search path for shared libraries */\nstruct ext_table caml_shared_libs_path;\n\n/* Look up the given primitive name in the built-in primitive table,\n   then in the opened shared libraries (shared_libs) */\nstatic c_primitive lookup_primitive(char * name)\n{\n  int i;\n  void * res;\n\n  for (i = 0; caml_names_of_builtin_cprim[i] != NULL; i++) {\n    if (strcmp(name, caml_names_of_builtin_cprim[i]) == 0)\n      return caml_builtin_cprim[i];\n  }\n  for (i = 0; i < shared_libs.size; i++) {\n    res = caml_dlsym(shared_libs.contents[i], name);\n    if (res != NULL) return (c_primitive) res;\n  }\n  return NULL;\n}\n\n/* Parse the OCAML_STDLIB_DIR/ld.conf file and add the directories\n   listed there to the search path */\n\n#define LD_CONF_NAME \"ld.conf\"\n\nstatic char * parse_ld_conf(void)\n{\n  char * stdlib, * ldconfname, * config, * p, * q;\n  struct stat st;\n  int ldconf, nread;\n\n  stdlib = getenv(\"OCAMLLIB\");\n  if (stdlib == NULL) stdlib = getenv(\"CAMLLIB\");\n  if (stdlib == NULL) stdlib = OCAML_STDLIB_DIR;\n  ldconfname = caml_strconcat(3, stdlib, \"/\", LD_CONF_NAME);\n  if (stat(ldconfname, &st) == -1) {\n    caml_stat_free(ldconfname);\n    return NULL;\n  }\n  ldconf = open(ldconfname, O_RDONLY, 0);\n  if (ldconf == -1)\n    caml_fatal_error_arg(\"Fatal error: cannot read loader config file %s\\n\",\n                         ldconfname);\n  config = caml_stat_alloc(st.st_size + 1);\n  nread = read(ldconf, config, st.st_size);\n  if (nread == -1)\n    caml_fatal_error_arg\n      (\"Fatal error: error while reading loader config file %s\\n\",\n       ldconfname);\n  config[nread] = 0;\n  q = config;\n  for (p = config; *p != 0; p++) {\n    if (*p == '\\n') {\n      *p = 0;\n      caml_ext_table_add(&caml_shared_libs_path, q);\n      q = p + 1;\n    }\n  }\n  if (q < p) caml_ext_table_add(&caml_shared_libs_path, q);\n  close(ldconf);\n  caml_stat_free(ldconfname);\n  return config;\n}\n\n/* Open the given shared library and add it to shared_libs.\n   Abort on error. */\nstatic void open_shared_lib(char * name)\n{\n  char * realname;\n  void * handle;\n\n  realname = caml_search_dll_in_path(&caml_shared_libs_path, name);\n  caml_gc_message(0x100, \"Loading shared library %s\\n\",\n                  (uintnat) realname);\n  caml_enter_blocking_section();\n  handle = caml_dlopen(realname, 1, 1);\n  caml_leave_blocking_section();\n  if (handle == NULL)\n    caml_fatal_error_arg2(\"Fatal error: cannot load shared library %s\\n\", name,\n                          \"Reason: %s\\n\", caml_dlerror());\n  caml_ext_table_add(&shared_libs, handle);\n  caml_stat_free(realname);\n}\n\n/* Build the table of primitives, given a search path and a list\n   of shared libraries (both 0-separated in a char array).\n   Abort the runtime system on error. */\nvoid caml_build_primitive_table(char * lib_path,\n                                char * libs,\n                                char * req_prims)\n{\n  char * tofree1, * tofree2;\n  char * p;\n\n  /* Initialize the search path for dynamic libraries:\n     - directories specified on the command line with the -I option\n     - directories specified in the CAML_LD_LIBRARY_PATH\n     - directories specified in the executable\n     - directories specified in the file <stdlib>/ld.conf */\n  tofree1 = caml_decompose_path(&caml_shared_libs_path,\n                                getenv(\"CAML_LD_LIBRARY_PATH\"));\n  if (lib_path != NULL)\n    for (p = lib_path; *p != 0; p += strlen(p) + 1)\n      caml_ext_table_add(&caml_shared_libs_path, p);\n  tofree2 = parse_ld_conf();\n  /* Open the shared libraries */\n  caml_ext_table_init(&shared_libs, 8);\n  if (libs != NULL)\n    for (p = libs; *p != 0; p += strlen(p) + 1)\n      open_shared_lib(p);\n  /* Build the primitive table */\n  caml_ext_table_init(&caml_prim_table, 0x180);\n#ifdef DEBUG\n  caml_ext_table_init(&caml_prim_name_table, 0x180);\n#endif\n  for (p = req_prims; *p != 0; p += strlen(p) + 1) {\n    c_primitive prim = lookup_primitive(p);\n    if (prim == NULL)\n          caml_fatal_error_arg(\"Fatal error: unknown C primitive `%s'\\n\", p);\n    caml_ext_table_add(&caml_prim_table, (void *) prim);\n#ifdef DEBUG\n    caml_ext_table_add(&caml_prim_name_table, strdup(p));\n#endif\n  }\n  /* Clean up */\n  caml_stat_free(tofree1);\n  caml_stat_free(tofree2);\n  caml_ext_table_free(&caml_shared_libs_path, 0);\n}\n\n/* Build the table of primitives as a copy of the builtin primitive table.\n   Used for executables generated by ocamlc -output-obj. */\n\nvoid caml_build_primitive_table_builtin(void)\n{\n  int i;\n  caml_ext_table_init(&caml_prim_table, 0x180);\n#ifdef DEBUG\n  caml_ext_table_init(&caml_prim_name_table, 0x180);\n#endif\n  for (i = 0; caml_builtin_cprim[i] != 0; i++) {\n    caml_ext_table_add(&caml_prim_table, (void *) caml_builtin_cprim[i]);\n#ifdef DEBUG\n    caml_ext_table_add(&caml_prim_name_table,\n                       strdup(caml_names_of_builtin_cprim[i]));\n#endif\n  }\n}\n\n#endif /* NATIVE_CODE */\n\n/** dlopen interface for the bytecode linker **/\n\n#define Handle_val(v) (*((void **) (v)))\n\nCAMLprim value caml_dynlink_open_lib(value mode, value filename)\n{\n  void * handle;\n  value result;\n  char * p;\n\n  caml_gc_message(0x100, \"Opening shared library %s\\n\",\n                  (uintnat) String_val(filename));\n  p = caml_strdup(String_val(filename));\n  caml_enter_blocking_section();\n  handle = caml_dlopen(p, Int_val(mode), 1);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n  if (handle == NULL) caml_failwith(caml_dlerror());\n  result = caml_alloc_small(1, Abstract_tag);\n  Handle_val(result) = handle;\n  return result;\n}\n\nCAMLprim value caml_dynlink_close_lib(value handle)\n{\n  caml_dlclose(Handle_val(handle));\n  return Val_unit;\n}\n\n/*#include <stdio.h>*/\nCAMLprim value caml_dynlink_lookup_symbol(value handle, value symbolname)\n{\n  void * symb;\n  value result;\n  symb = caml_dlsym(Handle_val(handle), String_val(symbolname));\n  /* printf(\"%s = 0x%lx\\n\", String_val(symbolname), symb);\n     fflush(stdout); */\n  if (symb == NULL) return Val_unit /*caml_failwith(caml_dlerror())*/;\n  result = caml_alloc_small(1, Abstract_tag);\n  Handle_val(result) = symb;\n  return result;\n}\n\n#ifndef NATIVE_CODE\n\nCAMLprim value caml_dynlink_add_primitive(value handle)\n{\n  return Val_int(caml_ext_table_add(&caml_prim_table, Handle_val(handle)));\n}\n\nCAMLprim value caml_dynlink_get_current_libs(value unit)\n{\n  CAMLparam0();\n  CAMLlocal1(res);\n  int i;\n\n  res = caml_alloc_tuple(shared_libs.size);\n  for (i = 0; i < shared_libs.size; i++) {\n    value v = caml_alloc_small(1, Abstract_tag);\n    Handle_val(v) = shared_libs.contents[i];\n    Store_field(res, i, v);\n  }\n  CAMLreturn(res);\n}\n\n#else\n\nvalue caml_dynlink_add_primitive(value handle)\n{\n  caml_invalid_argument(\"dynlink_add_primitive\");\n  return Val_unit; /* not reached */\n}\n\nvalue caml_dynlink_get_current_libs(value unit)\n{\n  caml_invalid_argument(\"dynlink_get_current_libs\");\n  return Val_unit; /* not reached */\n}\n\n#endif /* NATIVE_CODE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/byterun/caml/osdeps.h": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            */\n/*                                                                        */\n/*   Copyright 2001 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n/* Operating system - specific stuff */\n\n#ifndef CAML_OSDEPS_H\n#define CAML_OSDEPS_H\n\n#include \"misc.h\"\n\n/* Read at most [n] bytes from file descriptor [fd] into buffer [buf].\n   [flags] indicates whether [fd] is a socket\n   (bit [CHANNEL_FLAG_FROM_SOCKET] is set in this case, see [io.h]).\n   (This distinction matters for Win32, but not for Unix.)\n   Return number of bytes read.\n   In case of error, raises [Sys_error] or [Sys_blocked_io]. */\nextern int caml_read_fd(int fd, int flags, void * buf, int n);\n\n/* Write at most [n] bytes from buffer [buf] onto file descriptor [fd].\n   [flags] indicates whether [fd] is a socket\n   (bit [CHANNEL_FLAG_FROM_SOCKET] is set in this case, see [io.h]).\n   (This distinction matters for Win32, but not for Unix.)\n   Return number of bytes written.\n   In case of error, raises [Sys_error] or [Sys_blocked_io]. */\nextern int caml_write_fd(int fd, int flags, void * buf, int n);\n\n/* Decompose the given path into a list of directories, and add them\n   to the given table.  Return the block to be freed later. */\nextern char * caml_decompose_path(struct ext_table * tbl, char * path);\n\n/* Search the given file in the given list of directories.\n   If not found, return a copy of [name].  Result is allocated with\n   [caml_stat_alloc]. */\nextern char * caml_search_in_path(struct ext_table * path, char * name);\n\n/* Same, but search an executable name in the system path for executables. */\nCAMLextern char * caml_search_exe_in_path(char * name);\n\n/* Same, but search a shared library in the given path. */\nextern char * caml_search_dll_in_path(struct ext_table * path, char * name);\n\n/* Open a shared library and return a handle on it.\n   If [for_execution] is true, perform full symbol resolution and\n   execute initialization code so that functions from the shared library\n   can be called.  If [for_execution] is false, functions from this\n   shared library will not be called, but just checked for presence,\n   so symbol resolution can be skipped.\n   If [global] is true, symbols from the shared library can be used\n   to resolve for other libraries to be opened later on.\n   Return [NULL] on error. */\nextern void * caml_dlopen(char * libname, int for_execution, int global);\n\n/* Close a shared library handle */\nextern void caml_dlclose(void * handle);\n\n/* Look up the given symbol in the given shared library.\n   Return [NULL] if not found, or symbol value if found. */\nextern void * caml_dlsym(void * handle, char * name);\n\nextern void * caml_globalsym(char * name);\n\n/* Return an error message describing the most recent dynlink failure. */\nextern char * caml_dlerror(void);\n\n/* Add to [contents] the (short) names of the files contained in\n   the directory named [dirname].  No entries are added for [.] and [..].\n   Return 0 on success, -1 on error; set errno in the case of error. */\nextern int caml_read_directory(char * dirname, struct ext_table * contents);\n\n/* Recover executable name if possible (/proc/sef/exe under Linux,\n   GetModuleFileName under Windows). */\nextern int caml_executable_name(char * name, int name_len);\n\n#endif /* CAML_OSDEPS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/asmrun/natdynlink.c": "/**************************************************************************/\n/*                                                                        */\n/*                                 OCaml                                  */\n/*                                                                        */\n/*             Alain Frisch, projet Gallium, INRIA Rocquencourt           */\n/*                                                                        */\n/*   Copyright 2007 Institut National de Recherche en Informatique et     */\n/*     en Automatique.                                                    */\n/*                                                                        */\n/*   All rights reserved.  This file is distributed under the terms of    */\n/*   the GNU Lesser General Public License version 2.1, with the          */\n/*   special exception on linking described in the file LICENSE.          */\n/*                                                                        */\n/**************************************************************************/\n\n#include \"caml/misc.h\"\n#include \"caml/mlvalues.h\"\n#include \"caml/memory.h\"\n#include \"stack.h\"\n#include \"caml/callback.h\"\n#include \"caml/alloc.h\"\n#include \"caml/intext.h\"\n#include \"caml/osdeps.h\"\n#include \"caml/fail.h\"\n#include \"caml/signals.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic void *getsym(void *handle, char *module, char *name){\n  char *fullname = caml_strconcat(3, \"caml\", module, name);\n  void *sym;\n  sym = caml_dlsym (handle, fullname);\n  /*  printf(\"%s => %lx\\n\", fullname, (uintnat) sym); */\n  caml_stat_free(fullname);\n  return sym;\n}\n\nextern char caml_globals_map[];\n\nCAMLprim value caml_natdynlink_getmap(value unit)\n{\n  return (value)caml_globals_map;\n}\n\nCAMLprim value caml_natdynlink_globals_inited(value unit)\n{\n  return Val_int(caml_globals_inited);\n}\n\nCAMLprim value caml_natdynlink_open(value filename, value global)\n{\n  CAMLparam1 (filename);\n  CAMLlocal1 (res);\n  void *sym;\n  void *handle;\n  char *p;\n\n  /* TODO: dlclose in case of error... */\n\n  p = caml_strdup(String_val(filename));\n  caml_enter_blocking_section();\n  handle = caml_dlopen(p, 1, Int_val(global));\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  if (NULL == handle)\n    CAMLreturn(caml_copy_string(caml_dlerror()));\n\n  sym = caml_dlsym(handle, \"caml_plugin_header\");\n  if (NULL == sym)\n    CAMLreturn(caml_copy_string(\"not an OCaml plugin\"));\n\n  res = caml_alloc_tuple(2);\n  Field(res, 0) = (value) handle;\n  Field(res, 1) = (value) (sym);\n  CAMLreturn(res);\n}\n\nCAMLprim value caml_natdynlink_run(void *handle, value symbol) {\n  CAMLparam1 (symbol);\n  CAMLlocal1 (result);\n  void *sym,*sym2;\n  struct code_fragment * cf;\n\n#define optsym(n) getsym(handle,unit,n)\n  char *unit;\n  void (*entrypoint)(void);\n\n  unit = String_val(symbol);\n\n  sym = optsym(\"__frametable\");\n  if (NULL != sym) caml_register_frametable(sym);\n\n  sym = optsym(\"__gc_roots\");\n  if (NULL != sym) caml_register_dyn_global(sym);\n\n  sym = optsym(\"__data_begin\");\n  sym2 = optsym(\"__data_end\");\n  if (NULL != sym && NULL != sym2)\n    caml_page_table_add(In_static_data, sym, sym2);\n\n  sym = optsym(\"__code_begin\");\n  sym2 = optsym(\"__code_end\");\n  if (NULL != sym && NULL != sym2) {\n    caml_page_table_add(In_code_area, sym, sym2);\n    cf = caml_stat_alloc(sizeof(struct code_fragment));\n    cf->code_start = (char *) sym;\n    cf->code_end = (char *) sym2;\n    cf->digest_computed = 0;\n    caml_ext_table_add(&caml_code_fragments_table, cf);\n  }\n\n  entrypoint = optsym(\"__entry\");\n  if (NULL != entrypoint) result = caml_callback((value)(&entrypoint), 0);\n  else result = Val_unit;\n\n#undef optsym\n\n  CAMLreturn (result);\n}\n\nCAMLprim value caml_natdynlink_run_toplevel(value filename, value symbol)\n{\n  CAMLparam2 (filename, symbol);\n  CAMLlocal2 (res, v);\n  void *handle;\n  char *p;\n\n  /* TODO: dlclose in case of error... */\n\n  p = caml_strdup(String_val(filename));\n  caml_enter_blocking_section();\n  handle = caml_dlopen(p, 1, 1);\n  caml_leave_blocking_section();\n  caml_stat_free(p);\n\n  if (NULL == handle) {\n    res = caml_alloc(1,1);\n    v = caml_copy_string(caml_dlerror());\n    Store_field(res, 0, v);\n  } else {\n    res = caml_alloc(1,0);\n    v = caml_natdynlink_run(handle, symbol);\n    Store_field(res, 0, v);\n  }\n  CAMLreturn(res);\n}\n\nCAMLprim value caml_natdynlink_loadsym(value symbol)\n{\n  CAMLparam1 (symbol);\n  CAMLlocal1 (sym);\n\n  sym = (value) caml_globalsym(String_val(symbol));\n  if (!sym) caml_failwith(String_val(symbol));\n  CAMLreturn(sym);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ocaml-4.03.0-ja2ayqkp66nbtroad5vutgixlorznxaj/spack-src/testsuite/tests/lib-str/t01.reference"
    ],
    "total_files": 2293
}