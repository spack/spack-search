{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/ispcrt/detail/cpu/CPUDevice.cpp": "// Copyright 2020 Intel Corporation\n// SPDX-License-Identifier: BSD-3-Clause\n\n#include \"CPUDevice.h\"\n\n#ifdef _WIN32\n#error \"Windows not yet supported!\"\n#else\n#include <dlfcn.h>\n#endif\n// std\n#include <cassert>\n#include <chrono>\n#include <exception>\n#include <string>\n\nnamespace ispcrt {\nnamespace cpu {\n\nstruct Future : public ispcrt::base::Future {\n    Future() = default;\n    virtual ~Future() = default;\n\n    bool valid() override { return m_valid; }\n    uint64_t time() override { return m_time; }\n\n    friend class TaskQueue;\n\n  private:\n    uint64_t m_time{0};\n    bool m_valid{false};\n};\n\nusing CPUKernelEntryPoint = void (*)(void *, size_t, size_t, size_t);\n\nstruct MemoryView : public ispcrt::base::MemoryView {\n    MemoryView(void *appMem, size_t numBytes) : m_mem(appMem), m_size(numBytes) {}\n\n    void *hostPtr() { return m_mem; };\n\n    void *devicePtr() { return m_mem; };\n\n    size_t numBytes() { return m_size; };\n\n  private:\n    void *m_mem{nullptr};\n    size_t m_size{0};\n};\n\nstruct Module : public ispcrt::base::Module {\n    Module(const char *moduleFile) : m_file(moduleFile) {\n        if (!m_file.empty()) {\n#if defined(__MACOSX__) || defined(__APPLE__)\n            std::string ext = \".dylib\";\n#else\n            std::string ext = \".so\";\n#endif\n            m_lib = dlopen((\"lib\" + m_file + ext).c_str(), RTLD_LAZY | RTLD_LOCAL);\n\n            if (!m_lib)\n                throw std::logic_error(\"could not open CPU shared module file\");\n        }\n    }\n\n    ~Module() {\n        if (m_lib)\n            dlclose(m_lib);\n    }\n\n    void *lib() const { return m_lib; }\n\n  private:\n    std::string m_file;\n    void *m_lib{nullptr};\n};\n\nstruct Kernel : public ispcrt::base::Kernel {\n    Kernel(const ispcrt::base::Module &_module, const char *_name) : m_fcnName(_name), m_module(&_module) {\n        const cpu::Module &module = (const cpu::Module &)_module;\n\n        auto name = std::string(_name) + \"_cpu_entry_point\";\n\n        void *fcn = dlsym(module.lib() ? module.lib() : RTLD_DEFAULT, name.c_str());\n\n        if (!fcn)\n            throw std::logic_error(\"could not find CPU kernel function\");\n\n        m_fcn = (CPUKernelEntryPoint)fcn;\n        m_module->refInc();\n    }\n\n    ~Kernel() {\n        if (m_module)\n            m_module->refDec();\n    }\n\n    CPUKernelEntryPoint entryPoint() const { return m_fcn; }\n\n  private:\n    std::string m_fcnName;\n    CPUKernelEntryPoint m_fcn{nullptr};\n\n    const ispcrt::base::Module *m_module{nullptr};\n};\n\nstruct TaskQueue : public ispcrt::base::TaskQueue {\n    TaskQueue() {\n        // no-op\n    }\n\n    void barrier() override {\n        // no-op\n    }\n\n    void copyToHost(ispcrt::base::MemoryView &) override {\n        // no-op\n    }\n\n    void copyToDevice(ispcrt::base::MemoryView &) override {\n        // no-op\n    }\n\n    ispcrt::base::Future *launch(ispcrt::base::Kernel &k, ispcrt::base::MemoryView *params, size_t dim0, size_t dim1,\n                                 size_t dim2) override {\n        auto &kernel = (cpu::Kernel &)k;\n        auto *parameters = (cpu::MemoryView *)params;\n\n        auto *fcn = kernel.entryPoint();\n\n        auto *future = new cpu::Future;\n        assert(future);\n\n        auto start = std::chrono::high_resolution_clock::now();\n        fcn(parameters ? parameters->devicePtr() : nullptr, dim0, dim1, dim2);\n        auto end = std::chrono::high_resolution_clock::now();\n\n        future->m_time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n        future->m_valid = true;\n\n        return future;\n    }\n\n    void sync() override {\n        // no-op\n    }\n};\n} // namespace cpu\n\nispcrt::base::MemoryView *CPUDevice::newMemoryView(void *appMem, size_t numBytes) const {\n    return new cpu::MemoryView(appMem, numBytes);\n}\n\nispcrt::base::TaskQueue *CPUDevice::newTaskQueue() const { return new cpu::TaskQueue(); }\n\nispcrt::base::Module *CPUDevice::newModule(const char *moduleFile) const { return new cpu::Module(moduleFile); }\n\nispcrt::base::Kernel *CPUDevice::newKernel(const ispcrt::base::Module &module, const char *name) const {\n    return new cpu::Kernel(module, name);\n}\n\n} // namespace ispcrt\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/src/ispc.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/deferred/data/pp1280x720.bin",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/deferred/data/pp1920x1200.bin",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/cornell.camera",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/teapot.camera",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/teapot.bvh",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/sponza.bvh",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/cornell.bvh",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/examples/rt/sponza.camera",
        "/tmp/vanessa/spack-stage/spack-stage-ispc-1.14.1-ch2y5p5i6x3hruizd3iycq2btxms25hs/spack-src/builtins/target-avx1-i64x4base.ll"
    ],
    "total_files": 1868
}